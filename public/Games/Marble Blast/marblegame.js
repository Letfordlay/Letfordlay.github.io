// Generated by Haxe 4.3.6
/* pako 1.0.4 nodeca/pako */
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,e.pako=t()}}(function(){return function t(e,a,i){function n(s,o){if(!a[s]){if(!e[s]){var l="function"==typeof require&&require;if(!o&&l)return l(s,!0);if(r)return r(s,!0);var h=new Error("Cannot find module '"+s+"'");throw h.code="MODULE_NOT_FOUND",h}var d=a[s]={exports:{}};e[s][0].call(d.exports,function(t){var a=e[s][1][t];return n(a?a:t)},d,d.exports,t,e,a,i)}return a[s].exports}for(var r="function"==typeof require&&require,s=0;s<i.length;s++)n(i[s]);return n}({1:[function(t,e,a){"use strict";function i(t){if(!(this instanceof i))return new i(t);this.options=l.assign({level:w,method:v,chunkSize:16384,windowBits:15,memLevel:8,strategy:p,to:""},t||{});var e=this.options;e.raw&&e.windowBits>0?e.windowBits=-e.windowBits:e.gzip&&e.windowBits>0&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new f,this.strm.avail_out=0;var a=o.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(a!==b)throw new Error(d[a]);if(e.header&&o.deflateSetHeader(this.strm,e.header),e.dictionary){var n;if(n="string"==typeof e.dictionary?h.string2buf(e.dictionary):"[object ArrayBuffer]"===_.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,a=o.deflateSetDictionary(this.strm,n),a!==b)throw new Error(d[a]);this._dict_set=!0}}function n(t,e){var a=new i(e);if(a.push(t,!0),a.err)throw a.msg||d[a.err];return a.result}function r(t,e){return e=e||{},e.raw=!0,n(t,e)}function s(t,e){return e=e||{},e.gzip=!0,n(t,e)}var o=t("./zlib/deflate"),l=t("./utils/common"),h=t("./utils/strings"),d=t("./zlib/messages"),f=t("./zlib/zstream"),_=Object.prototype.toString,u=0,c=4,b=0,g=1,m=2,w=-1,p=0,v=8;i.prototype.push=function(t,e){var a,i,n=this.strm,r=this.options.chunkSize;if(this.ended)return!1;i=e===~~e?e:e===!0?c:u,"string"==typeof t?n.input=h.string2buf(t):"[object ArrayBuffer]"===_.call(t)?n.input=new Uint8Array(t):n.input=t,n.next_in=0,n.avail_in=n.input.length;do{if(0===n.avail_out&&(n.output=new l.Buf8(r),n.next_out=0,n.avail_out=r),a=o.deflate(n,i),a!==g&&a!==b)return this.onEnd(a),this.ended=!0,!1;0!==n.avail_out&&(0!==n.avail_in||i!==c&&i!==m)||("string"===this.options.to?this.onData(h.buf2binstring(l.shrinkBuf(n.output,n.next_out))):this.onData(l.shrinkBuf(n.output,n.next_out)))}while((n.avail_in>0||0===n.avail_out)&&a!==g);return i===c?(a=o.deflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===b):i!==m||(this.onEnd(b),n.avail_out=0,!0)},i.prototype.onData=function(t){this.chunks.push(t)},i.prototype.onEnd=function(t){t===b&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=l.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},a.Deflate=i,a.deflate=n,a.deflateRaw=r,a.gzip=s},{"./utils/common":3,"./utils/strings":4,"./zlib/deflate":8,"./zlib/messages":13,"./zlib/zstream":15}],2:[function(t,e,a){"use strict";function i(t){if(!(this instanceof i))return new i(t);this.options=o.assign({chunkSize:16384,windowBits:0,to:""},t||{});var e=this.options;e.raw&&e.windowBits>=0&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(e.windowBits>=0&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),e.windowBits>15&&e.windowBits<48&&0===(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new f,this.strm.avail_out=0;var a=s.inflateInit2(this.strm,e.windowBits);if(a!==h.Z_OK)throw new Error(d[a]);this.header=new _,s.inflateGetHeader(this.strm,this.header)}function n(t,e){var a=new i(e);if(a.push(t,!0),a.err)throw a.msg||d[a.err];return a.result}function r(t,e){return e=e||{},e.raw=!0,n(t,e)}var s=t("./zlib/inflate"),o=t("./utils/common"),l=t("./utils/strings"),h=t("./zlib/constants"),d=t("./zlib/messages"),f=t("./zlib/zstream"),_=t("./zlib/gzheader"),u=Object.prototype.toString;i.prototype.push=function(t,e){var a,i,n,r,d,f,_=this.strm,c=this.options.chunkSize,b=this.options.dictionary,g=!1;if(this.ended)return!1;i=e===~~e?e:e===!0?h.Z_FINISH:h.Z_NO_FLUSH,"string"==typeof t?_.input=l.binstring2buf(t):"[object ArrayBuffer]"===u.call(t)?_.input=new Uint8Array(t):_.input=t,_.next_in=0,_.avail_in=_.input.length;do{if(0===_.avail_out&&(_.output=new o.Buf8(c),_.next_out=0,_.avail_out=c),a=s.inflate(_,h.Z_NO_FLUSH),a===h.Z_NEED_DICT&&b&&(f="string"==typeof b?l.string2buf(b):"[object ArrayBuffer]"===u.call(b)?new Uint8Array(b):b,a=s.inflateSetDictionary(this.strm,f)),a===h.Z_BUF_ERROR&&g===!0&&(a=h.Z_OK,g=!1),a!==h.Z_STREAM_END&&a!==h.Z_OK)return this.onEnd(a),this.ended=!0,!1;_.next_out&&(0!==_.avail_out&&a!==h.Z_STREAM_END&&(0!==_.avail_in||i!==h.Z_FINISH&&i!==h.Z_SYNC_FLUSH)||("string"===this.options.to?(n=l.utf8border(_.output,_.next_out),r=_.next_out-n,d=l.buf2string(_.output,n),_.next_out=r,_.avail_out=c-r,r&&o.arraySet(_.output,_.output,n,r,0),this.onData(d)):this.onData(o.shrinkBuf(_.output,_.next_out)))),0===_.avail_in&&0===_.avail_out&&(g=!0)}while((_.avail_in>0||0===_.avail_out)&&a!==h.Z_STREAM_END);return a===h.Z_STREAM_END&&(i=h.Z_FINISH),i===h.Z_FINISH?(a=s.inflateEnd(this.strm),this.onEnd(a),this.ended=!0,a===h.Z_OK):i!==h.Z_SYNC_FLUSH||(this.onEnd(h.Z_OK),_.avail_out=0,!0)},i.prototype.onData=function(t){this.chunks.push(t)},i.prototype.onEnd=function(t){t===h.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},a.Inflate=i,a.inflate=n,a.inflateRaw=r,a.ungzip=n},{"./utils/common":3,"./utils/strings":4,"./zlib/constants":6,"./zlib/gzheader":9,"./zlib/inflate":11,"./zlib/messages":13,"./zlib/zstream":15}],3:[function(t,e,a){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;a.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var a=e.shift();if(a){if("object"!=typeof a)throw new TypeError(a+"must be non-object");for(var i in a)a.hasOwnProperty(i)&&(t[i]=a[i])}}return t},a.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var n={arraySet:function(t,e,a,i,n){if(e.subarray&&t.subarray)return void t.set(e.subarray(a,a+i),n);for(var r=0;r<i;r++)t[n+r]=e[a+r]},flattenChunks:function(t){var e,a,i,n,r,s;for(i=0,e=0,a=t.length;e<a;e++)i+=t[e].length;for(s=new Uint8Array(i),n=0,e=0,a=t.length;e<a;e++)r=t[e],s.set(r,n),n+=r.length;return s}},r={arraySet:function(t,e,a,i,n){for(var r=0;r<i;r++)t[n+r]=e[a+r]},flattenChunks:function(t){return[].concat.apply([],t)}};a.setTyped=function(t){t?(a.Buf8=Uint8Array,a.Buf16=Uint16Array,a.Buf32=Int32Array,a.assign(a,n)):(a.Buf8=Array,a.Buf16=Array,a.Buf32=Array,a.assign(a,r))},a.setTyped(i)},{}],4:[function(t,e,a){"use strict";function i(t,e){if(e<65537&&(t.subarray&&s||!t.subarray&&r))return String.fromCharCode.apply(null,n.shrinkBuf(t,e));for(var a="",i=0;i<e;i++)a+=String.fromCharCode(t[i]);return a}var n=t("./common"),r=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(t){r=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){s=!1}for(var o=new n.Buf8(256),l=0;l<256;l++)o[l]=l>=252?6:l>=248?5:l>=240?4:l>=224?3:l>=192?2:1;o[254]=o[254]=1,a.string2buf=function(t){var e,a,i,r,s,o=t.length,l=0;for(r=0;r<o;r++)a=t.charCodeAt(r),55296===(64512&a)&&r+1<o&&(i=t.charCodeAt(r+1),56320===(64512&i)&&(a=65536+(a-55296<<10)+(i-56320),r++)),l+=a<128?1:a<2048?2:a<65536?3:4;for(e=new n.Buf8(l),s=0,r=0;s<l;r++)a=t.charCodeAt(r),55296===(64512&a)&&r+1<o&&(i=t.charCodeAt(r+1),56320===(64512&i)&&(a=65536+(a-55296<<10)+(i-56320),r++)),a<128?e[s++]=a:a<2048?(e[s++]=192|a>>>6,e[s++]=128|63&a):a<65536?(e[s++]=224|a>>>12,e[s++]=128|a>>>6&63,e[s++]=128|63&a):(e[s++]=240|a>>>18,e[s++]=128|a>>>12&63,e[s++]=128|a>>>6&63,e[s++]=128|63&a);return e},a.buf2binstring=function(t){return i(t,t.length)},a.binstring2buf=function(t){for(var e=new n.Buf8(t.length),a=0,i=e.length;a<i;a++)e[a]=t.charCodeAt(a);return e},a.buf2string=function(t,e){var a,n,r,s,l=e||t.length,h=new Array(2*l);for(n=0,a=0;a<l;)if(r=t[a++],r<128)h[n++]=r;else if(s=o[r],s>4)h[n++]=65533,a+=s-1;else{for(r&=2===s?31:3===s?15:7;s>1&&a<l;)r=r<<6|63&t[a++],s--;s>1?h[n++]=65533:r<65536?h[n++]=r:(r-=65536,h[n++]=55296|r>>10&1023,h[n++]=56320|1023&r)}return i(h,n)},a.utf8border=function(t,e){var a;for(e=e||t.length,e>t.length&&(e=t.length),a=e-1;a>=0&&128===(192&t[a]);)a--;return a<0?e:0===a?e:a+o[t[a]]>e?a:e}},{"./common":3}],5:[function(t,e,a){"use strict";function i(t,e,a,i){for(var n=65535&t|0,r=t>>>16&65535|0,s=0;0!==a;){s=a>2e3?2e3:a,a-=s;do n=n+e[i++]|0,r=r+n|0;while(--s);n%=65521,r%=65521}return n|r<<16|0}e.exports=i},{}],6:[function(t,e,a){"use strict";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],7:[function(t,e,a){"use strict";function i(){for(var t,e=[],a=0;a<256;a++){t=a;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[a]=t}return e}function n(t,e,a,i){var n=r,s=i+a;t^=-1;for(var o=i;o<s;o++)t=t>>>8^n[255&(t^e[o])];return t^-1}var r=i();e.exports=n},{}],8:[function(t,e,a){"use strict";function i(t,e){return t.msg=D[e],e}function n(t){return(t<<1)-(t>4?9:0)}function r(t){for(var e=t.length;--e>=0;)t[e]=0}function s(t){var e=t.state,a=e.pending;a>t.avail_out&&(a=t.avail_out),0!==a&&(R.arraySet(t.output,e.pending_buf,e.pending_out,a,t.next_out),t.next_out+=a,e.pending_out+=a,t.total_out+=a,t.avail_out-=a,e.pending-=a,0===e.pending&&(e.pending_out=0))}function o(t,e){C._tr_flush_block(t,t.block_start>=0?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,s(t.strm)}function l(t,e){t.pending_buf[t.pending++]=e}function h(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function d(t,e,a,i){var n=t.avail_in;return n>i&&(n=i),0===n?0:(t.avail_in-=n,R.arraySet(e,t.input,t.next_in,n,a),1===t.state.wrap?t.adler=N(t.adler,e,n,a):2===t.state.wrap&&(t.adler=O(t.adler,e,n,a)),t.next_in+=n,t.total_in+=n,n)}function f(t,e){var a,i,n=t.max_chain_length,r=t.strstart,s=t.prev_length,o=t.nice_match,l=t.strstart>t.w_size-ft?t.strstart-(t.w_size-ft):0,h=t.window,d=t.w_mask,f=t.prev,_=t.strstart+dt,u=h[r+s-1],c=h[r+s];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do if(a=e,h[a+s]===c&&h[a+s-1]===u&&h[a]===h[r]&&h[++a]===h[r+1]){r+=2,a++;do;while(h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&h[++r]===h[++a]&&r<_);if(i=dt-(_-r),r=_-dt,i>s){if(t.match_start=e,s=i,i>=o)break;u=h[r+s-1],c=h[r+s]}}while((e=f[e&d])>l&&0!==--n);return s<=t.lookahead?s:t.lookahead}function _(t){var e,a,i,n,r,s=t.w_size;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=s+(s-ft)){R.arraySet(t.window,t.window,s,s,0),t.match_start-=s,t.strstart-=s,t.block_start-=s,a=t.hash_size,e=a;do i=t.head[--e],t.head[e]=i>=s?i-s:0;while(--a);a=s,e=a;do i=t.prev[--e],t.prev[e]=i>=s?i-s:0;while(--a);n+=s}if(0===t.strm.avail_in)break;if(a=d(t.strm,t.window,t.strstart+t.lookahead,n),t.lookahead+=a,t.lookahead+t.insert>=ht)for(r=t.strstart-t.insert,t.ins_h=t.window[r],t.ins_h=(t.ins_h<<t.hash_shift^t.window[r+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[r+ht-1])&t.hash_mask,t.prev[r&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=r,r++,t.insert--,!(t.lookahead+t.insert<ht)););}while(t.lookahead<ft&&0!==t.strm.avail_in)}function u(t,e){var a=65535;for(a>t.pending_buf_size-5&&(a=t.pending_buf_size-5);;){if(t.lookahead<=1){if(_(t),0===t.lookahead&&e===I)return vt;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+a;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,o(t,!1),0===t.strm.avail_out))return vt;if(t.strstart-t.block_start>=t.w_size-ft&&(o(t,!1),0===t.strm.avail_out))return vt}return t.insert=0,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.strstart>t.block_start&&(o(t,!1),0===t.strm.avail_out)?vt:vt}function c(t,e){for(var a,i;;){if(t.lookahead<ft){if(_(t),t.lookahead<ft&&e===I)return vt;if(0===t.lookahead)break}if(a=0,t.lookahead>=ht&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+ht-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==a&&t.strstart-a<=t.w_size-ft&&(t.match_length=f(t,a)),t.match_length>=ht)if(i=C._tr_tally(t,t.strstart-t.match_start,t.match_length-ht),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=ht){t.match_length--;do t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+ht-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart;while(0!==--t.match_length);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=C._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(o(t,!1),0===t.strm.avail_out))return vt}return t.insert=t.strstart<ht-1?t.strstart:ht-1,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?vt:kt}function b(t,e){for(var a,i,n;;){if(t.lookahead<ft){if(_(t),t.lookahead<ft&&e===I)return vt;if(0===t.lookahead)break}if(a=0,t.lookahead>=ht&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+ht-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=ht-1,0!==a&&t.prev_length<t.max_lazy_match&&t.strstart-a<=t.w_size-ft&&(t.match_length=f(t,a),t.match_length<=5&&(t.strategy===q||t.match_length===ht&&t.strstart-t.match_start>4096)&&(t.match_length=ht-1)),t.prev_length>=ht&&t.match_length<=t.prev_length){n=t.strstart+t.lookahead-ht,i=C._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-ht),t.lookahead-=t.prev_length-1,t.prev_length-=2;do++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+ht-1])&t.hash_mask,a=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart);while(0!==--t.prev_length);if(t.match_available=0,t.match_length=ht-1,t.strstart++,i&&(o(t,!1),0===t.strm.avail_out))return vt}else if(t.match_available){if(i=C._tr_tally(t,0,t.window[t.strstart-1]),i&&o(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return vt}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=C._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<ht-1?t.strstart:ht-1,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?vt:kt}function g(t,e){for(var a,i,n,r,s=t.window;;){if(t.lookahead<=dt){if(_(t),t.lookahead<=dt&&e===I)return vt;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=ht&&t.strstart>0&&(n=t.strstart-1,i=s[n],i===s[++n]&&i===s[++n]&&i===s[++n])){r=t.strstart+dt;do;while(i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&i===s[++n]&&n<r);t.match_length=dt-(r-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=ht?(a=C._tr_tally(t,1,t.match_length-ht),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(a=C._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),a&&(o(t,!1),0===t.strm.avail_out))return vt}return t.insert=0,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?vt:kt}function m(t,e){for(var a;;){if(0===t.lookahead&&(_(t),0===t.lookahead)){if(e===I)return vt;break}if(t.match_length=0,a=C._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,a&&(o(t,!1),0===t.strm.avail_out))return vt}return t.insert=0,e===F?(o(t,!0),0===t.strm.avail_out?yt:xt):t.last_lit&&(o(t,!1),0===t.strm.avail_out)?vt:kt}function w(t,e,a,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=a,this.max_chain=i,this.func=n}function p(t){t.window_size=2*t.w_size,r(t.head),t.max_lazy_match=Z[t.level].max_lazy,t.good_match=Z[t.level].good_length,t.nice_match=Z[t.level].nice_length,t.max_chain_length=Z[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=ht-1,t.match_available=0,t.ins_h=0}function v(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=V,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new R.Buf16(2*ot),this.dyn_dtree=new R.Buf16(2*(2*rt+1)),this.bl_tree=new R.Buf16(2*(2*st+1)),r(this.dyn_ltree),r(this.dyn_dtree),r(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new R.Buf16(lt+1),this.heap=new R.Buf16(2*nt+1),r(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new R.Buf16(2*nt+1),r(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function k(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=Q,e=t.state,e.pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?ut:wt,t.adler=2===e.wrap?0:1,e.last_flush=I,C._tr_init(e),H):i(t,K)}function y(t){var e=k(t);return e===H&&p(t.state),e}function x(t,e){return t&&t.state?2!==t.state.wrap?K:(t.state.gzhead=e,H):K}function z(t,e,a,n,r,s){if(!t)return K;var o=1;if(e===Y&&(e=6),n<0?(o=0,n=-n):n>15&&(o=2,n-=16),r<1||r>$||a!==V||n<8||n>15||e<0||e>9||s<0||s>W)return i(t,K);8===n&&(n=9);var l=new v;return t.state=l,l.strm=t,l.wrap=o,l.gzhead=null,l.w_bits=n,l.w_size=1<<l.w_bits,l.w_mask=l.w_size-1,l.hash_bits=r+7,l.hash_size=1<<l.hash_bits,l.hash_mask=l.hash_size-1,l.hash_shift=~~((l.hash_bits+ht-1)/ht),l.window=new R.Buf8(2*l.w_size),l.head=new R.Buf16(l.hash_size),l.prev=new R.Buf16(l.w_size),l.lit_bufsize=1<<r+6,l.pending_buf_size=4*l.lit_bufsize,l.pending_buf=new R.Buf8(l.pending_buf_size),l.d_buf=1*l.lit_bufsize,l.l_buf=3*l.lit_bufsize,l.level=e,l.strategy=s,l.method=a,y(t)}function B(t,e){return z(t,e,V,tt,et,J)}function S(t,e){var a,o,d,f;if(!t||!t.state||e>L||e<0)return t?i(t,K):K;if(o=t.state,!t.output||!t.input&&0!==t.avail_in||o.status===pt&&e!==F)return i(t,0===t.avail_out?P:K);if(o.strm=t,a=o.last_flush,o.last_flush=e,o.status===ut)if(2===o.wrap)t.adler=0,l(o,31),l(o,139),l(o,8),o.gzhead?(l(o,(o.gzhead.text?1:0)+(o.gzhead.hcrc?2:0)+(o.gzhead.extra?4:0)+(o.gzhead.name?8:0)+(o.gzhead.comment?16:0)),l(o,255&o.gzhead.time),l(o,o.gzhead.time>>8&255),l(o,o.gzhead.time>>16&255),l(o,o.gzhead.time>>24&255),l(o,9===o.level?2:o.strategy>=G||o.level<2?4:0),l(o,255&o.gzhead.os),o.gzhead.extra&&o.gzhead.extra.length&&(l(o,255&o.gzhead.extra.length),l(o,o.gzhead.extra.length>>8&255)),o.gzhead.hcrc&&(t.adler=O(t.adler,o.pending_buf,o.pending,0)),o.gzindex=0,o.status=ct):(l(o,0),l(o,0),l(o,0),l(o,0),l(o,0),l(o,9===o.level?2:o.strategy>=G||o.level<2?4:0),l(o,zt),o.status=wt);else{var _=V+(o.w_bits-8<<4)<<8,u=-1;u=o.strategy>=G||o.level<2?0:o.level<6?1:6===o.level?2:3,_|=u<<6,0!==o.strstart&&(_|=_t),_+=31-_%31,o.status=wt,h(o,_),0!==o.strstart&&(h(o,t.adler>>>16),h(o,65535&t.adler)),t.adler=1}if(o.status===ct)if(o.gzhead.extra){for(d=o.pending;o.gzindex<(65535&o.gzhead.extra.length)&&(o.pending!==o.pending_buf_size||(o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),s(t),d=o.pending,o.pending!==o.pending_buf_size));)l(o,255&o.gzhead.extra[o.gzindex]),o.gzindex++;o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),o.gzindex===o.gzhead.extra.length&&(o.gzindex=0,o.status=bt)}else o.status=bt;if(o.status===bt)if(o.gzhead.name){d=o.pending;do{if(o.pending===o.pending_buf_size&&(o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),s(t),d=o.pending,o.pending===o.pending_buf_size)){f=1;break}f=o.gzindex<o.gzhead.name.length?255&o.gzhead.name.charCodeAt(o.gzindex++):0,l(o,f)}while(0!==f);o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),0===f&&(o.gzindex=0,o.status=gt)}else o.status=gt;if(o.status===gt)if(o.gzhead.comment){d=o.pending;do{if(o.pending===o.pending_buf_size&&(o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),s(t),d=o.pending,o.pending===o.pending_buf_size)){f=1;break}f=o.gzindex<o.gzhead.comment.length?255&o.gzhead.comment.charCodeAt(o.gzindex++):0,l(o,f)}while(0!==f);o.gzhead.hcrc&&o.pending>d&&(t.adler=O(t.adler,o.pending_buf,o.pending-d,d)),0===f&&(o.status=mt)}else o.status=mt;if(o.status===mt&&(o.gzhead.hcrc?(o.pending+2>o.pending_buf_size&&s(t),o.pending+2<=o.pending_buf_size&&(l(o,255&t.adler),l(o,t.adler>>8&255),t.adler=0,o.status=wt)):o.status=wt),0!==o.pending){if(s(t),0===t.avail_out)return o.last_flush=-1,H}else if(0===t.avail_in&&n(e)<=n(a)&&e!==F)return i(t,P);if(o.status===pt&&0!==t.avail_in)return i(t,P);if(0!==t.avail_in||0!==o.lookahead||e!==I&&o.status!==pt){var c=o.strategy===G?m(o,e):o.strategy===X?g(o,e):Z[o.level].func(o,e);if(c!==yt&&c!==xt||(o.status=pt),c===vt||c===yt)return 0===t.avail_out&&(o.last_flush=-1),H;if(c===kt&&(e===U?C._tr_align(o):e!==L&&(C._tr_stored_block(o,0,0,!1),e===T&&(r(o.head),0===o.lookahead&&(o.strstart=0,o.block_start=0,o.insert=0))),s(t),0===t.avail_out))return o.last_flush=-1,H}return e!==F?H:o.wrap<=0?j:(2===o.wrap?(l(o,255&t.adler),l(o,t.adler>>8&255),l(o,t.adler>>16&255),l(o,t.adler>>24&255),l(o,255&t.total_in),l(o,t.total_in>>8&255),l(o,t.total_in>>16&255),l(o,t.total_in>>24&255)):(h(o,t.adler>>>16),h(o,65535&t.adler)),s(t),o.wrap>0&&(o.wrap=-o.wrap),0!==o.pending?H:j)}function E(t){var e;return t&&t.state?(e=t.state.status,e!==ut&&e!==ct&&e!==bt&&e!==gt&&e!==mt&&e!==wt&&e!==pt?i(t,K):(t.state=null,e===wt?i(t,M):H)):K}function A(t,e){var a,i,n,s,o,l,h,d,f=e.length;if(!t||!t.state)return K;if(a=t.state,s=a.wrap,2===s||1===s&&a.status!==ut||a.lookahead)return K;for(1===s&&(t.adler=N(t.adler,e,f,0)),a.wrap=0,f>=a.w_size&&(0===s&&(r(a.head),a.strstart=0,a.block_start=0,a.insert=0),d=new R.Buf8(a.w_size),R.arraySet(d,e,f-a.w_size,a.w_size,0),e=d,f=a.w_size),o=t.avail_in,l=t.next_in,h=t.input,t.avail_in=f,t.next_in=0,t.input=e,_(a);a.lookahead>=ht;){i=a.strstart,n=a.lookahead-(ht-1);do a.ins_h=(a.ins_h<<a.hash_shift^a.window[i+ht-1])&a.hash_mask,a.prev[i&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=i,i++;while(--n);a.strstart=i,a.lookahead=ht-1,_(a)}return a.strstart+=a.lookahead,a.block_start=a.strstart,a.insert=a.lookahead,a.lookahead=0,a.match_length=a.prev_length=ht-1,a.match_available=0,t.next_in=l,t.input=h,t.avail_in=o,a.wrap=s,H}var Z,R=t("../utils/common"),C=t("./trees"),N=t("./adler32"),O=t("./crc32"),D=t("./messages"),I=0,U=1,T=3,F=4,L=5,H=0,j=1,K=-2,M=-3,P=-5,Y=-1,q=1,G=2,X=3,W=4,J=0,Q=2,V=8,$=9,tt=15,et=8,at=29,it=256,nt=it+1+at,rt=30,st=19,ot=2*nt+1,lt=15,ht=3,dt=258,ft=dt+ht+1,_t=32,ut=42,ct=69,bt=73,gt=91,mt=103,wt=113,pt=666,vt=1,kt=2,yt=3,xt=4,zt=3;Z=[new w(0,0,0,0,u),new w(4,4,8,4,c),new w(4,5,16,8,c),new w(4,6,32,32,c),new w(4,4,16,16,b),new w(8,16,32,32,b),new w(8,16,128,128,b),new w(8,32,128,256,b),new w(32,128,258,1024,b),new w(32,258,258,4096,b)],a.deflateInit=B,a.deflateInit2=z,a.deflateReset=y,a.deflateResetKeep=k,a.deflateSetHeader=x,a.deflate=S,a.deflateEnd=E,a.deflateSetDictionary=A,a.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":3,"./adler32":5,"./crc32":7,"./messages":13,"./trees":14}],9:[function(t,e,a){"use strict";function i(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}e.exports=i},{}],10:[function(t,e,a){"use strict";var i=30,n=12;e.exports=function(t,e){var a,r,s,o,l,h,d,f,_,u,c,b,g,m,w,p,v,k,y,x,z,B,S,E,A;a=t.state,r=t.next_in,E=t.input,s=r+(t.avail_in-5),o=t.next_out,A=t.output,l=o-(e-t.avail_out),h=o+(t.avail_out-257),d=a.dmax,f=a.wsize,_=a.whave,u=a.wnext,c=a.window,b=a.hold,g=a.bits,m=a.lencode,w=a.distcode,p=(1<<a.lenbits)-1,v=(1<<a.distbits)-1;t:do{g<15&&(b+=E[r++]<<g,g+=8,b+=E[r++]<<g,g+=8),k=m[b&p];e:for(;;){if(y=k>>>24,b>>>=y,g-=y,y=k>>>16&255,0===y)A[o++]=65535&k;else{if(!(16&y)){if(0===(64&y)){k=m[(65535&k)+(b&(1<<y)-1)];continue e}if(32&y){a.mode=n;break t}t.msg="invalid literal/length code",a.mode=i;break t}x=65535&k,y&=15,y&&(g<y&&(b+=E[r++]<<g,g+=8),x+=b&(1<<y)-1,b>>>=y,g-=y),g<15&&(b+=E[r++]<<g,g+=8,b+=E[r++]<<g,g+=8),k=w[b&v];a:for(;;){if(y=k>>>24,b>>>=y,g-=y,y=k>>>16&255,!(16&y)){if(0===(64&y)){k=w[(65535&k)+(b&(1<<y)-1)];continue a}t.msg="invalid distance code",a.mode=i;break t}if(z=65535&k,y&=15,g<y&&(b+=E[r++]<<g,g+=8,g<y&&(b+=E[r++]<<g,g+=8)),z+=b&(1<<y)-1,z>d){t.msg="invalid distance too far back",a.mode=i;break t}if(b>>>=y,g-=y,y=o-l,z>y){if(y=z-y,y>_&&a.sane){t.msg="invalid distance too far back",a.mode=i;break t}if(B=0,S=c,0===u){if(B+=f-y,y<x){x-=y;do A[o++]=c[B++];while(--y);B=o-z,S=A}}else if(u<y){if(B+=f+u-y,y-=u,y<x){x-=y;do A[o++]=c[B++];while(--y);if(B=0,u<x){y=u,x-=y;do A[o++]=c[B++];while(--y);B=o-z,S=A}}}else if(B+=u-y,y<x){x-=y;do A[o++]=c[B++];while(--y);B=o-z,S=A}for(;x>2;)A[o++]=S[B++],A[o++]=S[B++],A[o++]=S[B++],x-=3;x&&(A[o++]=S[B++],x>1&&(A[o++]=S[B++]))}else{B=o-z;do A[o++]=A[B++],A[o++]=A[B++],A[o++]=A[B++],x-=3;while(x>2);x&&(A[o++]=A[B++],x>1&&(A[o++]=A[B++]))}break}}break}}while(r<s&&o<h);x=g>>3,r-=x,g-=x<<3,b&=(1<<g)-1,t.next_in=r,t.next_out=o,t.avail_in=r<s?5+(s-r):5-(r-s),t.avail_out=o<h?257+(h-o):257-(o-h),a.hold=b,a.bits=g}},{}],11:[function(t,e,a){"use strict";function i(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function n(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new w.Buf16(320),this.work=new w.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function r(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=T,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new w.Buf32(bt),e.distcode=e.distdyn=new w.Buf32(gt),e.sane=1,e.back=-1,Z):N}function s(t){var e;return t&&t.state?(e=t.state,e.wsize=0,e.whave=0,e.wnext=0,r(t)):N}function o(t,e){var a,i;return t&&t.state?(i=t.state,e<0?(a=0,e=-e):(a=(e>>4)+1,e<48&&(e&=15)),e&&(e<8||e>15)?N:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=a,i.wbits=e,s(t))):N}function l(t,e){var a,i;return t?(i=new n,t.state=i,i.window=null,a=o(t,e),a!==Z&&(t.state=null),a):N}function h(t){return l(t,wt)}function d(t){if(pt){var e;for(g=new w.Buf32(512),m=new w.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(y(z,t.lens,0,288,g,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;y(B,t.lens,0,32,m,0,t.work,{bits:5}),pt=!1}t.lencode=g,t.lenbits=9,t.distcode=m,t.distbits=5}function f(t,e,a,i){var n,r=t.state;return null===r.window&&(r.wsize=1<<r.wbits,r.wnext=0,r.whave=0,r.window=new w.Buf8(r.wsize)),i>=r.wsize?(w.arraySet(r.window,e,a-r.wsize,r.wsize,0),r.wnext=0,r.whave=r.wsize):(n=r.wsize-r.wnext,n>i&&(n=i),w.arraySet(r.window,e,a-i,n,r.wnext),i-=n,i?(w.arraySet(r.window,e,a-i,i,0),r.wnext=i,r.whave=r.wsize):(r.wnext+=n,r.wnext===r.wsize&&(r.wnext=0),r.whave<r.wsize&&(r.whave+=n))),0}function _(t,e){var a,n,r,s,o,l,h,_,u,c,b,g,m,bt,gt,mt,wt,pt,vt,kt,yt,xt,zt,Bt,St=0,Et=new w.Buf8(4),At=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return N;a=t.state,a.mode===X&&(a.mode=W),o=t.next_out,r=t.output,h=t.avail_out,s=t.next_in,n=t.input,l=t.avail_in,_=a.hold,u=a.bits,c=l,b=h,xt=Z;t:for(;;)switch(a.mode){case T:if(0===a.wrap){a.mode=W;break}for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(2&a.wrap&&35615===_){a.check=0,Et[0]=255&_,Et[1]=_>>>8&255,a.check=v(a.check,Et,2,0),_=0,u=0,a.mode=F;break}if(a.flags=0,a.head&&(a.head.done=!1),!(1&a.wrap)||(((255&_)<<8)+(_>>8))%31){t.msg="incorrect header check",a.mode=_t;break}if((15&_)!==U){t.msg="unknown compression method",a.mode=_t;break}if(_>>>=4,u-=4,yt=(15&_)+8,0===a.wbits)a.wbits=yt;else if(yt>a.wbits){t.msg="invalid window size",a.mode=_t;break}a.dmax=1<<yt,t.adler=a.check=1,a.mode=512&_?q:X,_=0,u=0;break;case F:for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(a.flags=_,(255&a.flags)!==U){t.msg="unknown compression method",a.mode=_t;break}if(57344&a.flags){t.msg="unknown header flags set",a.mode=_t;break}a.head&&(a.head.text=_>>8&1),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,a.check=v(a.check,Et,2,0)),_=0,u=0,a.mode=L;case L:for(;u<32;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.head&&(a.head.time=_),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,Et[2]=_>>>16&255,Et[3]=_>>>24&255,a.check=v(a.check,Et,4,0)),_=0,u=0,a.mode=H;case H:for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.head&&(a.head.xflags=255&_,a.head.os=_>>8),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,a.check=v(a.check,Et,2,0)),_=0,u=0,a.mode=j;case j:if(1024&a.flags){for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.length=_,a.head&&(a.head.extra_len=_),512&a.flags&&(Et[0]=255&_,Et[1]=_>>>8&255,a.check=v(a.check,Et,2,0)),_=0,u=0}else a.head&&(a.head.extra=null);a.mode=K;case K:if(1024&a.flags&&(g=a.length,g>l&&(g=l),g&&(a.head&&(yt=a.head.extra_len-a.length,a.head.extra||(a.head.extra=new Array(a.head.extra_len)),w.arraySet(a.head.extra,n,s,g,yt)),512&a.flags&&(a.check=v(a.check,n,g,s)),l-=g,s+=g,a.length-=g),a.length))break t;a.length=0,a.mode=M;case M:if(2048&a.flags){if(0===l)break t;g=0;do yt=n[s+g++],a.head&&yt&&a.length<65536&&(a.head.name+=String.fromCharCode(yt));while(yt&&g<l);if(512&a.flags&&(a.check=v(a.check,n,g,s)),l-=g,s+=g,yt)break t}else a.head&&(a.head.name=null);a.length=0,a.mode=P;case P:if(4096&a.flags){if(0===l)break t;g=0;do yt=n[s+g++],a.head&&yt&&a.length<65536&&(a.head.comment+=String.fromCharCode(yt));while(yt&&g<l);if(512&a.flags&&(a.check=v(a.check,n,g,s)),l-=g,s+=g,yt)break t}else a.head&&(a.head.comment=null);a.mode=Y;case Y:if(512&a.flags){for(;u<16;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(_!==(65535&a.check)){t.msg="header crc mismatch",a.mode=_t;break}_=0,u=0}a.head&&(a.head.hcrc=a.flags>>9&1,a.head.done=!0),t.adler=a.check=0,a.mode=X;break;case q:for(;u<32;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}t.adler=a.check=i(_),_=0,u=0,a.mode=G;case G:if(0===a.havedict)return t.next_out=o,t.avail_out=h,t.next_in=s,t.avail_in=l,a.hold=_,a.bits=u,C;t.adler=a.check=1,a.mode=X;case X:if(e===E||e===A)break t;case W:if(a.last){_>>>=7&u,u-=7&u,a.mode=ht;break}for(;u<3;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}switch(a.last=1&_,_>>>=1,u-=1,3&_){case 0:a.mode=J;break;case 1:if(d(a),a.mode=at,e===A){_>>>=2,u-=2;break t}break;case 2:a.mode=$;break;case 3:t.msg="invalid block type",a.mode=_t}_>>>=2,u-=2;break;case J:for(_>>>=7&u,u-=7&u;u<32;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if((65535&_)!==(_>>>16^65535)){t.msg="invalid stored block lengths",a.mode=_t;break}if(a.length=65535&_,_=0,u=0,a.mode=Q,e===A)break t;case Q:a.mode=V;case V:if(g=a.length){if(g>l&&(g=l),g>h&&(g=h),0===g)break t;w.arraySet(r,n,s,g,o),l-=g,s+=g,h-=g,o+=g,a.length-=g;break}a.mode=X;break;case $:
for(;u<14;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(a.nlen=(31&_)+257,_>>>=5,u-=5,a.ndist=(31&_)+1,_>>>=5,u-=5,a.ncode=(15&_)+4,_>>>=4,u-=4,a.nlen>286||a.ndist>30){t.msg="too many length or distance symbols",a.mode=_t;break}a.have=0,a.mode=tt;case tt:for(;a.have<a.ncode;){for(;u<3;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.lens[At[a.have++]]=7&_,_>>>=3,u-=3}for(;a.have<19;)a.lens[At[a.have++]]=0;if(a.lencode=a.lendyn,a.lenbits=7,zt={bits:a.lenbits},xt=y(x,a.lens,0,19,a.lencode,0,a.work,zt),a.lenbits=zt.bits,xt){t.msg="invalid code lengths set",a.mode=_t;break}a.have=0,a.mode=et;case et:for(;a.have<a.nlen+a.ndist;){for(;St=a.lencode[_&(1<<a.lenbits)-1],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(wt<16)_>>>=gt,u-=gt,a.lens[a.have++]=wt;else{if(16===wt){for(Bt=gt+2;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(_>>>=gt,u-=gt,0===a.have){t.msg="invalid bit length repeat",a.mode=_t;break}yt=a.lens[a.have-1],g=3+(3&_),_>>>=2,u-=2}else if(17===wt){for(Bt=gt+3;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}_>>>=gt,u-=gt,yt=0,g=3+(7&_),_>>>=3,u-=3}else{for(Bt=gt+7;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}_>>>=gt,u-=gt,yt=0,g=11+(127&_),_>>>=7,u-=7}if(a.have+g>a.nlen+a.ndist){t.msg="invalid bit length repeat",a.mode=_t;break}for(;g--;)a.lens[a.have++]=yt}}if(a.mode===_t)break;if(0===a.lens[256]){t.msg="invalid code -- missing end-of-block",a.mode=_t;break}if(a.lenbits=9,zt={bits:a.lenbits},xt=y(z,a.lens,0,a.nlen,a.lencode,0,a.work,zt),a.lenbits=zt.bits,xt){t.msg="invalid literal/lengths set",a.mode=_t;break}if(a.distbits=6,a.distcode=a.distdyn,zt={bits:a.distbits},xt=y(B,a.lens,a.nlen,a.ndist,a.distcode,0,a.work,zt),a.distbits=zt.bits,xt){t.msg="invalid distances set",a.mode=_t;break}if(a.mode=at,e===A)break t;case at:a.mode=it;case it:if(l>=6&&h>=258){t.next_out=o,t.avail_out=h,t.next_in=s,t.avail_in=l,a.hold=_,a.bits=u,k(t,b),o=t.next_out,r=t.output,h=t.avail_out,s=t.next_in,n=t.input,l=t.avail_in,_=a.hold,u=a.bits,a.mode===X&&(a.back=-1);break}for(a.back=0;St=a.lencode[_&(1<<a.lenbits)-1],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(mt&&0===(240&mt)){for(pt=gt,vt=mt,kt=wt;St=a.lencode[kt+((_&(1<<pt+vt)-1)>>pt)],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(pt+gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}_>>>=pt,u-=pt,a.back+=pt}if(_>>>=gt,u-=gt,a.back+=gt,a.length=wt,0===mt){a.mode=lt;break}if(32&mt){a.back=-1,a.mode=X;break}if(64&mt){t.msg="invalid literal/length code",a.mode=_t;break}a.extra=15&mt,a.mode=nt;case nt:if(a.extra){for(Bt=a.extra;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.length+=_&(1<<a.extra)-1,_>>>=a.extra,u-=a.extra,a.back+=a.extra}a.was=a.length,a.mode=rt;case rt:for(;St=a.distcode[_&(1<<a.distbits)-1],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(0===(240&mt)){for(pt=gt,vt=mt,kt=wt;St=a.distcode[kt+((_&(1<<pt+vt)-1)>>pt)],gt=St>>>24,mt=St>>>16&255,wt=65535&St,!(pt+gt<=u);){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}_>>>=pt,u-=pt,a.back+=pt}if(_>>>=gt,u-=gt,a.back+=gt,64&mt){t.msg="invalid distance code",a.mode=_t;break}a.offset=wt,a.extra=15&mt,a.mode=st;case st:if(a.extra){for(Bt=a.extra;u<Bt;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}a.offset+=_&(1<<a.extra)-1,_>>>=a.extra,u-=a.extra,a.back+=a.extra}if(a.offset>a.dmax){t.msg="invalid distance too far back",a.mode=_t;break}a.mode=ot;case ot:if(0===h)break t;if(g=b-h,a.offset>g){if(g=a.offset-g,g>a.whave&&a.sane){t.msg="invalid distance too far back",a.mode=_t;break}g>a.wnext?(g-=a.wnext,m=a.wsize-g):m=a.wnext-g,g>a.length&&(g=a.length),bt=a.window}else bt=r,m=o-a.offset,g=a.length;g>h&&(g=h),h-=g,a.length-=g;do r[o++]=bt[m++];while(--g);0===a.length&&(a.mode=it);break;case lt:if(0===h)break t;r[o++]=a.length,h--,a.mode=it;break;case ht:if(a.wrap){for(;u<32;){if(0===l)break t;l--,_|=n[s++]<<u,u+=8}if(b-=h,t.total_out+=b,a.total+=b,b&&(t.adler=a.check=a.flags?v(a.check,r,b,o-b):p(a.check,r,b,o-b)),b=h,(a.flags?_:i(_))!==a.check){t.msg="incorrect data check",a.mode=_t;break}_=0,u=0}a.mode=dt;case dt:if(a.wrap&&a.flags){for(;u<32;){if(0===l)break t;l--,_+=n[s++]<<u,u+=8}if(_!==(4294967295&a.total)){t.msg="incorrect length check",a.mode=_t;break}_=0,u=0}a.mode=ft;case ft:xt=R;break t;case _t:xt=O;break t;case ut:return D;case ct:default:return N}return t.next_out=o,t.avail_out=h,t.next_in=s,t.avail_in=l,a.hold=_,a.bits=u,(a.wsize||b!==t.avail_out&&a.mode<_t&&(a.mode<ht||e!==S))&&f(t,t.output,t.next_out,b-t.avail_out)?(a.mode=ut,D):(c-=t.avail_in,b-=t.avail_out,t.total_in+=c,t.total_out+=b,a.total+=b,a.wrap&&b&&(t.adler=a.check=a.flags?v(a.check,r,b,t.next_out-b):p(a.check,r,b,t.next_out-b)),t.data_type=a.bits+(a.last?64:0)+(a.mode===X?128:0)+(a.mode===at||a.mode===Q?256:0),(0===c&&0===b||e===S)&&xt===Z&&(xt=I),xt)}function u(t){if(!t||!t.state)return N;var e=t.state;return e.window&&(e.window=null),t.state=null,Z}function c(t,e){var a;return t&&t.state?(a=t.state,0===(2&a.wrap)?N:(a.head=e,e.done=!1,Z)):N}function b(t,e){var a,i,n,r=e.length;return t&&t.state?(a=t.state,0!==a.wrap&&a.mode!==G?N:a.mode===G&&(i=1,i=p(i,e,r,0),i!==a.check)?O:(n=f(t,e,r,r))?(a.mode=ut,D):(a.havedict=1,Z)):N}var g,m,w=t("../utils/common"),p=t("./adler32"),v=t("./crc32"),k=t("./inffast"),y=t("./inftrees"),x=0,z=1,B=2,S=4,E=5,A=6,Z=0,R=1,C=2,N=-2,O=-3,D=-4,I=-5,U=8,T=1,F=2,L=3,H=4,j=5,K=6,M=7,P=8,Y=9,q=10,G=11,X=12,W=13,J=14,Q=15,V=16,$=17,tt=18,et=19,at=20,it=21,nt=22,rt=23,st=24,ot=25,lt=26,ht=27,dt=28,ft=29,_t=30,ut=31,ct=32,bt=852,gt=592,mt=15,wt=mt,pt=!0;a.inflateReset=s,a.inflateReset2=o,a.inflateResetKeep=r,a.inflateInit=h,a.inflateInit2=l,a.inflate=_,a.inflateEnd=u,a.inflateGetHeader=c,a.inflateSetDictionary=b,a.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":3,"./adler32":5,"./crc32":7,"./inffast":10,"./inftrees":12}],12:[function(t,e,a){"use strict";var i=t("../utils/common"),n=15,r=852,s=592,o=0,l=1,h=2,d=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],f=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],_=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],u=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,a,c,b,g,m,w){var p,v,k,y,x,z,B,S,E,A=w.bits,Z=0,R=0,C=0,N=0,O=0,D=0,I=0,U=0,T=0,F=0,L=null,H=0,j=new i.Buf16(n+1),K=new i.Buf16(n+1),M=null,P=0;for(Z=0;Z<=n;Z++)j[Z]=0;for(R=0;R<c;R++)j[e[a+R]]++;for(O=A,N=n;N>=1&&0===j[N];N--);if(O>N&&(O=N),0===N)return b[g++]=20971520,b[g++]=20971520,w.bits=1,0;for(C=1;C<N&&0===j[C];C++);for(O<C&&(O=C),U=1,Z=1;Z<=n;Z++)if(U<<=1,U-=j[Z],U<0)return-1;if(U>0&&(t===o||1!==N))return-1;for(K[1]=0,Z=1;Z<n;Z++)K[Z+1]=K[Z]+j[Z];for(R=0;R<c;R++)0!==e[a+R]&&(m[K[e[a+R]]++]=R);if(t===o?(L=M=m,z=19):t===l?(L=d,H-=257,M=f,P-=257,z=256):(L=_,M=u,z=-1),F=0,R=0,Z=C,x=g,D=O,I=0,k=-1,T=1<<O,y=T-1,t===l&&T>r||t===h&&T>s)return 1;for(;;){B=Z-I,m[R]<z?(S=0,E=m[R]):m[R]>z?(S=M[P+m[R]],E=L[H+m[R]]):(S=96,E=0),p=1<<Z-I,v=1<<D,C=v;do v-=p,b[x+(F>>I)+v]=B<<24|S<<16|E|0;while(0!==v);for(p=1<<Z-1;F&p;)p>>=1;if(0!==p?(F&=p-1,F+=p):F=0,R++,0===--j[Z]){if(Z===N)break;Z=e[a+m[R]]}if(Z>O&&(F&y)!==k){for(0===I&&(I=O),x+=C,D=Z-I,U=1<<D;D+I<N&&(U-=j[D+I],!(U<=0));)D++,U<<=1;if(T+=1<<D,t===l&&T>r||t===h&&T>s)return 1;k=F&y,b[k]=O<<24|D<<16|x-g|0}}return 0!==F&&(b[x+F]=Z-I<<24|64<<16|0),w.bits=O,0}},{"../utils/common":3}],13:[function(t,e,a){"use strict";e.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],14:[function(t,e,a){"use strict";function i(t){for(var e=t.length;--e>=0;)t[e]=0}function n(t,e,a,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=a,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function r(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function s(t){return t<256?lt[t]:lt[256+(t>>>7)]}function o(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function l(t,e,a){t.bi_valid>W-a?(t.bi_buf|=e<<t.bi_valid&65535,o(t,t.bi_buf),t.bi_buf=e>>W-t.bi_valid,t.bi_valid+=a-W):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=a)}function h(t,e,a){l(t,a[2*e],a[2*e+1])}function d(t,e){var a=0;do a|=1&t,t>>>=1,a<<=1;while(--e>0);return a>>>1}function f(t){16===t.bi_valid?(o(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):t.bi_valid>=8&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}function _(t,e){var a,i,n,r,s,o,l=e.dyn_tree,h=e.max_code,d=e.stat_desc.static_tree,f=e.stat_desc.has_stree,_=e.stat_desc.extra_bits,u=e.stat_desc.extra_base,c=e.stat_desc.max_length,b=0;for(r=0;r<=X;r++)t.bl_count[r]=0;for(l[2*t.heap[t.heap_max]+1]=0,a=t.heap_max+1;a<G;a++)i=t.heap[a],r=l[2*l[2*i+1]+1]+1,r>c&&(r=c,b++),l[2*i+1]=r,i>h||(t.bl_count[r]++,s=0,i>=u&&(s=_[i-u]),o=l[2*i],t.opt_len+=o*(r+s),f&&(t.static_len+=o*(d[2*i+1]+s)));if(0!==b){do{for(r=c-1;0===t.bl_count[r];)r--;t.bl_count[r]--,t.bl_count[r+1]+=2,t.bl_count[c]--,b-=2}while(b>0);for(r=c;0!==r;r--)for(i=t.bl_count[r];0!==i;)n=t.heap[--a],n>h||(l[2*n+1]!==r&&(t.opt_len+=(r-l[2*n+1])*l[2*n],l[2*n+1]=r),i--)}}function u(t,e,a){var i,n,r=new Array(X+1),s=0;for(i=1;i<=X;i++)r[i]=s=s+a[i-1]<<1;for(n=0;n<=e;n++){var o=t[2*n+1];0!==o&&(t[2*n]=d(r[o]++,o))}}function c(){var t,e,a,i,r,s=new Array(X+1);for(a=0,i=0;i<K-1;i++)for(dt[i]=a,t=0;t<1<<et[i];t++)ht[a++]=i;for(ht[a-1]=i,r=0,i=0;i<16;i++)for(ft[i]=r,t=0;t<1<<at[i];t++)lt[r++]=i;for(r>>=7;i<Y;i++)for(ft[i]=r<<7,t=0;t<1<<at[i]-7;t++)lt[256+r++]=i;for(e=0;e<=X;e++)s[e]=0;for(t=0;t<=143;)st[2*t+1]=8,t++,s[8]++;for(;t<=255;)st[2*t+1]=9,t++,s[9]++;for(;t<=279;)st[2*t+1]=7,t++,s[7]++;for(;t<=287;)st[2*t+1]=8,t++,s[8]++;for(u(st,P+1,s),t=0;t<Y;t++)ot[2*t+1]=5,ot[2*t]=d(t,5);_t=new n(st,et,M+1,P,X),ut=new n(ot,at,0,Y,X),ct=new n(new Array(0),it,0,q,J)}function b(t){var e;for(e=0;e<P;e++)t.dyn_ltree[2*e]=0;for(e=0;e<Y;e++)t.dyn_dtree[2*e]=0;for(e=0;e<q;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*Q]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function g(t){t.bi_valid>8?o(t,t.bi_buf):t.bi_valid>0&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function m(t,e,a,i){g(t),i&&(o(t,a),o(t,~a)),N.arraySet(t.pending_buf,t.window,e,a,t.pending),t.pending+=a}function w(t,e,a,i){var n=2*e,r=2*a;return t[n]<t[r]||t[n]===t[r]&&i[e]<=i[a]}function p(t,e,a){for(var i=t.heap[a],n=a<<1;n<=t.heap_len&&(n<t.heap_len&&w(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!w(e,i,t.heap[n],t.depth));)t.heap[a]=t.heap[n],a=n,n<<=1;t.heap[a]=i}function v(t,e,a){var i,n,r,o,d=0;if(0!==t.last_lit)do i=t.pending_buf[t.d_buf+2*d]<<8|t.pending_buf[t.d_buf+2*d+1],n=t.pending_buf[t.l_buf+d],d++,0===i?h(t,n,e):(r=ht[n],h(t,r+M+1,e),o=et[r],0!==o&&(n-=dt[r],l(t,n,o)),i--,r=s(i),h(t,r,a),o=at[r],0!==o&&(i-=ft[r],l(t,i,o)));while(d<t.last_lit);h(t,Q,e)}function k(t,e){var a,i,n,r=e.dyn_tree,s=e.stat_desc.static_tree,o=e.stat_desc.has_stree,l=e.stat_desc.elems,h=-1;for(t.heap_len=0,t.heap_max=G,a=0;a<l;a++)0!==r[2*a]?(t.heap[++t.heap_len]=h=a,t.depth[a]=0):r[2*a+1]=0;for(;t.heap_len<2;)n=t.heap[++t.heap_len]=h<2?++h:0,r[2*n]=1,t.depth[n]=0,t.opt_len--,o&&(t.static_len-=s[2*n+1]);for(e.max_code=h,a=t.heap_len>>1;a>=1;a--)p(t,r,a);n=l;do a=t.heap[1],t.heap[1]=t.heap[t.heap_len--],p(t,r,1),i=t.heap[1],t.heap[--t.heap_max]=a,t.heap[--t.heap_max]=i,r[2*n]=r[2*a]+r[2*i],t.depth[n]=(t.depth[a]>=t.depth[i]?t.depth[a]:t.depth[i])+1,r[2*a+1]=r[2*i+1]=n,t.heap[1]=n++,p(t,r,1);while(t.heap_len>=2);t.heap[--t.heap_max]=t.heap[1],_(t,e),u(r,h,t.bl_count)}function y(t,e,a){var i,n,r=-1,s=e[1],o=0,l=7,h=4;for(0===s&&(l=138,h=3),e[2*(a+1)+1]=65535,i=0;i<=a;i++)n=s,s=e[2*(i+1)+1],++o<l&&n===s||(o<h?t.bl_tree[2*n]+=o:0!==n?(n!==r&&t.bl_tree[2*n]++,t.bl_tree[2*V]++):o<=10?t.bl_tree[2*$]++:t.bl_tree[2*tt]++,o=0,r=n,0===s?(l=138,h=3):n===s?(l=6,h=3):(l=7,h=4))}function x(t,e,a){var i,n,r=-1,s=e[1],o=0,d=7,f=4;for(0===s&&(d=138,f=3),i=0;i<=a;i++)if(n=s,s=e[2*(i+1)+1],!(++o<d&&n===s)){if(o<f){do h(t,n,t.bl_tree);while(0!==--o)}else 0!==n?(n!==r&&(h(t,n,t.bl_tree),o--),h(t,V,t.bl_tree),l(t,o-3,2)):o<=10?(h(t,$,t.bl_tree),l(t,o-3,3)):(h(t,tt,t.bl_tree),l(t,o-11,7));o=0,r=n,0===s?(d=138,f=3):n===s?(d=6,f=3):(d=7,f=4)}}function z(t){var e;for(y(t,t.dyn_ltree,t.l_desc.max_code),y(t,t.dyn_dtree,t.d_desc.max_code),k(t,t.bl_desc),e=q-1;e>=3&&0===t.bl_tree[2*nt[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}function B(t,e,a,i){var n;for(l(t,e-257,5),l(t,a-1,5),l(t,i-4,4),n=0;n<i;n++)l(t,t.bl_tree[2*nt[n]+1],3);x(t,t.dyn_ltree,e-1),x(t,t.dyn_dtree,a-1)}function S(t){var e,a=4093624447;for(e=0;e<=31;e++,a>>>=1)if(1&a&&0!==t.dyn_ltree[2*e])return D;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return I;for(e=32;e<M;e++)if(0!==t.dyn_ltree[2*e])return I;return D}function E(t){bt||(c(),bt=!0),t.l_desc=new r(t.dyn_ltree,_t),t.d_desc=new r(t.dyn_dtree,ut),t.bl_desc=new r(t.bl_tree,ct),t.bi_buf=0,t.bi_valid=0,b(t)}function A(t,e,a,i){l(t,(T<<1)+(i?1:0),3),m(t,e,a,!0)}function Z(t){l(t,F<<1,3),h(t,Q,st),f(t)}function R(t,e,a,i){var n,r,s=0;t.level>0?(t.strm.data_type===U&&(t.strm.data_type=S(t)),k(t,t.l_desc),k(t,t.d_desc),s=z(t),n=t.opt_len+3+7>>>3,r=t.static_len+3+7>>>3,r<=n&&(n=r)):n=r=a+5,a+4<=n&&e!==-1?A(t,e,a,i):t.strategy===O||r===n?(l(t,(F<<1)+(i?1:0),3),v(t,st,ot)):(l(t,(L<<1)+(i?1:0),3),B(t,t.l_desc.max_code+1,t.d_desc.max_code+1,s+1),v(t,t.dyn_ltree,t.dyn_dtree)),b(t),i&&g(t)}function C(t,e,a){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&a,t.last_lit++,0===e?t.dyn_ltree[2*a]++:(t.matches++,e--,t.dyn_ltree[2*(ht[a]+M+1)]++,t.dyn_dtree[2*s(e)]++),t.last_lit===t.lit_bufsize-1}var N=t("../utils/common"),O=4,D=0,I=1,U=2,T=0,F=1,L=2,H=3,j=258,K=29,M=256,P=M+1+K,Y=30,q=19,G=2*P+1,X=15,W=16,J=7,Q=256,V=16,$=17,tt=18,et=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],at=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],it=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],nt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],rt=512,st=new Array(2*(P+2));i(st);var ot=new Array(2*Y);i(ot);var lt=new Array(rt);i(lt);var ht=new Array(j-H+1);i(ht);var dt=new Array(K);i(dt);var ft=new Array(Y);i(ft);var _t,ut,ct,bt=!1;a._tr_init=E,a._tr_stored_block=A,a._tr_flush_block=R,a._tr_tally=C,a._tr_align=Z},{"../utils/common":3}],15:[function(t,e,a){"use strict";function i(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}e.exports=i},{}],"/":[function(t,e,a){"use strict";var i=t("./lib/utils/common").assign,n=t("./lib/deflate"),r=t("./lib/inflate"),s=t("./lib/zlib/constants"),o={};i(o,n,r,s),e.exports=o},{"./lib/deflate":1,"./lib/inflate":2,"./lib/utils/common":3,"./lib/zlib/constants":6}]},{},[])("/")});

;(function ($hx_exports, $global) { "use strict";
$hx_exports["dif"] = $hx_exports["dif"] || {};
$hx_exports["dif"]["math"] = $hx_exports["dif"]["math"] || {};
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	matched(n) {
		if(this.r.m != null && n >= 0 && n < this.r.m.length) {
			return this.r.m[n];
		} else {
			throw haxe_Exception.thrown("EReg::matched");
		}
	}
	matchedRight() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		let sz = this.r.m.index + this.r.m[0].length;
		return HxOverrides.substr(this.r.s,sz,this.r.s.length - sz);
	}
	matchedPos() {
		if(this.r.m == null) {
			throw haxe_Exception.thrown("No string matched");
		}
		return { pos : this.r.m.index, len : this.r.m[0].length};
	}
	matchSub(s,pos,len) {
		if(len == null) {
			len = -1;
		}
		if(this.r.global) {
			this.r.lastIndex = pos;
			this.r.m = this.r.exec(len < 0 ? s : HxOverrides.substr(s,0,pos + len));
			let b = this.r.m != null;
			if(b) {
				this.r.s = s;
			}
			return b;
		} else {
			let b = this.match(len < 0 ? HxOverrides.substr(s,pos,null) : HxOverrides.substr(s,pos,len));
			if(b) {
				this.r.s = s;
				this.r.m.index += pos;
			}
			return b;
		}
	}
}
$hxClasses["EReg"] = EReg;
EReg.__name__ = "EReg";
Object.assign(EReg.prototype, {
	__class__: EReg
	,r: null
});
class HxOverrides {
	static strDate(s) {
		switch(s.length) {
		case 8:
			let k = s.split(":");
			let d = new Date();
			d["setTime"](0);
			d["setUTCHours"](k[0]);
			d["setUTCMinutes"](k[1]);
			d["setUTCSeconds"](k[2]);
			return d;
		case 10:
			let k1 = s.split("-");
			return new Date(k1[0],k1[1] - 1,k1[2],0,0,0);
		case 19:
			let k2 = s.split(" ");
			let y = k2[0].split("-");
			let t = k2[1].split(":");
			return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
		default:
			throw haxe_Exception.thrown("Invalid date format : " + s);
		}
	}
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		let i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static now() {
		return Date.now();
	}
}
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = "HxOverrides";
class Lambda {
	static array(it) {
		let a = [];
		let i = $getIterator(it);
		while(i.hasNext()) {
			let i1 = i.next();
			a.push(i1);
		}
		return a;
	}
}
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = "Lambda";
class MPCustoms {
	static loadMissionList() {
		if(MPCustoms.missionList.length == 0 && !MPCustoms._requestSent) {
			MPCustoms._requestSent = true;
			src_Http.get("https://marbleblastultra.randomityguy.me/data/ultraCustom.json",function(b) {
				let misList = JSON.parse(b.toString());
				MPCustoms.missionList = misList;
				MPCustoms.missionList.sort(function(a,b) {
					let a1 = a.title.toLowerCase();
					let b1 = b.title.toLowerCase();
					if(a1 < b1) {
						return -1;
					} else if(a1 > b1) {
						return 1;
					} else {
						return 0;
					}
				});
				src_Console.instance.addEntry("log","Loaded " + misList.length + " custom missions.");
				MPCustoms._requestSent = false;
			},function(e) {
				src_Console.instance.addEntry("log","Error getting custom list from marbleland.");
				MPCustoms._requestSent = false;
			});
		}
	}
	static download(mission,onFinish,onFail) {
		let lastSlashIdx = mission.path.lastIndexOf("/");
		let s = HxOverrides.substr(mission.path,0,lastSlashIdx);
		let dlPath = "https://marbleblastultra.randomityguy.me/" + encodeURIComponent(s) + ".zip";
		src_Http.get(dlPath,function(zipData) {
			let reader = new haxe_zip_Reader(new haxe_io_BytesInput(zipData));
			let entries = null;
			try {
				let _g = [];
				let _g_head = reader.read().h;
				while(_g_head != null) {
					let val = _g_head.item;
					_g_head = _g_head.next;
					let x = val;
					_g.push(x);
				}
				entries = _g;
			} catch( _g ) {
			}
			src_ResourceLoader.loadZip(entries,"missions/mpcustom/");
			if(entries != null) {
				onFinish();
			} else {
				src_MarbleGame.canvas.pushDialog(new gui_MessageBoxOkDlg("Failed to download mission"));
				onFail();
			}
		},function(e) {
			src_MarbleGame.canvas.pushDialog(new gui_MessageBoxOkDlg("Failed to download mission"));
			onFail();
		});
	}
	static play(mission,onFinish,onFail) {
		MPCustoms.download(mission,function() {
			let f = src_ResourceLoader.getFileEntry(mission.path);
			let mis = src_MissionList.parseMisHeader(f.entry.getBytes().toString(),mission.path);
			src_MarbleGame.instance.playMission(mis,true);
			onFinish();
		},onFail);
	}
}
$hxClasses["MPCustoms"] = MPCustoms;
MPCustoms.__name__ = "MPCustoms";
class h3d_IDrawable {
}
$hxClasses["h3d.IDrawable"] = h3d_IDrawable;
h3d_IDrawable.__name__ = "h3d.IDrawable";
h3d_IDrawable.__isInterface__ = true;
class hxd_App {
	constructor() {
		if(hxd_App._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
		let engine = h3d_Engine.CURRENT;
		let _gthis = this;
		if(engine != null) {
			this.engine = engine;
			engine.onReady = $bind(this,this.setup);
			haxe_Timer.delay($bind(this,this.setup),0);
		} else {
			hxd_System.start(function() {
				engine = new h3d_Engine();
				_gthis.engine = engine;
				engine.onReady = $bind(_gthis,_gthis.setup);
				engine.init();
			});
		}
	}
	onResize() {
	}
	onContextLost() {
		if(this.s3d != null) {
			this.s3d.onContextLost();
		}
	}
	render(e) {
		this.s3d.render(e);
		this.s2d.render(e);
	}
	setup() {
		let initDone = false;
		this.engine.onReady = hxd_App.staticHandler;
		this.engine.onContextLost = $bind(this,this.onContextLost);
		let _gthis = this;
		this.engine.onResized = function() {
			if(_gthis.s2d == null) {
				return;
			}
			_gthis.s2d.checkResize();
			if(initDone) {
				_gthis.onResize();
			}
		};
		this.s3d = new h3d_scene_Scene();
		this.s2d = new h2d_Scene();
		this.sevents = new hxd_SceneEvents();
		this.sevents.addScene(this.s2d);
		this.sevents.addScene(this.s3d);
		this.loadAssets(function() {
			initDone = true;
			_gthis.init();
			hxd_Timer.skip();
			_gthis.mainLoop();
			hxd_System.setLoop($bind(_gthis,_gthis.mainLoop));
			hxd_Key.initialize();
		});
	}
	loadAssets(onLoaded) {
		onLoaded();
	}
	init() {
	}
	mainLoop() {
		hxd_Timer.update();
		this.sevents.checkEvents();
		if(this.isDisposed) {
			return;
		}
		this.update(hxd_Timer.dt);
		if(this.isDisposed) {
			return;
		}
		let dt = hxd_Timer.dt;
		if(this.s2d != null) {
			this.s2d.setElapsedTime(dt);
		}
		if(this.s3d != null) {
			this.s3d.setElapsedTime(dt);
		}
		this.engine.render(this);
	}
	update(dt) {
	}
	static staticHandler() {
	}
}
$hxClasses["hxd.App"] = hxd_App;
hxd_App.__name__ = "hxd.App";
hxd_App.__interfaces__ = [h3d_IDrawable];
Object.assign(hxd_App.prototype, {
	__class__: hxd_App
	,engine: null
	,s3d: null
	,s2d: null
	,sevents: null
	,isDisposed: null
});
class Main extends hxd_App {
	constructor() {
		hxd_App._hx_skip_constructor = true;
		super();
		hxd_App._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.loaded = false;
		super._hx_constructor();
	}
	init() {
		super.init();
		this.s3d.set_renderer(new src_Renderer());
		this.s3d.checkPasses = false;
		let zoomRatio;
		if(src_Util.isTouchDevice()) {
			let reg = new EReg("iPad|tablet","gm");
			let t1 = reg.match($global.navigator.userAgent);
			let zoomRatio1;
			if(!t1) {
				let reg2 = new EReg("Mac","gm");
				zoomRatio1 = reg2.match($global.navigator.userAgent) && $global.navigator.maxTouchPoints != null && $global.navigator.maxTouchPoints > 2;
			} else {
				zoomRatio1 = true;
			}
			zoomRatio = !zoomRatio1;
		} else {
			zoomRatio = false;
		}
		let zoomRatio1 = zoomRatio ? window.screen.height * window.devicePixelRatio / 768 : window.devicePixelRatio;
		let reg = new EReg("iPhone","gm");
		if(reg.match($global.navigator.userAgent)) {
			zoomRatio1 = 1.5;
		}
		let reg1 = new EReg("iPhone","gm");
		if(reg1.match($global.navigator.userAgent) && window.devicePixelRatio == 2) {
			zoomRatio1 = 1.0;
		}
		this.s2d.set_scaleMode(h2d_ScaleMode.Zoom(zoomRatio1));
		src_Settings.zoomRatio = zoomRatio1;
		let tmp = window.screen.width;
		src_Settings.optionsSettings.screenWidth = Math.max(tmp,window.screen.height);
		let tmp1 = window.screen.width;
		src_Settings.optionsSettings.screenHeight = Math.min(tmp1,window.screen.height);
		let canvasElement = window.document.getElementById("webgl");
		canvasElement.style.width = "100%";
		canvasElement.style.height = "100%";
		this.s3d.camera.setFovX(src_Settings.optionsSettings.fovX,src_Settings.optionsSettings.screenWidth / src_Settings.optionsSettings.screenHeight);
		new src_Console();
		src_Console.instance.addEntry("log","Initializing MBHaxe");
		datachannel_RTC.init();
		haxe_MainLoop.add(function() {
		});
		src_Settings.init();
		src_Gamepad.init();
		MPCustoms.loadMissionList();
		let _gthis = this;
		src_ResourceLoader.init(this.s2d,function() {
			src_AudioManager.init();
			src_AudioManager.playShell();
			_gthis.marbleGame = new src_MarbleGame(_gthis.s2d,_gthis.s3d);
			src_MarbleGame.canvas.setContent(new gui_PresentsGui());
			src_MissionList.buildMissionList();
			_gthis.marbleGame.startPreviewWorld(function() {
				_gthis.marbleGame.setPreviewMission("urban",function() {
					src_MarbleGame.canvas.setContent(new gui_MainMenuGui());
					gui_VersionGui.checkVersion();
				});
			});
			new src_ProfilerUI(_gthis.s2d);
			_gthis.loaded = true;
		});
	}
	update(dt) {
		super.update(dt);
		src_ProfilerUI.begin(1);
		src_ProfilerUI.measure("updateBegin",1);
		if(this.loaded) {
			this.marbleGame.update(dt);
			src_ProfilerUI.update(this.engine.get_fps());
		}
		src_ProfilerUI.end(1);
	}
	render(e) {
		src_ProfilerUI.begin(0);
		if(this.loaded) {
			src_ProfilerUI.measure("renderBegin",0);
			this.marbleGame.render(e);
		}
		super.render(e);
		src_ProfilerUI.end(0);
	}
	static main() {
		new Main();
	}
}
$hxClasses["Main"] = Main;
Main.__name__ = "Main";
Main.__super__ = hxd_App;
Object.assign(Main.prototype, {
	__class__: Main
	,marbleGame: null
	,loaded: null
});
Math.__name__ = "Math";
class RandomLCG {
	constructor(seed) {
		if(seed == null) {
			seed = -1;
		}
		let tmp;
		if(seed == -1) {
			RandomLCG.msSeed = RandomLCG.msSeed * 22695477 + 1;
			RandomLCG.msSeed = RandomLCG.msSeed >> 16 & 32767;
			tmp = RandomLCG.msSeed;
		} else {
			tmp = seed;
		}
		this.seed = tmp;
	}
	setSeed(seed) {
		this.seed = seed;
	}
	randInt() {
		if(this.seed <= RandomLCG.quotient) {
			this.seed = this.seed * 16807 % 2147483647;
		} else {
			let high_part = this.seed / RandomLCG.quotient | 0;
			let low_part = this.seed % RandomLCG.quotient;
			let test = 16807 * low_part - RandomLCG.remainder * high_part;
			if(test > 0) {
				this.seed = test;
			} else {
				this.seed = test + 2147483647;
			}
		}
		return this.seed;
	}
	randRange(i,n) {
		return i + this.randInt() % (n - i + 1);
	}
}
$hxClasses["RandomLCG"] = RandomLCG;
RandomLCG.__name__ = "RandomLCG";
Object.assign(RandomLCG.prototype, {
	__class__: RandomLCG
	,seed: null
});
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			return null;
		}
	}
	static fields(o) {
		let a = [];
		if(o != null) {
			let hasOwnProperty = Object.prototype.hasOwnProperty;
			for( var f in o ) {
			if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
				a.push(f);
			}
			}
		}
		return a;
	}
	static isFunction(f) {
		if(typeof(f) == "function") {
			return !(f.__name__ || f.__ename__);
		} else {
			return false;
		}
	}
	static compare(a,b) {
		if(a == b) {
			return 0;
		} else if(a > b) {
			return 1;
		} else {
			return -1;
		}
	}
	static isEnumValue(v) {
		if(v != null) {
			return v.__enum__ != null;
		} else {
			return false;
		}
	}
}
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = "Reflect";
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		let v = parseInt(x);
		if(isNaN(v)) {
			return null;
		}
		return v;
	}
	static random(x) {
		if(x <= 0) {
			return 0;
		} else {
			return Math.floor(Math.random() * x);
		}
	}
}
$hxClasses["Std"] = Std;
Std.__name__ = "Std";
class StringBuf {
	constructor() {
		this.b = "";
	}
}
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = "StringBuf";
Object.assign(StringBuf.prototype, {
	__class__: StringBuf
	,b: null
});
class StringTools {
	static htmlEscape(s,quotes) {
		let buf_b = "";
		let _g_offset = 0;
		let _g_s = s;
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let code = c1;
			switch(code) {
			case 34:
				if(quotes) {
					buf_b += "&quot;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 38:
				buf_b += "&amp;";
				break;
			case 39:
				if(quotes) {
					buf_b += "&#039;";
				} else {
					buf_b += String.fromCodePoint(code);
				}
				break;
			case 60:
				buf_b += "&lt;";
				break;
			case 62:
				buf_b += "&gt;";
				break;
			default:
				buf_b += String.fromCodePoint(code);
			}
		}
		return buf_b;
	}
	static htmlUnescape(s) {
		return s.split("&gt;").join(">").split("&lt;").join("<").split("&quot;").join("\"").split("&#039;").join("'").split("&amp;").join("&");
	}
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static lpad(s,c,l) {
		if(c.length <= 0) {
			return s;
		}
		let buf_b = "";
		l -= s.length;
		while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
		buf_b += s == null ? "null" : "" + s;
		return buf_b;
	}
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
	static hex(n,digits) {
		let s = "";
		do {
			s = "0123456789ABCDEF".charAt(n & 15) + s;
			n >>>= 4;
		} while(n > 0);
		if(digits != null) {
			while(s.length < digits) s = "0" + s;
		}
		return s;
	}
}
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = "StringTools";
class Type {
	static createInstance(cl,args) {
		let ctor = Function.prototype.bind.apply(cl,[null].concat(args));
		return new (ctor);
	}
	static createEnum(e,constr,params) {
		let f = Reflect.field(e,constr);
		if(f == null) {
			throw haxe_Exception.thrown("No such constructor " + constr);
		}
		if(Reflect.isFunction(f)) {
			if(params == null) {
				throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
			}
			return f.apply(e,params);
		}
		if(params != null && params.length != 0) {
			throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
		}
		return f;
	}
	static createEnumIndex(e,index,params) {
		let c;
		let _g = e.__constructs__[index];
		if(_g == null) {
			c = null;
		} else {
			let ctor = _g;
			c = ctor._hx_name;
		}
		if(c == null) {
			throw haxe_Exception.thrown(index + " is not a valid enum constructor index");
		}
		return Type.createEnum(e,c,params);
	}
	static getInstanceFields(c) {
		let result = [];
		while(c != null) {
			let _g = 0;
			let _g1 = Object.getOwnPropertyNames(c.prototype);
			while(_g < _g1.length) {
				let name = _g1[_g];
				++_g;
				switch(name) {
				case "__class__":case "__properties__":case "constructor":
					break;
				default:
					if(result.indexOf(name) == -1) {
						result.push(name);
					}
				}
			}
			c = c.__super__;
		}
		return result;
	}
	static enumEq(a,b) {
		if(a == b) {
			return true;
		}
		try {
			let e = a.__enum__;
			if(e == null || e != b.__enum__) {
				return false;
			}
			if(a._hx_index != b._hx_index) {
				return false;
			}
			let enm = $hxEnums[e];
			let params = enm.__constructs__[a._hx_index].__params__;
			let _g = 0;
			while(_g < params.length) {
				let f = params[_g];
				++_g;
				if(!Type.enumEq(a[f],b[f])) {
					return false;
				}
			}
		} catch( _g ) {
			return false;
		}
		return true;
	}
	static enumParameters(e) {
		let enm = $hxEnums[e.__enum__];
		let params = enm.__constructs__[e._hx_index].__params__;
		if(params != null) {
			let _g = [];
			let _g1 = 0;
			while(_g1 < params.length) {
				let p = params[_g1];
				++_g1;
				_g.push(e[p]);
			}
			return _g;
		} else {
			return [];
		}
	}
}
$hxClasses["Type"] = Type;
Type.__name__ = "Type";
class UInt {
	static gt(a,b) {
		let aNeg = a < 0;
		let bNeg = b < 0;
		if(aNeg != bNeg) {
			return aNeg;
		} else {
			return a > b;
		}
	}
	static gte(a,b) {
		let aNeg = a < 0;
		let bNeg = b < 0;
		if(aNeg != bNeg) {
			return aNeg;
		} else {
			return a >= b;
		}
	}
	static toFloat(this1) {
		if(this1 < 0) {
			return 4294967296.0 + this1;
		} else {
			return this1 + 0.0;
		}
	}
}
class XmlType {
	static toString(this1) {
		switch(this1) {
		case 0:
			return "Element";
		case 1:
			return "PCData";
		case 2:
			return "CData";
		case 3:
			return "Comment";
		case 4:
			return "DocType";
		case 5:
			return "ProcessingInstruction";
		case 6:
			return "Document";
		}
	}
}
class Xml {
	constructor(nodeType) {
		this.nodeType = nodeType;
		this.children = [];
		this.attributeMap = new haxe_ds_StringMap();
	}
	get(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return this.attributeMap.h[att];
	}
	set(att,value) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		this.attributeMap.h[att] = value;
	}
	exists(att) {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return Object.prototype.hasOwnProperty.call(this.attributeMap.h,att);
	}
	attributes() {
		if(this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.attributeMap.h);
	}
	iterator() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		return new haxe_iterators_ArrayIterator(this.children);
	}
	elements() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = this.children;
		while(_g1 < _g2.length) {
			let child = _g2[_g1];
			++_g1;
			if(child.nodeType == Xml.Element) {
				_g.push(child);
			}
		}
		return new haxe_iterators_ArrayIterator(_g);
	}
	elementsNamed(name) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = this.children;
		while(_g1 < _g2.length) {
			let child = _g2[_g1];
			++_g1;
			let tmp;
			if(child.nodeType == Xml.Element) {
				if(child.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				tmp = child.nodeName == name;
			} else {
				tmp = false;
			}
			if(tmp) {
				_g.push(child);
			}
		}
		return new haxe_iterators_ArrayIterator(_g);
	}
	firstElement() {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let child = _g1[_g];
			++_g;
			if(child.nodeType == Xml.Element) {
				return child;
			}
		}
		return null;
	}
	addChild(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	removeChild(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (this.nodeType == null ? "null" : XmlType.toString(this.nodeType)));
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	toString() {
		return haxe_xml_Printer.print(this);
	}
	static parse(str) {
		return haxe_xml_Parser.parse(str);
	}
	static createElement(name) {
		let xml = new Xml(Xml.Element);
		if(xml.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeName = name;
		return xml;
	}
	static createPCData(data) {
		let xml = new Xml(Xml.PCData);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createCData(data) {
		let xml = new Xml(Xml.CData);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createComment(data) {
		let xml = new Xml(Xml.Comment);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createDocType(data) {
		let xml = new Xml(Xml.DocType);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createProcessingInstruction(data) {
		let xml = new Xml(Xml.ProcessingInstruction);
		if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, unexpected " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
		}
		xml.nodeValue = data;
		return xml;
	}
	static createDocument() {
		return new Xml(Xml.Document);
	}
}
$hxClasses["Xml"] = Xml;
Xml.__name__ = "Xml";
Object.assign(Xml.prototype, {
	__class__: Xml
	,nodeType: null
	,nodeName: null
	,nodeValue: null
	,parent: null
	,children: null
	,attributeMap: null
});
class collision_IBVHObject {
}
$hxClasses["collision.IBVHObject"] = collision_IBVHObject;
collision_IBVHObject.__name__ = "collision.IBVHObject";
collision_IBVHObject.__isInterface__ = true;
class collision_BVHNode {
	constructor() {
		this.zMax = 0;
		this.yMax = 0;
		this.xMax = 0;
		this.zMin = 0;
		this.yMin = 0;
		this.xMin = 0;
		this.child2 = -1;
		this.child1 = -1;
	}
}
$hxClasses["collision.BVHNode"] = collision_BVHNode;
collision_BVHNode.__name__ = "collision.BVHNode";
Object.assign(collision_BVHNode.prototype, {
	__class__: collision_BVHNode
	,index: null
	,child1: null
	,child2: null
	,isLeaf: null
	,object: null
	,xMin: null
	,yMin: null
	,zMin: null
	,xMax: null
	,yMax: null
	,zMax: null
});
class collision_BVHTree {
	constructor() {
		this.nodes = [];
	}
	boundingSearch(searchbox) {
		let res = [];
		if(this.root == null) {
			return res;
		}
		let q = [this.root.index];
		let qptr = 0;
		while(qptr != q.length) {
			let current = q[qptr++];
			let currentnode = this.nodes[current];
			if(currentnode.xMin <= searchbox.xMin && currentnode.yMin <= searchbox.yMin && currentnode.zMin <= searchbox.zMin && currentnode.xMax >= searchbox.xMax && currentnode.yMax >= searchbox.yMax && currentnode.zMax >= searchbox.zMax || !(currentnode.xMin > searchbox.xMax || currentnode.yMin > searchbox.yMax || currentnode.zMin > searchbox.zMax || currentnode.xMax < searchbox.xMin || currentnode.yMax < searchbox.yMin || currentnode.zMax < searchbox.zMin)) {
				if(currentnode.isLeaf) {
					res.push(currentnode.object);
				} else {
					if(currentnode.child1 != -1) {
						q.push(currentnode.child1);
					}
					if(currentnode.child2 != -1) {
						q.push(currentnode.child2);
					}
				}
			}
		}
		return res;
	}
}
$hxClasses["collision.BVHTree"] = collision_BVHTree;
collision_BVHTree.__name__ = "collision.BVHTree";
Object.assign(collision_BVHTree.prototype, {
	__class__: collision_BVHTree
	,root: null
	,nodes: null
});
class octree_IOctreeElement {
}
$hxClasses["octree.IOctreeElement"] = octree_IOctreeElement;
octree_IOctreeElement.__name__ = "octree.IOctreeElement";
octree_IOctreeElement.__isInterface__ = true;
Object.assign(octree_IOctreeElement.prototype, {
	__class__: octree_IOctreeElement
	,getElementType: null
	,setPriority: null
});
class octree_IOctreeObject {
}
$hxClasses["octree.IOctreeObject"] = octree_IOctreeObject;
octree_IOctreeObject.__name__ = "octree.IOctreeObject";
octree_IOctreeObject.__isInterface__ = true;
octree_IOctreeObject.__interfaces__ = [octree_IOctreeElement];
Object.assign(octree_IOctreeObject.prototype, {
	__class__: octree_IOctreeObject
	,boundingBox: null
});
class collision_CollisionEntity {
	constructor(go) {
		this._transformKey = 0;
		this.isWorldStatic = false;
		this.fastTransform = false;
		this.correctNormals = false;
		this.velocity = new h3d_Vector();
		this.go = go;
		this.octree = new octree_Octree();
		this.surfaces = [];
		this.transform = h3d_Matrix.I();
		this.invTransform = h3d_Matrix.I();
	}
	addSurface(surface) {
		if(surface.points.length > 0) {
			this.octree.insert(surface);
			this.surfaces.push(surface);
		}
	}
	finalize() {
		this.generateBoundingBox();
		let bbox = new h3d_col_Bounds();
		let _g = 0;
		let _g1 = this.surfaces;
		while(_g < _g1.length) {
			let surface = _g1[_g];
			++_g;
			let b = surface.boundingBox;
			if(b.xMin < bbox.xMin) {
				bbox.xMin = b.xMin;
			}
			if(b.xMax > bbox.xMax) {
				bbox.xMax = b.xMax;
			}
			if(b.yMin < bbox.yMin) {
				bbox.yMin = b.yMin;
			}
			if(b.yMax > bbox.yMax) {
				bbox.yMax = b.yMax;
			}
			if(b.zMin < bbox.zMin) {
				bbox.zMin = b.zMin;
			}
			if(b.zMax > bbox.zMax) {
				bbox.zMax = b.zMax;
			}
		}
		this.grid = new collision_Grid(bbox);
		let _g2 = 0;
		let _g3 = this.surfaces;
		while(_g2 < _g3.length) {
			let surface = _g3[_g2];
			++_g2;
			this.grid.insert(surface);
		}
		this.grid.build();
	}
	dispose() {
		let _g = 0;
		let _g1 = this.surfaces;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			s.dispose();
		}
		this.go = null;
		this.surfaces = null;
		this.bvh = null;
		this.octree = null;
	}
	setTransform(transform) {
		if(this.transform.equal(transform)) {
			return;
		}
		let tmp;
		if(this.fastTransform) {
			let a = this.transform;
			tmp = a._11 == transform._11 && a._12 == transform._12 && a._13 == transform._13 && a._21 == transform._21 && a._22 == transform._22 && a._23 == transform._23 && a._31 == transform._31 && a._32 == transform._32 && a._33 == transform._33;
		} else {
			tmp = false;
		}
		if(tmp) {
			let _this = this.transform;
			let oldPos_x = 0.;
			let oldPos_y = 0.;
			let oldPos_z = 0.;
			let x = _this._41;
			let y = _this._42;
			let z = _this._43;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			oldPos_x = x;
			oldPos_y = y;
			oldPos_z = z;
			let newPos_x = 0.;
			let newPos_y = 0.;
			let newPos_z = 0.;
			let newPos_w = 1.;
			let x1 = transform._41;
			let y1 = transform._42;
			let z1 = transform._43;
			let w = transform._44;
			if(w == null) {
				w = 1.;
			}
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			newPos_x = x1;
			newPos_y = y1;
			newPos_z = z1;
			newPos_w = w;
			let _this1 = this.transform;
			_this1._41 = newPos_x;
			_this1._42 = newPos_y;
			_this1._43 = newPos_z;
			_this1._44 = newPos_w;
			this.invTransform = this.transform.getInverse();
			if(this.boundingBox == null) {
				this.generateBoundingBox();
			} else {
				this.boundingBox.xMin += newPos_x - oldPos_x;
				this.boundingBox.xMax += newPos_x - oldPos_x;
				this.boundingBox.yMin += newPos_y - oldPos_y;
				this.boundingBox.yMax += newPos_y - oldPos_y;
				this.boundingBox.zMin += newPos_z - oldPos_z;
				this.boundingBox.zMax += newPos_z - oldPos_z;
			}
		} else {
			this.transform.load(transform);
			this.invTransform = transform.getInverse();
			this.generateBoundingBox();
		}
		this._transformKey++;
	}
	generateBoundingBox() {
		let boundingBox = new h3d_col_Bounds();
		let _g = 0;
		let _g1 = this.surfaces;
		while(_g < _g1.length) {
			let surface = _g1[_g];
			++_g;
			let _this = surface.boundingBox;
			let b = new h3d_col_Bounds();
			b.xMin = _this.xMin;
			b.xMax = _this.xMax;
			b.yMin = _this.yMin;
			b.yMax = _this.yMax;
			b.zMin = _this.zMin;
			b.zMax = _this.zMax;
			b.transform(this.transform);
			if(b.xMin < boundingBox.xMin) {
				boundingBox.xMin = b.xMin;
			}
			if(b.xMax > boundingBox.xMax) {
				boundingBox.xMax = b.xMax;
			}
			if(b.yMin < boundingBox.yMin) {
				boundingBox.yMin = b.yMin;
			}
			if(b.yMax > boundingBox.yMax) {
				boundingBox.yMax = b.yMax;
			}
			if(b.zMin < boundingBox.zMin) {
				boundingBox.zMin = b.zMin;
			}
			if(b.zMax > boundingBox.zMax) {
				boundingBox.zMax = b.zMax;
			}
		}
		this.boundingBox = boundingBox;
		if(src_Debug.drawBounds) {
			if(this._dbgEntity == null) {
				this._dbgEntity = this.boundingBox.makeDebugObj();
				this._dbgEntity.getMaterials()[0].passes.set_wireframe(true);
				src_MarbleGame.instance.scene.addChild(this._dbgEntity);
			} else {
				let _this = this._dbgEntity;
				if(_this != null && _this.parent != null) {
					_this.parent.removeChild(_this);
				}
				this._dbgEntity = this.boundingBox.makeDebugObj();
				this._dbgEntity.getMaterials()[0].passes.set_wireframe(true);
				src_MarbleGame.instance.scene.addChild(this._dbgEntity);
			}
		}
	}
	rayCast(rayOrigin,rayDirection,results) {
		let invMatrix = this.invTransform;
		let invTPos = invMatrix.clone();
		invTPos.transpose();
		let rStart = new h3d_Vector(rayOrigin.x,rayOrigin.y,rayOrigin.z,rayOrigin.w);
		let px = rStart.x * invMatrix._11 + rStart.y * invMatrix._21 + rStart.z * invMatrix._31 + rStart.w * invMatrix._41;
		let py = rStart.x * invMatrix._12 + rStart.y * invMatrix._22 + rStart.z * invMatrix._32 + rStart.w * invMatrix._42;
		let pz = rStart.x * invMatrix._13 + rStart.y * invMatrix._23 + rStart.z * invMatrix._33 + rStart.w * invMatrix._43;
		let pw = rStart.x * invMatrix._14 + rStart.y * invMatrix._24 + rStart.z * invMatrix._34 + rStart.w * invMatrix._44;
		rStart.x = px;
		rStart.y = py;
		rStart.z = pz;
		rStart.w = pw;
		let px1 = rayDirection.x * invMatrix._11 + rayDirection.y * invMatrix._21 + rayDirection.z * invMatrix._31;
		let py1 = rayDirection.x * invMatrix._12 + rayDirection.y * invMatrix._22 + rayDirection.z * invMatrix._32;
		let pz1 = rayDirection.x * invMatrix._13 + rayDirection.y * invMatrix._23 + rayDirection.z * invMatrix._33;
		let rDir = new h3d_Vector(px1,py1,pz1);
		let intersections = this.grid.rayCast(rStart,rDir);
		let _g = 0;
		while(_g < intersections.length) {
			let i = intersections[_g];
			++_g;
			let _this = i.point;
			let m = this.transform;
			let px = _this.x * m._11 + _this.y * m._21 + _this.z * m._31 + _this.w * m._41;
			let py = _this.x * m._12 + _this.y * m._22 + _this.z * m._32 + _this.w * m._42;
			let pz = _this.x * m._13 + _this.y * m._23 + _this.z * m._33 + _this.w * m._43;
			let pw = _this.x * m._14 + _this.y * m._24 + _this.z * m._34 + _this.w * m._44;
			_this.x = px;
			_this.y = py;
			_this.z = pz;
			_this.w = pw;
			let _this1 = i.normal;
			let px1 = _this1.x * invTPos._11 + _this1.y * invTPos._21 + _this1.z * invTPos._31;
			let py1 = _this1.x * invTPos._12 + _this1.y * invTPos._22 + _this1.z * invTPos._32;
			let pz1 = _this1.x * invTPos._13 + _this1.y * invTPos._23 + _this1.z * invTPos._33;
			_this1.x = px1;
			_this1.y = py1;
			_this1.z = pz1;
			let _this2 = i.normal;
			let k = _this2.x * _this2.x + _this2.y * _this2.y + _this2.z * _this2.z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			_this2.x *= k;
			_this2.y *= k;
			_this2.z *= k;
			results.push(i);
		}
	}
	getElementType() {
		return 2;
	}
	setPriority(priority) {
		this.priority = priority;
	}
	sphereIntersection(collisionEntity,timeState) {
		let _this = collisionEntity.transform;
		let position_x = 0.;
		let position_y = 0.;
		let position_z = 0.;
		let position_w = 1.;
		let x = _this._41;
		let y = _this._42;
		let z = _this._43;
		let w = _this._44;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		position_x = x;
		position_y = y;
		position_z = z;
		position_w = w;
		let radius = collisionEntity.radius + 0.001;
		let invMatrix = this.invTransform;
		if(((this.go) instanceof src_PathedInterior)) {
			invMatrix = this.transform.getInverse();
		}
		let sphereBounds = new h3d_col_Bounds();
		let x1 = position_x;
		let y1 = position_y;
		let z1 = position_z;
		let w1 = position_w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let localPos_x = x1;
		let localPos_y = y1;
		let localPos_z = z1;
		let localPos_w = w1;
		let px = localPos_x * invMatrix._11 + localPos_y * invMatrix._21 + localPos_z * invMatrix._31 + localPos_w * invMatrix._41;
		let py = localPos_x * invMatrix._12 + localPos_y * invMatrix._22 + localPos_z * invMatrix._32 + localPos_w * invMatrix._42;
		let pz = localPos_x * invMatrix._13 + localPos_y * invMatrix._23 + localPos_z * invMatrix._33 + localPos_w * invMatrix._43;
		localPos_x = px;
		localPos_y = py;
		localPos_z = pz;
		let invScale_x = 0.;
		let invScale_y = 0.;
		let invScale_z = 0.;
		invScale_x = Math.sqrt(invMatrix._11 * invMatrix._11 + invMatrix._12 * invMatrix._12 + invMatrix._13 * invMatrix._13);
		invScale_y = Math.sqrt(invMatrix._21 * invMatrix._21 + invMatrix._22 * invMatrix._22 + invMatrix._23 * invMatrix._23);
		invScale_z = Math.sqrt(invMatrix._31 * invMatrix._31 + invMatrix._32 * invMatrix._32 + invMatrix._33 * invMatrix._33);
		if(invMatrix._11 * (invMatrix._22 * invMatrix._33 - invMatrix._23 * invMatrix._32) + invMatrix._12 * (invMatrix._23 * invMatrix._31 - invMatrix._21 * invMatrix._33) + invMatrix._13 * (invMatrix._21 * invMatrix._32 - invMatrix._22 * invMatrix._31) < 0) {
			invScale_x *= -1;
			invScale_y *= -1;
			invScale_z *= -1;
		}
		let x2 = radius * invScale_x;
		let y2 = radius * invScale_y;
		let z2 = radius * invScale_z;
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let sphereRadius_x = x2;
		let sphereRadius_y = y2;
		let sphereRadius_z = z2;
		let x3 = localPos_x;
		let y3 = localPos_y;
		let z3 = localPos_z;
		let r = Math.max(Math.max(sphereRadius_x,sphereRadius_y),sphereRadius_z) * 1.1;
		if(x3 - r < sphereBounds.xMin) {
			sphereBounds.xMin = x3 - r;
		}
		if(x3 + r > sphereBounds.xMax) {
			sphereBounds.xMax = x3 + r;
		}
		if(y3 - r < sphereBounds.yMin) {
			sphereBounds.yMin = y3 - r;
		}
		if(y3 + r > sphereBounds.yMax) {
			sphereBounds.yMax = y3 + r;
		}
		if(z3 - r < sphereBounds.zMin) {
			sphereBounds.zMin = z3 - r;
		}
		if(z3 + r > sphereBounds.zMax) {
			sphereBounds.zMax = z3 + r;
		}
		let surfaces = this.grid.boundingSearch(sphereBounds);
		let invtform = invMatrix.clone();
		invtform.transpose();
		let tform = this.transform.clone();
		if(this.isWorldStatic) {
			tform.load(h3d_Matrix.I());
			invtform.load(h3d_Matrix.I());
		}
		let contacts = [];
		let _g = 0;
		while(_g < surfaces.length) {
			let obj = surfaces[_g];
			++_g;
			let i = 0;
			while(i < obj.indices.length) {
				let key = this._transformKey;
				if(obj._transformedPoints == null) {
					obj._transformedPoints = obj.points.slice();
				}
				if(obj._transformedNormals == null) {
					obj._transformedNormals = obj.normals.slice();
				}
				let p1 = obj.indices[i];
				let p2 = obj.indices[i + 1];
				let p3 = obj.indices[i + 2];
				if(obj.transformKeys[p1] != key) {
					let x = obj.points[p1 * 3];
					let y = obj.points[p1 * 3 + 1];
					let z = obj.points[p1 * 3 + 2];
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let _this_x = x;
					let _this_y = y;
					let _this_z = z;
					let px = _this_x * tform._11 + _this_y * tform._21 + _this_z * tform._31 + tform._41;
					let py = _this_x * tform._12 + _this_y * tform._22 + _this_z * tform._32 + tform._42;
					let pz = _this_x * tform._13 + _this_y * tform._23 + _this_z * tform._33 + tform._43;
					let x1 = px;
					let y1 = py;
					let z1 = pz;
					if(pz == null) {
						z1 = 0.;
					}
					if(py == null) {
						y1 = 0.;
					}
					if(px == null) {
						x1 = 0.;
					}
					let pt_x = x1;
					let pt_y = y1;
					let pt_z = z1;
					obj._transformedPoints[p1 * 3] = pt_x;
					obj._transformedPoints[p1 * 3 + 1] = pt_y;
					obj._transformedPoints[p1 * 3 + 2] = pt_z;
					let x2 = obj.normals[p1 * 3];
					let y2 = obj.normals[p1 * 3 + 1];
					let z2 = obj.normals[p1 * 3 + 2];
					if(z2 == null) {
						z2 = 0.;
					}
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					let _this_x1 = x2;
					let _this_y1 = y2;
					let _this_z1 = z2;
					let px1 = _this_x1 * invtform._11 + _this_y1 * invtform._21 + _this_z1 * invtform._31;
					let py1 = _this_x1 * invtform._12 + _this_y1 * invtform._22 + _this_z1 * invtform._32;
					let pz1 = _this_x1 * invtform._13 + _this_y1 * invtform._23 + _this_z1 * invtform._33;
					let x3 = px1;
					let y3 = py1;
					let z3 = pz1;
					if(pz1 == null) {
						z3 = 0.;
					}
					if(py1 == null) {
						y3 = 0.;
					}
					if(px1 == null) {
						x3 = 0.;
					}
					let _this_x2 = x3;
					let _this_y2 = y3;
					let _this_z2 = z3;
					let k = _this_x2 * _this_x2 + _this_y2 * _this_y2 + _this_z2 * _this_z2;
					if(k < 1e-10) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					let x4 = _this_x2 * k;
					let y4 = _this_y2 * k;
					let z4 = _this_z2 * k;
					if(z4 == null) {
						z4 = 0.;
					}
					if(y4 == null) {
						y4 = 0.;
					}
					if(x4 == null) {
						x4 = 0.;
					}
					let pn_x = x4;
					let pn_y = y4;
					let pn_z = z4;
					obj._transformedNormals[p1 * 3] = pn_x;
					obj._transformedNormals[p1 * 3 + 1] = pn_y;
					obj._transformedNormals[p1 * 3 + 2] = pn_z;
					obj.transformKeys[p1] = key;
				}
				if(obj.transformKeys[p2] != key) {
					let x = obj.points[p2 * 3];
					let y = obj.points[p2 * 3 + 1];
					let z = obj.points[p2 * 3 + 2];
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let _this_x = x;
					let _this_y = y;
					let _this_z = z;
					let px = _this_x * tform._11 + _this_y * tform._21 + _this_z * tform._31 + tform._41;
					let py = _this_x * tform._12 + _this_y * tform._22 + _this_z * tform._32 + tform._42;
					let pz = _this_x * tform._13 + _this_y * tform._23 + _this_z * tform._33 + tform._43;
					let x1 = px;
					let y1 = py;
					let z1 = pz;
					if(pz == null) {
						z1 = 0.;
					}
					if(py == null) {
						y1 = 0.;
					}
					if(px == null) {
						x1 = 0.;
					}
					let pt_x = x1;
					let pt_y = y1;
					let pt_z = z1;
					obj._transformedPoints[p2 * 3] = pt_x;
					obj._transformedPoints[p2 * 3 + 1] = pt_y;
					obj._transformedPoints[p2 * 3 + 2] = pt_z;
					obj.transformKeys[p2] = key;
				}
				if(obj.transformKeys[p3] != key) {
					let x = obj.points[p3 * 3];
					let y = obj.points[p3 * 3 + 1];
					let z = obj.points[p3 * 3 + 2];
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let _this_x = x;
					let _this_y = y;
					let _this_z = z;
					let px = _this_x * tform._11 + _this_y * tform._21 + _this_z * tform._31 + tform._41;
					let py = _this_x * tform._12 + _this_y * tform._22 + _this_z * tform._32 + tform._42;
					let pz = _this_x * tform._13 + _this_y * tform._23 + _this_z * tform._33 + tform._43;
					let x1 = px;
					let y1 = py;
					let z1 = pz;
					if(pz == null) {
						z1 = 0.;
					}
					if(py == null) {
						y1 = 0.;
					}
					if(px == null) {
						x1 = 0.;
					}
					let pt_x = x1;
					let pt_y = y1;
					let pt_z = z1;
					obj._transformedPoints[p3 * 3] = pt_x;
					obj._transformedPoints[p3 * 3 + 1] = pt_y;
					obj._transformedPoints[p3 * 3 + 2] = pt_z;
					obj.transformKeys[p3] = key;
				}
				let x = obj._transformedPoints[p1 * 3];
				let y = obj._transformedPoints[p1 * 3 + 1];
				let z = obj._transformedPoints[p1 * 3 + 2];
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v1_x = x;
				let v1_y = y;
				let v1_z = z;
				let x1 = obj._transformedPoints[p2 * 3];
				let y1 = obj._transformedPoints[p2 * 3 + 1];
				let z1 = obj._transformedPoints[p2 * 3 + 2];
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let v2_x = x1;
				let v2_y = y1;
				let v2_z = z1;
				let x2 = obj._transformedPoints[p3 * 3];
				let y2 = obj._transformedPoints[p3 * 3 + 1];
				let z2 = obj._transformedPoints[p3 * 3 + 2];
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let v3_x = x2;
				let v3_y = y2;
				let v3_z = z2;
				let x3 = obj._transformedNormals[p1 * 3];
				let y3 = obj._transformedNormals[p1 * 3 + 1];
				let z3 = obj._transformedNormals[p1 * 3 + 2];
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				let n_x = x3;
				let n_y = y3;
				let n_z = z3;
				let x4 = v1_x;
				let y4 = v1_y;
				let z4 = v1_z;
				if(v1_z == null) {
					z4 = 0.;
				}
				if(v1_y == null) {
					y4 = 0.;
				}
				if(v1_x == null) {
					x4 = 0.;
				}
				let v0_x = x4;
				let v0_y = y4;
				let v0_z = z4;
				let x5 = v2_x;
				let y5 = v2_y;
				let z5 = v2_z;
				if(v2_z == null) {
					z5 = 0.;
				}
				if(v2_y == null) {
					y5 = 0.;
				}
				if(v2_x == null) {
					x5 = 0.;
				}
				let v_x = x5;
				let v_y = y5;
				let v_z = z5;
				let x6 = v3_x;
				let y6 = v3_y;
				let z6 = v3_z;
				if(v3_z == null) {
					z6 = 0.;
				}
				if(v3_y == null) {
					y6 = 0.;
				}
				if(v3_x == null) {
					x6 = 0.;
				}
				let v2_x1 = x6;
				let v2_y1 = y6;
				let v2_z1 = z6;
				let x7 = n_x;
				let y7 = n_y;
				let z7 = n_z;
				if(n_z == null) {
					z7 = 0.;
				}
				if(n_y == null) {
					y7 = 0.;
				}
				if(n_x == null) {
					x7 = 0.;
				}
				let surfacenormal_x = x7;
				let surfacenormal_y = y7;
				let surfacenormal_z = z7;
				if(this.correctNormals) {
					let x = v_x - v0_x;
					let y = v_y - v0_y;
					let z = v_z - v0_z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let _this_x = x;
					let _this_y = y;
					let _this_z = z;
					let x1 = v2_x1 - v0_x;
					let y1 = v2_y1 - v0_y;
					let z1 = v2_z1 - v0_z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let v_x1 = x1;
					let v_y1 = y1;
					let v_z1 = z1;
					let x2 = _this_y * v_z1 - _this_z * v_y1;
					let y2 = _this_z * v_x1 - _this_x * v_z1;
					let z2 = _this_x * v_y1 - _this_y * v_x1;
					if(z2 == null) {
						z2 = 0.;
					}
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					let _this_x1 = x2;
					let _this_y1 = y2;
					let _this_z1 = z2;
					let k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
					if(k < 1e-10) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					let x3 = _this_x1 * k;
					let y3 = _this_y1 * k;
					let z3 = _this_z1 * k;
					if(z3 == null) {
						z3 = 0.;
					}
					if(y3 == null) {
						y3 = 0.;
					}
					if(x3 == null) {
						x3 = 0.;
					}
					let _this_x2 = x3;
					let _this_y2 = y3;
					let _this_z2 = z3;
					let x4 = _this_x2 * -1;
					let y4 = _this_y2 * -1;
					let z4 = _this_z2 * -1;
					if(z4 == null) {
						z4 = 0.;
					}
					if(y4 == null) {
						y4 = 0.;
					}
					if(x4 == null) {
						x4 = 0.;
					}
					let vn_x = x4;
					let vn_y = y4;
					let vn_z = z4;
					let vdot = vn_x * surfacenormal_x + vn_y * surfacenormal_y + vn_z * surfacenormal_z;
					if(vdot < 0.95) {
						let x = v3_x;
						let y = v3_y;
						let z = v3_z;
						if(v3_z == null) {
							z = 0.;
						}
						if(v3_y == null) {
							y = 0.;
						}
						if(v3_x == null) {
							x = 0.;
						}
						v_x = x;
						v_y = y;
						v_z = z;
						let x1 = v2_x;
						let y1 = v2_y;
						let z1 = v2_z;
						if(v2_z == null) {
							z1 = 0.;
						}
						if(v2_y == null) {
							y1 = 0.;
						}
						if(v2_x == null) {
							x1 = 0.;
						}
						v2_x1 = x1;
						v2_y1 = y1;
						v2_z1 = z1;
						surfacenormal_x = vn_x;
						surfacenormal_y = vn_y;
						surfacenormal_z = vn_z;
					}
				}
				let closest_x = 0.;
				let closest_y = 0.;
				let closest_z = 0.;
				let closest_w = 1.;
				let normal_x = 0.;
				let normal_y = 0.;
				let normal_z = 0.;
				let x8 = v0_x - position_x;
				let y8 = v0_y - position_y;
				let z8 = v0_z - position_z;
				let w = 1. - position_w;
				if(w == null) {
					w = 1.;
				}
				if(z8 == null) {
					z8 = 0.;
				}
				if(y8 == null) {
					y8 = 0.;
				}
				if(x8 == null) {
					x8 = 0.;
				}
				let A_x = x8;
				let A_y = y8;
				let A_z = z8;
				let A_w = w;
				let x9 = v_x - position_x;
				let y9 = v_y - position_y;
				let z9 = v_z - position_z;
				let w1 = 1. - position_w;
				if(w1 == null) {
					w1 = 1.;
				}
				if(z9 == null) {
					z9 = 0.;
				}
				if(y9 == null) {
					y9 = 0.;
				}
				if(x9 == null) {
					x9 = 0.;
				}
				let B_x = x9;
				let B_y = y9;
				let B_z = z9;
				let B_w = w1;
				let x10 = v2_x1 - position_x;
				let y10 = v2_y1 - position_y;
				let z10 = v2_z1 - position_z;
				let w2 = 1. - position_w;
				if(w2 == null) {
					w2 = 1.;
				}
				if(z10 == null) {
					z10 = 0.;
				}
				if(y10 == null) {
					y10 = 0.;
				}
				if(x10 == null) {
					x10 = 0.;
				}
				let C_x = x10;
				let C_y = y10;
				let C_z = z10;
				let C_w = w2;
				let x11 = C_x - A_x;
				let y11 = C_y - A_y;
				let z11 = C_z - A_z;
				if(z11 == null) {
					z11 = 0.;
				}
				if(y11 == null) {
					y11 = 0.;
				}
				if(x11 == null) {
					x11 = 0.;
				}
				let ca_x = x11;
				let ca_y = y11;
				let ca_z = z11;
				let x12 = B_x - A_x;
				let y12 = B_y - A_y;
				let z12 = B_z - A_z;
				let w3 = B_w - A_w;
				if(w3 == null) {
					w3 = 1.;
				}
				if(z12 == null) {
					z12 = 0.;
				}
				if(y12 == null) {
					y12 = 0.;
				}
				if(x12 == null) {
					x12 = 0.;
				}
				let ba_x = x12;
				let ba_y = y12;
				let ba_z = z12;
				let ba_w = w3;
				let radiusSq = radius * radius;
				let x13 = ba_y * ca_z - ba_z * ca_y;
				let y13 = ba_z * ca_x - ba_x * ca_z;
				let z13 = ba_x * ca_y - ba_y * ca_x;
				if(z13 == null) {
					z13 = 0.;
				}
				if(y13 == null) {
					y13 = 0.;
				}
				if(x13 == null) {
					x13 = 0.;
				}
				let cp_x = x13;
				let cp_y = y13;
				let cp_z = z13;
				let aDotCp = A_x * cp_x + A_y * cp_y + A_z * cp_z;
				let cpLenSq = cp_x * cp_x + cp_y * cp_y + cp_z * cp_z;
				let res;
				if(aDotCp * aDotCp > radiusSq * cpLenSq) {
					res = false;
				} else {
					let aSq = A_x * A_x + A_y * A_y + A_z * A_z;
					let aDotB = A_x * B_x + A_y * B_y + A_z * B_z;
					let aDotC = A_x * C_x + A_y * C_y + A_z * C_z;
					let bSq = B_x * B_x + B_y * B_y + B_z * B_z;
					let bDotC = B_x * C_x + B_y * C_y + B_z * C_z;
					let cSq = C_x * C_x + C_y * C_y + C_z * C_z;
					if(aSq > radiusSq && aDotB > aSq && aDotC > aSq) {
						res = false;
					} else if(bSq > radiusSq && aDotB > bSq && bDotC > bSq) {
						res = false;
					} else if(cSq > radiusSq && aDotC > cSq && bDotC > cSq) {
						res = false;
					} else {
						let x = C_x - B_x;
						let y = C_y - B_y;
						let z = C_z - B_z;
						let w = C_w - B_w;
						if(w == null) {
							w = 1.;
						}
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let cSubB_x = x;
						let cSubB_y = y;
						let cSubB_z = z;
						let cSubB_w = w;
						let x1 = A_x - C_x;
						let y1 = A_y - C_y;
						let z1 = A_z - C_z;
						let w1 = A_w - C_w;
						if(w1 == null) {
							w1 = 1.;
						}
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let aSubC_x = x1;
						let aSubC_y = y1;
						let aSubC_z = z1;
						let aSubC_w = w1;
						let baSq = ba_x * ba_x + ba_y * ba_y + ba_z * ba_z;
						let cSubBSq = cSubB_x * cSubB_x + cSubB_y * cSubB_y + cSubB_z * cSubB_z;
						let aSubCSq = aSubC_x * aSubC_x + aSubC_y * aSubC_y + aSubC_z * aSubC_z;
						let x2 = A_x * baSq;
						let y2 = A_y * baSq;
						let z2 = A_z * baSq;
						let w2 = A_w;
						if(A_w == null) {
							w2 = 1.;
						}
						if(z2 == null) {
							z2 = 0.;
						}
						if(y2 == null) {
							y2 = 0.;
						}
						if(x2 == null) {
							x2 = 0.;
						}
						let _this_x = x2;
						let _this_y = y2;
						let _this_z = z2;
						let _this_w = w2;
						let v = aDotB - aSq;
						let x3 = ba_x * v;
						let y3 = ba_y * v;
						let z3 = ba_z * v;
						let w3 = ba_w;
						if(ba_w == null) {
							w3 = 1.;
						}
						if(z3 == null) {
							z3 = 0.;
						}
						if(y3 == null) {
							y3 = 0.;
						}
						if(x3 == null) {
							x3 = 0.;
						}
						let v_x1 = x3;
						let v_y1 = y3;
						let v_z1 = z3;
						let v_w = w3;
						let x4 = _this_x - v_x1;
						let y4 = _this_y - v_y1;
						let z4 = _this_z - v_z1;
						let w4 = _this_w - v_w;
						if(w4 == null) {
							w4 = 1.;
						}
						if(z4 == null) {
							z4 = 0.;
						}
						if(y4 == null) {
							y4 = 0.;
						}
						if(x4 == null) {
							x4 = 0.;
						}
						let aTest_x = x4;
						let aTest_y = y4;
						let aTest_z = z4;
						let x5 = B_x * cSubBSq;
						let y5 = B_y * cSubBSq;
						let z5 = B_z * cSubBSq;
						let w5 = B_w;
						if(B_w == null) {
							w5 = 1.;
						}
						if(z5 == null) {
							z5 = 0.;
						}
						if(y5 == null) {
							y5 = 0.;
						}
						if(x5 == null) {
							x5 = 0.;
						}
						let _this_x1 = x5;
						let _this_y1 = y5;
						let _this_z1 = z5;
						let _this_w1 = w5;
						let v1 = bDotC - bSq;
						let x6 = cSubB_x * v1;
						let y6 = cSubB_y * v1;
						let z6 = cSubB_z * v1;
						let w6 = cSubB_w;
						if(cSubB_w == null) {
							w6 = 1.;
						}
						if(z6 == null) {
							z6 = 0.;
						}
						if(y6 == null) {
							y6 = 0.;
						}
						if(x6 == null) {
							x6 = 0.;
						}
						let v_x2 = x6;
						let v_y2 = y6;
						let v_z2 = z6;
						let v_w1 = w6;
						let x7 = _this_x1 - v_x2;
						let y7 = _this_y1 - v_y2;
						let z7 = _this_z1 - v_z2;
						let w7 = _this_w1 - v_w1;
						if(w7 == null) {
							w7 = 1.;
						}
						if(z7 == null) {
							z7 = 0.;
						}
						if(y7 == null) {
							y7 = 0.;
						}
						if(x7 == null) {
							x7 = 0.;
						}
						let bTest_x = x7;
						let bTest_y = y7;
						let bTest_z = z7;
						let x8 = C_x * aSubCSq;
						let y8 = C_y * aSubCSq;
						let z8 = C_z * aSubCSq;
						let w8 = C_w;
						if(C_w == null) {
							w8 = 1.;
						}
						if(z8 == null) {
							z8 = 0.;
						}
						if(y8 == null) {
							y8 = 0.;
						}
						if(x8 == null) {
							x8 = 0.;
						}
						let _this_x2 = x8;
						let _this_y2 = y8;
						let _this_z2 = z8;
						let _this_w2 = w8;
						let v2 = aDotC - cSq;
						let x9 = aSubC_x * v2;
						let y9 = aSubC_y * v2;
						let z9 = aSubC_z * v2;
						let w9 = aSubC_w;
						if(aSubC_w == null) {
							w9 = 1.;
						}
						if(z9 == null) {
							z9 = 0.;
						}
						if(y9 == null) {
							y9 = 0.;
						}
						if(x9 == null) {
							x9 = 0.;
						}
						let v_x3 = x9;
						let v_y3 = y9;
						let v_z3 = z9;
						let v_w2 = w9;
						let x10 = _this_x2 - v_x3;
						let y10 = _this_y2 - v_y3;
						let z10 = _this_z2 - v_z3;
						let w10 = _this_w2 - v_w2;
						if(w10 == null) {
							w10 = 1.;
						}
						if(z10 == null) {
							z10 = 0.;
						}
						if(y10 == null) {
							y10 = 0.;
						}
						if(x10 == null) {
							x10 = 0.;
						}
						let cTest_x = x10;
						let cTest_y = y10;
						let cTest_z = z10;
						let x11 = C_x * baSq;
						let y11 = C_y * baSq;
						let z11 = C_z * baSq;
						let w11 = C_w;
						if(C_w == null) {
							w11 = 1.;
						}
						if(z11 == null) {
							z11 = 0.;
						}
						if(y11 == null) {
							y11 = 0.;
						}
						if(x11 == null) {
							x11 = 0.;
						}
						let _this_x3 = x11;
						let _this_y3 = y11;
						let _this_z3 = z11;
						let x12 = _this_x3 - aTest_x;
						let y12 = _this_y3 - aTest_y;
						let z12 = _this_z3 - aTest_z;
						if(z12 == null) {
							z12 = 0.;
						}
						if(y12 == null) {
							y12 = 0.;
						}
						if(x12 == null) {
							x12 = 0.;
						}
						let rhs_x = x12;
						let rhs_y = y12;
						let rhs_z = z12;
						let x13 = A_x * cSubBSq;
						let y13 = A_y * cSubBSq;
						let z13 = A_z * cSubBSq;
						let w12 = A_w;
						if(A_w == null) {
							w12 = 1.;
						}
						if(z13 == null) {
							z13 = 0.;
						}
						if(y13 == null) {
							y13 = 0.;
						}
						if(x13 == null) {
							x13 = 0.;
						}
						let _this_x4 = x13;
						let _this_y4 = y13;
						let _this_z4 = z13;
						let x14 = _this_x4 - bTest_x;
						let y14 = _this_y4 - bTest_y;
						let z14 = _this_z4 - bTest_z;
						if(z14 == null) {
							z14 = 0.;
						}
						if(y14 == null) {
							y14 = 0.;
						}
						if(x14 == null) {
							x14 = 0.;
						}
						let rhs2_x = x14;
						let rhs2_y = y14;
						let rhs2_z = z14;
						let x15 = B_x * aSubCSq;
						let y15 = B_y * aSubCSq;
						let z15 = B_z * aSubCSq;
						let w13 = B_w;
						if(B_w == null) {
							w13 = 1.;
						}
						if(z15 == null) {
							z15 = 0.;
						}
						if(y15 == null) {
							y15 = 0.;
						}
						if(x15 == null) {
							x15 = 0.;
						}
						let _this_x5 = x15;
						let _this_y5 = y15;
						let _this_z5 = z15;
						let x16 = _this_x5 - cTest_x;
						let y16 = _this_y5 - cTest_y;
						let z16 = _this_z5 - cTest_z;
						if(z16 == null) {
							z16 = 0.;
						}
						if(y16 == null) {
							y16 = 0.;
						}
						if(x16 == null) {
							x16 = 0.;
						}
						let rhs3_x = x16;
						let rhs3_y = y16;
						let rhs3_z = z16;
						if(aTest_x * aTest_x + aTest_y * aTest_y + aTest_z * aTest_z > radiusSq * baSq * baSq && aTest_x * rhs_x + aTest_y * rhs_y + aTest_z * rhs_z > 0) {
							res = false;
						} else if(bTest_x * bTest_x + bTest_y * bTest_y + bTest_z * bTest_z > radiusSq * cSubBSq * cSubBSq && bTest_x * rhs2_x + bTest_y * rhs2_y + bTest_z * rhs2_z > 0) {
							res = false;
						} else if(cTest_x * cTest_x + cTest_y * cTest_y + cTest_z * cTest_z > radiusSq * aSubCSq * aSubCSq && cTest_x * rhs3_x + cTest_y * rhs3_y + cTest_z * rhs3_z > 0) {
							res = false;
						} else {
							let x = position_x - v0_x;
							let y = position_y - v0_y;
							let z = position_z - v0_z;
							if(z == null) {
								z = 0.;
							}
							if(y == null) {
								y = 0.;
							}
							if(x == null) {
								x = 0.;
							}
							let lhs_x = x;
							let lhs_y = y;
							let lhs_z = z;
							let baca = ba_x * ca_x + ba_y * ca_y + ba_z * ca_z;
							let caSq = ca_x * ca_x + ca_y * ca_y + ca_z * ca_z;
							let lhsBa = lhs_x * ba_x + lhs_y * ba_y + lhs_z * ba_z;
							let lhsCa = lhs_x * ca_x + lhs_y * ca_y + lhs_z * ca_z;
							let len = baSq * caSq - baca * baca;
							let d1 = (caSq * lhsBa - baca * lhsCa) / len;
							let d2 = (baSq * lhsCa - baca * lhsBa) / len;
							if(1 - d1 - d2 >= 0 && d1 >= 0 && d2 >= 0) {
								normal_x = surfacenormal_x;
								normal_y = surfacenormal_y;
								normal_z = surfacenormal_z;
								let x = position_x - v0_x;
								let y = position_y - v0_y;
								let z = position_z - v0_z;
								if(z == null) {
									z = 0.;
								}
								if(y == null) {
									y = 0.;
								}
								if(x == null) {
									x = 0.;
								}
								let _this_x = x;
								let _this_y = y;
								let _this_z = z;
								let v = _this_x * surfacenormal_x + _this_y * surfacenormal_y + _this_z * surfacenormal_z;
								let x1 = surfacenormal_x * v;
								let y1 = surfacenormal_y * v;
								let z1 = surfacenormal_z * v;
								if(z1 == null) {
									z1 = 0.;
								}
								if(y1 == null) {
									y1 = 0.;
								}
								if(x1 == null) {
									x1 = 0.;
								}
								let v_x = x1;
								let v_y = y1;
								let v_z = z1;
								let x2 = position_x - v_x;
								let y2 = position_y - v_y;
								let z2 = position_z - v_z;
								let w = position_w - 1.;
								if(w == null) {
									w = 1.;
								}
								if(z2 == null) {
									z2 = 0.;
								}
								if(y2 == null) {
									y2 = 0.;
								}
								if(x2 == null) {
									x2 = 0.;
								}
								let v_x1 = x2;
								let v_y1 = y2;
								let v_z1 = z2;
								let v_w = w;
								closest_x = v_x1;
								closest_y = v_y1;
								closest_z = v_z1;
								closest_w = v_w;
								res = true;
							} else {
								let x = position_x - v0_x;
								let y = position_y - v0_y;
								let z = position_z - v0_z;
								if(z == null) {
									z = 0.;
								}
								if(y == null) {
									y = 0.;
								}
								if(x == null) {
									x = 0.;
								}
								let _this_x = x;
								let _this_y = y;
								let _this_z = z;
								let v = _this_x * surfacenormal_x + _this_y * surfacenormal_y + _this_z * surfacenormal_z;
								let x1 = surfacenormal_x * v;
								let y1 = surfacenormal_y * v;
								let z1 = surfacenormal_z * v;
								if(z1 == null) {
									z1 = 0.;
								}
								if(y1 == null) {
									y1 = 0.;
								}
								if(x1 == null) {
									x1 = 0.;
								}
								let v_x1 = x1;
								let v_y1 = y1;
								let v_z1 = z1;
								let x2 = position_x - v_x1;
								let y2 = position_y - v_y1;
								let z2 = position_z - v_z1;
								let w = position_w - 1.;
								if(w == null) {
									w = 1.;
								}
								if(z2 == null) {
									z2 = 0.;
								}
								if(y2 == null) {
									y2 = 0.;
								}
								if(x2 == null) {
									x2 = 0.;
								}
								let closestPt_x = x2;
								let closestPt_y = y2;
								let closestPt_z = z2;
								let x3 = v_x - v0_x;
								let y3 = v_y - v0_y;
								let z3 = v_z - v0_z;
								if(z3 == null) {
									z3 = 0.;
								}
								if(y3 == null) {
									y3 = 0.;
								}
								if(x3 == null) {
									x3 = 0.;
								}
								let d_x = x3;
								let d_y = y3;
								let d_z = z3;
								let x4 = closestPt_x - v0_x;
								let y4 = closestPt_y - v0_y;
								let z4 = closestPt_z - v0_z;
								if(z4 == null) {
									z4 = 0.;
								}
								if(y4 == null) {
									y4 = 0.;
								}
								if(x4 == null) {
									x4 = 0.;
								}
								let v_x2 = x4;
								let v_y2 = y4;
								let v_z2 = z4;
								let t = (v_x2 * d_x + v_y2 * d_y + v_z2 * d_z) / (d_x * d_x + d_y * d_y + d_z * d_z);
								if(t < 0) {
									t = 0;
								}
								if(t > 1) {
									t = 1;
								}
								let x5 = d_x * t;
								let y5 = d_y * t;
								let z5 = d_z * t;
								if(z5 == null) {
									z5 = 0.;
								}
								if(y5 == null) {
									y5 = 0.;
								}
								if(x5 == null) {
									x5 = 0.;
								}
								let v_x3 = x5;
								let v_y3 = y5;
								let v_z3 = z5;
								let x6 = v0_x + v_x3;
								let y6 = v0_y + v_y3;
								let z6 = v0_z + v_z3;
								if(z6 == null) {
									z6 = 0.;
								}
								if(y6 == null) {
									y6 = 0.;
								}
								if(x6 == null) {
									x6 = 0.;
								}
								let r1_x = x6;
								let r1_y = y6;
								let r1_z = z6;
								let x7 = v2_x1 - v_x;
								let y7 = v2_y1 - v_y;
								let z7 = v2_z1 - v_z;
								if(z7 == null) {
									z7 = 0.;
								}
								if(y7 == null) {
									y7 = 0.;
								}
								if(x7 == null) {
									x7 = 0.;
								}
								let d_x1 = x7;
								let d_y1 = y7;
								let d_z1 = z7;
								let x8 = closestPt_x - v_x;
								let y8 = closestPt_y - v_y;
								let z8 = closestPt_z - v_z;
								if(z8 == null) {
									z8 = 0.;
								}
								if(y8 == null) {
									y8 = 0.;
								}
								if(x8 == null) {
									x8 = 0.;
								}
								let v_x4 = x8;
								let v_y4 = y8;
								let v_z4 = z8;
								let t1 = (v_x4 * d_x1 + v_y4 * d_y1 + v_z4 * d_z1) / (d_x1 * d_x1 + d_y1 * d_y1 + d_z1 * d_z1);
								if(t1 < 0) {
									t1 = 0;
								}
								if(t1 > 1) {
									t1 = 1;
								}
								let x9 = d_x1 * t1;
								let y9 = d_y1 * t1;
								let z9 = d_z1 * t1;
								if(z9 == null) {
									z9 = 0.;
								}
								if(y9 == null) {
									y9 = 0.;
								}
								if(x9 == null) {
									x9 = 0.;
								}
								let v_x5 = x9;
								let v_y5 = y9;
								let v_z5 = z9;
								let x10 = v_x + v_x5;
								let y10 = v_y + v_y5;
								let z10 = v_z + v_z5;
								if(z10 == null) {
									z10 = 0.;
								}
								if(y10 == null) {
									y10 = 0.;
								}
								if(x10 == null) {
									x10 = 0.;
								}
								let r2_x = x10;
								let r2_y = y10;
								let r2_z = z10;
								let x11 = v0_x - v2_x1;
								let y11 = v0_y - v2_y1;
								let z11 = v0_z - v2_z1;
								if(z11 == null) {
									z11 = 0.;
								}
								if(y11 == null) {
									y11 = 0.;
								}
								if(x11 == null) {
									x11 = 0.;
								}
								let d_x2 = x11;
								let d_y2 = y11;
								let d_z2 = z11;
								let x12 = closestPt_x - v2_x1;
								let y12 = closestPt_y - v2_y1;
								let z12 = closestPt_z - v2_z1;
								if(z12 == null) {
									z12 = 0.;
								}
								if(y12 == null) {
									y12 = 0.;
								}
								if(x12 == null) {
									x12 = 0.;
								}
								let v_x6 = x12;
								let v_y6 = y12;
								let v_z6 = z12;
								let t2 = (v_x6 * d_x2 + v_y6 * d_y2 + v_z6 * d_z2) / (d_x2 * d_x2 + d_y2 * d_y2 + d_z2 * d_z2);
								if(t2 < 0) {
									t2 = 0;
								}
								if(t2 > 1) {
									t2 = 1;
								}
								let x13 = d_x2 * t2;
								let y13 = d_y2 * t2;
								let z13 = d_z2 * t2;
								if(z13 == null) {
									z13 = 0.;
								}
								if(y13 == null) {
									y13 = 0.;
								}
								if(x13 == null) {
									x13 = 0.;
								}
								let v_x7 = x13;
								let v_y7 = y13;
								let v_z7 = z13;
								let x14 = v2_x1 + v_x7;
								let y14 = v2_y1 + v_y7;
								let z14 = v2_z1 + v_z7;
								if(z14 == null) {
									z14 = 0.;
								}
								if(y14 == null) {
									y14 = 0.;
								}
								if(x14 == null) {
									x14 = 0.;
								}
								let r3_x = x14;
								let r3_y = y14;
								let r3_z = z14;
								let chosenPt_x = 0.;
								let chosenPt_y = 0.;
								let chosenPt_z = 0.;
								let dx = position_x - r1_x;
								let dy = position_y - r1_y;
								let dz = position_z - r1_z;
								let dx1 = position_x - r2_x;
								let dy1 = position_y - r2_y;
								let dz1 = position_z - r2_z;
								if(dx * dx + dy * dy + dz * dz < dx1 * dx1 + dy1 * dy1 + dz1 * dz1) {
									chosenPt_x = r1_x;
									chosenPt_y = r1_y;
									chosenPt_z = r1_z;
								} else {
									chosenPt_x = r2_x;
									chosenPt_y = r2_y;
									chosenPt_z = r2_z;
								}
								let dx2 = position_x - chosenPt_x;
								let dy2 = position_y - chosenPt_y;
								let dz2 = position_z - chosenPt_z;
								let dx3 = position_x - r3_x;
								let dy3 = position_y - r3_y;
								let dz3 = position_z - r3_z;
								if(dx2 * dx2 + dy2 * dy2 + dz2 * dz2 < dx3 * dx3 + dy3 * dy3 + dz3 * dz3) {
									closest_x = chosenPt_x;
									closest_y = chosenPt_y;
									closest_z = chosenPt_z;
									closest_w = 1.;
								} else {
									closest_x = r3_x;
									closest_y = r3_y;
									closest_z = r3_z;
									closest_w = 1.;
								}
								let x15 = position_x - closest_x;
								let y15 = position_y - closest_y;
								let z15 = position_z - closest_z;
								if(z15 == null) {
									z15 = 0.;
								}
								if(y15 == null) {
									y15 = 0.;
								}
								if(x15 == null) {
									x15 = 0.;
								}
								let _this_x1 = x15;
								let _this_y1 = y15;
								let _this_z1 = z15;
								let k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
								if(k < 1e-10) {
									k = 0;
								} else {
									k = 1. / Math.sqrt(k);
								}
								let x16 = _this_x1 * k;
								let y16 = _this_y1 * k;
								let z16 = _this_z1 * k;
								if(z16 == null) {
									z16 = 0.;
								}
								if(y16 == null) {
									y16 = 0.;
								}
								if(x16 == null) {
									x16 = 0.;
								}
								let v_x8 = x16;
								let v_y8 = y16;
								let v_z8 = z16;
								normal_x = v_x8;
								normal_y = v_y8;
								normal_z = v_z8;
								res = true;
							}
						}
					}
				}
				if(res) {
					let dx = position_x - closest_x;
					let dy = position_y - closest_y;
					let dz = position_z - closest_z;
					let contactDist = dx * dx + dy * dy + dz * dz;
					if(contactDist <= radius * radius) {
						let x = position_x - closest_x;
						let y = position_y - closest_y;
						let z = position_z - closest_z;
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let _this_x = x;
						let _this_y = y;
						let _this_z = z;
						if(_this_x * surfacenormal_x + _this_y * surfacenormal_y + _this_z * surfacenormal_z > 0) {
							let k = normal_x * normal_x + normal_y * normal_y + normal_z * normal_z;
							if(k < 1e-10) {
								k = 0;
							} else {
								k = 1. / Math.sqrt(k);
							}
							normal_x *= k;
							normal_y *= k;
							normal_z *= k;
							let cinfo = collision_CollisionPool.alloc();
							let _this = cinfo.normal;
							_this.x = normal_x;
							_this.y = normal_y;
							_this.z = normal_z;
							_this.w = 1.;
							let _this1 = cinfo.point;
							_this1.x = closest_x;
							_this1.y = closest_y;
							_this1.z = closest_z;
							_this1.w = closest_w;
							cinfo.collider = null;
							let _this2 = cinfo.velocity;
							let v = this.velocity;
							_this2.x = v.x;
							_this2.y = v.y;
							_this2.z = v.z;
							_this2.w = v.w;
							cinfo.contactDistance = Math.sqrt(contactDist);
							cinfo.otherObject = this.go;
							cinfo.restitution = obj.restitution;
							cinfo.force = obj.force;
							cinfo.friction = obj.friction;
							contacts.push(cinfo);
							if(this.go != null) {
								this.go.onMarbleContact(collisionEntity.marble,timeState,cinfo);
							}
						}
					}
				}
				i += 3;
			}
		}
		return contacts;
	}
}
$hxClasses["collision.CollisionEntity"] = collision_CollisionEntity;
collision_CollisionEntity.__name__ = "collision.CollisionEntity";
collision_CollisionEntity.__interfaces__ = [collision_IBVHObject,octree_IOctreeObject];
Object.assign(collision_CollisionEntity.prototype, {
	__class__: collision_CollisionEntity
	,boundingBox: null
	,octree: null
	,bvh: null
	,grid: null
	,surfaces: null
	,priority: null
	,velocity: null
	,transform: null
	,invTransform: null
	,go: null
	,correctNormals: null
	,userData: null
	,fastTransform: null
	,isWorldStatic: null
	,_transformKey: null
	,_dbgEntity: null
});
class collision_BoxCollisionEntity extends collision_CollisionEntity {
	constructor(bounds,go) {
		super(go);
		this.bounds = bounds;
		this.generateBoundingBox();
	}
	generateBoundingBox() {
		let _this = this.bounds;
		let b = new h3d_col_Bounds();
		b.xMin = _this.xMin;
		b.xMax = _this.xMax;
		b.yMin = _this.yMin;
		b.yMax = _this.yMax;
		b.zMin = _this.zMin;
		b.zMax = _this.zMax;
		this.boundingBox = b;
		this.boundingBox.transform(this.transform);
		if(src_Debug.drawBounds) {
			if(this._dbgEntity == null) {
				this._dbgEntity = this.boundingBox.makeDebugObj();
				this._dbgEntity.getMaterials()[0].passes.set_wireframe(true);
				src_MarbleGame.instance.scene.addChild(this._dbgEntity);
			} else {
				this._dbgEntity = this.boundingBox.makeDebugObj();
				this._dbgEntity.getMaterials()[0].passes.set_wireframe(true);
				src_MarbleGame.instance.scene.addChild(this._dbgEntity);
			}
		}
	}
	setTransform(transform) {
		super.setTransform(transform);
		if(src_Debug.drawBounds) {
			if(this._dbgEntity != null) {
				this._dbgEntity = this.boundingBox.makeDebugObj();
				this._dbgEntity.getMaterials()[0].passes.set_wireframe(true);
				src_MarbleGame.instance.scene.addChild(this._dbgEntity);
			}
		}
	}
	rayCast(rayOrigin,rayDirection,results) {
	}
	sphereIntersection(collisionEntity,timeState) {
		return [];
	}
}
$hxClasses["collision.BoxCollisionEntity"] = collision_BoxCollisionEntity;
collision_BoxCollisionEntity.__name__ = "collision.BoxCollisionEntity";
collision_BoxCollisionEntity.__interfaces__ = [collision_IBVHObject];
collision_BoxCollisionEntity.__super__ = collision_CollisionEntity;
Object.assign(collision_BoxCollisionEntity.prototype, {
	__class__: collision_BoxCollisionEntity
	,bounds: null
});
class collision_Collision {
	static capsuleSphereNearestOverlap(a0,a1,radA,b,radB) {
		let x = a1.x - a0.x;
		let y = a1.y - a0.y;
		let z = a1.z - a0.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let V_x = x;
		let V_y = y;
		let V_z = z;
		let x1 = a0.x - b.x;
		let y1 = a0.y - b.y;
		let z1 = a0.z - b.z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let A0B_x = x1;
		let A0B_y = y1;
		let A0B_z = z1;
		let d1 = A0B_x * V_x + A0B_y * V_y + A0B_z * V_z;
		let d2 = A0B_x * A0B_x + A0B_y * A0B_y + A0B_z * A0B_z;
		let d3 = V_x * V_x + V_y * V_y + V_z * V_z;
		let R2 = (radA + radB) * (radA + radB);
		if(d2 < R2) {
			return { result : true, t : 0.0};
		}
		if(d3 < 0.01) {
			return { result : false, t : 0.0};
		}
		let b24ac = Math.sqrt(d1 * d1 - d2 * d3 + d3 * R2);
		let t1 = (-d1 - b24ac) / d3;
		if(t1 > 0 && t1 < 1.0) {
			return { result : true, t : t1};
		}
		let t2 = (-d1 + b24ac) / d3;
		if(t2 > 0 && t2 < 1.0) {
			return { result : true, t : t2};
		}
		if(t1 < 0 && t2 > 0) {
			return { result : true, t : 0.0};
		}
		return { result : false, t : 0.0};
	}
}
$hxClasses["collision.Collision"] = collision_Collision;
collision_Collision.__name__ = "collision.Collision";
class collision_CollisionInfo {
	constructor() {
		this.velocity = new h3d_Vector();
		this.normal = new h3d_Vector();
		this.point = new h3d_Vector();
	}
}
$hxClasses["collision.CollisionInfo"] = collision_CollisionInfo;
collision_CollisionInfo.__name__ = "collision.CollisionInfo";
Object.assign(collision_CollisionInfo.prototype, {
	__class__: collision_CollisionInfo
	,point: null
	,normal: null
	,velocity: null
	,collider: null
	,otherObject: null
	,friction: null
	,normalForce: null
	,restitution: null
	,contactDistance: null
	,force: null
});
class collision_CollisionPool {
	static alloc() {
		if(collision_CollisionPool.pool.length <= collision_CollisionPool.currentPtr) {
			collision_CollisionPool.pool.push(new collision_CollisionInfo());
		}
		return collision_CollisionPool.pool[collision_CollisionPool.currentPtr++];
	}
	static clear() {
		collision_CollisionPool.currentPtr = 0;
	}
	static freeMemory() {
		collision_CollisionPool.pool = [];
	}
}
$hxClasses["collision.CollisionPool"] = collision_CollisionPool;
collision_CollisionPool.__name__ = "collision.CollisionPool";
class collision_CollisionSurface {
	constructor() {
		this.key = 0;
		this.force = 0;
		this.restitution = 1;
		this.friction = 1;
	}
	getElementType() {
		return 2;
	}
	generateBoundingBox() {
		let boundingBox = new h3d_col_Bounds();
		boundingBox.xMin = 10e8;
		boundingBox.yMin = 10e8;
		boundingBox.zMin = 10e8;
		boundingBox.xMax = -10e8;
		boundingBox.yMax = -10e8;
		boundingBox.zMax = -10e8;
		let _g = 0;
		let _g1 = this.points.length / 3 | 0;
		while(_g < _g1) {
			let i = _g++;
			let x = this.points[i * 3];
			let y = this.points[i * 3 + 1];
			let z = this.points[i * 3 + 2];
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let point_x = x;
			let point_y = y;
			let point_z = z;
			if(point_x > boundingBox.xMax) {
				boundingBox.xMax = point_x;
			}
			if(point_x < boundingBox.xMin) {
				boundingBox.xMin = point_x;
			}
			if(point_y > boundingBox.yMax) {
				boundingBox.yMax = point_y;
			}
			if(point_y < boundingBox.yMin) {
				boundingBox.yMin = point_y;
			}
			if(point_z > boundingBox.zMax) {
				boundingBox.zMax = point_z;
			}
			if(point_z < boundingBox.zMin) {
				boundingBox.zMin = point_z;
			}
		}
		this.boundingBox = boundingBox;
	}
	setPriority(priority) {
		this.priority = priority;
	}
	rayCast(rayOrigin,rayDirection,intersections) {
		let i = 0;
		while(i < this.indices.length) {
			let idx = this.indices[i];
			let x = this.points[idx * 3];
			let y = this.points[idx * 3 + 1];
			let z = this.points[idx * 3 + 2];
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let p1_x = x;
			let p1_y = y;
			let p1_z = z;
			let idx1 = this.indices[i + 1];
			let x1 = this.points[idx1 * 3];
			let y1 = this.points[idx1 * 3 + 1];
			let z1 = this.points[idx1 * 3 + 2];
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let p2_x = x1;
			let p2_y = y1;
			let p2_z = z1;
			let idx2 = this.indices[i + 2];
			let x2 = this.points[idx2 * 3];
			let y2 = this.points[idx2 * 3 + 1];
			let z2 = this.points[idx2 * 3 + 2];
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let p3_x = x2;
			let p3_y = y2;
			let p3_z = z2;
			let idx3 = this.indices[i];
			let n = new h3d_Vector(this.normals[idx3 * 3],this.normals[idx3 * 3 + 1],this.normals[idx3 * 3 + 2]);
			let d = -(p1_x * n.x + p1_y * n.y + p1_z * n.z);
			let t = -(rayOrigin.x * n.x + rayOrigin.y * n.y + rayOrigin.z * n.z + d) / (rayDirection.x * n.x + rayDirection.y * n.y + rayDirection.z * n.z);
			let x3 = rayDirection.x * t;
			let y3 = rayDirection.y * t;
			let z3 = rayDirection.z * t;
			let w = rayDirection.w;
			if(w == null) {
				w = 1.;
			}
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			let v_x = x3;
			let v_y = y3;
			let v_z = z3;
			let v_w = w;
			let ip = new h3d_Vector(rayOrigin.x + v_x,rayOrigin.y + v_y,rayOrigin.z + v_z,rayOrigin.w + v_w);
			ip.w = 1;
			let tmp;
			if(t >= 0) {
				let x = p2_x - p1_x;
				let y = p2_y - p1_y;
				let z = p2_z - p1_z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let u_x = x;
				let u_y = y;
				let u_z = z;
				let x1 = p3_x - p1_x;
				let y1 = p3_y - p1_y;
				let z1 = p3_z - p1_z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let v_x = x1;
				let v_y = y1;
				let v_z = z1;
				let x2 = ip.x - p1_x;
				let y2 = ip.y - p1_y;
				let z2 = ip.z - p1_z;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let w_x = x2;
				let w_y = y2;
				let w_z = z2;
				let x3 = v_y * w_z - v_z * w_y;
				let y3 = v_z * w_x - v_x * w_z;
				let z3 = v_x * w_y - v_y * w_x;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				let vw_x = x3;
				let vw_y = y3;
				let vw_z = z3;
				let x4 = v_y * u_z - v_z * u_y;
				let y4 = v_z * u_x - v_x * u_z;
				let z4 = v_x * u_y - v_y * u_x;
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				let vu_x = x4;
				let vu_y = y4;
				let vu_z = z4;
				if(vw_x * vu_x + vw_y * vu_y + vw_z * vu_z < 0.0) {
					tmp = false;
				} else {
					let x = u_y * w_z - u_z * w_y;
					let y = u_z * w_x - u_x * w_z;
					let z = u_x * w_y - u_y * w_x;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let uw_x = x;
					let uw_y = y;
					let uw_z = z;
					let x1 = u_y * v_z - u_z * v_y;
					let y1 = u_z * v_x - u_x * v_z;
					let z1 = u_x * v_y - u_y * v_x;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let uv_x = x1;
					let uv_y = y1;
					let uv_z = z1;
					if(uw_x * uv_x + uw_y * uv_y + uw_z * uv_z < 0.0) {
						tmp = false;
					} else {
						let d = Math.sqrt(uv_x * uv_x + uv_y * uv_y + uv_z * uv_z);
						let r = Math.sqrt(vw_x * vw_x + vw_y * vw_y + vw_z * vw_z) / d;
						let t = Math.sqrt(uw_x * uw_x + uw_y * uw_y + uw_z * uw_z) / d;
						tmp = r + t <= 1;
					}
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				intersections.push(new octree_RayIntersectionData(ip,n,this));
			}
			i += 3;
		}
	}
	dispose() {
		this.points = null;
		this.normals = null;
		this.indices = null;
		this._transformedPoints = null;
		this._transformedNormals = null;
		this.originalIndices = null;
	}
}
$hxClasses["collision.CollisionSurface"] = collision_CollisionSurface;
collision_CollisionSurface.__name__ = "collision.CollisionSurface";
collision_CollisionSurface.__interfaces__ = [collision_IBVHObject,octree_IOctreeObject];
Object.assign(collision_CollisionSurface.prototype, {
	__class__: collision_CollisionSurface
	,priority: null
	,boundingBox: null
	,points: null
	,normals: null
	,indices: null
	,friction: null
	,restitution: null
	,force: null
	,originalIndices: null
	,originalSurfaceIndex: null
	,transformKeys: null
	,key: null
	,_transformedPoints: null
	,_transformedNormals: null
});
class collision_SphereIntersectionResult {
	constructor(foundEntities,contacts) {
		this.foundEntities = foundEntities;
		this.contacts = contacts;
	}
}
$hxClasses["collision.SphereIntersectionResult"] = collision_SphereIntersectionResult;
collision_SphereIntersectionResult.__name__ = "collision.SphereIntersectionResult";
Object.assign(collision_SphereIntersectionResult.prototype, {
	__class__: collision_SphereIntersectionResult
	,foundEntities: null
	,contacts: null
});
class collision_CollisionWorld {
	constructor() {
		this.dynamicEntitySet = new haxe_ds_ObjectMap();
		this.marbleEntities = [];
		this.dynamicEntities = [];
		this.entities = [];
		this.octree = new octree_Octree();
		this.dynamicOctree = new octree_Octree();
		this.staticWorld = new collision_CollisionEntity(null);
	}
	sphereIntersection(spherecollision,timeState) {
		let _this = spherecollision.transform;
		let position_x = 0.;
		let position_y = 0.;
		let position_z = 0.;
		let x = _this._41;
		let y = _this._42;
		let z = _this._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		position_x = x;
		position_y = y;
		position_z = z;
		let radius = spherecollision.radius;
		let box = new h3d_col_Bounds();
		if(0 - radius < box.xMin) {
			box.xMin = 0 - radius;
		}
		if(radius > box.xMax) {
			box.xMax = radius;
		}
		if(0 - radius < box.yMin) {
			box.yMin = 0 - radius;
		}
		if(radius > box.yMax) {
			box.yMax = radius;
		}
		if(0 - radius < box.zMin) {
			box.zMin = 0 - radius;
		}
		if(radius > box.zMax) {
			box.zMax = radius;
		}
		let rotQuat = spherecollision.marble.getRotationQuat();
		let m = null;
		m = new h3d_Matrix();
		let xx = rotQuat.x * rotQuat.x;
		let xy = rotQuat.x * rotQuat.y;
		let xz = rotQuat.x * rotQuat.z;
		let xw = rotQuat.x * rotQuat.w;
		let yy = rotQuat.y * rotQuat.y;
		let yz = rotQuat.y * rotQuat.z;
		let yw = rotQuat.y * rotQuat.w;
		let zz = rotQuat.z * rotQuat.z;
		let zw = rotQuat.z * rotQuat.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		box.transform(m);
		let dx = position_x;
		let dy = position_y;
		let dz = position_z;
		box.xMin += dx;
		box.xMax += dx;
		box.yMin += dy;
		box.yMax += dy;
		box.zMin += dz;
		box.zMax += dz;
		let intersections = this.octree.boundingSearch(box);
		let contacts = [];
		let foundEntities = [];
		let _g = 0;
		while(_g < intersections.length) {
			let obj = intersections[_g];
			++_g;
			let entity = obj;
			foundEntities.push(entity);
			if(entity.go.isCollideable) {
				contacts = contacts.concat(entity.sphereIntersection(spherecollision,timeState));
			}
		}
		let dynSearch = this.dynamicOctree.boundingSearch(box);
		let _g1 = 0;
		while(_g1 < dynSearch.length) {
			let obj = dynSearch[_g1];
			++_g1;
			if(obj != spherecollision) {
				let col = js_Boot.__cast(obj , collision_CollisionEntity);
				let _this = col.boundingBox;
				if(!(_this.xMin > box.xMax || _this.yMin > box.yMax || _this.zMin > box.zMax || _this.xMax < box.xMin || _this.yMax < box.yMin || _this.zMax < box.zMin) && col.go.isCollideable) {
					contacts = contacts.concat(col.sphereIntersection(spherecollision,timeState));
				}
			}
		}
		return new collision_SphereIntersectionResult(foundEntities,contacts);
	}
	boundingSearch(bounds,useCache) {
		if(useCache == null) {
			useCache = true;
		}
		let _this = this.octree.boundingSearch(bounds,useCache);
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = js_Boot.__cast(_this[i] , collision_CollisionEntity);
		}
		let contacts = result;
		let _this1 = this.dynamicOctree.boundingSearch(bounds,useCache);
		let result1 = new Array(_this1.length);
		let _g2 = 0;
		let _g3 = _this1.length;
		while(_g2 < _g3) {
			let i = _g2++;
			result1[i] = js_Boot.__cast(_this1[i] , collision_CollisionEntity);
		}
		contacts = result.concat(result1);
		return contacts;
	}
	rayCast(rayStart,rayDirection,rayLength) {
		rayStart.w = 1;
		rayDirection.w = 1;
		let bounds = new h3d_col_Bounds();
		let x = rayStart.x;
		let y = rayStart.y;
		let z = rayStart.z;
		if(x < bounds.xMin) {
			bounds.xMin = x;
		}
		if(x > bounds.xMax) {
			bounds.xMax = x;
		}
		if(y < bounds.yMin) {
			bounds.yMin = y;
		}
		if(y > bounds.yMax) {
			bounds.yMax = y;
		}
		if(z < bounds.zMin) {
			bounds.zMin = z;
		}
		if(z > bounds.zMax) {
			bounds.zMax = z;
		}
		let x1 = rayStart.x + rayDirection.x * rayLength;
		let y1 = rayStart.y + rayDirection.y * rayLength;
		let z1 = rayStart.z + rayDirection.z * rayLength;
		if(x1 < bounds.xMin) {
			bounds.xMin = x1;
		}
		if(x1 > bounds.xMax) {
			bounds.xMax = x1;
		}
		if(y1 < bounds.yMin) {
			bounds.yMin = y1;
		}
		if(y1 > bounds.yMax) {
			bounds.yMax = y1;
		}
		if(z1 < bounds.zMin) {
			bounds.zMin = z1;
		}
		if(z1 > bounds.zMax) {
			bounds.zMax = z1;
		}
		let objs = this.octree.boundingSearch(bounds);
		let dynObjs = this.dynamicOctree.boundingSearch(bounds);
		let results = [];
		let _g = 0;
		while(_g < objs.length) {
			let obj = objs[_g];
			++_g;
			let oo = js_Boot.__cast(obj , collision_CollisionEntity);
			oo.rayCast(rayStart,rayDirection,results);
		}
		let _g1 = 0;
		while(_g1 < dynObjs.length) {
			let obj = dynObjs[_g1];
			++_g1;
			let oo = js_Boot.__cast(obj , collision_CollisionEntity);
			oo.rayCast(rayStart,rayDirection,results);
		}
		return results;
	}
	addEntity(entity) {
		this.octree.insert(entity);
		this.entities.push(entity);
	}
	addMarbleEntity(entity) {
		this.marbleEntities.push(entity);
	}
	removeMarbleEntity(entity) {
		HxOverrides.remove(this.marbleEntities,entity);
	}
	addMovingEntity(entity) {
		this.dynamicEntities.push(entity);
		this.dynamicOctree.insert(entity);
		this.dynamicEntitySet.set(entity,true);
	}
	removeMovingEntity(entity) {
		HxOverrides.remove(this.dynamicEntities,entity);
		this.dynamicOctree.remove(entity);
		this.dynamicEntitySet.remove(entity);
	}
	updateTransform(entity) {
		if(this.dynamicEntitySet.h.__keys__[entity.__id__] == null) {
			this.octree.update(entity);
		} else {
			this.dynamicOctree.update(entity);
		}
	}
	finalizeStaticGeometry() {
		this.staticWorld.finalize();
	}
	dispose() {
		let _g = 0;
		let _g1 = this.entities;
		while(_g < _g1.length) {
			let e = _g1[_g];
			++_g;
			e.dispose();
		}
		let _g2 = 0;
		let _g3 = this.dynamicEntities;
		while(_g2 < _g3.length) {
			let e = _g3[_g2];
			++_g2;
			e.dispose();
		}
		this.octree = null;
		this.entities = null;
		this.dynamicEntities = null;
		this.dynamicOctree = null;
		this.dynamicEntitySet = null;
		this.staticWorld.dispose();
		this.staticWorld = null;
	}
}
$hxClasses["collision.CollisionWorld"] = collision_CollisionWorld;
collision_CollisionWorld.__name__ = "collision.CollisionWorld";
Object.assign(collision_CollisionWorld.prototype, {
	__class__: collision_CollisionWorld
	,staticWorld: null
	,octree: null
	,entities: null
	,dynamicEntities: null
	,dynamicOctree: null
	,marbleEntities: null
	,dynamicEntitySet: null
});
class collision_Grid {
	constructor(bounds) {
		this.searchKey = 0;
		this.surfaces = [];
		this.cells = [];
		this.CELL_DIV = new h3d_Vector(collision_Grid.CELL_SIZE,collision_Grid.CELL_SIZE);
		let b = new h3d_col_Bounds();
		b.xMin = bounds.xMin;
		b.xMax = bounds.xMax;
		b.yMin = bounds.yMin;
		b.yMax = bounds.yMax;
		b.zMin = bounds.zMin;
		b.zMax = bounds.zMax;
		this.bounds = b;
		this.cellSize = new h3d_Vector((bounds.xMax - bounds.xMin) / this.CELL_DIV.x,(bounds.yMax - bounds.yMin) / this.CELL_DIV.y);
		let _g = 0;
		let _g1 = collision_Grid.CELL_SIZE;
		while(_g < _g1) {
			++_g;
			let _g1 = 0;
			let _g2 = collision_Grid.CELL_SIZE;
			while(_g1 < _g2) {
				++_g1;
				this.cells.push([]);
			}
		}
	}
	insert(surface) {
		let _this = this.bounds;
		let b = surface.boundingBox;
		if(_this.xMin <= b.xMin && _this.yMin <= b.yMin && _this.zMin <= b.zMin && _this.xMax >= b.xMax && _this.yMax >= b.yMax && _this.zMax >= b.zMax) {
			this.surfaces.push(surface);
		} else {
			throw new haxe_Exception("Surface is not contained in the grid's bounds");
		}
	}
	build() {
		let _g = 0;
		let _g1 = collision_Grid.CELL_SIZE;
		while(_g < _g1) {
			let i = _g++;
			let minX = this.bounds.xMin;
			let maxX = this.bounds.xMin;
			minX += i * this.cellSize.x;
			maxX += (i + 1) * this.cellSize.x;
			let _g1 = 0;
			let _g2 = collision_Grid.CELL_SIZE;
			while(_g1 < _g2) {
				let j = _g1++;
				let minY = this.bounds.yMin;
				let maxY = this.bounds.yMin;
				minY += j * this.cellSize.y;
				maxY += (j + 1) * this.cellSize.y;
				let binRect_xMin = 1e20;
				let binRect_yMin = 1e20;
				let binRect_xMax = -1e20;
				let binRect_yMax = -1e20;
				binRect_xMin = minX;
				binRect_yMin = minY;
				binRect_xMax = maxX;
				binRect_yMax = maxY;
				let _g = 0;
				let _g2 = this.surfaces.length;
				while(_g < _g2) {
					let idx = _g++;
					let surface = this.surfaces[idx];
					let hullRect_xMin = 1e20;
					let hullRect_yMin = 1e20;
					let hullRect_xMax = -1e20;
					let hullRect_yMax = -1e20;
					hullRect_xMin = surface.boundingBox.xMin;
					hullRect_yMin = surface.boundingBox.yMin;
					hullRect_xMax = surface.boundingBox.xMax;
					hullRect_yMax = surface.boundingBox.yMax;
					if(!(hullRect_xMin > binRect_xMax || hullRect_yMin > binRect_yMax || hullRect_xMax < binRect_xMin || hullRect_yMax < binRect_yMin)) {
						this.cells[16 * i + j].push(idx);
					}
				}
			}
		}
	}
	boundingSearch(searchbox) {
		let queryMinX = Math.max(searchbox.xMin,this.bounds.xMin);
		let queryMinY = Math.max(searchbox.yMin,this.bounds.yMin);
		let queryMaxX = Math.min(searchbox.xMax,this.bounds.xMax);
		let queryMaxY = Math.min(searchbox.yMax,this.bounds.yMax);
		let xStart = Math.floor((queryMinX - this.bounds.xMin) / this.cellSize.x);
		let yStart = Math.floor((queryMinY - this.bounds.yMin) / this.cellSize.y);
		let xEnd = Math.ceil((queryMaxX - this.bounds.xMin) / this.cellSize.x);
		let yEnd = Math.ceil((queryMaxY - this.bounds.yMin) / this.cellSize.y);
		if(xStart < 0) {
			xStart = 0;
		}
		if(yStart < 0) {
			yStart = 0;
		}
		if(xEnd > collision_Grid.CELL_SIZE) {
			xEnd = collision_Grid.CELL_SIZE;
		}
		if(yEnd > collision_Grid.CELL_SIZE) {
			yEnd = collision_Grid.CELL_SIZE;
		}
		let foundSurfaces = [];
		this.searchKey++;
		let _g = xStart;
		let _g1 = xEnd;
		while(_g < _g1) {
			let i = _g++;
			let _g1 = yStart;
			let _g2 = yEnd;
			while(_g1 < _g2) {
				let j = _g1++;
				let _g = 0;
				let _g2 = this.cells[16 * i + j];
				while(_g < _g2.length) {
					let surfIdx = _g2[_g];
					++_g;
					let surf = this.surfaces[surfIdx];
					if(surf.key == this.searchKey) {
						continue;
					}
					surf.key = this.searchKey;
					let tmp;
					let b = surf.boundingBox;
					if(!(searchbox.xMin <= b.xMin && searchbox.yMin <= b.yMin && searchbox.zMin <= b.zMin && searchbox.xMax >= b.xMax && searchbox.yMax >= b.yMax && searchbox.zMax >= b.zMax)) {
						let b = surf.boundingBox;
						tmp = !(searchbox.xMin > b.xMax || searchbox.yMin > b.yMax || searchbox.zMin > b.zMax || searchbox.xMax < b.xMin || searchbox.yMax < b.yMin || searchbox.zMax < b.zMin);
					} else {
						tmp = true;
					}
					if(tmp) {
						foundSurfaces.push(surf);
						surf.key = this.searchKey;
					}
				}
			}
		}
		return foundSurfaces;
	}
	rayCast(origin,direction) {
		let _this = this.bounds;
		let x = _this.xMin;
		let y = _this.yMin;
		let z = _this.zMin;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let _this_x = x;
		let _this_y = y;
		let _this_z = z;
		let x1 = _this_x;
		let y1 = _this_y;
		let z1 = _this_z;
		if(_this_z == null) {
			z1 = 0.;
		}
		if(_this_y == null) {
			y1 = 0.;
		}
		if(_this_x == null) {
			x1 = 0.;
		}
		let v_x = x1;
		let v_y = y1;
		let x2 = origin.x - v_x;
		let y2 = origin.y - v_y;
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let cell_x = x2;
		let cell_y = y2;
		cell_x /= this.cellSize.x;
		cell_y /= this.cellSize.y;
		let stepX;
		let outX;
		let X = Math.floor(cell_x);
		let stepY;
		let outY;
		let Y = Math.floor(cell_y);
		if(X < 0 || X >= this.CELL_DIV.x || Y < 0 || Y >= this.CELL_DIV.y) {
			return [];
		}
		let cb_x = 0.;
		let cb_y = 0.;
		if(direction.x > 0) {
			stepX = 1;
			outX = this.CELL_DIV.x;
			cb_x = this.bounds.xMin + (X + 1) * this.cellSize.x;
		} else {
			stepX = -1;
			outX = -1;
			cb_x = this.bounds.xMin + X * this.cellSize.x;
		}
		if(direction.y > 0.0) {
			stepY = 1;
			outY = this.CELL_DIV.y;
			cb_y = this.bounds.yMin + (Y + 1) * this.cellSize.y;
		} else {
			stepY = -1;
			outY = -1;
			cb_y = this.bounds.yMin + Y * this.cellSize.y;
		}
		let tmax_x = 0.;
		let tmax_y = 0.;
		let tdelta_x = 0.;
		let tdelta_y = 0.;
		let rxr;
		let ryr;
		if(direction.x != 0) {
			rxr = 1.0 / direction.x;
			tmax_x = (cb_x - origin.x) * rxr;
			tdelta_x = this.cellSize.x * stepX * rxr;
		} else {
			tmax_x = 1000000;
		}
		if(direction.y != 0) {
			ryr = 1.0 / direction.y;
			tmax_y = (cb_y - origin.y) * ryr;
			tdelta_y = this.cellSize.y * stepY * ryr;
		} else {
			tmax_y = 1000000;
		}
		this.searchKey++;
		let results = [];
		while(true) {
			let cell = this.cells[16 * X + Y];
			let _g = 0;
			while(_g < cell.length) {
				let idx = cell[_g];
				++_g;
				let surf = this.surfaces[idx];
				if(surf.key == this.searchKey) {
					continue;
				}
				surf.key = this.searchKey;
				surf.rayCast(origin,direction,results);
			}
			if(tmax_x < tmax_y) {
				X += stepX;
				if(X == outX) {
					break;
				}
				tmax_x += tdelta_x;
			} else {
				Y += stepY;
				if(Y == outY) {
					break;
				}
				tmax_y += tdelta_y;
			}
		}
		return results;
	}
}
$hxClasses["collision.Grid"] = collision_Grid;
collision_Grid.__name__ = "collision.Grid";
Object.assign(collision_Grid.prototype, {
	__class__: collision_Grid
	,bounds: null
	,cellSize: null
	,CELL_DIV: null
	,cells: null
	,surfaces: null
	,searchKey: null
});
class collision_SphereCollisionEntity extends collision_CollisionEntity {
	constructor(marble) {
		super(marble);
		this.marble = marble;
		this.velocity = marble.velocity;
		this.radius = marble._radius;
		this.generateBoundingBox();
	}
	generateBoundingBox() {
		let boundingBox = new h3d_col_Bounds();
		let _this = this.transform;
		let pos_x = 0.;
		let pos_y = 0.;
		let pos_z = 0.;
		let x = _this._41;
		let y = _this._42;
		let z = _this._43;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		pos_x = x;
		pos_y = y;
		pos_z = z;
		let r = this.radius;
		if(0 - r < boundingBox.xMin) {
			boundingBox.xMin = 0 - r;
		}
		if(r > boundingBox.xMax) {
			boundingBox.xMax = r;
		}
		if(0 - r < boundingBox.yMin) {
			boundingBox.yMin = 0 - r;
		}
		if(r > boundingBox.yMax) {
			boundingBox.yMax = r;
		}
		if(0 - r < boundingBox.zMin) {
			boundingBox.zMin = 0 - r;
		}
		if(r > boundingBox.zMax) {
			boundingBox.zMax = r;
		}
		boundingBox.transform(this.transform);
		this.boundingBox = boundingBox;
		if(src_Debug.drawBounds) {
			if(this._dbgEntity == null) {
				let _this = this.boundingBox;
				let _this1 = this.boundingBox;
				let _this2 = this.boundingBox;
				let cube = new h3d_prim_Cube(_this.xMax - _this.xMin,_this1.yMax - _this1.yMin,_this2.zMax - _this2.zMin,true);
				cube.addNormals();
				cube.addUVs();
				this._dbgEntity = new h3d_scene_Mesh(cube);
				this._dbgEntity.material.passes.set_wireframe(true);
				this._dbgEntity.setTransform(this.transform);
				src_MarbleGame.instance.scene.addChild(this._dbgEntity);
				let _this3 = this.boundingBox;
				let _this4 = this.boundingBox;
				let _this5 = this.boundingBox;
				let cube2 = new h3d_prim_Cube(_this3.xMax - _this3.xMin,_this4.yMax - _this4.yMin,_this5.zMax - _this5.zMin,true);
				cube2.addNormals();
				cube2.addUVs();
				this._dbgEntity2 = new h3d_scene_Mesh(cube2);
				this._dbgEntity2.material.passes.set_wireframe(true);
				this._dbgEntity2.setTransform(this.transform);
				src_MarbleGame.instance.scene.addChild(this._dbgEntity2);
			} else {
				this._dbgEntity.setTransform(this.transform);
				let _this = this.boundingBox;
				let _this1 = this.boundingBox;
				let _this2 = this.boundingBox;
				let cube2 = new h3d_prim_Cube(_this.xMax - _this.xMin,_this1.yMax - _this1.yMin,_this2.zMax - _this2.zMin,true);
				cube2.addNormals();
				cube2.addUVs();
				this._dbgEntity2.set_primitive(cube2);
				let _this3 = this._dbgEntity2;
				let x = pos_x;
				let y = pos_y;
				let z = pos_z;
				_this3.x = x;
				_this3.flags |= 1;
				_this3.y = y;
				_this3.flags |= 1;
				_this3.z = z;
				_this3.flags |= 1;
				_this3.flags |= 1;
			}
		}
	}
	setTransform(transform) {
		super.setTransform(transform);
		if(src_Debug.drawBounds) {
			if(this._dbgEntity != null) {
				this._dbgEntity.setTransform(transform);
			}
		}
	}
	rayCast(rayOrigin,rayDirection,results) {
	}
	sphereIntersection(collisionEntity,timeState) {
		let contacts = [];
		let _this = this.transform;
		let thispos_x = 0.;
		let thispos_y = 0.;
		let thispos_z = 0.;
		let thispos_w = 1.;
		let x = _this._41;
		let y = _this._42;
		let z = _this._43;
		let w = _this._44;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		thispos_x = x;
		thispos_y = y;
		thispos_z = z;
		thispos_w = w;
		let _this1 = collisionEntity.transform;
		let position_x = 0.;
		let position_y = 0.;
		let position_z = 0.;
		let position_w = 1.;
		let x1 = _this1._41;
		let y1 = _this1._42;
		let z1 = _this1._43;
		let w1 = _this1._44;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		position_x = x1;
		position_y = y1;
		position_z = z1;
		position_w = w1;
		let radius = collisionEntity.radius;
		let x2 = thispos_x - position_x;
		let y2 = thispos_y - position_y;
		let z2 = thispos_z - position_z;
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let otherDist_x = x2;
		let otherDist_y = y2;
		let otherDist_z = z2;
		let otherRadius = this.radius + radius;
		if(otherRadius * otherRadius * 1.01 > otherDist_x * otherDist_x + otherDist_y * otherDist_y + otherDist_z * otherDist_z) {
			let k = otherDist_x * otherDist_x + otherDist_y * otherDist_y + otherDist_z * otherDist_z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			let x = otherDist_x * k;
			let y = otherDist_y * k;
			let z = otherDist_z * k;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let normDist_x = x;
			let normDist_y = y;
			let normDist_z = z;
			let contact = collision_CollisionPool.alloc();
			contact.collider = this;
			contact.friction = 1;
			contact.restitution = 1;
			let _this = this.velocity;
			contact.velocity = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
			contact.otherObject = this.go;
			contact.point = new h3d_Vector(position_x + normDist_x,position_y + normDist_y,position_z + normDist_z,position_w + 1.);
			contact.normal = new h3d_Vector(normDist_x * -1,normDist_y * -1,normDist_z * -1,1.);
			contact.force = 0;
			let _this1 = contact.point;
			let dx = position_x - _this1.x;
			let dy = position_y - _this1.y;
			let dz = position_z - _this1.z;
			contact.contactDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
			contacts.push(contact);
		}
		return contacts;
	}
}
$hxClasses["collision.SphereCollisionEntity"] = collision_SphereCollisionEntity;
collision_SphereCollisionEntity.__name__ = "collision.SphereCollisionEntity";
collision_SphereCollisionEntity.__super__ = collision_CollisionEntity;
Object.assign(collision_SphereCollisionEntity.prototype, {
	__class__: collision_SphereCollisionEntity
	,radius: null
	,marble: null
	,_dbgEntity2: null
});
class collision_gjk_GJKShape {
}
$hxClasses["collision.gjk.GJKShape"] = collision_gjk_GJKShape;
collision_gjk_GJKShape.__name__ = "collision.gjk.GJKShape";
collision_gjk_GJKShape.__isInterface__ = true;
class collision_gjk_ConvexHull {
	constructor(vertices) {
		this.transform = h3d_Matrix.I();
		this.vertices = vertices;
	}
}
$hxClasses["collision.gjk.ConvexHull"] = collision_gjk_ConvexHull;
collision_gjk_ConvexHull.__name__ = "collision.gjk.ConvexHull";
collision_gjk_ConvexHull.__interfaces__ = [collision_gjk_GJKShape];
Object.assign(collision_gjk_ConvexHull.prototype, {
	__class__: collision_gjk_ConvexHull
	,vertices: null
	,transform: null
});
class datachannel_RTC {
	static init() {
		if(!datachannel_RTC.inited) {
			datachannel_RTC.inited = true;
		}
	}
}
$hxClasses["datachannel.RTC"] = datachannel_RTC;
datachannel_RTC.__name__ = "datachannel.RTC";
var datachannel_RTCDataChannelReliability = $hxEnums["datachannel.RTCDataChannelReliability"] = { __ename__:true,__constructs__:null
	,Reliable: {_hx_name:"Reliable",_hx_index:0,__enum__:"datachannel.RTCDataChannelReliability",toString:$estr}
	,Unreliable: ($_=function(maxRetransmits,maxLifetime) { return {_hx_index:1,maxRetransmits:maxRetransmits,maxLifetime:maxLifetime,__enum__:"datachannel.RTCDataChannelReliability",toString:$estr}; },$_._hx_name="Unreliable",$_.__params__ = ["maxRetransmits","maxLifetime"],$_)
};
datachannel_RTCDataChannelReliability.__constructs__ = [datachannel_RTCDataChannelReliability.Reliable,datachannel_RTCDataChannelReliability.Unreliable];
datachannel_RTCDataChannelReliability.__empty_constructs__ = [datachannel_RTCDataChannelReliability.Reliable];
var datachannel_RTCDataChannelState = $hxEnums["datachannel.RTCDataChannelState"] = { __ename__:true,__constructs__:null
	,Closed: {_hx_name:"Closed",_hx_index:0,__enum__:"datachannel.RTCDataChannelState",toString:$estr}
	,Open: {_hx_name:"Open",_hx_index:1,__enum__:"datachannel.RTCDataChannelState",toString:$estr}
	,Error: {_hx_name:"Error",_hx_index:2,__enum__:"datachannel.RTCDataChannelState",toString:$estr}
};
datachannel_RTCDataChannelState.__constructs__ = [datachannel_RTCDataChannelState.Closed,datachannel_RTCDataChannelState.Open,datachannel_RTCDataChannelState.Error];
datachannel_RTCDataChannelState.__empty_constructs__ = [datachannel_RTCDataChannelState.Closed,datachannel_RTCDataChannelState.Open,datachannel_RTCDataChannelState.Error];
class datachannel_RTCDataChannel {
	constructor(inner,pc) {
		this.inner = inner;
		this.inner.binaryType = "arraybuffer";
		this.peerConnection = pc;
		this.state = datachannel_RTCDataChannelState.Open;
		this.setCallbacks();
	}
	onOpen(name) {
	}
	onClosed() {
	}
	onError(msg) {
	}
	onMessage(msg) {
	}
	onBufferedAmountLow() {
	}
	setCallbacks() {
		let _gthis = this;
		this.inner.onopen = function() {
			_gthis.state = datachannel_RTCDataChannelState.Open;
			_gthis.onOpen(_gthis.inner.label);
		};
		this.inner.onclose = function() {
			_gthis.state = datachannel_RTCDataChannelState.Closed;
			_gthis.onClosed();
		};
		this.inner.onbufferedamountlow = function() {
			_gthis.onBufferedAmountLow();
		};
		this.inner.onerror = function(e) {
			_gthis.state = datachannel_RTCDataChannelState.Error;
			_gthis.onError(e.error.message);
		};
		this.inner.onmessage = function(m) {
			if(typeof(m.data) == "string") {
				_gthis.onMessage(m.data);
			}
			_gthis.onMessage(haxe_io_Bytes.ofData(m.data));
		};
	}
	sendBytes(b) {
		if(this.state != datachannel_RTCDataChannelState.Open) {
			throw new datachannel_RTCException("DataChannel is not open!");
		}
		this.inner.send(b.b.bufferValue);
	}
	get_name() {
		return this.inner.label;
	}
	get_reliability() {
		if(this.inner.reliable) {
			return datachannel_RTCDataChannelReliability.Reliable;
		} else {
			return datachannel_RTCDataChannelReliability.Unreliable(this.inner.maxRetransmits,this.inner.maxPacketLifeTime);
		}
	}
}
$hxClasses["datachannel.RTCDataChannel"] = datachannel_RTCDataChannel;
datachannel_RTCDataChannel.__name__ = "datachannel.RTCDataChannel";
Object.assign(datachannel_RTCDataChannel.prototype, {
	__class__: datachannel_RTCDataChannel
	,inner: null
	,name: null
	,peerConnection: null
	,reliability: null
	,state: null
});
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	unwrap() {
		return this.__nativeException;
	}
	toString() {
		return this.get_message();
	}
	get_message() {
		return this.message;
	}
	get_native() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
$hxClasses["haxe.Exception"] = haxe_Exception;
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.__super__ = Error;
Object.assign(haxe_Exception.prototype, {
	__class__: haxe_Exception
	,__skipStack: null
	,__nativeException: null
	,__previousException: null
});
class datachannel_RTCException extends haxe_Exception {
	constructor(message,previous,native) {
		super(message,previous,native);
	}
}
$hxClasses["datachannel.RTCException"] = datachannel_RTCException;
datachannel_RTCException.__name__ = "datachannel.RTCException";
datachannel_RTCException.__super__ = haxe_Exception;
Object.assign(datachannel_RTCException.prototype, {
	__class__: datachannel_RTCException
});
class datachannel_RTCPeerConnection {
	constructor(iceServers,bindAddress) {
		this._sdpGenerated = false;
		if(!datachannel_RTC.inited) {
			throw new datachannel_RTCException("RTC is not initialized");
		}
		this.inner = new RTCPeerConnection({ iceServers : [{ urls : iceServers}]});
		this.iceServers = iceServers;
		this.dataChannels = [];
		this.setCallbacks();
	}
	onLocalDescription(sdp,type) {
	}
	onLocalCandidate(candidate) {
	}
	onStateChange(state) {
	}
	onGatheringStateChange(state) {
	}
	onDataChannel(dc) {
	}
	close() {
		this.inner.close();
	}
	setCallbacks() {
		let _gthis = this;
		this.inner.onicecandidate = function(c) {
			if(c.candidate != null && c.candidate.candidate != "") {
				_gthis.onLocalCandidate(c.candidate.candidate);
			}
		};
		this.inner.oniceconnectionstatechange = function() {
			switch(_gthis.inner.iceConnectionState) {
			case "checking":
				_gthis.state = 1;
				break;
			case "closed":
				_gthis.state = 5;
				break;
			case "completed":
				break;
			case "connected":
				_gthis.state = 2;
				break;
			case "disconnected":
				_gthis.state = 3;
				break;
			case "failed":
				_gthis.state = 4;
				break;
			case "new":
				_gthis.state = 0;
				break;
			}
			_gthis.onStateChange(_gthis.state);
		};
		this.inner.onicegatheringstatechange = function() {
			switch(_gthis.inner.iceGatheringState) {
			case "complete":
				_gthis.gatheringState = 2;
				break;
			case "gathering":
				_gthis.gatheringState = 1;
				break;
			case "new":
				_gthis.gatheringState = 0;
				break;
			}
			_gthis.onGatheringStateChange(_gthis.gatheringState);
		};
		this.inner.ondatachannel = function(e) {
			let dc = new datachannel_RTCDataChannel(e.channel,_gthis);
			dc.state = datachannel_RTCDataChannelState.Open;
			_gthis.dataChannels.push(dc);
			_gthis.onDataChannel(dc);
		};
	}
	setRemoteDescription(sdp,type) {
		let tmp;
		switch(type) {
		case "answer":
			tmp = "answer";
			break;
		case "offer":
			tmp = "offer";
			break;
		default:
			tmp = "offer";
		}
		this.inner.setRemoteDescription({ sdp : sdp, type : tmp});
		this.remoteDescription = sdp;
		this.remoteDescriptionType = type;
		let _gthis = this;
		if(type == "offer" && !this._sdpGenerated) {
			this.inner.createAnswer().then(function(e) {
				_gthis.localDescription = e.sdp;
				let tmp;
				switch(e.type) {
				case "answer":
					tmp = "answer";
					break;
				case "offer":
					tmp = "offer";
					break;
				default:
					tmp = "offer";
				}
				_gthis.localDescriptionType = tmp;
				_gthis._sdpGenerated = true;
				_gthis.inner.setLocalDescription(e);
				_gthis.onLocalDescription(e.sdp,_gthis.localDescriptionType);
			});
		}
	}
	createDatachannel(label) {
		let dc = null;
		dc = new datachannel_RTCDataChannel(this.inner.createDataChannel(label),this);
		this.dataChannels.push(dc);
		let _gthis = this;
		if(!this._sdpGenerated) {
			this.inner.createOffer().then(function(sdp) {
				_gthis.localDescription = sdp.sdp;
				let tmp;
				switch(sdp.type) {
				case "answer":
					tmp = "answer";
					break;
				case "offer":
					tmp = "offer";
					break;
				default:
					tmp = "offer";
				}
				_gthis.localDescriptionType = tmp;
				_gthis._sdpGenerated = true;
				_gthis.inner.setLocalDescription(sdp);
				_gthis.onLocalDescription(sdp.sdp,_gthis.localDescriptionType);
			});
		}
		return dc;
	}
	createDatachannelWithOptions(label,unordered,maxRetransmits,maxLifetime) {
		let dc = null;
		let reliable = maxRetransmits == 0 && maxLifetime == 0;
		dc = new datachannel_RTCDataChannel(this.inner.createDataChannel(label,{ ordered : !unordered, maxRetransmits : reliable ? null : maxRetransmits, maxPacketLifeTime : reliable ? null : maxLifetime}),this);
		this.dataChannels.push(dc);
		let _gthis = this;
		if(!this._sdpGenerated) {
			this.inner.createOffer().then(function(sdp) {
				_gthis.localDescription = sdp.sdp;
				let tmp;
				switch(sdp.type) {
				case "answer":
					tmp = "answer";
					break;
				case "offer":
					tmp = "offer";
					break;
				default:
					tmp = "offer";
				}
				_gthis.localDescriptionType = tmp;
				_gthis._sdpGenerated = true;
				_gthis.inner.setLocalDescription(sdp);
				_gthis.onLocalDescription(sdp.sdp,_gthis.localDescriptionType);
			});
		}
		return dc;
	}
}
$hxClasses["datachannel.RTCPeerConnection"] = datachannel_RTCPeerConnection;
datachannel_RTCPeerConnection.__name__ = "datachannel.RTCPeerConnection";
Object.assign(datachannel_RTCPeerConnection.prototype, {
	__class__: datachannel_RTCPeerConnection
	,inner: null
	,_sdpGenerated: null
	,iceServers: null
	,state: null
	,gatheringState: null
	,remoteDescription: null
	,remoteDescriptionType: null
	,localDescription: null
	,localDescriptionType: null
	,dataChannels: null
});
class dif_AISpecialNode {
	constructor(name,position) {
		this.name = name;
		this.position = position;
	}
	write(io) {
		io.writeStr(this.name);
		this.position.write(io);
	}
	static read(io) {
		return new dif_AISpecialNode(io.readStr(),dif_math_Point3F.read(io));
	}
}
$hxClasses["dif.AISpecialNode"] = $hx_exports["dif"]["AISpecialNode"] = dif_AISpecialNode;
dif_AISpecialNode.__name__ = "dif.AISpecialNode";
Object.assign(dif_AISpecialNode.prototype, {
	__class__: dif_AISpecialNode
	,name: null
	,position: null
});
class dif_AnimatedLight {
	constructor(nameIndex,stateIndex,stateCount,flags,duration) {
		this.nameIndex = nameIndex;
		this.stateIndex = stateIndex;
		this.stateCount = stateCount;
		this.flags = flags;
		this.duration = duration;
	}
	write(io) {
		io.writeInt32(this.nameIndex);
		io.writeInt32(this.stateIndex);
		io.writeUInt16(this.stateCount);
		io.writeUInt16(this.flags);
		io.writeInt32(this.duration);
	}
	static read(io) {
		return new dif_AnimatedLight(io.readInt32(),io.readInt32(),io.readInt16(),io.readInt16(),io.readInt32());
	}
}
$hxClasses["dif.AnimatedLight"] = $hx_exports["dif"]["AnimatedLight"] = dif_AnimatedLight;
dif_AnimatedLight.__name__ = "dif.AnimatedLight";
Object.assign(dif_AnimatedLight.prototype, {
	__class__: dif_AnimatedLight
	,nameIndex: null
	,stateIndex: null
	,stateCount: null
	,flags: null
	,duration: null
});
class dif_BSPNode {
	constructor(planeIndex,frontIndex,backIndex,isFrontLeaf,isFrontSolid,isBackLeaf,isBackSolid) {
		this.planeIndex = planeIndex;
		this.frontIndex = frontIndex;
		this.backIndex = backIndex;
		this.isFrontLeaf = isFrontLeaf;
		this.isFrontSolid = isFrontSolid;
		this.isBackLeaf = isBackLeaf;
		this.isBackSolid = isBackSolid;
	}
	write(io,version) {
		io.writeUInt16(this.planeIndex);
		if(version.interiorVersion >= 14) {
			let frontwrite = this.frontIndex;
			if(this.isFrontLeaf) {
				frontwrite &= -32769;
				frontwrite |= 524288;
			}
			if(this.isFrontSolid) {
				frontwrite &= -16385;
				frontwrite |= 262144;
			}
			io.writeInt32(frontwrite);
			let backwrite = this.backIndex;
			if(this.isBackLeaf) {
				backwrite &= -32769;
				backwrite |= 524288;
			}
			if(this.isBackSolid) {
				backwrite &= -16385;
				backwrite |= 262144;
			}
			io.writeInt32(backwrite);
		} else {
			io.writeInt16(this.frontIndex);
			io.writeInt16(this.backIndex);
		}
	}
	static read(io,version) {
		let planeIndex = io.readUInt16();
		let frontIndex;
		let backIndex;
		let isfrontleaf = false;
		let isfrontsolid = false;
		let isbackleaf = false;
		let isbacksolid = false;
		if(version.interiorVersion >= 14) {
			frontIndex = io.readInt32();
			backIndex = io.readInt32();
			if((frontIndex & 524288) != 0) {
				frontIndex = frontIndex & -524289 | 32768;
				isfrontleaf = true;
			}
			if((frontIndex & 262144) != 0) {
				frontIndex = frontIndex & -262145 | 16384;
				isfrontsolid = true;
			}
			if((backIndex & 524288) != 0) {
				backIndex = backIndex & -524289 | 32768;
				isbackleaf = true;
			}
			if((backIndex & 262144) != 0) {
				backIndex = backIndex & -262145 | 16384;
				isbacksolid = true;
			}
		} else {
			frontIndex = io.readUInt16();
			backIndex = io.readUInt16();
			if((frontIndex & 32768) != 0) {
				isfrontleaf = true;
			}
			if((frontIndex & 16384) != 0) {
				isfrontsolid = true;
			}
			if((backIndex & 32768) != 0) {
				isbackleaf = true;
			}
			if((backIndex & 16384) != 0) {
				isbacksolid = true;
			}
		}
		return new dif_BSPNode(planeIndex,frontIndex,backIndex,isfrontleaf,isfrontsolid,isbackleaf,isbacksolid);
	}
}
$hxClasses["dif.BSPNode"] = $hx_exports["dif"]["BSPNode"] = dif_BSPNode;
dif_BSPNode.__name__ = "dif.BSPNode";
Object.assign(dif_BSPNode.prototype, {
	__class__: dif_BSPNode
	,planeIndex: null
	,frontIndex: null
	,backIndex: null
	,isFrontLeaf: null
	,isFrontSolid: null
	,isBackLeaf: null
	,isBackSolid: null
});
class dif_BSPSolidLeaf {
	constructor(surfaceStart,surfaceCount) {
		this.surfaceStart = surfaceStart;
		this.surfaceCount = surfaceCount;
	}
	write(io) {
		io.writeInt32(this.surfaceStart);
		io.writeInt16(this.surfaceCount);
	}
	static read(io) {
		return new dif_BSPSolidLeaf(io.readInt32(),io.readInt16());
	}
}
$hxClasses["dif.BSPSolidLeaf"] = $hx_exports["dif"]["BSPSolidLeaf"] = dif_BSPSolidLeaf;
dif_BSPSolidLeaf.__name__ = "dif.BSPSolidLeaf";
Object.assign(dif_BSPSolidLeaf.prototype, {
	__class__: dif_BSPSolidLeaf
	,surfaceStart: null
	,surfaceCount: null
});
class dif_ConvexHull {
	constructor() {
		this.hullStart = 0;
		this.hullCount = 0;
		this.minX = 0;
		this.minY = 0;
		this.minZ = 0;
		this.maxX = 0;
		this.maxY = 0;
		this.maxZ = 0;
		this.surfaceStart = 0;
		this.surfaceCount = 0;
		this.planeStart = 0;
		this.polyListPlaneStart = 0;
		this.polyListPointStart = 0;
		this.polyListStringStart = 0;
		this.staticMesh = false;
	}
	write(io,version) {
		io.writeInt32(this.hullStart);
		io.writeUInt16(this.hullCount);
		io.writeFloat(this.minX);
		io.writeFloat(this.minY);
		io.writeFloat(this.minZ);
		io.writeFloat(this.maxX);
		io.writeFloat(this.maxY);
		io.writeFloat(this.maxZ);
		io.writeInt32(this.surfaceStart);
		io.writeUInt16(this.surfaceCount);
		io.writeInt32(this.planeStart);
		io.writeInt32(this.polyListPlaneStart);
		io.writeInt32(this.polyListPointStart);
		io.writeInt32(this.polyListStringStart);
		if(version.interiorVersion >= 12) {
			io.writeByte(this.staticMesh ? 1 : 0);
		}
	}
	static read(io,version) {
		let ret = new dif_ConvexHull();
		ret.hullStart = io.readInt32();
		ret.hullCount = io.readUInt16();
		ret.minX = io.readFloat();
		ret.minY = io.readFloat();
		ret.minZ = io.readFloat();
		ret.maxX = io.readFloat();
		ret.maxY = io.readFloat();
		ret.maxZ = io.readFloat();
		ret.surfaceStart = io.readInt32();
		ret.surfaceCount = io.readUInt16();
		ret.planeStart = io.readInt32();
		ret.polyListPlaneStart = io.readInt32();
		ret.polyListPointStart = io.readInt32();
		ret.polyListStringStart = io.readInt32();
		if(version.interiorVersion >= 12) {
			ret.staticMesh = io.readByte() > 0;
		}
		return ret;
	}
}
$hxClasses["dif.ConvexHull"] = $hx_exports["dif"]["ConvexHull"] = dif_ConvexHull;
dif_ConvexHull.__name__ = "dif.ConvexHull";
Object.assign(dif_ConvexHull.prototype, {
	__class__: dif_ConvexHull
	,hullStart: null
	,hullCount: null
	,minX: null
	,minY: null
	,minZ: null
	,maxX: null
	,maxY: null
	,maxZ: null
	,surfaceStart: null
	,surfaceCount: null
	,planeStart: null
	,polyListPlaneStart: null
	,polyListPointStart: null
	,polyListStringStart: null
	,staticMesh: null
});
class dif_CoordBin {
	constructor() {
		this.binStart = 0;
		this.binCount = 0;
	}
	write(io) {
		io.writeInt32(this.binStart);
		io.writeInt32(this.binCount);
	}
	static read(io) {
		let ret = new dif_CoordBin();
		ret.binStart = io.readInt32();
		ret.binCount = io.readInt32();
		return ret;
	}
}
$hxClasses["dif.CoordBin"] = $hx_exports["dif"]["CoordBin"] = dif_CoordBin;
dif_CoordBin.__name__ = "dif.CoordBin";
Object.assign(dif_CoordBin.prototype, {
	__class__: dif_CoordBin
	,binStart: null
	,binCount: null
});
class dif_Dif {
	constructor() {
		this.gameEntities = null;
		this.vehicleCollision = null;
	}
	write(io,version) {
		io.writeInt32(this.difVersion);
		io.writeByte(this.previewIncluded);
		dif_WriterExtensions.writeArray(io,this.interiors,function(io,p) {
			p.write(io,version);
		});
		dif_WriterExtensions.writeArray(io,this.subObjects,function(io,p) {
			p.write(io,version);
		});
		dif_WriterExtensions.writeArray(io,this.triggers,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.interiorPathfollowers,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.forceFields,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.aiSpecialNodes,function(io,p) {
			p.write(io);
		});
		if(this.vehicleCollision != null) {
			io.writeInt32(1);
			this.vehicleCollision.write(io,version);
		} else {
			io.writeInt32(0);
		}
		if(this.gameEntities != null) {
			io.writeInt32(2);
			dif_WriterExtensions.writeArray(io,this.gameEntities,function(io,p) {
				p.write(io);
			});
		} else {
			io.writeInt32(0);
		}
		io.writeInt32(0);
	}
	static LoadFromBuffer(buffer) {
		let br = new dif_io_BytesReader(buffer);
		return dif_Dif.read(br);
	}
	static SaveToBuffer(dif,version) {
		let bw = new dif_io_BytesWriter();
		dif.write(bw,version);
		return bw.getBuffer();
	}
	static LoadFromArrayBuffer(buffer) {
		let br = new dif_io_BytesReader(haxe_io_Bytes.ofData(buffer));
		return dif_Dif.read(br);
	}
	static SaveToArrayBuffer(dif,version) {
		let bw = new dif_io_BytesWriter();
		dif.write(bw,version);
		return bw.getBuffer().b.bufferValue;
	}
	static read(io) {
		let ret = new dif_Dif();
		let version = new dif_Version();
		version.difVersion = io.readInt32();
		ret.difVersion = version.difVersion;
		ret.previewIncluded = io.readByte();
		ret.interiors = dif_ReaderExtensions.readArray(io,function(io) {
			return dif_Interior.read(io,version);
		});
		ret.subObjects = dif_ReaderExtensions.readArray(io,function(io) {
			return dif_Interior.read(io,version);
		});
		ret.triggers = dif_ReaderExtensions.readArray(io,dif_Trigger.read);
		ret.interiorPathfollowers = dif_ReaderExtensions.readArray(io,dif_InteriorPathFollower.read);
		ret.forceFields = dif_ReaderExtensions.readArray(io,dif_ForceField.read);
		ret.aiSpecialNodes = dif_ReaderExtensions.readArray(io,dif_AISpecialNode.read);
		let readVehicleCollision = io.readInt32();
		if(readVehicleCollision == 1) {
			ret.vehicleCollision = dif_VehicleCollision.read(io,version);
		}
		let readGameEntities = io.readInt32();
		if(readGameEntities == 2) {
			ret.gameEntities = dif_ReaderExtensions.readArray(io,dif_GameEntity.read);
		}
		return ret;
	}
}
$hxClasses["dif.Dif"] = $hx_exports["dif"]["Dif"] = dif_Dif;
dif_Dif.__name__ = "dif.Dif";
Object.assign(dif_Dif.prototype, {
	__class__: dif_Dif
	,difVersion: null
	,previewIncluded: null
	,interiors: null
	,subObjects: null
	,triggers: null
	,interiorPathfollowers: null
	,forceFields: null
	,aiSpecialNodes: null
	,vehicleCollision: null
	,gameEntities: null
});
class dif_Edge {
	constructor(pointIndex0,pointIndex1,surfaceIndex0,surfaceIndex1) {
		this.pointIndex0 = pointIndex0;
		this.pointIndex1 = pointIndex1;
		this.surfaceIndex0 = surfaceIndex0;
		this.surfaceIndex1 = surfaceIndex1;
	}
	write(io,version) {
		io.writeInt32(this.pointIndex0);
		io.writeInt32(this.pointIndex1);
		io.writeInt32(this.surfaceIndex0);
		io.writeInt32(this.surfaceIndex1);
	}
	static read(io,version) {
		return new dif_Edge(io.readInt32(),io.readInt32(),io.readInt32(),io.readInt32());
	}
}
$hxClasses["dif.Edge"] = $hx_exports["dif"]["Edge"] = dif_Edge;
dif_Edge.__name__ = "dif.Edge";
Object.assign(dif_Edge.prototype, {
	__class__: dif_Edge
	,pointIndex0: null
	,pointIndex1: null
	,surfaceIndex0: null
	,surfaceIndex1: null
	,farPoint0: null
	,farPoint1: null
});
class dif_Edge2 {
	constructor() {
		this.vertex0 = 0;
		this.vertex1 = 0;
		this.normal0 = 0;
		this.normal1 = 0;
		this.face0 = 0;
		this.face1 = 0;
	}
	write(io,version) {
		io.writeInt32(this.vertex0);
		io.writeInt32(this.vertex1);
		io.writeInt32(this.normal0);
		io.writeInt32(this.normal1);
		if(version.interiorVersion >= 3) {
			io.writeInt32(this.face0);
			io.writeInt32(this.face1);
		}
	}
	static read(io,version) {
		let ret = new dif_Edge2();
		ret.vertex0 = io.readInt32();
		ret.vertex1 = io.readInt32();
		ret.normal0 = io.readInt32();
		ret.normal1 = io.readInt32();
		if(version.interiorVersion >= 3) {
			ret.face0 = io.readInt32();
			ret.face1 = io.readInt32();
		}
		return ret;
	}
}
$hxClasses["dif.Edge2"] = $hx_exports["dif"]["Edge2"] = dif_Edge2;
dif_Edge2.__name__ = "dif.Edge2";
Object.assign(dif_Edge2.prototype, {
	__class__: dif_Edge2
	,vertex0: null
	,vertex1: null
	,normal0: null
	,normal1: null
	,face0: null
	,face1: null
});
class dif_FFSurface {
	constructor() {
		this.windingStart = 0;
		this.windingCount = 0;
		this.planeIndex = 0;
		this.surfaceFlags = 0;
		this.fanMask = 0;
	}
	write(io) {
		io.writeInt32(this.windingStart);
		io.writeByte(this.windingCount);
		io.writeInt16(this.planeIndex);
		io.writeByte(this.surfaceFlags);
		io.writeInt32(this.fanMask);
	}
	static read(io) {
		let ret = new dif_FFSurface();
		ret.windingStart = io.readInt32();
		ret.windingCount = io.readByte();
		ret.planeIndex = io.readInt16();
		ret.surfaceFlags = io.readByte();
		ret.fanMask = io.readInt32();
		return ret;
	}
}
$hxClasses["dif.FFSurface"] = $hx_exports["dif"]["FFSurface"] = dif_FFSurface;
dif_FFSurface.__name__ = "dif.FFSurface";
Object.assign(dif_FFSurface.prototype, {
	__class__: dif_FFSurface
	,windingStart: null
	,windingCount: null
	,planeIndex: null
	,surfaceFlags: null
	,fanMask: null
});
class dif_ForceField {
	constructor() {
	}
	write(io) {
		io.writeInt32(this.forceFieldFileVersion);
		io.writeStr(this.name);
		dif_WriterExtensions.writeArray(io,this.triggers,function(io,p) {
			io.writeStr(p);
		});
		this.boundingBox.write(io);
		this.boundingSphere.write(io);
		dif_WriterExtensions.writeArray(io,this.normals,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.planes,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.bspNodes,function(io,p) {
			p.write(io,new dif_Version());
		});
		dif_WriterExtensions.writeArray(io,this.bspSolidLeaves,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.windings,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeArray(io,this.surfaces,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.solidLeafSurfaces,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeColorF(io,this.color);
	}
	static read(io) {
		let ret = new dif_ForceField();
		ret.forceFieldFileVersion = io.readInt32();
		ret.name = io.readStr();
		ret.triggers = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readStr();
		});
		ret.boundingBox = dif_math_Box3F.read(io);
		ret.boundingSphere = dif_math_Spheref.read(io);
		ret.normals = dif_ReaderExtensions.readArray(io,dif_math_Point3F.read);
		ret.planes = dif_ReaderExtensions.readArray(io,dif_Plane.read);
		ret.bspNodes = dif_ReaderExtensions.readArray(io,function(io) {
			return dif_BSPNode.read(io,new dif_Version());
		});
		ret.bspSolidLeaves = dif_ReaderExtensions.readArray(io,dif_BSPSolidLeaf.read);
		ret.windings = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.surfaces = dif_ReaderExtensions.readArray(io,dif_FFSurface.read);
		ret.solidLeafSurfaces = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.color = dif_ReaderExtensions.readColorF(io);
		return ret;
	}
}
$hxClasses["dif.ForceField"] = $hx_exports["dif"]["ForceField"] = dif_ForceField;
dif_ForceField.__name__ = "dif.ForceField";
Object.assign(dif_ForceField.prototype, {
	__class__: dif_ForceField
	,forceFieldFileVersion: null
	,name: null
	,triggers: null
	,boundingBox: null
	,boundingSphere: null
	,normals: null
	,planes: null
	,bspNodes: null
	,bspSolidLeaves: null
	,windings: null
	,surfaces: null
	,solidLeafSurfaces: null
	,color: null
});
class dif_GameEntity {
	constructor() {
		this.datablock = "";
		this.gameClass = "";
		this.position = new dif_math_Point3F();
		this.properties = new haxe_ds_StringMap();
	}
	write(io) {
		io.writeStr(this.datablock);
		io.writeStr(this.gameClass);
		this.position.write(io);
		dif_WriterExtensions.writeDictionary(io,this.properties);
	}
	static read(io) {
		let ret = new dif_GameEntity();
		ret.datablock = io.readStr();
		ret.gameClass = io.readStr();
		ret.position = dif_math_Point3F.read(io);
		ret.properties = dif_ReaderExtensions.readDictionary(io);
		return ret;
	}
}
$hxClasses["dif.GameEntity"] = $hx_exports["dif"]["GameEntity"] = dif_GameEntity;
dif_GameEntity.__name__ = "dif.GameEntity";
Object.assign(dif_GameEntity.prototype, {
	__class__: dif_GameEntity
	,datablock: null
	,gameClass: null
	,position: null
	,properties: null
});
class dif_Interior {
	constructor() {
	}
	write(io,version) {
		io.writeInt32(this.detailLevel);
		io.writeInt32(this.minPixels);
		this.boundingBox.write(io);
		this.boundingSphere.write(io);
		io.writeByte(this.hasAlarmState);
		io.writeInt32(this.numLightStateEntries);
		dif_WriterExtensions.writeArray(io,this.normals,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.planes,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.points,function(io,p) {
			p.write(io);
		});
		if(version.interiorVersion != 4) {
			dif_WriterExtensions.writeArray(io,this.pointVisibilities,function(io,p) {
				io.writeByte(p);
			});
		}
		dif_WriterExtensions.writeArray(io,this.texGenEQs,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.bspNodes,function(io,p) {
			p.write(io,version);
		});
		dif_WriterExtensions.writeArray(io,this.bspSolidLeaves,function(io,p) {
			p.write(io);
		});
		io.writeByte(this.materialListVersion);
		dif_WriterExtensions.writeArray(io,this.materialList,function(io,p) {
			io.writeStr(p);
		});
		dif_WriterExtensions.writeArray(io,this.windings,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeArray(io,this.windingIndices,function(io,p) {
			p.write(io);
		});
		if(version.interiorVersion >= 12) {
			dif_WriterExtensions.writeArray(io,this.edges,function(io,p) {
				p.write(io,version);
			});
		}
		dif_WriterExtensions.writeArray(io,this.zones,function(io,p) {
			p.write(io,version);
		});
		dif_WriterExtensions.writeArray(io,this.zoneSurfaces,function(io,p) {
			io.writeUInt16(p);
		});
		if(version.interiorVersion >= 12) {
			dif_WriterExtensions.writeArray(io,this.zoneStaticMeshes,function(io,p) {
				io.writeInt32(p);
			});
		}
		dif_WriterExtensions.writeArray(io,this.zonePortalList,function(io,p) {
			io.writeUInt16(p);
		});
		dif_WriterExtensions.writeArray(io,this.portals,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.surfaces,function(io,p) {
			p.write(io,version);
		});
		if(version.interiorVersion >= 2 && version.interiorVersion <= 5) {
			dif_WriterExtensions.writeArray(io,this.edges2,function(io,p) {
				p.write(io,version);
			});
			if(version.interiorVersion >= 4 && version.interiorVersion <= 5) {
				dif_WriterExtensions.writeArray(io,this.normals2,function(io,p) {
					p.write(io);
				});
				dif_WriterExtensions.writeArray(io,this.normalIndices,function(io,p) {
					io.writeUInt16(p);
				});
			}
		}
		if(version.interiorVersion == 4) {
			dif_WriterExtensions.writeArray(io,this.normalLMapIndices,function(io,p) {
				io.writeByte(p);
			});
		} else if(version.interiorVersion >= 13) {
			dif_WriterExtensions.writeArray(io,this.normalLMapIndices,function(io,p) {
				io.writeInt32(p);
			});
			dif_WriterExtensions.writeArray(io,this.normalLMapIndices,function(io,p) {
				io.writeInt32(p);
			});
		} else {
			dif_WriterExtensions.writeArray(io,this.normalLMapIndices,function(io,p) {
				io.writeByte(p);
			});
			dif_WriterExtensions.writeArray(io,this.normalLMapIndices,function(io,p) {
				io.writeByte(p);
			});
		}
		dif_WriterExtensions.writeArray(io,this.nullSurfaces,function(io,p) {
			p.write(io,version);
		});
		if(version.interiorVersion != 4) {
			dif_WriterExtensions.writeArray(io,this.lightMaps,function(io,p) {
				p.writeLightMap(io,version);
			});
		}
		dif_WriterExtensions.writeArray(io,this.solidLeafSurfaces,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeArray(io,this.animatedLights,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.lightStates,function(io,p) {
			p.write(io);
		});
		if(version.interiorVersion != 4) {
			dif_WriterExtensions.writeArray(io,this.stateDatas,function(io,p) {
				p.write(io);
			});
			dif_WriterExtensions.writeArrayFlags(io,this.stateDataBuffers,this.stateDataFlags,function(io,p) {
				io.writeByte(p);
			});
			dif_WriterExtensions.writeArray(io,this.nameBuffer,function(io,p) {
				io.writeByte(p);
			});
			io.writeInt32(this.numSubObjects);
		}
		dif_WriterExtensions.writeArray(io,this.convexHulls,function(io,p) {
			p.write(io,version);
		});
		dif_WriterExtensions.writeArray(io,this.convexHullEmitStrings,function(io,p) {
			io.writeByte(p);
		});
		dif_WriterExtensions.writeArray(io,this.hullIndices,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeArray(io,this.hullPlaneIndices,function(io,p) {
			io.writeInt16(p);
		});
		dif_WriterExtensions.writeArray(io,this.hullEmitStringIndices,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeArray(io,this.hullSurfaceIndices,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeArray(io,this.polyListPlanes,function(io,p) {
			io.writeInt16(p);
		});
		dif_WriterExtensions.writeArray(io,this.polyListPoints,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeArray(io,this.polyListStrings,function(io,p) {
			io.writeByte(p);
		});
		let _g = 0;
		while(_g < 256) {
			let i = _g++;
			this.coordBins[i].write(io);
		}
		dif_WriterExtensions.writeArray(io,this.coordBinIndices,function(io,p) {
			io.writeInt16(p);
		});
		io.writeInt32(this.coordBinMode);
		if(version.interiorVersion != 4) {
			dif_WriterExtensions.writeColorF(io,this.baseAmbientColor);
			dif_WriterExtensions.writeColorF(io,this.alarmAmbientColor);
			if(version.interiorVersion >= 10) {
				io.writeInt32(this.numStaticMeshes);
			}
			if(version.interiorVersion >= 11) {
				dif_WriterExtensions.writeArray(io,this.texNormals,function(io,p) {
					p.write(io);
				});
				dif_WriterExtensions.writeArray(io,this.texNormals,function(io,p) {
					p.write(io);
				});
				dif_WriterExtensions.writeArray(io,this.texMatIndices,function(io,p) {
					io.writeInt32(p);
				});
			} else {
				io.writeInt32(0);
				io.writeInt32(0);
				io.writeInt32(0);
			}
			io.writeInt32(this.extendedLightMapData);
			if(this.extendedLightMapData > 0) {
				io.writeInt32(this.lightMapBorderSize);
				io.writeInt32(0);
			}
		}
	}
	static read(io,version) {
		if(version.interiorType == "?") {
			version.interiorType = "tgea";
		}
		version.interiorVersion = io.readInt32();
		let it = new dif_Interior();
		it.detailLevel = io.readInt32();
		it.minPixels = io.readInt32();
		it.boundingBox = dif_math_Box3F.read(io);
		it.boundingSphere = dif_math_Spheref.read(io);
		it.hasAlarmState = io.readByte();
		it.numLightStateEntries = io.readInt32();
		it.normals = dif_ReaderExtensions.readArray(io,dif_math_Point3F.read);
		it.planes = dif_ReaderExtensions.readArray(io,dif_Plane.read);
		it.points = dif_ReaderExtensions.readArray(io,dif_math_Point3F.read);
		if(version.interiorVersion == 4) {
			it.pointVisibilities = [];
		} else {
			it.pointVisibilities = dif_ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
		}
		it.texGenEQs = dif_ReaderExtensions.readArray(io,dif_TexGenEQ.read);
		it.bspNodes = dif_ReaderExtensions.readArray(io,function(io) {
			return dif_BSPNode.read(io,version);
		});
		it.bspSolidLeaves = dif_ReaderExtensions.readArray(io,dif_BSPSolidLeaf.read);
		it.materialListVersion = io.readByte();
		it.materialList = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readStr();
		});
		it.windings = dif_ReaderExtensions.readArrayAs(io,function(signed,param) {
			return param > 0;
		},function(io) {
			return io.readInt32();
		},function(io) {
			return io.readInt16();
		});
		it.windingIndices = dif_ReaderExtensions.readArray(io,dif_WindingIndex.read);
		if(version.interiorVersion >= 12) {
			it.edges = dif_ReaderExtensions.readArray(io,function(io) {
				return dif_Edge.read(io,version);
			});
		}
		it.zones = dif_ReaderExtensions.readArray(io,function(io) {
			return dif_Zone.read(io,version);
		});
		it.zoneSurfaces = dif_ReaderExtensions.readArrayAs(io,function(signed,param) {
			return false;
		},function(io) {
			return io.readInt16();
		},function(io) {
			return io.readInt16();
		});
		if(version.interiorVersion >= 12) {
			it.zoneStaticMeshes = dif_ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
		}
		it.zonePortalList = dif_ReaderExtensions.readArrayAs(io,function(signed,param) {
			return false;
		},function(io) {
			return io.readInt16();
		},function(io) {
			return io.readInt16();
		});
		it.portals = dif_ReaderExtensions.readArray(io,dif_Portal.read);
		let pos = io.tell();
		try {
			it.surfaces = dif_ReaderExtensions.readArray(io,function(io) {
				return dif_Surface.read(io,version,it);
			});
			if(version.interiorType == "?") {
				version.interiorType = "tge";
			}
		} catch( _g ) {
			if(version.interiorType == "tgea") {
				version.interiorType = "tge";
			}
			io.seek(pos);
			try {
				it.surfaces = dif_ReaderExtensions.readArray(io,function(io) {
					return dif_Surface.read(io,version,it);
				});
			} catch( _g ) {
			}
		}
		if(version.interiorVersion >= 2 && version.interiorVersion <= 5) {
			it.edges2 = dif_ReaderExtensions.readArray(io,function(io) {
				return dif_Edge2.read(io,version);
			});
			if(version.interiorVersion >= 4 && version.interiorVersion <= 5) {
				it.normals2 = dif_ReaderExtensions.readArray(io,dif_math_Point3F.read);
				it.normalIndices = dif_ReaderExtensions.readArrayAs(io,function(alt,param) {
					if(alt) {
						return param == 0;
					} else {
						return false;
					}
				},function(io) {
					return io.readUInt16();
				},function(io) {
					return io.readByte();
				});
			}
		}
		if(version.interiorVersion == 4) {
			it.normalLMapIndices = dif_ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
			it.alarmLMapIndices = [];
		} else if(version.interiorVersion >= 13) {
			it.normalLMapIndices = dif_ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
			it.alarmLMapIndices = dif_ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
		} else {
			it.normalLMapIndices = dif_ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
			it.alarmLMapIndices = dif_ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
		}
		it.nullSurfaces = dif_ReaderExtensions.readArray(io,function(io) {
			return dif_NullSurface.read(io,version);
		});
		if(version.interiorVersion != 4) {
			it.lightMaps = dif_ReaderExtensions.readArray(io,function(io) {
				return dif_LightMap.read(io,version);
			});
			if(it.lightMaps.length > 0 && version.interiorType == "mbg") {
				version.interiorType = "tge";
			}
		} else {
			it.lightMaps = [];
		}
		it.solidLeafSurfaces = dif_ReaderExtensions.readArrayAs(io,function(alt,$void) {
			return alt;
		},function(io) {
			return io.readInt32();
		},function(io) {
			return io.readUInt16();
		});
		it.animatedLights = dif_ReaderExtensions.readArray(io,dif_AnimatedLight.read);
		it.lightStates = dif_ReaderExtensions.readArray(io,dif_LightState.read);
		if(version.interiorVersion == 4) {
			it.stateDatas = [];
			it.stateDataFlags = 0;
			it.stateDataBuffers = [];
			it.numSubObjects = 0;
		} else {
			it.stateDatas = dif_ReaderExtensions.readArray(io,dif_StateData.read);
			it.stateDataBuffers = dif_ReaderExtensions.readArrayFlags(io,function(io) {
				return io.readByte();
			});
			it.nameBuffer = dif_ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
			it.stateDataFlags = 0;
			it.numSubObjects = io.readInt32();
		}
		it.convexHulls = dif_ReaderExtensions.readArray(io,function(io) {
			return dif_ConvexHull.read(io,version);
		});
		it.convexHullEmitStrings = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readByte();
		});
		it.hullIndices = dif_ReaderExtensions.readArrayAs(io,function(alt,that) {
			return alt;
		},function(io) {
			return io.readInt32();
		},function(io) {
			return io.readUInt16();
		});
		it.hullPlaneIndices = dif_ReaderExtensions.readArrayAs(io,function(alt,that) {
			return true;
		},function(io) {
			return io.readUInt16();
		},function(io) {
			return io.readUInt16();
		});
		it.hullEmitStringIndices = dif_ReaderExtensions.readArrayAs(io,function(alt,that) {
			return alt;
		},function(io) {
			return io.readInt32();
		},function(io) {
			return io.readUInt16();
		});
		it.hullSurfaceIndices = dif_ReaderExtensions.readArrayAs(io,function(alt,that) {
			return alt;
		},function(io) {
			return io.readInt32();
		},function(io) {
			return io.readUInt16();
		});
		it.polyListPlanes = dif_ReaderExtensions.readArrayAs(io,function(alt,that) {
			return true;
		},function(io) {
			return io.readUInt16();
		},function(io) {
			return io.readUInt16();
		});
		it.polyListPoints = dif_ReaderExtensions.readArrayAs(io,function(alt,that) {
			return alt;
		},function(io) {
			return io.readInt32();
		},function(io) {
			return io.readUInt16();
		});
		it.polyListStrings = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readByte();
		});
		it.coordBins = [];
		let _g = 0;
		while(_g < 256) {
			++_g;
			it.coordBins.push(dif_CoordBin.read(io));
		}
		it.coordBinIndices = dif_ReaderExtensions.readArrayAs(io,function(a,b) {
			return true;
		},function(io) {
			return io.readUInt16();
		},function(io) {
			return io.readUInt16();
		});
		it.coordBinMode = io.readInt32();
		if(version.interiorVersion == 4) {
			it.baseAmbientColor = [0,0,0,255];
			it.alarmAmbientColor = [0,0,0,255];
			it.extendedLightMapData = 0;
			it.lightMapBorderSize = 0;
		} else {
			it.baseAmbientColor = dif_ReaderExtensions.readColorF(io);
			it.alarmAmbientColor = dif_ReaderExtensions.readColorF(io);
			if(version.interiorVersion >= 10) {
				it.numStaticMeshes = io.readInt32();
			}
			if(version.interiorVersion >= 11) {
				it.texNormals = dif_ReaderExtensions.readArray(io,dif_math_Point3F.read);
				it.texMatrices = dif_ReaderExtensions.readArray(io,dif_TexMatrix.read);
				it.texMatIndices = dif_ReaderExtensions.readArray(io,function(io) {
					return io.readInt32();
				});
			} else {
				io.readInt32();
				io.readInt32();
				io.readInt32();
			}
			it.extendedLightMapData = io.readInt32();
			if(it.extendedLightMapData > 0) {
				it.lightMapBorderSize = io.readInt32();
				io.readInt32();
			}
		}
		return it;
	}
}
$hxClasses["dif.Interior"] = $hx_exports["dif"]["Interior"] = dif_Interior;
dif_Interior.__name__ = "dif.Interior";
Object.assign(dif_Interior.prototype, {
	__class__: dif_Interior
	,detailLevel: null
	,minPixels: null
	,boundingBox: null
	,boundingSphere: null
	,hasAlarmState: null
	,numLightStateEntries: null
	,normals: null
	,planes: null
	,points: null
	,pointVisibilities: null
	,texGenEQs: null
	,bspNodes: null
	,bspSolidLeaves: null
	,materialListVersion: null
	,materialList: null
	,windings: null
	,windingIndices: null
	,edges: null
	,zones: null
	,zoneSurfaces: null
	,zoneStaticMeshes: null
	,zonePortalList: null
	,portals: null
	,surfaces: null
	,edges2: null
	,normals2: null
	,normalIndices: null
	,normalLMapIndices: null
	,alarmLMapIndices: null
	,nullSurfaces: null
	,lightMaps: null
	,solidLeafSurfaces: null
	,animatedLights: null
	,lightStates: null
	,stateDatas: null
	,stateDataFlags: null
	,stateDataBuffers: null
	,nameBuffer: null
	,numSubObjects: null
	,convexHulls: null
	,convexHullEmitStrings: null
	,hullIndices: null
	,hullPlaneIndices: null
	,hullEmitStringIndices: null
	,hullSurfaceIndices: null
	,polyListPlanes: null
	,polyListPoints: null
	,polyListStrings: null
	,coordBins: null
	,coordBinIndices: null
	,coordBinMode: null
	,baseAmbientColor: null
	,alarmAmbientColor: null
	,numStaticMeshes: null
	,texNormals: null
	,texMatrices: null
	,texMatIndices: null
	,extendedLightMapData: null
	,lightMapBorderSize: null
});
class dif_InteriorPathFollower {
	constructor() {
		this.name = "";
		this.datablock = "";
		this.interiorResIndex = 0;
		this.offset = new dif_math_Point3F();
		this.properties = new haxe_ds_StringMap();
		this.triggerId = [];
		this.wayPoint = [];
		this.totalMS = 0;
	}
	write(io) {
		io.writeStr(this.name);
		io.writeStr(this.datablock);
		io.writeInt32(this.interiorResIndex);
		this.offset.write(io);
		dif_WriterExtensions.writeDictionary(io,this.properties);
		dif_WriterExtensions.writeArray(io,this.triggerId,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeArray(io,this.wayPoint,function(io,p) {
			p.write(io);
		});
		io.writeInt32(this.totalMS);
	}
	static read(io) {
		let ret = new dif_InteriorPathFollower();
		ret.name = io.readStr();
		ret.datablock = io.readStr();
		ret.interiorResIndex = io.readInt32();
		ret.offset = dif_math_Point3F.read(io);
		ret.properties = dif_ReaderExtensions.readDictionary(io);
		ret.triggerId = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.wayPoint = dif_ReaderExtensions.readArray(io,dif_WayPoint.read);
		ret.totalMS = io.readInt32();
		return ret;
	}
}
$hxClasses["dif.InteriorPathFollower"] = $hx_exports["dif"]["InteriorPathFollower"] = dif_InteriorPathFollower;
dif_InteriorPathFollower.__name__ = "dif.InteriorPathFollower";
Object.assign(dif_InteriorPathFollower.prototype, {
	__class__: dif_InteriorPathFollower
	,name: null
	,datablock: null
	,interiorResIndex: null
	,offset: null
	,properties: null
	,triggerId: null
	,wayPoint: null
	,totalMS: null
});
class dif_LightMap {
	constructor() {
		this.lightmap = [];
		this.lightdirmap = [];
		this.keepLightMap = 0;
	}
	writeLightMap(io,version) {
		dif_WriterExtensions.writePNG(io,this.lightmap);
		if(version.interiorType != "mbg" && version.interiorType != "tge") {
			dif_WriterExtensions.writePNG(io,this.lightdirmap);
		}
		io.writeByte(this.keepLightMap);
	}
	static read(io,version) {
		let ret = new dif_LightMap();
		ret.lightmap = dif_ReaderExtensions.readPNG(io);
		if(version.interiorType != "mbg" && version.interiorType != "tge") {
			ret.lightdirmap = dif_ReaderExtensions.readPNG(io);
		}
		ret.keepLightMap = io.readByte();
		return ret;
	}
}
$hxClasses["dif.LightMap"] = $hx_exports["dif"]["LightMap"] = dif_LightMap;
dif_LightMap.__name__ = "dif.LightMap";
Object.assign(dif_LightMap.prototype, {
	__class__: dif_LightMap
	,lightmap: null
	,lightdirmap: null
	,keepLightMap: null
});
class dif_LightState {
	constructor(red,green,blue,activeTime,dataIndex,dataCount) {
		this.red = red;
		this.green = green;
		this.blue = blue;
		this.activeTime = activeTime;
		this.dataIndex = dataIndex;
		this.dataCount = dataCount;
	}
	write(io) {
		io.writeByte(this.red);
		io.writeByte(this.green);
		io.writeByte(this.blue);
		io.writeInt32(this.activeTime);
		io.writeInt32(this.dataIndex);
		io.writeInt16(this.dataCount);
	}
	static read(io) {
		return new dif_LightState(io.readByte(),io.readByte(),io.readByte(),io.readInt32(),io.readInt32(),io.readInt16());
	}
}
$hxClasses["dif.LightState"] = $hx_exports["dif"]["LightState"] = dif_LightState;
dif_LightState.__name__ = "dif.LightState";
Object.assign(dif_LightState.prototype, {
	__class__: dif_LightState
	,red: null
	,green: null
	,blue: null
	,activeTime: null
	,dataIndex: null
	,dataCount: null
});
class dif_NullSurface {
	constructor() {
		this.windingStart = 0;
		this.planeIndex = 0;
		this.surfaceFlags = 0;
		this.windingCount = 0;
	}
	write(io,version) {
		io.writeInt32(this.windingStart);
		io.writeUInt16(this.planeIndex);
		io.writeByte(this.surfaceFlags);
		if(version.interiorVersion >= 13) {
			io.writeInt32(this.windingCount);
		} else {
			io.writeByte(this.windingCount);
		}
	}
	static read(io,version) {
		let ret = new dif_NullSurface();
		ret.windingStart = io.readInt32();
		ret.planeIndex = io.readUInt16();
		ret.surfaceFlags = io.readByte();
		if(version.interiorVersion >= 13) {
			ret.windingCount = io.readInt32();
		} else {
			ret.windingCount = io.readByte();
		}
		return ret;
	}
}
$hxClasses["dif.NullSurface"] = $hx_exports["dif"]["NullSurface"] = dif_NullSurface;
dif_NullSurface.__name__ = "dif.NullSurface";
Object.assign(dif_NullSurface.prototype, {
	__class__: dif_NullSurface
	,windingStart: null
	,planeIndex: null
	,surfaceFlags: null
	,windingCount: null
});
class dif_Plane {
	constructor(normalIndex,planeDistance) {
		this.normalIndex = normalIndex;
		this.planeDistance = planeDistance;
	}
	write(io) {
		io.writeInt16(this.normalIndex);
		io.writeFloat(this.planeDistance);
	}
	static read(io) {
		return new dif_Plane(io.readInt16(),io.readFloat());
	}
}
$hxClasses["dif.Plane"] = $hx_exports["dif"]["Plane"] = dif_Plane;
dif_Plane.__name__ = "dif.Plane";
Object.assign(dif_Plane.prototype, {
	__class__: dif_Plane
	,normalIndex: null
	,planeDistance: null
});
class dif_Polyhedron {
	constructor() {
		this.pointList = [];
		this.planeList = [];
		this.edgeList = [];
	}
	write(io) {
		dif_WriterExtensions.writeArray(io,this.pointList,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.planeList,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.edgeList,function(io,p) {
			p.write(io);
		});
	}
	static read(io) {
		let ret = new dif_Polyhedron();
		ret.pointList = dif_ReaderExtensions.readArray(io,dif_math_Point3F.read);
		ret.planeList = dif_ReaderExtensions.readArray(io,dif_math_PlaneF.read);
		ret.edgeList = dif_ReaderExtensions.readArray(io,dif_PolyhedronEdge.read);
		return ret;
	}
}
$hxClasses["dif.Polyhedron"] = $hx_exports["dif"]["Polyhedron"] = dif_Polyhedron;
dif_Polyhedron.__name__ = "dif.Polyhedron";
Object.assign(dif_Polyhedron.prototype, {
	__class__: dif_Polyhedron
	,pointList: null
	,planeList: null
	,edgeList: null
});
class dif_PolyhedronEdge {
	constructor(faceIndex0,faceIndex1,pointIndex0,pointIndex1) {
		this.pointIndex0 = pointIndex0;
		this.pointIndex1 = pointIndex1;
		this.faceIndex0 = faceIndex0;
		this.faceIndex1 = faceIndex1;
	}
	write(io) {
		io.writeInt32(this.faceIndex0);
		io.writeInt32(this.faceIndex1);
		io.writeInt32(this.pointIndex0);
		io.writeInt32(this.pointIndex1);
	}
	static read(io) {
		return new dif_PolyhedronEdge(io.readInt32(),io.readInt32(),io.readInt32(),io.readInt32());
	}
}
$hxClasses["dif.PolyhedronEdge"] = $hx_exports["dif"]["PolyhedronEdge"] = dif_PolyhedronEdge;
dif_PolyhedronEdge.__name__ = "dif.PolyhedronEdge";
Object.assign(dif_PolyhedronEdge.prototype, {
	__class__: dif_PolyhedronEdge
	,pointIndex0: null
	,pointIndex1: null
	,faceIndex0: null
	,faceIndex1: null
});
class dif_Portal {
	constructor(planeIndex,triFanCount,triFanStart,zoneFront,zoneBack) {
		this.planeIndex = planeIndex;
		this.triFanCount = triFanCount;
		this.triFanStart = triFanStart;
		this.zoneFront = zoneFront;
		this.zoneBack = zoneBack;
	}
	write(io) {
		io.writeUInt16(this.planeIndex);
		io.writeUInt16(this.triFanCount);
		io.writeInt32(this.triFanStart);
		io.writeUInt16(this.zoneFront);
		io.writeUInt16(this.zoneBack);
	}
	static read(io) {
		return new dif_Portal(io.readUInt16(),io.readUInt16(),io.readInt32(),io.readUInt16(),io.readUInt16());
	}
}
$hxClasses["dif.Portal"] = $hx_exports["dif"]["Portal"] = dif_Portal;
dif_Portal.__name__ = "dif.Portal";
Object.assign(dif_Portal.prototype, {
	__class__: dif_Portal
	,planeIndex: null
	,triFanCount: null
	,triFanStart: null
	,zoneFront: null
	,zoneBack: null
});
class dif_ReaderExtensions {
	static readDictionary(io) {
		let len = io.readInt32();
		let dict = new haxe_ds_StringMap();
		let _g = 0;
		while(_g < len) {
			++_g;
			let name = io.readStr();
			let value = io.readStr();
			dict.h[name] = value;
		}
		return dict;
	}
	static readArray(io,readMethod) {
		let len = io.readInt32();
		let arr = [];
		let _g = 0;
		while(_g < len) {
			++_g;
			arr.push(readMethod(io));
		}
		return arr;
	}
	static readArrayAs(io,test,failMethod,passMethod) {
		let length = io.readInt32();
		let signed = false;
		let param = 0;
		if((length & -2147483648) == -2147483648) {
			length ^= -2147483648;
			signed = true;
			param = io.readByte();
		}
		let array = [];
		let _g = 0;
		let _g1 = length;
		while(_g < _g1) {
			++_g;
			if(test(signed,param)) {
				array.push(passMethod(io));
			} else {
				array.push(failMethod(io));
			}
		}
		return array;
	}
	static readArrayFlags(io,readMethod) {
		let length = io.readInt32();
		io.readInt32();
		let array = [];
		let _g = 0;
		while(_g < length) {
			++_g;
			array.push(readMethod(io));
		}
		return array;
	}
	static readPNG(io) {
		let footer = [73,69,78,68,174,66,96,130];
		let data = [];
		while(true) {
			data.push(io.readByte());
			if(data.length >= 8) {
				let match = true;
				let _g = 0;
				while(_g < 8) {
					let i = _g++;
					if(data[i + (data.length - 8)] != footer[i]) {
						match = false;
						break;
					}
				}
				if(match) {
					break;
				}
			}
		}
		return data;
	}
	static readColorF(io) {
		return [io.readByte(),io.readByte(),io.readByte(),io.readByte()];
	}
}
$hxClasses["dif.ReaderExtensions"] = dif_ReaderExtensions;
dif_ReaderExtensions.__name__ = "dif.ReaderExtensions";
class dif_StateData {
	constructor(surfaceIndex,mapIndex,lightStateIndex) {
		this.surfaceIndex = surfaceIndex;
		this.mapIndex = mapIndex;
		this.lightStateIndex = lightStateIndex;
	}
	write(io) {
		io.writeInt32(this.surfaceIndex);
		io.writeInt32(this.mapIndex);
		io.writeInt32(this.lightStateIndex);
	}
	static read(io) {
		return new dif_StateData(io.readInt32(),io.readInt32(),io.readInt32());
	}
}
$hxClasses["dif.StateData"] = $hx_exports["dif"]["StateData"] = dif_StateData;
dif_StateData.__name__ = "dif.StateData";
Object.assign(dif_StateData.prototype, {
	__class__: dif_StateData
	,surfaceIndex: null
	,mapIndex: null
	,lightStateIndex: null
});
class dif_Surface {
	constructor() {
		this.windingStart = 0;
		this.windingCount = 0;
		this.planeIndex = 0;
		this.textureIndex = 0;
		this.texGenIndex = 0;
		this.surfaceFlags = 0;
		this.fanMask = 0;
		this.lightMapFinalWord = 0;
		this.lightMapTexGenXD = 0;
		this.lightMapTexGenYD = 0;
		this.lightCount = 0;
		this.lightStateInfoStart = 0;
		this.mapOffsetX = 0;
		this.mapOffsetY = 0;
		this.mapSizeX = 0;
		this.mapSizeY = 0;
		this.brushId = 0;
	}
	write(io,version) {
		io.writeInt32(this.windingStart);
		if(version.interiorVersion >= 13) {
			io.writeInt32(this.windingCount);
		} else {
			io.writeByte(this.windingCount);
		}
		io.writeInt16(this.planeIndex);
		io.writeInt16(this.textureIndex);
		io.writeInt32(this.texGenIndex);
		io.writeByte(this.surfaceFlags);
		io.writeInt32(this.fanMask);
		io.writeInt16(this.lightMapFinalWord);
		io.writeFloat(this.lightMapTexGenXD);
		io.writeFloat(this.lightMapTexGenYD);
		io.writeInt16(this.lightCount);
		io.writeInt32(this.lightStateInfoStart);
		if(version.interiorVersion >= 13) {
			io.writeInt32(this.mapOffsetX);
			io.writeInt32(this.mapOffsetY);
			io.writeInt32(this.mapSizeX);
			io.writeInt32(this.mapSizeY);
		} else {
			io.writeByte(this.mapOffsetX);
			io.writeByte(this.mapOffsetY);
			io.writeByte(this.mapSizeX);
			io.writeByte(this.mapSizeY);
		}
		if(version.interiorType != "tge" && version.interiorType != "mbg") {
			io.writeByte(0);
			if(version.interiorVersion >= 2 && version.interiorVersion <= 5) {
				io.writeInt32(this.brushId);
			}
		}
	}
	static read(io,version,interior) {
		let ret = new dif_Surface();
		ret.windingStart = io.readInt32();
		if(interior.windings.length <= ret.windingStart) {
			throw new haxe_Exception("DIF Type Error");
		}
		if(version.interiorVersion >= 13) {
			ret.windingCount = io.readInt32();
		} else {
			ret.windingCount = io.readByte();
		}
		if(ret.windingStart + ret.windingCount > interior.windings.length) {
			throw new haxe_Exception("DIF Type Error");
		}
		ret.planeIndex = io.readInt16();
		let planeIndexTemp = ret.planeIndex & -32769;
		if((planeIndexTemp & -32769) >= interior.planes.length) {
			throw new haxe_Exception("DIF Type Error");
		}
		ret.textureIndex = io.readInt16();
		if(ret.textureIndex >= interior.materialList.length) {
			throw new haxe_Exception("DIF Type Error");
		}
		ret.texGenIndex = io.readInt32();
		if(ret.texGenIndex >= interior.texGenEQs.length) {
			throw new haxe_Exception("DIF Type Error");
		}
		ret.surfaceFlags = io.readByte();
		ret.fanMask = io.readInt32();
		ret.lightMapFinalWord = io.readInt16();
		ret.lightMapTexGenXD = io.readFloat();
		ret.lightMapTexGenYD = io.readFloat();
		ret.lightCount = io.readInt16();
		ret.lightStateInfoStart = io.readInt32();
		if(version.interiorVersion >= 13) {
			ret.mapOffsetX = io.readInt32();
			ret.mapOffsetY = io.readInt32();
			ret.mapSizeX = io.readInt32();
			ret.mapSizeY = io.readInt32();
		} else {
			ret.mapOffsetX = io.readByte();
			ret.mapOffsetY = io.readByte();
			ret.mapSizeX = io.readByte();
			ret.mapSizeY = io.readByte();
		}
		if(version.interiorType != "tge" && version.interiorType != "mbg") {
			io.readByte();
			if(version.interiorVersion >= 2 && version.interiorVersion <= 5) {
				ret.brushId = io.readInt32();
			}
		}
		return ret;
	}
}
$hxClasses["dif.Surface"] = $hx_exports["dif"]["Surface"] = dif_Surface;
dif_Surface.__name__ = "dif.Surface";
Object.assign(dif_Surface.prototype, {
	__class__: dif_Surface
	,windingStart: null
	,windingCount: null
	,planeIndex: null
	,textureIndex: null
	,texGenIndex: null
	,surfaceFlags: null
	,fanMask: null
	,lightMapFinalWord: null
	,lightMapTexGenXD: null
	,lightMapTexGenYD: null
	,lightCount: null
	,lightStateInfoStart: null
	,mapOffsetX: null
	,mapOffsetY: null
	,mapSizeX: null
	,mapSizeY: null
	,brushId: null
});
class dif_TexGenEQ {
	constructor() {
		this.planeX = new dif_math_PlaneF();
		this.planeY = new dif_math_PlaneF();
	}
	write(io) {
		this.planeX.write(io);
		this.planeY.write(io);
	}
	static read(io) {
		let ret = new dif_TexGenEQ();
		ret.planeX = dif_math_PlaneF.read(io);
		ret.planeY = dif_math_PlaneF.read(io);
		return ret;
	}
}
$hxClasses["dif.TexGenEQ"] = $hx_exports["dif"]["TexGenEQ"] = dif_TexGenEQ;
dif_TexGenEQ.__name__ = "dif.TexGenEQ";
Object.assign(dif_TexGenEQ.prototype, {
	__class__: dif_TexGenEQ
	,planeX: null
	,planeY: null
});
class dif_TexMatrix {
	constructor() {
		this.t = 0;
		this.n = 0;
		this.b = 0;
	}
	write(io) {
		io.writeInt32(this.t);
		io.writeInt32(this.n);
		io.writeInt32(this.b);
	}
	static read(io) {
		let ret = new dif_TexMatrix();
		ret.t = io.readInt32();
		ret.n = io.readInt32();
		ret.b = io.readInt32();
		return ret;
	}
}
$hxClasses["dif.TexMatrix"] = $hx_exports["dif"]["TexMatrix"] = dif_TexMatrix;
dif_TexMatrix.__name__ = "dif.TexMatrix";
Object.assign(dif_TexMatrix.prototype, {
	__class__: dif_TexMatrix
	,t: null
	,n: null
	,b: null
});
class dif_Trigger {
	constructor() {
		this.name = "";
		this.datablock = "";
		this.offset = new dif_math_Point3F();
		this.properties = new haxe_ds_StringMap();
		this.polyhedron = new dif_Polyhedron();
	}
	write(io) {
		io.writeStr(this.name);
		io.writeStr(this.datablock);
		dif_WriterExtensions.writeDictionary(io,this.properties);
		this.polyhedron.write(io);
		this.offset.write(io);
	}
	static read(io) {
		let ret = new dif_Trigger();
		ret.name = io.readStr();
		ret.datablock = io.readStr();
		ret.properties = dif_ReaderExtensions.readDictionary(io);
		ret.polyhedron = dif_Polyhedron.read(io);
		ret.offset = dif_math_Point3F.read(io);
		return ret;
	}
}
$hxClasses["dif.Trigger"] = $hx_exports["dif"]["Trigger"] = dif_Trigger;
dif_Trigger.__name__ = "dif.Trigger";
Object.assign(dif_Trigger.prototype, {
	__class__: dif_Trigger
	,name: null
	,datablock: null
	,properties: null
	,polyhedron: null
	,offset: null
});
class dif_VehicleCollision {
	constructor() {
	}
	write(io,version) {
		io.writeInt32(this.vehicleCollisionFileVersion);
		dif_WriterExtensions.writeArray(io,this.convexHulls,function(io,p) {
			p.write(io,version);
		});
		dif_WriterExtensions.writeArray(io,this.convexHullEmitStrings,function(io,p) {
			io.writeByte(p);
		});
		dif_WriterExtensions.writeArray(io,this.hullIndices,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeArray(io,this.hullPlaneIndices,function(io,p) {
			io.writeInt16(p);
		});
		dif_WriterExtensions.writeArray(io,this.hullEmitStringIndices,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeArray(io,this.hullSurfaceIndices,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeArray(io,this.polyListPlanes,function(io,p) {
			io.writeInt16(p);
		});
		dif_WriterExtensions.writeArray(io,this.polyListPoints,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeArray(io,this.polyListStrings,function(io,p) {
			io.writeByte(p);
		});
		dif_WriterExtensions.writeArray(io,this.nullSurfaces,function(io,p) {
			p.write(io,new dif_Version());
		});
		dif_WriterExtensions.writeArray(io,this.points,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.planes,function(io,p) {
			p.write(io);
		});
		dif_WriterExtensions.writeArray(io,this.windings,function(io,p) {
			io.writeInt32(p);
		});
		dif_WriterExtensions.writeArray(io,this.windingIndices,function(io,p) {
			p.write(io);
		});
	}
	static read(io,version) {
		let ret = new dif_VehicleCollision();
		ret.vehicleCollisionFileVersion = io.readInt32();
		ret.convexHulls = dif_ReaderExtensions.readArray(io,function(io) {
			return dif_ConvexHull.read(io,version);
		});
		ret.convexHullEmitStrings = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readByte();
		});
		ret.hullIndices = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.hullPlaneIndices = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readInt16();
		});
		ret.hullEmitStringIndices = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.hullSurfaceIndices = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.polyListPlanes = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readInt16();
		});
		ret.polyListPoints = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.polyListStrings = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readByte();
		});
		ret.nullSurfaces = dif_ReaderExtensions.readArray(io,function(io) {
			return dif_NullSurface.read(io,new dif_Version());
		});
		ret.points = dif_ReaderExtensions.readArray(io,dif_math_Point3F.read);
		ret.planes = dif_ReaderExtensions.readArray(io,dif_Plane.read);
		ret.windings = dif_ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.windingIndices = dif_ReaderExtensions.readArray(io,dif_WindingIndex.read);
		return ret;
	}
}
$hxClasses["dif.VehicleCollision"] = $hx_exports["dif"]["VehicleCollision"] = dif_VehicleCollision;
dif_VehicleCollision.__name__ = "dif.VehicleCollision";
Object.assign(dif_VehicleCollision.prototype, {
	__class__: dif_VehicleCollision
	,vehicleCollisionFileVersion: null
	,convexHulls: null
	,convexHullEmitStrings: null
	,hullIndices: null
	,hullPlaneIndices: null
	,hullEmitStringIndices: null
	,hullSurfaceIndices: null
	,polyListPlanes: null
	,polyListPoints: null
	,polyListStrings: null
	,nullSurfaces: null
	,points: null
	,planes: null
	,windings: null
	,windingIndices: null
});
class dif_Version {
	constructor() {
		this.difVersion = 44;
		this.interiorVersion = 0;
		this.interiorType = "?";
	}
}
$hxClasses["dif.Version"] = $hx_exports["dif"]["Version"] = dif_Version;
dif_Version.__name__ = "dif.Version";
Object.assign(dif_Version.prototype, {
	__class__: dif_Version
	,difVersion: null
	,interiorVersion: null
	,interiorType: null
});
class dif_WayPoint {
	constructor(position,rotation,msToNext,smoothingType) {
		this.position = position;
		this.rotation = rotation;
		this.msToNext = msToNext;
		this.smoothingType = smoothingType;
	}
	write(io) {
		this.position.write(io);
		this.rotation.write(io);
		io.writeInt32(this.msToNext);
		io.writeInt32(this.smoothingType);
	}
	static read(io) {
		return new dif_WayPoint(dif_math_Point3F.read(io),dif_math_QuatF.read(io),io.readInt32(),io.readInt32());
	}
}
$hxClasses["dif.WayPoint"] = $hx_exports["dif"]["WayPoint"] = dif_WayPoint;
dif_WayPoint.__name__ = "dif.WayPoint";
Object.assign(dif_WayPoint.prototype, {
	__class__: dif_WayPoint
	,position: null
	,rotation: null
	,msToNext: null
	,smoothingType: null
});
class dif_WindingIndex {
	constructor(windingStart,windingCount) {
		this.windingStart = windingStart;
		this.windingCount = windingCount;
	}
	write(io) {
		io.writeInt32(this.windingStart);
		io.writeInt32(this.windingCount);
	}
	static read(io) {
		return new dif_WindingIndex(io.readInt32(),io.readInt32());
	}
}
$hxClasses["dif.WindingIndex"] = $hx_exports["dif"]["WindingIndex"] = dif_WindingIndex;
dif_WindingIndex.__name__ = "dif.WindingIndex";
Object.assign(dif_WindingIndex.prototype, {
	__class__: dif_WindingIndex
	,windingStart: null
	,windingCount: null
});
class dif_WriterExtensions {
	static writeDictionary(io,dict) {
		let h = dict.h;
		let _g_keys = Object.keys(h);
		let _g_length = _g_keys.length;
		let _g_current = 0;
		while(_g_current < _g_length) ++_g_current;
		let h1 = dict.h;
		let _g_keys1 = Object.keys(h1);
		let _g_length1 = _g_keys1.length;
		let _g_current1 = 0;
		while(_g_current1 < _g_length1) {
			let key = _g_keys1[_g_current1++];
			let kvp_value = h1[key];
			io.writeStr(key);
			io.writeStr(kvp_value);
		}
	}
	static writeArray(io,arr,writeMethod) {
		io.writeInt32(arr.length);
		let _g = 0;
		let _g1 = arr.length;
		while(_g < _g1) {
			let i = _g++;
			writeMethod(io,arr[i]);
		}
		return arr;
	}
	static writeArrayFlags(io,arr,flags,writeMethod) {
		io.writeInt32(arr.length);
		io.writeInt32(flags);
		let _g = 0;
		let _g1 = arr.length;
		while(_g < _g1) {
			let i = _g++;
			writeMethod(io,arr[i]);
		}
	}
	static writePNG(io,arr) {
		let _g = 0;
		let _g1 = arr.length;
		while(_g < _g1) {
			let i = _g++;
			io.writeByte(arr[i]);
		}
	}
	static writeColorF(io,color) {
		io.writeByte(color[0]);
		io.writeByte(color[1]);
		io.writeByte(color[2]);
		io.writeByte(color[3]);
	}
}
$hxClasses["dif.WriterExtensions"] = dif_WriterExtensions;
dif_WriterExtensions.__name__ = "dif.WriterExtensions";
class dif_Zone {
	constructor() {
		this.portalStart = 0;
		this.portalCount = 0;
		this.surfaceStart = 0;
		this.surfaceCount = 0;
		this.staticMeshStart = 0;
		this.staticMeshCount = 0;
	}
	write(io,version) {
		io.writeInt16(this.portalStart);
		io.writeInt16(this.portalCount);
		io.writeInt32(this.surfaceStart);
		io.writeInt32(this.surfaceCount);
		if(version.interiorVersion >= 12) {
			io.writeInt32(this.staticMeshStart);
			io.writeInt32(this.staticMeshCount);
		}
	}
	static read(io,version) {
		let ret = new dif_Zone();
		ret.portalStart = io.readUInt16();
		ret.portalCount = io.readUInt16();
		ret.surfaceStart = io.readInt32();
		ret.surfaceCount = io.readInt32();
		if(version.interiorVersion >= 12) {
			ret.staticMeshStart = io.readInt32();
			ret.staticMeshCount = io.readInt32();
		}
		return ret;
	}
}
$hxClasses["dif.Zone"] = $hx_exports["dif"]["Zone"] = dif_Zone;
dif_Zone.__name__ = "dif.Zone";
Object.assign(dif_Zone.prototype, {
	__class__: dif_Zone
	,portalStart: null
	,portalCount: null
	,surfaceStart: null
	,surfaceCount: null
	,staticMeshStart: null
	,staticMeshCount: null
});
class dif_io_BytesReader {
	constructor(bytes) {
		this.bytes = bytes;
		this.position = 0;
	}
	readInt32() {
		let b = this.bytes.getInt32(this.position);
		this.position += 4;
		return b;
	}
	readInt16() {
		let b = this.bytes.getUInt16(this.position);
		this.position += 2;
		return b;
	}
	readUInt16() {
		let b = this.bytes.getUInt16(this.position);
		this.position += 2;
		return b;
	}
	readByte() {
		let b = this.bytes.b[this.position];
		this.position += 1;
		return b;
	}
	readStr() {
		let len = this.readByte();
		let str = "";
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			_g++;
			let code = this.readByte();
			str += String.fromCodePoint(code);
		}
		return str;
	}
	readFloat() {
		let b = this.bytes.getFloat(this.position);
		this.position += 4;
		return b;
	}
	tell() {
		return this.position;
	}
	seek(pos) {
		this.position = pos;
	}
}
$hxClasses["dif.io.BytesReader"] = dif_io_BytesReader;
dif_io_BytesReader.__name__ = "dif.io.BytesReader";
Object.assign(dif_io_BytesReader.prototype, {
	__class__: dif_io_BytesReader
	,bytes: null
	,position: null
});
class dif_io_BytesWriter {
	constructor() {
		this.bytes = new haxe_io_BytesBuffer();
	}
	writeInt32(int) {
		this.bytes.addInt32(int);
	}
	writeUInt16(int) {
		let h = int >> 8;
		let l = int & 255;
		this.bytes.addByte(l);
		this.bytes.addByte(h);
	}
	writeInt16(int) {
		let h = int >> 8;
		let l = int & 255;
		this.bytes.addByte(l);
		this.bytes.addByte(h);
	}
	writeByte(int) {
		this.bytes.addByte(int);
	}
	writeStr(str) {
		this.bytes.addByte(str.length);
		let _g = 0;
		let _g1 = str.length;
		while(_g < _g1) {
			let c = _g++;
			this.bytes.addByte(HxOverrides.cca(str,c));
		}
	}
	writeFloat(f) {
		this.bytes.addFloat(f);
	}
	getBuffer() {
		return this.bytes.getBytes();
	}
}
$hxClasses["dif.io.BytesWriter"] = dif_io_BytesWriter;
dif_io_BytesWriter.__name__ = "dif.io.BytesWriter";
Object.assign(dif_io_BytesWriter.prototype, {
	__class__: dif_io_BytesWriter
	,bytes: null
});
class dif_math_Box3F {
	constructor(minX,minY,minZ,maxX,maxY,maxZ) {
		if(maxZ == null) {
			maxZ = 0.0;
		}
		if(maxY == null) {
			maxY = 0.0;
		}
		if(maxX == null) {
			maxX = 0.0;
		}
		if(minZ == null) {
			minZ = 0.0;
		}
		if(minY == null) {
			minY = 0.0;
		}
		if(minX == null) {
			minX = 0.0;
		}
		this.minX = minX;
		this.minY = minY;
		this.minZ = minZ;
		this.maxX = maxX;
		this.maxY = maxY;
		this.maxZ = maxZ;
	}
	center() {
		return new dif_math_Point3F(this.minX + this.maxX,this.minY + this.maxY,this.minZ + this.maxZ).scalarDiv(2);
	}
	Expand(point) {
		if(this.minX > point.x) {
			this.minX = point.x;
		}
		if(this.minY > point.y) {
			this.minY = point.y;
		}
		if(this.minZ > point.z) {
			this.minZ = point.z;
		}
		if(this.maxX < point.x) {
			this.maxX = point.x;
		}
		if(this.maxY < point.y) {
			this.maxY = point.y;
		}
		if(this.maxZ < point.z) {
			this.maxZ = point.z;
		}
	}
	contains(p) {
		if(this.minX <= p.x && p.x <= this.maxX && this.minY <= p.y && p.y <= this.maxY && this.minZ <= p.z) {
			return p.z <= this.maxZ;
		} else {
			return false;
		}
	}
	getClosestPoint(point) {
		let closest = new dif_math_Point3F();
		if(this.minX > point.x) {
			closest.x = this.minX;
		} else if(this.maxX < point.x) {
			closest.x = this.maxX;
		} else {
			closest.x = point.x;
		}
		if(this.minY > point.y) {
			closest.y = this.minY;
		} else if(this.maxY < point.y) {
			closest.y = this.maxY;
		} else {
			closest.y = point.y;
		}
		if(this.minZ > point.z) {
			closest.z = this.minZ;
		} else if(this.maxZ < point.z) {
			closest.z = this.maxZ;
		} else {
			closest.z = point.z;
		}
		return closest;
	}
	write(io) {
		io.writeFloat(this.minX);
		io.writeFloat(this.minY);
		io.writeFloat(this.minZ);
		io.writeFloat(this.maxX);
		io.writeFloat(this.maxY);
		io.writeFloat(this.maxZ);
	}
	static PointBounds(point,size) {
		let ret = new dif_math_Box3F();
		ret.minX = point.x;
		ret.minY = point.y;
		ret.minZ = point.z;
		ret.maxX = point.x + size.x;
		ret.maxY = point.y + size.y;
		ret.maxZ = point.z + size.z;
		return ret;
	}
	static read(io) {
		let ret = new dif_math_Box3F();
		ret.minX = io.readFloat();
		ret.minY = io.readFloat();
		ret.minZ = io.readFloat();
		ret.maxX = io.readFloat();
		ret.maxY = io.readFloat();
		ret.maxZ = io.readFloat();
		return ret;
	}
}
$hxClasses["dif.math.Box3F"] = $hx_exports["dif"]["math"]["Box3F"] = dif_math_Box3F;
dif_math_Box3F.__name__ = "dif.math.Box3F";
Object.assign(dif_math_Box3F.prototype, {
	__class__: dif_math_Box3F
	,minX: null
	,minY: null
	,minZ: null
	,maxX: null
	,maxY: null
	,maxZ: null
});
class dif_math_PlaneF {
	constructor(x,y,z,d) {
		if(d == null) {
			d = 0.0;
		}
		if(z == null) {
			z = 0.0;
		}
		if(y == null) {
			y = 0.0;
		}
		if(x == null) {
			x = 0.0;
		}
		this.x = x;
		this.y = y;
		this.z = z;
		this.d = d;
	}
	distance(p) {
		return this.x * p.x + this.y * p.y + this.z * p.z + this.d;
	}
	project(p) {
		let d = this.distance(p);
		return new dif_math_Point3F(p.x - d * this.x,p.y - d * this.y,p.z - d * this.z);
	}
	getNormal() {
		return new dif_math_Point3F(this.x,this.y,this.z);
	}
	write(io) {
		io.writeFloat(this.x);
		io.writeFloat(this.y);
		io.writeFloat(this.z);
		io.writeFloat(this.d);
	}
	static ThreePoints(a,b,c) {
		let v1 = a.sub(b);
		let v2 = c.sub(b);
		let res = v1.cross(v2);
		let ret = new dif_math_PlaneF();
		let normal = res.normalized();
		ret.x = normal.x;
		ret.y = normal.y;
		ret.z = normal.z;
		ret.d = -b.dot(normal);
		return ret;
	}
	static NormalD(normal,d) {
		let ret = new dif_math_PlaneF();
		ret.x = normal.x;
		ret.y = normal.y;
		ret.z = normal.z;
		ret.d = d;
		return ret;
	}
	static PointNormal(pt,n) {
		let ret = new dif_math_PlaneF();
		let normal = n.normalized();
		ret.x = normal.x;
		ret.y = normal.y;
		ret.z = normal.z;
		ret.d = -pt.dot(normal);
		return ret;
	}
	static read(io) {
		let ret = new dif_math_PlaneF();
		ret.x = io.readFloat();
		ret.y = io.readFloat();
		ret.z = io.readFloat();
		ret.d = io.readFloat();
		return ret;
	}
}
$hxClasses["dif.math.PlaneF"] = $hx_exports["dif"]["math"]["PlaneF"] = dif_math_PlaneF;
dif_math_PlaneF.__name__ = "dif.math.PlaneF";
Object.assign(dif_math_PlaneF.prototype, {
	__class__: dif_math_PlaneF
	,x: null
	,y: null
	,z: null
	,d: null
});
class dif_math_Point2F {
	constructor(x,y) {
		this.x = x;
		this.y = y;
	}
}
$hxClasses["dif.math.Point2F"] = $hx_exports["dif"]["math"]["Point2F"] = dif_math_Point2F;
dif_math_Point2F.__name__ = "dif.math.Point2F";
Object.assign(dif_math_Point2F.prototype, {
	__class__: dif_math_Point2F
	,x: null
	,y: null
});
class dif_math_Point3F {
	constructor(x,y,z) {
		if(z == null) {
			z = 0.0;
		}
		if(y == null) {
			y = 0.0;
		}
		if(x == null) {
			x = 0.0;
		}
		this.x = x;
		this.y = y;
		this.z = z;
	}
	get(dim) {
		if(dim == 0) {
			return this.x;
		}
		if(dim == 1) {
			return this.y;
		}
		if(dim == 2) {
			return this.z;
		}
		return -1;
	}
	set(dim,value) {
		if(dim == 0) {
			this.x = value;
		}
		if(dim == 1) {
			this.y = value;
		}
		if(dim == 2) {
			this.z = value;
		}
	}
	add(rhs) {
		return new dif_math_Point3F(this.x + rhs.x,this.y + rhs.y,this.z + rhs.z);
	}
	sub(rhs) {
		return new dif_math_Point3F(this.x - rhs.x,this.y - rhs.y,this.z - rhs.z);
	}
	scalar(rhs) {
		return new dif_math_Point3F(this.x * rhs,this.y * rhs,this.z * rhs);
	}
	scalarDiv(rhs) {
		return new dif_math_Point3F(this.x / rhs,this.y / rhs,this.z / rhs);
	}
	dot(rhs) {
		return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
	}
	cross(rhs) {
		return new dif_math_Point3F(this.y * rhs.z - this.z * rhs.y,this.z * rhs.x - this.x * rhs.z,this.x * rhs.y - this.y * rhs.x);
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}
	normalized() {
		if(this.length() != 0) {
			return this.scalarDiv(this.length());
		} else {
			return this;
		}
	}
	equal(other) {
		if(this.x == other.x && this.y == other.y) {
			return this.z == other.z;
		} else {
			return false;
		}
	}
	write(io) {
		io.writeFloat(this.x);
		io.writeFloat(this.y);
		io.writeFloat(this.z);
	}
	copy() {
		return new dif_math_Point3F(this.x,this.y,this.z);
	}
	static read(io) {
		let ret = new dif_math_Point3F();
		ret.x = io.readFloat();
		ret.y = io.readFloat();
		ret.z = io.readFloat();
		return ret;
	}
}
$hxClasses["dif.math.Point3F"] = $hx_exports["dif"]["math"]["Point3F"] = dif_math_Point3F;
dif_math_Point3F.__name__ = "dif.math.Point3F";
Object.assign(dif_math_Point3F.prototype, {
	__class__: dif_math_Point3F
	,x: null
	,y: null
	,z: null
});
class dif_math_Point4F {
	constructor() {
		this.x = 0;
		this.y = 0;
		this.z = 0;
		this.w = 0;
	}
	write(io) {
		io.writeFloat(this.x);
		io.writeFloat(this.y);
		io.writeFloat(this.z);
		io.writeFloat(this.w);
	}
	static read(io) {
		let ret = new dif_math_Point4F();
		ret.x = io.readFloat();
		ret.y = io.readFloat();
		ret.z = io.readFloat();
		ret.w = io.readFloat();
		return ret;
	}
}
$hxClasses["dif.math.Point4F"] = $hx_exports["dif"]["math"]["Point4F"] = dif_math_Point4F;
dif_math_Point4F.__name__ = "dif.math.Point4F";
Object.assign(dif_math_Point4F.prototype, {
	__class__: dif_math_Point4F
	,x: null
	,y: null
	,z: null
	,w: null
});
class dif_math_QuatF {
	constructor() {
		this.x = 0;
		this.y = 0;
		this.z = 0;
		this.w = 0;
	}
	write(io) {
		io.writeFloat(this.x);
		io.writeFloat(this.y);
		io.writeFloat(this.z);
		io.writeFloat(this.w);
	}
	static read(io) {
		let ret = new dif_math_QuatF();
		ret.x = io.readFloat();
		ret.y = io.readFloat();
		ret.z = io.readFloat();
		ret.w = io.readFloat();
		return ret;
	}
}
$hxClasses["dif.math.QuatF"] = $hx_exports["dif"]["math"]["QuatF"] = dif_math_QuatF;
dif_math_QuatF.__name__ = "dif.math.QuatF";
Object.assign(dif_math_QuatF.prototype, {
	__class__: dif_math_QuatF
	,x: null
	,y: null
	,z: null
	,w: null
});
class dif_math_Spheref {
	constructor() {
		this.originX = 0;
		this.originY = 0;
		this.originZ = 0;
		this.radius = 0;
	}
	write(io) {
		io.writeFloat(this.originX);
		io.writeFloat(this.originY);
		io.writeFloat(this.originZ);
		io.writeFloat(this.radius);
	}
	static read(io) {
		let ret = new dif_math_Spheref();
		ret.originX = io.readFloat();
		ret.originY = io.readFloat();
		ret.originZ = io.readFloat();
		ret.radius = io.readFloat();
		return ret;
	}
}
$hxClasses["dif.math.Spheref"] = $hx_exports["dif"]["math"]["Spheref"] = dif_math_Spheref;
dif_math_Spheref.__name__ = "dif.math.Spheref";
Object.assign(dif_math_Spheref.prototype, {
	__class__: dif_math_Spheref
	,originX: null
	,originY: null
	,originZ: null
	,radius: null
});
class dts_Detail {
	constructor() {
	}
	static read(reader) {
		let d = new dts_Detail();
		d.name = reader.readU32();
		d.subShape = reader.readU32();
		d.objectDetail = reader.readU32();
		d.size = reader.readF32();
		d.avgError = reader.readF32();
		d.maxError = reader.readF32();
		d.polyCount = reader.readU32();
		return d;
	}
}
$hxClasses["dts.Detail"] = dts_Detail;
dts_Detail.__name__ = "dts.Detail";
Object.assign(dts_Detail.prototype, {
	__class__: dts_Detail
	,name: null
	,subShape: null
	,objectDetail: null
	,size: null
	,avgError: null
	,maxError: null
	,polyCount: null
});
class dts_DtsAlloc {
	constructor(buf,start32,start16,start8) {
		this.lastGuardValue = 0;
		this.buf = buf;
		this.index32 = start32;
		this.index16 = start32 + start16 * 4;
		this.index8 = start32 + start8 * 4;
	}
	readU32() {
		this.buf.seek(this.index32);
		let val = this.buf.readInt32();
		this.index32 += 4;
		return val;
	}
	readS32() {
		this.buf.seek(this.index32);
		let val = this.buf.readInt32();
		this.index32 += 4;
		return val;
	}
	readF32() {
		this.buf.seek(this.index32);
		let val = this.buf.readFloat();
		this.index32 += 4;
		return val;
	}
	readPoint2F() {
		return new dif_math_Point2F(this.readF32(),this.readF32());
	}
	readPoint3F() {
		let x = this.readF32();
		let y = this.readF32();
		let z = this.readF32();
		return new dif_math_Point3F(x,y,z);
	}
	readBoxF() {
		return new dif_math_Box3F(this.readF32(),this.readF32(),this.readF32(),this.readF32(),this.readF32(),this.readF32());
	}
	readU16() {
		this.buf.seek(this.index16);
		let val = this.buf.readInt16();
		this.index16 += 2;
		return val;
	}
	readS16() {
		this.buf.seek(this.index16);
		let val = this.buf.readInt16();
		if(val > 32767) {
			val -= 65536;
		}
		this.index16 += 2;
		return val;
	}
	readU8() {
		this.buf.seek(this.index8);
		let val = this.buf.readByte();
		this.index8 += 1;
		return val;
	}
	readQuat16() {
		let quat = new dif_math_QuatF();
		quat.x = this.readS16();
		quat.y = this.readS16();
		quat.z = this.readS16();
		quat.w = this.readS16();
		return quat;
	}
	readMatrixF() {
		let mat = new h3d_Matrix();
		mat._11 = this.readF32();
		mat._12 = this.readF32();
		mat._13 = this.readF32();
		mat._14 = this.readF32();
		mat._21 = this.readF32();
		mat._22 = this.readF32();
		mat._23 = this.readF32();
		mat._24 = this.readF32();
		mat._31 = this.readF32();
		mat._32 = this.readF32();
		mat._33 = this.readF32();
		mat._34 = this.readF32();
		mat._41 = this.readF32();
		mat._42 = this.readF32();
		mat._43 = this.readF32();
		mat._44 = this.readF32();
		return mat;
	}
	guard() {
		let guard32 = this.readU32();
		let guard16 = this.readU16();
		let guard8 = this.readU8();
		if(!(guard32 == guard16 && guard16 == guard8 && guard8 == this.lastGuardValue)) {
			throw new haxe_Exception("Guard fail! Expected " + this.lastGuardValue + " but got " + guard32 + " for 32, " + guard16 + " for 16 and " + guard8 + " for 8.");
		}
		this.lastGuardValue++;
	}
}
$hxClasses["dts.DtsAlloc"] = dts_DtsAlloc;
dts_DtsAlloc.__name__ = "dts.DtsAlloc";
Object.assign(dts_DtsAlloc.prototype, {
	__class__: dts_DtsAlloc
	,buf: null
	,index32: null
	,index16: null
	,index8: null
	,lastGuardValue: null
});
class dts_DtsFile {
	constructor() {
	}
	read(filepath) {
		let f = src_ResourceLoader.getFileEntry(filepath).entry;
		let bytes = f.getBytes();
		let br = new dif_io_BytesReader(bytes);
		this.fileVersion = br.readInt16();
		this.exporterVersion = br.readInt16();
		this.fileVersion &= 255;
		let memBuffer;
		let start32;
		let start16;
		let start8;
		if(this.fileVersion > 24) {
			throw new haxe_Exception("Invalid DTS version");
		}
		if(this.fileVersion < 19) {
			let result = this.readOldShape(this.fileVersion,br);
			memBuffer = new dif_io_BytesReader(result.bufferInfo.buffer);
			start32 = 0;
			start16 = result.bufferInfo.start16;
			start8 = result.bufferInfo.start8;
			this.sequences = result.sequences;
		} else {
			let sizeMemBuffer = br.readInt32();
			memBuffer = br;
			start16 = br.readInt32();
			start8 = br.readInt32();
			start32 = br.tell();
			br.seek(br.tell() + sizeMemBuffer * 4);
			let numSequences = br.readInt32();
			this.sequences = [];
			let _g = 0;
			while(_g < numSequences) {
				++_g;
				let seq = new dts_Sequence();
				seq.read(br,this.fileVersion,true);
				this.sequences.push(seq);
			}
			this.parseMaterialList(br,this.fileVersion);
		}
		let alloc = new dts_DtsAlloc(memBuffer,start32,start16,start8);
		this.assembleShape(alloc);
	}
	readOldShape(version,br) {
		let oldAlloc = new dts_DtsOldAlloc(br,br.tell());
		oldAlloc.allocate32(15);
		oldAlloc.guard();
		oldAlloc.copyInto32(1);
		oldAlloc.copyInto32(1);
		oldAlloc.copyInto32(3);
		oldAlloc.copyInto32(6);
		oldAlloc.guard();
		let numNodes = oldAlloc.readS32(0);
		let _g = 0;
		while(_g < numNodes) {
			++_g;
			oldAlloc.copyInto32(2);
			oldAlloc.allocate32(3);
		}
		oldAlloc.guard();
		let numObjects = oldAlloc.readS32(1);
		let _g1 = 0;
		while(_g1 < numObjects) {
			++_g1;
			oldAlloc.copyInto32(4);
			oldAlloc.allocate32(2);
		}
		oldAlloc.guard();
		let numDecals = oldAlloc.readS32(2);
		let _g2 = 0;
		while(_g2 < numDecals) {
			++_g2;
			oldAlloc.copyInto32(4);
			oldAlloc.allocate32(1);
		}
		oldAlloc.guard();
		let numIflMaterials = oldAlloc.readS32(4);
		let _g3 = 0;
		while(_g3 < numIflMaterials) {
			++_g3;
			oldAlloc.copyInto32(2);
			oldAlloc.allocate32(3);
		}
		oldAlloc.guard();
		let numSubShapes = oldAlloc.readS32(3);
		let subShapeFirstStart = oldAlloc.index32;
		oldAlloc.copyInto32(numSubShapes);
		oldAlloc.skip(4);
		oldAlloc.copyInto32(numSubShapes);
		oldAlloc.skip(4);
		oldAlloc.copyInto32(numSubShapes);
		oldAlloc.guard();
		let subShapeNumStart = oldAlloc.index32;
		oldAlloc.allocate32(3 * numSubShapes);
		oldAlloc.guard();
		let prev;
		let first;
		prev = numNodes;
		let j = numSubShapes - 1;
		while(j >= 0) {
			first = oldAlloc.buffer32.getInt32(subShapeFirstStart + j * 4);
			oldAlloc.buffer32.setInt32(subShapeNumStart + j * 4,prev - first);
			prev = first;
			--j;
		}
		subShapeFirstStart += numSubShapes;
		subShapeNumStart += numSubShapes;
		prev = numObjects;
		let j1 = numSubShapes - 1;
		while(j1 >= 0) {
			first = oldAlloc.buffer32.getInt32(subShapeFirstStart + j1 * 4);
			oldAlloc.buffer32.setInt32(subShapeNumStart + j1 * 4,prev - first);
			prev = first;
			--j1;
		}
		subShapeFirstStart += numSubShapes;
		subShapeNumStart += numSubShapes;
		prev = numDecals;
		let j2 = numSubShapes - 1;
		while(j2 >= 0) {
			first = oldAlloc.buffer32.getInt32(subShapeFirstStart + j2 * 4);
			oldAlloc.buffer32.setInt32(subShapeNumStart + j2 * 4,prev - first);
			prev = first;
			--j2;
		}
		let numNodeStates = oldAlloc.readS32(5);
		let _g4 = 0;
		while(_g4 < numNodeStates) {
			++_g4;
			oldAlloc.copyInto16(4);
			oldAlloc.copyInto32(3);
		}
		oldAlloc.guard();
		let numObjectStates = oldAlloc.readS32(6);
		oldAlloc.copyInto32(numObjectStates * 3);
		oldAlloc.guard();
		let numDecalStates = oldAlloc.readS32(7);
		oldAlloc.copyInto32(numDecalStates);
		oldAlloc.guard();
		let numTriggers = oldAlloc.readS32(8);
		oldAlloc.copyInto32(numTriggers * 2);
		oldAlloc.guard();
		let numDetails = oldAlloc.readS32(9);
		let _g5 = 0;
		while(_g5 < numDetails) {
			++_g5;
			oldAlloc.copyInto32(4);
			oldAlloc.allocate32(3);
		}
		oldAlloc.guard();
		br.seek(oldAlloc.sourceIndex);
		let numSequences = br.readInt32();
		let sequences = [];
		let _g6 = 0;
		while(_g6 < numSequences) {
			++_g6;
			let sequence = new dts_Sequence();
			sequence.read(br,version,true);
			sequences.push(sequence);
		}
		oldAlloc.sourceIndex = br.tell();
		let numMeshes = oldAlloc.readS32(10);
		let _g7 = 0;
		while(_g7 < numMeshes) {
			++_g7;
			let meshType = oldAlloc.readS32(-1);
			this.readAllocMesh(oldAlloc,meshType);
		}
		oldAlloc.guard();
		let numNames = oldAlloc.readS32(12);
		let _g8 = 0;
		while(_g8 < numNames) {
			++_g8;
			let length = oldAlloc.readS32(null);
			oldAlloc.copyInto8(length);
			oldAlloc.writeU8(0);
		}
		oldAlloc.guard();
		br.seek(oldAlloc.sourceIndex);
		let gotList = br.readInt32();
		if(gotList > 0) {
			this.parseMaterialList(br,version);
		}
		oldAlloc.sourceIndex = br.tell();
		oldAlloc.allocate32(16);
		return { bufferInfo : oldAlloc.createBuffer(), sequences : sequences};
	}
	readAllocMesh(oldAlloc,meshType) {
		if(meshType == 4) {
			return;
		}
		oldAlloc.guard();
		oldAlloc.copyInto32(2);
		oldAlloc.writeS32(-1);
		oldAlloc.allocate32(10);
		let numVerts = oldAlloc.readS32(-1);
		oldAlloc.copyInto32(numVerts * 3);
		let numTverts = oldAlloc.readS32(-1);
		oldAlloc.copyInto32(numTverts * 2);
		let numNormals = oldAlloc.readS32(null);
		oldAlloc.copyInto32(numNormals * 3);
		let numPrimitives = oldAlloc.readS32(-1);
		let _g = 0;
		while(_g < numPrimitives) {
			++_g;
			oldAlloc.copyInto16(2);
			oldAlloc.copyInto32(1);
		}
		let numIndices = oldAlloc.readS32(-1);
		oldAlloc.copyInto16(numIndices);
		oldAlloc.writeS32(0);
		oldAlloc.copyInto32(2);
		oldAlloc.guard();
		if(meshType == 1) {
			let numInitialVerts = oldAlloc.readS32(-1);
			oldAlloc.copyInto32(numInitialVerts * 3);
			let numInitialNorms = oldAlloc.readS32(null);
			oldAlloc.copyInto32(numInitialNorms * 3);
			let numInitialTransforms = oldAlloc.readS32(-1);
			oldAlloc.copyInto32(numInitialTransforms * 16);
			let numVertIndices = oldAlloc.readS32(-1);
			oldAlloc.copyInto32(numVertIndices);
			let numBoneIndices = oldAlloc.readS32(null);
			oldAlloc.copyInto32(numBoneIndices);
			let weightStart = oldAlloc.index32;
			oldAlloc.allocate32(numBoneIndices);
			let numNodeIndices = oldAlloc.readS32(-1);
			oldAlloc.copyInto32(numNodeIndices);
			let returnToIndex = oldAlloc.index32;
			let numWeights = oldAlloc.readS32(null);
			oldAlloc.index32 = weightStart;
			oldAlloc.copyInto32(numWeights);
			oldAlloc.index32 = returnToIndex;
			oldAlloc.guard();
		}
	}
	assembleShape(ar) {
		let numNodes = ar.readS32();
		let numObjects = ar.readS32();
		ar.readS32();
		let numSubShapes = ar.readS32();
		let numIflMaterials = ar.readS32();
		let numNodeRots;
		let numNodeTrans;
		let numNodeUniformScales;
		let numNodeAlignedScales;
		let numNodeArbitraryScales;
		if(this.fileVersion < 22) {
			numNodeTrans = ar.readS32() - numNodes;
			numNodeRots = numNodeTrans;
			numNodeArbitraryScales = 0;
			numNodeAlignedScales = numNodeArbitraryScales;
			numNodeUniformScales = numNodeAlignedScales;
		} else {
			numNodeRots = ar.readS32();
			numNodeTrans = ar.readS32();
			numNodeUniformScales = ar.readS32();
			numNodeAlignedScales = ar.readS32();
			numNodeArbitraryScales = ar.readS32();
		}
		let numGroundFrames = 0;
		if(this.fileVersion > 23) {
			numGroundFrames = ar.readS32();
		}
		let numObjectStates = ar.readS32();
		let numDecalStates = ar.readS32();
		let numTriggers = ar.readS32();
		let numDetails = ar.readS32();
		let numMeshes = ar.readS32();
		let numSkins = 0;
		if(this.fileVersion < 23) {
			numSkins = ar.readS32();
		}
		let numNames = ar.readS32();
		this.smallestVisibleSize = ar.readF32();
		this.smallestVisibleDL = ar.readS32();
		ar.guard();
		this.radius = ar.readF32();
		this.radiusTube = ar.readF32();
		this.center = ar.readPoint3F();
		this.bounds = ar.readBoxF();
		ar.guard();
		this.nodes = [];
		let _g = 0;
		let _g1 = numNodes;
		while(_g < _g1) {
			_g++;
			this.nodes.push(dts_Node.read(ar));
		}
		ar.guard();
		this.objects = [];
		let _g2 = 0;
		let _g3 = numObjects;
		while(_g2 < _g3) {
			_g2++;
			this.objects.push(dts_Object.read(ar));
		}
		ar.guard();
		ar.guard();
		this.mats = [];
		let _g4 = 0;
		let _g5 = numIflMaterials;
		while(_g4 < _g5) {
			_g4++;
			this.mats.push(dts_IflMaterial.read(ar));
		}
		ar.guard();
		this.subshapes = [];
		let _g6 = 0;
		let _g7 = numSubShapes;
		while(_g6 < _g7) {
			_g6++;
			this.subshapes.push(new dts_SubShape(0,0,0,0,0,0));
		}
		let _g8 = 0;
		let _g9 = numSubShapes;
		while(_g8 < _g9) {
			let i = _g8++;
			this.subshapes[i].firstNode = ar.readS32();
		}
		let _g10 = 0;
		let _g11 = numSubShapes;
		while(_g10 < _g11) {
			let i = _g10++;
			this.subshapes[i].firstObject = ar.readS32();
		}
		let _g12 = 0;
		let _g13 = numSubShapes;
		while(_g12 < _g13) {
			let i = _g12++;
			this.subshapes[i].firstDecal = ar.readS32();
		}
		ar.guard();
		let _g14 = 0;
		let _g15 = numSubShapes;
		while(_g14 < _g15) {
			let i = _g14++;
			this.subshapes[i].numNodes = ar.readS32();
		}
		let _g16 = 0;
		let _g17 = numSubShapes;
		while(_g16 < _g17) {
			let i = _g16++;
			this.subshapes[i].numObjects = ar.readS32();
		}
		let _g18 = 0;
		let _g19 = numSubShapes;
		while(_g18 < _g19) {
			let i = _g18++;
			this.subshapes[i].numDecals = ar.readS32();
		}
		ar.guard();
		if(this.fileVersion < 16) {
			let num = ar.readS32();
			let _g = 0;
			let _g1 = num;
			while(_g < _g1) {
				_g++;
				ar.readS32();
			}
		}
		this.defaultRotations = [];
		this.defaultTranslations = [];
		let _g20 = 0;
		let _g21 = numNodes;
		while(_g20 < _g21) {
			_g20++;
			this.defaultRotations.push(ar.readQuat16());
			this.defaultTranslations.push(ar.readPoint3F());
		}
		this.nodeTranslations = [];
		let _g22 = 0;
		let _g23 = numNodeTrans;
		while(_g22 < _g23) {
			_g22++;
			this.nodeTranslations.push(ar.readPoint3F());
		}
		this.nodeRotations = [];
		let _g24 = 0;
		let _g25 = numNodeRots;
		while(_g24 < _g25) {
			_g24++;
			this.nodeRotations.push(ar.readQuat16());
		}
		ar.guard();
		this.nodeUniformScales = [];
		this.nodeAlignedScales = [];
		this.nodeArbitraryScaleFactors = [];
		this.nodeArbitraryScaleRots = [];
		if(this.fileVersion > 21) {
			let _g = 0;
			let _g1 = numNodeUniformScales;
			while(_g < _g1) {
				_g++;
				this.nodeUniformScales.push(ar.readF32());
			}
			let _g2 = 0;
			let _g3 = numNodeAlignedScales;
			while(_g2 < _g3) {
				_g2++;
				this.nodeAlignedScales.push(ar.readPoint3F());
			}
			let _g4 = 0;
			let _g5 = numNodeArbitraryScales;
			while(_g4 < _g5) {
				_g4++;
				this.nodeArbitraryScaleFactors.push(ar.readPoint3F());
			}
			let _g6 = 0;
			let _g7 = numNodeArbitraryScales;
			while(_g6 < _g7) {
				_g6++;
				this.nodeArbitraryScaleRots.push(ar.readQuat16());
			}
			ar.guard();
		} else {
			let _g = 0;
			let _g1 = numNodeUniformScales;
			while(_g < _g1) {
				_g++;
				this.nodeUniformScales.push(1);
			}
			let _g2 = 0;
			let _g3 = numNodeAlignedScales;
			while(_g2 < _g3) {
				_g2++;
				this.nodeAlignedScales.push(new dif_math_Point3F(1,1,1));
			}
			let _g4 = 0;
			let _g5 = numNodeArbitraryScales;
			while(_g4 < _g5) {
				_g4++;
				this.nodeArbitraryScaleFactors.push(new dif_math_Point3F(1,1,1));
			}
			let _g6 = 0;
			let _g7 = numNodeArbitraryScales;
			while(_g6 < _g7) {
				_g6++;
				this.nodeArbitraryScaleRots.push(new dif_math_QuatF());
			}
		}
		this.groundTranslations = [];
		this.groundRots = [];
		if(this.fileVersion > 23) {
			let _g = 0;
			let _g1 = numGroundFrames;
			while(_g < _g1) {
				_g++;
				this.groundTranslations.push(ar.readPoint3F());
			}
			let _g2 = 0;
			let _g3 = numGroundFrames;
			while(_g2 < _g3) {
				_g2++;
				this.groundRots.push(ar.readQuat16());
			}
			ar.guard();
		} else {
			let _g = 0;
			let _g1 = numGroundFrames;
			while(_g < _g1) {
				_g++;
				this.groundTranslations.push(new dif_math_Point3F(1,1,1));
			}
			let _g2 = 0;
			let _g3 = numGroundFrames;
			while(_g2 < _g3) {
				_g2++;
				this.groundRots.push(new dif_math_QuatF());
			}
		}
		this.objectStates = [];
		let _g26 = 0;
		let _g27 = numObjectStates;
		while(_g26 < _g27) {
			_g26++;
			this.objectStates.push(dts_ObjectState.read(ar));
		}
		ar.guard();
		this.decalStates = [];
		let _g28 = 0;
		let _g29 = numDecalStates;
		while(_g28 < _g29) {
			_g28++;
			this.decalStates.push(ar.readS32());
		}
		ar.guard();
		this.triggers = [];
		let _g30 = 0;
		let _g31 = numTriggers;
		while(_g30 < _g31) {
			_g30++;
			this.triggers.push(dts_Trigger.read(ar));
		}
		ar.guard();
		this.detailLevels = [];
		let _g32 = 0;
		let _g33 = numDetails;
		while(_g32 < _g33) {
			_g32++;
			this.detailLevels.push(dts_Detail.read(ar));
		}
		ar.guard();
		this.meshes = [];
		let _g34 = 0;
		let _g35 = numMeshes;
		while(_g34 < _g35) {
			_g34++;
			this.meshes.push(dts_Mesh.read(this,ar,this.fileVersion));
		}
		ar.guard();
		this.names = [];
		let _g36 = 0;
		let _g37 = numNames;
		while(_g36 < _g37) {
			_g36++;
			let str = "";
			while(true) {
				let charCode = ar.readU8();
				if(charCode == 0) {
					break;
				}
				str += String.fromCodePoint(charCode);
			}
			this.names.push(str);
		}
		ar.guard();
		this.alphaIn = [];
		this.alphaOut = [];
		if(this.fileVersion >= 26) {
			let _g = 0;
			let _g1 = numDetails;
			while(_g < _g1) {
				_g++;
				this.alphaIn.push(ar.readS32());
			}
			let _g2 = 0;
			let _g3 = numDetails;
			while(_g2 < _g3) {
				_g2++;
				this.alphaOut.push(ar.readS32());
			}
		}
	}
	parseMaterialList(br,version) {
		br.readByte();
		let numMaterials = br.readInt32();
		this.matNames = [];
		this.matFlags = [];
		this.matReflectanceMaps = [];
		this.matBumpMaps = [];
		this.matDetailMaps = [];
		this.matDetailScales = [];
		this.matReflectionAmounts = [];
		let _g = 0;
		while(_g < numMaterials) {
			++_g;
			let mname = br.readStr();
			mname = StringTools.replace(mname,"\x00","");
			this.matNames.push(mname);
		}
		let _g1 = 0;
		while(_g1 < numMaterials) {
			++_g1;
			this.matFlags.push(br.readInt32());
		}
		let _g2 = 0;
		while(_g2 < numMaterials) {
			++_g2;
			this.matReflectanceMaps.push(br.readInt32());
		}
		let _g3 = 0;
		while(_g3 < numMaterials) {
			++_g3;
			this.matBumpMaps.push(br.readInt32());
		}
		let _g4 = 0;
		while(_g4 < numMaterials) {
			++_g4;
			this.matDetailMaps.push(br.readInt32());
		}
		if(version == 25) {
			let _g = 0;
			while(_g < numMaterials) {
				++_g;
				br.readInt32();
			}
		}
		let _g5 = 0;
		while(_g5 < numMaterials) {
			++_g5;
			this.matDetailScales.push(br.readFloat());
		}
		let _g6 = 0;
		while(_g6 < numMaterials) {
			++_g6;
			this.matReflectionAmounts.push(br.readFloat());
		}
	}
	readName(br,addName) {
		let sz = br.readInt32();
		let nameIndex = -1;
		if(sz > 0) {
			let str = "";
			let _g = 0;
			let _g1 = sz;
			while(_g < _g1) {
				_g++;
				let code = br.readByte();
				str += String.fromCodePoint(code);
			}
			nameIndex = this.names.indexOf(str);
			if(nameIndex < 0 && addName) {
				nameIndex = this.names.length;
				this.names.push(str);
			}
		}
		return nameIndex;
	}
	importSequences(filepath) {
		let f = src_ResourceLoader.getFileEntry(filepath).entry;
		let bytes = f.getBytes();
		let br = new dif_io_BytesReader(bytes);
		let version = br.readInt32();
		let sz = br.readInt32();
		let checkForDups = [];
		let nodeMap = [];
		let _g = 0;
		let _g1 = sz;
		while(_g < _g1) {
			++_g;
			nodeMap.push(0);
		}
		let _g2 = 0;
		let _g3 = sz;
		while(_g2 < _g3) {
			let i = _g2++;
			let startSize = this.names.length;
			let nameIndex = this.readName(br,true);
			let count = 0;
			if(nameIndex >= 0) {
				while(checkForDups.length < nameIndex + 1) checkForDups.push(0);
				count = checkForDups[nameIndex]++;
			}
			if(count > 0) {
				nodeMap[i] = -1;
				let jout = 0;
				let _g = 0;
				let _g1 = this.nodes.length;
				while(_g < _g1) {
					let j = _g++;
					if(this.nodes[j].name == nameIndex && count-- == 0) {
						break;
					}
					++jout;
				}
				nodeMap[i] = jout;
				if(jout == this.nodes.length) {
					src_Console.instance.addEntry("error","Sequence import failed, a node is duplicated more in sequence than in shape.");
					return false;
				}
			} else {
				let tmp = this.nodes;
				let _this = this.nodes;
				let _g = [];
				let _g1 = 0;
				while(_g1 < _this.length) {
					let v = _this[_g1];
					++_g1;
					if(v.name == nameIndex) {
						_g.push(v);
					}
				}
				nodeMap[i] = tmp.indexOf(_g[0]);
			}
			if(nodeMap[i] < 0) {
				src_Console.instance.addEntry("error","Sequence import failed, a node is duplicated more in sequence than in shape.");
				if(this.names.length != startSize) {
					this.names.pop();
				}
				return false;
			}
		}
		sz = br.readInt32();
		let oldShapeNumObjects = br.readInt32();
		let keyframes = [];
		if(version < 17) {
			let sz = br.readInt32();
			let _g = 0;
			while(_g < sz) {
				++_g;
				keyframes.push(dts_KeyFrame.read(br));
			}
		}
		let adjNodeRots = version < 22 ? this.nodeRotations.length - nodeMap.length : this.nodeRotations.length;
		let adjNodeTrans = version < 22 ? this.nodeTranslations.length - nodeMap.length : this.nodeTranslations.length;
		let adjNodeScales1 = this.nodeUniformScales.length;
		let adjNodeScales2 = this.nodeAlignedScales.length;
		let adjNodeScales3 = this.nodeArbitraryScaleFactors.length;
		let adjObjectStates = this.objectStates.length - oldShapeNumObjects;
		let adjGroundStates = version < 22 ? 0 : this.groundTranslations.length;
		let _g4 = 0;
		let _g5 = keyframes.length;
		while(_g4 < _g5) {
			let i = _g4++;
			keyframes[i].firstNodeState += adjNodeRots;
			keyframes[i].firstObjectState += adjObjectStates;
		}
		let readS16 = function() {
			let val = br.readInt16();
			if(val > 32767) {
				val -= 65536;
			}
			return val;
		};
		if(version > 21) {
			sz = br.readInt32();
			let _g = 0;
			let _g1 = sz;
			while(_g < _g1) {
				++_g;
				let q = new dif_math_QuatF();
				q.x = readS16();
				q.y = readS16();
				q.z = readS16();
				q.w = readS16();
				this.nodeRotations.push(q);
			}
			sz = br.readInt32();
			let _g2 = 0;
			let _g3 = sz;
			while(_g2 < _g3) {
				++_g2;
				let p = new dif_math_Point3F();
				p.x = br.readFloat();
				p.y = br.readFloat();
				p.z = br.readFloat();
				this.nodeTranslations.push(p);
			}
			sz = br.readInt32();
			let _g4 = 0;
			let _g5 = sz;
			while(_g4 < _g5) {
				++_g4;
				this.nodeUniformScales.push(br.readFloat());
			}
			sz = br.readInt32();
			let _g6 = 0;
			let _g7 = sz;
			while(_g6 < _g7) {
				++_g6;
				let p = new dif_math_Point3F();
				p.x = br.readFloat();
				p.y = br.readFloat();
				p.z = br.readFloat();
				this.nodeAlignedScales.push(p);
			}
			sz = br.readInt32();
			let _g8 = 0;
			let _g9 = sz;
			while(_g8 < _g9) {
				++_g8;
				let q = new dif_math_QuatF();
				q.x = readS16();
				q.y = readS16();
				q.z = readS16();
				q.w = readS16();
				this.nodeArbitraryScaleRots.push(q);
			}
			let _g10 = 0;
			let _g11 = sz;
			while(_g10 < _g11) {
				++_g10;
				let p = new dif_math_Point3F();
				p.x = br.readFloat();
				p.y = br.readFloat();
				p.z = br.readFloat();
				this.nodeArbitraryScaleFactors.push(p);
			}
			sz = br.readInt32();
			let _g12 = 0;
			let _g13 = sz;
			while(_g12 < _g13) {
				++_g12;
				let p = new dif_math_Point3F();
				p.x = br.readFloat();
				p.y = br.readFloat();
				p.z = br.readFloat();
				this.groundTranslations.push(p);
			}
			let _g14 = 0;
			let _g15 = sz;
			while(_g14 < _g15) {
				++_g14;
				let q = new dif_math_QuatF();
				q.x = readS16();
				q.y = readS16();
				q.z = readS16();
				q.w = readS16();
				this.groundRots.push(q);
			}
		} else {
			sz = br.readInt32();
			let _g = 0;
			let _g1 = sz;
			while(_g < _g1) {
				++_g;
				let q = new dif_math_QuatF();
				q.x = readS16();
				q.y = readS16();
				q.z = readS16();
				q.w = readS16();
				let p = new dif_math_Point3F();
				p.x = br.readFloat();
				p.y = br.readFloat();
				p.z = br.readFloat();
				this.nodeRotations.push(q);
				this.nodeTranslations.push(p);
			}
		}
		sz = br.readInt32();
		sz = br.readInt32();
		let startSeqNum = this.sequences.length;
		let _g6 = 0;
		let _g7 = sz;
		while(_g6 < _g7) {
			++_g6;
			let seq = new dts_Sequence();
			seq.nameIndex = this.readName(br,true);
			seq.read(br,this.fileVersion,false);
			if(version > 21) {
				seq.baseRotation += adjNodeRots;
				seq.baseTranslation += adjNodeTrans;
				if((seq.flags & 1) > 0) {
					seq.baseScale += adjNodeScales1;
				} else if((seq.flags & 2) > 0) {
					seq.baseScale += adjNodeScales2;
				} else if((seq.flags & 4) > 0) {
					seq.baseScale += adjNodeScales3;
				}
			} else if(version >= 17) {
				seq.baseRotation += adjNodeRots;
				seq.baseTranslation += adjNodeTrans;
			}
			let newTM = 0;
			let newRM = 0;
			let newSM = 0;
			let _g = 0;
			let _g1 = nodeMap.length;
			while(_g < _g1) {
				let j = _g++;
				if((seq.translationMatters[0] & 1 << j) > 0) {
					newTM |= 1 << nodeMap[j];
				}
				if((seq.rotationMatters[0] & 1 << j) > 0) {
					newRM |= 1 << nodeMap[j];
				}
				if((seq.scaleMatters[0] & 1 << j) > 0) {
					newSM |= 1 << nodeMap[j];
				}
			}
			seq.translationMatters[0] = newTM;
			seq.rotationMatters[0] = newRM;
			seq.scaleMatters[0] = newSM;
			seq.firstTrigger += this.triggers.length;
			seq.firstGroundFrame += adjGroundStates;
			this.sequences.push(seq);
		}
		if(version < 17) {
			return false;
		}
		if(version < 22) {
			let _g = startSeqNum;
			let _g1 = this.sequences.length;
			while(_g < _g1) {
				let i = _g++;
				let oldSz = this.groundTranslations.length;
				let _g1 = 0;
				let _g2 = this.sequences[i].numGroundFrames;
				while(_g1 < _g2) {
					let j = _g1++;
					this.groundTranslations.push(this.nodeTranslations[this.sequences[i].firstGroundFrame + adjNodeTrans + j]);
					this.groundRots.push(this.nodeRotations[this.sequences[i].firstGroundFrame + adjNodeRots + j]);
				}
				this.sequences[i].firstGroundFrame = oldSz;
			}
		}
		if(version > 8) {
			sz = br.readInt32();
			let _g = 0;
			let _g1 = sz;
			while(_g < _g1) {
				++_g;
				let t = new dts_Trigger();
				t.state = br.readInt32();
				t.position = br.readFloat();
			}
		}
		return true;
	}
}
$hxClasses["dts.DtsFile"] = dts_DtsFile;
dts_DtsFile.__name__ = "dts.DtsFile";
Object.assign(dts_DtsFile.prototype, {
	__class__: dts_DtsFile
	,fileVersion: null
	,exporterVersion: null
	,sequences: null
	,matNames: null
	,matFlags: null
	,matReflectanceMaps: null
	,matBumpMaps: null
	,matDetailMaps: null
	,matDetailScales: null
	,matReflectionAmounts: null
	,smallestVisibleSize: null
	,smallestVisibleDL: null
	,radius: null
	,radiusTube: null
	,center: null
	,bounds: null
	,nodes: null
	,objects: null
	,mats: null
	,subshapes: null
	,defaultRotations: null
	,defaultTranslations: null
	,nodeTranslations: null
	,nodeRotations: null
	,nodeUniformScales: null
	,nodeAlignedScales: null
	,nodeArbitraryScaleFactors: null
	,nodeArbitraryScaleRots: null
	,groundTranslations: null
	,groundRots: null
	,objectStates: null
	,decalStates: null
	,triggers: null
	,detailLevels: null
	,meshes: null
	,names: null
	,alphaIn: null
	,alphaOut: null
});
class dts_DtsOldAlloc {
	constructor(buf,sourceIndex) {
		this.nextGuard = 0;
		this.buf = buf;
		this.index32 = 0;
		this.index16 = 0;
		this.index8 = 0;
		this.sourceIndex = sourceIndex;
		this.buffer8 = new haxe_io_Bytes(new ArrayBuffer(25000));
		this.buffer16 = new haxe_io_Bytes(new ArrayBuffer(25000));
		this.buffer32 = new haxe_io_Bytes(new ArrayBuffer(25000));
	}
	skip(bytes) {
		this.sourceIndex += bytes;
	}
	allocate32(words) {
		this.index32 += words * 4;
	}
	copyInto32(count) {
		let _g = 0;
		while(_g < count) {
			let i = _g++;
			this.buf.seek(this.sourceIndex + i * 4);
			this.buffer32.setInt32(this.index32 + i * 4,this.buf.readInt32());
		}
		this.sourceIndex += count * 4;
		this.index32 += count * 4;
	}
	copyInto16(count) {
		let _g = 0;
		while(_g < count) {
			let i = _g++;
			this.buf.seek(this.sourceIndex + i * 2);
			this.buffer16.setUInt16(this.index16 + i * 2,this.buf.readInt16());
		}
		this.sourceIndex += count * 2;
		this.index16 += count * 2;
	}
	copyInto8(count) {
		let _g = 0;
		while(_g < count) {
			let i = _g++;
			this.buf.seek(this.sourceIndex + i);
			let _this = this.buffer8;
			let pos = this.index8 + i;
			let v = this.buf.readByte();
			_this.b[pos] = v;
		}
		this.sourceIndex += count;
		this.index8 += count;
	}
	readS32(storeIndex) {
		if(storeIndex == -1) {
			storeIndex = this.index32 / 4;
		}
		this.buf.seek(this.sourceIndex);
		let val = this.buf.readInt32();
		this.sourceIndex += 4;
		if(storeIndex != null) {
			this.buffer32.setInt32(storeIndex * 4,val);
			if(storeIndex * 4 == this.index32) {
				this.index32 += 4;
			}
		}
		return val;
	}
	writeS32(value) {
		this.buffer32.setInt32(this.index32,value);
		this.index32 += 4;
	}
	writeU8(value) {
		this.buffer8.b[this.index8] = value;
		this.index8 += 1;
	}
	guard() {
		this.buffer32.setInt32(this.index32,this.nextGuard);
		this.buffer16.setUInt16(this.index16,this.nextGuard);
		this.buffer8.b[this.index8] = this.nextGuard;
		this.nextGuard++;
		this.index32 += 4;
		this.index16 += 2;
		this.index8 += 1;
	}
	createBuffer() {
		this.index16 = Math.ceil(this.index16 / 4) * 4;
		this.index8 = Math.ceil(this.index8 / 4) * 4;
		let buffer = new haxe_io_Bytes(new ArrayBuffer(this.index32 + this.index16 + this.index8));
		let index = 0;
		let _g = 0;
		let _g1 = this.index32;
		while(_g < _g1) {
			let i = _g++;
			buffer.b[index++] = this.buffer32.b[i];
		}
		let _g2 = 0;
		let _g3 = this.index16;
		while(_g2 < _g3) {
			let i = _g2++;
			buffer.b[index++] = this.buffer16.b[i];
		}
		let _g4 = 0;
		let _g5 = this.index8;
		while(_g4 < _g5) {
			let i = _g4++;
			buffer.b[index++] = this.buffer8.b[i];
		}
		return { buffer : buffer, start16 : this.index32 / 4 | 0, start8 : (this.index32 + this.index16) / 4 | 0};
	}
}
$hxClasses["dts.DtsOldAlloc"] = dts_DtsOldAlloc;
dts_DtsOldAlloc.__name__ = "dts.DtsOldAlloc";
Object.assign(dts_DtsOldAlloc.prototype, {
	__class__: dts_DtsOldAlloc
	,buf: null
	,index32: null
	,index16: null
	,index8: null
	,sourceIndex: null
	,buffer32: null
	,buffer16: null
	,buffer8: null
	,nextGuard: null
});
class dts_IflMaterial {
	constructor() {
	}
	static read(reader) {
		let ifl = new dts_IflMaterial();
		ifl.name = reader.readU32();
		ifl.slot = reader.readU32();
		ifl.firstFrame = reader.readU32();
		ifl.time = reader.readU32();
		ifl.numFrames = reader.readU32();
		return ifl;
	}
}
$hxClasses["dts.IflMaterial"] = dts_IflMaterial;
dts_IflMaterial.__name__ = "dts.IflMaterial";
Object.assign(dts_IflMaterial.prototype, {
	__class__: dts_IflMaterial
	,name: null
	,slot: null
	,firstFrame: null
	,time: null
	,numFrames: null
});
class dts_KeyFrame {
	constructor() {
	}
	static read(reader) {
		let k = new dts_KeyFrame();
		k.firstNodeState = reader.readInt32();
		k.firstObjectState = reader.readInt32();
		k.firstDecalState = reader.readInt32();
		return k;
	}
}
$hxClasses["dts.KeyFrame"] = dts_KeyFrame;
dts_KeyFrame.__name__ = "dts.KeyFrame";
Object.assign(dts_KeyFrame.prototype, {
	__class__: dts_KeyFrame
	,firstNodeState: null
	,firstObjectState: null
	,firstDecalState: null
});
class dts_Mesh {
	constructor() {
	}
	readStandard(reader,version) {
		reader.guard();
		this.numFrames = reader.readU32();
		this.numMatFrames = reader.readU32();
		this.parent = reader.readS32();
		this.bounds = reader.readBoxF();
		this.center = reader.readPoint3F();
		this.radius = reader.readF32();
		let numVerts = reader.readU32();
		this.vertices = [];
		if(this.parent < 0) {
			let _g = 0;
			while(_g < numVerts) {
				++_g;
				this.vertices.push(reader.readPoint3F());
			}
		} else {
			this.vertices = this.shape.meshes[this.parent].vertices;
		}
		let tVerts = reader.readU32();
		this.uv = [];
		if(this.parent < 0) {
			let _g = 0;
			while(_g < tVerts) {
				++_g;
				this.uv.push(reader.readPoint2F());
			}
		} else {
			this.uv = this.shape.meshes[this.parent].uv;
		}
		this.normals = [];
		if(this.parent < 0) {
			let _g = 0;
			while(_g < numVerts) {
				++_g;
				this.normals.push(reader.readPoint3F());
			}
		} else {
			this.normals = this.shape.meshes[this.parent].normals;
		}
		this.enormals = [];
		if(this.parent < 0 && version > 21) {
			let _g = 0;
			while(_g < numVerts) {
				++_g;
				this.enormals.push(reader.readU8());
			}
		}
		this.primitives = [];
		let numPrimitives = reader.readU32();
		let _g = 0;
		while(_g < numPrimitives) {
			++_g;
			this.primitives.push(dts_Primitive.read(reader));
		}
		this.indices = [];
		let numIndices = reader.readU32();
		let _g1 = 0;
		while(_g1 < numIndices) {
			++_g1;
			this.indices.push(reader.readS16());
		}
		this.mindices = [];
		let numMIndices = reader.readU32();
		let _g2 = 0;
		while(_g2 < numMIndices) {
			++_g2;
			this.mindices.push(reader.readS16());
		}
		this.vertsPerFrame = reader.readS32();
		this.type = reader.readS32();
		reader.guard();
	}
	readSkinned(reader,version) {
		this.readStandard(reader,version);
		let numVerts = reader.readS32();
		if(this.parent < 0) {
			this.vertices = [];
			let _g = 0;
			while(_g < numVerts) {
				++_g;
				this.vertices.push(reader.readPoint3F());
			}
			this.normals = [];
			let _g1 = 0;
			while(_g1 < numVerts) {
				++_g1;
				this.normals.push(reader.readPoint3F());
			}
			if(this.parent < 0) {
				let _g = 0;
				while(_g < numVerts) {
					++_g;
					reader.readU8();
				}
			}
			let sz = reader.readS32();
			this.initialTransforms = [];
			let _g2 = 0;
			let _g3 = sz;
			while(_g2 < _g3) {
				++_g2;
				this.initialTransforms.push(reader.readMatrixF());
			}
			sz = reader.readS32();
			this.vertexIndices = [];
			let _g4 = 0;
			let _g5 = sz;
			while(_g4 < _g5) {
				++_g4;
				this.vertexIndices.push(reader.readS32());
			}
			this.boneIndices = [];
			let _g6 = 0;
			let _g7 = sz;
			while(_g6 < _g7) {
				++_g6;
				this.boneIndices.push(reader.readS32());
			}
			this.weights = [];
			let _g8 = 0;
			let _g9 = sz;
			while(_g8 < _g9) {
				++_g8;
				this.weights.push(reader.readF32());
			}
			sz = reader.readS32();
			this.nodeIndices = [];
			let _g10 = 0;
			let _g11 = sz;
			while(_g10 < _g11) {
				++_g10;
				this.nodeIndices.push(reader.readS32());
			}
		} else {
			let other = this.shape.meshes[this.parent];
			if(other == null) {
				return;
			}
			this.vertices = other.vertices;
			this.normals = other.normals;
			if(this.parent < 0) {
				let _g = 0;
				while(_g < numVerts) {
					++_g;
					reader.readU8();
				}
			}
			reader.readS32();
			this.initialTransforms = other.initialTransforms;
			reader.readS32();
			this.vertexIndices = other.vertexIndices;
			this.boneIndices = other.boneIndices;
			this.weights = other.weights;
			reader.readS32();
			this.nodeIndices = other.nodeIndices;
		}
		reader.guard();
	}
	static read(shape,reader,version) {
		let mesh = new dts_Mesh();
		mesh.shape = shape;
		mesh.meshType = reader.readS32() & 7;
		if(mesh.meshType == 0) {
			mesh.readStandard(reader,version);
		} else if(mesh.meshType == 1) {
			mesh.readSkinned(reader,version);
		} else if(mesh.meshType == 4) {
			return null;
		} else {
			throw new haxe_Exception("idk how to read this");
		}
		return mesh;
	}
}
$hxClasses["dts.Mesh"] = dts_Mesh;
dts_Mesh.__name__ = "dts.Mesh";
Object.assign(dts_Mesh.prototype, {
	__class__: dts_Mesh
	,meshType: null
	,numFrames: null
	,numMatFrames: null
	,parent: null
	,bounds: null
	,center: null
	,radius: null
	,vertices: null
	,uv: null
	,normals: null
	,enormals: null
	,primitives: null
	,indices: null
	,mindices: null
	,vertsPerFrame: null
	,type: null
	,shape: null
	,initialTransforms: null
	,vertexIndices: null
	,boneIndices: null
	,weights: null
	,nodeIndices: null
});
class dts_Node {
	constructor() {
		this.nextSibling = -1;
		this.firstChild = -1;
		this.firstObject = -1;
	}
	static read(reader) {
		let node = new dts_Node();
		node.name = reader.readU32();
		node.parent = reader.readU32();
		node.firstObject = reader.readU32();
		node.firstChild = reader.readU32();
		node.nextSibling = reader.readU32();
		return node;
	}
}
$hxClasses["dts.Node"] = dts_Node;
dts_Node.__name__ = "dts.Node";
Object.assign(dts_Node.prototype, {
	__class__: dts_Node
	,name: null
	,parent: null
	,firstObject: null
	,firstChild: null
	,nextSibling: null
});
class dts_Object {
	constructor() {
	}
	static read(reader) {
		let obj = new dts_Object();
		obj.name = reader.readU32();
		obj.numMeshes = reader.readU32();
		obj.firstMesh = reader.readU32();
		obj.node = reader.readU32();
		obj.nextSibling = reader.readU32();
		obj.firstDecal = reader.readU32();
		return obj;
	}
}
$hxClasses["dts.Object"] = dts_Object;
dts_Object.__name__ = "dts.Object";
Object.assign(dts_Object.prototype, {
	__class__: dts_Object
	,name: null
	,numMeshes: null
	,firstMesh: null
	,node: null
	,firstDecal: null
	,nextSibling: null
});
class dts_ObjectState {
	constructor() {
	}
	static read(reader) {
		let os = new dts_ObjectState();
		os.vis = reader.readF32();
		os.frame = reader.readU32();
		os.matFrame = reader.readU32();
		return os;
	}
}
$hxClasses["dts.ObjectState"] = dts_ObjectState;
dts_ObjectState.__name__ = "dts.ObjectState";
Object.assign(dts_ObjectState.prototype, {
	__class__: dts_ObjectState
	,vis: null
	,frame: null
	,matFrame: null
});
class dts_Primitive {
	constructor() {
	}
	static read(reader) {
		let p = new dts_Primitive();
		p.firstElement = reader.readU16();
		p.numElements = reader.readU16();
		p.matIndex = reader.readU32();
		return p;
	}
}
$hxClasses["dts.Primitive"] = dts_Primitive;
dts_Primitive.__name__ = "dts.Primitive";
Object.assign(dts_Primitive.prototype, {
	__class__: dts_Primitive
	,firstElement: null
	,numElements: null
	,matIndex: null
});
class dts_Sequence {
	constructor() {
	}
	read(reader,fileVersion,readNameIndex) {
		if(readNameIndex) {
			this.nameIndex = reader.readInt32();
		}
		this.flags = 0;
		if(fileVersion > 21) {
			this.flags = reader.readInt32();
		}
		this.numKeyFrames = reader.readInt32();
		this.duration = reader.readFloat();
		if(fileVersion < 22) {
			let tmp = reader.readByte();
			if(tmp > 0) {
				this.flags |= dts_ShapeFlags.Blend;
			}
			tmp = reader.readByte();
			if(tmp > 0) {
				this.flags |= dts_ShapeFlags.Cyclic;
			}
			tmp = reader.readByte();
			if(tmp > 0) {
				this.flags |= dts_ShapeFlags.MakePath;
			}
		}
		this.priority = reader.readInt32();
		this.firstGroundFrame = reader.readInt32();
		this.numGroundFrames = reader.readInt32();
		if(fileVersion > 21) {
			this.baseRotation = reader.readInt32();
			this.baseTranslation = reader.readInt32();
			this.baseScale = reader.readInt32();
			this.baseObjectState = reader.readInt32();
			this.baseDecalState = reader.readInt32();
		} else {
			this.baseRotation = reader.readInt32();
			this.baseTranslation = this.baseRotation;
			this.baseObjectState = reader.readInt32();
			this.baseDecalState = reader.readInt32();
		}
		this.firstTrigger = reader.readInt32();
		this.numTriggers = reader.readInt32();
		this.toolBegin = reader.readInt32();
		this.rotationMatters = this.readBitSet(reader);
		this.translationMatters = this.readBitSet(reader);
		this.scaleMatters = this.readBitSet(reader);
		this.decalMatters = this.readBitSet(reader);
		this.iflMatters = this.readBitSet(reader);
		this.visMatters = this.readBitSet(reader);
		this.frameMatters = this.readBitSet(reader);
		this.matFrameMatters = this.readBitSet(reader);
		this.dirtyFlags = 0;
		return true;
	}
	readBitSet(reader) {
		reader.readInt32();
		let numWords = reader.readInt32();
		let ret = [];
		let _g = 0;
		while(_g < numWords) {
			++_g;
			ret.push(reader.readInt32());
		}
		return ret;
	}
}
$hxClasses["dts.Sequence"] = dts_Sequence;
dts_Sequence.__name__ = "dts.Sequence";
Object.assign(dts_Sequence.prototype, {
	__class__: dts_Sequence
	,nameIndex: null
	,numKeyFrames: null
	,duration: null
	,baseRotation: null
	,baseTranslation: null
	,baseScale: null
	,baseObjectState: null
	,baseDecalState: null
	,firstGroundFrame: null
	,numGroundFrames: null
	,firstTrigger: null
	,numTriggers: null
	,toolBegin: null
	,rotationMatters: null
	,translationMatters: null
	,scaleMatters: null
	,visMatters: null
	,frameMatters: null
	,matFrameMatters: null
	,decalMatters: null
	,iflMatters: null
	,priority: null
	,flags: null
	,dirtyFlags: null
});
class dts_ShapeFlags {
}
$hxClasses["dts.ShapeFlags"] = dts_ShapeFlags;
dts_ShapeFlags.__name__ = "dts.ShapeFlags";
class dts_SubShape {
	constructor(firstNode,firstObject,firstDecal,numNodes,numObjects,numDecals) {
		this.firstNode = firstNode;
		this.firstObject = firstObject;
		this.firstDecal = firstDecal;
		this.numNodes = numNodes;
		this.numObjects = numObjects;
		this.numDecals = numDecals;
	}
}
$hxClasses["dts.SubShape"] = dts_SubShape;
dts_SubShape.__name__ = "dts.SubShape";
Object.assign(dts_SubShape.prototype, {
	__class__: dts_SubShape
	,firstNode: null
	,firstObject: null
	,firstDecal: null
	,numNodes: null
	,numObjects: null
	,numDecals: null
});
class dts_TSDrawPrimitive {
}
$hxClasses["dts.TSDrawPrimitive"] = dts_TSDrawPrimitive;
dts_TSDrawPrimitive.__name__ = "dts.TSDrawPrimitive";
class dts_Trigger {
	constructor() {
	}
	static read(reader) {
		let t = new dts_Trigger();
		t.state = reader.readU32();
		t.position = reader.readU32();
		return t;
	}
}
$hxClasses["dts.Trigger"] = dts_Trigger;
dts_Trigger.__name__ = "dts.Trigger";
Object.assign(dts_Trigger.prototype, {
	__class__: dts_Trigger
	,state: null
	,position: null
});
class format_bmp_Reader {
	constructor(i) {
		this.input = i;
	}
	read() {
		if(this.input.readByte() != 66) {
			throw haxe_Exception.thrown("Invalid header");
		}
		if(this.input.readByte() != 77) {
			throw haxe_Exception.thrown("Invalid header");
		}
		let fileSize = this.input.readInt32();
		this.input.readInt32();
		let offset = this.input.readInt32();
		let infoHeaderSize = this.input.readInt32();
		if(infoHeaderSize != 40) {
			throw haxe_Exception.thrown("Info headers with size " + infoHeaderSize + " not supported.");
		}
		let width = this.input.readInt32();
		let height = this.input.readInt32();
		this.input.readInt16();
		let bits = this.input.readInt16();
		let compression = this.input.readInt32();
		let dataLength = this.input.readInt32();
		this.input.readInt32();
		this.input.readInt32();
		let colorsUsed = this.input.readInt32();
		this.input.readInt32();
		if(compression == 0 && dataLength == 0) {
			dataLength = fileSize - offset;
		}
		let bytesRead = 54;
		let colorTable = null;
		if(bits <= 8) {
			if(colorsUsed == 0) {
				switch(bits) {
				case 1:
					colorsUsed = 2;
					break;
				case 4:
					colorsUsed = 16;
					break;
				case 8:
					colorsUsed = 256;
					break;
				case 16:
					colorsUsed = 65536;
					break;
				default:
					throw haxe_Exception.thrown("Unsupported bpp " + bits);
				}
			}
			let colorTableLength = 4 * colorsUsed;
			colorTable = new haxe_io_Bytes(new ArrayBuffer(colorTableLength));
			this.input.readFullBytes(colorTable,0,colorTableLength);
			bytesRead = 54 + colorTableLength;
		}
		this.input.read(offset - bytesRead);
		let p = new haxe_io_Bytes(new ArrayBuffer(dataLength));
		let paddedStride = (width * bits + 31 & -32) >> 3;
		let topToBottom = false;
		if(height < 0) {
			topToBottom = true;
			height = -height;
		}
		this.input.readFullBytes(p,0,dataLength);
		return { header : { width : width, height : height, paddedStride : paddedStride, topToBottom : topToBottom, bpp : bits, dataLength : dataLength, compression : compression}, pixels : p, colorTable : colorTable};
	}
}
$hxClasses["format.bmp.Reader"] = format_bmp_Reader;
format_bmp_Reader.__name__ = "format.bmp.Reader";
Object.assign(format_bmp_Reader.prototype, {
	__class__: format_bmp_Reader
	,input: null
});
var format_gif_Block = $hxEnums["format.gif.Block"] = { __ename__:true,__constructs__:null
	,BFrame: ($_=function(frame) { return {_hx_index:0,frame:frame,__enum__:"format.gif.Block",toString:$estr}; },$_._hx_name="BFrame",$_.__params__ = ["frame"],$_)
	,BExtension: ($_=function(extension) { return {_hx_index:1,extension:extension,__enum__:"format.gif.Block",toString:$estr}; },$_._hx_name="BExtension",$_.__params__ = ["extension"],$_)
	,BEOF: {_hx_name:"BEOF",_hx_index:2,__enum__:"format.gif.Block",toString:$estr}
};
format_gif_Block.__constructs__ = [format_gif_Block.BFrame,format_gif_Block.BExtension,format_gif_Block.BEOF];
format_gif_Block.__empty_constructs__ = [format_gif_Block.BEOF];
var format_gif_Extension = $hxEnums["format.gif.Extension"] = { __ename__:true,__constructs__:null
	,EGraphicControl: ($_=function(gce) { return {_hx_index:0,gce:gce,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EGraphicControl",$_.__params__ = ["gce"],$_)
	,EComment: ($_=function(text) { return {_hx_index:1,text:text,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EComment",$_.__params__ = ["text"],$_)
	,EText: ($_=function(pte) { return {_hx_index:2,pte:pte,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EText",$_.__params__ = ["pte"],$_)
	,EApplicationExtension: ($_=function(ext) { return {_hx_index:3,ext:ext,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EApplicationExtension",$_.__params__ = ["ext"],$_)
	,EUnknown: ($_=function(id,data) { return {_hx_index:4,id:id,data:data,__enum__:"format.gif.Extension",toString:$estr}; },$_._hx_name="EUnknown",$_.__params__ = ["id","data"],$_)
};
format_gif_Extension.__constructs__ = [format_gif_Extension.EGraphicControl,format_gif_Extension.EComment,format_gif_Extension.EText,format_gif_Extension.EApplicationExtension,format_gif_Extension.EUnknown];
format_gif_Extension.__empty_constructs__ = [];
var format_gif_ApplicationExtension = $hxEnums["format.gif.ApplicationExtension"] = { __ename__:true,__constructs__:null
	,AENetscapeLooping: ($_=function(loops) { return {_hx_index:0,loops:loops,__enum__:"format.gif.ApplicationExtension",toString:$estr}; },$_._hx_name="AENetscapeLooping",$_.__params__ = ["loops"],$_)
	,AEUnknown: ($_=function(name,version,data) { return {_hx_index:1,name:name,version:version,data:data,__enum__:"format.gif.ApplicationExtension",toString:$estr}; },$_._hx_name="AEUnknown",$_.__params__ = ["name","version","data"],$_)
};
format_gif_ApplicationExtension.__constructs__ = [format_gif_ApplicationExtension.AENetscapeLooping,format_gif_ApplicationExtension.AEUnknown];
format_gif_ApplicationExtension.__empty_constructs__ = [];
var format_gif_Version = $hxEnums["format.gif.Version"] = { __ename__:true,__constructs__:null
	,GIF87a: {_hx_name:"GIF87a",_hx_index:0,__enum__:"format.gif.Version",toString:$estr}
	,GIF89a: {_hx_name:"GIF89a",_hx_index:1,__enum__:"format.gif.Version",toString:$estr}
	,Unknown: ($_=function(version) { return {_hx_index:2,version:version,__enum__:"format.gif.Version",toString:$estr}; },$_._hx_name="Unknown",$_.__params__ = ["version"],$_)
};
format_gif_Version.__constructs__ = [format_gif_Version.GIF87a,format_gif_Version.GIF89a,format_gif_Version.Unknown];
format_gif_Version.__empty_constructs__ = [format_gif_Version.GIF87a,format_gif_Version.GIF89a];
var format_gif_DisposalMethod = $hxEnums["format.gif.DisposalMethod"] = { __ename__:true,__constructs__:null
	,UNSPECIFIED: {_hx_name:"UNSPECIFIED",_hx_index:0,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,NO_ACTION: {_hx_name:"NO_ACTION",_hx_index:1,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,FILL_BACKGROUND: {_hx_name:"FILL_BACKGROUND",_hx_index:2,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,RENDER_PREVIOUS: {_hx_name:"RENDER_PREVIOUS",_hx_index:3,__enum__:"format.gif.DisposalMethod",toString:$estr}
	,UNDEFINED: ($_=function(index) { return {_hx_index:4,index:index,__enum__:"format.gif.DisposalMethod",toString:$estr}; },$_._hx_name="UNDEFINED",$_.__params__ = ["index"],$_)
};
format_gif_DisposalMethod.__constructs__ = [format_gif_DisposalMethod.UNSPECIFIED,format_gif_DisposalMethod.NO_ACTION,format_gif_DisposalMethod.FILL_BACKGROUND,format_gif_DisposalMethod.RENDER_PREVIOUS,format_gif_DisposalMethod.UNDEFINED];
format_gif_DisposalMethod.__empty_constructs__ = [format_gif_DisposalMethod.UNSPECIFIED,format_gif_DisposalMethod.NO_ACTION,format_gif_DisposalMethod.FILL_BACKGROUND,format_gif_DisposalMethod.RENDER_PREVIOUS];
class format_gif_Reader {
	constructor(i) {
		this.i = i;
		i.set_bigEndian(false);
	}
	read() {
		if(this.i.readByte() != 71) {
			throw haxe_Exception.thrown("Invalid header");
		}
		if(this.i.readByte() != 73) {
			throw haxe_Exception.thrown("Invalid header");
		}
		if(this.i.readByte() != 70) {
			throw haxe_Exception.thrown("Invalid header");
		}
		let gifVer = this.i.readString(3);
		let version = format_gif_Version.GIF89a;
		switch(gifVer) {
		case "87a":
			version = format_gif_Version.GIF87a;
			break;
		case "89a":
			version = format_gif_Version.GIF89a;
			break;
		default:
			version = format_gif_Version.Unknown(gifVer);
		}
		let width = this.i.readUInt16();
		let height = this.i.readUInt16();
		let packedField = this.i.readByte();
		let bgIndex = this.i.readByte();
		let pixelAspectRatio = this.i.readByte();
		if(pixelAspectRatio != 0) {
			pixelAspectRatio = (pixelAspectRatio + 15) / 64;
		} else {
			pixelAspectRatio = 1;
		}
		let lsd = { width : width, height : height, hasGlobalColorTable : (packedField & 128) == 128, colorResolution : (packedField & 112) >>> 4, sorted : (packedField & 8) == 8, globalColorTableSize : 2 << (packedField & 7), backgroundColorIndex : bgIndex, pixelAspectRatio : pixelAspectRatio};
		let gct = null;
		if(lsd.hasGlobalColorTable) {
			gct = this.readColorTable(lsd.globalColorTableSize);
		}
		let blocks = new haxe_ds_List();
		while(true) {
			let b = this.readBlock();
			blocks.add(b);
			if(b == format_gif_Block.BEOF) {
				break;
			}
		}
		return { version : version, logicalScreenDescriptor : lsd, globalColorTable : gct, blocks : blocks};
	}
	readBlock() {
		let blockID = this.i.readByte();
		switch(blockID) {
		case 33:
			return this.readExtension();
		case 44:
			return this.readImage();
		case 59:
			return format_gif_Block.BEOF;
		}
		return format_gif_Block.BEOF;
	}
	readImage() {
		let x = this.i.readUInt16();
		let y = this.i.readUInt16();
		let width = this.i.readUInt16();
		let height = this.i.readUInt16();
		let packed = this.i.readByte();
		let localColorTable = (packed & 128) == 128;
		let interlaced = (packed & 64) == 64;
		let sorted = (packed & 32) == 32;
		let localColorTableSize = 2 << (packed & 7);
		let lct = null;
		if(localColorTable) {
			lct = this.readColorTable(localColorTableSize);
		}
		return format_gif_Block.BFrame({ x : x, y : y, width : width, height : height, localColorTable : localColorTable, interlaced : interlaced, sorted : sorted, localColorTableSize : localColorTableSize, pixels : this.readPixels(width,height,interlaced), colorTable : lct});
	}
	readPixels(width,height,interlaced) {
		let input = this.i;
		let pixelsCount = width * height;
		let pixels = new haxe_io_Bytes(new ArrayBuffer(pixelsCount));
		let minCodeSize = input.readByte();
		let blockSize = input.readByte() - 1;
		let bits = input.readByte();
		let bitsCount = 8;
		let clearCode = 1 << minCodeSize;
		let eoiCode = clearCode + 1;
		let codeSize = minCodeSize + 1;
		let codeSizeLimit = 1 << codeSize;
		let codeMask = codeSizeLimit - 1;
		let baseDict = [];
		let _g = 0;
		while(_g < clearCode) {
			let i = _g++;
			baseDict[i] = [i];
		}
		let dict = [];
		let dictLen = clearCode + 2;
		let newRecord;
		let i = 0;
		let code = 0;
		let last;
		while(i < pixelsCount) {
			last = code;
			while(bitsCount < codeSize) {
				if(blockSize == 0) {
					break;
				}
				bits |= input.readByte() << bitsCount;
				bitsCount += 8;
				--blockSize;
				if(blockSize == 0) {
					blockSize = input.readByte();
				}
			}
			code = bits & codeMask;
			bits >>= codeSize;
			bitsCount -= codeSize;
			if(code == clearCode) {
				dict = baseDict.slice();
				dictLen = clearCode + 2;
				codeSize = minCodeSize + 1;
				codeSizeLimit = 1 << codeSize;
				codeMask = codeSizeLimit - 1;
				continue;
			}
			if(code == eoiCode) {
				break;
			}
			if(code < dictLen) {
				if(last != clearCode) {
					newRecord = dict[last].slice();
					newRecord.push(dict[code][0]);
					dict[dictLen++] = newRecord;
				}
			} else {
				if(code != dictLen) {
					throw haxe_Exception.thrown("Invalid LZW code. Excepted: " + dictLen + ", got: " + code);
				}
				newRecord = dict[last].slice();
				newRecord.push(newRecord[0]);
				dict[dictLen++] = newRecord;
			}
			newRecord = dict[code];
			let _g = 0;
			while(_g < newRecord.length) {
				let item = newRecord[_g];
				++_g;
				pixels.b[i++] = item;
			}
			if(dictLen == codeSizeLimit && codeSize < 12) {
				++codeSize;
				codeSizeLimit = 1 << codeSize;
				codeMask = codeSizeLimit - 1;
			}
		}
		while(blockSize > 0) {
			input.readByte();
			--blockSize;
			if(blockSize == 0) {
				blockSize = input.readByte();
			}
		}
		while(i < pixelsCount) pixels.b[i++] = 0;
		if(interlaced) {
			let buffer = new haxe_io_Bytes(new ArrayBuffer(pixelsCount));
			let offset = this.deinterlace(pixels,buffer,8,0,0,width,height);
			offset = this.deinterlace(pixels,buffer,8,4,offset,width,height);
			offset = this.deinterlace(pixels,buffer,4,2,offset,width,height);
			this.deinterlace(pixels,buffer,2,1,offset,width,height);
			pixels = buffer;
		}
		return pixels;
	}
	deinterlace(input,output,step,y,offset,width,height) {
		while(y < height) {
			output.blit(y * width,input,offset,width);
			offset += width;
			y += step;
		}
		return offset;
	}
	readExtension() {
		let subId = this.i.readByte();
		switch(subId) {
		case 1:
			if(this.i.readByte() != 12) {
				throw haxe_Exception.thrown("Incorrect size of Plain Text Extension introducer block.");
			}
			let tmp = this.i.readUInt16();
			let tmp1 = this.i.readUInt16();
			let tmp2 = this.i.readUInt16();
			let tmp3 = this.i.readUInt16();
			let tmp4 = this.i.readByte();
			let tmp5 = this.i.readByte();
			let tmp6 = this.i.readByte();
			let tmp7 = this.i.readByte();
			let buffer = new haxe_io_BytesOutput();
			let bytes = new haxe_io_Bytes(new ArrayBuffer(255));
			let len = this.i.readByte();
			while(len != 0) {
				this.i.readBytes(bytes,0,len);
				buffer.writeBytes(bytes,0,len);
				len = this.i.readByte();
			}
			buffer.flush();
			bytes = buffer.getBytes();
			buffer.close();
			return format_gif_Block.BExtension(format_gif_Extension.EText({ textGridX : tmp, textGridY : tmp1, textGridWidth : tmp2, textGridHeight : tmp3, charCellWidth : tmp4, charCellHeight : tmp5, textForegroundColorIndex : tmp6, textBackgroundColorIndex : tmp7, text : bytes.toString()}));
		case 249:
			if(this.i.readByte() != 4) {
				throw haxe_Exception.thrown("Incorrect Graphic Control Extension block size!");
			}
			let packed = this.i.readByte();
			let disposalMethod;
			switch((packed & 28) >> 2) {
			case 0:
				disposalMethod = format_gif_DisposalMethod.UNSPECIFIED;
				break;
			case 1:
				disposalMethod = format_gif_DisposalMethod.NO_ACTION;
				break;
			case 2:
				disposalMethod = format_gif_DisposalMethod.FILL_BACKGROUND;
				break;
			case 3:
				disposalMethod = format_gif_DisposalMethod.RENDER_PREVIOUS;
				break;
			default:
				disposalMethod = format_gif_DisposalMethod.UNDEFINED((packed & 28) >> 2);
			}
			let b = format_gif_Block.BExtension(format_gif_Extension.EGraphicControl({ disposalMethod : disposalMethod, userInput : (packed & 2) == 2, hasTransparentColor : (packed & 1) == 1, delay : this.i.readUInt16(), transparentIndex : this.i.readByte()}));
			this.i.readByte();
			return b;
		case 254:
			let buffer1 = new haxe_io_BytesOutput();
			let bytes1 = new haxe_io_Bytes(new ArrayBuffer(255));
			let len1 = this.i.readByte();
			while(len1 != 0) {
				this.i.readBytes(bytes1,0,len1);
				buffer1.writeBytes(bytes1,0,len1);
				len1 = this.i.readByte();
			}
			buffer1.flush();
			bytes1 = buffer1.getBytes();
			buffer1.close();
			return format_gif_Block.BExtension(format_gif_Extension.EComment(bytes1.toString()));
		case 255:
			return this.readApplicationExtension();
		default:
			let buffer2 = new haxe_io_BytesOutput();
			let bytes2 = new haxe_io_Bytes(new ArrayBuffer(255));
			let len2 = this.i.readByte();
			while(len2 != 0) {
				this.i.readBytes(bytes2,0,len2);
				buffer2.writeBytes(bytes2,0,len2);
				len2 = this.i.readByte();
			}
			buffer2.flush();
			bytes2 = buffer2.getBytes();
			buffer2.close();
			return format_gif_Block.BExtension(format_gif_Extension.EUnknown(subId,bytes2));
		}
	}
	readApplicationExtension() {
		if(this.i.readByte() != 11) {
			throw haxe_Exception.thrown("Incorrect size of Application Extension introducer block.");
		}
		let name = this.i.readString(8);
		let version = this.i.readString(3);
		let buffer = new haxe_io_BytesOutput();
		let bytes = new haxe_io_Bytes(new ArrayBuffer(255));
		let len = this.i.readByte();
		while(len != 0) {
			this.i.readBytes(bytes,0,len);
			buffer.writeBytes(bytes,0,len);
			len = this.i.readByte();
		}
		buffer.flush();
		bytes = buffer.getBytes();
		buffer.close();
		let data = bytes;
		if(name == "NETSCAPE" && version == "2.0" && data.b[0] == 1) {
			return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AENetscapeLooping(data.b[1] | data.b[2] << 8)));
		}
		return format_gif_Block.BExtension(format_gif_Extension.EApplicationExtension(format_gif_ApplicationExtension.AEUnknown(name,version,data)));
	}
	readColorTable(size) {
		size *= 3;
		let output = new haxe_io_Bytes(new ArrayBuffer(size));
		let c = 0;
		while(c < size) {
			let v = this.i.readByte();
			output.b[c] = v;
			let v1 = this.i.readByte();
			output.b[c + 1] = v1;
			let v2 = this.i.readByte();
			output.b[c + 2] = v2;
			c += 3;
		}
		return output;
	}
}
$hxClasses["format.gif.Reader"] = format_gif_Reader;
format_gif_Reader.__name__ = "format.gif.Reader";
Object.assign(format_gif_Reader.prototype, {
	__class__: format_gif_Reader
	,i: null
});
class format_gif_Tools {
	static extractFullBGRA(data,frameIndex) {
		let gce = null;
		let frameCaret = 0;
		let bytes = new haxe_io_Bytes(new ArrayBuffer(data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height * 4));
		let _g_head = data.blocks.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			switch(val._hx_index) {
			case 0:
				let _g = val.frame;
				let ct = _g.localColorTable ? _g.colorTable : data.globalColorTable;
				if(ct == null) {
					throw haxe_Exception.thrown("Frame does not have a color table!");
				}
				let transparentIndex = gce != null && gce.hasTransparentColor ? gce.transparentIndex * 3 : -1;
				let pixels = _g.pixels;
				let x = 0;
				let writeCaret = (_g.y * data.logicalScreenDescriptor.width + _g.x) * 4;
				let lineSkip = (data.logicalScreenDescriptor.width - _g.width) * 4 + 4;
				let disposalMethod = frameCaret != frameIndex && gce != null ? gce.disposalMethod : format_gif_DisposalMethod.NO_ACTION;
				switch(disposalMethod._hx_index) {
				case 2:
					let _g1 = 0;
					let _g2 = pixels.length;
					while(_g1 < _g2) {
						++_g1;
						bytes.b[writeCaret] = 0;
						bytes.b[writeCaret + 1] = 0;
						bytes.b[writeCaret + 2] = 0;
						bytes.b[writeCaret + 3] = 0;
						if(++x == _g.width) {
							x = 0;
							writeCaret += lineSkip;
						} else {
							writeCaret += 4;
						}
					}
					break;
				case 3:
					break;
				default:
					let _g3 = 0;
					let _g4 = pixels.length;
					while(_g3 < _g4) {
						let i = _g3++;
						let index = pixels.b[i] * 3;
						if(transparentIndex != index) {
							bytes.b[writeCaret] = ct.b[index + 2];
							bytes.b[writeCaret + 1] = ct.b[index + 1];
							bytes.b[writeCaret + 2] = ct.b[index];
							bytes.b[writeCaret + 3] = 255;
						}
						if(++x == _g.width) {
							x = 0;
							writeCaret += lineSkip;
						} else {
							writeCaret += 4;
						}
					}
				}
				if(frameCaret == frameIndex) {
					return bytes;
				}
				++frameCaret;
				gce = null;
				break;
			case 1:
				let _g5 = val.extension;
				if(_g5._hx_index == 0) {
					gce = _g5.gce;
				}
				break;
			default:
			}
		}
		return bytes;
	}
	static extractFullRGBA(data,frameIndex) {
		let gce = null;
		let frameCaret = 0;
		let bytes = new haxe_io_Bytes(new ArrayBuffer(data.logicalScreenDescriptor.width * data.logicalScreenDescriptor.height * 4));
		let _g_head = data.blocks.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			switch(val._hx_index) {
			case 0:
				let _g = val.frame;
				let ct = _g.localColorTable ? _g.colorTable : data.globalColorTable;
				if(ct == null) {
					throw haxe_Exception.thrown("Frame does not have a color table!");
				}
				let transparentIndex = gce != null && gce.hasTransparentColor ? gce.transparentIndex * 3 : -1;
				let pixels = _g.pixels;
				let x = 0;
				let writeCaret = (_g.y * data.logicalScreenDescriptor.width + _g.x) * 4;
				let lineSkip = (data.logicalScreenDescriptor.width - _g.width) * 4 + 4;
				let disposalMethod = frameCaret != frameIndex && gce != null ? gce.disposalMethod : format_gif_DisposalMethod.NO_ACTION;
				switch(disposalMethod._hx_index) {
				case 2:
					let _g1 = 0;
					let _g2 = pixels.length;
					while(_g1 < _g2) {
						++_g1;
						bytes.b[writeCaret] = 0;
						bytes.b[writeCaret + 1] = 0;
						bytes.b[writeCaret + 2] = 0;
						bytes.b[writeCaret + 3] = 0;
						if(++x == _g.width) {
							x = 0;
							writeCaret += lineSkip;
						} else {
							writeCaret += 4;
						}
					}
					break;
				case 3:
					break;
				default:
					let _g3 = 0;
					let _g4 = pixels.length;
					while(_g3 < _g4) {
						let i = _g3++;
						let index = pixels.b[i] * 3;
						if(transparentIndex != index) {
							bytes.b[writeCaret] = ct.b[index];
							bytes.b[writeCaret + 1] = ct.b[index + 1];
							bytes.b[writeCaret + 2] = ct.b[index + 2];
							bytes.b[writeCaret + 3] = 255;
						}
						if(++x == _g.width) {
							x = 0;
							writeCaret += lineSkip;
						} else {
							writeCaret += 4;
						}
					}
				}
				if(frameCaret == frameIndex) {
					return bytes;
				}
				++frameCaret;
				gce = null;
				break;
			case 1:
				let _g5 = val.extension;
				if(_g5._hx_index == 0) {
					gce = _g5.gce;
				}
				break;
			default:
			}
		}
		return bytes;
	}
}
$hxClasses["format.gif.Tools"] = format_gif_Tools;
format_gif_Tools.__name__ = "format.gif.Tools";
var format_mp3_SamplingRate = $hxEnums["format.mp3.SamplingRate"] = { __ename__:true,__constructs__:null
	,SR_8000: {_hx_name:"SR_8000",_hx_index:0,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_11025: {_hx_name:"SR_11025",_hx_index:1,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_12000: {_hx_name:"SR_12000",_hx_index:2,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_22050: {_hx_name:"SR_22050",_hx_index:3,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_24000: {_hx_name:"SR_24000",_hx_index:4,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_32000: {_hx_name:"SR_32000",_hx_index:5,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_44100: {_hx_name:"SR_44100",_hx_index:6,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_48000: {_hx_name:"SR_48000",_hx_index:7,__enum__:"format.mp3.SamplingRate",toString:$estr}
	,SR_Bad: {_hx_name:"SR_Bad",_hx_index:8,__enum__:"format.mp3.SamplingRate",toString:$estr}
};
format_mp3_SamplingRate.__constructs__ = [format_mp3_SamplingRate.SR_8000,format_mp3_SamplingRate.SR_11025,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_22050,format_mp3_SamplingRate.SR_24000,format_mp3_SamplingRate.SR_32000,format_mp3_SamplingRate.SR_44100,format_mp3_SamplingRate.SR_48000,format_mp3_SamplingRate.SR_Bad];
format_mp3_SamplingRate.__empty_constructs__ = [format_mp3_SamplingRate.SR_8000,format_mp3_SamplingRate.SR_11025,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_22050,format_mp3_SamplingRate.SR_24000,format_mp3_SamplingRate.SR_32000,format_mp3_SamplingRate.SR_44100,format_mp3_SamplingRate.SR_48000,format_mp3_SamplingRate.SR_Bad];
var format_mp3_Bitrate = $hxEnums["format.mp3.Bitrate"] = { __ename__:true,__constructs__:null
	,BR_8: {_hx_name:"BR_8",_hx_index:0,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_16: {_hx_name:"BR_16",_hx_index:1,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_24: {_hx_name:"BR_24",_hx_index:2,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_32: {_hx_name:"BR_32",_hx_index:3,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_40: {_hx_name:"BR_40",_hx_index:4,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_48: {_hx_name:"BR_48",_hx_index:5,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_56: {_hx_name:"BR_56",_hx_index:6,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_64: {_hx_name:"BR_64",_hx_index:7,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_80: {_hx_name:"BR_80",_hx_index:8,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_96: {_hx_name:"BR_96",_hx_index:9,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_112: {_hx_name:"BR_112",_hx_index:10,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_128: {_hx_name:"BR_128",_hx_index:11,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_144: {_hx_name:"BR_144",_hx_index:12,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_160: {_hx_name:"BR_160",_hx_index:13,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_176: {_hx_name:"BR_176",_hx_index:14,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_192: {_hx_name:"BR_192",_hx_index:15,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_224: {_hx_name:"BR_224",_hx_index:16,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_256: {_hx_name:"BR_256",_hx_index:17,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_288: {_hx_name:"BR_288",_hx_index:18,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_320: {_hx_name:"BR_320",_hx_index:19,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_352: {_hx_name:"BR_352",_hx_index:20,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_384: {_hx_name:"BR_384",_hx_index:21,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_416: {_hx_name:"BR_416",_hx_index:22,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_448: {_hx_name:"BR_448",_hx_index:23,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_Free: {_hx_name:"BR_Free",_hx_index:24,__enum__:"format.mp3.Bitrate",toString:$estr}
	,BR_Bad: {_hx_name:"BR_Bad",_hx_index:25,__enum__:"format.mp3.Bitrate",toString:$estr}
};
format_mp3_Bitrate.__constructs__ = [format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_176,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_288,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_352,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_416,format_mp3_Bitrate.BR_448,format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_Bad];
format_mp3_Bitrate.__empty_constructs__ = [format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_176,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_288,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_352,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_416,format_mp3_Bitrate.BR_448,format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_Bad];
class format_mp3_MPEG {
	static enum2Num(m) {
		switch(m._hx_index) {
		case 0:
			return 3;
		case 1:
			return 2;
		case 2:
			return 0;
		case 3:
			return format_mp3_MPEG.Reserved;
		}
	}
	static num2Enum(m) {
		switch(m) {
		case 0:
			return format_mp3_MPEGVersion.MPEG_V25;
		case 2:
			return format_mp3_MPEGVersion.MPEG_V2;
		case 3:
			return format_mp3_MPEGVersion.MPEG_V1;
		default:
			return format_mp3_MPEGVersion.MPEG_Reserved;
		}
	}
	static srEnum2Num(sr) {
		switch(sr._hx_index) {
		case 0:
			return 8000;
		case 1:
			return 11025;
		case 2:
			return 12000;
		case 3:
			return 22050;
		case 4:
			return 24000;
		case 5:
			return 32000;
		case 6:
			return 44100;
		case 7:
			return 48000;
		case 8:
			return -1;
		}
	}
	static bitrateEnum2Num(br) {
		switch(br._hx_index) {
		case 0:
			return 8;
		case 1:
			return 16;
		case 2:
			return 24;
		case 3:
			return 32;
		case 4:
			return 40;
		case 5:
			return 48;
		case 6:
			return 56;
		case 7:
			return 64;
		case 8:
			return 80;
		case 9:
			return 96;
		case 10:
			return 112;
		case 11:
			return 128;
		case 12:
			return 144;
		case 13:
			return 160;
		case 14:
			return 176;
		case 15:
			return 192;
		case 16:
			return 224;
		case 17:
			return 256;
		case 18:
			return 288;
		case 19:
			return 320;
		case 20:
			return 352;
		case 21:
			return 384;
		case 22:
			return 416;
		case 23:
			return 448;
		case 24:
			return 0;
		case 25:
			return -1;
		}
	}
}
$hxClasses["format.mp3.MPEG"] = format_mp3_MPEG;
format_mp3_MPEG.__name__ = "format.mp3.MPEG";
class format_mp3_CLayer {
	static num2Enum(l) {
		switch(l) {
		case 1:
			return format_mp3_Layer.Layer3;
		case 2:
			return format_mp3_Layer.Layer2;
		case 3:
			return format_mp3_Layer.Layer1;
		default:
			return format_mp3_Layer.LayerReserved;
		}
	}
}
$hxClasses["format.mp3.CLayer"] = format_mp3_CLayer;
format_mp3_CLayer.__name__ = "format.mp3.CLayer";
class format_mp3_CChannelMode {
	static num2Enum(c) {
		switch(c) {
		case 0:
			return format_mp3_ChannelMode.Stereo;
		case 1:
			return format_mp3_ChannelMode.JointStereo;
		case 2:
			return format_mp3_ChannelMode.DualChannel;
		case 3:
			return format_mp3_ChannelMode.Mono;
		default:
			throw haxe_Exception.thrown("assert");
		}
	}
}
$hxClasses["format.mp3.CChannelMode"] = format_mp3_CChannelMode;
format_mp3_CChannelMode.__name__ = "format.mp3.CChannelMode";
class format_mp3_CEmphasis {
	static num2Enum(c) {
		switch(c) {
		case 0:
			return format_mp3_Emphasis.NoEmphasis;
		case 1:
			return format_mp3_Emphasis.Ms50_15;
		case 2:
			return format_mp3_Emphasis.InvalidEmphasis;
		case 3:
			return format_mp3_Emphasis.CCIT_J17;
		default:
			throw haxe_Exception.thrown("assert");
		}
	}
}
$hxClasses["format.mp3.CEmphasis"] = format_mp3_CEmphasis;
format_mp3_CEmphasis.__name__ = "format.mp3.CEmphasis";
var format_mp3_MPEGVersion = $hxEnums["format.mp3.MPEGVersion"] = { __ename__:true,__constructs__:null
	,MPEG_V1: {_hx_name:"MPEG_V1",_hx_index:0,__enum__:"format.mp3.MPEGVersion",toString:$estr}
	,MPEG_V2: {_hx_name:"MPEG_V2",_hx_index:1,__enum__:"format.mp3.MPEGVersion",toString:$estr}
	,MPEG_V25: {_hx_name:"MPEG_V25",_hx_index:2,__enum__:"format.mp3.MPEGVersion",toString:$estr}
	,MPEG_Reserved: {_hx_name:"MPEG_Reserved",_hx_index:3,__enum__:"format.mp3.MPEGVersion",toString:$estr}
};
format_mp3_MPEGVersion.__constructs__ = [format_mp3_MPEGVersion.MPEG_V1,format_mp3_MPEGVersion.MPEG_V2,format_mp3_MPEGVersion.MPEG_V25,format_mp3_MPEGVersion.MPEG_Reserved];
format_mp3_MPEGVersion.__empty_constructs__ = [format_mp3_MPEGVersion.MPEG_V1,format_mp3_MPEGVersion.MPEG_V2,format_mp3_MPEGVersion.MPEG_V25,format_mp3_MPEGVersion.MPEG_Reserved];
var format_mp3_Layer = $hxEnums["format.mp3.Layer"] = { __ename__:true,__constructs__:null
	,LayerReserved: {_hx_name:"LayerReserved",_hx_index:0,__enum__:"format.mp3.Layer",toString:$estr}
	,Layer3: {_hx_name:"Layer3",_hx_index:1,__enum__:"format.mp3.Layer",toString:$estr}
	,Layer2: {_hx_name:"Layer2",_hx_index:2,__enum__:"format.mp3.Layer",toString:$estr}
	,Layer1: {_hx_name:"Layer1",_hx_index:3,__enum__:"format.mp3.Layer",toString:$estr}
};
format_mp3_Layer.__constructs__ = [format_mp3_Layer.LayerReserved,format_mp3_Layer.Layer3,format_mp3_Layer.Layer2,format_mp3_Layer.Layer1];
format_mp3_Layer.__empty_constructs__ = [format_mp3_Layer.LayerReserved,format_mp3_Layer.Layer3,format_mp3_Layer.Layer2,format_mp3_Layer.Layer1];
var format_mp3_ChannelMode = $hxEnums["format.mp3.ChannelMode"] = { __ename__:true,__constructs__:null
	,Stereo: {_hx_name:"Stereo",_hx_index:0,__enum__:"format.mp3.ChannelMode",toString:$estr}
	,JointStereo: {_hx_name:"JointStereo",_hx_index:1,__enum__:"format.mp3.ChannelMode",toString:$estr}
	,DualChannel: {_hx_name:"DualChannel",_hx_index:2,__enum__:"format.mp3.ChannelMode",toString:$estr}
	,Mono: {_hx_name:"Mono",_hx_index:3,__enum__:"format.mp3.ChannelMode",toString:$estr}
};
format_mp3_ChannelMode.__constructs__ = [format_mp3_ChannelMode.Stereo,format_mp3_ChannelMode.JointStereo,format_mp3_ChannelMode.DualChannel,format_mp3_ChannelMode.Mono];
format_mp3_ChannelMode.__empty_constructs__ = [format_mp3_ChannelMode.Stereo,format_mp3_ChannelMode.JointStereo,format_mp3_ChannelMode.DualChannel,format_mp3_ChannelMode.Mono];
var format_mp3_Emphasis = $hxEnums["format.mp3.Emphasis"] = { __ename__:true,__constructs__:null
	,NoEmphasis: {_hx_name:"NoEmphasis",_hx_index:0,__enum__:"format.mp3.Emphasis",toString:$estr}
	,Ms50_15: {_hx_name:"Ms50_15",_hx_index:1,__enum__:"format.mp3.Emphasis",toString:$estr}
	,CCIT_J17: {_hx_name:"CCIT_J17",_hx_index:2,__enum__:"format.mp3.Emphasis",toString:$estr}
	,InvalidEmphasis: {_hx_name:"InvalidEmphasis",_hx_index:3,__enum__:"format.mp3.Emphasis",toString:$estr}
};
format_mp3_Emphasis.__constructs__ = [format_mp3_Emphasis.NoEmphasis,format_mp3_Emphasis.Ms50_15,format_mp3_Emphasis.CCIT_J17,format_mp3_Emphasis.InvalidEmphasis];
format_mp3_Emphasis.__empty_constructs__ = [format_mp3_Emphasis.NoEmphasis,format_mp3_Emphasis.Ms50_15,format_mp3_Emphasis.CCIT_J17,format_mp3_Emphasis.InvalidEmphasis];
var format_mp3_FrameType = $hxEnums["format.mp3.FrameType"] = { __ename__:true,__constructs__:null
	,FT_MP3: {_hx_name:"FT_MP3",_hx_index:0,__enum__:"format.mp3.FrameType",toString:$estr}
	,FT_NONE: {_hx_name:"FT_NONE",_hx_index:1,__enum__:"format.mp3.FrameType",toString:$estr}
};
format_mp3_FrameType.__constructs__ = [format_mp3_FrameType.FT_MP3,format_mp3_FrameType.FT_NONE];
format_mp3_FrameType.__empty_constructs__ = [format_mp3_FrameType.FT_MP3,format_mp3_FrameType.FT_NONE];
class format_mp3_Reader {
	constructor(i) {
		this.i = i;
		i.set_bigEndian(true);
		this.bits = new format_tools_BitsInput(i);
		this.samples = 0;
		this.sampleSize = 0;
		this.any_read = false;
	}
	skipID3v2() {
		this.id3v2_version = this.i.readUInt16();
		this.id3v2_flags = this.i.readByte();
		let size = this.i.readByte() & 127;
		size = size << 7 | this.i.readByte() & 127;
		size = size << 7 | this.i.readByte() & 127;
		size = size << 7 | this.i.readByte() & 127;
		this.id3v2_data = this.i.read(size);
	}
	seekFrame() {
		try {
			let b;
			while(true) {
				b = this.i.readByte();
				if(!this.any_read) {
					this.any_read = true;
					if(b == 73) {
						b = this.i.readByte();
						if(b == 68) {
							b = this.i.readByte();
							if(b == 51) {
								this.skipID3v2();
							}
						}
					}
				}
				if(b == 255) {
					this.bits.nbits = 0;
					b = this.bits.readBits(3);
					if(b == 7) {
						return format_mp3_FrameType.FT_MP3;
					}
				}
			}
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				return format_mp3_FrameType.FT_NONE;
			} else {
				throw _g;
			}
		}
	}
	readFrames() {
		let frames = [];
		let ft;
		while(true) {
			ft = this.seekFrame();
			if(!(ft != format_mp3_FrameType.FT_NONE)) {
				break;
			}
			switch(ft._hx_index) {
			case 0:
				let f = this.readFrame();
				if(f != null) {
					frames.push(f);
				}
				break;
			case 1:
				break;
			}
		}
		return frames;
	}
	readFrameHeader() {
		let version = this.bits.readBits(2);
		let layer = this.bits.readBits(2);
		let hasCrc = !this.bits.readBit();
		if(version == format_mp3_MPEG.Reserved || layer == format_mp3_CLayer.LReserved) {
			return null;
		}
		let bitrateIdx = this.bits.readBits(4);
		let bitrate = format_mp3_Tools.getBitrate(version,layer,bitrateIdx);
		let samplingRateIdx = this.bits.readBits(2);
		let samplingRate = format_mp3_Tools.getSamplingRate(version,samplingRateIdx);
		let isPadded = this.bits.readBit();
		let privateBit = this.bits.readBit();
		if(bitrate == format_mp3_Bitrate.BR_Bad || bitrate == format_mp3_Bitrate.BR_Free || samplingRate == format_mp3_SamplingRate.SR_Bad) {
			return null;
		}
		let channelMode = this.bits.readBits(2);
		let isIntensityStereo = this.bits.readBit();
		let isMSStereo = this.bits.readBit();
		let isCopyrighted = this.bits.readBit();
		let isOriginal = this.bits.readBit();
		let emphasis = this.bits.readBits(2);
		let crc16 = 0;
		if(hasCrc) {
			crc16 = this.i.readUInt16();
		}
		return { version : format_mp3_MPEG.num2Enum(version), layer : format_mp3_CLayer.num2Enum(layer), hasCrc : hasCrc, crc16 : crc16, bitrate : bitrate, samplingRate : samplingRate, isPadded : isPadded, privateBit : privateBit, channelMode : format_mp3_CChannelMode.num2Enum(channelMode), isIntensityStereo : isIntensityStereo, isMSStereo : isMSStereo, isCopyrighted : isCopyrighted, isOriginal : isOriginal, emphasis : format_mp3_CEmphasis.num2Enum(emphasis)};
	}
	readFrame() {
		let header = this.readFrameHeader();
		if(header == null || format_mp3_Tools.isInvalidFrameHeader(header)) {
			return null;
		}
		try {
			let data = this.i.read(format_mp3_Tools.getSampleDataSizeHdr(header));
			this.samples += format_mp3_Tools.getSampleCountHdr(header);
			this.sampleSize += data.length;
			return { header : header, data : data};
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				return null;
			} else {
				throw _g;
			}
		}
	}
	read() {
		let fs = this.readFrames();
		return { frames : fs, sampleCount : this.samples, sampleSize : this.sampleSize, id3v2 : this.id3v2_data == null ? null : { versionBytes : this.id3v2_version, flagByte : this.id3v2_flags, data : this.id3v2_data}};
	}
}
$hxClasses["format.mp3.Reader"] = format_mp3_Reader;
format_mp3_Reader.__name__ = "format.mp3.Reader";
Object.assign(format_mp3_Reader.prototype, {
	__class__: format_mp3_Reader
	,i: null
	,bits: null
	,samples: null
	,sampleSize: null
	,any_read: null
	,id3v2_data: null
	,id3v2_version: null
	,id3v2_flags: null
});
class format_mp3_Tools {
	static getBitrate(mpegVersion,layerIdx,bitrateIdx) {
		if(mpegVersion == format_mp3_MPEG.Reserved || layerIdx == format_mp3_CLayer.LReserved) {
			return format_mp3_Bitrate.BR_Bad;
		}
		return (mpegVersion == 3 ? format_mp3_MPEG.V1_Bitrates : format_mp3_MPEG.V2_Bitrates)[layerIdx][bitrateIdx];
	}
	static getSamplingRate(mpegVersion,samplingRateIdx) {
		return format_mp3_MPEG.SamplingRates[mpegVersion][samplingRateIdx];
	}
	static isInvalidFrameHeader(hdr) {
		if(!(hdr.version == format_mp3_MPEGVersion.MPEG_Reserved || hdr.layer == format_mp3_Layer.LayerReserved || hdr.bitrate == format_mp3_Bitrate.BR_Bad || hdr.bitrate == format_mp3_Bitrate.BR_Free)) {
			return hdr.samplingRate == format_mp3_SamplingRate.SR_Bad;
		} else {
			return true;
		}
	}
	static getSampleDataSize(mpegVersion,bitrate,samplingRate,isPadded,hasCrc) {
		return ((mpegVersion == 3 ? 144 : 72) * bitrate * 1000 / samplingRate | 0) + (isPadded ? 1 : 0) - (hasCrc ? 2 : 0) - 4;
	}
	static getSampleDataSizeHdr(hdr) {
		return format_mp3_Tools.getSampleDataSize(format_mp3_MPEG.enum2Num(hdr.version),format_mp3_MPEG.bitrateEnum2Num(hdr.bitrate),format_mp3_MPEG.srEnum2Num(hdr.samplingRate),hdr.isPadded,hdr.hasCrc);
	}
	static getSampleCount(mpegVersion) {
		if(mpegVersion == 3) {
			return 1152;
		} else {
			return 576;
		}
	}
	static getSampleCountHdr(hdr) {
		return format_mp3_Tools.getSampleCount(format_mp3_MPEG.enum2Num(hdr.version));
	}
}
$hxClasses["format.mp3.Tools"] = format_mp3_Tools;
format_mp3_Tools.__name__ = "format.mp3.Tools";
var format_png_Color = $hxEnums["format.png.Color"] = { __ename__:true,__constructs__:null
	,ColGrey: ($_=function(alpha) { return {_hx_index:0,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_._hx_name="ColGrey",$_.__params__ = ["alpha"],$_)
	,ColTrue: ($_=function(alpha) { return {_hx_index:1,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_._hx_name="ColTrue",$_.__params__ = ["alpha"],$_)
	,ColIndexed: {_hx_name:"ColIndexed",_hx_index:2,__enum__:"format.png.Color",toString:$estr}
};
format_png_Color.__constructs__ = [format_png_Color.ColGrey,format_png_Color.ColTrue,format_png_Color.ColIndexed];
format_png_Color.__empty_constructs__ = [format_png_Color.ColIndexed];
var format_png_Chunk = $hxEnums["format.png.Chunk"] = { __ename__:true,__constructs__:null
	,CEnd: {_hx_name:"CEnd",_hx_index:0,__enum__:"format.png.Chunk",toString:$estr}
	,CHeader: ($_=function(h) { return {_hx_index:1,h:h,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CHeader",$_.__params__ = ["h"],$_)
	,CData: ($_=function(b) { return {_hx_index:2,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CData",$_.__params__ = ["b"],$_)
	,CPalette: ($_=function(b) { return {_hx_index:3,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CPalette",$_.__params__ = ["b"],$_)
	,CUnknown: ($_=function(id,data) { return {_hx_index:4,id:id,data:data,__enum__:"format.png.Chunk",toString:$estr}; },$_._hx_name="CUnknown",$_.__params__ = ["id","data"],$_)
};
format_png_Chunk.__constructs__ = [format_png_Chunk.CEnd,format_png_Chunk.CHeader,format_png_Chunk.CData,format_png_Chunk.CPalette,format_png_Chunk.CUnknown];
format_png_Chunk.__empty_constructs__ = [format_png_Chunk.CEnd];
class format_png_Reader {
	constructor(i) {
		this.i = i;
		i.set_bigEndian(true);
		this.checkCRC = true;
	}
	read() {
		if(this.i.readByte() != 137) {
			throw haxe_Exception.thrown("Invalid header");
		}
		if(this.i.readByte() != 80) {
			throw haxe_Exception.thrown("Invalid header");
		}
		if(this.i.readByte() != 78) {
			throw haxe_Exception.thrown("Invalid header");
		}
		if(this.i.readByte() != 71) {
			throw haxe_Exception.thrown("Invalid header");
		}
		if(this.i.readByte() != 13) {
			throw haxe_Exception.thrown("Invalid header");
		}
		if(this.i.readByte() != 10) {
			throw haxe_Exception.thrown("Invalid header");
		}
		if(this.i.readByte() != 26) {
			throw haxe_Exception.thrown("Invalid header");
		}
		if(this.i.readByte() != 10) {
			throw haxe_Exception.thrown("Invalid header");
		}
		let l = new haxe_ds_List();
		while(true) {
			let c = this.readChunk();
			l.add(c);
			if(c == format_png_Chunk.CEnd) {
				break;
			}
		}
		return l;
	}
	readHeader(i) {
		i.set_bigEndian(true);
		let width = i.readInt32();
		let height = i.readInt32();
		let colbits = i.readByte();
		let color = i.readByte();
		let color1;
		switch(color) {
		case 0:
			color1 = format_png_Color.ColGrey(false);
			break;
		case 2:
			color1 = format_png_Color.ColTrue(false);
			break;
		case 3:
			color1 = format_png_Color.ColIndexed;
			break;
		case 4:
			color1 = format_png_Color.ColGrey(true);
			break;
		case 6:
			color1 = format_png_Color.ColTrue(true);
			break;
		default:
			throw haxe_Exception.thrown("Unknown color model " + color + ":" + colbits);
		}
		let compress = i.readByte();
		let filter = i.readByte();
		if(compress != 0 || filter != 0) {
			throw haxe_Exception.thrown("Invalid header");
		}
		let interlace = i.readByte();
		if(interlace != 0 && interlace != 1) {
			throw haxe_Exception.thrown("Invalid header");
		}
		return { width : width, height : height, colbits : colbits, color : color1, interlaced : interlace == 1};
	}
	readChunk() {
		let dataLen = this.i.readInt32();
		let id = this.i.readString(4);
		let data = this.i.read(dataLen);
		let crc = this.i.readInt32();
		if(this.checkCRC) {
			let c_crc = -1;
			let tmp = (-1 ^ HxOverrides.cca(id,0)) & 255;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
			c_crc = 16777215 ^ tmp;
			let tmp1 = (c_crc ^ HxOverrides.cca(id,1)) & 255;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			tmp1 = tmp1 >>> 1 ^ -(tmp1 & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp1;
			let tmp2 = (c_crc ^ HxOverrides.cca(id,2)) & 255;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			tmp2 = tmp2 >>> 1 ^ -(tmp2 & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp2;
			let tmp3 = (c_crc ^ HxOverrides.cca(id,3)) & 255;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			tmp3 = tmp3 >>> 1 ^ -(tmp3 & 1) & -306674912;
			c_crc = c_crc >>> 8 ^ tmp3;
			let len = data.length;
			let b = data.b.bufferValue;
			let _g = 0;
			while(_g < len) {
				let i = _g++;
				let tmp = (c_crc ^ b.bytes[i]) & 255;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				tmp = tmp >>> 1 ^ -(tmp & 1) & -306674912;
				c_crc = c_crc >>> 8 ^ tmp;
			}
			if((c_crc ^ -1) != crc) {
				throw haxe_Exception.thrown("CRC check failure");
			}
		}
		switch(id) {
		case "IDAT":
			return format_png_Chunk.CData(data);
		case "IEND":
			return format_png_Chunk.CEnd;
		case "IHDR":
			return format_png_Chunk.CHeader(this.readHeader(new haxe_io_BytesInput(data)));
		case "PLTE":
			return format_png_Chunk.CPalette(data);
		default:
			return format_png_Chunk.CUnknown(id,data);
		}
	}
}
$hxClasses["format.png.Reader"] = format_png_Reader;
format_png_Reader.__name__ = "format.png.Reader";
Object.assign(format_png_Reader.prototype, {
	__class__: format_png_Reader
	,i: null
	,checkCRC: null
});
class format_png_Tools {
	static getHeader(d) {
		let _g_head = d.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			if(val._hx_index == 1) {
				return val.h;
			}
		}
		throw haxe_Exception.thrown("Header not found");
	}
	static getPalette(d) {
		let _g_head = d.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			if(val._hx_index == 3) {
				return val.b;
			}
		}
		return null;
	}
	static extract32(d,bytes,flipY) {
		let h = format_png_Tools.getHeader(d);
		let bgra = bytes == null ? new haxe_io_Bytes(new ArrayBuffer(h.width * h.height * 4)) : bytes;
		let data = null;
		let fullData = null;
		let _g_head = d.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			if(val._hx_index == 2) {
				let _g = val.b;
				if(fullData != null) {
					fullData.add(_g);
				} else if(data == null) {
					data = _g;
				} else {
					fullData = new haxe_io_BytesBuffer();
					fullData.add(data);
					fullData.add(_g);
					data = null;
				}
			}
		}
		if(fullData != null) {
			data = fullData.getBytes();
		}
		if(data == null) {
			throw haxe_Exception.thrown("Data not found");
		}
		data = format_tools_Inflate.run(data);
		let r = 0;
		let w = 0;
		let lineDelta = 0;
		if(flipY) {
			lineDelta = -h.width * 8;
			w = (h.height - 1) * (h.width * 4);
		}
		let flipY1 = flipY ? -1 : 1;
		let _g = h.color;
		switch(_g._hx_index) {
		case 0:
			let _g1 = _g.alpha;
			if(h.colbits != 8) {
				throw haxe_Exception.thrown("Unsupported color mode");
			}
			let width = h.width;
			let stride = (_g1 ? 2 : 1) * width + 1;
			if(data.length < h.height * stride) {
				throw haxe_Exception.thrown("Not enough data");
			}
			let alphvaIdx = -1;
			if(!_g1) {
				let _g_head = d.h;
				while(_g_head != null) {
					let val = _g_head.item;
					_g_head = _g_head.next;
					if(val._hx_index == 4) {
						let _g = val.data;
						if(val.id == "tRNS") {
							if(_g.length >= 2) {
								alphvaIdx = _g.b[1];
							}
							break;
						}
					}
				}
			}
			let _g2 = 0;
			let _g3 = h.height;
			while(_g2 < _g3) {
				let y = _g2++;
				let f = data.b[r++];
				switch(f) {
				case 0:
					if(_g1) {
						let _g = 0;
						while(_g < width) {
							++_g;
							let v = data.b[r++];
							bgra.b[w++] = v;
							bgra.b[w++] = v;
							bgra.b[w++] = v;
							bgra.b[w++] = data.b[r++];
						}
					} else {
						let _g = 0;
						while(_g < width) {
							++_g;
							let v = data.b[r++];
							bgra.b[w++] = v;
							bgra.b[w++] = v;
							bgra.b[w++] = v;
							bgra.b[w++] = v == alphvaIdx ? 0 : 255;
						}
					}
					break;
				case 1:
					let cv = 0;
					let ca = 0;
					if(_g1) {
						let _g = 0;
						while(_g < width) {
							++_g;
							cv += data.b[r++];
							bgra.b[w++] = cv;
							bgra.b[w++] = cv;
							bgra.b[w++] = cv;
							ca += data.b[r++];
							bgra.b[w++] = ca;
						}
					} else {
						let _g = 0;
						while(_g < width) {
							++_g;
							cv += data.b[r++];
							bgra.b[w++] = cv;
							bgra.b[w++] = cv;
							bgra.b[w++] = cv;
							bgra.b[w++] = cv == alphvaIdx ? 0 : 255;
						}
					}
					break;
				case 2:
					let stride = y == 0 ? 0 : width * 4 * flipY1;
					if(_g1) {
						let _g = 0;
						while(_g < width) {
							++_g;
							let v = data.b[r++] + bgra.b[w - stride];
							bgra.b[w++] = v;
							bgra.b[w++] = v;
							bgra.b[w++] = v;
							let va = data.b[r++] + bgra.b[w - stride];
							bgra.b[w++] = va;
						}
					} else {
						let _g = 0;
						while(_g < width) {
							++_g;
							let v = data.b[r++] + bgra.b[w - stride];
							bgra.b[w++] = v;
							bgra.b[w++] = v;
							bgra.b[w++] = v;
							bgra.b[w++] = v == alphvaIdx ? 0 : 255;
						}
					}
					break;
				case 3:
					let cv1 = 0;
					let ca1 = 0;
					let stride1 = y == 0 ? 0 : width * 4 * flipY1;
					if(_g1) {
						let _g = 0;
						while(_g < width) {
							++_g;
							cv1 = data.b[r++] + (cv1 + bgra.b[w - stride1] >> 1) & 255;
							bgra.b[w++] = cv1;
							bgra.b[w++] = cv1;
							bgra.b[w++] = cv1;
							ca1 = data.b[r++] + (ca1 + bgra.b[w - stride1] >> 1) & 255;
							bgra.b[w++] = ca1;
						}
					} else {
						let _g = 0;
						while(_g < width) {
							++_g;
							cv1 = data.b[r++] + (cv1 + bgra.b[w - stride1] >> 1) & 255;
							bgra.b[w++] = cv1;
							bgra.b[w++] = cv1;
							bgra.b[w++] = cv1;
							bgra.b[w++] = cv1 == alphvaIdx ? 0 : 255;
						}
					}
					break;
				case 4:
					let stride2 = width * 4 * flipY1;
					let cv2 = 0;
					let ca2 = 0;
					if(_g1) {
						let _g = 0;
						while(_g < width) {
							let x = _g++;
							let b = y == 0 ? 0 : bgra.b[w - stride2];
							let c = x == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
							let k = cv2 + b - c;
							let pa = k - cv2;
							if(pa < 0) {
								pa = -pa;
							}
							let pb = k - b;
							if(pb < 0) {
								pb = -pb;
							}
							let pc = k - c;
							if(pc < 0) {
								pc = -pc;
							}
							let pos = r++;
							cv2 = (pa <= pb && pa <= pc ? cv2 : pb <= pc ? b : c) + data.b[pos] & 255;
							bgra.b[w++] = cv2;
							bgra.b[w++] = cv2;
							bgra.b[w++] = cv2;
							let b1 = y == 0 ? 0 : bgra.b[w - stride2];
							let c1 = x == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
							let k1 = ca2 + b1 - c1;
							let pa1 = k1 - ca2;
							if(pa1 < 0) {
								pa1 = -pa1;
							}
							let pb1 = k1 - b1;
							if(pb1 < 0) {
								pb1 = -pb1;
							}
							let pc1 = k1 - c1;
							if(pc1 < 0) {
								pc1 = -pc1;
							}
							let pos1 = r++;
							ca2 = (pa1 <= pb1 && pa1 <= pc1 ? ca2 : pb1 <= pc1 ? b1 : c1) + data.b[pos1] & 255;
							bgra.b[w++] = ca2;
						}
					} else {
						let _g = 0;
						while(_g < width) {
							let x = _g++;
							let b = y == 0 ? 0 : bgra.b[w - stride2];
							let c = x == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
							let k = cv2 + b - c;
							let pa = k - cv2;
							if(pa < 0) {
								pa = -pa;
							}
							let pb = k - b;
							if(pb < 0) {
								pb = -pb;
							}
							let pc = k - c;
							if(pc < 0) {
								pc = -pc;
							}
							let pos = r++;
							cv2 = (pa <= pb && pa <= pc ? cv2 : pb <= pc ? b : c) + data.b[pos] & 255;
							bgra.b[w++] = cv2;
							bgra.b[w++] = cv2;
							bgra.b[w++] = cv2;
							bgra.b[w++] = cv2 == alphvaIdx ? 0 : 255;
						}
					}
					break;
				default:
					throw haxe_Exception.thrown("Invalid filter " + f);
				}
				w += lineDelta;
			}
			break;
		case 1:
			let _g4 = _g.alpha;
			if(h.colbits != 8) {
				throw haxe_Exception.thrown("Unsupported color mode");
			}
			let width1 = h.width;
			let stride1 = (_g4 ? 4 : 3) * width1 + 1;
			if(data.length < h.height * stride1) {
				throw haxe_Exception.thrown("Not enough data");
			}
			let alphaRed = -1;
			let alphaGreen = -1;
			let alphaBlue = -1;
			if(!_g4) {
				let _g_head = d.h;
				while(_g_head != null) {
					let val = _g_head.item;
					_g_head = _g_head.next;
					if(val._hx_index == 4) {
						let _g = val.data;
						if(val.id == "tRNS") {
							if(_g.length >= 6) {
								alphaRed = _g.b[1];
								alphaGreen = _g.b[3];
								alphaBlue = _g.b[5];
							}
							break;
						}
					}
				}
			}
			let cr = 0;
			let cg = 0;
			let cb = 0;
			let ca = 0;
			let _g5 = 0;
			let _g6 = h.height;
			while(_g5 < _g6) {
				let y = _g5++;
				let f = data.b[r++];
				switch(f) {
				case 0:
					if(_g4) {
						let _g = 0;
						while(_g < width1) {
							++_g;
							bgra.b[w++] = data.b[r + 2];
							bgra.b[w++] = data.b[r + 1];
							bgra.b[w++] = data.b[r];
							bgra.b[w++] = data.b[r + 3];
							r += 4;
						}
					} else {
						let _g = 0;
						while(_g < width1) {
							++_g;
							cb = data.b[r + 2];
							bgra.b[w++] = cb;
							cg = data.b[r + 1];
							bgra.b[w++] = cg;
							cr = data.b[r];
							bgra.b[w++] = cr;
							bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
							r += 3;
						}
					}
					break;
				case 1:
					ca = 0;
					cb = 0;
					cg = 0;
					cr = 0;
					if(_g4) {
						let _g = 0;
						while(_g < width1) {
							++_g;
							cb += data.b[r + 2];
							bgra.b[w++] = cb;
							cg += data.b[r + 1];
							bgra.b[w++] = cg;
							cr += data.b[r];
							bgra.b[w++] = cr;
							ca += data.b[r + 3];
							bgra.b[w++] = ca;
							r += 4;
						}
					} else {
						let _g = 0;
						while(_g < width1) {
							++_g;
							cb += data.b[r + 2];
							bgra.b[w++] = cb;
							cg += data.b[r + 1];
							bgra.b[w++] = cg;
							cr += data.b[r];
							bgra.b[w++] = cr;
							bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
							r += 3;
						}
					}
					break;
				case 2:
					let stride = y == 0 ? 0 : width1 * 4 * flipY1;
					if(_g4) {
						let _g = 0;
						while(_g < width1) {
							++_g;
							bgra.b[w] = data.b[r + 2] + bgra.b[w - stride];
							++w;
							bgra.b[w] = data.b[r + 1] + bgra.b[w - stride];
							++w;
							bgra.b[w] = data.b[r] + bgra.b[w - stride];
							++w;
							bgra.b[w] = data.b[r + 3] + bgra.b[w - stride];
							++w;
							r += 4;
						}
					} else {
						let _g = 0;
						while(_g < width1) {
							++_g;
							cb = data.b[r + 2] + bgra.b[w - stride];
							bgra.b[w] = cb;
							++w;
							cg = data.b[r + 1] + bgra.b[w - stride];
							bgra.b[w] = cg;
							++w;
							cr = data.b[r] + bgra.b[w - stride];
							bgra.b[w] = cr;
							++w;
							bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
							r += 3;
						}
					}
					break;
				case 3:
					ca = 0;
					cb = 0;
					cg = 0;
					cr = 0;
					let stride1 = y == 0 ? 0 : width1 * 4 * flipY1;
					if(_g4) {
						let _g = 0;
						while(_g < width1) {
							++_g;
							cb = data.b[r + 2] + (cb + bgra.b[w - stride1] >> 1) & 255;
							bgra.b[w++] = cb;
							cg = data.b[r + 1] + (cg + bgra.b[w - stride1] >> 1) & 255;
							bgra.b[w++] = cg;
							cr = data.b[r] + (cr + bgra.b[w - stride1] >> 1) & 255;
							bgra.b[w++] = cr;
							ca = data.b[r + 3] + (ca + bgra.b[w - stride1] >> 1) & 255;
							bgra.b[w++] = ca;
							r += 4;
						}
					} else {
						let _g = 0;
						while(_g < width1) {
							++_g;
							cb = data.b[r + 2] + (cb + bgra.b[w - stride1] >> 1) & 255;
							bgra.b[w++] = cb;
							cg = data.b[r + 1] + (cg + bgra.b[w - stride1] >> 1) & 255;
							bgra.b[w++] = cg;
							cr = data.b[r] + (cr + bgra.b[w - stride1] >> 1) & 255;
							bgra.b[w++] = cr;
							bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
							r += 3;
						}
					}
					break;
				case 4:
					let stride2 = width1 * 4 * flipY1;
					ca = 0;
					cb = 0;
					cg = 0;
					cr = 0;
					if(_g4) {
						let _g = 0;
						while(_g < width1) {
							let x = _g++;
							let b = y == 0 ? 0 : bgra.b[w - stride2];
							let c = x == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
							let k = cb + b - c;
							let pa = k - cb;
							if(pa < 0) {
								pa = -pa;
							}
							let pb = k - b;
							if(pb < 0) {
								pb = -pb;
							}
							let pc = k - c;
							if(pc < 0) {
								pc = -pc;
							}
							cb = (pa <= pb && pa <= pc ? cb : pb <= pc ? b : c) + data.b[r + 2] & 255;
							bgra.b[w++] = cb;
							let b1 = y == 0 ? 0 : bgra.b[w - stride2];
							let c1 = x == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
							let k1 = cg + b1 - c1;
							let pa1 = k1 - cg;
							if(pa1 < 0) {
								pa1 = -pa1;
							}
							let pb1 = k1 - b1;
							if(pb1 < 0) {
								pb1 = -pb1;
							}
							let pc1 = k1 - c1;
							if(pc1 < 0) {
								pc1 = -pc1;
							}
							cg = (pa1 <= pb1 && pa1 <= pc1 ? cg : pb1 <= pc1 ? b1 : c1) + data.b[r + 1] & 255;
							bgra.b[w++] = cg;
							let b2 = y == 0 ? 0 : bgra.b[w - stride2];
							let c2 = x == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
							let k2 = cr + b2 - c2;
							let pa2 = k2 - cr;
							if(pa2 < 0) {
								pa2 = -pa2;
							}
							let pb2 = k2 - b2;
							if(pb2 < 0) {
								pb2 = -pb2;
							}
							let pc2 = k2 - c2;
							if(pc2 < 0) {
								pc2 = -pc2;
							}
							cr = (pa2 <= pb2 && pa2 <= pc2 ? cr : pb2 <= pc2 ? b2 : c2) + data.b[r] & 255;
							bgra.b[w++] = cr;
							let b3 = y == 0 ? 0 : bgra.b[w - stride2];
							let c3 = x == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
							let k3 = ca + b3 - c3;
							let pa3 = k3 - ca;
							if(pa3 < 0) {
								pa3 = -pa3;
							}
							let pb3 = k3 - b3;
							if(pb3 < 0) {
								pb3 = -pb3;
							}
							let pc3 = k3 - c3;
							if(pc3 < 0) {
								pc3 = -pc3;
							}
							ca = (pa3 <= pb3 && pa3 <= pc3 ? ca : pb3 <= pc3 ? b3 : c3) + data.b[r + 3] & 255;
							bgra.b[w++] = ca;
							r += 4;
						}
					} else {
						let _g = 0;
						while(_g < width1) {
							let x = _g++;
							let b = y == 0 ? 0 : bgra.b[w - stride2];
							let c = x == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
							let k = cb + b - c;
							let pa = k - cb;
							if(pa < 0) {
								pa = -pa;
							}
							let pb = k - b;
							if(pb < 0) {
								pb = -pb;
							}
							let pc = k - c;
							if(pc < 0) {
								pc = -pc;
							}
							cb = (pa <= pb && pa <= pc ? cb : pb <= pc ? b : c) + data.b[r + 2] & 255;
							bgra.b[w++] = cb;
							let b1 = y == 0 ? 0 : bgra.b[w - stride2];
							let c1 = x == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
							let k1 = cg + b1 - c1;
							let pa1 = k1 - cg;
							if(pa1 < 0) {
								pa1 = -pa1;
							}
							let pb1 = k1 - b1;
							if(pb1 < 0) {
								pb1 = -pb1;
							}
							let pc1 = k1 - c1;
							if(pc1 < 0) {
								pc1 = -pc1;
							}
							cg = (pa1 <= pb1 && pa1 <= pc1 ? cg : pb1 <= pc1 ? b1 : c1) + data.b[r + 1] & 255;
							bgra.b[w++] = cg;
							let b2 = y == 0 ? 0 : bgra.b[w - stride2];
							let c2 = x == 0 || y == 0 ? 0 : bgra.b[w - stride2 - 4];
							let k2 = cr + b2 - c2;
							let pa2 = k2 - cr;
							if(pa2 < 0) {
								pa2 = -pa2;
							}
							let pb2 = k2 - b2;
							if(pb2 < 0) {
								pb2 = -pb2;
							}
							let pc2 = k2 - c2;
							if(pc2 < 0) {
								pc2 = -pc2;
							}
							cr = (pa2 <= pb2 && pa2 <= pc2 ? cr : pb2 <= pc2 ? b2 : c2) + data.b[r] & 255;
							bgra.b[w++] = cr;
							bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
							r += 3;
						}
					}
					break;
				default:
					throw haxe_Exception.thrown("Invalid filter " + f);
				}
				w += lineDelta;
			}
			break;
		case 2:
			let pal = format_png_Tools.getPalette(d);
			if(pal == null) {
				throw haxe_Exception.thrown("PNG Palette is missing");
			}
			let alpha = null;
			let _g_head1 = d.h;
			while(_g_head1 != null) {
				let val = _g_head1.item;
				_g_head1 = _g_head1.next;
				if(val._hx_index == 4) {
					if(val.id == "tRNS") {
						alpha = val.data;
						break;
					}
				}
			}
			if(alpha != null && alpha.length < 1 << h.colbits) {
				let alpha2 = new haxe_io_Bytes(new ArrayBuffer(1 << h.colbits));
				alpha2.blit(0,alpha,0,alpha.length);
				alpha2.fill(alpha.length,alpha2.length - alpha.length,255);
				alpha = alpha2;
			}
			let width2 = h.width;
			let stride2 = Math.ceil(width2 * h.colbits / 8) + 1;
			if(data.length < h.height * stride2) {
				throw haxe_Exception.thrown("Not enough data");
			}
			let rline = stride2 - 1;
			let _g7 = 0;
			let _g8 = h.height;
			while(_g7 < _g8) {
				let y = _g7++;
				let f = data.b[r++];
				if(f == 0) {
					r += rline;
					continue;
				}
				switch(f) {
				case 1:
					let c = 0;
					let _g = 0;
					while(_g < width2) {
						++_g;
						let v = data.b[r];
						c += v;
						data.b[r++] = c & 255;
					}
					break;
				case 2:
					let stride = y == 0 ? 0 : rline + 1;
					let _g1 = 0;
					while(_g1 < width2) {
						++_g1;
						let v = data.b[r];
						data.b[r] = v + data.b[r - stride];
						++r;
					}
					break;
				case 3:
					let c1 = 0;
					let stride1 = y == 0 ? 0 : rline + 1;
					let _g2 = 0;
					while(_g2 < width2) {
						++_g2;
						let v = data.b[r];
						c1 = v + (c1 + data.b[r - stride1] >> 1) & 255;
						data.b[r++] = c1;
					}
					break;
				case 4:
					let stride2 = rline + 1;
					let c2 = 0;
					let _g3 = 0;
					while(_g3 < width2) {
						let x = _g3++;
						let v = data.b[r];
						let b = y == 0 ? 0 : data.b[r - stride2];
						let c = x == 0 || y == 0 ? 0 : data.b[r - stride2 - 1];
						let k = c2 + b - c;
						let pa = k - c2;
						if(pa < 0) {
							pa = -pa;
						}
						let pb = k - b;
						if(pb < 0) {
							pb = -pb;
						}
						let pc = k - c;
						if(pc < 0) {
							pc = -pc;
						}
						c2 = (pa <= pb && pa <= pc ? c2 : pb <= pc ? b : c) + v & 255;
						data.b[r++] = c2;
					}
					break;
				default:
					throw haxe_Exception.thrown("Invalid filter " + f);
				}
			}
			let r1 = 0;
			if(h.colbits == 8) {
				let _g = 0;
				let _g1 = h.height;
				while(_g < _g1) {
					++_g;
					++r1;
					let _g1 = 0;
					let _g2 = h.width;
					while(_g1 < _g2) {
						++_g1;
						let c = data.b[r1++];
						bgra.b[w++] = pal.b[c * 3 + 2];
						bgra.b[w++] = pal.b[c * 3 + 1];
						bgra.b[w++] = pal.b[c * 3];
						bgra.b[w++] = alpha != null ? alpha.b[c] : 255;
					}
					w += lineDelta;
				}
			} else if(h.colbits < 8) {
				let req = h.colbits;
				let mask = (1 << req) - 1;
				let _g = 0;
				let _g1 = h.height;
				while(_g < _g1) {
					++_g;
					++r1;
					let bits = 0;
					let nbits = 0;
					let _g1 = 0;
					let _g2 = h.width;
					while(_g1 < _g2) {
						++_g1;
						if(nbits < req) {
							bits = bits << 8 | data.b[r1++];
							nbits += 8;
						}
						let c = bits >>> nbits - req & mask;
						nbits -= req;
						bgra.b[w++] = pal.b[c * 3 + 2];
						bgra.b[w++] = pal.b[c * 3 + 1];
						bgra.b[w++] = pal.b[c * 3];
						bgra.b[w++] = alpha != null ? alpha.b[c] : 255;
					}
					w += lineDelta;
				}
			} else {
				throw haxe_Exception.thrown(h.colbits + " indexed bits per pixel not supported");
			}
			break;
		}
		return bgra;
	}
}
$hxClasses["format.png.Tools"] = format_png_Tools;
format_png_Tools.__name__ = "format.png.Tools";
var format_tga_ImageOrigin = $hxEnums["format.tga.ImageOrigin"] = { __ename__:true,__constructs__:null
	,BottomLeft: {_hx_name:"BottomLeft",_hx_index:0,__enum__:"format.tga.ImageOrigin",toString:$estr}
	,BottomRight: {_hx_name:"BottomRight",_hx_index:1,__enum__:"format.tga.ImageOrigin",toString:$estr}
	,TopLeft: {_hx_name:"TopLeft",_hx_index:2,__enum__:"format.tga.ImageOrigin",toString:$estr}
	,TopRight: {_hx_name:"TopRight",_hx_index:3,__enum__:"format.tga.ImageOrigin",toString:$estr}
};
format_tga_ImageOrigin.__constructs__ = [format_tga_ImageOrigin.BottomLeft,format_tga_ImageOrigin.BottomRight,format_tga_ImageOrigin.TopLeft,format_tga_ImageOrigin.TopRight];
format_tga_ImageOrigin.__empty_constructs__ = [format_tga_ImageOrigin.BottomLeft,format_tga_ImageOrigin.BottomRight,format_tga_ImageOrigin.TopLeft,format_tga_ImageOrigin.TopRight];
var format_tga_ImageType = $hxEnums["format.tga.ImageType"] = { __ename__:true,__constructs__:null
	,NoImage: {_hx_name:"NoImage",_hx_index:0,__enum__:"format.tga.ImageType",toString:$estr}
	,UncompressedColorMapped: {_hx_name:"UncompressedColorMapped",_hx_index:1,__enum__:"format.tga.ImageType",toString:$estr}
	,UncompressedTrueColor: {_hx_name:"UncompressedTrueColor",_hx_index:2,__enum__:"format.tga.ImageType",toString:$estr}
	,UncompressedBlackAndWhite: {_hx_name:"UncompressedBlackAndWhite",_hx_index:3,__enum__:"format.tga.ImageType",toString:$estr}
	,RunLengthColorMapped: {_hx_name:"RunLengthColorMapped",_hx_index:4,__enum__:"format.tga.ImageType",toString:$estr}
	,RunLengthTrueColor: {_hx_name:"RunLengthTrueColor",_hx_index:5,__enum__:"format.tga.ImageType",toString:$estr}
	,RunLengthBlackAndWhite: {_hx_name:"RunLengthBlackAndWhite",_hx_index:6,__enum__:"format.tga.ImageType",toString:$estr}
	,Unknown: ($_=function(type) { return {_hx_index:7,type:type,__enum__:"format.tga.ImageType",toString:$estr}; },$_._hx_name="Unknown",$_.__params__ = ["type"],$_)
};
format_tga_ImageType.__constructs__ = [format_tga_ImageType.NoImage,format_tga_ImageType.UncompressedColorMapped,format_tga_ImageType.UncompressedTrueColor,format_tga_ImageType.UncompressedBlackAndWhite,format_tga_ImageType.RunLengthColorMapped,format_tga_ImageType.RunLengthTrueColor,format_tga_ImageType.RunLengthBlackAndWhite,format_tga_ImageType.Unknown];
format_tga_ImageType.__empty_constructs__ = [format_tga_ImageType.NoImage,format_tga_ImageType.UncompressedColorMapped,format_tga_ImageType.UncompressedTrueColor,format_tga_ImageType.UncompressedBlackAndWhite,format_tga_ImageType.RunLengthColorMapped,format_tga_ImageType.RunLengthTrueColor,format_tga_ImageType.RunLengthBlackAndWhite];
class format_tga_Reader {
	constructor(i) {
		this.i = i;
		i.set_bigEndian(false);
	}
	read() {
		let idLength = this.i.readByte();
		let header = this.readHeader();
		let id = idLength == 0 ? "" : this.i.readString(idLength);
		let colorMap = this.readColorMapData(header);
		return { header : header, imageId : id, colorMapData : colorMap, imageData : this.readImageData(header,colorMap), developerData : null};
	}
	readHeader() {
		let colorMapType = this.i.readByte();
		let dataType;
		let dataId = this.i.readByte();
		switch(dataId) {
		case 0:
			dataType = format_tga_ImageType.NoImage;
			break;
		case 1:
			dataType = format_tga_ImageType.UncompressedColorMapped;
			break;
		case 2:
			dataType = format_tga_ImageType.UncompressedTrueColor;
			break;
		case 3:
			dataType = format_tga_ImageType.UncompressedBlackAndWhite;
			break;
		case 9:
			dataType = format_tga_ImageType.RunLengthColorMapped;
			break;
		case 10:
			dataType = format_tga_ImageType.RunLengthTrueColor;
			break;
		case 11:
			dataType = format_tga_ImageType.RunLengthBlackAndWhite;
			break;
		default:
			dataType = format_tga_ImageType.Unknown(dataId);
		}
		let colorMapOrigin = this.i.readInt16();
		let colorMapLength = this.i.readInt16();
		let colorMapDepth = this.i.readByte();
		let xOrigin = this.i.readInt16();
		let yOrigin = this.i.readInt16();
		let width = this.i.readInt16();
		let height = this.i.readInt16();
		let depth = this.i.readByte();
		let descriptor = this.i.readByte();
		let origin;
		switch(descriptor & 48) {
		case 16:
			origin = format_tga_ImageOrigin.BottomRight;
			break;
		case 32:
			origin = format_tga_ImageOrigin.TopLeft;
			break;
		case 48:
			origin = format_tga_ImageOrigin.TopRight;
			break;
		default:
			origin = format_tga_ImageOrigin.BottomLeft;
		}
		return { colorMapType : colorMapType, imageType : dataType, colorMapFirstIndex : colorMapOrigin, colorMapLength : colorMapLength, colorMapEntrySize : colorMapDepth, xOrigin : xOrigin, yOrigin : yOrigin, width : width, height : height, bitsPerPixel : depth, alphaChannelBits : descriptor & 15, imageOrigin : origin};
	}
	readColorMapData(header) {
		if(header.colorMapType == 0) {
			return null;
		}
		return this.readPixels(header.colorMapEntrySize,header.colorMapLength,header.alphaChannelBits,false);
	}
	readImageData(header,colorMap) {
		switch(header.imageType._hx_index) {
		case 0:
			return null;
		case 1:
			return this.readIndexes(header.bitsPerPixel,header.width * header.height,colorMap,header.colorMapFirstIndex,false);
		case 2:
			return this.readPixels(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,false);
		case 3:
			return this.readMono(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,false);
		case 4:
			return this.readIndexes(header.bitsPerPixel,header.width * header.height,colorMap,header.colorMapFirstIndex,true);
		case 5:
			return this.readPixels(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,true);
		case 6:
			return this.readMono(header.bitsPerPixel,header.width * header.height,header.alphaChannelBits,true);
		default:
			throw haxe_Exception.thrown("Unsupported image data type!");
		}
	}
	readPixels(bitsPerPixel,amount,alphaChannelBits,rle) {
		let list = new Array(amount);
		let alpha = alphaChannelBits != 0;
		let parsePixel;
		let readEntry;
		switch(bitsPerPixel) {
		case 8:
			readEntry = ($_=this.i,$bind($_,$_.readByte));
			parsePixel = $bind(this,this.parsePixel1);
			break;
		case 16:
			readEntry = ($_=this.i,$bind($_,$_.readUInt16));
			parsePixel = $bind(this,this.parsePixel2);
			break;
		case 24:
			readEntry = ($_=this.i,$bind($_,$_.readUInt24));
			parsePixel = $bind(this,this.parsePixel3);
			break;
		case 32:
			readEntry = ($_=this.i,$bind($_,$_.readInt32));
			parsePixel = $bind(this,this.parsePixel4);
			break;
		default:
			throw haxe_Exception.thrown("Unsupported bits per pixels amount!");
		}
		if(rle) {
			let rleChunk;
			let i = 0;
			while(i < amount) {
				rleChunk = this.i.readByte();
				if((rleChunk & 128) != 0) {
					rleChunk &= 127;
					let pixel = parsePixel(readEntry(),alpha);
					while(rleChunk >= 0) {
						list[i++] = pixel;
						--rleChunk;
					}
				} else {
					rleChunk &= 127;
					while(rleChunk >= 0) {
						list[i++] = parsePixel(readEntry(),alpha);
						--rleChunk;
					}
				}
			}
		} else {
			let _g = 0;
			while(_g < amount) {
				let i = _g++;
				list[i] = parsePixel(readEntry(),alpha);
			}
		}
		return list;
	}
	readMono(bitsPerPixel,amount,alphaChannelBits,rle) {
		let list = new Array(amount);
		let alpha = alphaChannelBits != 0;
		let parsePixel;
		let readEntry;
		switch(bitsPerPixel) {
		case 8:
			readEntry = ($_=this.i,$bind($_,$_.readByte));
			parsePixel = $bind(this,this.parsePixel1);
			break;
		case 16:
			readEntry = ($_=this.i,$bind($_,$_.readUInt16));
			parsePixel = $bind(this,this.parsePixelGreyAlpha);
			break;
		default:
			throw haxe_Exception.thrown("Unsupported bits per pixels amount!");
		}
		if(rle) {
			let rleChunk;
			let i = 0;
			while(i < amount) {
				rleChunk = this.i.readByte();
				if((rleChunk & 128) != 0) {
					rleChunk &= 127;
					let pixel = parsePixel(readEntry(),alpha);
					while(rleChunk >= 0) {
						list[i++] = pixel;
						--rleChunk;
					}
				} else {
					rleChunk &= 127;
					while(rleChunk >= 0) {
						list[i++] = parsePixel(readEntry(),alpha);
						--rleChunk;
					}
				}
			}
		} else {
			let _g = 0;
			while(_g < amount) {
				let i = _g++;
				list[i] = parsePixel(readEntry(),alpha);
			}
		}
		return list;
	}
	readIndexes(bitsPerPixel,amount,colorMap,offset,rle) {
		let list = new Array(amount);
		let readEntry;
		switch(bitsPerPixel) {
		case 8:
			readEntry = ($_=this.i,$bind($_,$_.readByte));
			break;
		case 16:
			readEntry = ($_=this.i,$bind($_,$_.readUInt16));
			break;
		case 24:
			readEntry = ($_=this.i,$bind($_,$_.readUInt24));
			break;
		case 32:
			readEntry = ($_=this.i,$bind($_,$_.readInt32));
			break;
		default:
			throw haxe_Exception.thrown("Unsupported bits per pixels amount!");
		}
		if(rle) {
			let i = 0;
			let rleChunk;
			while(i < amount) {
				rleChunk = this.i.readByte();
				if((rleChunk & 128) != 0) {
					rleChunk &= 127;
					let pixel = colorMap[offset + readEntry()];
					while(rleChunk >= 0) {
						list[i++] = pixel;
						--rleChunk;
					}
				} else {
					rleChunk &= 127;
					while(rleChunk >= 0) {
						list[i++] = colorMap[offset + readEntry()];
						--rleChunk;
					}
				}
			}
		} else {
			let _g = 0;
			while(_g < amount) {
				let i = _g++;
				list[i] = colorMap[offset + readEntry()];
			}
		}
		return list;
	}
	parsePixel1(value,alpha) {
		return value << 16 | value << 8 | value;
	}
	parsePixelGreyAlpha(value,alpha) {
		return (alpha ? (value & 65280) << 16 : 0) | this.parsePixel1(value & 255,false);
	}
	parsePixel2(value,alpha) {
		return (alpha ? (value & 32768) == 1 ? -16777216 : 0 : 0) | (((value & 31744) >> 10) / 31 * 255 | 0) << 16 | (((value & 992) >> 5) / 31 * 255 | 0) << 8 | ((value & 31) / 31 * 255 | 0);
	}
	parsePixel3(value,alpha) {
		return value;
	}
	parsePixel4(value,alpha) {
		return value;
	}
}
$hxClasses["format.tga.Reader"] = format_tga_Reader;
format_tga_Reader.__name__ = "format.tga.Reader";
Object.assign(format_tga_Reader.prototype, {
	__class__: format_tga_Reader
	,i: null
});
class format_tools_BitsInput {
	constructor(i) {
		this.i = i;
		this.nbits = 0;
		this.bits = 0;
	}
	readBits(n) {
		if(this.nbits >= n) {
			let c = this.nbits - n;
			let k = this.bits >>> c & (1 << n) - 1;
			this.nbits = c;
			return k;
		}
		let k = this.i.readByte();
		if(this.nbits >= 24) {
			if(n > 31) {
				throw haxe_Exception.thrown("Bits error");
			}
			let c = 8 + this.nbits - n;
			let d = this.bits & (1 << this.nbits) - 1;
			d = d << 8 - c | k << c;
			this.bits = k;
			this.nbits = c;
			return d;
		}
		this.bits = this.bits << 8 | k;
		this.nbits += 8;
		return this.readBits(n);
	}
	readBit() {
		if(this.nbits == 0) {
			this.bits = this.i.readByte();
			this.nbits = 8;
		}
		this.nbits--;
		return (this.bits >>> this.nbits & 1) == 1;
	}
}
$hxClasses["format.tools.BitsInput"] = format_tools_BitsInput;
format_tools_BitsInput.__name__ = "format.tools.BitsInput";
Object.assign(format_tools_BitsInput.prototype, {
	__class__: format_tools_BitsInput
	,i: null
	,nbits: null
	,bits: null
});
class format_tools_Inflate {
	static run(bytes) {
		return haxe_zip_Uncompress.run(bytes);
	}
}
$hxClasses["format.tools.Inflate"] = format_tools_Inflate;
format_tools_Inflate.__name__ = "format.tools.Inflate";
var format_wav_WAVEFormat = $hxEnums["format.wav.WAVEFormat"] = { __ename__:true,__constructs__:null
	,WF_PCM: {_hx_name:"WF_PCM",_hx_index:0,__enum__:"format.wav.WAVEFormat",toString:$estr}
};
format_wav_WAVEFormat.__constructs__ = [format_wav_WAVEFormat.WF_PCM];
format_wav_WAVEFormat.__empty_constructs__ = [format_wav_WAVEFormat.WF_PCM];
class format_wav_Reader {
	constructor(i) {
		this.i = i;
		i.set_bigEndian(false);
	}
	read() {
		if(this.i.readString(4) != "RIFF") {
			throw haxe_Exception.thrown("RIFF header expected");
		}
		this.i.readInt32();
		if(this.i.readString(4) != "WAVE") {
			throw haxe_Exception.thrown("WAVE signature not found");
		}
		let fmt = this.i.readString(4);
		_hx_loop1: while(fmt != "fmt ") switch(fmt) {
		case "JUNK":
			let junkLen = this.i.readInt32();
			this.i.read(junkLen);
			fmt = this.i.readString(4);
			break;
		case "bext":
			let bextLen = this.i.readInt32();
			this.i.read(bextLen);
			fmt = this.i.readString(4);
			break;
		default:
			break _hx_loop1;
		}
		if(fmt != "fmt ") {
			throw haxe_Exception.thrown("unsupported wave chunk " + fmt);
		}
		let fmtlen = this.i.readInt32();
		let format;
		switch(this.i.readUInt16()) {
		case 1:case 3:
			format = format_wav_WAVEFormat.WF_PCM;
			break;
		default:
			throw haxe_Exception.thrown("only PCM (uncompressed) WAV files are supported");
		}
		let channels = this.i.readUInt16();
		let samplingRate = this.i.readInt32();
		let byteRate = this.i.readInt32();
		let blockAlign = this.i.readUInt16();
		let bitsPerSample = this.i.readUInt16();
		if(fmtlen > 16) {
			this.i.read(fmtlen - 16);
		}
		let nextChunk = this.i.readString(4);
		while(nextChunk != "data") {
			this.i.read(this.i.readInt32());
			nextChunk = this.i.readString(4);
		}
		if(nextChunk != "data") {
			throw haxe_Exception.thrown("expected data subchunk");
		}
		let datalen = this.i.readInt32();
		let data;
		try {
			data = this.i.read(datalen);
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw haxe_Exception.thrown("Invalid chunk data length");
			} else {
				throw _g;
			}
		}
		let cuePoints = [];
		try {
			while(true) {
				let nextChunk = this.i.readString(4);
				if(nextChunk == "cue ") {
					this.i.readInt32();
					let nbCuePoints = this.i.readInt32();
					let _g = 0;
					while(_g < nbCuePoints) {
						++_g;
						let cueId = this.i.readInt32();
						this.i.readInt32();
						this.i.readString(4);
						this.i.readInt32();
						this.i.readInt32();
						let cueSampleOffset = this.i.readInt32();
						cuePoints.push({ id : cueId, sampleOffset : cueSampleOffset});
					}
				} else {
					let n = this.i.readInt32();
					if(n < 0) {
						break;
					}
					this.i.read(n);
				}
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return { header : { format : format, channels : channels, samplingRate : samplingRate, byteRate : byteRate, blockAlign : blockAlign, bitsPerSample : bitsPerSample}, data : data, cuePoints : cuePoints};
	}
}
$hxClasses["format.wav.Reader"] = format_wav_Reader;
format_wav_Reader.__name__ = "format.wav.Reader";
Object.assign(format_wav_Reader.prototype, {
	__class__: format_wav_Reader
	,i: null
});
class hxd_fs_FileEntry {
	getBytes() {
		return null;
	}
	readBytes(out,outPos,pos,len) {
		throw haxe_Exception.thrown("readBytes() not implemented");
	}
	fetchBytes(pos,len) {
		let bytes = hxd_fs_FileEntry.TMP_BYTES;
		if(bytes == null || bytes.length < len) {
			let allocSize = len + 65535 & -65536;
			bytes = new haxe_io_Bytes(new ArrayBuffer(allocSize));
			hxd_fs_FileEntry.TMP_BYTES = bytes;
		}
		this.readFull(bytes,pos,len);
		return bytes;
	}
	readFull(bytes,pos,len) {
		if(this.readBytes(bytes,0,pos,len) < len) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
	}
	getText() {
		return this.getBytes().toString();
	}
	open() {
		return new hxd_fs_FileInput(this);
	}
	load(onReady) {
		if(!this.get_isAvailable()) {
			throw haxe_Exception.thrown("load() not implemented");
		} else if(onReady != null) {
			onReady();
		}
	}
	loadBitmap(onLoaded) {
		throw haxe_Exception.thrown("loadBitmap() not implemented");
	}
	watch(onChanged) {
	}
	iterator() {
		return null;
	}
	get_isAvailable() {
		return true;
	}
	get_isDirectory() {
		return false;
	}
	get_size() {
		return 0;
	}
	get_path() {
		throw haxe_Exception.thrown("path() not implemented");
	}
	get_extension() {
		let idx = this.name.lastIndexOf(".");
		if(idx < 0) {
			return "";
		}
		return HxOverrides.substr(this.name,idx + 1,null).toLowerCase();
	}
}
$hxClasses["hxd.fs.FileEntry"] = hxd_fs_FileEntry;
hxd_fs_FileEntry.__name__ = "hxd.fs.FileEntry";
Object.assign(hxd_fs_FileEntry.prototype, {
	__class__: hxd_fs_FileEntry
	,name: null
});
class fs_ManifestEntry extends hxd_fs_FileEntry {
	constructor(fs,name,relPath,file,originalFile) {
		super();
		this.fs = fs;
		this.name = name;
		this.relPath = relPath;
		this.originalFile = originalFile;
		this.file = file;
		if(file == null) {
			this.isDir = true;
			this.contents = [];
		}
	}
	getBytes() {
		return this.bytes;
	}
	readBytes(out,outPos,pos,len) {
		if(this.bytes == null) {
			this.bytes = this.getBytes();
		}
		if(pos + len > this.bytes.length) {
			len = this.bytes.length - pos;
		}
		if(len < 0) {
			len = 0;
		}
		out.blit(outPos,this.bytes,pos,len);
		return len;
	}
	open() {
		return new hxd_fs_FileInput(this);
	}
	load(onReady) {
		let _gthis = this;
		if(this.loaded) {
			if(onReady != null) {
				onReady();
			}
		} else {
			window.fetch(this.file).then(function(res) {
				return res.arrayBuffer();
			}).then(function(buf) {
				_gthis.loaded = true;
				_gthis.bytes = haxe_io_Bytes.ofData(buf);
				if(onReady != null) {
					onReady();
				}
			});
		}
	}
	loadBitmap(onLoaded) {
		let _gthis = this;
		this.load(function() {
			let img = new Image();
			img.onload = function(_) {
				onLoaded(img);
			};
			img.src = _gthis.file;
		});
	}
	_get(name) {
		if(this.isDir) {
			let _g = 0;
			let _g1 = this.contents;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				if(c.name.toLowerCase() == name.toLowerCase()) {
					return c;
				}
			}
		}
		return null;
	}
	iterator() {
		if(this.isDir) {
			return new hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry(this.contents);
		}
		return null;
	}
	get_isAvailable() {
		return this.loaded;
	}
	get_isDirectory() {
		return this.isDir;
	}
	get_path() {
		if(this.relPath == ".") {
			return "<root>";
		} else {
			return this.relPath;
		}
	}
	get_size() {
		if(this.bytes != null) {
			return this.bytes.length;
		} else {
			return 0;
		}
	}
}
$hxClasses["fs.ManifestEntry"] = fs_ManifestEntry;
fs_ManifestEntry.__name__ = "fs.ManifestEntry";
fs_ManifestEntry.__super__ = hxd_fs_FileEntry;
Object.assign(fs_ManifestEntry.prototype, {
	__class__: fs_ManifestEntry
	,fs: null
	,relPath: null
	,isDir: null
	,contents: null
	,file: null
	,originalFile: null
	,bytes: null
	,loaded: null
});
class hxd_fs_FileSystem {
}
$hxClasses["hxd.fs.FileSystem"] = hxd_fs_FileSystem;
hxd_fs_FileSystem.__name__ = "hxd.fs.FileSystem";
hxd_fs_FileSystem.__isInterface__ = true;
Object.assign(hxd_fs_FileSystem.prototype, {
	__class__: hxd_fs_FileSystem
	,get: null
	,exists: null
	,dir: null
});
class fs_ManifestFileSystem {
	constructor(dir,_manifest) {
		this.baseDir = haxe_io_Path.addTrailingSlash(dir);
		this.root = new fs_ManifestEntry(this,"<root>",".",null);
		this.manifest = new haxe_ds_StringMap();
		switch(_manifest.b[0]) {
		case 0:
			throw haxe_Exception.thrown("Binary manifest not yet supported!");
		case 1:
			throw haxe_Exception.thrown("Serialized manifest not yet supported!");
		case 91:
			let json = JSON.parse(_manifest.toString());
			let _g = 0;
			while(_g < json.length) {
				let entry = json[_g];
				++_g;
				let path = entry.path.toLowerCase();
				let file = this.baseDir + entry.path;
				let original = entry.original;
				let dir = haxe_io_Path.directory(original).split("/");
				let r = this.root;
				let _g1 = 0;
				while(_g1 < dir.length) {
					let n = dir[_g1];
					++_g1;
					if(n == "") {
						continue;
					}
					let found = false;
					let _g = 0;
					let _g2 = r.contents;
					while(_g < _g2.length) {
						let c = _g2[_g];
						++_g;
						if(c.name == n) {
							r = c;
							found = true;
							break;
						}
					}
					if(!found) {
						let dirEntry = new fs_ManifestEntry(this,n,r.relPath + "/" + n,null);
						r.contents.push(dirEntry);
						r = dirEntry;
					}
				}
				let entry1 = new fs_ManifestEntry(this,haxe_io_Path.withoutDirectory(original),original,file,original);
				r.contents.push(entry1);
				this.manifest.h[path.toLowerCase()] = entry1;
			}
			break;
		case 108:
			throw haxe_Exception.thrown("List manifest not yet supported");
		case 109:
			throw haxe_Exception.thrown("Mapping manifest not yet supported");
		}
	}
	splitPath(path) {
		if(path == ".") {
			return [];
		} else {
			return path.split("/");
		}
	}
	find(path) {
		let r = this.root;
		let _g = 0;
		let _g1 = this.splitPath(path.toLowerCase());
		while(_g < _g1.length) {
			let p = _g1[_g];
			++_g;
			r = r._get(p.toLowerCase());
			if(r == null) {
				return null;
			}
		}
		return r;
	}
	exists(path) {
		return this.find(path.toLowerCase()) != null;
	}
	get(path) {
		let entry = this.find(path.toLowerCase());
		if(entry == null) {
			throw haxe_Exception.thrown(new hxd_fs_NotFound(path));
		}
		return entry;
	}
	dir(path) {
		let entry = this.find(path.toLowerCase());
		if(entry == null) {
			throw haxe_Exception.thrown(new hxd_fs_NotFound(path));
		}
		return entry.contents.slice();
	}
}
$hxClasses["fs.ManifestFileSystem"] = fs_ManifestFileSystem;
fs_ManifestFileSystem.__name__ = "fs.ManifestFileSystem";
fs_ManifestFileSystem.__interfaces__ = [hxd_fs_FileSystem];
Object.assign(fs_ManifestFileSystem.prototype, {
	__class__: fs_ManifestFileSystem
	,baseDir: null
	,manifest: null
	,root: null
});
class hxd_res_Loader {
	constructor(fs) {
		this.fs = fs;
		this.cache = new haxe_ds_StringMap();
	}
	load(path) {
		return new hxd_res_Any(this,this.fs.get(path));
	}
	loadCache(path,c) {
		let res = this.cache.h[path];
		if(res == null) {
			let entry = this.fs.get(path);
			let old = hxd_res_Loader.currentInstance;
			hxd_res_Loader.currentInstance = this;
			res = Type.createInstance(c,[entry]);
			hxd_res_Loader.currentInstance = old;
			this.cache.h[path] = res;
		} else if((js_Boot.__downcastCheck(res,c) ? res : null) == null) {
			throw haxe_Exception.thrown(path + " has been reintrepreted from " + Std.string(js_Boot.getClass(res)) + " to " + Std.string(c));
		}
		return res;
	}
}
$hxClasses["hxd.res.Loader"] = hxd_res_Loader;
hxd_res_Loader.__name__ = "hxd.res.Loader";
Object.assign(hxd_res_Loader.prototype, {
	__class__: hxd_res_Loader
	,fs: null
	,cache: null
});
class fs_ManifestLoader extends hxd_res_Loader {
	constructor(fs) {
		super(fs);
		this.mfs = fs;
		this.totalFiles = 0;
		let h = fs.manifest.h;
		let f_keys = Object.keys(h);
		let f_length = f_keys.length;
		let f_current = 0;
		while(f_current < f_length) {
			++f_current;
			this.totalFiles++;
		}
		this.loadedFiles = 0;
		this.loading = false;
	}
}
$hxClasses["fs.ManifestLoader"] = fs_ManifestLoader;
fs_ManifestLoader.__name__ = "fs.ManifestLoader";
fs_ManifestLoader.__super__ = hxd_res_Loader;
Object.assign(fs_ManifestLoader.prototype, {
	__class__: fs_ManifestLoader
	,mfs: null
	,totalFiles: null
	,loadedFiles: null
	,loading: null
});
class h2d_col_Point {
	constructor(x,y) {
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.x = x;
		this.y = y;
	}
}
$hxClasses["h2d.col.Point"] = h2d_col_Point;
h2d_col_Point.__name__ = "h2d.col.Point";
Object.assign(h2d_col_Point.prototype, {
	__class__: h2d_col_Point
	,x: null
	,y: null
});
class h2d_Object {
	constructor(parent) {
		if(h2d_Object._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(parent);
	}
	_hx_constructor(parent) {
		this.blendMode = h2d_BlendMode.Alpha;
		this.alpha = 1.;
		this.visible = true;
		this.rotation = 0;
		this.scaleY = 1;
		this.scaleX = 1;
		this.y = 0;
		this.x = 0;
		this.matA = 1;
		this.matB = 0;
		this.matC = 0;
		this.matD = 1;
		this.absX = 0;
		this.absY = 0;
		this.posChanged = parent != null;
		this.children = [];
		if(parent != null) {
			parent.addChild(this);
		}
	}
	getBounds(relativeTo,out) {
		if(out == null) {
			out = new h2d_col_Bounds();
		} else {
			out.xMin = 1e20;
			out.yMin = 1e20;
			out.xMax = -1e20;
			out.yMax = -1e20;
		}
		if(relativeTo != null) {
			relativeTo.syncPos();
		}
		if(relativeTo != this) {
			this.syncPos();
		}
		this.getBoundsRec(relativeTo,out,false);
		if(out.xMax <= out.xMin || out.yMax <= out.yMin) {
			this.addBounds(relativeTo,out,-1,-1,2,2);
			out.xMax = out.xMin = (out.xMax + out.xMin) * 0.5;
			out.yMax = out.yMin = (out.yMax + out.yMin) * 0.5;
		}
		return out;
	}
	contains(o) {
		while(o != null) {
			o = o.parent;
			if(o == this) {
				return true;
			}
		}
		return false;
	}
	set_filter(f) {
		if(this.filter != null && this.allocated) {
			this.filter.unbind(this);
		}
		this.filter = f;
		if(f != null && this.allocated) {
			f.bind(this);
		}
		return f;
	}
	getBoundsRec(relativeTo,out,forSize) {
		if(this.posChanged) {
			this.calcAbsPos();
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
		let n = this.children.length;
		if(n == 0) {
			out.xMin = 1e20;
			out.yMin = 1e20;
			out.xMax = -1e20;
			out.yMax = -1e20;
			return;
		}
		if(n == 1) {
			let c = this.children[0];
			if(c.visible) {
				c.getBoundsRec(relativeTo,out,forSize);
			} else {
				out.xMin = 1e20;
				out.yMin = 1e20;
				out.xMax = -1e20;
				out.yMax = -1e20;
			}
			return;
		}
		let xmin = Infinity;
		let ymin = Infinity;
		let xmax = -Infinity;
		let ymax = -Infinity;
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			if(!c.visible) {
				continue;
			}
			c.getBoundsRec(relativeTo,out,forSize);
			if(out.xMin < xmin) {
				xmin = out.xMin;
			}
			if(out.yMin < ymin) {
				ymin = out.yMin;
			}
			if(out.xMax > xmax) {
				xmax = out.xMax;
			}
			if(out.yMax > ymax) {
				ymax = out.yMax;
			}
		}
		out.xMin = xmin;
		out.yMin = ymin;
		out.xMax = xmax;
		out.yMax = ymax;
	}
	addBounds(relativeTo,out,dx,dy,width,height) {
		if(width <= 0 || height <= 0) {
			return;
		}
		if(relativeTo == null) {
			let x = dx * this.matA + dy * this.matC + this.absX;
			let y = dx * this.matB + dy * this.matD + this.absY;
			if(x < out.xMin) {
				out.xMin = x;
			}
			if(x > out.xMax) {
				out.xMax = x;
			}
			if(y < out.yMin) {
				out.yMin = y;
			}
			if(y > out.yMax) {
				out.yMax = y;
			}
			let x1 = (dx + width) * this.matA + dy * this.matC + this.absX;
			let y1 = (dx + width) * this.matB + dy * this.matD + this.absY;
			if(x1 < out.xMin) {
				out.xMin = x1;
			}
			if(x1 > out.xMax) {
				out.xMax = x1;
			}
			if(y1 < out.yMin) {
				out.yMin = y1;
			}
			if(y1 > out.yMax) {
				out.yMax = y1;
			}
			let x2 = dx * this.matA + (dy + height) * this.matC + this.absX;
			let y2 = dx * this.matB + (dy + height) * this.matD + this.absY;
			if(x2 < out.xMin) {
				out.xMin = x2;
			}
			if(x2 > out.xMax) {
				out.xMax = x2;
			}
			if(y2 < out.yMin) {
				out.yMin = y2;
			}
			if(y2 > out.yMax) {
				out.yMax = y2;
			}
			let x3 = (dx + width) * this.matA + (dy + height) * this.matC + this.absX;
			let y3 = (dx + width) * this.matB + (dy + height) * this.matD + this.absY;
			if(x3 < out.xMin) {
				out.xMin = x3;
			}
			if(x3 > out.xMax) {
				out.xMax = x3;
			}
			if(y3 < out.yMin) {
				out.yMin = y3;
			}
			if(y3 > out.yMax) {
				out.yMax = y3;
			}
			return;
		}
		if(relativeTo == this) {
			if(out.xMin > dx) {
				out.xMin = dx;
			}
			if(out.yMin > dy) {
				out.yMin = dy;
			}
			if(out.xMax < dx + width) {
				out.xMax = dx + width;
			}
			if(out.yMax < dy + height) {
				out.yMax = dy + height;
			}
			return;
		}
		let r = relativeTo.matA * relativeTo.matD - relativeTo.matB * relativeTo.matC;
		if(r == 0) {
			return;
		}
		let det = 1 / r;
		let rA = relativeTo.matD * det;
		let rB = -relativeTo.matB * det;
		let rC = -relativeTo.matC * det;
		let rD = relativeTo.matA * det;
		let rX = this.absX - relativeTo.absX;
		let rY = this.absY - relativeTo.absY;
		let x = dx * this.matA + dy * this.matC + rX;
		let y = dx * this.matB + dy * this.matD + rY;
		let x1 = x * rA + y * rC;
		let y1 = x * rB + y * rD;
		if(x1 < out.xMin) {
			out.xMin = x1;
		}
		if(x1 > out.xMax) {
			out.xMax = x1;
		}
		if(y1 < out.yMin) {
			out.yMin = y1;
		}
		if(y1 > out.yMax) {
			out.yMax = y1;
		}
		x = (dx + width) * this.matA + dy * this.matC + rX;
		y = (dx + width) * this.matB + dy * this.matD + rY;
		let x2 = x * rA + y * rC;
		let y2 = x * rB + y * rD;
		if(x2 < out.xMin) {
			out.xMin = x2;
		}
		if(x2 > out.xMax) {
			out.xMax = x2;
		}
		if(y2 < out.yMin) {
			out.yMin = y2;
		}
		if(y2 > out.yMax) {
			out.yMax = y2;
		}
		x = dx * this.matA + (dy + height) * this.matC + rX;
		y = dx * this.matB + (dy + height) * this.matD + rY;
		let x3 = x * rA + y * rC;
		let y3 = x * rB + y * rD;
		if(x3 < out.xMin) {
			out.xMin = x3;
		}
		if(x3 > out.xMax) {
			out.xMax = x3;
		}
		if(y3 < out.yMin) {
			out.yMin = y3;
		}
		if(y3 > out.yMax) {
			out.yMax = y3;
		}
		x = (dx + width) * this.matA + (dy + height) * this.matC + rX;
		y = (dx + width) * this.matB + (dy + height) * this.matD + rY;
		let x4 = x * rA + y * rC;
		let y4 = x * rB + y * rD;
		if(x4 < out.xMin) {
			out.xMin = x4;
		}
		if(x4 > out.xMax) {
			out.xMax = x4;
		}
		if(y4 < out.yMin) {
			out.yMin = y4;
		}
		if(y4 > out.yMax) {
			out.yMax = y4;
		}
	}
	localToGlobal(pt) {
		this.syncPos();
		if(pt == null) {
			pt = new h2d_col_Point();
		}
		let px = pt.x * this.matA + pt.y * this.matC + this.absX;
		let py = pt.x * this.matB + pt.y * this.matD + this.absY;
		pt.x = px;
		pt.y = py;
		return pt;
	}
	globalToLocal(pt) {
		this.syncPos();
		pt.x -= this.absX;
		pt.y -= this.absY;
		let invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
		let px = (pt.x * this.matD - pt.y * this.matC) * invDet;
		let py = (-pt.x * this.matB + pt.y * this.matA) * invDet;
		pt.x = px;
		pt.y = py;
		return pt;
	}
	getScene() {
		let p = this;
		while(p.parent != null) p = p.parent;
		if(((p) instanceof h2d_Scene)) {
			return p;
		} else {
			return null;
		}
	}
	set_visible(b) {
		if(this.visible == b) {
			return b;
		}
		this.visible = b;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return b;
	}
	addChild(s) {
		this.addChildAt(s,this.children.length);
	}
	addChildAt(s,pos) {
		if(pos < 0) {
			pos = 0;
		}
		if(pos > this.children.length) {
			pos = this.children.length;
		}
		let p = this;
		while(p != null) {
			if(p == s) {
				throw haxe_Exception.thrown("Recursive addChild");
			}
			p = p.parent;
		}
		if(s.parent != null) {
			let old = s.allocated;
			s.allocated = false;
			s.parent.removeChild(s);
			s.allocated = old;
		}
		this.children.splice(pos,0,s);
		if(!this.allocated && s.allocated) {
			s.onRemove();
		}
		s.parent = this;
		s.parentContainer = this.parentContainer;
		s.posChanged = true;
		if(this.allocated) {
			if(!s.allocated) {
				s.onAdd();
			} else {
				s.onHierarchyMoved(true);
			}
		}
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
	}
	onHierarchyMoved(parentChanged) {
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.onHierarchyMoved(parentChanged);
		}
	}
	onAdd() {
		this.allocated = true;
		if(this.filter != null) {
			this.filter.bind(this);
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.onAdd();
		}
	}
	onRemove() {
		this.allocated = false;
		if(this.filter != null) {
			this.filter.unbind(this);
		}
		let i = this.children.length - 1;
		while(i >= 0) {
			let c = this.children[i--];
			if(c != null) {
				c.onRemove();
			}
		}
	}
	removeChild(s) {
		if(HxOverrides.remove(this.children,s)) {
			if(s.allocated) {
				s.onRemove();
			}
			s.parent = null;
			if(s.parentContainer != null) {
				s.setParentContainer(null);
			}
			s.posChanged = true;
			if(this.parentContainer != null) {
				this.parentContainer.contentChanged(this);
			}
		}
	}
	setParentContainer(c) {
		this.parentContainer = c;
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			s.setParentContainer(c);
		}
	}
	draw(ctx) {
	}
	sync(ctx) {
		let changed = this.posChanged;
		if(changed) {
			this.calcAbsPos();
			this.posChanged = false;
		}
		this.lastFrame = ctx.frame;
		let p = 0;
		let len = this.children.length;
		while(p < len) {
			let c = this.children[p];
			if(c == null) {
				break;
			}
			if(c.lastFrame != ctx.frame) {
				if(changed) {
					c.posChanged = true;
				}
				c.sync(ctx);
			}
			if(this.children[p] != c) {
				p = 0;
				len = this.children.length;
			} else {
				++p;
			}
		}
	}
	syncPos() {
		if(this.parent != null) {
			this.parent.syncPos();
		}
		if(this.posChanged) {
			this.calcAbsPos();
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
	}
	calcAbsPos() {
		if(this.parent == null) {
			let cr;
			let sr;
			if(this.rotation == 0) {
				this.matA = this.scaleX;
				this.matB = 0;
				this.matC = 0;
				this.matD = this.scaleY;
			} else {
				cr = Math.cos(this.rotation);
				sr = Math.sin(this.rotation);
				this.matA = this.scaleX * cr;
				this.matB = this.scaleX * sr;
				this.matC = this.scaleY * -sr;
				this.matD = this.scaleY * cr;
			}
			this.absX = this.x;
			this.absY = this.y;
		} else {
			if(this.rotation == 0) {
				this.matA = this.scaleX * this.parent.matA;
				this.matB = this.scaleX * this.parent.matB;
				this.matC = this.scaleY * this.parent.matC;
				this.matD = this.scaleY * this.parent.matD;
			} else {
				let cr = Math.cos(this.rotation);
				let sr = Math.sin(this.rotation);
				let tmpA = this.scaleX * cr;
				let tmpB = this.scaleX * sr;
				let tmpC = this.scaleY * -sr;
				let tmpD = this.scaleY * cr;
				this.matA = tmpA * this.parent.matA + tmpB * this.parent.matC;
				this.matB = tmpA * this.parent.matB + tmpB * this.parent.matD;
				this.matC = tmpC * this.parent.matA + tmpD * this.parent.matC;
				this.matD = tmpC * this.parent.matB + tmpD * this.parent.matD;
			}
			this.absX = this.x * this.parent.matA + this.y * this.parent.matC + this.parent.absX;
			this.absY = this.x * this.parent.matB + this.y * this.parent.matD + this.parent.absY;
		}
	}
	emitTile(ctx,tile) {
		if(h2d_Object.nullDrawable == null) {
			h2d_Object.nullDrawable = new h2d_Drawable(null);
		}
		h2d_Object.nullDrawable.absX = this.absX;
		h2d_Object.nullDrawable.absY = this.absY;
		h2d_Object.nullDrawable.matA = this.matA;
		h2d_Object.nullDrawable.matB = this.matB;
		h2d_Object.nullDrawable.matC = this.matC;
		h2d_Object.nullDrawable.matD = this.matD;
		ctx.drawTile(h2d_Object.nullDrawable,tile);
	}
	clipBounds(ctx,bounds,scaleX,scaleY) {
		if(scaleY == null) {
			scaleY = 1.;
		}
		if(scaleX == null) {
			scaleX = 1.;
		}
		let view = ctx.tmpBounds;
		let matA;
		let matB;
		let matC;
		let matD;
		let absX;
		let absY;
		if(ctx.inFilter != null) {
			let f1 = ctx.baseShader.filterMatrixA__;
			let f2 = ctx.baseShader.filterMatrixB__;
			let tmpA = this.matA * f1.x + this.matB * f1.y;
			let tmpB = this.matA * f2.x + this.matB * f2.y;
			let tmpC = this.matC * f1.x + this.matD * f1.y;
			let tmpD = this.matC * f2.x + this.matD * f2.y;
			let tmpX = this.absX * f1.x + this.absY * f1.y + f1.z;
			let tmpY = this.absX * f2.x + this.absY * f2.y + f2.z;
			matA = (tmpA * ctx.viewA + tmpB * ctx.viewC) / scaleX;
			matB = (tmpA * ctx.viewB + tmpB * ctx.viewD) / scaleY;
			matC = (tmpC * ctx.viewA + tmpD * ctx.viewC) / scaleX;
			matD = (tmpC * ctx.viewB + tmpD * ctx.viewD) / scaleY;
			absX = tmpX * ctx.viewA + tmpY * ctx.viewC + ctx.viewX;
			absY = tmpX * ctx.viewB + tmpY * ctx.viewD + ctx.viewY;
		} else {
			matA = (this.matA * ctx.viewA + this.matB * ctx.viewC) / scaleX;
			matB = (this.matA * ctx.viewB + this.matB * ctx.viewD) / scaleY;
			matC = (this.matC * ctx.viewA + this.matD * ctx.viewC) / scaleX;
			matD = (this.matC * ctx.viewB + this.matD * ctx.viewD) / scaleY;
			absX = this.absX * ctx.viewA + this.absY * ctx.viewC + ctx.viewX;
			absY = this.absX * ctx.viewB + this.absY * ctx.viewD + ctx.viewY;
		}
		view.xMin = 1e20;
		view.yMin = 1e20;
		view.xMax = -1e20;
		view.yMax = -1e20;
		let x = bounds.xMin;
		let y = bounds.yMin;
		let x1 = x * matA + y * matC + absX;
		let y1 = x * matB + y * matD + absY;
		if(x1 < view.xMin) {
			view.xMin = x1;
		}
		if(x1 > view.xMax) {
			view.xMax = x1;
		}
		if(y1 < view.yMin) {
			view.yMin = y1;
		}
		if(y1 > view.yMax) {
			view.yMax = y1;
		}
		let x2 = bounds.xMax;
		let y2 = bounds.yMin;
		let x3 = x2 * matA + y2 * matC + absX;
		let y3 = x2 * matB + y2 * matD + absY;
		if(x3 < view.xMin) {
			view.xMin = x3;
		}
		if(x3 > view.xMax) {
			view.xMax = x3;
		}
		if(y3 < view.yMin) {
			view.yMin = y3;
		}
		if(y3 > view.yMax) {
			view.yMax = y3;
		}
		let x4 = bounds.xMin;
		let y4 = bounds.yMax;
		let x5 = x4 * matA + y4 * matC + absX;
		let y5 = x4 * matB + y4 * matD + absY;
		if(x5 < view.xMin) {
			view.xMin = x5;
		}
		if(x5 > view.xMax) {
			view.xMax = x5;
		}
		if(y5 < view.yMin) {
			view.yMin = y5;
		}
		if(y5 > view.yMax) {
			view.yMax = y5;
		}
		let x6 = bounds.xMax;
		let y6 = bounds.yMax;
		let x7 = x6 * matA + y6 * matC + absX;
		let y7 = x6 * matB + y6 * matD + absY;
		if(x7 < view.xMin) {
			view.xMin = x7;
		}
		if(x7 > view.xMax) {
			view.xMax = x7;
		}
		if(y7 < view.yMin) {
			view.yMin = y7;
		}
		if(y7 > view.yMax) {
			view.yMax = y7;
		}
		if(view.xMin < -1) {
			view.xMin = -1;
		}
		if(view.yMin < -1) {
			view.yMin = -1;
		}
		if(view.xMax > 1) {
			view.xMax = 1;
		}
		if(view.yMax > 1) {
			view.yMax = 1;
		}
		let invDet = 1 / (matA * matD - matB * matC);
		let sxMin = view.xMin;
		let syMin = view.yMin;
		let sxMax = view.xMax;
		let syMax = view.yMax;
		view.xMin = 1e20;
		view.yMin = 1e20;
		view.xMax = -1e20;
		view.yMax = -1e20;
		let x8 = sxMin;
		let y8 = syMin;
		x8 = sxMin - absX;
		y8 = syMin - absY;
		let x9 = (x8 * matD - y8 * matC) * invDet;
		let y9 = (-x8 * matB + y8 * matA) * invDet;
		if(x9 < view.xMin) {
			view.xMin = x9;
		}
		if(x9 > view.xMax) {
			view.xMax = x9;
		}
		if(y9 < view.yMin) {
			view.yMin = y9;
		}
		if(y9 > view.yMax) {
			view.yMax = y9;
		}
		let x10 = sxMax;
		let y10 = syMin;
		x10 = sxMax - absX;
		y10 = syMin - absY;
		let x11 = (x10 * matD - y10 * matC) * invDet;
		let y11 = (-x10 * matB + y10 * matA) * invDet;
		if(x11 < view.xMin) {
			view.xMin = x11;
		}
		if(x11 > view.xMax) {
			view.xMax = x11;
		}
		if(y11 < view.yMin) {
			view.yMin = y11;
		}
		if(y11 > view.yMax) {
			view.yMax = y11;
		}
		let x12 = sxMin;
		let y12 = syMax;
		x12 = sxMin - absX;
		y12 = syMax - absY;
		let x13 = (x12 * matD - y12 * matC) * invDet;
		let y13 = (-x12 * matB + y12 * matA) * invDet;
		if(x13 < view.xMin) {
			view.xMin = x13;
		}
		if(x13 > view.xMax) {
			view.xMax = x13;
		}
		if(y13 < view.yMin) {
			view.yMin = y13;
		}
		if(y13 > view.yMax) {
			view.yMax = y13;
		}
		let x14 = sxMax;
		let y14 = syMax;
		x14 = sxMax - absX;
		y14 = syMax - absY;
		let x15 = (x14 * matD - y14 * matC) * invDet;
		let y15 = (-x14 * matB + y14 * matA) * invDet;
		if(x15 < view.xMin) {
			view.xMin = x15;
		}
		if(x15 > view.xMax) {
			view.xMax = x15;
		}
		if(y15 < view.yMin) {
			view.yMin = y15;
		}
		if(y15 > view.yMax) {
			view.yMax = y15;
		}
		let a = bounds.xMin;
		let b = view.xMin;
		bounds.xMin = a < b ? b : a;
		let a1 = bounds.yMin;
		let b1 = view.yMin;
		bounds.yMin = a1 < b1 ? b1 : a1;
		let a2 = bounds.xMax;
		let b2 = view.xMax;
		bounds.xMax = a2 > b2 ? b2 : a2;
		let a3 = bounds.yMax;
		let b3 = view.yMax;
		bounds.yMax = a3 > b3 ? b3 : a3;
	}
	drawFilters(ctx) {
		if(!ctx.pushFilter(this)) {
			return;
		}
		let bounds = ctx.tmpBounds;
		let total = new h2d_col_Bounds();
		this.filter.sync(ctx,this);
		let scaleX;
		let scaleY;
		if(this.filter.useScreenResolution) {
			let s = ctx.scene;
			scaleX = s.viewportScaleX * this.filter.resolutionScale;
			scaleY = s.viewportScaleY * this.filter.resolutionScale;
		} else {
			scaleX = this.filter.resolutionScale;
			scaleY = this.filter.resolutionScale;
		}
		if(this.filter.autoBounds) {
			let maxExtent = this.filter.boundsExtend;
			if(maxExtent >= 0) {
				this.getBounds(this,bounds);
				bounds.xMin = bounds.xMin * scaleX - maxExtent;
				bounds.yMin = bounds.yMin * scaleY - maxExtent;
				bounds.xMax = bounds.xMax * scaleX + maxExtent;
				bounds.yMax = bounds.yMax * scaleY + maxExtent;
				if(bounds.xMin < total.xMin) {
					total.xMin = bounds.xMin;
				}
				if(bounds.xMax > total.xMax) {
					total.xMax = bounds.xMax;
				}
				if(bounds.yMin < total.yMin) {
					total.yMin = bounds.yMin;
				}
				if(bounds.yMax > total.yMax) {
					total.yMax = bounds.yMax;
				}
			}
		} else {
			let scale = h2d_Object.tmpPoint;
			let x = scaleX;
			let y = scaleY;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			scale.x = x;
			scale.y = y;
			this.filter.getBounds(this,bounds,scale);
			if(bounds.xMin < total.xMin) {
				total.xMin = bounds.xMin;
			}
			if(bounds.xMax > total.xMax) {
				total.xMax = bounds.xMax;
			}
			if(bounds.yMin < total.yMin) {
				total.yMin = bounds.yMin;
			}
			if(bounds.yMax > total.yMax) {
				total.yMax = bounds.yMax;
			}
			scaleX = scale.x;
			scaleY = scale.y;
		}
		ctx.setFilterScale(scaleX,scaleY);
		this.clipBounds(ctx,total,scaleX,scaleY);
		let xMin = Math.floor(total.xMin + 1e-10);
		let yMin = Math.floor(total.yMin + 1e-10);
		let width = Math.ceil(total.xMax - xMin - 1e-10);
		let height = Math.ceil(total.yMax - yMin - 1e-10);
		if(width <= 0 || height <= 0 || total.xMax < total.xMin) {
			ctx.popFilter();
			return;
		}
		let t = ctx.textures.allocTarget("filterTemp",width,height,false);
		ctx.pushTarget(t,xMin,yMin,width,height);
		ctx.engine.clear(0);
		let oldAlpha = ctx.globalAlpha;
		let shader = ctx.baseShader;
		let _this = shader.filterMatrixA__;
		let x = _this.x;
		let y = _this.y;
		let z = _this.z;
		let w = _this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let oldA_x = x;
		let oldA_y = y;
		let oldA_z = z;
		let oldA_w = w;
		let _this1 = shader.filterMatrixB__;
		let x1 = _this1.x;
		let y1 = _this1.y;
		let z1 = _this1.z;
		let w1 = _this1.w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let oldB_x = x1;
		let oldB_y = y1;
		let oldB_z = z1;
		let oldB_w = w1;
		let invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
		let invA = this.matD * invDet * scaleX;
		let invB = -this.matB * invDet * scaleY;
		let invC = -this.matC * invDet * scaleX;
		let invD = this.matA * invDet * scaleY;
		let invX = -(this.absX * invA + this.absY * invC);
		let invY = -(this.absX * invB + this.absY * invD);
		let _this2 = shader.filterMatrixA__;
		let x2 = invA;
		let y2 = invC;
		let z2 = invX;
		if(invX == null) {
			z2 = 0.;
		}
		if(invC == null) {
			y2 = 0.;
		}
		if(invA == null) {
			x2 = 0.;
		}
		_this2.x = x2;
		_this2.y = y2;
		_this2.z = z2;
		_this2.w = 1.;
		let _this3 = shader.filterMatrixB__;
		let x3 = invB;
		let y3 = invD;
		let z3 = invY;
		if(invY == null) {
			z3 = 0.;
		}
		if(invD == null) {
			y3 = 0.;
		}
		if(invB == null) {
			x3 = 0.;
		}
		_this3.x = x3;
		_this3.y = y3;
		_this3.z = z3;
		_this3.w = 1.;
		ctx.globalAlpha = 1;
		this.drawContent(ctx);
		let finalTile = h2d_Tile.fromTexture(t);
		finalTile.dx = xMin / scaleX;
		finalTile.dy = yMin / scaleY;
		let prev = finalTile;
		finalTile = this.filter.draw(ctx,finalTile);
		if(finalTile != null) {
			if(finalTile != prev) {
				finalTile.dx = (finalTile.dx + xMin) / scaleX;
				finalTile.dy = (finalTile.dy + yMin) / scaleY;
			}
			finalTile.width /= scaleX;
			finalTile.height /= scaleY;
		}
		let _this4 = shader.filterMatrixA__;
		_this4.x = oldA_x;
		_this4.y = oldA_y;
		_this4.z = oldA_z;
		_this4.w = oldA_w;
		let _this5 = shader.filterMatrixB__;
		_this5.x = oldB_x;
		_this5.y = oldB_y;
		_this5.z = oldB_z;
		_this5.w = oldB_w;
		ctx.popTarget();
		ctx.popFilter();
		ctx.globalAlpha = oldAlpha;
		if(finalTile == null) {
			return;
		}
		this.drawFiltered(ctx,finalTile);
	}
	drawFiltered(ctx,tile) {
		let oldAlpha = ctx.globalAlpha;
		ctx.currentBlend = null;
		ctx.inFilterBlend = this.blendMode;
		ctx.globalAlpha *= this.alpha;
		this.emitTile(ctx,tile);
		ctx.globalAlpha = oldAlpha;
		ctx.inFilterBlend = null;
		ctx.currentBlend = null;
	}
	drawRec(ctx) {
		if(!this.visible) {
			return;
		}
		if(this.posChanged) {
			this.calcAbsPos();
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
		if(this.filter != null && this.filter.get_enable()) {
			this.drawFilters(ctx);
		} else {
			let old = ctx.globalAlpha;
			ctx.globalAlpha *= this.alpha;
			this.drawContent(ctx);
			ctx.globalAlpha = old;
		}
	}
	drawContent(ctx) {
		if(ctx.front2back) {
			let i = this.children.length;
			while(i-- > 0) this.children[i].drawRec(ctx);
			this.draw(ctx);
		} else {
			this.draw(ctx);
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				c.drawRec(ctx);
			}
		}
	}
	getChildIndex(o) {
		let _g = 0;
		let _g1 = this.children.length;
		while(_g < _g1) {
			let i = _g++;
			if(this.children[i] == o) {
				return i;
			}
		}
		return -1;
	}
	contentChanged(s) {
	}
	constraintSize(maxWidth,maxHeight) {
	}
}
$hxClasses["h2d.Object"] = h2d_Object;
h2d_Object.__name__ = "h2d.Object";
Object.assign(h2d_Object.prototype, {
	__class__: h2d_Object
	,children: null
	,parentContainer: null
	,parent: null
	,x: null
	,y: null
	,scaleX: null
	,scaleY: null
	,rotation: null
	,visible: null
	,alpha: null
	,filter: null
	,blendMode: null
	,matA: null
	,matB: null
	,matC: null
	,matD: null
	,absX: null
	,absY: null
	,posChanged: null
	,allocated: null
	,lastFrame: null
});
class fs_ManifestProgress extends h2d_Object {
	constructor(loader,color,onLoaded,parent) {
		if(color == null) {
			color = 16777215;
		}
		super(parent);
		this.loader = loader;
		this.color = color;
		this.onLoaded = onLoaded;
		this.g = new h2d_Graphics(this);
		this.text = new h2d_Text(hxd_res_DefaultFont.get(),this);
		let _this = this.text;
		_this.posChanged = true;
		_this.y = 50;
		this.text.set_textAlign(h2d_Align.Center);
		this.text.set_textColor(-16777216 | color);
	}
}
$hxClasses["fs.ManifestProgress"] = fs_ManifestProgress;
fs_ManifestProgress.__name__ = "fs.ManifestProgress";
fs_ManifestProgress.__super__ = h2d_Object;
Object.assign(fs_ManifestProgress.prototype, {
	__class__: fs_ManifestProgress
	,g: null
	,text: null
	,loader: null
	,color: null
	,onLoaded: null
});
class gui_GuiControl {
	constructor() {
		if(gui_GuiControl._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
		this._manualScroll = false;
		this._disposed = false;
		this.soundResources = [];
		this.textureResources = [];
		this.imageResources = [];
		this._mousePos = null;
		this._skipNextEvent = false;
		this._entered = false;
		this.children = [];
		this.yScale = 1;
		this.xScale = 1;
		this.vertSizing = gui_VertSizing.Bottom;
		this.horizSizing = gui_HorizSizing.Right;
	}
	render(scene2d,parent) {
		if(this._flow == null) {
			this._flow = new h2d_Flow(parent != null ? parent : scene2d);
		}
		if(parent == null) {
			if(scene2d.contains(this._flow)) {
				scene2d.removeChild(this._flow);
			}
			scene2d.addChild(this._flow);
		} else {
			if(parent.contains(this._flow)) {
				parent.removeChild(this._flow);
			}
			parent.addChild(this._flow);
		}
		let rrect = this.getRenderRectangle();
		this._flow.set_maxWidth(rrect.extent.x);
		this._flow.set_maxHeight(rrect.extent.y);
		this._flow.set_borderWidth(rrect.extent.x);
		this._flow.set_borderHeight(rrect.extent.y);
		this._flow.set_borderRight(rrect.extent.x);
		this._flow.set_borderBottom(rrect.extent.y);
		this._flow.set_overflow(h2d_FlowOverflow.Hidden);
		this._flow.set_multiline(true);
		if(parent != null) {
			let props = parent.getProperties(this._flow);
			props.set_isAbsolute(true);
			let off = this.getOffsetFromParent();
			let _this = this._flow;
			_this.posChanged = true;
			_this.x = off.x;
			_this.posChanged = true;
			_this.y = off.y;
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.render(scene2d,this._flow);
		}
		this._skipNextEvent = true;
	}
	update(dt,mouseState) {
		if(!this._skipNextEvent) {
			let hitTestRect = this.getHitTestRect(!this._manualScroll);
			if(hitTestRect.inRect(mouseState.position)) {
				if(hxd_Key.isPressed(0)) {
					mouseState.button = 0;
					this.onMousePress(mouseState);
					if(mouseState.handled) {
						return;
					}
				}
				if(hxd_Key.isPressed(1)) {
					mouseState.button = 1;
					this.onMousePress(mouseState);
					if(mouseState.handled) {
						return;
					}
				}
				if(hxd_Key.isReleased(0)) {
					mouseState.button = 0;
					this.onMouseRelease(mouseState);
					if(mouseState.handled) {
						return;
					}
				}
				if(hxd_Key.isReleased(1)) {
					mouseState.button = 1;
					this.onMouseRelease(mouseState);
					if(mouseState.handled) {
						return;
					}
				}
				if(hxd_Key.isDown(0)) {
					mouseState.button = 0;
					this.onMouseDown(mouseState);
					if(mouseState.handled) {
						return;
					}
				}
				if(hxd_Key.isDown(1)) {
					mouseState.button = 1;
					this.onMouseDown(mouseState);
					if(mouseState.handled) {
						return;
					}
				}
				if(!this._entered) {
					this._entered = true;
					this.onMouseEnter(mouseState);
					if(mouseState.handled) {
						return;
					}
				}
				if(this._entered) {
					if(this._mousePos != null) {
						let _this = this._mousePos;
						let v = mouseState.position;
						if(!(_this.x == v.x && _this.y == v.y && _this.z == v.z && _this.w == v.w)) {
							this.onMouseMove(mouseState);
							let _this = mouseState.position;
							this._mousePos = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
							if(mouseState.handled) {
								return;
							}
						}
					} else {
						let _this = mouseState.position;
						this._mousePos = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
						this.onMouseMove(mouseState);
						if(mouseState.handled) {
							return;
						}
					}
				}
			} else if(this._entered) {
				this._entered = false;
				this.onMouseLeave(mouseState);
				if(mouseState.handled) {
					return;
				}
			}
		} else {
			this._skipNextEvent = false;
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.update(dt,mouseState);
		}
	}
	getRenderRectangle() {
		let rect = new gui_Rect(this.position,this.extent);
		let parentRect = null;
		let uiScaleFactor = src_Settings.uiScale;
		if(this.parent != null) {
			parentRect = this.parent.getRenderRectangle();
			let _this = parentRect.position;
			let x = this.position.x * uiScaleFactor * this.xScale;
			let y = this.position.y * uiScaleFactor * this.yScale;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let v_x = x;
			let v_y = y;
			rect.position = new h3d_Vector(_this.x + v_x,_this.y + v_y,_this.z,_this.w + 1.);
		}
		let scaleFactor = 1.0 / hxd_Window.getInstance().get_windowToPixelRatio();
		scaleFactor = 1 / src_Settings.zoomRatio;
		if(this.horizSizing == gui_HorizSizing.Width) {
			if(this.parent != null) {
				rect.extent.x = parentRect.extent.x * (this.extent.x / this.parent.extent.x);
			} else {
				let tmp = hxd_Window.getInstance().get_width();
				rect.extent.x = tmp * scaleFactor;
			}
		}
		if(this.horizSizing == gui_HorizSizing.Height) {
			if(this.parent != null) {
				rect.extent.x = parentRect.extent.y * (this.extent.y / this.parent.extent.y);
			} else {
				let tmp = hxd_Window.getInstance().get_height();
				rect.extent.x = tmp * scaleFactor;
			}
		}
		if(this.vertSizing == gui_VertSizing.Height) {
			if(this.parent != null) {
				rect.extent.y = parentRect.extent.y * (this.extent.y / this.parent.extent.y);
			} else {
				let tmp = hxd_Window.getInstance().get_height();
				rect.extent.y = tmp * scaleFactor;
			}
		}
		if(this.vertSizing == gui_VertSizing.Width) {
			if(this.parent != null) {
				rect.extent.y = parentRect.extent.x * (this.extent.x / this.parent.extent.x);
			} else {
				let tmp = hxd_Window.getInstance().get_width();
				rect.extent.y = tmp * scaleFactor;
			}
		}
		if(this.horizSizing == gui_HorizSizing.Center) {
			if(this.parent != null) {
				rect.position.x = parentRect.position.x + parentRect.extent.x / 2 - rect.extent.x * uiScaleFactor * this.xScale / 2;
				rect.extent.x *= uiScaleFactor * this.xScale;
			}
		}
		if(this.vertSizing == gui_VertSizing.Center) {
			if(this.parent != null) {
				rect.position.y = parentRect.position.y + parentRect.extent.y / 2 - rect.extent.y * uiScaleFactor * this.yScale / 2;
				rect.extent.y *= uiScaleFactor * this.yScale;
			}
		}
		if(this.horizSizing == gui_HorizSizing.Right) {
			if(this.parent != null) {
				rect.position.x = parentRect.position.x + this.position.x * uiScaleFactor * this.xScale;
				rect.extent.x *= uiScaleFactor * this.xScale;
			}
		}
		if(this.vertSizing == gui_VertSizing.Bottom) {
			if(this.parent != null) {
				rect.position.y = parentRect.position.y + this.position.y * uiScaleFactor * this.yScale;
				rect.extent.y *= uiScaleFactor * this.yScale;
			}
		}
		if(this.horizSizing == gui_HorizSizing.Left) {
			if(this.parent != null) {
				rect.position.x = parentRect.position.x + parentRect.extent.x - (this.parent.extent.x - this.position.x) * uiScaleFactor * this.xScale;
				rect.extent.x *= uiScaleFactor * this.xScale;
			}
		}
		if(this.vertSizing == gui_VertSizing.Top) {
			if(this.parent != null) {
				rect.position.y = parentRect.position.y + parentRect.extent.y - (this.parent.extent.y - this.position.y) * uiScaleFactor * this.yScale;
				rect.extent.y *= uiScaleFactor * this.yScale;
			}
		}
		if(this.parent != null) {
			rect.scroll.x = parentRect.scroll.x;
			rect.scroll.y = parentRect.scroll.y;
		}
		return rect;
	}
	getHitTestRect(useScroll) {
		if(useScroll == null) {
			useScroll = true;
		}
		let thisRect = this.getRenderRectangle();
		if(useScroll) {
			thisRect.position.y -= thisRect.scroll.y;
		}
		if(this.parent == null) {
			return thisRect;
		} else {
			let parRect = this.parent.getRenderRectangle();
			let rr = thisRect.intersect(parRect);
			if(useScroll) {
				thisRect.position.y -= thisRect.scroll.y;
				rr.scroll.y = thisRect.scroll.y;
			}
			return rr;
		}
	}
	getOffsetFromParent() {
		let rect = new gui_Rect(this.position,this.extent);
		let parentRect = null;
		let uiScaleFactor = src_Settings.uiScale;
		let _this = this.position;
		let offset = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
		offset.x *= uiScaleFactor * this.xScale;
		offset.y *= uiScaleFactor * this.yScale;
		if(this.parent != null) {
			parentRect = this.parent.getRenderRectangle();
			let _this = this.position;
			offset = new h3d_Vector(_this.x * uiScaleFactor,_this.y * uiScaleFactor,_this.z * uiScaleFactor,_this.w);
			offset.x *= this.xScale;
			offset.y *= this.yScale;
		}
		hxd_Window.getInstance().get_windowToPixelRatio();
		if(this.horizSizing == gui_HorizSizing.Center) {
			if(this.parent != null) {
				offset.x = parentRect.extent.x / 2 - rect.extent.x * uiScaleFactor * this.xScale / 2;
			}
		}
		if(this.vertSizing == gui_VertSizing.Center) {
			if(this.parent != null) {
				offset.y = parentRect.extent.y / 2 - rect.extent.y * uiScaleFactor * this.yScale / 2;
			}
		}
		if(this.horizSizing == gui_HorizSizing.Right) {
			if(this.parent != null) {
				offset.x = this.position.x * uiScaleFactor * this.xScale;
			}
		}
		if(this.vertSizing == gui_VertSizing.Bottom) {
			if(this.parent != null) {
				offset.y = this.position.y * uiScaleFactor * this.yScale;
			}
		}
		if(this.horizSizing == gui_HorizSizing.Left) {
			if(this.parent != null) {
				offset.x = parentRect.extent.x - (this.parent.extent.x - this.position.x) * uiScaleFactor * this.xScale;
			}
		}
		if(this.vertSizing == gui_VertSizing.Top) {
			if(this.parent != null) {
				offset.y = parentRect.extent.y - (this.parent.extent.y - this.position.y) * uiScaleFactor * this.yScale;
			}
		}
		offset.x = Math.floor(offset.x);
		offset.y = Math.floor(offset.y);
		return offset;
	}
	addChild(ctrl) {
		this.children.push(ctrl);
		ctrl.parent = this;
	}
	removeChild(ctrl) {
		HxOverrides.remove(this.children,ctrl);
		ctrl.parent = null;
		ctrl.onRemove();
	}
	removeChildren() {
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.parent = null;
			c.onRemove();
		}
		this.children = [];
	}
	dispose() {
		let _this = this._flow;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.dispose();
		}
		this.children = [];
		let _g2 = 0;
		let _g3 = this.textureResources;
		while(_g2 < _g3.length) {
			let textureResource = _g3[_g2];
			++_g2;
			textureResource.release();
		}
		let _g4 = 0;
		let _g5 = this.imageResources;
		while(_g4 < _g5.length) {
			let imageResource = _g5[_g4];
			++_g4;
			imageResource.release();
		}
		let _g6 = 0;
		let _g7 = this.soundResources;
		while(_g6 < _g7.length) {
			let audioResource = _g7[_g6];
			++_g6;
			audioResource.release();
		}
		this._disposed = true;
	}
	onMouseDown(mouseState) {
	}
	onMousePress(mouseState) {
	}
	onMouseRelease(mouseState) {
	}
	onMouseEnter(mouseState) {
	}
	onMouseLeave(mouseState) {
	}
	onMouseMove(mouseState) {
	}
	onScroll(scrollX,scrollY) {
	}
	onRemove() {
		let _this = this._flow;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.onRemove();
		}
	}
	renderEngine(engine) {
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.renderEngine(engine);
		}
	}
	onResize(width,height) {
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.onResize(width,height);
		}
	}
}
$hxClasses["gui.GuiControl"] = gui_GuiControl;
gui_GuiControl.__name__ = "gui.GuiControl";
Object.assign(gui_GuiControl.prototype, {
	__class__: gui_GuiControl
	,horizSizing: null
	,vertSizing: null
	,position: null
	,extent: null
	,xScale: null
	,yScale: null
	,children: null
	,parent: null
	,_entered: null
	,_skipNextEvent: null
	,_mousePos: null
	,imageResources: null
	,textureResources: null
	,soundResources: null
	,_disposed: null
	,_flow: null
	,_manualScroll: null
});
class gui_GuiImage extends gui_GuiControl {
	constructor(texture) {
		if(gui_GuiControl._hx_skip_constructor) {
			super();
			return;
		}
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(texture);
	}
	_hx_constructor(texture) {
		this.pressedAction = null;
		super._hx_constructor();
		this.bmp = new h2d_Bitmap(texture);
	}
	render(scene2d,parent) {
		if(parent != null) {
			if(parent.contains(this.bmp)) {
				parent.removeChild(this.bmp);
			}
			parent.addChild(this.bmp);
			let off = this.getOffsetFromParent();
			let props = parent.getProperties(this.bmp);
			props.set_isAbsolute(true);
			let _this = this.bmp;
			_this.posChanged = true;
			_this.x = off.x;
			_this.posChanged = true;
			_this.y = off.y;
		}
		super.render(scene2d,parent);
		let renderRect = this.getRenderRectangle();
		this.bmp.set_width(renderRect.extent.x);
		this.bmp.set_height(renderRect.extent.y);
	}
	dispose() {
		super.dispose();
		let _this = this.bmp;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
	onMouseRelease(mouseState) {
		super.onMouseRelease(mouseState);
		if(this.pressedAction != null) {
			this.pressedAction(new gui_GuiEvent(this));
		}
	}
	onRemove() {
		super.onRemove();
		if(src_MarbleGame.canvas.scene2d.contains(this.bmpFlow)) {
			src_MarbleGame.canvas.scene2d.removeChild(this.bmpFlow);
		}
		if(src_MarbleGame.canvas.scene2d.contains(this.bmp)) {
			src_MarbleGame.canvas.scene2d.removeChild(this.bmp);
		}
		let _this = this.bmp;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
}
$hxClasses["gui.GuiImage"] = gui_GuiImage;
gui_GuiImage.__name__ = "gui.GuiImage";
gui_GuiImage.__super__ = gui_GuiControl;
Object.assign(gui_GuiImage.prototype, {
	__class__: gui_GuiImage
	,bmp: null
	,bmpFlow: null
	,pressedAction: null
});
class gui_AboutMenuOptionsGui extends gui_GuiImage {
	constructor(pauseGui) {
		if(pauseGui == null) {
			pauseGui = false;
		}
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("HOW TO PLAY");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		this.btnList = new gui_GuiXboxList();
		this.btnList.position = new h3d_Vector(70 - offsetX,165);
		this.btnList.horizSizing = gui_HorizSizing.Left;
		this.btnList.extent = new h3d_Vector(502,500);
		this.innerCtrl.addChild(this.btnList);
		let _gthis = this;
		if(pauseGui) {
			this.btnList.addButton(5,"Marble Controls",function(e) {
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.canvas.pushDialog(new gui_HelpCreditsGui(4,true));
			});
			this.btnList.addButton(5,"Powerups",function(e) {
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.canvas.pushDialog(new gui_HelpCreditsGui(0,true));
			});
			this.btnList.addButton(5,"Blast Meter",function(e) {
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.canvas.pushDialog(new gui_HelpCreditsGui(1,true));
			});
			this.btnList.addButton(5,"Single Player Mode",function(e) {
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.canvas.pushDialog(new gui_HelpCreditsGui(2,true));
			});
			this.btnList.addButton(5,"Multiplayer Mode",function(e) {
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.canvas.pushDialog(new gui_HelpCreditsGui(3,true));
			});
		} else {
			this.btnList.addButton(5,"Marble Controls",function(e) {
				src_MarbleGame.canvas.setContent(new gui_HelpCreditsGui(4));
			});
			this.btnList.addButton(5,"Powerups",function(e) {
				src_MarbleGame.canvas.setContent(new gui_HelpCreditsGui(0));
			});
			this.btnList.addButton(5,"Blast Meter",function(e) {
				src_MarbleGame.canvas.setContent(new gui_HelpCreditsGui(1));
			});
			this.btnList.addButton(5,"Single Player Mode",function(e) {
				src_MarbleGame.canvas.setContent(new gui_HelpCreditsGui(2));
			});
			this.btnList.addButton(5,"Multiplayer Mode",function(e) {
				src_MarbleGame.canvas.setContent(new gui_HelpCreditsGui(3));
			});
		}
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Back",160);
		backButton.position = new h3d_Vector(400,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["B"];
		backButton.accelerators = [27,8];
		if(pauseGui) {
			backButton.pressedAction = function(e) {
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.canvas.pushDialog(new gui_OptionsListGui(true));
			};
		} else {
			backButton.pressedAction = function(e) {
				src_MarbleGame.canvas.setContent(new gui_OptionsListGui());
			};
		}
		bottomBar.addChild(backButton);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.btnList.position = new h3d_Vector(70 - offsetX,165);
		super.onResize(width,height);
	}
}
$hxClasses["gui.AboutMenuOptionsGui"] = gui_AboutMenuOptionsGui;
gui_AboutMenuOptionsGui.__name__ = "gui.AboutMenuOptionsGui";
gui_AboutMenuOptionsGui.__super__ = gui_GuiImage;
Object.assign(gui_AboutMenuOptionsGui.prototype, {
	__class__: gui_AboutMenuOptionsGui
	,innerCtrl: null
	,btnList: null
});
class gui_AchievementPopupDlg extends gui_GuiControl {
	constructor(id) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(id);
	}
	_hx_constructor(id) {
		this.lifetime = 0;
		super._hx_constructor();
		this.extent = new h3d_Vector(640,480);
		this.position = new h3d_Vector();
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		let popup = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/achievement/" + id + ".png",src_ResourceLoader.getImage,this.imageResources).toTile());
		popup.horizSizing = gui_HorizSizing.Center;
		popup.vertSizing = gui_VertSizing.Top;
		popup.position = new h3d_Vector(70,225);
		popup.extent = new h3d_Vector(477,90);
		this.addChild(popup);
	}
	update(dt,mouseState) {
		super.update(dt,mouseState);
		this.lifetime += dt;
		if(this.lifetime > 3) {
			src_MarbleGame.canvas.popDialog(this);
			if(this.onFinish != null) {
				this.onFinish();
			}
		}
	}
}
$hxClasses["gui.AchievementPopupDlg"] = gui_AchievementPopupDlg;
gui_AchievementPopupDlg.__name__ = "gui.AchievementPopupDlg";
gui_AchievementPopupDlg.__super__ = gui_GuiControl;
Object.assign(gui_AchievementPopupDlg.prototype, {
	__class__: gui_AchievementPopupDlg
	,lifetime: null
	,onFinish: null
});
class gui_AchievementsGui extends gui_GuiImage {
	constructor(isPause) {
		if(isPause == null) {
			isPause = false;
		}
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		this.achievementsWnd = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/achievementWindow.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		this.achievementsWnd.horizSizing = gui_HorizSizing.Right;
		this.achievementsWnd.vertSizing = gui_VertSizing.Bottom;
		this.achievementsWnd.position = new h3d_Vector(this.innerCtrl.extent.x / 2 + 25,this.innerCtrl.extent.y / 3);
		this.achievementsWnd.extent = new h3d_Vector(640,480);
		this.innerCtrl.addChild(this.achievementsWnd);
		let _gthis = this;
		let imgLoader = function(path) {
			switch(path) {
			case "locked":
				let t = src_ResourceLoader.getResource("data/ui/xbox/DemoOutOfTimeIcon.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				t.scaleToSize(t.width * src_Settings.uiScale,t.height * src_Settings.uiScale);
				return t;
			case "unlocked":
				let t1 = src_ResourceLoader.getResource("data/ui/xbox/Ready.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				t1.scaleToSize(t1.width * src_Settings.uiScale,t1.height * src_Settings.uiScale);
				return t1;
			}
			return null;
		};
		let curSelection = -1;
		gui_AchievementsGui.check();
		let achNameDisplays = ["<img src='locked'></img>Timely Marble","<img src='locked'></img>Apprentice's Badge","<img src='locked'></img>Journeyman's Badge","<img src='locked'></img>Adept's Badge","<img src='locked'></img>Marble-fu Initiate","<img src='locked'></img>Marble-fu Master","<img src='locked'></img>Marble-fu Transcendent","<img src='locked'></img>Egg Seeker","<img src='locked'></img>Egg Basket","<img src='locked'></img>First Place","<img src='locked'></img>Gem Collector","<img src='locked'></img>Veteran Battler","<img src='locked'></img>Blue Gem Hunt","<img src='locked'></img>Map Pack Dominator","<img src='locked'></img>Master of the Spires"];
		if((src_Settings.achievementProgression & 1) == 1) {
			achNameDisplays[0] = "<img src='unlocked'></img>Timely Marble";
		}
		if((src_Settings.achievementProgression & 2) == 2) {
			achNameDisplays[1] = "<img src='unlocked'></img>Apprentice's Badge";
		}
		if((src_Settings.achievementProgression & 4) == 4) {
			achNameDisplays[2] = "<img src='unlocked'></img>Journeyman's Badge";
		}
		if((src_Settings.achievementProgression & 8) == 8) {
			achNameDisplays[3] = "<img src='unlocked'></img>Adept's Badge";
		}
		if((src_Settings.achievementProgression & 16) == 16) {
			achNameDisplays[4] = "<img src='unlocked'></img>Marble-fu Initiate";
		}
		if((src_Settings.achievementProgression & 32) == 32) {
			achNameDisplays[5] = "<img src='unlocked'></img>Marble-fu Master";
		}
		if((src_Settings.achievementProgression & 64) == 64) {
			achNameDisplays[6] = "<img src='unlocked'></img>Marble-fu Transcendent";
		}
		if((src_Settings.achievementProgression & 128) == 128) {
			achNameDisplays[7] = "<img src='unlocked'></img>Egg Seeker";
		}
		if((src_Settings.achievementProgression & 256) == 256) {
			achNameDisplays[8] = "<img src='unlocked'></img>Egg Basket";
		}
		if((src_Settings.achievementProgression & 512) == 512) {
			achNameDisplays[9] = "<img src='unlocked'></img>First Place";
		}
		if((src_Settings.achievementProgression & 1024) == 1024) {
			achNameDisplays[10] = "<img src='unlocked'></img>Gem Collector";
		}
		if((src_Settings.achievementProgression & 2048) == 2048) {
			achNameDisplays[11] = "<img src='unlocked'></img>Veteran Battler";
		}
		if((src_Settings.achievementProgression & 4096) == 4096) {
			achNameDisplays[12] = "<img src='unlocked'></img>Blue Gem Hunt";
		}
		if((src_Settings.achievementProgression & 8192) == 8192) {
			achNameDisplays[13] = "<img src='unlocked'></img>Map Pack Dominator";
		}
		if((src_Settings.achievementProgression & 16384) == 16384) {
			achNameDisplays[14] = "<img src='unlocked'></img>Master of the Spires";
		}
		let achievementsList = new gui_GuiMLTextListCtrl(arial14,achNameDisplays,imgLoader);
		achievementsList.selectedColor = 15897877;
		achievementsList.selectedFillColor = 15461355;
		achievementsList.position = new h3d_Vector(25,22);
		achievementsList.extent = new h3d_Vector(550,480);
		achievementsList.scrollable = true;
		achievementsList.onSelectedFunc = function(sel) {
			curSelection = sel;
		};
		this.achievementsWnd.addChild(achievementsList);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Back",160);
		backButton.position = new h3d_Vector(400,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["B"];
		backButton.accelerators = [27,8];
		if(isPause) {
			backButton.pressedAction = function(e) {
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.instance.showPauseUI();
			};
		} else {
			backButton.pressedAction = function(e) {
				src_MarbleGame.canvas.setContent(new gui_MainMenuGui());
			};
		}
		bottomBar.addChild(backButton);
		let nextButton = new gui_GuiXboxButton("Details",160);
		nextButton.position = new h3d_Vector(960,0);
		nextButton.vertSizing = gui_VertSizing.Bottom;
		nextButton.horizSizing = gui_HorizSizing.Right;
		nextButton.accelerators = [13];
		nextButton.gamepadAccelerator = ["X"];
		nextButton.pressedAction = function(e) {
			let desc = "Select an achievement from the list.";
			let selection = curSelection;
			switch(selection) {
			case 0:
				desc = "Finish any level under par time.";
				break;
			case 1:
				desc = "Complete all Beginner levels.";
				break;
			case 2:
				desc = "Complete all Intermediate levels.";
				break;
			case 3:
				desc = "Complete all Advanced levels.";
				break;
			case 4:
				desc = "Finish all Beginner levels under par time.";
				break;
			case 5:
				desc = "Finish all Intermediate levels under par time.";
				break;
			case 6:
				desc = "Finish all Advanced levels under par time.";
				break;
			case 7:
				desc = "Find any hidden easter egg.";
				break;
			case 8:
				desc = "Find all twenty easter eggs.";
				break;
			case 9:
				desc = "Get first place in a multiplayer match.";
				break;
			case 10:
				desc = "Get 75 points in a multiplayer match.";
				break;
			case 11:
				desc = "Collect 2,000 total points in multiplayer.";
				break;
			case 12:
				desc = "Collect a blue gem in a Marble It Up! multiplayer match.";
				break;
			case 13:
				desc = "Get 40 gems in any 3 of the Playground, Bowl, Concentric, Vortex Effect, Blast Club (Marble Fu Pack).";
				break;
			case 14:
				desc = "Collect 50 gems in Spires (Agoraphobia pack).";
				break;
			}
			src_MarbleGame.canvas.pushDialog(new gui_MessageBoxOkDlg(desc));
		};
		bottomBar.addChild(nextButton);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.achievementsWnd.position = new h3d_Vector(this.innerCtrl.extent.x / 2 + 25,this.innerCtrl.extent.y / 3);
		super.onResize(width,height);
	}
	static queueMPAchievement(mpAchFlag) {
		gui_AchievementsGui.mpAchs |= mpAchFlag;
	}
	static check() {
		let completions_h = Object.create(null);
		let totalEggs = 0;
		let totalPars = 0;
		let notifies = 0;
		let h = src_MissionList.missionList.h["ultra"].h;
		let _g_keys = Object.keys(h);
		let _g_length = _g_keys.length;
		let _g_current = 0;
		while(_g_current < _g_length) {
			let key = _g_keys[_g_current++];
			let _g_value = h[key];
			let result = new Array(_g_value.length);
			let _g = 0;
			let _g1 = _g_value.length;
			while(_g < _g1) {
				let i = _g++;
				let mis = _g_value[i];
				let misScores = src_Settings.getScores(mis.path);
				let tmp;
				if(misScores.length == 0) {
					tmp = { mission : mis, beatPar : false, beaten : false};
				} else {
					let bestTime = misScores[0];
					let beatPar = bestTime.time < mis.qualifyTime;
					if(beatPar) {
						++totalPars;
					}
					if(Object.prototype.hasOwnProperty.call(src_Settings.easterEggs.h,mis.path)) {
						++totalEggs;
					}
					tmp = { mission : mis, beatPar : beatPar, beaten : true};
				}
				result[i] = tmp;
			}
			completions_h[key] = result;
		}
		if((src_Settings.achievementProgression & 1) != 1) {
			if(totalPars > 0) {
				src_Settings.achievementProgression |= 1;
				notifies = 1;
			}
		}
		if((src_Settings.achievementProgression & 2) != 2) {
			let _this = completions_h["beginner"];
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(v.beaten) {
					_g.push(v);
				}
			}
			if(_g.length == completions_h["beginner"].length) {
				src_Settings.achievementProgression |= 2;
				notifies |= 2;
			}
		}
		if((src_Settings.achievementProgression & 4) != 4) {
			let _this = completions_h["intermediate"];
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(v.beaten) {
					_g.push(v);
				}
			}
			if(_g.length == completions_h["intermediate"].length) {
				src_Settings.achievementProgression |= 4;
				notifies |= 4;
			}
		}
		if((src_Settings.achievementProgression & 8) != 8) {
			let _this = completions_h["advanced"];
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(v.beaten) {
					_g.push(v);
				}
			}
			if(_g.length == completions_h["advanced"].length) {
				src_Settings.achievementProgression |= 8;
				notifies |= 8;
			}
		}
		if((src_Settings.achievementProgression & 16) != 16) {
			let _this = completions_h["beginner"];
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(v.beatPar) {
					_g.push(v);
				}
			}
			if(_g.length == completions_h["beginner"].length) {
				src_Settings.achievementProgression |= 16;
				notifies |= 16;
			}
		}
		if((src_Settings.achievementProgression & 32) != 32) {
			let _this = completions_h["intermediate"];
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(v.beatPar) {
					_g.push(v);
				}
			}
			if(_g.length == completions_h["intermediate"].length) {
				src_Settings.achievementProgression |= 32;
				notifies |= 32;
			}
		}
		if((src_Settings.achievementProgression & 64) != 64) {
			let _this = completions_h["advanced"];
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(v.beatPar) {
					_g.push(v);
				}
			}
			if(_g.length == completions_h["advanced"].length) {
				src_Settings.achievementProgression |= 64;
				notifies |= 64;
			}
		}
		if((src_Settings.achievementProgression & 128) != 128) {
			if(totalEggs >= 1) {
				src_Settings.achievementProgression |= 128;
				notifies |= 128;
			}
		}
		if((src_Settings.achievementProgression & 256) != 256) {
			if(totalEggs >= 20) {
				src_Settings.achievementProgression |= 256;
				notifies |= 256;
			}
		}
		if((src_Settings.achievementProgression & 512) != 512) {
			if((gui_AchievementsGui.mpAchs & 512) == 512) {
				src_Settings.achievementProgression |= 512;
				notifies |= 512;
			}
		}
		if((src_Settings.achievementProgression & 1024) != 1024) {
			if((gui_AchievementsGui.mpAchs & 1024) == 1024) {
				src_Settings.achievementProgression |= 1024;
				notifies |= 1024;
			}
		}
		if((src_Settings.achievementProgression & 2048) != 2048) {
			if((gui_AchievementsGui.mpAchs & 2048) == 2048) {
				src_Settings.achievementProgression |= 2048;
				notifies |= 2048;
			}
		}
		if((src_Settings.achievementProgression & 4096) != 4096) {
			if((gui_AchievementsGui.mpAchs & 4096) == 4096) {
				src_Settings.achievementProgression |= 4096;
				notifies |= 4096;
			}
		}
		if((src_Settings.achievementProgression & 8192) != 8192) {
			if((gui_AchievementsGui.mpAchs & 8192) == 8192) {
				src_Settings.achievementProgression |= 8192;
				notifies |= 8192;
			}
		}
		if((src_Settings.achievementProgression & 16384) != 16384) {
			if((gui_AchievementsGui.mpAchs & 16384) == 16384) {
				src_Settings.achievementProgression |= 16384;
				notifies |= 16384;
			}
		}
		gui_AchievementsGui.mpAchs = 0;
		let showdlgs = [];
		if((notifies & 1) > 0) {
			let popup = new gui_AchievementPopupDlg(1);
			showdlgs.push(popup);
		}
		if((notifies & 2) > 0) {
			let popup = new gui_AchievementPopupDlg(2);
			showdlgs.push(popup);
		}
		if((notifies & 4) > 0) {
			let popup = new gui_AchievementPopupDlg(3);
			showdlgs.push(popup);
		}
		if((notifies & 8) > 0) {
			let popup = new gui_AchievementPopupDlg(4);
			showdlgs.push(popup);
		}
		if((notifies & 16) > 0) {
			let popup = new gui_AchievementPopupDlg(5);
			showdlgs.push(popup);
		}
		if((notifies & 32) > 0) {
			let popup = new gui_AchievementPopupDlg(6);
			showdlgs.push(popup);
		}
		if((notifies & 64) > 0) {
			let popup = new gui_AchievementPopupDlg(7);
			showdlgs.push(popup);
		}
		if((notifies & 128) > 0) {
			let popup = new gui_AchievementPopupDlg(8);
			showdlgs.push(popup);
		}
		if((notifies & 256) > 0) {
			let popup = new gui_AchievementPopupDlg(9);
			showdlgs.push(popup);
		}
		if(showdlgs.length > 1) {
			let _g = 0;
			let _g1 = showdlgs.length - 1;
			while(_g < _g1) {
				let i = _g++;
				showdlgs[i].onFinish = function() {
					src_MarbleGame.canvas.pushDialog(showdlgs[i + 1]);
				};
			}
		}
		if(showdlgs.length != 0) {
			src_MarbleGame.canvas.pushDialog(showdlgs[0]);
		}
		return notifies;
	}
}
$hxClasses["gui.AchievementsGui"] = gui_AchievementsGui;
gui_AchievementsGui.__name__ = "gui.AchievementsGui";
gui_AchievementsGui.__super__ = gui_GuiImage;
Object.assign(gui_AchievementsGui.prototype, {
	__class__: gui_AchievementsGui
	,innerCtrl: null
	,achievementsWnd: null
});
class gui_Canvas extends gui_GuiControl {
	constructor(scene,marbleGame) {
		super();
		src_Console.instance.addEntry("log","Creating canvas");
		this.scene2d = scene;
		this.marbleGame = marbleGame;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
	}
	setContent(content) {
		this.dispose();
		this.content = content;
		this.addChild(content);
		this.render(this.scene2d);
	}
	pushDialog(content) {
		this.addChild(content);
		content.render(this.scene2d,this._flow);
	}
	popDialog(content,dispose) {
		if(dispose == null) {
			dispose = true;
		}
		if(dispose) {
			content.dispose();
		}
		this.removeChild(content);
		this.render(this.scene2d);
	}
	clearContent() {
		this.dispose();
		this.render(this.scene2d);
	}
	update(dt,mouseState) {
		if(this.children.length > 0) {
			this.children[this.children.length - 1].update(dt,mouseState);
		}
	}
	renderEngine(e) {
		if(this.children.length > 0) {
			this.children[this.children.length - 1].renderEngine(e);
		}
	}
}
$hxClasses["gui.Canvas"] = gui_Canvas;
gui_Canvas.__name__ = "gui.Canvas";
gui_Canvas.__super__ = gui_GuiControl;
Object.assign(gui_Canvas.prototype, {
	__class__: gui_Canvas
	,scene2d: null
	,marbleGame: null
	,content: null
});
class gui_ChatMessage {
	constructor(text,age) {
		this.text = text;
		this.age = age;
	}
}
$hxClasses["gui.ChatMessage"] = gui_ChatMessage;
gui_ChatMessage.__name__ = "gui.ChatMessage";
Object.assign(gui_ChatMessage.prototype, {
	__class__: gui_ChatMessage
	,text: null
	,age: null
});
class gui_ChatCtrl extends gui_GuiControl {
	constructor() {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.chatFocused = false;
		super._hx_constructor();
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(15 * src_Settings.uiScale,4);
		this.chats = [];
		this.chatHudBg = new gui_GuiMLText(arial14,function(s) {
			return arial14;
		});
		this.chatHudBg.position = new h3d_Vector(1,21);
		this.chatHudBg.extent = new h3d_Vector(200,250);
		this.chatHudBg.text.set_textColor(0);
		this.addChild(this.chatHudBg);
		this.chatHud = new gui_GuiMLText(arial14,function(s) {
			return arial14;
		});
		this.chatHud.position = new h3d_Vector(0,20);
		this.chatHud.extent = new h3d_Vector(200,250);
		this.addChild(this.chatHud);
		this.chatInputBg = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/fade_black.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		this.chatInputBg.position = new h3d_Vector(0,0);
		this.chatInputBg.extent = new h3d_Vector(200,20);
		this.addChild(this.chatInputBg);
		this.chatInputBgText = new gui_GuiText(arial14);
		this.chatInputBgText.position = new h3d_Vector(0,0);
		this.chatInputBgText.extent = new h3d_Vector(200,20);
		this.chatInputBg.addChild(this.chatInputBgText);
		this.chatInputBgText.text.set_textColor(15897877);
		this.chatInputBgText.text.set_text("Chat:");
		this.chatHudInput = new gui_GuiTextInput(arial14);
		this.chatHudInput.position = new h3d_Vector(40,0);
		this.chatHudInput.extent = new h3d_Vector(160,20);
		this.chatHudInput.text.interactive.forceAnywherefocus = true;
		this.addChild(this.chatHudInput);
		this.chatInputBgText.text.set_visible(false);
		this.chatInputBg.bmp.set_visible(false);
		let sendText = "";
		let _gthis = this;
		this.chatHudInput.text.onFocus = function(e) {
			_gthis.chatInputBgText.text.set_visible(true);
			_gthis.chatInputBg.bmp.set_visible(true);
			_gthis.chatFocused = true;
		};
		this.chatHudInput.text.onFocusLost = function(e) {
			_gthis.chatInputBgText.text.set_visible(false);
			_gthis.chatInputBg.bmp.set_visible(false);
			_gthis.chatHudInput.text.set_text("");
			sendText = "";
			_gthis.chatFocused = false;
		};
		this.chatHudInput.text.onKeyDown = function(e) {
			if(e.keyCode == 13) {
				if(StringTools.trim(_gthis.chatHudInput.text.text) != "") {
					sendText = "<font color=\"#F29515\">" + StringTools.htmlEscape(HxOverrides.substr(src_Settings.highscoreName,0,30)) + ":</font> " + StringTools.htmlEscape(HxOverrides.substr(_gthis.chatHudInput.text.text,0,100));
					if(net_Net.isClient) {
						net_NetCommands.sendChatMessage(StringTools.htmlEscape(sendText));
					}
					if(net_Net.isHost) {
						net_NetCommands.sendServerChatMessage(StringTools.htmlEscape(sendText));
					}
				}
				_gthis.chatHudInput.text.set_text("");
				_gthis.chatInputBgText.text.set_visible(false);
				_gthis.chatInputBg.bmp.set_visible(false);
				_gthis.chatFocused = false;
			}
			if(e.keyCode == 27) {
				_gthis.chatHudInput.text.set_text("");
				_gthis.chatInputBgText.text.set_visible(false);
				_gthis.chatInputBg.bmp.set_visible(false);
				_gthis.chatFocused = false;
				hxd_Key.keyPressed[27] = 0;
			}
			hxd_Key.keyPressed[e.keyCode] = 0;
		};
		this.chatHud.text.set_text("");
	}
	addChatMessage(text) {
		let realText = StringTools.htmlUnescape(text);
		this.chats.push(new gui_ChatMessage(realText,10.0));
		if(this.chats.length > 10) {
			this.chats = this.chats.slice(this.chats.length - 10);
		}
		this.redrawChatMessages();
	}
	redrawChatMessages() {
		let _this = this.chats;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _this[i].text;
		}
		let joined = result.join("<br/>");
		this.chatHud.text.set_text(joined);
		this.chatHudBg.text.set_text(StringTools.replace(joined,"#F29515","#000000"));
	}
	tickChats(dt) {
		let needsRedraw = false;
		let chatsToRemove = [];
		let _g = 0;
		let _g1 = this.chats;
		while(_g < _g1.length) {
			let chat = _g1[_g];
			++_g;
			chat.age -= dt;
			if(chat.age < 0) {
				chatsToRemove.push(chat);
			}
		}
		while(chatsToRemove.length > 0) {
			HxOverrides.remove(this.chats,chatsToRemove[0]);
			needsRedraw = true;
			chatsToRemove.shift();
		}
		if(needsRedraw) {
			this.redrawChatMessages();
		}
	}
	updateChat(dt) {
		if(!this.chatFocused) {
			if(hxd_Key.isPressed(src_Settings.controlsSettings.chat)) {
				this.chatHudInput.text.focus();
			}
		}
		this.tickChats(dt);
	}
}
$hxClasses["gui.ChatCtrl"] = gui_ChatCtrl;
gui_ChatCtrl.__name__ = "gui.ChatCtrl";
gui_ChatCtrl.__super__ = gui_GuiControl;
Object.assign(gui_ChatCtrl.prototype, {
	__class__: gui_ChatCtrl
	,chatHud: null
	,chatHudBg: null
	,chatHudInput: null
	,chatInputBg: null
	,chatInputBgText: null
	,chats: null
	,chatFocused: null
});
class gui_ConsoleDlg extends gui_GuiControl {
	constructor() {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.cmdHistoryIndex = 0;
		this.cmdHistory = [];
		this.isShowing = false;
		super._hx_constructor();
		this.position = new h3d_Vector(0,0);
		this.extent = new h3d_Vector(640,370);
		let white = h2d_Tile.fromColor(16777215);
		let black = h2d_Tile.fromColor(0);
		let consoleWhite = new gui_GuiImage(white);
		consoleWhite.position = new h3d_Vector(0,0);
		consoleWhite.extent = new h3d_Vector(640,350);
		consoleWhite.horizSizing = gui_HorizSizing.Width;
		consoleWhite.vertSizing = gui_VertSizing.Top;
		this.addChild(consoleWhite);
		this.scroll = new gui_GuiConsoleScrollCtrl(src_ResourceLoader.getResource("data/ui/common/darkscroll.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		this.scroll.position = new h3d_Vector(0,0);
		this.scroll.extent = new h3d_Vector(640,350);
		this.scroll.horizSizing = gui_HorizSizing.Width;
		this.scroll.vertSizing = gui_VertSizing.Height;
		consoleWhite.addChild(this.scroll);
		let consolefontdata = src_ResourceLoader.getFileEntry("data/font/Lucida Console.fnt");
		let consoleb = new hxd_res_BitmapFont(consolefontdata.entry);
		consoleb.loader = src_ResourceLoader.loader;
		let consoleb1 = consoleb.toSdfFont(11.7 * src_Settings.uiScale,4);
		let mlFontLoader = function(text) {
			return null;
		};
		this.consoleContent = new gui_GuiMLText(consoleb1,mlFontLoader);
		this.consoleContent.position = new h3d_Vector(0,0);
		this.consoleContent.extent = new h3d_Vector(640,350);
		this.consoleContent.horizSizing = gui_HorizSizing.Width;
		this.consoleContent.vertSizing = gui_VertSizing.Top;
		this.consoleContent.text.set_textColor(0);
		this.consoleContent.scrollable = true;
		this.scroll.addChild(this.consoleContent);
		this.consoleContent.text.set_text("");
		let _g = 0;
		let _g1 = src_Console.instance.entries;
		while(_g < _g1.length) {
			let entry = _g1[_g];
			++_g;
			let txt = "[" + entry.time + "] " + StringTools.htmlEscape(entry.text) + "<br/>";
			let fh = this.consoleContent.text;
			fh.set_text(fh.text + txt);
		}
		this.scroll.setScrollMax(this.consoleContent.text.get_textHeight());
		this.scroll.updateScrollVisual();
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/arial.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(14 * src_Settings.uiScale,4);
		let bord = new gui_GuiImage(black);
		bord.position = new h3d_Vector(0,350);
		bord.extent = new h3d_Vector(640,18);
		bord.horizSizing = gui_HorizSizing.Width;
		this.addChild(bord);
		this.consoleInput = new gui_GuiTextInput(arial14);
		this.consoleInput.position = new h3d_Vector(1,351);
		this.consoleInput.extent = new h3d_Vector(638,20);
		this.consoleInput.horizSizing = gui_HorizSizing.Width;
		this.consoleInput.vertSizing = gui_VertSizing.Top;
		this.consoleInput.text.set_textColor(0);
		this.consoleInput.text.set_backgroundColor(-1);
		let _this = this.consoleInput.text.selectionColor;
		_this.x = 1;
		_this.y = 1;
		_this.z = 1;
		_this.w = 1.;
		this.consoleInput.text.selectionTile = h2d_Tile.fromColor(8421504,0,Math.ceil(this.consoleInput.text.font.lineHeight));
		this.consoleInput.text.onKeyDown = function(e) {
			if(e.keyCode == 192) {
				e.cancel = true;
			}
		};
		this.consoleInput.text.onTextInput = function(e) {
			if(e.charCode == 96) {
				e.cancel = true;
			}
		};
		this.addChild(this.consoleInput);
		let _gthis = this;
		this.onConsoleEntry = function(e) {
			let txt = "[" + e.time + "] " + StringTools.htmlEscape(e.text) + "<br/>";
			let fh = _gthis.consoleContent.text;
			fh.set_text(fh.text + txt);
			if(_gthis.isShowing) {
				_gthis.scroll.setScrollMax(_gthis.consoleContent.text.get_textHeight());
			}
		};
		src_Console.instance.consumers.push(this.onConsoleEntry);
	}
	dispose() {
		super.dispose();
		HxOverrides.remove(src_Console.instance.consumers,this.onConsoleEntry);
	}
	render(scene2d,parent) {
		super.render(scene2d,parent);
		this.scroll.setScrollMax(this.consoleContent.text.get_textHeight());
	}
	unfocus() {
		this.consoleInput.text.interactive.blur();
	}
	update(dt,mouseState) {
		super.update(dt,mouseState);
		if(hxd_Key.isPressed(13) && this.consoleInput.text.text != "") {
			let cmdText = this.consoleInput.text.text;
			this.cmdHistory.push(cmdText);
			let fh = this.consoleContent.text;
			fh.set_text(fh.text + ("==> " + cmdText + "<br/>"));
			src_Console.eval(cmdText);
			this.consoleInput.text.set_text("");
			this.consoleInput.text.focus();
		}
		if(hxd_Key.isPressed(38)) {
			if(this.cmdHistoryIndex < this.cmdHistory.length) {
				this.cmdHistoryIndex++;
				this.consoleInput.text.set_text(this.cmdHistory[this.cmdHistory.length - this.cmdHistoryIndex]);
			}
		}
		if(hxd_Key.isPressed(40)) {
			if(this.cmdHistoryIndex > 1) {
				this.cmdHistoryIndex--;
				this.consoleInput.text.set_text(this.cmdHistory[this.cmdHistory.length - this.cmdHistoryIndex]);
			}
		}
	}
}
$hxClasses["gui.ConsoleDlg"] = gui_ConsoleDlg;
gui_ConsoleDlg.__name__ = "gui.ConsoleDlg";
gui_ConsoleDlg.__super__ = gui_GuiControl;
Object.assign(gui_ConsoleDlg.prototype, {
	__class__: gui_ConsoleDlg
	,onConsoleEntry: null
	,isShowing: null
	,consoleContent: null
	,scroll: null
	,consoleInput: null
	,cmdHistory: null
	,cmdHistoryIndex: null
});
class gui_CreateMatchGui extends gui_GuiImage {
	constructor() {
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("CREATE MATCH");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let optionCollection = new gui_GuiXboxOptionsListCollection();
		optionCollection.position = new h3d_Vector(380,373);
		optionCollection.extent = new h3d_Vector(815,500);
		this.innerCtrl.addChild(optionCollection);
		let maxPlayers = 8;
		let privateSlots = 0;
		let privateGame = false;
		let playerOpt = optionCollection.addOption(1,"Max Players",["2","3","4","5","6","7","8"],function(idx) {
			let newMaxPlayers = idx + 2;
			if(privateSlots >= newMaxPlayers) {
				return false;
			}
			maxPlayers = idx + 2;
			return true;
		},0.5,118);
		playerOpt.setCurrentOption(6);
		optionCollection.addOption(1,"Private Slots",["None","1","2","3","4","5","6","7"],function(idx) {
			if(idx >= maxPlayers) {
				return false;
			}
			privateSlots = idx;
			return true;
		},0.5,118);
		optionCollection.addOption(1,"Private Game",["No","Yes"],function(idx) {
			privateGame = idx == 1;
			return true;
		},0.5,118);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Back",160);
		backButton.position = new h3d_Vector(400,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["B"];
		backButton.accelerators = [27,8];
		backButton.pressedAction = function(e) {
			src_MarbleGame.canvas.setContent(new gui_MultiplayerGui());
		};
		bottomBar.addChild(backButton);
		let nextButton = new gui_GuiXboxButton("Go",160);
		nextButton.position = new h3d_Vector(960,0);
		nextButton.vertSizing = gui_VertSizing.Bottom;
		nextButton.horizSizing = gui_HorizSizing.Right;
		nextButton.gamepadAccelerator = ["A"];
		nextButton.accelerators = [13];
		nextButton.pressedAction = function(e) {
			net_Net.hostServer("" + src_Settings.highscoreName + "'s Server",maxPlayers,privateSlots,privateGame,function() {
				src_MarbleGame.canvas.setContent(new gui_MultiplayerLevelSelectGui(true));
			});
		};
		bottomBar.addChild(nextButton);
	}
}
$hxClasses["gui.CreateMatchGui"] = gui_CreateMatchGui;
gui_CreateMatchGui.__name__ = "gui.CreateMatchGui";
gui_CreateMatchGui.__super__ = gui_GuiImage;
Object.assign(gui_CreateMatchGui.prototype, {
	__class__: gui_CreateMatchGui
	,innerCtrl: null
});
class gui_DifficultySelectGui extends gui_GuiImage {
	constructor() {
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("SELECT DIFFICULTY");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		this.btnList = new gui_GuiXboxList();
		this.btnList.position = new h3d_Vector(70 - offsetX,165);
		this.btnList.horizSizing = gui_HorizSizing.Left;
		this.btnList.extent = new h3d_Vector(502,500);
		this.innerCtrl.addChild(this.btnList);
		this.btnList.addButton(0,"Beginner Levels",function(e) {
			src_MarbleGame.canvas.setContent(new gui_LevelSelectGui("beginner"));
		});
		this.btnList.addButton(0,"Intermediate Levels",function(e) {
			src_MarbleGame.canvas.setContent(new gui_LevelSelectGui("intermediate"));
		});
		this.btnList.addButton(0,"Advanced Levels",function(e) {
			src_MarbleGame.canvas.setContent(new gui_LevelSelectGui("advanced"));
		});
		this.btnList.addButton(0,"Gem Hunt",function(e) {
			src_MarbleGame.canvas.setContent(new gui_LevelSelectGui("multiplayer"));
		},20);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Back",160);
		backButton.position = new h3d_Vector(400,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["B"];
		backButton.accelerators = [27,8];
		backButton.pressedAction = function(e) {
			src_MarbleGame.canvas.setContent(new gui_MainMenuGui());
		};
		bottomBar.addChild(backButton);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.btnList.position = new h3d_Vector(70 - offsetX,165);
		super.onResize(width,height);
	}
}
$hxClasses["gui.DifficultySelectGui"] = gui_DifficultySelectGui;
gui_DifficultySelectGui.__name__ = "gui.DifficultySelectGui";
gui_DifficultySelectGui.__super__ = gui_GuiImage;
Object.assign(gui_DifficultySelectGui.prototype, {
	__class__: gui_DifficultySelectGui
	,innerCtrl: null
	,btnList: null
});
class gui_EndGameGui extends gui_GuiImage {
	constructor(continueFunc,restartFunc,nextLevelFunc,mission,score,scoreType,replayData) {
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector(0,0);
		this.extent = new h3d_Vector(640,480);
		this.mission = mission;
		this.retryFunc = restartFunc;
		this.nextFunc = nextLevelFunc;
		this.continueFunc = continueFunc;
		let _gthis = this;
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("LEVEL COMPLETE!");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		this.endGameWnd = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/endGameWindow.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		this.endGameWnd.horizSizing = gui_HorizSizing.Right;
		this.endGameWnd.vertSizing = gui_VertSizing.Bottom;
		this.endGameWnd.position = new h3d_Vector(720,420);
		this.endGameWnd.extent = new h3d_Vector(336,150);
		this.innerCtrl.addChild(this.endGameWnd);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(22 * src_Settings.uiScale,4);
		let statIcon = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/statIcon.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		statIcon.position = new h3d_Vector(38,27);
		statIcon.extent = new h3d_Vector(20,20);
		this.endGameWnd.addChild(statIcon);
		let mlFontLoader = function(text) {
			return arial14;
		};
		let beatPar = score < mission.qualifyTime;
		let egResultLeft = new gui_GuiMLText(arial14,mlFontLoader);
		egResultLeft.position = new h3d_Vector(28,26);
		egResultLeft.extent = new h3d_Vector(180,100);
		if(scoreType == modes_ScoreType.Time) {
			egResultLeft.text.set_text("<p align=\"right\"><font color=\"" + (beatPar ? "#8DFF8D" : "#FF7575") + "\">Time:</font><br/><font color=\"#88BCEE\">Par Time:</font><br/><font color=\"#EBEBEB\">Rating:</font><br/><font color=\"#EBEBEB\">My Best Time:</font></p>");
		}
		if(scoreType == modes_ScoreType.Score) {
			egResultLeft.text.set_text("<p align=\"right\"><font color=\"#8DFF8D\">Score:</font><br/><font color=\"#EBEBEB\">My Best Score:</font></p>");
		}
		this.endGameWnd.addChild(egResultLeft);
		let calcRating = function(time,parTime,goldTime,difficulty) {
			let t = time - time % 10;
			if(t == 0) {
				return 0;
			}
			let timeBonus = 0;
			if(t < parTime) {
				timeBonus = Math.floor(parTime / t) * 1000;
			} else {
				timeBonus = Math.floor(parTime / t) * 500;
			}
			return (1000 + timeBonus) * difficulty;
		};
		let rating = calcRating(score * 1000,mission.qualifyTime * 1000,mission.goldTime * 1000,Std.parseInt(mission.missionInfo.difficulty));
		let scoreData = src_Settings.getScores(mission.path);
		while(scoreData.length < 1) {
			if(scoreType == modes_ScoreType.Score) {
				scoreData.push({ name : "Nardo Polo", time : 0});
			}
			if(scoreType == modes_ScoreType.Time) {
				scoreData.push({ name : "Nardo Polo", time : 5999.999});
			}
		}
		let bestScore = scoreData[0];
		let egResultRight = new gui_GuiMLText(arial14,mlFontLoader);
		egResultRight.position = new h3d_Vector(214,26);
		egResultRight.extent = new h3d_Vector(180,100);
		if(scoreType == modes_ScoreType.Score) {
			let scoreInt = Math.round(score) | 0;
			let scoreInt1 = Math.round(bestScore.time) | 0;
			egResultRight.text.set_text("<font color=\"#8DFF8D\">" + ("" + scoreInt) + "</font><br/><font color=\"#EBEBEB\">" + ("" + scoreInt1) + "</font>");
		}
		if(scoreType == modes_ScoreType.Time) {
			egResultRight.text.set_text("<font color=\"" + (beatPar ? "#8DFF8D" : "#FF7575") + "\">" + src_Util.formatTime(score) + "</font><br/><font color=\"#88BCEE\">" + src_Util.formatTime(mission.qualifyTime) + "</font><br/><font color=\"#EBEBEB\">" + rating + "</font><br/><font color=\"#EBEBEB\">" + src_Util.formatTime(bestScore.time) + "</font>");
		}
		this.endGameWnd.addChild(egResultRight);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		if(!net_Net.isMP || net_Net.isHost) {
			let retryButton = new gui_GuiXboxButton("Retry",160);
			retryButton.position = new h3d_Vector(400,0);
			retryButton.vertSizing = gui_VertSizing.Bottom;
			retryButton.horizSizing = gui_HorizSizing.Right;
			retryButton.gamepadAccelerator = ["B"];
			retryButton.accelerators = [27,8];
			retryButton.pressedAction = function(e) {
				if(src_MarbleGame.canvas.children.length == 1) {
					restartFunc(retryButton);
				}
			};
			bottomBar.addChild(retryButton);
		}
		let nextButton = new gui_GuiXboxButton("Next",160);
		nextButton.position = new h3d_Vector(960,0);
		nextButton.vertSizing = gui_VertSizing.Bottom;
		nextButton.horizSizing = gui_HorizSizing.Right;
		nextButton.gamepadAccelerator = ["A"];
		nextButton.accelerators = [13];
		nextButton.pressedAction = function(e) {
			if(src_MarbleGame.canvas.children.length == 1) {
				continueFunc(nextButton);
			}
		};
		bottomBar.addChild(nextButton);
		let submitScore = function() {
			let lbScoreValue = score;
			if(scoreType == modes_ScoreType.Score) {
				lbScoreValue = 1000 - score;
			}
			src_Leaderboards.submitScore(mission.path,lbScoreValue,src_MarbleGame.instance.world.rewindUsed,function(needsReplay,ref) {
				if(needsReplay) {
					src_Leaderboards.submitReplay(ref,replayData);
				}
			});
		};
		if(bestScore.time == score) {
			if(src_Settings.highscoreName == "" || src_Settings.highscoreName == "Player" || src_Settings.highscoreName == "Player Name") {
				haxe_Timer.delay(function() {
					src_MarbleGame.canvas.pushDialog(new gui_EnterNamePopupDlg(function() {
						submitScore();
					}));
				},100);
			} else {
				submitScore();
			}
		} else {
			src_Leaderboards.getScores(mission.path,0,function(lbscores) {
				let foundScore = false;
				let foundLBScore = 0;
				let _g = 0;
				while(_g < lbscores.length) {
					let lb = lbscores[_g];
					++_g;
					if(lb.name == src_Settings.highscoreName) {
						foundScore = true;
						foundLBScore = lb.score;
						break;
					}
				}
				if(!foundScore) {
					submitScore();
				} else if(foundLBScore > score) {
					submitScore();
				}
			});
		}
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.EndGameGui"] = gui_EndGameGui;
gui_EndGameGui.__name__ = "gui.EndGameGui";
gui_EndGameGui.__super__ = gui_GuiImage;
Object.assign(gui_EndGameGui.prototype, {
	__class__: gui_EndGameGui
	,mission: null
	,innerCtrl: null
	,endGameWnd: null
	,retryFunc: null
	,nextFunc: null
	,continueFunc: null
});
class gui_EnterNameDlg extends gui_GuiImage {
	constructor() {
		let res = src_ResourceLoader.getImage("data/ui/xbox/roundedBG.png").resource.toTile();
		super(res);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		let yesNoFrame = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/popupGUI.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		yesNoFrame.horizSizing = gui_HorizSizing.Center;
		yesNoFrame.vertSizing = gui_VertSizing.Center;
		yesNoFrame.position = new h3d_Vector(70,30);
		yesNoFrame.extent = new h3d_Vector(512,400);
		this.addChild(yesNoFrame);
		let yesNoText = new gui_GuiMLText(arial14,null);
		yesNoText.position = new h3d_Vector(103,85);
		yesNoText.extent = new h3d_Vector(313,186);
		yesNoText.text.set_text("Enter your name");
		yesNoText.text.set_textColor(15461355);
		yesNoFrame.addChild(yesNoText);
		let textFrame = new gui_GuiControl();
		textFrame.position = new h3d_Vector(33,107);
		textFrame.extent = new h3d_Vector(232,40);
		textFrame.horizSizing = gui_HorizSizing.Center;
		yesNoFrame.addChild(textFrame);
		let textInput = new gui_GuiTextInput(arial14);
		textInput.position = new h3d_Vector(6,5);
		textInput.extent = new h3d_Vector(216,40);
		textInput.horizSizing = gui_HorizSizing.Width;
		textInput.vertSizing = gui_VertSizing.Height;
		textInput.text.set_textColor(15461355);
		textInput.setCaretColor(15461355);
		let _this = textInput.text.selectionColor;
		_this.x = 0.55294117647058827;
		_this.y = 1.;
		_this.z = 0.55294117647058827;
		_this.w = 0.;
		textInput.text.selectionTile = h2d_Tile.fromColor(8961262,0,Math.ceil(textInput.text.font.lineHeight));
		textFrame.addChild(textInput);
		textInput.text.set_text(src_Settings.highscoreName == "" ? "Player Name" : src_Settings.highscoreName);
		let okButton = new gui_GuiXboxButton("Ok",120);
		okButton.position = new h3d_Vector(211,248);
		okButton.extent = new h3d_Vector(120,94);
		okButton.vertSizing = gui_VertSizing.Top;
		okButton.accelerators = [13];
		okButton.gamepadAccelerator = ["A"];
		okButton.pressedAction = function(sender) {
			src_Settings.highscoreName = HxOverrides.substr(textInput.text.text,0,15);
			src_Settings.save();
			src_MarbleGame.canvas.setContent(new gui_MultiplayerGui());
		};
		yesNoFrame.addChild(okButton);
		let cancelButton = new gui_GuiXboxButton("Cancel",120);
		cancelButton.position = new h3d_Vector(321,248);
		cancelButton.extent = new h3d_Vector(120,94);
		cancelButton.vertSizing = gui_VertSizing.Top;
		cancelButton.accelerators = [13];
		cancelButton.gamepadAccelerator = ["A"];
		cancelButton.pressedAction = function(sender) {
			src_MarbleGame.canvas.setContent(new gui_MultiplayerGui());
		};
		yesNoFrame.addChild(cancelButton);
	}
}
$hxClasses["gui.EnterNameDlg"] = gui_EnterNameDlg;
gui_EnterNameDlg.__name__ = "gui.EnterNameDlg";
gui_EnterNameDlg.__super__ = gui_GuiImage;
Object.assign(gui_EnterNameDlg.prototype, {
	__class__: gui_EnterNameDlg
});
class gui_EnterNamePopupDlg extends gui_GuiImage {
	constructor(callback) {
		let res = src_ResourceLoader.getImage("data/ui/xbox/roundedBG.png").resource.toTile();
		super(res);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		let yesNoFrame = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/popupGUI.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		yesNoFrame.horizSizing = gui_HorizSizing.Center;
		yesNoFrame.vertSizing = gui_VertSizing.Center;
		yesNoFrame.position = new h3d_Vector(70,30);
		yesNoFrame.extent = new h3d_Vector(512,400);
		this.addChild(yesNoFrame);
		let yesNoText = new gui_GuiMLText(arial14,null);
		yesNoText.position = new h3d_Vector(103,85);
		yesNoText.extent = new h3d_Vector(313,186);
		yesNoText.text.set_text("Enter your name");
		yesNoText.text.set_textColor(15461355);
		yesNoFrame.addChild(yesNoText);
		let textFrame = new gui_GuiControl();
		textFrame.position = new h3d_Vector(33,107);
		textFrame.extent = new h3d_Vector(232,40);
		textFrame.horizSizing = gui_HorizSizing.Center;
		yesNoFrame.addChild(textFrame);
		let textInput = new gui_GuiTextInput(arial14);
		textInput.position = new h3d_Vector(6,5);
		textInput.extent = new h3d_Vector(216,40);
		textInput.horizSizing = gui_HorizSizing.Width;
		textInput.vertSizing = gui_VertSizing.Height;
		textInput.text.set_textColor(15461355);
		textInput.setCaretColor(15461355);
		let _this = textInput.text.selectionColor;
		_this.x = 0.55294117647058827;
		_this.y = 1.;
		_this.z = 0.55294117647058827;
		_this.w = 0.;
		textInput.text.selectionTile = h2d_Tile.fromColor(8961262,0,Math.ceil(textInput.text.font.lineHeight));
		textFrame.addChild(textInput);
		textInput.text.set_text(src_Settings.highscoreName == "" ? "Player Name" : src_Settings.highscoreName);
		let okButton = new gui_GuiXboxButton("Ok",120);
		okButton.position = new h3d_Vector(211,248);
		okButton.extent = new h3d_Vector(120,94);
		okButton.vertSizing = gui_VertSizing.Top;
		okButton.accelerators = [13];
		okButton.gamepadAccelerator = ["A"];
		let _gthis = this;
		okButton.pressedAction = function(sender) {
			src_Settings.highscoreName = HxOverrides.substr(textInput.text.text,0,15);
			src_Settings.save();
			src_MarbleGame.canvas.popDialog(_gthis);
			callback();
		};
		yesNoFrame.addChild(okButton);
	}
}
$hxClasses["gui.EnterNamePopupDlg"] = gui_EnterNamePopupDlg;
gui_EnterNamePopupDlg.__name__ = "gui.EnterNamePopupDlg";
gui_EnterNamePopupDlg.__super__ = gui_GuiImage;
Object.assign(gui_EnterNamePopupDlg.prototype, {
	__class__: gui_EnterNamePopupDlg
});
class gui_ExitGameDlg extends gui_GuiImage {
	constructor(yesFunc,noFunc,restartFunc) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(yesFunc,noFunc,restartFunc);
	}
	_hx_constructor(yesFunc,noFunc,restartFunc) {
		this.timeMenu = 0.0;
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super._hx_constructor(res);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let _gthis = this;
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		let subX = 640 - (scene2d.width - offsetX * 2) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY * 2) * 480 / scene2d.height;
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("Paused");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let levelTitle = new gui_GuiText(coliseum);
		levelTitle.position = new h3d_Vector(100,75);
		levelTitle.extent = new h3d_Vector(1120,80);
		levelTitle.text.set_textColor(16777215);
		levelTitle.text.alpha = 0.5;
		levelTitle.text.set_text("Level " + (src_MarbleGame.instance.world.mission.index + 1));
		this.innerCtrl.addChild(levelTitle);
		this.btnList = new gui_GuiXboxList();
		this.btnList.position = new h3d_Vector(70 - offsetX / 2,95);
		this.btnList.horizSizing = gui_HorizSizing.Left;
		this.btnList.extent = new h3d_Vector(502,500);
		this.innerCtrl.addChild(this.btnList);
		this.btnList.addButton(0,"Resume",function(evt) {
			noFunc(_gthis.btnList);
		});
		if(!net_Net.isMP) {
			this.btnList.addButton(0,"Restart",function(evt) {
				restartFunc(_gthis.btnList);
			});
		}
		this.btnList.addButton(4,"Exit Level",function(evt) {
			src_MarbleGame.canvas.pushDialog(new gui_MessageBoxYesNoDlg("Are you sure you want to exit this level?  You will lose your current level progress.",function() {
				yesFunc(_gthis.btnList);
			},function() {
			}));
		});
		this.btnList.addButton(3,"Help & Options",function(evt) {
			src_MarbleGame.canvas.popDialog(_gthis);
			src_MarbleGame.canvas.pushDialog(new gui_OptionsListGui(true));
		},20);
		this.btnList.addButton(2,"Achievements",function(evt) {
			src_MarbleGame.canvas.popDialog(_gthis);
			src_MarbleGame.canvas.pushDialog(new gui_AchievementsGui(true));
		});
		this.btnList.addButton(4,"Main Menu",function(evt) {
			src_MarbleGame.canvas.pushDialog(new gui_MessageBoxYesNoDlg("Are you sure you want to exit this level?  You will lose your current level progress.",function() {
				src_MarbleGame.instance._exitingToMenu = true;
				yesFunc(_gthis.btnList);
			},function() {
			}));
		});
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.btnList.position = new h3d_Vector(70 - offsetX / 2,95);
		super.onResize(width,height);
	}
	update(dt,mouseState) {
		super.update(dt,mouseState);
		this.timeMenu += dt;
	}
	onRemove() {
		src_MarbleGame.instance.world.skipStartBugPauseTime += this.timeMenu;
	}
}
$hxClasses["gui.ExitGameDlg"] = gui_ExitGameDlg;
gui_ExitGameDlg.__name__ = "gui.ExitGameDlg";
gui_ExitGameDlg.__super__ = gui_GuiImage;
Object.assign(gui_ExitGameDlg.prototype, {
	__class__: gui_ExitGameDlg
	,innerCtrl: null
	,btnList: null
	,timeMenu: null
});
class gui_GPoint {
	constructor() {
	}
	load(x,y,r,g,b,a) {
		this.x = x;
		this.y = y;
		this.r = r;
		this.g = g;
		this.b = b;
		this.a = a;
	}
}
$hxClasses["gui.GPoint"] = gui_GPoint;
gui_GPoint.__name__ = "gui.GPoint";
Object.assign(gui_GPoint.prototype, {
	__class__: gui_GPoint
	,x: null
	,y: null
	,r: null
	,g: null
	,b: null
	,a: null
});
class h3d_prim_Primitive {
	constructor() {
		if(h3d_prim_Primitive._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
		this.refCount = 0;
	}
	triCount() {
		if(this.indexes != null) {
			return this.indexes.count / 3 | 0;
		} else if(this.buffer == null) {
			return 0;
		} else {
			return this.buffer.totalVertices() / 3 | 0;
		}
	}
	getBounds() {
		throw haxe_Exception.thrown("not implemented for " + Std.string(this));
	}
	incref() {
		this.refCount++;
	}
	decref() {
		this.refCount--;
		if(this.refCount <= 0) {
			this.refCount = 0;
			this.dispose();
		}
	}
	alloc(engine) {
		throw haxe_Exception.thrown("not implemented");
	}
	selectMaterial(material) {
	}
	getMaterialIndexes(material) {
		return { start : 0, count : this.indexes == null ? this.triCount() * 3 : this.indexes.count};
	}
	render(engine) {
		let tmp;
		if(this.buffer != null) {
			let _this = this.buffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.alloc(engine);
		}
		if(this.indexes == null) {
			if((this.buffer.flags & 4) != 0) {
				engine.renderBuffer(this.buffer,engine.mem.quadIndexes,2,0,-1);
			} else {
				engine.renderBuffer(this.buffer,engine.mem.triIndexes,3,0,-1);
			}
		} else {
			engine.renderIndexed(this.buffer,this.indexes);
		}
	}
	dispose() {
		if(this.buffer != null) {
			this.buffer.dispose();
			this.buffer = null;
		}
		if(this.indexes != null) {
			this.indexes.dispose();
			this.indexes = null;
		}
	}
	toString() {
		let c = js_Boot.getClass(this);
		return c.__name__.split(".").pop();
	}
}
$hxClasses["h3d.prim.Primitive"] = h3d_prim_Primitive;
h3d_prim_Primitive.__name__ = "h3d.prim.Primitive";
Object.assign(h3d_prim_Primitive.prototype, {
	__class__: h3d_prim_Primitive
	,buffer: null
	,indexes: null
	,refCount: null
});
class gui__$Graphics_GraphicsContent extends h3d_prim_Primitive {
	constructor() {
		super();
		this.state = new h2d_impl_BatchDrawState();
	}
	setTile(tile) {
		if(tile != null) {
			this.state.setTexture(tile.innerTex);
		}
	}
	next() {
		let nvect = this.tmp.pos >> 3;
		if(nvect < 32768) {
			return false;
		}
		this.tmp = hxd__$FloatBuffer_Float32Expand._new(0);
		this.index = new Array(0);
		let tex = this.state.tail.texture;
		this.state = new h2d_impl_BatchDrawState();
		this.state.setTexture(tex);
		super.dispose();
		return true;
	}
	alloc(engine) {
		if(this.index.length <= 0) {
			return;
		}
		let alloc = hxd_impl_Allocator.get();
		this.buffer = alloc.ofFloats(this.tmp,8,2);
		this.bufferSize = this.tmp.pos;
		this.indexes = alloc.ofIndexes(this.index);
		this.ibufferSize = this.index.length;
		this.bufferDirty = false;
		this.indexDirty = false;
	}
	doRender(ctx) {
		if(this.index.length == 0) {
			return;
		}
		this.flush();
		this.state.drawIndexed(ctx,this.buffer,this.indexes,0,this.tmp.pos >> 3);
	}
	flush() {
		let tmp;
		if(this.buffer != null) {
			let _this = this.buffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.alloc(h3d_Engine.CURRENT);
		} else {
			let allocator = hxd_impl_Allocator.get();
			if(this.bufferDirty) {
				if(this.tmp.pos > this.bufferSize) {
					allocator.disposeBuffer(this.buffer);
					this.buffer = new h3d_Buffer(this.tmp.pos >> 3,8,[h3d_BufferFlag.RawFormat,h3d_BufferFlag.Dynamic]);
					this.buffer.uploadVector(this.tmp,0,this.tmp.pos >> 3);
					this.bufferSize = this.tmp.pos;
				} else {
					this.buffer.uploadVector(this.tmp,0,this.tmp.pos >> 3);
				}
				this.bufferDirty = false;
			}
			if(this.indexDirty) {
				if(this.index.length > this.ibufferSize) {
					allocator.disposeIndexBuffer(this.indexes);
					this.indexes = allocator.ofIndexes(this.index);
					this.ibufferSize = this.index.length;
				} else {
					this.indexes.upload(this.index,0,this.index.length);
				}
				this.indexDirty = false;
			}
		}
	}
	dispose() {
		this.state.clear();
	}
	disposeBuffers() {
		if(this.buffer != null) {
			hxd_impl_Allocator.get().disposeBuffer(this.buffer);
			this.buffer = null;
		}
		if(this.indexes != null) {
			hxd_impl_Allocator.get().disposeIndexBuffer(this.indexes);
			this.indexes = null;
		}
	}
	clear() {
		this.dispose();
		this.tmp = hxd__$FloatBuffer_Float32Expand._new(0);
		this.index = new Array(0);
	}
	disposeForReal() {
		this.state.clear();
		this.disposeBuffers();
		super.dispose();
	}
}
$hxClasses["gui._Graphics.GraphicsContent"] = gui__$Graphics_GraphicsContent;
gui__$Graphics_GraphicsContent.__name__ = "gui._Graphics.GraphicsContent";
gui__$Graphics_GraphicsContent.__super__ = h3d_prim_Primitive;
Object.assign(gui__$Graphics_GraphicsContent.prototype, {
	__class__: gui__$Graphics_GraphicsContent
	,tmp: null
	,index: null
	,state: null
	,bufferDirty: null
	,indexDirty: null
	,bufferSize: null
	,ibufferSize: null
});
class h2d_Drawable extends h2d_Object {
	_hx_constructor(parent) {
		super._hx_constructor(parent);
		this.color = new h3d_Vector(1,1,1,1);
	}
	drawFiltered(ctx,tile) {
		let old = this.shaders;
		this.shaders = null;
		super.drawFiltered(ctx,tile);
		this.shaders = old;
	}
	addShader(s) {
		if(s == null) {
			throw haxe_Exception.thrown("Can't add null shader");
		}
		this.shaders = hxsl_ShaderList.addSort(s,this.shaders);
		return s;
	}
	removeShader(s) {
		let prev = null;
		let cur = this.shaders;
		while(cur != null) {
			if(cur.s == s) {
				if(prev == null) {
					this.shaders = cur.next;
				} else {
					prev.next = cur.next;
				}
				return true;
			}
			prev = cur;
			cur = cur.next;
		}
		return false;
	}
	emitTile(ctx,tile) {
		if(tile == null) {
			tile = new h2d_Tile(null,0,0,5,5);
		}
		if(!ctx.drawTile(this,tile)) {
			return;
		}
	}
}
$hxClasses["h2d.Drawable"] = h2d_Drawable;
h2d_Drawable.__name__ = "h2d.Drawable";
h2d_Drawable.__super__ = h2d_Object;
Object.assign(h2d_Drawable.prototype, {
	__class__: h2d_Drawable
	,color: null
	,smooth: null
	,tileWrap: null
	,shaders: null
});
class gui_Graphics extends h2d_Drawable {
	constructor(parent) {
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor(parent);
	}
	_hx_constructor(parent) {
		this.bevel = 0.25;
		this.my = 0.;
		this.mx = 0.;
		this.md = 1.;
		this.mc = 0.;
		this.mb = 0.;
		this.ma = 1.;
		super._hx_constructor(parent);
		this.content = new gui__$Graphics_GraphicsContent();
		this.tile = h2d_Tile.fromColor(16777215);
		this.clear();
	}
	onRemove() {
		super.onRemove();
		this.clear();
		this.content.disposeForReal();
	}
	clear() {
		this.content.clear();
		this.tmpPoints = [];
		this.pindex = 0;
		this.lineSize = 0;
		this.xMin = Infinity;
		this.yMin = Infinity;
		this.yMax = -Infinity;
		this.xMax = -Infinity;
		this.xMinSize = Infinity;
		this.yMinSize = Infinity;
		this.yMaxSize = -Infinity;
		this.xMaxSize = -Infinity;
	}
	getBoundsRec(relativeTo,out,forSize) {
		super.getBoundsRec(relativeTo,out,forSize);
		if(this.tile != null) {
			if(forSize) {
				this.addBounds(relativeTo,out,this.xMinSize,this.yMinSize,this.xMaxSize - this.xMinSize,this.yMaxSize - this.yMinSize);
			} else {
				this.addBounds(relativeTo,out,this.xMin,this.yMin,this.xMax - this.xMin,this.yMax - this.yMin);
			}
		}
	}
	isConvex(points) {
		let first = true;
		let sign = false;
		let _g = 0;
		let _g1 = points.length;
		while(_g < _g1) {
			let i = _g++;
			let p1 = points[i];
			let p2 = points[(i + 1) % points.length];
			let p3 = points[(i + 2) % points.length];
			let s = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0;
			if(first) {
				first = false;
				sign = s;
			} else if(sign != s) {
				return false;
			}
		}
		return true;
	}
	flushLine(start) {
		let pts = this.tmpPoints;
		let last = pts.length - 1;
		let prev = pts[last];
		let p = pts[0];
		this.content.setTile(h2d_Tile.fromColor(16777215));
		let closed = p.x == prev.x && p.y == prev.y;
		let count = pts.length;
		if(!closed) {
			let prevLast = pts[last - 1];
			if(prevLast == null) {
				prevLast = p;
			}
			let gp = new gui_GPoint();
			gp.load(prev.x * 2 - prevLast.x,prev.y * 2 - prevLast.y,0,0,0,0);
			pts.push(gp);
			let pNext = pts[1];
			if(pNext == null) {
				pNext = p;
			}
			let gp1 = new gui_GPoint();
			gp1.load(p.x * 2 - pNext.x,p.y * 2 - pNext.y,0,0,0,0);
			prev = gp1;
		} else if(p != prev) {
			--count;
			--last;
			prev = pts[last];
		}
		let _g = 0;
		let _g1 = count;
		while(_g < _g1) {
			let i = _g++;
			let next = pts[(i + 1) % pts.length];
			let nx1 = prev.y - p.y;
			let ny1 = p.x - prev.x;
			let ns1 = 1. / Math.sqrt(nx1 * nx1 + ny1 * ny1);
			let nx2 = p.y - next.y;
			let ny2 = next.x - p.x;
			let ns2 = 1. / Math.sqrt(nx2 * nx2 + ny2 * ny2);
			let nx = nx1 * ns1 + nx2 * ns2;
			let ny = ny1 * ns1 + ny2 * ns2;
			let ns = 1. / Math.sqrt(nx * nx + ny * ny);
			nx *= ns;
			ny *= ns;
			let size = nx * nx1 * ns1 + ny * ny1 * ns1;
			if(size < 0.1) {
				size = 0.1;
			}
			let d = this.lineSize * 0.5 / size;
			nx *= d;
			ny *= d;
			if(size > this.bevel) {
				let _this = this.content;
				let x = p.x + nx;
				let y = p.y + ny;
				let r = p.r;
				let g = p.g;
				let b = p.b;
				let a = p.a;
				let this1 = _this.tmp;
				if(this1.pos == this1.array.length) {
					let newSize = this1.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this1.array);
					this1.array = newArray;
				}
				this1.array[this1.pos++] = x;
				let this2 = _this.tmp;
				if(this2.pos == this2.array.length) {
					let newSize = this2.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this2.array);
					this2.array = newArray;
				}
				this2.array[this2.pos++] = y;
				let this3 = _this.tmp;
				if(this3.pos == this3.array.length) {
					let newSize = this3.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this3.array);
					this3.array = newArray;
				}
				this3.array[this3.pos++] = 0;
				let this4 = _this.tmp;
				if(this4.pos == this4.array.length) {
					let newSize = this4.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this4.array);
					this4.array = newArray;
				}
				this4.array[this4.pos++] = 0;
				let this5 = _this.tmp;
				if(this5.pos == this5.array.length) {
					let newSize = this5.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this5.array);
					this5.array = newArray;
				}
				this5.array[this5.pos++] = r;
				let this6 = _this.tmp;
				if(this6.pos == this6.array.length) {
					let newSize = this6.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this6.array);
					this6.array = newArray;
				}
				this6.array[this6.pos++] = g;
				let this7 = _this.tmp;
				if(this7.pos == this7.array.length) {
					let newSize = this7.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this7.array);
					this7.array = newArray;
				}
				this7.array[this7.pos++] = b;
				let this8 = _this.tmp;
				if(this8.pos == this8.array.length) {
					let newSize = this8.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this8.array);
					this8.array = newArray;
				}
				this8.array[this8.pos++] = a;
				_this.bufferDirty = true;
				let _this1 = this.content;
				let x1 = p.x - nx;
				let y1 = p.y - ny;
				let r1 = p.r;
				let g1 = p.g;
				let b1 = p.b;
				let a1 = p.a;
				let this9 = _this1.tmp;
				if(this9.pos == this9.array.length) {
					let newSize = this9.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this9.array);
					this9.array = newArray;
				}
				this9.array[this9.pos++] = x1;
				let this10 = _this1.tmp;
				if(this10.pos == this10.array.length) {
					let newSize = this10.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this10.array);
					this10.array = newArray;
				}
				this10.array[this10.pos++] = y1;
				let this11 = _this1.tmp;
				if(this11.pos == this11.array.length) {
					let newSize = this11.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this11.array);
					this11.array = newArray;
				}
				this11.array[this11.pos++] = 0;
				let this12 = _this1.tmp;
				if(this12.pos == this12.array.length) {
					let newSize = this12.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this12.array);
					this12.array = newArray;
				}
				this12.array[this12.pos++] = 0;
				let this13 = _this1.tmp;
				if(this13.pos == this13.array.length) {
					let newSize = this13.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this13.array);
					this13.array = newArray;
				}
				this13.array[this13.pos++] = r1;
				let this14 = _this1.tmp;
				if(this14.pos == this14.array.length) {
					let newSize = this14.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this14.array);
					this14.array = newArray;
				}
				this14.array[this14.pos++] = g1;
				let this15 = _this1.tmp;
				if(this15.pos == this15.array.length) {
					let newSize = this15.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this15.array);
					this15.array = newArray;
				}
				this15.array[this15.pos++] = b1;
				let this16 = _this1.tmp;
				if(this16.pos == this16.array.length) {
					let newSize = this16.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this16.array);
					this16.array = newArray;
				}
				this16.array[this16.pos++] = a1;
				_this1.bufferDirty = true;
				let pnext = i == last ? start : this.pindex + 2;
				if(i < count - 1 || closed) {
					let _this = this.content;
					_this.index.push(this.pindex);
					let _this1 = _this.state;
					_this1.tail.count += 1;
					_this1.totalCount += 1;
					_this.indexDirty = true;
					let _this2 = this.content;
					_this2.index.push(this.pindex + 1);
					let _this3 = _this2.state;
					_this3.tail.count += 1;
					_this3.totalCount += 1;
					_this2.indexDirty = true;
					let _this4 = this.content;
					_this4.index.push(pnext);
					let _this5 = _this4.state;
					_this5.tail.count += 1;
					_this5.totalCount += 1;
					_this4.indexDirty = true;
					let _this6 = this.content;
					_this6.index.push(this.pindex + 1);
					let _this7 = _this6.state;
					_this7.tail.count += 1;
					_this7.totalCount += 1;
					_this6.indexDirty = true;
					let _this8 = this.content;
					_this8.index.push(pnext);
					let _this9 = _this8.state;
					_this9.tail.count += 1;
					_this9.totalCount += 1;
					_this8.indexDirty = true;
					let _this10 = this.content;
					_this10.index.push(pnext + 1);
					let _this11 = _this10.state;
					_this11.tail.count += 1;
					_this11.totalCount += 1;
					_this10.indexDirty = true;
				}
				this.pindex += 2;
			} else {
				let n0x = next.x - p.x;
				let n0y = next.y - p.y;
				let sign = n0x * nx + n0y * ny;
				let nnx = -ny;
				let nny = nx;
				let size = nnx * nx1 * ns1 + nny * ny1 * ns1;
				let d = this.lineSize * 0.5 / size;
				nnx *= d;
				nny *= d;
				let pnext = i == last ? start : this.pindex + 3;
				if(sign > 0) {
					let _this = this.content;
					let x = p.x + nx;
					let y = p.y + ny;
					let r = p.r;
					let g = p.g;
					let b = p.b;
					let a = p.a;
					let this1 = _this.tmp;
					if(this1.pos == this1.array.length) {
						let newSize = this1.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this1.array);
						this1.array = newArray;
					}
					this1.array[this1.pos++] = x;
					let this2 = _this.tmp;
					if(this2.pos == this2.array.length) {
						let newSize = this2.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this2.array);
						this2.array = newArray;
					}
					this2.array[this2.pos++] = y;
					let this3 = _this.tmp;
					if(this3.pos == this3.array.length) {
						let newSize = this3.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this3.array);
						this3.array = newArray;
					}
					this3.array[this3.pos++] = 0;
					let this4 = _this.tmp;
					if(this4.pos == this4.array.length) {
						let newSize = this4.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this4.array);
						this4.array = newArray;
					}
					this4.array[this4.pos++] = 0;
					let this5 = _this.tmp;
					if(this5.pos == this5.array.length) {
						let newSize = this5.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this5.array);
						this5.array = newArray;
					}
					this5.array[this5.pos++] = r;
					let this6 = _this.tmp;
					if(this6.pos == this6.array.length) {
						let newSize = this6.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this6.array);
						this6.array = newArray;
					}
					this6.array[this6.pos++] = g;
					let this7 = _this.tmp;
					if(this7.pos == this7.array.length) {
						let newSize = this7.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this7.array);
						this7.array = newArray;
					}
					this7.array[this7.pos++] = b;
					let this8 = _this.tmp;
					if(this8.pos == this8.array.length) {
						let newSize = this8.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this8.array);
						this8.array = newArray;
					}
					this8.array[this8.pos++] = a;
					_this.bufferDirty = true;
					let _this1 = this.content;
					let x1 = p.x - nnx;
					let y1 = p.y - nny;
					let r1 = p.r;
					let g1 = p.g;
					let b1 = p.b;
					let a1 = p.a;
					let this9 = _this1.tmp;
					if(this9.pos == this9.array.length) {
						let newSize = this9.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this9.array);
						this9.array = newArray;
					}
					this9.array[this9.pos++] = x1;
					let this10 = _this1.tmp;
					if(this10.pos == this10.array.length) {
						let newSize = this10.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this10.array);
						this10.array = newArray;
					}
					this10.array[this10.pos++] = y1;
					let this11 = _this1.tmp;
					if(this11.pos == this11.array.length) {
						let newSize = this11.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this11.array);
						this11.array = newArray;
					}
					this11.array[this11.pos++] = 0;
					let this12 = _this1.tmp;
					if(this12.pos == this12.array.length) {
						let newSize = this12.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this12.array);
						this12.array = newArray;
					}
					this12.array[this12.pos++] = 0;
					let this13 = _this1.tmp;
					if(this13.pos == this13.array.length) {
						let newSize = this13.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this13.array);
						this13.array = newArray;
					}
					this13.array[this13.pos++] = r1;
					let this14 = _this1.tmp;
					if(this14.pos == this14.array.length) {
						let newSize = this14.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this14.array);
						this14.array = newArray;
					}
					this14.array[this14.pos++] = g1;
					let this15 = _this1.tmp;
					if(this15.pos == this15.array.length) {
						let newSize = this15.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this15.array);
						this15.array = newArray;
					}
					this15.array[this15.pos++] = b1;
					let this16 = _this1.tmp;
					if(this16.pos == this16.array.length) {
						let newSize = this16.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this16.array);
						this16.array = newArray;
					}
					this16.array[this16.pos++] = a1;
					_this1.bufferDirty = true;
					let _this2 = this.content;
					let x2 = p.x + nnx;
					let y2 = p.y + nny;
					let r2 = p.r;
					let g2 = p.g;
					let b2 = p.b;
					let a2 = p.a;
					let this17 = _this2.tmp;
					if(this17.pos == this17.array.length) {
						let newSize = this17.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this17.array);
						this17.array = newArray;
					}
					this17.array[this17.pos++] = x2;
					let this18 = _this2.tmp;
					if(this18.pos == this18.array.length) {
						let newSize = this18.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this18.array);
						this18.array = newArray;
					}
					this18.array[this18.pos++] = y2;
					let this19 = _this2.tmp;
					if(this19.pos == this19.array.length) {
						let newSize = this19.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this19.array);
						this19.array = newArray;
					}
					this19.array[this19.pos++] = 0;
					let this20 = _this2.tmp;
					if(this20.pos == this20.array.length) {
						let newSize = this20.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this20.array);
						this20.array = newArray;
					}
					this20.array[this20.pos++] = 0;
					let this21 = _this2.tmp;
					if(this21.pos == this21.array.length) {
						let newSize = this21.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this21.array);
						this21.array = newArray;
					}
					this21.array[this21.pos++] = r2;
					let this22 = _this2.tmp;
					if(this22.pos == this22.array.length) {
						let newSize = this22.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this22.array);
						this22.array = newArray;
					}
					this22.array[this22.pos++] = g2;
					let this23 = _this2.tmp;
					if(this23.pos == this23.array.length) {
						let newSize = this23.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this23.array);
						this23.array = newArray;
					}
					this23.array[this23.pos++] = b2;
					let this24 = _this2.tmp;
					if(this24.pos == this24.array.length) {
						let newSize = this24.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this24.array);
						this24.array = newArray;
					}
					this24.array[this24.pos++] = a2;
					_this2.bufferDirty = true;
					let _this3 = this.content;
					_this3.index.push(this.pindex);
					let _this4 = _this3.state;
					_this4.tail.count += 1;
					_this4.totalCount += 1;
					_this3.indexDirty = true;
					let _this5 = this.content;
					_this5.index.push(pnext);
					let _this6 = _this5.state;
					_this6.tail.count += 1;
					_this6.totalCount += 1;
					_this5.indexDirty = true;
					let _this7 = this.content;
					_this7.index.push(this.pindex + 2);
					let _this8 = _this7.state;
					_this8.tail.count += 1;
					_this8.totalCount += 1;
					_this7.indexDirty = true;
					let _this9 = this.content;
					_this9.index.push(this.pindex + 2);
					let _this10 = _this9.state;
					_this10.tail.count += 1;
					_this10.totalCount += 1;
					_this9.indexDirty = true;
					let _this11 = this.content;
					_this11.index.push(pnext);
					let _this12 = _this11.state;
					_this12.tail.count += 1;
					_this12.totalCount += 1;
					_this11.indexDirty = true;
					let _this13 = this.content;
					_this13.index.push(pnext + 1);
					let _this14 = _this13.state;
					_this14.tail.count += 1;
					_this14.totalCount += 1;
					_this13.indexDirty = true;
				} else {
					let _this = this.content;
					let x = p.x + nnx;
					let y = p.y + nny;
					let r = p.r;
					let g = p.g;
					let b = p.b;
					let a = p.a;
					let this1 = _this.tmp;
					if(this1.pos == this1.array.length) {
						let newSize = this1.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this1.array);
						this1.array = newArray;
					}
					this1.array[this1.pos++] = x;
					let this2 = _this.tmp;
					if(this2.pos == this2.array.length) {
						let newSize = this2.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this2.array);
						this2.array = newArray;
					}
					this2.array[this2.pos++] = y;
					let this3 = _this.tmp;
					if(this3.pos == this3.array.length) {
						let newSize = this3.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this3.array);
						this3.array = newArray;
					}
					this3.array[this3.pos++] = 0;
					let this4 = _this.tmp;
					if(this4.pos == this4.array.length) {
						let newSize = this4.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this4.array);
						this4.array = newArray;
					}
					this4.array[this4.pos++] = 0;
					let this5 = _this.tmp;
					if(this5.pos == this5.array.length) {
						let newSize = this5.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this5.array);
						this5.array = newArray;
					}
					this5.array[this5.pos++] = r;
					let this6 = _this.tmp;
					if(this6.pos == this6.array.length) {
						let newSize = this6.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this6.array);
						this6.array = newArray;
					}
					this6.array[this6.pos++] = g;
					let this7 = _this.tmp;
					if(this7.pos == this7.array.length) {
						let newSize = this7.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this7.array);
						this7.array = newArray;
					}
					this7.array[this7.pos++] = b;
					let this8 = _this.tmp;
					if(this8.pos == this8.array.length) {
						let newSize = this8.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this8.array);
						this8.array = newArray;
					}
					this8.array[this8.pos++] = a;
					_this.bufferDirty = true;
					let _this1 = this.content;
					let x1 = p.x - nx;
					let y1 = p.y - ny;
					let r1 = p.r;
					let g1 = p.g;
					let b1 = p.b;
					let a1 = p.a;
					let this9 = _this1.tmp;
					if(this9.pos == this9.array.length) {
						let newSize = this9.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this9.array);
						this9.array = newArray;
					}
					this9.array[this9.pos++] = x1;
					let this10 = _this1.tmp;
					if(this10.pos == this10.array.length) {
						let newSize = this10.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this10.array);
						this10.array = newArray;
					}
					this10.array[this10.pos++] = y1;
					let this11 = _this1.tmp;
					if(this11.pos == this11.array.length) {
						let newSize = this11.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this11.array);
						this11.array = newArray;
					}
					this11.array[this11.pos++] = 0;
					let this12 = _this1.tmp;
					if(this12.pos == this12.array.length) {
						let newSize = this12.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this12.array);
						this12.array = newArray;
					}
					this12.array[this12.pos++] = 0;
					let this13 = _this1.tmp;
					if(this13.pos == this13.array.length) {
						let newSize = this13.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this13.array);
						this13.array = newArray;
					}
					this13.array[this13.pos++] = r1;
					let this14 = _this1.tmp;
					if(this14.pos == this14.array.length) {
						let newSize = this14.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this14.array);
						this14.array = newArray;
					}
					this14.array[this14.pos++] = g1;
					let this15 = _this1.tmp;
					if(this15.pos == this15.array.length) {
						let newSize = this15.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this15.array);
						this15.array = newArray;
					}
					this15.array[this15.pos++] = b1;
					let this16 = _this1.tmp;
					if(this16.pos == this16.array.length) {
						let newSize = this16.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this16.array);
						this16.array = newArray;
					}
					this16.array[this16.pos++] = a1;
					_this1.bufferDirty = true;
					let _this2 = this.content;
					let x2 = p.x - nnx;
					let y2 = p.y - nny;
					let r2 = p.r;
					let g2 = p.g;
					let b2 = p.b;
					let a2 = p.a;
					let this17 = _this2.tmp;
					if(this17.pos == this17.array.length) {
						let newSize = this17.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this17.array);
						this17.array = newArray;
					}
					this17.array[this17.pos++] = x2;
					let this18 = _this2.tmp;
					if(this18.pos == this18.array.length) {
						let newSize = this18.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this18.array);
						this18.array = newArray;
					}
					this18.array[this18.pos++] = y2;
					let this19 = _this2.tmp;
					if(this19.pos == this19.array.length) {
						let newSize = this19.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this19.array);
						this19.array = newArray;
					}
					this19.array[this19.pos++] = 0;
					let this20 = _this2.tmp;
					if(this20.pos == this20.array.length) {
						let newSize = this20.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this20.array);
						this20.array = newArray;
					}
					this20.array[this20.pos++] = 0;
					let this21 = _this2.tmp;
					if(this21.pos == this21.array.length) {
						let newSize = this21.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this21.array);
						this21.array = newArray;
					}
					this21.array[this21.pos++] = r2;
					let this22 = _this2.tmp;
					if(this22.pos == this22.array.length) {
						let newSize = this22.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this22.array);
						this22.array = newArray;
					}
					this22.array[this22.pos++] = g2;
					let this23 = _this2.tmp;
					if(this23.pos == this23.array.length) {
						let newSize = this23.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this23.array);
						this23.array = newArray;
					}
					this23.array[this23.pos++] = b2;
					let this24 = _this2.tmp;
					if(this24.pos == this24.array.length) {
						let newSize = this24.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this24.array);
						this24.array = newArray;
					}
					this24.array[this24.pos++] = a2;
					_this2.bufferDirty = true;
					let _this3 = this.content;
					_this3.index.push(this.pindex + 1);
					let _this4 = _this3.state;
					_this4.tail.count += 1;
					_this4.totalCount += 1;
					_this3.indexDirty = true;
					let _this5 = this.content;
					_this5.index.push(pnext);
					let _this6 = _this5.state;
					_this6.tail.count += 1;
					_this6.totalCount += 1;
					_this5.indexDirty = true;
					let _this7 = this.content;
					_this7.index.push(this.pindex + 2);
					let _this8 = _this7.state;
					_this8.tail.count += 1;
					_this8.totalCount += 1;
					_this7.indexDirty = true;
					let _this9 = this.content;
					_this9.index.push(this.pindex + 1);
					let _this10 = _this9.state;
					_this10.tail.count += 1;
					_this10.totalCount += 1;
					_this9.indexDirty = true;
					let _this11 = this.content;
					_this11.index.push(pnext);
					let _this12 = _this11.state;
					_this12.tail.count += 1;
					_this12.totalCount += 1;
					_this11.indexDirty = true;
					let _this13 = this.content;
					_this13.index.push(pnext + 1);
					let _this14 = _this13.state;
					_this14.tail.count += 1;
					_this14.totalCount += 1;
					_this13.indexDirty = true;
				}
				let _this = this.content;
				_this.index.push(this.pindex);
				let _this1 = _this.state;
				_this1.tail.count += 1;
				_this1.totalCount += 1;
				_this.indexDirty = true;
				let _this2 = this.content;
				_this2.index.push(this.pindex + 1);
				let _this3 = _this2.state;
				_this3.tail.count += 1;
				_this3.totalCount += 1;
				_this2.indexDirty = true;
				let _this4 = this.content;
				_this4.index.push(this.pindex + 2);
				let _this5 = _this4.state;
				_this5.tail.count += 1;
				_this5.totalCount += 1;
				_this4.indexDirty = true;
				this.pindex += 3;
			}
			prev = p;
			p = next;
		}
		this.content.setTile(this.tile);
	}
	flushFill(i0) {
		if(this.tmpPoints.length < 3) {
			return;
		}
		let pts = this.tmpPoints;
		let p0 = pts[0];
		let p1 = pts[pts.length - 1];
		let last = null;
		let tmp;
		let f = p0.x - p1.x;
		if((f < 0 ? -f : f) < 1e-9) {
			let f = p0.y - p1.y;
			tmp = (f < 0 ? -f : f) < 1e-9;
		} else {
			tmp = false;
		}
		if(tmp) {
			last = pts.pop();
		}
		if(this.isConvex(pts)) {
			let _g = 1;
			let _g1 = pts.length - 1;
			while(_g < _g1) {
				let i = _g++;
				let _this = this.content;
				_this.index.push(i0);
				let _this1 = _this.state;
				_this1.tail.count += 1;
				_this1.totalCount += 1;
				_this.indexDirty = true;
				let _this2 = this.content;
				_this2.index.push(i0 + i);
				let _this3 = _this2.state;
				_this3.tail.count += 1;
				_this3.totalCount += 1;
				_this2.indexDirty = true;
				let _this4 = this.content;
				_this4.index.push(i0 + i + 1);
				let _this5 = _this4.state;
				_this5.tail.count += 1;
				_this5.totalCount += 1;
				_this4.indexDirty = true;
			}
		} else {
			let ear = gui_Graphics.EARCUT;
			if(ear == null) {
				ear = new hxd_earcut_Earcut();
				gui_Graphics.EARCUT = ear;
			}
			let _g = 0;
			let _g1 = ear.triangulate_gui_GPoint(pts);
			while(_g < _g1.length) {
				let i = _g1[_g];
				++_g;
				let _this = this.content;
				_this.index.push(i + i0);
				let _this1 = _this.state;
				_this1.tail.count += 1;
				_this1.totalCount += 1;
				_this.indexDirty = true;
			}
		}
		if(last != null) {
			pts.push(last);
		}
	}
	flush() {
		if(this.tmpPoints.length == 0) {
			return;
		}
		if(this.doFill) {
			this.flushFill(this.pindex);
			this.pindex += this.tmpPoints.length;
			if(this.content.next()) {
				this.pindex = 0;
			}
		}
		if(this.lineSize > 0) {
			this.flushLine(this.pindex);
			if(this.content.next()) {
				this.pindex = 0;
			}
		}
		this.tmpPoints = [];
	}
	beginFill(color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 0;
		}
		this.flush();
		this.tile = h2d_Tile.fromColor(16777215);
		this.content.setTile(this.tile);
		let alpha1 = alpha;
		if(alpha == null) {
			alpha1 = 1.;
		}
		this.curA = alpha1;
		this.curR = (color >> 16 & 255) / 255.;
		this.curG = (color >> 8 & 255) / 255.;
		this.curB = (color & 255) / 255.;
		this.doFill = true;
	}
	lineStyle(size,color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 0;
		}
		if(size == null) {
			size = 0;
		}
		this.flush();
		this.lineSize = size;
		this.lineA = alpha;
		this.lineR = (color >> 16 & 255) / 255.;
		this.lineG = (color >> 8 & 255) / 255.;
		this.lineB = (color & 255) / 255.;
	}
	endFill() {
		this.flush();
		this.doFill = false;
	}
	addVertex(x,y,r,g,b,a,u,v) {
		if(v == null) {
			v = 0.;
		}
		if(u == null) {
			u = 0.;
		}
		let half = this.lineSize / 2.0;
		if(x - half < this.xMin) {
			this.xMin = x - half;
		}
		if(y - half < this.yMin) {
			this.yMin = y - half;
		}
		if(x + half > this.xMax) {
			this.xMax = x + half;
		}
		if(y + half > this.yMax) {
			this.yMax = y + half;
		}
		if(x < this.xMinSize) {
			this.xMinSize = x;
		}
		if(y < this.yMinSize) {
			this.yMinSize = y;
		}
		if(x > this.xMaxSize) {
			this.xMaxSize = x;
		}
		if(y > this.yMaxSize) {
			this.yMaxSize = y;
		}
		if(this.doFill) {
			let _this = this.content;
			let this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				let newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = x;
			let this2 = _this.tmp;
			if(this2.pos == this2.array.length) {
				let newSize = this2.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this2.array);
				this2.array = newArray;
			}
			this2.array[this2.pos++] = y;
			let this3 = _this.tmp;
			if(this3.pos == this3.array.length) {
				let newSize = this3.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this3.array);
				this3.array = newArray;
			}
			this3.array[this3.pos++] = u;
			let this4 = _this.tmp;
			if(this4.pos == this4.array.length) {
				let newSize = this4.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this4.array);
				this4.array = newArray;
			}
			this4.array[this4.pos++] = v;
			let this5 = _this.tmp;
			if(this5.pos == this5.array.length) {
				let newSize = this5.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this5.array);
				this5.array = newArray;
			}
			this5.array[this5.pos++] = r;
			let this6 = _this.tmp;
			if(this6.pos == this6.array.length) {
				let newSize = this6.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this6.array);
				this6.array = newArray;
			}
			this6.array[this6.pos++] = g;
			let this7 = _this.tmp;
			if(this7.pos == this7.array.length) {
				let newSize = this7.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this7.array);
				this7.array = newArray;
			}
			this7.array[this7.pos++] = b;
			let this8 = _this.tmp;
			if(this8.pos == this8.array.length) {
				let newSize = this8.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this8.array);
				this8.array = newArray;
			}
			this8.array[this8.pos++] = a;
			_this.bufferDirty = true;
		}
		let gp = new gui_GPoint();
		gp.load(x,y,this.lineR,this.lineG,this.lineB,this.lineA);
		this.tmpPoints.push(gp);
	}
	draw(ctx) {
		if(!ctx.beginDrawBatchState(this)) {
			return;
		}
		this.content.doRender(ctx);
	}
	sync(ctx) {
		super.sync(ctx);
		this.flush();
		this.content.flush();
	}
}
$hxClasses["gui.Graphics"] = gui_Graphics;
gui_Graphics.__name__ = "gui.Graphics";
gui_Graphics.__super__ = h2d_Drawable;
Object.assign(gui_Graphics.prototype, {
	__class__: gui_Graphics
	,content: null
	,tmpPoints: null
	,pindex: null
	,curR: null
	,curG: null
	,curB: null
	,curA: null
	,lineSize: null
	,lineR: null
	,lineG: null
	,lineB: null
	,lineA: null
	,doFill: null
	,xMin: null
	,yMin: null
	,xMax: null
	,yMax: null
	,xMinSize: null
	,yMinSize: null
	,xMaxSize: null
	,yMaxSize: null
	,ma: null
	,mb: null
	,mc: null
	,md: null
	,mx: null
	,my: null
	,tile: null
	,bevel: null
});
class gui_GuiAnim extends gui_GuiControl {
	constructor(textures) {
		if(gui_GuiControl._hx_skip_constructor) {
			super();
			return;
		}
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(textures);
	}
	_hx_constructor(textures) {
		super._hx_constructor();
		this.anim = new h2d_Anim(textures,0);
	}
	render(scene2d,parent) {
		if(parent != null) {
			if(parent.contains(this.anim)) {
				parent.removeChild(this.anim);
			}
			parent.addChild(this.anim);
			let off = this.getOffsetFromParent();
			let props = parent.getProperties(this.anim);
			props.set_isAbsolute(true);
			let _this = this.anim;
			_this.posChanged = true;
			_this.x = off.x;
			_this.posChanged = true;
			_this.y = off.y;
		}
		let renderRect = this.getRenderRectangle();
		let _this = this.anim;
		let v = renderRect.extent.x / this.anim.getFrame().width;
		_this.posChanged = true;
		_this.scaleX = v;
		let _this1 = this.anim;
		let v1 = renderRect.extent.y / this.anim.getFrame().height;
		_this1.posChanged = true;
		_this1.scaleY = v1;
		super.render(scene2d,parent);
	}
	dispose() {
		super.dispose();
		let _this = this.anim;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
	onRemove() {
		super.onRemove();
		if(src_MarbleGame.canvas.scene2d.contains(this.anim)) {
			src_MarbleGame.canvas.scene2d.removeChild(this.anim);
		}
		let _this = this.anim;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
}
$hxClasses["gui.GuiAnim"] = gui_GuiAnim;
gui_GuiAnim.__name__ = "gui.GuiAnim";
gui_GuiAnim.__super__ = gui_GuiControl;
Object.assign(gui_GuiAnim.prototype, {
	__class__: gui_GuiAnim
	,anim: null
});
var gui_ButtonType = $hxEnums["gui.ButtonType"] = { __ename__:true,__constructs__:null
	,Normal: {_hx_name:"Normal",_hx_index:0,__enum__:"gui.ButtonType",toString:$estr}
	,Toggle: {_hx_name:"Toggle",_hx_index:1,__enum__:"gui.ButtonType",toString:$estr}
	,Radio: {_hx_name:"Radio",_hx_index:2,__enum__:"gui.ButtonType",toString:$estr}
};
gui_ButtonType.__constructs__ = [gui_ButtonType.Normal,gui_ButtonType.Toggle,gui_ButtonType.Radio];
gui_ButtonType.__empty_constructs__ = [gui_ButtonType.Normal,gui_ButtonType.Toggle,gui_ButtonType.Radio];
class gui_GuiButton extends gui_GuiAnim {
	constructor(anim) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(anim);
	}
	_hx_constructor(anim) {
		this.acceleratorWasPressed = false;
		this.gamepadAccelerator = [];
		this.accelerator = 0;
		this.buttonSounds = true;
		this.pressed = false;
		this.buttonType = gui_ButtonType.Normal;
		this.disabled = false;
		this.pressedAction = null;
		super._hx_constructor(anim);
	}
	update(dt,mouseState) {
		let renderRect = this.getHitTestRect();
		if(renderRect.inRect(mouseState.position) && !this.disabled) {
			if(this.buttonSounds && hxd_Key.isPressed(0)) {
				src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/buttonpress.wav",src_ResourceLoader.getAudio,this.soundResources));
			}
		}
		if(this.buttonType == gui_ButtonType.Normal) {
			if(renderRect.inRect(mouseState.position) && !this.disabled) {
				if(hxd_Key.isDown(0)) {
					this.anim.set_currentFrame(2);
					this.pressed = true;
				} else {
					this.anim.set_currentFrame(1);
					this.pressed = false;
				}
			} else {
				this.anim.set_currentFrame(this.disabled ? 3 : 0);
				this.pressed = false;
			}
		}
		if(this.buttonType == gui_ButtonType.Toggle || this.buttonType == gui_ButtonType.Radio) {
			if(this.pressed) {
				this.anim.set_currentFrame(2);
			} else if(renderRect.inRect(mouseState.position) && !this.disabled) {
				if(hxd_Key.isDown(0)) {
					this.anim.set_currentFrame(2);
				} else if(!hxd_Key.isReleased(0)) {
					this.anim.set_currentFrame(1);
				}
			} else {
				this.anim.set_currentFrame(this.disabled ? 3 : 0);
			}
		}
		if(!this.disabled) {
			if(this.acceleratorWasPressed && (this.accelerator != 0 && hxd_Key.isReleased(this.accelerator)) || src_Gamepad.isReleased(this.gamepadAccelerator)) {
				if(this.pressedAction != null) {
					this.pressedAction(new gui_GuiEvent(this));
				}
			} else if(this.accelerator != 0 && hxd_Key.isPressed(this.accelerator) || src_Gamepad.isPressed(this.gamepadAccelerator)) {
				this.acceleratorWasPressed = true;
			}
		}
		if(this.acceleratorWasPressed) {
			if(this.accelerator != 0 && hxd_Key.isReleased(this.accelerator) || src_Gamepad.isReleased(this.gamepadAccelerator)) {
				this.acceleratorWasPressed = false;
			}
		}
		super.update(dt,mouseState);
	}
	onMouseRelease(mouseState) {
		super.onMouseRelease(mouseState);
		if(this.pressedAction != null && !this.disabled) {
			this.pressedAction(new gui_GuiEvent(this));
		}
		if(this.buttonType == gui_ButtonType.Toggle) {
			this.pressed = !this.pressed;
		}
		if(this.buttonType == gui_ButtonType.Radio) {
			this.pressed = true;
			let _g = 0;
			let _g1 = this.parent.children;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				if(c != this && ((c) instanceof gui_GuiButton)) {
					let cb = c;
					if(cb.buttonType == gui_ButtonType.Radio) {
						cb.pressed = false;
					}
				}
			}
		}
	}
	onMouseEnter(mouseState) {
		super.onMouseEnter(mouseState);
		if(this.buttonSounds && !this.disabled) {
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/buttonover.wav",src_ResourceLoader.getAudio,this.soundResources));
		}
	}
}
$hxClasses["gui.GuiButton"] = gui_GuiButton;
gui_GuiButton.__name__ = "gui.GuiButton";
gui_GuiButton.__super__ = gui_GuiAnim;
Object.assign(gui_GuiButton.prototype, {
	__class__: gui_GuiButton
	,pressedAction: null
	,disabled: null
	,buttonType: null
	,pressed: null
	,buttonSounds: null
	,accelerator: null
	,gamepadAccelerator: null
	,acceleratorWasPressed: null
});
class gui_GuiConsoleScrollCtrl extends gui_GuiControl {
	constructor(scrollBar) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(scrollBar);
	}
	_hx_constructor(scrollBar) {
		this.dirty = true;
		this.pressed = false;
		this.scrollToBottom = true;
		this.scrollY = 0;
		super._hx_constructor();
		this.scrollTopTile = scrollBar.sub(0,37,18,8);
		this.scrollBottomTile = scrollBar.sub(0,55,18,8);
		this.scrollFillTile = scrollBar.sub(0,46,18,1);
		this.scrollTopPressedTile = scrollBar.sub(19,37,18,8);
		this.scrollBottomPressedTile = scrollBar.sub(19,55,18,8);
		this.scrollFillPressedTile = scrollBar.sub(19,46,18,1);
		this.scrollTrackTile = scrollBar.sub(0,64,18,1);
		let scrollUpTile = scrollBar.sub(0,1,18,17);
		let scrollDownTile = scrollBar.sub(0,19,18,17);
		let scrollUpPressedTile = scrollBar.sub(19,1,18,17);
		let scrollDownPressedTile = scrollBar.sub(19,19,18,17);
		let scrollUpDisabledTile = scrollBar.sub(38,1,18,17);
		let scrollDownDisabledTile = scrollBar.sub(38,19,18,17);
		this._manualScroll = true;
		this.scrollTrack = new gui_GuiImage(this.scrollTrackTile);
		this.addChild(this.scrollTrack);
		this.scrollUpButton = new gui_GuiButton([scrollUpTile,scrollUpTile,scrollUpPressedTile,scrollUpDisabledTile]);
		this.scrollUpButton.position = new h3d_Vector(0,0);
		this.scrollUpButton.extent = new h3d_Vector(18,17);
		this.scrollUpButton.horizSizing = gui_HorizSizing.Right;
		let _gthis = this;
		this.scrollUpButton.pressedAction = function(e) {
			_gthis.scrollY -= 10;
			_gthis.updateScrollVisual();
		};
		this.addChild(this.scrollUpButton);
		this.scrollDownButton = new gui_GuiButton([scrollDownTile,scrollDownTile,scrollDownPressedTile,scrollDownDisabledTile]);
		this.scrollDownButton.position = new h3d_Vector(0,0);
		this.scrollDownButton.extent = new h3d_Vector(18,17);
		this.scrollDownButton.horizSizing = gui_HorizSizing.Right;
		this.scrollDownButton.pressedAction = function(e) {
			_gthis.scrollY += 10;
			_gthis.updateScrollVisual();
		};
		this.addChild(this.scrollDownButton);
		this.scrollBarY = new h2d_Graphics();
		this.scrollTopBmp = new h2d_Bitmap(this.scrollTopTile);
		this.scrollBottomBmp = new h2d_Bitmap(this.scrollBottomTile);
		this.scrollFillBmp = new h2d_Bitmap(this.scrollFillTile);
		this.scrollBarY.addChild(this.scrollTopBmp);
		this.scrollBarY.addChild(this.scrollBottomBmp);
		this.scrollBarY.addChild(this.scrollFillBmp);
		let _this = this.scrollBarY;
		let v = src_Settings.uiScale;
		_this.posChanged = true;
		_this.scaleX *= v;
		_this.posChanged = true;
		_this.scaleY *= v;
		this.clickInteractive = new h2d_Interactive(18 * src_Settings.uiScale,1);
		this.clickInteractive.onPush = function(e) {
			if(!_gthis.pressed) {
				_gthis.pressed = true;
				_gthis.dirty = true;
				_gthis.updateScrollVisual();
				let prevEY = null;
				_gthis.clickInteractive.startCapture(function(e2) {
					if(e2.kind == hxd_EventKind.ERelease) {
						_gthis.clickInteractive.stopCapture();
					}
					if(e2.kind == hxd_EventKind.EMove) {
						if(prevEY == null) {
							prevEY = e2.relY;
						} else {
							_gthis.scrollY += e2.relY - prevEY;
							prevEY = e2.relY;
							_gthis.updateScrollVisual();
						}
					}
				},function() {
					if(_gthis.pressed) {
						_gthis.pressed = false;
						_gthis.dirty = true;
						_gthis.updateScrollVisual();
					}
				});
			}
		};
	}
	setScrollMax(max) {
		let renderRect = this.getRenderRectangle();
		if(this.scrollToBottom) {
			let scrollExtentY = renderRect.extent.y - 34 * src_Settings.uiScale;
			let scrollBarYSize = scrollExtentY * scrollExtentY / (this.maxScrollY * src_Settings.uiScale - 34 * src_Settings.uiScale);
			this.scrollY = scrollExtentY - scrollBarYSize * src_Settings.uiScale;
		} else {
			this.scrollY = 0;
		}
		this.maxScrollY = max;
		this.dirty = true;
		this.updateScrollVisual();
	}
	getRenderRectangle() {
		let rrec = super.getRenderRectangle();
		return rrec;
	}
	render(scene2d,parent) {
		this.dirty = true;
		this.scrollTrack.position = new h3d_Vector(this.extent.x - 18,0);
		this.scrollTrack.extent = new h3d_Vector(18,this.extent.y);
		this.scrollUpButton.position = new h3d_Vector(this.extent.x - 18,0);
		this.scrollDownButton.position = new h3d_Vector(this.extent.x - 18,this.extent.y - 17);
		if(scene2d.contains(this.scrollBarY)) {
			scene2d.removeChild(this.scrollBarY);
		}
		if(scene2d.contains(this.clickInteractive)) {
			scene2d.removeChild(this.clickInteractive);
		}
		scene2d.addChild(this.scrollBarY);
		scene2d.addChild(this.clickInteractive);
		this.updateScrollVisual();
		super.render(scene2d,parent);
	}
	updateScrollVisual() {
		let renderRect = this.getRenderRectangle();
		if(this.maxScrollY < renderRect.extent.y) {
			this.scrollBarY.set_visible(false);
			return;
		}
		this.scrollBarY.set_visible(true);
		let scrollExtentY = renderRect.extent.y - 34 * src_Settings.uiScale;
		let scrollBarYSize = scrollExtentY * scrollExtentY / (this.maxScrollY * src_Settings.uiScale - 34 * src_Settings.uiScale);
		let _this = this.scrollTrack.bmp;
		_this.posChanged = true;
		_this.scaleY = renderRect.extent.y;
		let value = this.scrollY;
		let max = scrollExtentY - scrollBarYSize * src_Settings.uiScale;
		this.scrollY = value < 0 ? 0 : value > max ? max : value;
		let _this1 = this.scrollBarY;
		_this1.posChanged = true;
		_this1.x = renderRect.position.x + renderRect.extent.x - 18 * src_Settings.uiScale;
		_this1.posChanged = true;
		_this1.y = 18 * src_Settings.uiScale + renderRect.position.y + this.scrollY;
		let _this2 = this.clickInteractive;
		_this2.posChanged = true;
		_this2.x = renderRect.position.x + renderRect.extent.x - 18 * src_Settings.uiScale;
		_this2.posChanged = true;
		_this2.y = 18 * src_Settings.uiScale + renderRect.position.y;
		this.clickInteractive.height = scrollExtentY;
		if(this.dirty) {
			if(scrollBarYSize > scrollExtentY) {
				this.scrollBarY.set_visible(false);
				return;
			}
			this.scrollTopBmp.set_tile(this.pressed ? this.scrollTopPressedTile : this.scrollTopTile);
			this.scrollBottomBmp.set_tile(this.pressed ? this.scrollBottomPressedTile : this.scrollBottomTile);
			this.scrollFillBmp.set_tile(this.pressed ? this.scrollFillPressedTile : this.scrollFillTile);
			let _this = this.scrollBottomBmp;
			_this.posChanged = true;
			_this.y = scrollBarYSize - 8;
			let _this1 = this.scrollFillBmp;
			_this1.posChanged = true;
			_this1.y = 8;
			let _this2 = this.scrollFillBmp;
			_this2.posChanged = true;
			_this2.scaleY = scrollBarYSize - 12;
			this.dirty = false;
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			if(c == this.scrollTrack || c == this.scrollUpButton || c == this.scrollDownButton) {
				continue;
			}
			c.onScroll(0,this.scrollY * (this.maxScrollY - 34 * src_Settings.uiScale) / scrollExtentY);
		}
	}
	dispose() {
		super.dispose();
		let _this = this.scrollBarY;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
		let _this1 = this.clickInteractive;
		if(_this1 != null && _this1.parent != null) {
			_this1.parent.removeChild(_this1);
		}
	}
	onRemove() {
		super.onRemove();
		if(src_MarbleGame.canvas.scene2d.contains(this.scrollBarY)) {
			src_MarbleGame.canvas.scene2d.removeChild(this.scrollBarY);
		}
		if(src_MarbleGame.canvas.scene2d.contains(this.clickInteractive)) {
			src_MarbleGame.canvas.scene2d.removeChild(this.clickInteractive);
		}
	}
	onMousePress(mouseState) {
		if(src_Util.isTouchDevice()) {
			this.pressed = true;
			this.dirty = true;
			this.updateScrollVisual();
			this.prevMousePos = mouseState.position;
		}
	}
	onMouseRelease(mouseState) {
		if(src_Util.isTouchDevice()) {
			this.pressed = false;
			this.dirty = true;
			this.updateScrollVisual();
		}
	}
	onMouseMove(mouseState) {
		if(src_Util.isTouchDevice()) {
			super.onMouseMove(mouseState);
			if(this.pressed) {
				let dy = mouseState.position.y - this.prevMousePos.y;
				this.scrollY -= dy;
				this.prevMousePos = mouseState.position;
				this.updateScrollVisual();
			}
		}
	}
}
$hxClasses["gui.GuiConsoleScrollCtrl"] = gui_GuiConsoleScrollCtrl;
gui_GuiConsoleScrollCtrl.__name__ = "gui.GuiConsoleScrollCtrl";
gui_GuiConsoleScrollCtrl.__super__ = gui_GuiControl;
Object.assign(gui_GuiConsoleScrollCtrl.prototype, {
	__class__: gui_GuiConsoleScrollCtrl
	,scrollY: null
	,scrollToBottom: null
	,maxScrollY: null
	,scrollBarY: null
	,scrollTrack: null
	,scrollTopTile: null
	,scrollBottomTile: null
	,scrollFillTile: null
	,scrollTopBmp: null
	,scrollBottomBmp: null
	,scrollFillBmp: null
	,scrollTopPressedTile: null
	,scrollBottomPressedTile: null
	,scrollFillPressedTile: null
	,scrollTrackTile: null
	,clickInteractive: null
	,pressed: null
	,dirty: null
	,prevMousePos: null
	,scrollUpButton: null
	,scrollDownButton: null
});
var gui_HorizSizing = $hxEnums["gui.HorizSizing"] = { __ename__:true,__constructs__:null
	,Right: {_hx_name:"Right",_hx_index:0,__enum__:"gui.HorizSizing",toString:$estr}
	,Width: {_hx_name:"Width",_hx_index:1,__enum__:"gui.HorizSizing",toString:$estr}
	,Left: {_hx_name:"Left",_hx_index:2,__enum__:"gui.HorizSizing",toString:$estr}
	,Center: {_hx_name:"Center",_hx_index:3,__enum__:"gui.HorizSizing",toString:$estr}
	,Relative: {_hx_name:"Relative",_hx_index:4,__enum__:"gui.HorizSizing",toString:$estr}
	,Height: {_hx_name:"Height",_hx_index:5,__enum__:"gui.HorizSizing",toString:$estr}
};
gui_HorizSizing.__constructs__ = [gui_HorizSizing.Right,gui_HorizSizing.Width,gui_HorizSizing.Left,gui_HorizSizing.Center,gui_HorizSizing.Relative,gui_HorizSizing.Height];
gui_HorizSizing.__empty_constructs__ = [gui_HorizSizing.Right,gui_HorizSizing.Width,gui_HorizSizing.Left,gui_HorizSizing.Center,gui_HorizSizing.Relative,gui_HorizSizing.Height];
var gui_VertSizing = $hxEnums["gui.VertSizing"] = { __ename__:true,__constructs__:null
	,Bottom: {_hx_name:"Bottom",_hx_index:0,__enum__:"gui.VertSizing",toString:$estr}
	,Height: {_hx_name:"Height",_hx_index:1,__enum__:"gui.VertSizing",toString:$estr}
	,Top: {_hx_name:"Top",_hx_index:2,__enum__:"gui.VertSizing",toString:$estr}
	,Center: {_hx_name:"Center",_hx_index:3,__enum__:"gui.VertSizing",toString:$estr}
	,Relative: {_hx_name:"Relative",_hx_index:4,__enum__:"gui.VertSizing",toString:$estr}
	,Width: {_hx_name:"Width",_hx_index:5,__enum__:"gui.VertSizing",toString:$estr}
};
gui_VertSizing.__constructs__ = [gui_VertSizing.Bottom,gui_VertSizing.Height,gui_VertSizing.Top,gui_VertSizing.Center,gui_VertSizing.Relative,gui_VertSizing.Width];
gui_VertSizing.__empty_constructs__ = [gui_VertSizing.Bottom,gui_VertSizing.Height,gui_VertSizing.Top,gui_VertSizing.Center,gui_VertSizing.Relative,gui_VertSizing.Width];
class gui_GuiEvent {
	constructor(sender) {
		this.sender = sender;
		this.propagate = true;
	}
}
$hxClasses["gui.GuiEvent"] = gui_GuiEvent;
gui_GuiEvent.__name__ = "gui.GuiEvent";
Object.assign(gui_GuiEvent.prototype, {
	__class__: gui_GuiEvent
	,sender: null
	,propagate: null
});
class gui_GuiGraphics extends gui_GuiControl {
	constructor(graphics) {
		if(gui_GuiControl._hx_skip_constructor) {
			super();
			return;
		}
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(graphics);
	}
	_hx_constructor(graphics) {
		this.pressedAction = null;
		super._hx_constructor();
		this.graphics = graphics;
	}
	render(scene2d,parent) {
		let renderRect = this.getRenderRectangle();
		let _this = this.graphics;
		let x = Math.floor(renderRect.position.x);
		let y = Math.floor(renderRect.position.y);
		_this.posChanged = true;
		_this.x = x;
		_this.posChanged = true;
		_this.y = y;
		if(scene2d.contains(this.graphics)) {
			scene2d.removeChild(this.graphics);
		}
		scene2d.addChild(this.graphics);
		super.render(scene2d);
	}
	dispose() {
		super.dispose();
		let _this = this.graphics;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
	onMouseRelease(mouseState) {
		super.onMouseRelease(mouseState);
		if(this.pressedAction != null) {
			this.pressedAction(this);
		}
	}
	onRemove() {
		super.onRemove();
		if(src_MarbleGame.canvas.scene2d.contains(this.graphics)) {
			src_MarbleGame.canvas.scene2d.removeChild(this.graphics);
		}
	}
}
$hxClasses["gui.GuiGraphics"] = gui_GuiGraphics;
gui_GuiGraphics.__name__ = "gui.GuiGraphics";
gui_GuiGraphics.__super__ = gui_GuiControl;
Object.assign(gui_GuiGraphics.prototype, {
	__class__: gui_GuiGraphics
	,graphics: null
	,pressedAction: null
});
class gui_GuiLoadAnim extends gui_GuiAnim {
	constructor() {
		let img = src_ResourceLoader.getImage("data/ui/xbox/loadingAnimation.png").resource.toTile();
		let f1 = img.sub(0,1,63,63);
		let f2 = img.sub(64,1,63,63);
		let f3 = img.sub(0,65,63,63);
		let f4 = img.sub(64,65,63,63);
		let f5 = img.sub(0,129,63,63);
		let f6 = img.sub(64,129,63,63);
		let f7 = img.sub(0,193,63,63);
		super([f1,f2,f3,f4,f5,f6,f7]);
		this.anim.loop = true;
		this.anim.speed = 20;
	}
}
$hxClasses["gui.GuiLoadAnim"] = gui_GuiLoadAnim;
gui_GuiLoadAnim.__name__ = "gui.GuiLoadAnim";
gui_GuiLoadAnim.__super__ = gui_GuiAnim;
Object.assign(gui_GuiLoadAnim.prototype, {
	__class__: gui_GuiLoadAnim
});
class gui_GuiMLText extends gui_GuiControl {
	constructor(font,loadFontFunc) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(font,loadFontFunc);
	}
	_hx_constructor(font,loadFontFunc) {
		this._scroll = 0;
		this.scrollable = false;
		this.justify = gui_Justification.Left;
		super._hx_constructor();
		this.text = new gui_HtmlText(font);
		this.text.loadFont = loadFontFunc;
		this._manualScroll = true;
	}
	render(scene2d,parent) {
		let renderRect = this.getRenderRectangle();
		this.text.set_maxWidth(renderRect.extent.x);
		if(parent != null) {
			if(parent.contains(this.text)) {
				parent.removeChild(this.text);
			}
			parent.addChild(this.text);
			let off = this.getOffsetFromParent();
			let props = parent.getProperties(this.text);
			props.set_isAbsolute(true);
			if(this.justify == gui_Justification.Left) {
				let _this = this.text;
				let x = Math.floor(off.x);
				let y = Math.floor(off.y);
				_this.posChanged = true;
				_this.x = x;
				_this.posChanged = true;
				_this.y = y;
				this.text.set_textAlign(h2d_Align.Left);
			}
			if(this.justify == gui_Justification.Right) {
				let _this = this.text;
				let x = Math.floor(off.x + renderRect.extent.x);
				let y = Math.floor(off.y);
				_this.posChanged = true;
				_this.x = x;
				_this.posChanged = true;
				_this.y = y;
				this.text.set_textAlign(h2d_Align.Right);
			}
			if(this.justify == gui_Justification.Center) {
				let _this = this.text;
				let x = Math.floor(off.x + renderRect.extent.x / 2);
				let y = Math.floor(off.y);
				_this.posChanged = true;
				_this.x = x;
				_this.posChanged = true;
				_this.y = y;
				this.text.set_textAlign(h2d_Align.Center);
			}
		}
		super.render(scene2d,parent);
	}
	dispose() {
		super.dispose();
		if(!this.scrollable) {
			let _this = this.text;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		} else {
			let _this = this.flow;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		let _this = this.text;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
	onRemove() {
		super.onRemove();
		if(src_MarbleGame.canvas.scene2d.contains(this.flow)) {
			src_MarbleGame.canvas.scene2d.removeChild(this.flow);
		}
		if(src_MarbleGame.canvas.scene2d.contains(this.text)) {
			src_MarbleGame.canvas.scene2d.removeChild(this.text);
		}
		let _this = this.text;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
	onScroll(scrollX,scrollY) {
		this._scroll = scrollY;
		let _this = this.text;
		_this.posChanged = true;
		_this.x = this.text.x;
		_this.posChanged = true;
		_this.y = -scrollY;
		if(this.flow != null) {
			this.flow.getProperties(this.text).offsetY = -scrollY;
		}
	}
}
$hxClasses["gui.GuiMLText"] = gui_GuiMLText;
gui_GuiMLText.__name__ = "gui.GuiMLText";
gui_GuiMLText.__super__ = gui_GuiControl;
Object.assign(gui_GuiMLText.prototype, {
	__class__: gui_GuiMLText
	,text: null
	,justify: null
	,flow: null
	,scrollable: null
	,_scroll: null
});
class gui_GuiMLTextListCtrl extends gui_GuiControl {
	constructor(font,texts,imageLoader,filter) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(font,texts,imageLoader,filter);
	}
	_hx_constructor(font,texts,imageLoader,filter) {
		this.filter = null;
		this.scrollable = false;
		this.scroll = 0;
		this.textYOffset = 0;
		this.selectedFillColor = 13158600;
		this.selectedColor = 2122852;
		this._prevSelected = -1;
		super._hx_constructor();
		this.font = font;
		this.texts = texts;
		this._manualScroll = true;
		this.textObjs = [];
		this.filter = filter;
		this._imageLoader = imageLoader;
		let _g = 0;
		while(_g < texts.length) {
			let text = texts[_g];
			++_g;
			let tobj = new h2d_HtmlText(font);
			tobj.set_lineHeightMode(h2d_LineHeightMode.TextOnly);
			tobj.loadImage = imageLoader;
			tobj.set_text(text);
			tobj.set_textColor(0);
			if(filter != null) {
				tobj.set_filter(filter);
			}
			this.textObjs.push(tobj);
		}
		this.g = new h2d_Graphics();
	}
	setTexts(texts) {
		let renderRect = this.getRenderRectangle();
		let _g = 0;
		let _g1 = this.textObjs;
		while(_g < _g1.length) {
			let textObj = _g1[_g];
			++_g;
			if(textObj != null && textObj.parent != null) {
				textObj.parent.removeChild(textObj);
			}
		}
		this.textObjs = [];
		let _g2 = 0;
		while(_g2 < texts.length) {
			let text = texts[_g2];
			++_g2;
			let tobj = new h2d_HtmlText(this.font);
			tobj.loadImage = this._imageLoader;
			tobj.set_lineHeightMode(h2d_LineHeightMode.TextOnly);
			tobj.set_text(text);
			tobj.set_textColor(0);
			if(this.filter != null) {
				tobj.set_filter(this.filter);
			}
			this.textObjs.push(tobj);
			if(this.scrollable) {
				if(this.flow != null) {
					if(this.flow.contains(tobj)) {
						this.flow.removeChild(tobj);
					}
					this.flow.addChild(tobj);
					this.flow.getProperties(tobj).set_isAbsolute(true);
				}
			}
		}
		this.texts = texts;
		this._prevSelected = -1;
		if(this.onSelectedFunc != null) {
			this.onSelectedFunc(-1);
		}
		this.redrawSelectionRect(renderRect);
		let _g3 = 0;
		let _g4 = this.textObjs.length;
		while(_g3 < _g4) {
			let i = _g3++;
			let text = this.textObjs[i];
			let x = Math.floor((!this.scrollable ? renderRect.position.x : 0) + 5);
			let y = Math.floor((!this.scrollable ? renderRect.position.y : 0) + (i * (text.font.size + 4 * src_Settings.uiScale) + (5 + this.textYOffset) * src_Settings.uiScale - this.scroll));
			text.posChanged = true;
			text.x = x;
			text.posChanged = true;
			text.y = y;
			if(this._prevSelected == i) {
				text.set_textColor(this.selectedColor);
			}
		}
	}
	render(scene2d,parent) {
		let renderRect = this.getRenderRectangle();
		let htr = this.getHitTestRect(false);
		if(parent != null) {
			if(parent.contains(this.g)) {
				parent.removeChild(this.g);
			}
			parent.addChild(this.g);
			let off = this.getOffsetFromParent();
			parent.getProperties(this.g).set_isAbsolute(true);
			let _this = this.g;
			_this.posChanged = true;
			_this.x = off.x;
			_this.posChanged = true;
			_this.y = off.y - this.scroll;
		}
		if(this.scrollable) {
			this.flow = new h2d_Flow();
			this.flow.set_maxWidth(htr.extent.x);
			this.flow.set_maxHeight(htr.extent.y);
			this.flow.set_multiline(true);
			this.flow.set_layout(h2d_FlowLayout.Stack);
			this.flow.set_overflow(h2d_FlowOverflow.Hidden);
			if(parent != null) {
				if(parent.contains(this.flow)) {
					parent.removeChild(this.flow);
				}
				parent.addChild(this.flow);
				let off = this.getOffsetFromParent();
				let props = parent.getProperties(this.flow);
				props.set_isAbsolute(true);
				let _this = this.flow;
				_this.posChanged = true;
				_this.x = off.x;
				_this.posChanged = true;
				_this.y = off.y;
			}
		}
		let _g = 0;
		let _g1 = this.textObjs.length;
		while(_g < _g1) {
			let i = _g++;
			let text = this.textObjs[i];
			if(!this.scrollable) {
				if(scene2d.contains(text)) {
					scene2d.removeChild(text);
				}
				scene2d.addChild(text);
			} else {
				if(this.flow.contains(text)) {
					this.flow.removeChild(text);
				}
				this.flow.addChild(text);
				this.flow.getProperties(text).set_isAbsolute(true);
			}
			let x = Math.floor((!this.scrollable ? renderRect.position.x : 0) + 5);
			let y = Math.floor((!this.scrollable ? renderRect.position.y : 0) + (i * (text.font.size + 4 * src_Settings.uiScale) + (5 + this.textYOffset) * src_Settings.uiScale - this.scroll));
			text.posChanged = true;
			text.x = x;
			text.posChanged = true;
			text.y = y;
			if(this._prevSelected == i) {
				text.set_textColor(this.selectedColor);
			}
		}
		this.redrawSelectionRect(htr);
		super.render(scene2d,parent);
	}
	dispose() {
		super.dispose();
		let _g = 0;
		let _g1 = this.textObjs;
		while(_g < _g1.length) {
			let text = _g1[_g];
			++_g;
			if(text != null && text.parent != null) {
				text.parent.removeChild(text);
			}
		}
		let _this = this.g;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
		if(this.scrollable) {
			let _this = this.flow;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
	}
	onRemove() {
		super.onRemove();
		let _g = 0;
		let _g1 = this.textObjs;
		while(_g < _g1.length) {
			let text = _g1[_g];
			++_g;
			if(src_MarbleGame.canvas.scene2d.contains(text)) {
				src_MarbleGame.canvas.scene2d.removeChild(text);
			}
			if(text != null && text.parent != null) {
				text.parent.removeChild(text);
			}
		}
		if(src_MarbleGame.canvas.scene2d.contains(this.g)) {
			src_MarbleGame.canvas.scene2d.removeChild(this.g);
		}
		let _this = this.g;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
	onMouseMove(mouseState) {
		let mousePos = mouseState.position;
		let renderRect = this.getRenderRectangle();
		let yStart = renderRect.position.y;
		let dy = mousePos.y - yStart;
		let hoverIndex = Math.floor(dy / (this.font.size + 4 * src_Settings.uiScale));
		if(hoverIndex >= this.texts.length) {
			hoverIndex = -1;
		}
		let _g = 0;
		let _g1 = this.textObjs.length;
		while(_g < _g1) {
			let i = _g++;
			let selected = i == hoverIndex || i == this._prevSelected;
			let text = this.textObjs[i];
			text.set_textColor(selected ? this.selectedColor : 0);
		}
	}
	onMouseLeave(mouseState) {
		let _g = 0;
		let _g1 = this.textObjs.length;
		while(_g < _g1) {
			let i = _g++;
			if(i == this._prevSelected) {
				continue;
			}
			let text = this.textObjs[i];
			text.set_textColor(0);
		}
	}
	onMousePress(mouseState) {
		super.onMousePress(mouseState);
		let mousePos = mouseState.position;
		let renderRect = this.getRenderRectangle();
		let yStart = renderRect.position.y;
		let dy = mousePos.y - yStart;
		let selectedIndex = Math.floor((dy + this.scroll) / (this.font.size + 4 * src_Settings.uiScale));
		if(selectedIndex >= this.texts.length) {
			selectedIndex = -1;
		}
		if(this._prevSelected != selectedIndex) {
			this._prevSelected = selectedIndex;
			this.redrawSelectionRect(renderRect);
		}
		if(this.onSelectedFunc != null) {
			this.onSelectedFunc(selectedIndex);
		}
	}
	redrawSelectionRect(renderRect) {
		if(this._prevSelected != -1) {
			this.g.clear();
			this.g.beginFill(this.selectedFillColor);
			let off = this.getOffsetFromParent();
			let topY = 2 * src_Settings.uiScale + this._prevSelected * (this.font.size + 4 * src_Settings.uiScale) + this.g.y;
			let bottomY = 2 * src_Settings.uiScale + this._prevSelected * (this.font.size + 4 * src_Settings.uiScale) + this.g.y + this.font.size + 4 * src_Settings.uiScale;
			let topRectY = off.y;
			let bottomRectY = off.y + renderRect.extent.y;
			if(topY >= topRectY && bottomY <= bottomRectY) {
				this.g.drawRect(0,5 * src_Settings.uiScale + this._prevSelected * (this.font.size + 4 * src_Settings.uiScale) - 3 * src_Settings.uiScale,renderRect.extent.x,this.font.size + 4 * src_Settings.uiScale);
			}
			if(topY <= topRectY && bottomY >= topRectY) {
				this.g.drawRect(0,this.scroll,renderRect.extent.x,topY + this.font.size + 4 * src_Settings.uiScale - off.y);
			}
			if(topY <= bottomRectY && bottomY >= bottomRectY) {
				this.g.drawRect(0,this.scroll + renderRect.extent.y - this.font.size - 4 * src_Settings.uiScale + (topY + this.font.size + 4 * src_Settings.uiScale - bottomRectY),renderRect.extent.x,off.y + renderRect.extent.y - topY);
			}
			this.g.endFill();
		} else {
			this.g.clear();
		}
	}
	onScroll(scrollX,scrollY) {
		super.onScroll(scrollX,scrollY);
		this.getRenderRectangle();
		this.scroll = scrollY;
		let hittestrect = this.getHitTestRect(false);
		let _g = 0;
		let _g1 = this.textObjs.length;
		while(_g < _g1) {
			let i = _g++;
			let text = this.textObjs[i];
			let v = Math.floor(i * (text.font.size + 4 * src_Settings.uiScale) + (5 + this.textYOffset) * src_Settings.uiScale - scrollY);
			text.posChanged = true;
			text.y = v;
			let _this = this.g;
			_this.posChanged = true;
			_this.y = -scrollY;
		}
		this.redrawSelectionRect(hittestrect);
	}
}
$hxClasses["gui.GuiMLTextListCtrl"] = gui_GuiMLTextListCtrl;
gui_GuiMLTextListCtrl.__name__ = "gui.GuiMLTextListCtrl";
gui_GuiMLTextListCtrl.__super__ = gui_GuiControl;
Object.assign(gui_GuiMLTextListCtrl.prototype, {
	__class__: gui_GuiMLTextListCtrl
	,texts: null
	,onSelectedFunc: null
	,font: null
	,textObjs: null
	,g: null
	,_prevSelected: null
	,selectedColor: null
	,selectedFillColor: null
	,textYOffset: null
	,scroll: null
	,scrollable: null
	,filter: null
	,flow: null
	,_imageLoader: null
});
var gui_Justification = $hxEnums["gui.Justification"] = { __ename__:true,__constructs__:null
	,Left: {_hx_name:"Left",_hx_index:0,__enum__:"gui.Justification",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:1,__enum__:"gui.Justification",toString:$estr}
	,Center: {_hx_name:"Center",_hx_index:2,__enum__:"gui.Justification",toString:$estr}
};
gui_Justification.__constructs__ = [gui_Justification.Left,gui_Justification.Right,gui_Justification.Center];
gui_Justification.__empty_constructs__ = [gui_Justification.Left,gui_Justification.Right,gui_Justification.Center];
class gui_GuiText extends gui_GuiControl {
	constructor(font) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(font);
	}
	_hx_constructor(font) {
		this.justify = gui_Justification.Left;
		super._hx_constructor();
		this.text = new h2d_Text(font);
	}
	render(scene2d,parent) {
		let renderRect = this.getRenderRectangle();
		if(parent != null) {
			if(parent.contains(this.text)) {
				parent.removeChild(this.text);
			}
			parent.addChild(this.text);
			let off = this.getOffsetFromParent();
			let props = parent.getProperties(this.text);
			props.set_isAbsolute(true);
			if(this.justify == gui_Justification.Left) {
				let _this = this.text;
				let x = Math.floor(off.x);
				let y = Math.floor(off.y);
				_this.posChanged = true;
				_this.x = x;
				_this.posChanged = true;
				_this.y = y;
				this.text.set_textAlign(h2d_Align.Left);
			}
			if(this.justify == gui_Justification.Right) {
				let _this = this.text;
				let x = Math.floor(off.x + renderRect.extent.x);
				let y = Math.floor(off.y);
				_this.posChanged = true;
				_this.x = x;
				_this.posChanged = true;
				_this.y = y;
				this.text.set_textAlign(h2d_Align.Right);
			}
			if(this.justify == gui_Justification.Center) {
				let _this = this.text;
				let x = Math.floor(off.x + renderRect.extent.x / 2);
				let y = Math.floor(off.y);
				_this.posChanged = true;
				_this.x = x;
				_this.posChanged = true;
				_this.y = y;
				this.text.set_textAlign(h2d_Align.Center);
			}
		}
		super.render(scene2d,parent);
	}
	dispose() {
		super.dispose();
		let _this = this.text;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
	onRemove() {
		super.onRemove();
		if(src_MarbleGame.canvas.scene2d.contains(this.text)) {
			src_MarbleGame.canvas.scene2d.removeChild(this.text);
		}
		let _this = this.text;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
}
$hxClasses["gui.GuiText"] = gui_GuiText;
gui_GuiText.__name__ = "gui.GuiText";
gui_GuiText.__super__ = gui_GuiControl;
Object.assign(gui_GuiText.prototype, {
	__class__: gui_GuiText
	,text: null
	,justify: null
});
class gui_GuiTextInput extends gui_GuiControl {
	constructor(font) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(font);
	}
	_hx_constructor(font) {
		this.justify = gui_Justification.Left;
		super._hx_constructor();
		this.text = new h2d_TextInput(font);
		let _gthis = this;
		this.text.onChange = function() {
			if(_gthis.onTextChange != null) {
				_gthis.onTextChange(_gthis.text.text);
			}
		};
	}
	render(scene2d,parent) {
		let renderRect = this.getRenderRectangle();
		if(parent != null) {
			if(parent.contains(this.text)) {
				parent.removeChild(this.text);
			}
			parent.addChild(this.text);
			let off = this.getOffsetFromParent();
			let props = parent.getProperties(this.text);
			props.set_isAbsolute(true);
			if(this.justify == gui_Justification.Left) {
				let _this = this.text;
				let x = Math.floor(off.x);
				let y = Math.floor(off.y);
				_this.posChanged = true;
				_this.x = x;
				_this.posChanged = true;
				_this.y = y;
				this.text.set_textAlign(h2d_Align.Left);
			}
			if(this.justify == gui_Justification.Right) {
				let _this = this.text;
				let x = Math.floor(off.x + renderRect.extent.x);
				let y = Math.floor(off.y);
				_this.posChanged = true;
				_this.x = x;
				_this.posChanged = true;
				_this.y = y;
				this.text.set_textAlign(h2d_Align.Right);
			}
			if(this.justify == gui_Justification.Center) {
				let _this = this.text;
				let x = Math.floor(off.x + renderRect.extent.x / 2);
				let y = Math.floor(off.y);
				_this.posChanged = true;
				_this.x = x;
				_this.posChanged = true;
				_this.y = y;
				this.text.set_textAlign(h2d_Align.Center);
			}
		}
		this.text.inputWidth = renderRect.extent.x;
		super.render(scene2d,parent);
	}
	dispose() {
		super.dispose();
		let _this = this.text;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
	onRemove() {
		super.onRemove();
		if(src_MarbleGame.canvas.scene2d.contains(this.text)) {
			src_MarbleGame.canvas.scene2d.removeChild(this.text);
		}
		let _this = this.text;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
	onMousePress(mouseState) {
		super.onMousePress(mouseState);
		if(src_Util.isTouchDevice()) {
			this.text.set_text(window.prompt("Enter your input",this.text.text));
			this.onTextChange(this.text.text);
			window;
		}
	}
	setCaretColor(col) {
		let tmp = 1 / hxd_Window.getInstance().get_windowToPixelRatio() | 0;
		this.text.cursorTile = h2d_Tile.fromColor(col,tmp,this.text.font.size);
		let tmp1 = hxd_Window.getInstance().get_windowToPixelRatio();
		this.text.cursorTile.dy = 2 / tmp1;
	}
}
$hxClasses["gui.GuiTextInput"] = gui_GuiTextInput;
gui_GuiTextInput.__name__ = "gui.GuiTextInput";
gui_GuiTextInput.__super__ = gui_GuiControl;
Object.assign(gui_GuiTextInput.prototype, {
	__class__: gui_GuiTextInput
	,text: null
	,justify: null
	,onTextChange: null
});
class gui_GuiTextListCtrl extends gui_GuiControl {
	constructor(font,texts,textColor) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(font,texts,textColor);
	}
	_hx_constructor(font,texts,textColor) {
		if(textColor == null) {
			textColor = 0;
		}
		this.scrollable = false;
		this.scroll = 0;
		this.textYOffset = 0;
		this.textColor = 0;
		this.selectedFillColor = 13158600;
		this.selectedColor = 2122852;
		this._prevSelected = -1;
		super._hx_constructor();
		this.font = font;
		this.texts = texts;
		this._manualScroll = true;
		this.textObjs = [];
		this.textColor = textColor;
		let _g = 0;
		while(_g < texts.length) {
			let text = texts[_g];
			++_g;
			let tobj = new h2d_Text(font);
			tobj.set_text(text);
			tobj.set_textColor(textColor);
			this.textObjs.push(tobj);
		}
		this.g = new h2d_Graphics();
	}
	render(scene2d,parent) {
		let renderRect = this.getRenderRectangle();
		let htr = this.getHitTestRect(false);
		if(parent != null) {
			if(parent.contains(this.g)) {
				parent.removeChild(this.g);
			}
			parent.addChild(this.g);
			let off = this.getOffsetFromParent();
			parent.getProperties(this.g).set_isAbsolute(true);
			let _this = this.g;
			_this.posChanged = true;
			_this.x = off.x;
			_this.posChanged = true;
			_this.y = off.y - this.scroll;
		}
		if(this.scrollable) {
			this.flow = new h2d_Flow();
			this.flow.set_maxWidth(htr.extent.x);
			this.flow.set_maxHeight(htr.extent.y);
			this.flow.set_multiline(true);
			this.flow.set_layout(h2d_FlowLayout.Stack);
			this.flow.set_overflow(h2d_FlowOverflow.Hidden);
			if(parent != null) {
				if(parent.contains(this.flow)) {
					parent.removeChild(this.flow);
				}
				parent.addChild(this.flow);
				let off = this.getOffsetFromParent();
				let props = parent.getProperties(this.flow);
				props.set_isAbsolute(true);
				let _this = this.flow;
				_this.posChanged = true;
				_this.x = off.x;
				_this.posChanged = true;
				_this.y = off.y;
			}
		}
		let _g = 0;
		let _g1 = this.textObjs.length;
		while(_g < _g1) {
			let i = _g++;
			let text = this.textObjs[i];
			if(!this.scrollable) {
				if(scene2d.contains(text)) {
					scene2d.removeChild(text);
				}
				scene2d.addChild(text);
			} else {
				if(this.flow.contains(text)) {
					this.flow.removeChild(text);
				}
				this.flow.addChild(text);
				this.flow.getProperties(text).set_isAbsolute(true);
			}
			let x = Math.floor((!this.scrollable ? renderRect.position.x : 0) + 5);
			let y = Math.floor((!this.scrollable ? renderRect.position.y : 0) + (i * (text.font.size + 4 * src_Settings.uiScale) + (5 + this.textYOffset) * src_Settings.uiScale - this.scroll));
			text.posChanged = true;
			text.x = x;
			text.posChanged = true;
			text.y = y;
			if(this._prevSelected == i) {
				text.set_textColor(this.selectedColor);
			}
		}
		this.redrawSelectionRect(htr);
		super.render(scene2d,parent);
	}
	calculateFullHeight() {
		return this.texts.length * (this.font.size + 4 * src_Settings.uiScale);
	}
	dispose() {
		super.dispose();
		let _g = 0;
		let _g1 = this.textObjs;
		while(_g < _g1.length) {
			let text = _g1[_g];
			++_g;
			if(text != null && text.parent != null) {
				text.parent.removeChild(text);
			}
		}
		let _this = this.g;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
		if(this.scrollable) {
			let _this = this.flow;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
	}
	onRemove() {
		super.onRemove();
		let _g = 0;
		let _g1 = this.textObjs;
		while(_g < _g1.length) {
			let text = _g1[_g];
			++_g;
			if(src_MarbleGame.canvas.scene2d.contains(text)) {
				src_MarbleGame.canvas.scene2d.removeChild(text);
			}
			if(text != null && text.parent != null) {
				text.parent.removeChild(text);
			}
		}
		if(src_MarbleGame.canvas.scene2d.contains(this.g)) {
			src_MarbleGame.canvas.scene2d.removeChild(this.g);
		}
		let _this = this.g;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
	}
	onMouseMove(mouseState) {
		let mousePos = mouseState.position;
		let renderRect = this.getRenderRectangle();
		let yStart = renderRect.position.y;
		let dy = mousePos.y - yStart;
		let hoverIndex = Math.floor((dy + this.scroll) / (this.font.size + 4 * src_Settings.uiScale));
		if(hoverIndex >= this.texts.length) {
			hoverIndex = -1;
		}
		let _g = 0;
		let _g1 = this.textObjs.length;
		while(_g < _g1) {
			let i = _g++;
			let selected = i == hoverIndex || i == this._prevSelected;
			let text = this.textObjs[i];
			text.set_textColor(selected ? this.selectedColor : this.textColor);
		}
	}
	onMouseLeave(mouseState) {
		let _g = 0;
		let _g1 = this.textObjs.length;
		while(_g < _g1) {
			let i = _g++;
			if(i == this._prevSelected) {
				continue;
			}
			let text = this.textObjs[i];
			text.set_textColor(this.textColor);
		}
	}
	onMousePress(mouseState) {
		super.onMousePress(mouseState);
		let mousePos = mouseState.position;
		let renderRect = this.getRenderRectangle();
		let yStart = renderRect.position.y;
		let dy = mousePos.y - yStart;
		let selectedIndex = Math.floor((dy + this.scroll) / (this.font.size + 4 * src_Settings.uiScale));
		if(selectedIndex >= this.texts.length) {
			selectedIndex = -1;
		}
		if(this._prevSelected != selectedIndex) {
			this._prevSelected = selectedIndex;
			this.redrawSelectionRect(renderRect);
		}
		if(this.onSelectedFunc != null) {
			this.onSelectedFunc(selectedIndex);
		}
	}
	redrawSelectionRect(renderRect) {
		if(this._prevSelected != -1) {
			this.g.clear();
			this.g.beginFill(this.selectedFillColor);
			let off = this.getOffsetFromParent();
			let topY = 2 * src_Settings.uiScale + this._prevSelected * (this.font.size + 4 * src_Settings.uiScale) + this.g.y;
			let bottomY = 2 * src_Settings.uiScale + this._prevSelected * (this.font.size + 4 * src_Settings.uiScale) + this.g.y + this.font.size + 4 * src_Settings.uiScale;
			let topRectY = off.y;
			let bottomRectY = off.y + renderRect.extent.y;
			if(topY >= topRectY && bottomY <= bottomRectY) {
				this.g.drawRect(0,5 * src_Settings.uiScale + this._prevSelected * (this.font.size + 4 * src_Settings.uiScale) - 3 * src_Settings.uiScale,renderRect.extent.x,this.font.size + 4 * src_Settings.uiScale);
			}
			if(topY <= topRectY && bottomY >= topRectY) {
				this.g.drawRect(0,this.scroll,renderRect.extent.x,topY + this.font.size + 4 * src_Settings.uiScale - off.y);
			}
			if(topY <= bottomRectY && bottomY >= bottomRectY) {
				this.g.drawRect(0,this.scroll + renderRect.extent.y - this.font.size - 4 * src_Settings.uiScale + (topY + this.font.size + 4 * src_Settings.uiScale - bottomRectY),renderRect.extent.x,off.y + renderRect.extent.y - topY);
			}
			this.g.endFill();
		} else {
			this.g.clear();
		}
	}
	onScroll(scrollX,scrollY) {
		super.onScroll(scrollX,scrollY);
		this.getRenderRectangle();
		this.scroll = scrollY;
		let hittestrect = this.getHitTestRect(false);
		let _g = 0;
		let _g1 = this.textObjs.length;
		while(_g < _g1) {
			let i = _g++;
			let text = this.textObjs[i];
			let v = Math.floor(i * (text.font.size + 4 * src_Settings.uiScale) + (5 + this.textYOffset) * src_Settings.uiScale - scrollY);
			text.posChanged = true;
			text.y = v;
			let _this = this.g;
			_this.posChanged = true;
			_this.y = -scrollY;
		}
		this.redrawSelectionRect(hittestrect);
	}
}
$hxClasses["gui.GuiTextListCtrl"] = gui_GuiTextListCtrl;
gui_GuiTextListCtrl.__name__ = "gui.GuiTextListCtrl";
gui_GuiTextListCtrl.__super__ = gui_GuiControl;
Object.assign(gui_GuiTextListCtrl.prototype, {
	__class__: gui_GuiTextListCtrl
	,texts: null
	,onSelectedFunc: null
	,font: null
	,textObjs: null
	,g: null
	,_prevSelected: null
	,selectedColor: null
	,selectedFillColor: null
	,textColor: null
	,textYOffset: null
	,scroll: null
	,scrollable: null
	,flow: null
});
class gui_GuiXboxButton extends gui_GuiControl {
	constructor(text,width) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(text,width);
	}
	_hx_constructor(text,width) {
		this.acceleratorWasPressed = false;
		this.gamepadAccelerator = [];
		this.accelerators = [];
		this.buttonSounds = true;
		this.pressed = false;
		this.disabled = false;
		this.pressedAction = null;
		super._hx_constructor();
		this.extent = new h3d_Vector(width,94);
		let buttonImage = src_ResourceLoader.getResource("data/ui/xbox/cursorButtonArray.png",src_ResourceLoader.getImage,this.imageResources).toTile();
		let buttonLeft = buttonImage.sub(0,2,39,94);
		let buttonFill = buttonImage.sub(52,2,396,94);
		let buttonRight = buttonImage.sub(452,2,41,94);
		let buttonLeftPressed = buttonImage.sub(0,98,39,94);
		let buttonFillPressed = buttonImage.sub(52,98,396,94);
		let buttonRightPressed = buttonImage.sub(452,98,41,94);
		let cmat = h3d_Matrix.I();
		cmat.colorGain(8355711,1);
		let shadeFilter = new h2d_filter_ColorMatrix(cmat);
		shadeFilter.set_enable(false);
		let fillWidth = width - 39 - 41;
		this.left = new gui_GuiAnim([buttonLeft,buttonLeftPressed]);
		this.left.position = new h3d_Vector(0,0);
		this.left.extent = new h3d_Vector(39,94);
		this.left.anim.set_filter(shadeFilter);
		this.addChild(this.left);
		this.fill = new gui_GuiAnim([buttonFill,buttonFillPressed]);
		this.fill.position = new h3d_Vector(39,0);
		this.fill.extent = new h3d_Vector(fillWidth,94);
		this.fill.anim.set_filter(shadeFilter);
		this.addChild(this.fill);
		this.right = new gui_GuiAnim([buttonRight,buttonRightPressed]);
		this.right.position = new h3d_Vector(39 + fillWidth,0);
		this.right.extent = new h3d_Vector(41,94);
		this.right.anim.set_filter(shadeFilter);
		this.addChild(this.right);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(20 * src_Settings.uiScale,4);
		this.text = new gui_GuiText(arial14);
		this.text.position = new h3d_Vector(39,37);
		this.text.extent = new h3d_Vector(fillWidth,35);
		this.text.justify = gui_Justification.Center;
		this.text.vertSizing = gui_VertSizing.Top;
		this.text.text.set_text(text);
		this.text.text.set_textColor(7895160);
		this.addChild(this.text);
	}
	update(dt,mouseState) {
		let renderRect = this.getHitTestRect();
		let _this = renderRect.position;
		let v_x = 16;
		let v_y = 22;
		renderRect.position = new h3d_Vector(_this.x + v_x,_this.y + v_y,_this.z,_this.w + 1.);
		let _this1 = renderRect.extent;
		let v_x1 = 32;
		let v_y1 = 44;
		renderRect.extent = new h3d_Vector(_this1.x - v_x1,_this1.y - v_y1,_this1.z,_this1.w - 1.);
		if(renderRect.inRect(mouseState.position) && !this.disabled) {
			if(this.buttonSounds && hxd_Key.isPressed(0)) {
				src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/buttonpress.wav",src_ResourceLoader.getAudio,this.soundResources));
			}
		}
		if(renderRect.inRect(mouseState.position) && !this.disabled) {
			if(hxd_Key.isDown(0)) {
				this.left.anim.set_currentFrame(1);
				this.fill.anim.set_currentFrame(1);
				this.right.anim.set_currentFrame(1);
				this.left.anim.filter.set_enable(true);
				this.fill.anim.filter.set_enable(true);
				this.right.anim.filter.set_enable(true);
				this.text.text.set_textColor(1052688);
				this.pressed = true;
			} else {
				this.left.anim.set_currentFrame(1);
				this.fill.anim.set_currentFrame(1);
				this.right.anim.set_currentFrame(1);
				this.left.anim.filter.set_enable(false);
				this.fill.anim.filter.set_enable(false);
				this.right.anim.filter.set_enable(false);
				this.text.text.set_textColor(1052688);
				this.pressed = false;
			}
		} else {
			this.left.anim.set_currentFrame(0);
			this.fill.anim.set_currentFrame(0);
			this.right.anim.set_currentFrame(0);
			this.left.anim.filter.set_enable(false);
			this.fill.anim.filter.set_enable(false);
			this.right.anim.filter.set_enable(false);
			this.text.text.set_textColor(7895160);
			this.pressed = false;
		}
		if(!this.disabled) {
			let tmp;
			if(this.acceleratorWasPressed) {
				if(this.accelerators.length != 0) {
					let _this = this.accelerators;
					let result = new Array(_this.length);
					let _g = 0;
					let _g1 = _this.length;
					while(_g < _g1) {
						let i = _g++;
						result[i] = hxd_Key.isReleased(_this[i]);
					}
					tmp = result.includes(true);
				} else {
					tmp = false;
				}
			} else {
				tmp = false;
			}
			if(tmp || src_Gamepad.isPressed(this.gamepadAccelerator)) {
				if(this.pressedAction != null) {
					this.pressedAction(new gui_GuiEvent(this));
				}
			} else {
				let tmp;
				if(this.accelerators.length != 0) {
					let _this = this.accelerators;
					let result = new Array(_this.length);
					let _g = 0;
					let _g1 = _this.length;
					while(_g < _g1) {
						let i = _g++;
						result[i] = hxd_Key.isPressed(_this[i]);
					}
					tmp = result.includes(true);
				} else {
					tmp = false;
				}
				if(tmp || src_Gamepad.isPressed(this.gamepadAccelerator)) {
					this.acceleratorWasPressed = true;
				}
			}
		}
		if(this.acceleratorWasPressed) {
			let tmp;
			if(this.accelerators.length != 0) {
				let _this = this.accelerators;
				let result = new Array(_this.length);
				let _g = 0;
				let _g1 = _this.length;
				while(_g < _g1) {
					let i = _g++;
					result[i] = hxd_Key.isReleased(_this[i]);
				}
				tmp = result.includes(true);
			} else {
				tmp = false;
			}
			if(tmp || src_Gamepad.isPressed(this.gamepadAccelerator)) {
				this.acceleratorWasPressed = false;
			}
		}
		super.update(dt,mouseState);
	}
	onMouseRelease(mouseState) {
		if(mouseState.handled) {
			return;
		}
		mouseState.handled = true;
		super.onMouseRelease(mouseState);
		if(this.pressedAction != null && !this.disabled) {
			this.pressedAction(new gui_GuiEvent(this));
		}
	}
	onMouseEnter(mouseState) {
		if(mouseState.handled) {
			return;
		}
		mouseState.handled = true;
		super.onMouseEnter(mouseState);
		if(this.buttonSounds && !this.disabled) {
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/buttonover.wav",src_ResourceLoader.getAudio,this.soundResources));
		}
	}
}
$hxClasses["gui.GuiXboxButton"] = gui_GuiXboxButton;
gui_GuiXboxButton.__name__ = "gui.GuiXboxButton";
gui_GuiXboxButton.__super__ = gui_GuiControl;
Object.assign(gui_GuiXboxButton.prototype, {
	__class__: gui_GuiXboxButton
	,left: null
	,fill: null
	,right: null
	,text: null
	,pressedAction: null
	,disabled: null
	,pressed: null
	,buttonSounds: null
	,accelerators: null
	,gamepadAccelerator: null
	,acceleratorWasPressed: null
});
class gui_GuiXboxList extends gui_GuiControl {
	constructor() {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.active = true;
		this.usedGamepad = false;
		this.buttons = [];
		this.selected = 0;
		this.currentOffset = 0;
		super._hx_constructor();
	}
	addButton(icon,name,func,addOffset) {
		if(addOffset == null) {
			addOffset = 0;
		}
		let btn = new gui_GuiXboxListButton(icon,name);
		btn.position = new h3d_Vector(0,this.currentOffset + addOffset);
		btn.extent = new h3d_Vector(502,94);
		btn.pressedAction = func;
		btn.list = this;
		this.addChild(btn);
		this.buttons.push(btn);
		this.currentOffset += 60 + addOffset;
		return btn;
	}
	update(dt,mouseState) {
		super.update(dt,mouseState);
		if(this.active) {
			if(!this.buttons[this.selected].selected) {
				this.buttons[this.selected].selected = true;
			}
			let prevSelected = this.selected;
			if(hxd_Key.isPressed(40) || src_Gamepad.isPressed(["dpadDown"]) || src_Gamepad.getAxis("analogY") > 0.75 && !this.usedGamepad) {
				this.selected++;
			}
			if(hxd_Key.isPressed(38) || src_Gamepad.isPressed(["dpadUp"]) || src_Gamepad.getAxis("analogY") < -0.75 && !this.usedGamepad) {
				this.selected--;
			}
			if(Math.abs(src_Gamepad.getAxis("analogY")) > 0.75) {
				this.usedGamepad = true;
			} else {
				this.usedGamepad = false;
			}
			if(this.selected < 0) {
				this.selected = this.buttons.length - 1;
			}
			if(this.selected >= this.buttons.length) {
				this.selected = 0;
			}
			if(prevSelected != this.selected) {
				this.buttons[prevSelected].selected = false;
				this.buttons[this.selected].selected = true;
			}
			if(hxd_Key.isPressed(13) || src_Gamepad.isPressed(["A"])) {
				this.buttons[this.selected].pressedAction(new gui_GuiEvent(this.buttons[this.selected]));
			}
		} else {
			let _g = 0;
			let _g1 = this.buttons;
			while(_g < _g1.length) {
				let b = _g1[_g];
				++_g;
				if(b.selected) {
					b.selected = false;
				}
			}
		}
	}
}
$hxClasses["gui.GuiXboxList"] = gui_GuiXboxList;
gui_GuiXboxList.__name__ = "gui.GuiXboxList";
gui_GuiXboxList.__super__ = gui_GuiControl;
Object.assign(gui_GuiXboxList.prototype, {
	__class__: gui_GuiXboxList
	,currentOffset: null
	,selected: null
	,buttons: null
	,usedGamepad: null
	,active: null
});
class gui_GuiXboxListButton extends gui_GuiControl {
	constructor(icon,text) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(icon,text);
	}
	_hx_constructor(icon,text) {
		this.acceleratorWasPressed = false;
		this.gamepadAccelerator = [];
		this.accelerator = 0;
		this.buttonSounds = true;
		this.selected = false;
		this.pressed = false;
		this.disabled = false;
		this.pressedAction = null;
		super._hx_constructor();
		let buttonImage = src_ResourceLoader.getResource("data/ui/xbox/cursorArray.png",src_ResourceLoader.getImage,this.imageResources).toTile();
		let buttonDefault = buttonImage.sub(0,2,502,94);
		let buttonHover = buttonImage.sub(0,98,502,94);
		let buttonIconImg = buttonImage.sub(74 * icon,219,36,36);
		let buttonIconPressed = buttonImage.sub(74 * icon + 37,219,36,36);
		let cmat = h3d_Matrix.I();
		cmat.colorGain(8355711,1);
		let shadeFilter = new h2d_filter_ColorMatrix(cmat);
		shadeFilter.set_enable(false);
		this.button = new gui_GuiAnim([buttonDefault,buttonHover]);
		this.button.position = new h3d_Vector(0,0);
		this.button.extent = new h3d_Vector(502,94);
		this.button.anim.set_filter(shadeFilter);
		this.addChild(this.button);
		this.buttonIcon = new gui_GuiAnim([buttonIconImg,buttonIconPressed]);
		this.buttonIcon.position = new h3d_Vector(42,30);
		this.buttonIcon.extent = new h3d_Vector(36,36);
		this.addChild(this.buttonIcon);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(26 * src_Settings.uiScale,4);
		this.buttonText = new gui_GuiText(arial14);
		this.buttonText.position = new h3d_Vector(92,36);
		this.buttonText.extent = new h3d_Vector(92,35);
		this.buttonText.vertSizing = gui_VertSizing.Top;
		this.buttonText.text.set_text(text);
		this.buttonText.text.set_textColor(7895160);
		this.addChild(this.buttonText);
	}
	update(dt,mouseState) {
		let renderRect = this.getHitTestRect();
		let _this = renderRect.position;
		let x = 24 * src_Settings.uiScale;
		let y = 20 * src_Settings.uiScale;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let v_x = x;
		let v_y = y;
		renderRect.position = new h3d_Vector(_this.x + v_x,_this.y + v_y,_this.z,_this.w + 1.);
		let _this1 = renderRect.extent;
		let x1 = 439 * src_Settings.uiScale;
		let y1 = 53 * src_Settings.uiScale;
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		_this1.x = x1;
		_this1.y = y1;
		_this1.z = 0.;
		_this1.w = 1.;
		if(renderRect.inRect(mouseState.position) && !this.disabled) {
			if(this.buttonSounds && hxd_Key.isPressed(0)) {
				src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/buttonpress.wav",src_ResourceLoader.getAudio,this.soundResources));
			}
		}
		let tmp;
		if(this._prevMousePos != null) {
			let _this = this._prevMousePos;
			let v = mouseState.position;
			tmp = !(_this.x == v.x && _this.y == v.y && _this.z == v.z && _this.w == v.w);
		} else {
			tmp = true;
		}
		if(tmp) {
			if(renderRect.inRect(mouseState.position) && !this.selected) {
				if(this.list != null) {
					this.list.buttons[this.list.selected].selected = false;
					this.list.selected = this.list.buttons.indexOf(this);
				}
				this.selected = true;
			}
			let _this = mouseState.position;
			this._prevMousePos = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
		}
		if(this.selected && !this.disabled) {
			if(hxd_Key.isDown(0) && renderRect.inRect(mouseState.position)) {
				this.button.anim.set_currentFrame(1);
				this.buttonIcon.anim.set_currentFrame(1);
				this.buttonText.text.set_textColor(1052688);
				this.button.anim.filter.set_enable(true);
				this.pressed = true;
			} else {
				this.button.anim.set_currentFrame(1);
				this.buttonIcon.anim.set_currentFrame(1);
				this.buttonText.text.set_textColor(1052688);
				this.button.anim.filter.set_enable(false);
				this.pressed = false;
			}
		} else {
			this.button.anim.set_currentFrame(this.disabled ? 3 : 0);
			this.buttonIcon.anim.set_currentFrame(0);
			this.buttonText.text.set_textColor(7895160);
			this.button.anim.filter.set_enable(false);
			this.pressed = false;
		}
		if(!this.disabled) {
			if(this.acceleratorWasPressed && (this.accelerator != 0 && hxd_Key.isReleased(this.accelerator)) || src_Gamepad.isReleased(this.gamepadAccelerator)) {
				if(this.pressedAction != null) {
					this.pressedAction(new gui_GuiEvent(this));
				}
			} else if(this.accelerator != 0 && hxd_Key.isPressed(this.accelerator) || src_Gamepad.isPressed(this.gamepadAccelerator)) {
				this.acceleratorWasPressed = true;
			}
		}
		if(this.acceleratorWasPressed) {
			if(this.accelerator != 0 && hxd_Key.isReleased(this.accelerator) || src_Gamepad.isReleased(this.gamepadAccelerator)) {
				this.acceleratorWasPressed = false;
			}
		}
		super.update(dt,mouseState);
	}
	onMouseRelease(mouseState) {
		let renderRect = this.getHitTestRect();
		let _this = renderRect.position;
		let x = 24 * src_Settings.uiScale;
		let y = 20 * src_Settings.uiScale;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let v_x = x;
		let v_y = y;
		renderRect.position = new h3d_Vector(_this.x + v_x,_this.y + v_y,_this.z,_this.w + 1.);
		let _this1 = renderRect.extent;
		let x1 = 439 * src_Settings.uiScale;
		let y1 = 53 * src_Settings.uiScale;
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		_this1.x = x1;
		_this1.y = y1;
		_this1.z = 0.;
		_this1.w = 1.;
		if(!renderRect.inRect(mouseState.position)) {
			return;
		}
		super.onMouseRelease(mouseState);
		if(this.pressedAction != null && !this.disabled) {
			this.pressedAction(new gui_GuiEvent(this));
		}
	}
	onMouseEnter(mouseState) {
		let renderRect = this.getHitTestRect();
		let _this = renderRect.position;
		let x = 24 * src_Settings.uiScale;
		let y = 20 * src_Settings.uiScale;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let v_x = x;
		let v_y = y;
		renderRect.position = new h3d_Vector(_this.x + v_x,_this.y + v_y,_this.z,_this.w + 1.);
		let _this1 = renderRect.extent;
		let x1 = 439 * src_Settings.uiScale;
		let y1 = 53 * src_Settings.uiScale;
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		_this1.x = x1;
		_this1.y = y1;
		_this1.z = 0.;
		_this1.w = 1.;
		if(!renderRect.inRect(mouseState.position)) {
			return;
		}
		super.onMouseEnter(mouseState);
		if(this.buttonSounds && !this.disabled) {
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/buttonover.wav",src_ResourceLoader.getAudio,this.soundResources));
		}
	}
}
$hxClasses["gui.GuiXboxListButton"] = gui_GuiXboxListButton;
gui_GuiXboxListButton.__name__ = "gui.GuiXboxListButton";
gui_GuiXboxListButton.__super__ = gui_GuiControl;
Object.assign(gui_GuiXboxListButton.prototype, {
	__class__: gui_GuiXboxListButton
	,button: null
	,buttonIcon: null
	,buttonText: null
	,pressedAction: null
	,disabled: null
	,pressed: null
	,selected: null
	,buttonSounds: null
	,accelerator: null
	,gamepadAccelerator: null
	,acceleratorWasPressed: null
	,list: null
	,_prevMousePos: null
});
class gui_GuiXboxOptionsList extends gui_GuiControl {
	constructor(icon,name,values,midcolumn,textOff,enableButtons) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(icon,name,values,midcolumn,textOff,enableButtons);
	}
	_hx_constructor(icon,name,values,midcolumn,textOff,enableButtons) {
		if(enableButtons == null) {
			enableButtons = true;
		}
		if(textOff == null) {
			textOff = 155.5;
		}
		if(midcolumn == null) {
			midcolumn = 0.3;
		}
		this.selected = false;
		this.enableButtons = true;
		this.usedGamepad = false;
		this.onChangeFunc = null;
		this.alwaysActive = false;
		this.currentOption = 0;
		super._hx_constructor();
		this.options = values;
		this.enableButtons = enableButtons;
		let baseImage = src_ResourceLoader.getResource("data/ui/xbox/optionsCursorArray.png",src_ResourceLoader.getImage,this.imageResources).toTile();
		let inactiveImage = baseImage.sub(0,2,815,94);
		let activeImage = baseImage.sub(0,98,815,94);
		let leftArrow = baseImage.sub(0,193,22,22);
		let leftArrowSelected = baseImage.sub(23,193,22,22);
		let rightArrow = baseImage.sub(48,193,22,22);
		let rightArrowSelected = baseImage.sub(72,193,22,22);
		let arrowButtonImage = baseImage.sub(0,256,114,94);
		let arrowButtonImagePressed = baseImage.sub(0,352,114,94);
		let iconImage = baseImage.sub(74 * icon,453,36,36);
		let iconImagePressed = baseImage.sub(74 * icon + 37,453,36,36);
		this.bgFill = new gui_GuiAnim([inactiveImage,activeImage]);
		this.bgFill.position = new h3d_Vector(0,0);
		this.bgFill.extent = new h3d_Vector(815,94);
		this.addChild(this.bgFill);
		this.optIcon = new gui_GuiAnim([iconImage,iconImagePressed]);
		this.optIcon.position = new h3d_Vector(30,30);
		this.optIcon.extent = new h3d_Vector(36,36);
		this.addChild(this.optIcon);
		let cmat = h3d_Matrix.I();
		cmat.colorGain(8355711,1);
		let leftShadeFilter = new h2d_filter_ColorMatrix(cmat);
		leftShadeFilter.set_enable(false);
		let rightShadeFilter = new h2d_filter_ColorMatrix(cmat);
		rightShadeFilter.set_enable(false);
		if(enableButtons) {
			this.leftButton = new gui_GuiAnim([arrowButtonImage,arrowButtonImagePressed]);
			this.leftButton.position = new h3d_Vector(815 * midcolumn,0);
			this.leftButton.extent = new h3d_Vector(114,94);
			this.leftButton.anim.set_filter(leftShadeFilter);
			this.addChild(this.leftButton);
			let leftButtonIcon = new gui_GuiAnim([leftArrow,leftArrowSelected]);
			leftButtonIcon.position = new h3d_Vector(39,36);
			leftButtonIcon.extent = new h3d_Vector(22,22);
			this.leftButton.addChild(leftButtonIcon);
			this.rightButton = new gui_GuiAnim([arrowButtonImage,arrowButtonImagePressed]);
			this.rightButton.position = new h3d_Vector(652.,0);
			this.rightButton.extent = new h3d_Vector(114,94);
			this.rightButton.anim.set_filter(rightShadeFilter);
			this.addChild(this.rightButton);
			let rightButtonIcon = new gui_GuiAnim([rightArrow,rightArrowSelected]);
			rightButtonIcon.position = new h3d_Vector(52,36);
			rightButtonIcon.extent = new h3d_Vector(22,22);
			this.rightButton.addChild(rightButtonIcon);
		}
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(25 * src_Settings.uiScale,4);
		this.labelText = new gui_GuiText(arial14);
		this.labelText.position = new h3d_Vector(815 * midcolumn - 125,36);
		this.labelText.extent = new h3d_Vector(100,35);
		this.labelText.vertSizing = gui_VertSizing.Top;
		this.labelText.justify = gui_Justification.Right;
		this.labelText.text.set_text(name);
		this.labelText.text.set_textColor(7895160);
		this.addChild(this.labelText);
		this.optionText = new gui_GuiText(arial14);
		this.optionText.position = new h3d_Vector(815 * midcolumn + textOff,36);
		this.optionText.extent = new h3d_Vector(815 * (0.8 - midcolumn) / 2,35);
		this.optionText.vertSizing = gui_VertSizing.Top;
		this.optionText.text.set_text(values[0]);
		this.optionText.text.set_textColor(7895160);
		this.optionText.justify = gui_Justification.Center;
		this.addChild(this.optionText);
	}
	update(dt,mouseState) {
		if(this.alwaysActive) {
			this.bgFill.anim.set_currentFrame(1);
			this.optIcon.anim.set_currentFrame(1);
			this.labelText.text.set_textColor(1052688);
			this.optionText.text.set_textColor(1052688);
		} else {
			let htr = this.getHitTestRect();
			let _this = htr.position;
			let x = 24 * src_Settings.uiScale;
			let y = 20 * src_Settings.uiScale;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let v_x = x;
			let v_y = y;
			htr.position = new h3d_Vector(_this.x + v_x,_this.y + v_y,_this.z,_this.w + 1.);
			let _this1 = htr.extent;
			let x1 = 776 * src_Settings.uiScale;
			let y1 = 53 * src_Settings.uiScale;
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			_this1.x = x1;
			_this1.y = y1;
			_this1.z = 0.;
			_this1.w = 1.;
			let tmp;
			if(this._prevMousePos != null) {
				let _this = this._prevMousePos;
				let v = mouseState.position;
				tmp = !(_this.x == v.x && _this.y == v.y && _this.z == v.z && _this.w == v.w);
			} else {
				tmp = true;
			}
			if(tmp) {
				if(htr.inRect(mouseState.position) && !this.selected) {
					this.selected = true;
					if(this.list != null) {
						this.list.options[this.list.selected].selected = false;
						this.list.selected = this.list.options.indexOf(this);
					}
				}
				let _this = mouseState.position;
				this._prevMousePos = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
			}
			if(this.selected) {
				this.bgFill.anim.set_currentFrame(1);
				this.optIcon.anim.set_currentFrame(1);
				this.labelText.text.set_textColor(1052688);
				this.optionText.text.set_textColor(1052688);
			} else {
				this.bgFill.anim.set_currentFrame(0);
				this.optIcon.anim.set_currentFrame(0);
				this.labelText.text.set_textColor(7895160);
				this.optionText.text.set_textColor(7895160);
			}
		}
		if(this.enableButtons) {
			let leftBtnRect = this.leftButton.getHitTestRect();
			let _this = leftBtnRect.position;
			let x = 15 * src_Settings.uiScale;
			let y = 21 * src_Settings.uiScale;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let v_x = x;
			let v_y = y;
			leftBtnRect.position = new h3d_Vector(_this.x + v_x,_this.y + v_y,_this.z,_this.w + 1.);
			let _this1 = leftBtnRect.extent;
			let x1 = 83 * src_Settings.uiScale;
			let y1 = 53 * src_Settings.uiScale;
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			_this1.x = x1;
			_this1.y = y1;
			_this1.z = 0.;
			_this1.w = 1.;
			let rightBtnRect = this.rightButton.getHitTestRect();
			let _this2 = rightBtnRect.position;
			let x2 = 15 * src_Settings.uiScale;
			let y2 = 21 * src_Settings.uiScale;
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let v_x1 = x2;
			let v_y1 = y2;
			rightBtnRect.position = new h3d_Vector(_this2.x + v_x1,_this2.y + v_y1,_this2.z,_this2.w + 1.);
			let _this3 = rightBtnRect.extent;
			let x3 = 83 * src_Settings.uiScale;
			let y3 = 53 * src_Settings.uiScale;
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			_this3.x = x3;
			_this3.y = y3;
			_this3.z = 0.;
			_this3.w = 1.;
			if(leftBtnRect.inRect(mouseState.position) || rightBtnRect.inRect(mouseState.position)) {
				if(hxd_Key.isPressed(0)) {
					src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/buttonpress.wav",src_ResourceLoader.getAudio,this.soundResources));
				}
			}
			if(leftBtnRect.inRect(mouseState.position)) {
				if(hxd_Key.isDown(0)) {
					this.leftButton.anim.set_currentFrame(1);
					this.leftButton.anim.filter.set_enable(true);
				} else {
					this.leftButton.anim.set_currentFrame(1);
					this.leftButton.anim.filter.set_enable(false);
				}
				if(hxd_Key.isReleased(0)) {
					let newOption = this.currentOption - 1;
					if(newOption < 0) {
						newOption = this.options.length - 1;
					}
					let doChange = true;
					if(this.onChangeFunc != null) {
						doChange = this.onChangeFunc(newOption);
					}
					if(doChange) {
						this.currentOption = newOption;
						this.optionText.text.set_text(this.options[this.currentOption]);
					}
				}
			} else {
				this.leftButton.anim.set_currentFrame(0);
				this.leftButton.anim.filter.set_enable(false);
			}
			if(rightBtnRect.inRect(mouseState.position)) {
				if(hxd_Key.isDown(0)) {
					this.rightButton.anim.set_currentFrame(1);
					this.rightButton.anim.filter.set_enable(true);
				} else {
					this.rightButton.anim.set_currentFrame(1);
					this.rightButton.anim.filter.set_enable(false);
				}
				if(hxd_Key.isReleased(0)) {
					let newOption = this.currentOption + 1;
					if(newOption >= this.options.length) {
						newOption = 0;
					}
					let doChange = true;
					if(this.onChangeFunc != null) {
						doChange = this.onChangeFunc(newOption);
					}
					if(doChange) {
						this.currentOption = newOption;
						this.optionText.text.set_text(this.options[this.currentOption]);
					}
				}
			} else {
				this.rightButton.anim.set_currentFrame(0);
				this.rightButton.anim.filter.set_enable(false);
			}
			if(this.selected || this.alwaysActive) {
				if(hxd_Key.isPressed(37) || src_Gamepad.isPressed(["dpadLeft"]) || src_Gamepad.getAxis("analogX") < -0.75 && !this.usedGamepad) {
					let newOption = this.currentOption - 1;
					if(newOption < 0) {
						newOption = this.options.length - 1;
					}
					let doChange = true;
					if(this.onChangeFunc != null) {
						doChange = this.onChangeFunc(newOption);
					}
					if(doChange) {
						this.currentOption = newOption;
						this.optionText.text.set_text(this.options[this.currentOption]);
					}
				}
				if(hxd_Key.isPressed(39) || src_Gamepad.isPressed(["dpadRight"]) || src_Gamepad.getAxis("analogX") > 0.75 && !this.usedGamepad) {
					let newOption = this.currentOption + 1;
					if(newOption >= this.options.length) {
						newOption = 0;
					}
					let doChange = true;
					if(this.onChangeFunc != null) {
						doChange = this.onChangeFunc(newOption);
					}
					if(doChange) {
						this.currentOption = newOption;
						this.optionText.text.set_text(this.options[this.currentOption]);
					}
				}
				if(Math.abs(src_Gamepad.getAxis("analogX")) > 0.75) {
					this.usedGamepad = true;
				} else {
					this.usedGamepad = false;
				}
			}
		}
		super.update(dt,mouseState);
	}
	setCurrentOption(opt) {
		this.currentOption = opt;
		this.optionText.text.set_text(this.options[this.currentOption]);
	}
}
$hxClasses["gui.GuiXboxOptionsList"] = gui_GuiXboxOptionsList;
gui_GuiXboxOptionsList.__name__ = "gui.GuiXboxOptionsList";
gui_GuiXboxOptionsList.__super__ = gui_GuiControl;
Object.assign(gui_GuiXboxOptionsList.prototype, {
	__class__: gui_GuiXboxOptionsList
	,bgFill: null
	,optIcon: null
	,leftButton: null
	,rightButton: null
	,labelText: null
	,optionText: null
	,options: null
	,currentOption: null
	,alwaysActive: null
	,onChangeFunc: null
	,_prevMousePos: null
	,usedGamepad: null
	,enableButtons: null
	,selected: null
	,list: null
});
class gui_GuiXboxOptionsListCollection extends gui_GuiControl {
	constructor() {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.options = [];
		this.selected = 0;
		this.offset = 0;
		super._hx_constructor();
	}
	addOption(icon,name,options,onChange,midColumn,textOff) {
		if(textOff == null) {
			textOff = 155.5;
		}
		if(midColumn == null) {
			midColumn = 0.3;
		}
		let opt = new gui_GuiXboxOptionsList(icon,name,options,midColumn,textOff);
		opt.vertSizing = gui_VertSizing.Bottom;
		opt.horizSizing = gui_HorizSizing.Right;
		opt.position = new h3d_Vector(0,this.offset);
		this.offset += 60;
		opt.extent = new h3d_Vector(815,94);
		opt.onChangeFunc = onChange;
		opt.list = this;
		this.addChild(opt);
		this.options.push(opt);
		return opt;
	}
	update(dt,mouseState) {
		super.update(dt,mouseState);
		if(!this.options[this.selected].selected) {
			this.options[this.selected].selected = true;
		}
		let prevSelected = this.selected;
		if(hxd_Key.isPressed(40) || src_Gamepad.isPressed(["dpadDown"])) {
			this.selected++;
		}
		if(hxd_Key.isPressed(38) || src_Gamepad.isPressed(["dpadUp"])) {
			this.selected--;
		}
		if(this.selected < 0) {
			this.selected = this.options.length - 1;
		}
		if(this.selected >= this.options.length) {
			this.selected = 0;
		}
		if(prevSelected != this.selected) {
			this.options[prevSelected].selected = false;
			this.options[this.selected].selected = true;
		}
	}
}
$hxClasses["gui.GuiXboxOptionsListCollection"] = gui_GuiXboxOptionsListCollection;
gui_GuiXboxOptionsListCollection.__name__ = "gui.GuiXboxOptionsListCollection";
gui_GuiXboxOptionsListCollection.__super__ = gui_GuiControl;
Object.assign(gui_GuiXboxOptionsListCollection.prototype, {
	__class__: gui_GuiXboxOptionsListCollection
	,offset: null
	,selected: null
	,options: null
});
class gui_HelpCreditsGui extends gui_GuiImage {
	constructor(index,pauseGui) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(index,pauseGui);
	}
	_hx_constructor(index,pauseGui) {
		if(pauseGui == null) {
			pauseGui = false;
		}
		this.doScroll = false;
		this.curScroll = -50;
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super._hx_constructor(res);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let titles = ["POWERUPS","BLAST METER","SINGLE PLAYER MODE","MULTIPLAYER MODE","MARBLE CONTROLS","CREDITS"];
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text(titles[index]);
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let wnd = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/helpWindow.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		wnd.position = new h3d_Vector(260,107);
		wnd.extent = new h3d_Vector(736,460);
		wnd.horizSizing = gui_HorizSizing.Right;
		wnd.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(wnd);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		let arial14big = arial14b.toSdfFont(30 * src_Settings.uiScale,4);
		let arial14med = arial14b.toSdfFont(26 * src_Settings.uiScale,4);
		let mlFontLoader = function(text) {
			switch(text) {
			case "ArialBig":
				return arial14big;
			case "ArialMed":
				return arial14med;
			default:
				return arial14;
			}
		};
		let texts = ["There are many powerups that will help you along.  To collect a powerup, roll over it.  It will appear in the powerup window.<br/><br/>On an Xbox 360 Controller, Pull the right trigger or press B to activate the powerup; Otherwise use left click or the Q key.","The Marble has a blast ability which gives you a slight upward boost.  Use it wisely!<br/><br/>The Blast meter shows the current level of blast that you have available.  It regenerates slowly over time.<br/><br/>On an Xbox 360 Controller, Press X or the right bumper to use your current blast power; Otherwise, use Right Click or the E key.<br/><br/>Collect the Ultra Blast powerup to instantly fill your blast meter - and then some!","Get to the End Pad of each level as fast as possible.<br/><br/>Start Pad - You start the level here.<br/><br/>End Pad - Roll your marble here to end the level.<br/><br/>Gems - Some levels have gems.  You must pick up all of them before you can end the level.<br/><br/>Time Travel - Roll through these to temporarily pause the clock.","Race to the gems and pick them up to earn points.  Get as many gems as you can, but be ready to go when the next group appears!<br/><br/>Some gems are worth more points than others.  More valuable gems are usually harder to reach.<br/><br/>View the leaderboards to compare your ranking with other players around the world.","Xbox 360 Controller:<br/>Use the left stick to move the marble. <br/><br/>Press A or pull the left trigger to make the marble jump.<br/><br/>Use the right stick to look around with the camera.<br/><br/>Keyboard and Mouse:<br/>Use the WASD keys to move.<br/>Move the mouse to look around.<br/>Press Space to Jump."];
		texts.push("<p align=\"center\"><font face=\"ArialBig\"><br/>GarageGames Team</font><br/><br/><font face=\"ArialMed\">Development</font><br/>Tim Aste<br/>Jane Chase<br/>Timothy Clarke<br/>Adam deGrandis<br/>Clark Fagot<br/>Matt Fairfax<br/>Mark Frohnmayer<br/>Ben Garney<br/>Tim Gift<br/>Davey Jackson<br/>Justin Kovac<br/>Joe Maruschak<br/>Mark McCoy<br/>Jay Moore<br/>Rick Overman<br/>John Quigley<br/>Brian Ramage<br/>Kevin Ryan<br/>Liam Ryan<br/>Alex Swanson<br/>Jeff Tunnell<br/>Pat Wilson<br/><br/><font face=\"ArialMed\">Special Thanks</font><br/>Cafe Aroma<br/>Cafe Yumm!<br/>Mezza Luna Pizzeria<br/>Pizza Research Institute<br/>The GarageGames Community</p>" + "<br/>" + "<p align=\"center\"><font face=\"ArialBig\">Xbox Live Arcade Team</font><br/><br/><font face=\"ArialMed\">Program Management</font><br/>Katie Stone<br/>Jon David<br/><br/><font face=\"ArialMed\">Test Manager</font><br/>Tony Harlich<br/><br/><font face=\"ArialMed\">Test</font><br/>Michael Jones<br/>Chad Dylan Long (VMC)<br/>Eric Snyder (VMC)<br/>Noriko Fritschle (VMC)<br/>Kevin Hathaway (VMC)<br/>Ty Roberts (VMC)<br/><br/><font face=\"ArialMed\">Release Manager</font><br/>Julie Pitt (VOLT)<br/><br/><font face=\"ArialMed\">Development</font><br/>Brian Ostergren<br/>Eric Heutchy<br/>Eric Fleegal<br/><br/><font face=\"ArialMed\">Group Manager</font><br/>Greg Canessa<br/><br/><font face=\"ArialMed\">Product Planning</font><br/>Ross Erickson<br/>Cherie Lutz<br/><br/><font face=\"ArialMed\">Content Creation</font><br/>Michelle Lomba<br/><br/><font face=\"ArialMed\">Usability</font><br/>Tom Fuller<br/>Chuck Harrison<br/><br/><font face=\"ArialMed\">Special Thanks</font><br/>J Allard<br/>Shane Kim<br/>Don Ryan<br/>Chris Early<br/>Oliver Miyashita<br/>Mike Minahan<br/>VMC Consulting<br/>Ami Blaire<br/>Darryl Saunders<br/>Aaron Greenberg<br/>Michael Wolf<br/>David Hufford<br/>Darren Trencher</p>" + "<br/>" + "<p align=\"center\"><font face=\"ArialBig\">Localization</font><br/><br/><font face=\"ArialMed\">Japan Localization Team</font><br/>Shinya Muto<br/>Junya Chiba<br/>Go Komatsu<br/>Mayumi Koike<br/>Takehiro Kuga<br/>Masao Okamoto<br/>Yutaka Hasegawa<br/>Munetaka Fuse<br/>Takashi Sasaki<br/>Shinji Komiyama<br/><br/><font face=\"ArialMed\">Korea Localization Team</font><br/>Eun Hee Lee<br/>In Goo Kwon<br/>Whi Young Yoon<br/>Ji Young Kim<br/><br/><font face=\"ArialMed\">Taiwan Localization Team</font><br/>Robert Lin<br/>Carole Lin<br/>Lilia Lee<br/>Jason Cheng</p>");
		if(index == 5) {
			this.doScroll = true;
		}
		let textCtrl = new gui_GuiControl();
		textCtrl.position = new h3d_Vector(30,33);
		textCtrl.extent = new h3d_Vector(683,403);
		wnd.addChild(textCtrl);
		this.wndTxtBg = new gui_GuiMLText(arial14,mlFontLoader);
		this.wndTxtBg.position = new h3d_Vector(2,7);
		this.wndTxtBg.extent = new h3d_Vector(683,343);
		this.wndTxtBg.text.set_textColor(1052688);
		this.wndTxtBg.text.set_text(texts[index]);
		this.wndTxtBg.scrollable = true;
		textCtrl.addChild(this.wndTxtBg);
		this.wndTxt = new gui_GuiMLText(arial14,mlFontLoader);
		this.wndTxt.position = new h3d_Vector(0,5);
		this.wndTxt.extent = new h3d_Vector(683,343);
		this.wndTxt.text.set_textColor(15461355);
		this.wndTxt.text.set_text(texts[index]);
		this.wndTxt.scrollable = true;
		textCtrl.addChild(this.wndTxt);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Ok",160);
		backButton.position = new h3d_Vector(960,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["A"];
		backButton.accelerators = [13];
		let _gthis = this;
		if(pauseGui) {
			if(index == 5) {
				backButton.pressedAction = function(e) {
					src_MarbleGame.canvas.popDialog(_gthis);
					src_MarbleGame.canvas.pushDialog(new gui_OptionsListGui(true));
				};
			} else {
				backButton.pressedAction = function(e) {
					src_MarbleGame.canvas.popDialog(_gthis);
					src_MarbleGame.canvas.pushDialog(new gui_AboutMenuOptionsGui(true));
				};
			}
		} else if(index == 5) {
			backButton.pressedAction = function(e) {
				src_MarbleGame.canvas.setContent(new gui_OptionsListGui());
			};
		} else {
			backButton.pressedAction = function(e) {
				src_MarbleGame.canvas.setContent(new gui_AboutMenuOptionsGui());
			};
		}
		bottomBar.addChild(backButton);
	}
	update(dt,mouseState) {
		super.update(dt,mouseState);
		if(this.doScroll) {
			this.curScroll += dt * 20;
			let realScroll = Math.max(this.curScroll,0);
			this.wndTxt.onScroll(0,realScroll);
			this.wndTxtBg.onScroll(0,realScroll);
		}
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.HelpCreditsGui"] = gui_HelpCreditsGui;
gui_HelpCreditsGui.__name__ = "gui.HelpCreditsGui";
gui_HelpCreditsGui.__super__ = gui_GuiImage;
Object.assign(gui_HelpCreditsGui.prototype, {
	__class__: gui_HelpCreditsGui
	,wndTxt: null
	,wndTxtBg: null
	,curScroll: null
	,doScroll: null
	,innerCtrl: null
});
var gui_LineHeightMode = $hxEnums["gui.LineHeightMode"] = { __ename__:true,__constructs__:null
	,Accurate: {_hx_name:"Accurate",_hx_index:0,__enum__:"gui.LineHeightMode",toString:$estr}
	,TextOnly: {_hx_name:"TextOnly",_hx_index:1,__enum__:"gui.LineHeightMode",toString:$estr}
	,Constant: {_hx_name:"Constant",_hx_index:2,__enum__:"gui.LineHeightMode",toString:$estr}
};
gui_LineHeightMode.__constructs__ = [gui_LineHeightMode.Accurate,gui_LineHeightMode.TextOnly,gui_LineHeightMode.Constant];
gui_LineHeightMode.__empty_constructs__ = [gui_LineHeightMode.Accurate,gui_LineHeightMode.TextOnly,gui_LineHeightMode.Constant];
var gui_ImageVerticalAlign = $hxEnums["gui.ImageVerticalAlign"] = { __ename__:true,__constructs__:null
	,Top: {_hx_name:"Top",_hx_index:0,__enum__:"gui.ImageVerticalAlign",toString:$estr}
	,Bottom: {_hx_name:"Bottom",_hx_index:1,__enum__:"gui.ImageVerticalAlign",toString:$estr}
	,Middle: {_hx_name:"Middle",_hx_index:2,__enum__:"gui.ImageVerticalAlign",toString:$estr}
};
gui_ImageVerticalAlign.__constructs__ = [gui_ImageVerticalAlign.Top,gui_ImageVerticalAlign.Bottom,gui_ImageVerticalAlign.Middle];
gui_ImageVerticalAlign.__empty_constructs__ = [gui_ImageVerticalAlign.Top,gui_ImageVerticalAlign.Bottom,gui_ImageVerticalAlign.Middle];
class h2d_Text extends h2d_Drawable {
	constructor(font,parent) {
		if(h2d_Object._hx_skip_constructor) {
			super();
			return;
		}
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor(font,parent);
	}
	_hx_constructor(font,parent) {
		this.realMaxWidth = -1;
		this.constraintWidth = -1;
		this.lineBreak = true;
		this.lineSpacing = 0;
		this.letterSpacing = 0;
		super._hx_constructor(parent);
		this.set_font(font);
		this.set_textAlign(h2d_Align.Left);
		this.set_text("");
		this.currentText = "";
		this._textColorVec = new h3d_Vector(1,1,1,1);
		this.set_textColor(16777215);
		this.color = new h3d_Vector(1,1,1,1);
		this.selectionColor = new h3d_Vector(1,1,1,1);
	}
	set_font(font) {
		if(this.font == font) {
			return font;
		}
		this.font = font;
		if(font != null) {
			let _g = font.type;
			switch(_g._hx_index) {
			case 0:
				if(this.sdfShader != null) {
					this.removeShader(this.sdfShader);
					this.sdfShader = null;
				}
				break;
			case 1:
				let _g1 = _g.smoothing;
				if(this.sdfShader == null) {
					this.sdfShader = new h3d_shader_SignedDistanceField();
					this.addShader(this.sdfShader);
				}
				if(this.smooth == null) {
					this.smooth = true;
				}
				this.sdfShader.alphaCutoff__ = _g.alphaCutoff;
				this.sdfShader.smoothing__ = _g1;
				let _this = this.sdfShader;
				_this.constModified = true;
				_this.channel__ = _g.channel;
				let _this1 = this.sdfShader;
				_this1.constModified = true;
				_this1.autoSmoothing__ = _g1 == -1;
				break;
			}
		}
		if(this.glyphs != null) {
			let _this = this.glyphs;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
		this.glyphs = new h2d_TileGroup(font == null ? null : font.tile,this);
		this.glyphs.set_visible(false);
		this.rebuild();
		return font;
	}
	set_textAlign(a) {
		if(this.textAlign == a) {
			return a;
		}
		this.textAlign = a;
		this.rebuild();
		return a;
	}
	set_lineSpacing(s) {
		if(this.lineSpacing == s) {
			return s;
		}
		this.lineSpacing = s;
		this.rebuild();
		return s;
	}
	constraintSize(width,height) {
		this.constraintWidth = width;
		this.updateConstraint();
	}
	onAdd() {
		super.onAdd();
		this.rebuild();
	}
	sync(ctx) {
		super.sync(ctx);
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(this.needsRebuild) {
			this.initGlyphs(this.currentText);
		}
	}
	draw(ctx) {
		if(this.glyphs == null) {
			this.emitTile(ctx,h2d_Tile.fromColor(16711935,16,16));
			return;
		}
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(this.needsRebuild) {
			this.initGlyphs(this.currentText);
		}
		if(this.dropShadow != null) {
			let oldX = this.absX;
			let oldY = this.absY;
			this.absX += this.dropShadow.dx * this.matA + this.dropShadow.dy * this.matC;
			this.absY += this.dropShadow.dx * this.matB + this.dropShadow.dy * this.matD;
			let oldR = this.color.x;
			let oldG = this.color.y;
			let oldB = this.color.z;
			let oldA = this.color.w;
			let _this = this.color;
			let c = this.dropShadow.color;
			_this.x = (c >> 16 & 255) / 255;
			_this.y = (c >> 8 & 255) / 255;
			_this.z = (c & 255) / 255;
			_this.w = (c >>> 24) / 255;
			this.color.w = this.dropShadow.alpha * oldA;
			this.glyphs.drawWith(ctx,this);
			this.absX = oldX;
			this.absY = oldY;
			let _this1 = this.color;
			let x = oldR;
			let y = oldG;
			let z = oldB;
			let w = oldA;
			if(oldA == null) {
				w = 1.;
			}
			if(oldB == null) {
				z = 0.;
			}
			if(oldG == null) {
				y = 0.;
			}
			if(oldR == null) {
				x = 0.;
			}
			_this1.x = x;
			_this1.y = y;
			_this1.z = z;
			_this1.w = w;
		}
		let oldR = this.color.x;
		let oldG = this.color.y;
		let oldB = this.color.z;
		let oldA = this.color.w;
		let _this = this.color;
		let w = this._textColorVec.w;
		if(w == null) {
			w = 1.;
		}
		_this.x = 1;
		_this.y = 1;
		_this.z = 1;
		_this.w = w;
		this.glyphs.drawWith(ctx,this);
		let _this1 = this.color;
		let x = oldR;
		let y = oldG;
		let z = oldB;
		let w1 = oldA;
		if(oldA == null) {
			w1 = 1.;
		}
		if(oldB == null) {
			z = 0.;
		}
		if(oldG == null) {
			y = 0.;
		}
		if(oldR == null) {
			x = 0.;
		}
		_this1.x = x;
		_this1.y = y;
		_this1.z = z;
		_this1.w = w1;
	}
	set_text(t) {
		let t1 = t == null ? "null" : t;
		if(t1 == this.text) {
			return t1;
		}
		this.text = t1;
		this.textChanged = true;
		this.validateText();
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return t1;
	}
	validateText() {
	}
	rebuild() {
		this.calcDone = false;
		this.needsRebuild = true;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
	}
	calcTextWidth(text) {
		if(this.calcDone) {
			let ow = this.calcWidth;
			let oh = this.calcHeight;
			let osh = this.calcSizeHeight;
			let ox = this.calcXMin;
			let oy = this.calcYMin;
			this.initGlyphs(text,false);
			let w = this.calcWidth;
			this.calcWidth = ow;
			this.calcHeight = oh;
			this.calcSizeHeight = osh;
			this.calcXMin = ox;
			this.calcYMin = oy;
			return w;
		} else {
			this.initGlyphs(text,false);
			this.calcDone = false;
			return this.calcWidth;
		}
	}
	splitRawText(text,leftMargin,afterData,font,sizes,prevChar) {
		if(prevChar == null) {
			prevChar = -1;
		}
		if(afterData == null) {
			afterData = 0.;
		}
		if(leftMargin == null) {
			leftMargin = 0.;
		}
		let maxWidth = this.realMaxWidth;
		if(maxWidth < 0) {
			if(sizes == null) {
				return text;
			} else {
				maxWidth = Infinity;
			}
		}
		if(font == null) {
			font = this.font;
		}
		let lines = [];
		let restPos = 0;
		let x = leftMargin;
		let _g = 0;
		let _g1 = text.length;
		while(_g < _g1) {
			let i = _g++;
			let cc = HxOverrides.cca(text,i);
			let c = font.glyphs.h[cc];
			if(c == null) {
				c = font.charset.resolveChar(cc,font.glyphs);
				if(c == null) {
					c = cc == 13 || cc == 10 ? font.nullChar : font.defaultChar;
				}
			}
			let e = c;
			let newline = cc == 10;
			let esize = e.width + e.getKerningOffset(prevChar);
			let nc = HxOverrides.cca(text,i + 1);
			if(font.charset.isBreakChar(cc) && (nc == null || !font.charset.isComplementChar(nc))) {
				if(lines.length == 0 && leftMargin > 0 && x > maxWidth) {
					lines.push("");
					if(sizes != null) {
						sizes.push(leftMargin);
					}
					x -= leftMargin;
				}
				let size = x + esize + this.letterSpacing;
				let k = i + 1;
				let max = text.length;
				let prevChar1 = prevChar;
				let breakFound = false;
				while(size <= maxWidth && k < max) {
					let cc = HxOverrides.cca(text,k++);
					if(this.lineBreak && (font.charset.isSpace(cc) || cc == 10)) {
						breakFound = true;
						break;
					}
					let c = font.glyphs.h[cc];
					if(c == null) {
						c = font.charset.resolveChar(cc,font.glyphs);
						if(c == null) {
							c = cc == 13 || cc == 10 ? font.nullChar : font.defaultChar;
						}
					}
					let e = c;
					size += e.width + this.letterSpacing + e.getKerningOffset(prevChar1);
					prevChar1 = cc;
					let nc = HxOverrides.cca(text,k + 1);
					if(font.charset.isBreakChar(cc) && (nc == null || !font.charset.isComplementChar(nc))) {
						break;
					}
				}
				if(this.lineBreak && (size > maxWidth || !breakFound && size + afterData > maxWidth)) {
					newline = true;
					if(font.charset.isSpace(cc)) {
						lines.push(HxOverrides.substr(text,restPos,i - restPos));
						e = null;
					} else {
						lines.push(HxOverrides.substr(text,restPos,i + 1 - restPos));
					}
					restPos = i + 1;
				}
			}
			if(e != null && cc != 10) {
				x += esize + this.letterSpacing;
			}
			if(newline) {
				if(sizes != null) {
					sizes.push(x);
				}
				x = 0;
				prevChar = -1;
			} else {
				prevChar = cc;
			}
		}
		if(restPos < text.length) {
			if(lines.length == 0 && leftMargin > 0 && x + afterData - this.letterSpacing > maxWidth) {
				lines.push("");
				if(sizes != null) {
					sizes.push(leftMargin);
				}
				x -= leftMargin;
			}
			lines.push(HxOverrides.substr(text,restPos,text.length - restPos));
			if(sizes != null) {
				sizes.push(x);
			}
		}
		return lines.join("\n");
	}
	initGlyphs(text,rebuild) {
		if(rebuild == null) {
			rebuild = true;
		}
		if(rebuild) {
			this.glyphs.clear();
		}
		let x = 0.;
		let y = 0.;
		let xMax = 0.;
		let xMin = 0.;
		let yMin = 0.;
		let prevChar = -1;
		let linei = 0;
		let align = this.textAlign;
		let lines = [];
		let dl = this.font.lineHeight + this.lineSpacing;
		let t = this.splitRawText(text,0,0,null,lines);
		let _g = 0;
		while(_g < lines.length) {
			let lw = lines[_g];
			++_g;
			if(lw > x) {
				x = lw;
			}
		}
		this.calcWidth = x;
		switch(align._hx_index) {
		case 0:
			x = 0;
			break;
		case 1:case 2:case 3:case 4:
			let max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.realMaxWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
			let k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
			let _g1 = 0;
			let _g2 = lines.length;
			while(_g1 < _g2) {
				let i = _g1++;
				lines[i] = Math.floor((max - lines[i]) * k);
			}
			x = lines[0];
			xMin = x;
			break;
		}
		let _g3 = 0;
		let _g4 = t.length;
		while(_g3 < _g4) {
			let i = _g3++;
			let cc = HxOverrides.cca(t,i);
			let _this = this.font;
			let c = _this.glyphs.h[cc];
			if(c == null) {
				c = _this.charset.resolveChar(cc,_this.glyphs);
				if(c == null) {
					c = cc == 13 || cc == 10 ? _this.nullChar : _this.defaultChar;
				}
			}
			let e = c;
			let offs = e.getKerningOffset(prevChar);
			let esize = e.width + offs;
			if(cc == 10) {
				if(x > xMax) {
					xMax = x;
				}
				switch(align._hx_index) {
				case 0:
					x = 0;
					break;
				case 1:case 2:case 3:case 4:
					x = lines[++linei];
					if(x < xMin) {
						xMin = x;
					}
					break;
				}
				y += dl;
				prevChar = -1;
			} else {
				if(e != null) {
					if(rebuild) {
						if(this.selectionRange != null && this.selectionRange.start <= i && i < this.selectionRange.start + this.selectionRange.length) {
							this.glyphs.content.add(x + offs,y,this.selectionColor.x,this.selectionColor.y,this.selectionColor.z,this.selectionColor.w,e.t);
						} else {
							this.glyphs.content.add(x + offs,y,this._textColorVec.x,this._textColorVec.y,this._textColorVec.z,this._textColorVec.w,e.t);
						}
					}
					if(y == 0 && e.t.dy < yMin) {
						yMin = e.t.dy;
					}
					x += esize + this.letterSpacing;
				}
				prevChar = cc;
			}
		}
		if(x > xMax) {
			xMax = x;
		}
		this.calcXMin = xMin;
		this.calcYMin = yMin;
		this.calcWidth = xMax - xMin;
		this.calcHeight = y + this.font.lineHeight;
		this.calcSizeHeight = y + (this.font.baseLine > 0 ? this.font.baseLine : this.font.lineHeight);
		this.calcDone = true;
		if(rebuild) {
			this.needsRebuild = false;
		}
	}
	get_textHeight() {
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
		return this.calcHeight;
	}
	get_textWidth() {
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
		return this.calcWidth;
	}
	set_maxWidth(w) {
		if(this.maxWidth == w) {
			return w;
		}
		this.maxWidth = w;
		this.updateConstraint();
		return w;
	}
	updateConstraint() {
		let old = this.realMaxWidth;
		if(this.maxWidth == null) {
			this.realMaxWidth = this.constraintWidth;
		} else if(this.constraintWidth < 0) {
			this.realMaxWidth = this.maxWidth;
		} else {
			let a = this.maxWidth;
			let b = this.constraintWidth;
			this.realMaxWidth = a > b ? b : a;
		}
		if(this.realMaxWidth != old) {
			this.rebuild();
		}
	}
	set_textColor(c) {
		if(this.textColor == c) {
			return c;
		}
		this.textColor = c;
		let a = this.color.w;
		let _this = this._textColorVec;
		_this.x = (c >> 16 & 255) / 255;
		_this.y = (c >> 8 & 255) / 255;
		_this.z = (c & 255) / 255;
		_this.w = (c >>> 24) / 255;
		this._textColorVec.w = a;
		this.rebuild();
		return c;
	}
	getBoundsRec(relativeTo,out,forSize) {
		super.getBoundsRec(relativeTo,out,forSize);
		if(this.textChanged && this.text != this.currentText) {
			this.textChanged = false;
			this.currentText = this.text;
			this.calcDone = false;
			this.needsRebuild = true;
		}
		if(!this.calcDone) {
			this.initGlyphs(this.text,this.needsRebuild);
		}
		let x;
		let y;
		let w;
		let h;
		if(forSize) {
			x = this.calcXMin;
			y = 0.;
			w = this.calcWidth;
			h = this.calcSizeHeight;
		} else {
			x = this.calcXMin;
			y = this.calcYMin;
			w = this.calcWidth;
			h = this.calcHeight - this.calcYMin;
		}
		this.addBounds(relativeTo,out,x,y,w,h);
	}
}
$hxClasses["h2d.Text"] = h2d_Text;
h2d_Text.__name__ = "h2d.Text";
h2d_Text.__super__ = h2d_Drawable;
Object.assign(h2d_Text.prototype, {
	__class__: h2d_Text
	,font: null
	,text: null
	,textColor: null
	,maxWidth: null
	,dropShadow: null
	,textWidth: null
	,textHeight: null
	,textAlign: null
	,letterSpacing: null
	,lineSpacing: null
	,lineBreak: null
	,selectionRange: null
	,selectionColor: null
	,_textColorVec: null
	,glyphs: null
	,needsRebuild: null
	,currentText: null
	,textChanged: null
	,calcDone: null
	,calcXMin: null
	,calcYMin: null
	,calcWidth: null
	,calcHeight: null
	,calcSizeHeight: null
	,constraintWidth: null
	,realMaxWidth: null
	,sdfShader: null
});
class gui_HtmlText extends h2d_Text {
	constructor(font,parent) {
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor(font,parent);
	}
	_hx_constructor(font,parent) {
		this.elements = [];
		this.imageVerticalAlign = gui_ImageVerticalAlign.Bottom;
		this.lineHeightMode = gui_LineHeightMode.Accurate;
		this.imageSpacing = 1;
		this.condenseWhite = true;
		super._hx_constructor(font,parent);
	}
	draw(ctx) {
		if(this.dropShadow != null) {
			let oldX = this.absX;
			let oldY = this.absY;
			this.absX += this.dropShadow.dx * this.matA + this.dropShadow.dy * this.matC;
			this.absY += this.dropShadow.dx * this.matB + this.dropShadow.dy * this.matD;
			if(this.dropMatrix == null) {
				this.dropMatrix = new h3d_shader_ColorMatrix();
				this.addShader(this.dropMatrix);
			}
			let _this = this.dropMatrix;
			_this.constModified = true;
			_this.enabled__ = true;
			let m = this.dropMatrix.matrix__;
			m.zero();
			m._41 = (this.dropShadow.color >> 16 & 255) / 255;
			m._42 = (this.dropShadow.color >> 8 & 255) / 255;
			m._43 = (this.dropShadow.color & 255) / 255;
			m._44 = this.dropShadow.alpha;
			let _g = 0;
			let _g1 = this.elements;
			while(_g < _g1.length) {
				let e = _g1[_g];
				++_g;
				if(((e) instanceof h2d_TileGroup)) {
					(js_Boot.__cast(e , h2d_TileGroup)).drawWith(ctx,this);
				}
			}
			this.glyphs.drawWith(ctx,this);
			let _this1 = this.dropMatrix;
			_this1.constModified = true;
			_this1.enabled__ = false;
			this.absX = oldX;
			this.absY = oldY;
		} else {
			this.removeShader(this.dropMatrix);
			this.dropMatrix = null;
		}
		this.glyphs.drawWith(ctx,this);
	}
	loadImage(url) {
		return gui_HtmlText.defaultLoadImage(url);
	}
	loadFont(name) {
		let f = gui_HtmlText.defaultLoadFont(name);
		if(f == null) {
			return this.font;
		} else {
			return f;
		}
	}
	onHyperlink(url) {
	}
	formatText(text) {
		return gui_HtmlText.defaultFormatText(text);
	}
	set_text(t) {
		super.set_text(this.formatText(t));
		return t;
	}
	parseText(text) {
		try {
			return Xml.parse(text);
		} catch( _g ) {
			throw haxe_Exception.thrown("Could not parse " + text + " (" + Std.string(haxe_Exception.caught(_g).unwrap()) + ")");
		}
	}
	validateText() {
		this.textXml = this.parseText(this.text);
		this.validateNodes(this.textXml);
	}
	validateNodes(xml) {
		switch(xml.nodeType) {
		case 0:
			if(xml.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
			}
			let nodeName = xml.nodeName.toLowerCase();
			switch(nodeName) {
			case "b":case "bold":
				this.loadFont("bold");
				break;
			case "font":
				if(xml.exists("face")) {
					this.loadFont(xml.get("face"));
				}
				break;
			case "img":
				this.loadImage(xml.get("src"));
				break;
			case "i":case "italic":
				this.loadFont("italic");
				break;
			}
			if(xml.nodeType != Xml.Document && xml.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
			}
			let _this = xml.children;
			let _g_current = 0;
			while(_g_current < _this.length) {
				let child = _this[_g_current++];
				this.validateNodes(child);
			}
			break;
		case 6:
			if(xml.nodeType != Xml.Document && xml.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
			}
			let _this1 = xml.children;
			let _g_current1 = 0;
			while(_g_current1 < _this1.length) {
				let child = _this1[_g_current1++];
				this.validateNodes(child);
			}
			break;
		default:
		}
	}
	initGlyphs(text,rebuild) {
		if(rebuild == null) {
			rebuild = true;
		}
		if(rebuild) {
			this.glyphs.clear();
			let _g = 0;
			let _g1 = this.elements;
			while(_g < _g1.length) {
				let e = _g1[_g];
				++_g;
				if(e != null && e.parent != null) {
					e.parent.removeChild(e);
				}
			}
			this.elements = [];
		}
		this.glyphs.setDefaultColor(this.textColor);
		let doc;
		if(this.textXml == null) {
			doc = this.parseText(text);
		} else {
			doc = this.textXml;
		}
		this.yPos = 0;
		this.xMax = 0;
		this.xMin = Infinity;
		this.sizePos = 0;
		this.calcYMin = 0;
		let metrics = [{ width : 0, height : this.font.lineHeight, baseLine : this.font.baseLine}];
		this.prevChar = -1;
		this.newLine = true;
		let splitNode = { node : null, pos : 0, font : this.font, prevChar : -1, width : 0, height : 0, baseLine : 0};
		if(doc.nodeType != Xml.Document && doc.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (doc.nodeType == null ? "null" : XmlType.toString(doc.nodeType)));
		}
		let _this = doc.children;
		let _g_current = 0;
		while(_g_current < _this.length) {
			let e = _this[_g_current++];
			this.buildSizes(e,this.font,metrics,splitNode);
		}
		let max = 0.;
		let _g = 0;
		while(_g < metrics.length) {
			let info = metrics[_g];
			++_g;
			if(info.width > max) {
				max = info.width;
			}
		}
		this.calcWidth = max;
		this.prevChar = -1;
		this.newLine = true;
		let align = this.textAlign;
		let size = metrics[0].width;
		switch(align._hx_index) {
		case 0:
			this.xPos = 0;
			if(this.xMin > 0) {
				this.xMin = 0;
			}
			break;
		case 1:case 2:case 3:case 4:
			let max1 = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.calcWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
			let k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
			this.xPos = Math.floor((max1 - size) * k);
			if(this.xPos < this.xMin) {
				this.xMin = this.xPos;
			}
			break;
		}
		if(doc.nodeType != Xml.Document && doc.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (doc.nodeType == null ? "null" : XmlType.toString(doc.nodeType)));
		}
		let _this1 = doc.children;
		let _g_current1 = 0;
		while(_g_current1 < _this1.length) {
			let e = _this1[_g_current1++];
			this.addNode(e,this.font,this.textAlign,rebuild,metrics);
		}
		if(this.xPos > this.xMax) {
			this.xMax = this.xPos;
		}
		this.textXml = null;
		let y = this.yPos;
		this.calcXMin = this.xMin;
		this.calcWidth = this.xMax - this.xMin;
		this.calcHeight = y + metrics[this.sizePos].height;
		this.calcSizeHeight = y + metrics[this.sizePos].baseLine;
		this.calcDone = true;
		if(rebuild) {
			this.needsRebuild = false;
		}
	}
	buildSizes(e,font,metrics,splitNode) {
		let _gthis = this;
		let wordSplit = function() {
			let fnt = splitNode.font;
			let _this = splitNode.node;
			if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
			}
			let str = _this.nodeValue;
			let info = metrics[metrics.length - 1];
			let w = info.width;
			let cc = HxOverrides.cca(str,splitNode.pos);
			info.width = splitNode.width;
			info.height = splitNode.height;
			info.baseLine = splitNode.baseLine;
			let c = fnt.glyphs.h[cc];
			if(c == null) {
				c = fnt.charset.resolveChar(cc,fnt.glyphs);
				if(c == null) {
					c = cc == 13 || cc == 10 ? fnt.nullChar : fnt.defaultChar;
				}
			}
			let char = c;
			if(_gthis.lineBreak && fnt.charset.isSpace(cc)) {
				w -= splitNode.width + _gthis.letterSpacing + char.width + char.getKerningOffset(splitNode.prevChar);
				let _this = splitNode.node;
				let v = HxOverrides.substr(str,0,splitNode.pos) + "\n" + HxOverrides.substr(str,splitNode.pos + 1,null);
				if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
				}
				_this.nodeValue = v;
			} else {
				w -= splitNode.width + _gthis.letterSpacing + char.getKerningOffset(splitNode.prevChar);
				let _this = splitNode.node;
				let v = HxOverrides.substr(str,0,splitNode.pos + 1) + "\n" + HxOverrides.substr(str,splitNode.pos + 1,null);
				if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
				}
				_this.nodeValue = v;
			}
			splitNode.node = null;
			return w;
		};
		if(e.nodeType == Xml.Element) {
			if(e.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			let nodeName = e.nodeName.toLowerCase();
			switch(nodeName) {
			case "b":case "bold":
				font = this.loadFont("bold");
				break;
			case "br":
				let fontInfo = _gthis.lineHeightMode == gui_LineHeightMode.Constant ? _gthis.font : font;
				metrics.push({ width : 0, height : fontInfo.lineHeight, baseLine : fontInfo.baseLine});
				splitNode.node = null;
				_gthis.newLine = true;
				_gthis.prevChar = -1;
				break;
			case "font":
				let a = e.attributes();
				while(a.hasNext()) {
					let a1 = a.next();
					let v = e.get(a1);
					if(a1.toLowerCase() == "face") {
						font = this.loadFont(v);
					}
				}
				break;
			case "img":
				let i = this.loadImage(e.get("src"));
				if(i == null) {
					i = h2d_Tile.fromColor(16711935,8,8);
				}
				let size = metrics[metrics.length - 1].width + i.width + this.imageSpacing;
				if(this.realMaxWidth >= 0 && size > this.realMaxWidth && metrics[metrics.length - 1].width > 0) {
					if(splitNode.node != null) {
						size = wordSplit() + i.width + this.imageSpacing;
						let info = metrics[metrics.length - 1];
						if(this.lineHeightMode._hx_index == 0) {
							let grow = i.height - i.dy - info.baseLine;
							let h = info.height;
							let bl = info.baseLine;
							if(grow > 0) {
								h += grow;
								bl += grow;
							}
							metrics.push({ width : size, height : Math.max(h,bl + i.dy), baseLine : bl});
						} else {
							metrics.push({ width : size, height : info.height, baseLine : info.baseLine});
						}
					}
				} else {
					let info = metrics[metrics.length - 1];
					info.width = size;
					if(this.lineHeightMode == gui_LineHeightMode.Accurate) {
						let grow = i.height - i.dy - info.baseLine;
						if(grow > 0) {
							switch(this.imageVerticalAlign._hx_index) {
							case 0:
								info.height += grow;
								break;
							case 1:
								info.baseLine += grow;
								info.height += grow;
								break;
							case 2:
								info.height += grow;
								info.baseLine += grow / 2 | 0;
								break;
							}
						}
						grow = info.baseLine + i.dy;
						if(info.height < grow) {
							info.height = grow;
						}
					}
				}
				this.newLine = false;
				this.prevChar = -1;
				break;
			case "i":case "italic":
				font = this.loadFont("italic");
				break;
			case "p":
				if(!this.newLine) {
					let fontInfo = _gthis.lineHeightMode == gui_LineHeightMode.Constant ? _gthis.font : font;
					metrics.push({ width : 0, height : fontInfo.lineHeight, baseLine : fontInfo.baseLine});
					splitNode.node = null;
					_gthis.newLine = true;
					_gthis.prevChar = -1;
				}
				break;
			default:
			}
			if(e.nodeType != Xml.Document && e.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			let _this = e.children;
			let _g_current = 0;
			while(_g_current < _this.length) {
				let child = _this[_g_current++];
				this.buildSizes(child,font,metrics,splitNode);
			}
			if(nodeName == "p") {
				if(!this.newLine) {
					let fontInfo = _gthis.lineHeightMode == gui_LineHeightMode.Constant ? _gthis.font : font;
					metrics.push({ width : 0, height : fontInfo.lineHeight, baseLine : fontInfo.baseLine});
					splitNode.node = null;
					_gthis.newLine = true;
					_gthis.prevChar = -1;
				}
			}
		} else {
			if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			if(e.nodeValue.length != 0) {
				this.newLine = false;
				if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
				}
				let text = this.htmlToText(e.nodeValue);
				let fontInfo = _gthis.lineHeightMode == gui_LineHeightMode.Constant ? _gthis.font : font;
				let info = metrics.pop();
				let leftMargin = info.width;
				let maxWidth = this.realMaxWidth < 0 ? Infinity : this.realMaxWidth;
				let textSplit = [];
				let restPos = 0;
				let x = leftMargin;
				let breakChars = 0;
				let _g = 0;
				let _g1 = text.length;
				while(_g < _g1) {
					let i = _g++;
					let cc = HxOverrides.cca(text,i);
					let c = font.glyphs.h[cc];
					if(c == null) {
						c = font.charset.resolveChar(cc,font.glyphs);
						if(c == null) {
							c = cc == 13 || cc == 10 ? font.nullChar : font.defaultChar;
						}
					}
					let g = c;
					let newline = cc == 10;
					let esize = g.width + g.getKerningOffset(this.prevChar);
					let nc = HxOverrides.cca(text,i + 1);
					if(font.charset.isBreakChar(cc) && (nc == null || !font.charset.isComplementChar(nc))) {
						if(x > maxWidth && textSplit.length == 0 && splitNode.node != null) {
							metrics.push({ width : x, height : info.height, baseLine : info.baseLine});
							x = wordSplit();
						}
						let size = x + esize + this.letterSpacing;
						let k = i + 1;
						let max = text.length;
						let prevChar = cc;
						while(size <= maxWidth && k < max) {
							let cc = HxOverrides.cca(text,k++);
							if(this.lineBreak && (font.charset.isSpace(cc) || cc == 10)) {
								break;
							}
							let c = font.glyphs.h[cc];
							if(c == null) {
								c = font.charset.resolveChar(cc,font.glyphs);
								if(c == null) {
									c = cc == 13 || cc == 10 ? font.nullChar : font.defaultChar;
								}
							}
							let e = c;
							size += e.width + this.letterSpacing + e.getKerningOffset(prevChar);
							prevChar = cc;
							let nc = HxOverrides.cca(text,k);
							if(font.charset.isBreakChar(cc) && (nc == null || !font.charset.isComplementChar(nc))) {
								break;
							}
						}
						if(this.lineBreak && size > maxWidth && i != max - 1) {
							newline = true;
							if(font.charset.isSpace(cc)) {
								textSplit.push(HxOverrides.substr(text,restPos,i - restPos));
								g = null;
							} else {
								textSplit.push(HxOverrides.substr(text,restPos,i + 1 - restPos));
								++breakChars;
							}
							splitNode.node = null;
							restPos = i + 1;
						} else {
							splitNode.node = e;
							splitNode.pos = i + breakChars;
							splitNode.prevChar = this.prevChar;
							splitNode.width = x;
							splitNode.height = info.height;
							splitNode.baseLine = info.baseLine;
							splitNode.font = font;
						}
					}
					if(g != null && cc != 10) {
						x += esize + this.letterSpacing;
					}
					if(newline) {
						metrics.push({ width : x, height : info.height, baseLine : info.baseLine});
						info.height = fontInfo.lineHeight;
						info.baseLine = fontInfo.baseLine;
						x = 0;
						this.prevChar = -1;
						this.newLine = true;
					} else {
						this.prevChar = cc;
						this.newLine = false;
					}
				}
				if(restPos < text.length) {
					if(x > maxWidth) {
						if(splitNode.node != null && splitNode.node != e) {
							metrics.push({ width : x, height : info.height, baseLine : info.baseLine});
							x = wordSplit();
						}
					}
					textSplit.push(HxOverrides.substr(text,restPos,null));
					metrics.push({ width : x, height : info.height, baseLine : info.baseLine});
				}
				if(this.newLine || metrics.length == 0) {
					metrics.push({ width : 0, height : fontInfo.lineHeight, baseLine : fontInfo.baseLine});
					textSplit.push("");
				}
				let v = textSplit.join("\n");
				if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
				}
				e.nodeValue = v;
			}
		}
	}
	htmlToText(t) {
		if(this.condenseWhite) {
			t = t.replace(gui_HtmlText.REG_SPACES.r," ");
		}
		return t;
	}
	addNode(e,font,align,rebuild,metrics) {
		let _gthis = this;
		if(e.nodeType == Xml.Element) {
			let prevColor = null;
			let prevGlyphs = null;
			let oldAlign = align;
			if(e.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			let nodeName = e.nodeName.toLowerCase();
			switch(nodeName) {
			case "a":
				if(e.exists("href")) {
					if(_gthis.aInteractive != null) {
						_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
						_gthis.aInteractive = null;
					}
					if(this.aHrefs == null) {
						this.aHrefs = [];
					}
					this.aHrefs.push(e.get("href"));
					if(!(_gthis.aHrefs == null || _gthis.aHrefs.length == 0)) {
						_gthis.aInteractive = new h2d_Interactive(0,metrics[_gthis.sizePos].height,_gthis);
						let href = _gthis.aHrefs[_gthis.aHrefs.length - 1];
						_gthis.aInteractive.onClick = function(event) {
							_gthis.onHyperlink(href);
						};
						let _this = _gthis.aInteractive;
						let v = _gthis.xPos;
						_this.posChanged = true;
						_this.x = v;
						let _this1 = _gthis.aInteractive;
						let v1 = _gthis.yPos;
						_this1.posChanged = true;
						_this1.y = v1;
						_gthis.elements.push(_gthis.aInteractive);
					}
				}
				break;
			case "b":case "bold":
				font = _gthis.loadFont("bold");
				prevGlyphs = _gthis.glyphs;
				let prev = _gthis.glyphs;
				_gthis.glyphs = new h2d_TileGroup(font == null ? null : font.tile,_gthis);
				if(font != null) {
					let _g = font.type;
					if(_g._hx_index == 1) {
						let _g1 = _g.smoothing;
						let shader = new h3d_shader_SignedDistanceField();
						shader.constModified = true;
						shader.channel__ = _g.channel;
						shader.alphaCutoff__ = _g.alphaCutoff;
						shader.smoothing__ = _g1;
						shader.constModified = true;
						shader.autoSmoothing__ = _g1 == -1;
						_gthis.glyphs.smooth = _gthis.smooth;
						_gthis.glyphs.addShader(shader);
					}
				}
				let _this = _gthis.glyphs.curColor;
				let v = prev.curColor;
				_this.x = v.x;
				_this.y = v.y;
				_this.z = v.z;
				_this.w = v.w;
				_gthis.elements.push(_gthis.glyphs);
				break;
			case "br":
				if(_gthis.aInteractive != null) {
					_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
					_gthis.aInteractive = null;
				}
				if(_gthis.xPos > _gthis.xMax) {
					_gthis.xMax = _gthis.xPos;
				}
				_gthis.yPos += metrics[_gthis.sizePos].height + _gthis.lineSpacing;
				let size = metrics[++_gthis.sizePos].width;
				switch(align._hx_index) {
				case 0:
					_gthis.xPos = 0;
					if(_gthis.xMin > 0) {
						_gthis.xMin = 0;
					}
					break;
				case 1:case 2:case 3:case 4:
					let max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(_gthis.calcWidth) : _gthis.calcWidth < 0 ? 0 : Math.ceil(_gthis.realMaxWidth);
					let k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
					_gthis.xPos = Math.floor((max - size) * k);
					if(_gthis.xPos < _gthis.xMin) {
						_gthis.xMin = _gthis.xPos;
					}
					break;
				}
				if(!(_gthis.aHrefs == null || _gthis.aHrefs.length == 0)) {
					_gthis.aInteractive = new h2d_Interactive(0,metrics[_gthis.sizePos].height,_gthis);
					let href = _gthis.aHrefs[_gthis.aHrefs.length - 1];
					_gthis.aInteractive.onClick = function(event) {
						_gthis.onHyperlink(href);
					};
					let _this = _gthis.aInteractive;
					let v = _gthis.xPos;
					_this.posChanged = true;
					_this.x = v;
					let _this1 = _gthis.aInteractive;
					let v1 = _gthis.yPos;
					_this1.posChanged = true;
					_this1.y = v1;
					_gthis.elements.push(_gthis.aInteractive);
				}
				this.newLine = true;
				this.prevChar = -1;
				break;
			case "font":
				let a = e.attributes();
				while(a.hasNext()) {
					let a1 = a.next();
					let v = e.get(a1);
					switch(a1.toLowerCase()) {
					case "color":
						if(prevColor == null) {
							let _this = this.glyphs.curColor;
							prevColor = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
						}
						if(HxOverrides.cca(v,0) == 35 && v.length == 4) {
							v = "#" + v.charAt(1) + v.charAt(1) + v.charAt(2) + v.charAt(2) + v.charAt(3) + v.charAt(3);
						}
						this.glyphs.setDefaultColor(Std.parseInt("0x" + HxOverrides.substr(v,1,null)));
						break;
					case "face":
						font = _gthis.loadFont(v);
						if(prevGlyphs == null) {
							prevGlyphs = _gthis.glyphs;
						}
						let prev = _gthis.glyphs;
						_gthis.glyphs = new h2d_TileGroup(font == null ? null : font.tile,_gthis);
						if(font != null) {
							let _g = font.type;
							if(_g._hx_index == 1) {
								let _g1 = _g.smoothing;
								let shader = new h3d_shader_SignedDistanceField();
								shader.constModified = true;
								shader.channel__ = _g.channel;
								shader.alphaCutoff__ = _g.alphaCutoff;
								shader.smoothing__ = _g1;
								shader.constModified = true;
								shader.autoSmoothing__ = _g1 == -1;
								_gthis.glyphs.smooth = _gthis.smooth;
								_gthis.glyphs.addShader(shader);
							}
						}
						let _this = _gthis.glyphs.curColor;
						let v1 = prev.curColor;
						_this.x = v1.x;
						_this.y = v1.y;
						_this.z = v1.z;
						_this.w = v1.w;
						_gthis.elements.push(_gthis.glyphs);
						break;
					case "opacity":
						if(prevColor == null) {
							let _this = this.glyphs.curColor;
							prevColor = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
						}
						this.glyphs.curColor.w *= parseFloat(v);
						break;
					default:
					}
				}
				break;
			case "img":
				let i = this.loadImage(e.get("src"));
				if(i == null) {
					i = h2d_Tile.fromColor(16711935,8,8);
				}
				let py = this.yPos;
				switch(this.imageVerticalAlign._hx_index) {
				case 0:
					break;
				case 1:
					py += metrics[this.sizePos].baseLine - i.height;
					break;
				case 2:
					py += metrics[this.sizePos].baseLine - i.height / 2;
					break;
				}
				if(py + i.dy < this.calcYMin) {
					this.calcYMin = py + i.dy;
				}
				if(rebuild) {
					let b = new h2d_Bitmap(i,this);
					b.posChanged = true;
					b.x = this.xPos;
					b.posChanged = true;
					b.y = py;
					this.elements.push(b);
				}
				this.newLine = false;
				this.prevChar = -1;
				this.xPos += i.width + this.imageSpacing;
				break;
			case "i":case "italic":
				font = _gthis.loadFont("italic");
				prevGlyphs = _gthis.glyphs;
				let prev1 = _gthis.glyphs;
				_gthis.glyphs = new h2d_TileGroup(font == null ? null : font.tile,_gthis);
				if(font != null) {
					let _g = font.type;
					if(_g._hx_index == 1) {
						let _g1 = _g.smoothing;
						let shader = new h3d_shader_SignedDistanceField();
						shader.constModified = true;
						shader.channel__ = _g.channel;
						shader.alphaCutoff__ = _g.alphaCutoff;
						shader.smoothing__ = _g1;
						shader.constModified = true;
						shader.autoSmoothing__ = _g1 == -1;
						_gthis.glyphs.smooth = _gthis.smooth;
						_gthis.glyphs.addShader(shader);
					}
				}
				let _this1 = _gthis.glyphs.curColor;
				let v1 = prev1.curColor;
				_this1.x = v1.x;
				_this1.y = v1.y;
				_this1.z = v1.z;
				_this1.w = v1.w;
				_gthis.elements.push(_gthis.glyphs);
				break;
			case "offset":
				let a1 = e.attributes();
				while(a1.hasNext()) {
					let a = a1.next();
					if(a.toLowerCase() == "value") {
						let v = e.get(a);
						if(v != null) {
							this.xPos = parseFloat(v) * src_Settings.uiScale;
						}
					}
				}
				break;
			case "p":
				let a2 = e.attributes();
				while(a2.hasNext()) {
					let a = a2.next();
					if(a.toLowerCase() == "align") {
						let v = e.get(a);
						if(v != null) {
							switch(v.toLowerCase()) {
							case "center":
								align = h2d_Align.Center;
								break;
							case "left":
								align = h2d_Align.Left;
								break;
							case "multiline-center":
								align = h2d_Align.MultilineCenter;
								break;
							case "multiline-right":
								align = h2d_Align.MultilineRight;
								break;
							case "right":
								align = h2d_Align.Right;
								break;
							}
						}
					}
				}
				if(!this.newLine) {
					if(_gthis.aInteractive != null) {
						_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
						_gthis.aInteractive = null;
					}
					if(_gthis.xPos > _gthis.xMax) {
						_gthis.xMax = _gthis.xPos;
					}
					_gthis.yPos += metrics[_gthis.sizePos].height + _gthis.lineSpacing;
					let size = metrics[++_gthis.sizePos].width;
					switch(align._hx_index) {
					case 0:
						_gthis.xPos = 0;
						if(_gthis.xMin > 0) {
							_gthis.xMin = 0;
						}
						break;
					case 1:case 2:case 3:case 4:
						let max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(_gthis.calcWidth) : _gthis.calcWidth < 0 ? 0 : Math.ceil(_gthis.realMaxWidth);
						let k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
						_gthis.xPos = Math.floor((max - size) * k);
						if(_gthis.xPos < _gthis.xMin) {
							_gthis.xMin = _gthis.xPos;
						}
						break;
					}
					if(!(_gthis.aHrefs == null || _gthis.aHrefs.length == 0)) {
						_gthis.aInteractive = new h2d_Interactive(0,metrics[_gthis.sizePos].height,_gthis);
						let href = _gthis.aHrefs[_gthis.aHrefs.length - 1];
						_gthis.aInteractive.onClick = function(event) {
							_gthis.onHyperlink(href);
						};
						let _this = _gthis.aInteractive;
						let v = _gthis.xPos;
						_this.posChanged = true;
						_this.x = v;
						let _this1 = _gthis.aInteractive;
						let v1 = _gthis.yPos;
						_this1.posChanged = true;
						_this1.y = v1;
						_gthis.elements.push(_gthis.aInteractive);
					}
					this.newLine = true;
					this.prevChar = -1;
				} else {
					let size = metrics[this.sizePos].width;
					switch(align._hx_index) {
					case 0:
						this.xPos = 0;
						if(this.xMin > 0) {
							this.xMin = 0;
						}
						break;
					case 1:case 2:case 3:case 4:
						let max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.calcWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
						let k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
						this.xPos = Math.floor((max - size) * k);
						if(this.xPos < this.xMin) {
							this.xMin = this.xPos;
						}
						break;
					}
				}
				break;
			default:
			}
			if(e.nodeType != Xml.Document && e.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			let _this2 = e.children;
			let _g_current = 0;
			while(_g_current < _this2.length) {
				let child = _this2[_g_current++];
				this.addNode(child,font,align,rebuild,metrics);
			}
			align = oldAlign;
			switch(nodeName) {
			case "a":
				if(this.aHrefs.length > 0) {
					if(_gthis.aInteractive != null) {
						_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
						_gthis.aInteractive = null;
					}
					this.aHrefs.pop();
					if(!(_gthis.aHrefs == null || _gthis.aHrefs.length == 0)) {
						_gthis.aInteractive = new h2d_Interactive(0,metrics[_gthis.sizePos].height,_gthis);
						let href = _gthis.aHrefs[_gthis.aHrefs.length - 1];
						_gthis.aInteractive.onClick = function(event) {
							_gthis.onHyperlink(href);
						};
						let _this = _gthis.aInteractive;
						let v = _gthis.xPos;
						_this.posChanged = true;
						_this.x = v;
						let _this1 = _gthis.aInteractive;
						let v1 = _gthis.yPos;
						_this1.posChanged = true;
						_this1.y = v1;
						_gthis.elements.push(_gthis.aInteractive);
					}
				}
				break;
			case "p":
				if(this.newLine) {
					let size = metrics[this.sizePos].width;
					switch(oldAlign._hx_index) {
					case 0:
						this.xPos = 0;
						if(this.xMin > 0) {
							this.xMin = 0;
						}
						break;
					case 1:case 2:case 3:case 4:
						let max = oldAlign == h2d_Align.MultilineCenter || oldAlign == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.calcWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
						let k = oldAlign == h2d_Align.Center || oldAlign == h2d_Align.MultilineCenter ? 0.5 : 1;
						this.xPos = Math.floor((max - size) * k);
						if(this.xPos < this.xMin) {
							this.xMin = this.xPos;
						}
						break;
					}
				} else if(this.sizePos < metrics.length - 2 || metrics[this.sizePos + 1].width != 0) {
					if(_gthis.aInteractive != null) {
						_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
						_gthis.aInteractive = null;
					}
					if(_gthis.xPos > _gthis.xMax) {
						_gthis.xMax = _gthis.xPos;
					}
					_gthis.yPos += metrics[_gthis.sizePos].height + _gthis.lineSpacing;
					let size = metrics[++_gthis.sizePos].width;
					switch(oldAlign._hx_index) {
					case 0:
						_gthis.xPos = 0;
						if(_gthis.xMin > 0) {
							_gthis.xMin = 0;
						}
						break;
					case 1:case 2:case 3:case 4:
						let max = oldAlign == h2d_Align.MultilineCenter || oldAlign == h2d_Align.MultilineRight ? Math.ceil(_gthis.calcWidth) : _gthis.calcWidth < 0 ? 0 : Math.ceil(_gthis.realMaxWidth);
						let k = oldAlign == h2d_Align.Center || oldAlign == h2d_Align.MultilineCenter ? 0.5 : 1;
						_gthis.xPos = Math.floor((max - size) * k);
						if(_gthis.xPos < _gthis.xMin) {
							_gthis.xMin = _gthis.xPos;
						}
						break;
					}
					if(!(_gthis.aHrefs == null || _gthis.aHrefs.length == 0)) {
						_gthis.aInteractive = new h2d_Interactive(0,metrics[_gthis.sizePos].height,_gthis);
						let href = _gthis.aHrefs[_gthis.aHrefs.length - 1];
						_gthis.aInteractive.onClick = function(event) {
							_gthis.onHyperlink(href);
						};
						let _this = _gthis.aInteractive;
						let v = _gthis.xPos;
						_this.posChanged = true;
						_this.x = v;
						let _this1 = _gthis.aInteractive;
						let v1 = _gthis.yPos;
						_this1.posChanged = true;
						_this1.y = v1;
						_gthis.elements.push(_gthis.aInteractive);
					}
					this.newLine = true;
					this.prevChar = -1;
				}
				break;
			default:
			}
			if(prevGlyphs != null) {
				this.glyphs = prevGlyphs;
			}
			if(prevColor != null) {
				let _this = this.glyphs.curColor;
				_this.x = prevColor.x;
				_this.y = prevColor.y;
				_this.z = prevColor.z;
				_this.w = prevColor.w;
			}
		} else {
			if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			if(e.nodeValue.length != 0) {
				this.newLine = false;
				if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
				}
				let t = e.nodeValue;
				let dy = metrics[this.sizePos].baseLine - font.baseLine;
				let _g = 0;
				let _g1 = t.length;
				while(_g < _g1) {
					let i = _g++;
					let cc = HxOverrides.cca(t,i);
					if(cc == 10) {
						if(_gthis.aInteractive != null) {
							_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
							_gthis.aInteractive = null;
						}
						if(_gthis.xPos > _gthis.xMax) {
							_gthis.xMax = _gthis.xPos;
						}
						_gthis.yPos += metrics[_gthis.sizePos].height + _gthis.lineSpacing;
						let size = metrics[++_gthis.sizePos].width;
						switch(align._hx_index) {
						case 0:
							_gthis.xPos = 0;
							if(_gthis.xMin > 0) {
								_gthis.xMin = 0;
							}
							break;
						case 1:case 2:case 3:case 4:
							let max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(_gthis.calcWidth) : _gthis.calcWidth < 0 ? 0 : Math.ceil(_gthis.realMaxWidth);
							let k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
							_gthis.xPos = Math.floor((max - size) * k);
							if(_gthis.xPos < _gthis.xMin) {
								_gthis.xMin = _gthis.xPos;
							}
							break;
						}
						if(!(_gthis.aHrefs == null || _gthis.aHrefs.length == 0)) {
							_gthis.aInteractive = new h2d_Interactive(0,metrics[_gthis.sizePos].height,_gthis);
							let href = _gthis.aHrefs[_gthis.aHrefs.length - 1];
							_gthis.aInteractive.onClick = function(event) {
								_gthis.onHyperlink(href);
							};
							let _this = _gthis.aInteractive;
							let v = _gthis.xPos;
							_this.posChanged = true;
							_this.x = v;
							let _this1 = _gthis.aInteractive;
							let v1 = _gthis.yPos;
							_this1.posChanged = true;
							_this1.y = v1;
							_gthis.elements.push(_gthis.aInteractive);
						}
						dy = metrics[this.sizePos].baseLine - font.baseLine;
						this.prevChar = -1;
						continue;
					} else {
						let c = font.glyphs.h[cc];
						if(c == null) {
							c = font.charset.resolveChar(cc,font.glyphs);
							if(c == null) {
								c = cc == 13 || cc == 10 ? font.nullChar : font.defaultChar;
							}
						}
						let fc = c;
						if(fc != null) {
							this.xPos += fc.getKerningOffset(this.prevChar);
							if(rebuild) {
								let _this = this.glyphs;
								_this.content.add(this.xPos,this.yPos + dy,_this.curColor.x,_this.curColor.y,_this.curColor.z,_this.curColor.w,fc.t);
							}
							if(this.yPos == 0 && fc.t.dy + dy < this.calcYMin) {
								this.calcYMin = fc.t.dy + dy;
							}
							this.xPos += fc.width + this.letterSpacing;
						}
						this.prevChar = cc;
					}
				}
			}
		}
	}
	set_textColor(c) {
		if(this.textColor == c) {
			return c;
		}
		this.textColor = c;
		this.rebuild();
		return c;
	}
	set_imageVerticalAlign(align) {
		if(this.imageVerticalAlign != align) {
			this.imageVerticalAlign = align;
			this.rebuild();
		}
		return align;
	}
	getBoundsRec(relativeTo,out,forSize) {
		if(forSize) {
			let _g = 0;
			let _g1 = this.elements;
			while(_g < _g1.length) {
				let i = _g1[_g];
				++_g;
				if(((i) instanceof h2d_Bitmap)) {
					i.set_visible(false);
				}
			}
		}
		super.getBoundsRec(relativeTo,out,forSize);
		if(forSize) {
			let _g = 0;
			let _g1 = this.elements;
			while(_g < _g1.length) {
				let i = _g1[_g];
				++_g;
				i.set_visible(true);
			}
		}
	}
	static defaultLoadImage(url) {
		return null;
	}
	static defaultLoadFont(name) {
		return null;
	}
	static defaultFormatText(text) {
		return text;
	}
}
$hxClasses["gui.HtmlText"] = gui_HtmlText;
gui_HtmlText.__name__ = "gui.HtmlText";
gui_HtmlText.__super__ = h2d_Text;
Object.assign(gui_HtmlText.prototype, {
	__class__: gui_HtmlText
	,condenseWhite: null
	,imageSpacing: null
	,lineHeightMode: null
	,imageVerticalAlign: null
	,elements: null
	,xPos: null
	,yPos: null
	,xMax: null
	,xMin: null
	,textXml: null
	,sizePos: null
	,dropMatrix: null
	,prevChar: null
	,newLine: null
	,aHrefs: null
	,aInteractive: null
});
class gui_InputOptionsGui extends gui_GuiImage {
	constructor(pauseGui) {
		if(pauseGui == null) {
			pauseGui = false;
		}
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("INPUT & SOUND OPTIONS");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let numberRange = function(start,stop,step) {
			let range = [];
			while(start <= stop) {
				range.push("" + start);
				start += step;
			}
			return range;
		};
		let optionCollection = new gui_GuiXboxOptionsListCollection();
		optionCollection.position = new h3d_Vector(380,160);
		optionCollection.extent = new h3d_Vector(815,500);
		this.innerCtrl.addChild(optionCollection);
		let iyOpt = optionCollection.addOption(1,"Camera Y-Axis",["Normal","Inverted"],function(idx) {
			src_Settings.controlsSettings.invertYAxis = idx == 1;
			return true;
		},0.5,118);
		iyOpt.setCurrentOption(src_Settings.controlsSettings.invertYAxis ? 1 : 0);
		let musicOpt = optionCollection.addOption(1,"Music Volume",numberRange(0,100,5),function(idx) {
			src_Settings.optionsSettings.musicVolume = idx / 20.0;
			src_AudioManager.updateVolumes();
			return true;
		},0.5,118);
		let value = Math.floor(src_Settings.optionsSettings.musicVolume * 20);
		musicOpt.setCurrentOption((value < 0 ? 0 : value > 20 ? 20 : value) | 0);
		let soundOpt = optionCollection.addOption(1,"Effects Volume",numberRange(0,100,5),function(idx) {
			src_Settings.optionsSettings.soundVolume = idx / 20.0;
			src_AudioManager.updateVolumes();
			return true;
		},0.5,118);
		let value1 = Math.floor(src_Settings.optionsSettings.soundVolume * 20);
		soundOpt.setCurrentOption((value1 < 0 ? 0 : value1 > 20 ? 20 : value1) | 0);
		let flOpt = optionCollection.addOption(1,"Free-Look",["Disabled","Enabled"],function(idx) {
			src_Settings.controlsSettings.alwaysFreeLook = idx == 1;
			return true;
		},0.5,118);
		flOpt.setCurrentOption(src_Settings.controlsSettings.alwaysFreeLook ? 1 : 0);
		let clOpt = optionCollection.addOption(1,"Camera Recentering",["Disabled","Enabled"],function(idx) {
			src_Settings.controlsSettings.controllerVerticalCenter = idx == 1;
			return true;
		},0.5,118);
		clOpt.setCurrentOption(src_Settings.controlsSettings.controllerVerticalCenter ? 1 : 0);
		let msOpt = optionCollection.addOption(1,"Mouse Sensitivity",numberRange(10,100,5),function(idx) {
			src_Settings.controlsSettings.cameraSensitivity = 0.12 + idx / 18.0 * 1.08;
			return true;
		},0.5,118);
		let value2 = Math.floor((src_Settings.controlsSettings.cameraSensitivity - 0.12) / 1.08 * 18);
		msOpt.setCurrentOption((value2 < 0 ? 0 : value2 > 18 ? 18 : value2) | 0);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Ok",160);
		backButton.position = new h3d_Vector(960,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["A"];
		backButton.accelerators = [13];
		let _gthis = this;
		if(pauseGui) {
			backButton.pressedAction = function(e) {
				src_Settings.applySettings();
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.canvas.pushDialog(new gui_OptionsListGui(true));
			};
		} else {
			backButton.pressedAction = function(e) {
				src_Settings.applySettings();
				src_MarbleGame.canvas.setContent(new gui_OptionsListGui());
			};
		}
		bottomBar.addChild(backButton);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.InputOptionsGui"] = gui_InputOptionsGui;
gui_InputOptionsGui.__name__ = "gui.InputOptionsGui";
gui_InputOptionsGui.__super__ = gui_GuiImage;
Object.assign(gui_InputOptionsGui.prototype, {
	__class__: gui_InputOptionsGui
	,innerCtrl: null
});
class gui_JoinServerGui extends gui_GuiImage {
	constructor() {
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("JOIN GAME");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let inviteCodeBg = new gui_GuiXboxOptionsList(1,"Invite Code: ",[""],0.3,155.5,false);
		inviteCodeBg.position = new h3d_Vector(360,111);
		inviteCodeBg.horizSizing = gui_HorizSizing.Right;
		inviteCodeBg.vertSizing = gui_VertSizing.Bottom;
		inviteCodeBg.extent = new h3d_Vector(835,400);
		inviteCodeBg.selected = true;
		this.innerCtrl.addChild(inviteCodeBg);
		let inviteCodeInput = new gui_GuiText(arial14);
		inviteCodeInput.position = new h3d_Vector(640,36);
		inviteCodeInput.extent = new h3d_Vector(235,18);
		inviteCodeInput.vertSizing = gui_VertSizing.Top;
		inviteCodeInput.text.set_text("");
		inviteCodeInput.text.set_textColor(0);
		inviteCodeBg.addChild(inviteCodeInput);
		let numpadCtrl = new gui_GuiControl();
		numpadCtrl.position = new h3d_Vector(0,60);
		numpadCtrl.extent = new h3d_Vector(800,300);
		numpadCtrl.vertSizing = gui_VertSizing.Top;
		inviteCodeBg.addChild(numpadCtrl);
		let addNum = function(str) {
			if(inviteCodeInput.text.text.length < 6) {
				let fh = inviteCodeInput.text;
				fh.set_text(fh.text + str);
			}
		};
		let delNum = function() {
			if(inviteCodeInput.text.text.length > 0) {
				inviteCodeInput.text.set_text(inviteCodeInput.text.text.substring(0,inviteCodeInput.text.text.length - 1));
			}
		};
		let one = new gui_GuiXboxButton("1",110);
		one.position = new h3d_Vector(240,150);
		one.accelerators = [49,97];
		one.pressedAction = function(e) {
			addNum("1");
		};
		numpadCtrl.addChild(one);
		let two = new gui_GuiXboxButton("2",110);
		two.position = new h3d_Vector(320,150);
		two.accelerators = [50,98];
		two.pressedAction = function(e) {
			addNum("2");
		};
		numpadCtrl.addChild(two);
		let three = new gui_GuiXboxButton("3",110);
		three.position = new h3d_Vector(400,150);
		three.accelerators = [51,99];
		three.pressedAction = function(e) {
			addNum("3");
		};
		numpadCtrl.addChild(three);
		let four = new gui_GuiXboxButton("4",110);
		four.position = new h3d_Vector(240,80);
		four.accelerators = [52,100];
		four.pressedAction = function(e) {
			addNum("4");
		};
		numpadCtrl.addChild(four);
		let five = new gui_GuiXboxButton("5",110);
		five.position = new h3d_Vector(320,80);
		five.accelerators = [53,101];
		five.pressedAction = function(e) {
			addNum("5");
		};
		numpadCtrl.addChild(five);
		let six = new gui_GuiXboxButton("6",110);
		six.position = new h3d_Vector(400,80);
		six.accelerators = [54,102];
		six.pressedAction = function(e) {
			addNum("6");
		};
		numpadCtrl.addChild(six);
		let seven = new gui_GuiXboxButton("7",110);
		seven.position = new h3d_Vector(240,10);
		seven.accelerators = [55,103];
		seven.pressedAction = function(e) {
			addNum("7");
		};
		numpadCtrl.addChild(seven);
		let eight = new gui_GuiXboxButton("8",110);
		eight.position = new h3d_Vector(320,10);
		eight.accelerators = [56,104];
		eight.pressedAction = function(e) {
			addNum("8");
		};
		numpadCtrl.addChild(eight);
		let nine = new gui_GuiXboxButton("9",110);
		nine.position = new h3d_Vector(400,10);
		nine.accelerators = [57,105];
		nine.pressedAction = function(e) {
			addNum("9");
		};
		numpadCtrl.addChild(nine);
		let zero = new gui_GuiXboxButton("0",110);
		zero.position = new h3d_Vector(240,220);
		zero.accelerators = [48,96];
		zero.pressedAction = function(e) {
			addNum("0");
		};
		numpadCtrl.addChild(zero);
		let del = new gui_GuiXboxButton("Del",110);
		del.position = new h3d_Vector(400,220);
		del.accelerators = [46,8];
		del.pressedAction = function(e) {
			delNum();
		};
		numpadCtrl.addChild(del);
		let joinFunc = function() {
			src_MarbleGame.canvas.setContent(new gui_MultiplayerLoadingGui("Connecting"));
			let failed = true;
			haxe_Timer.delay(function() {
				if(failed) {
					if(((src_MarbleGame.canvas.content) instanceof gui_MultiplayerLoadingGui)) {
						let loadGui = src_MarbleGame.canvas.content;
						if(loadGui != null) {
							loadGui.setErrorStatus("Failed to connect to server");
						}
					}
					net_Net.disconnect();
				}
			},15000);
			net_Net.joinServer(inviteCodeInput.text.text,true,function() {
				failed = false;
			});
		};
		let ok = new gui_GuiXboxButton("OK",110);
		ok.position = new h3d_Vector(320,220);
		ok.accelerators = [13];
		ok.pressedAction = function(e) {
			joinFunc();
		};
		numpadCtrl.addChild(ok);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Back",160);
		backButton.position = new h3d_Vector(400,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["B"];
		backButton.accelerators = [27,8];
		backButton.pressedAction = function(e) {
			src_MarbleGame.canvas.setContent(new gui_MultiplayerGui());
		};
		bottomBar.addChild(backButton);
		let goButton = new gui_GuiXboxButton("Go",160);
		goButton.position = new h3d_Vector(960,0);
		goButton.vertSizing = gui_VertSizing.Bottom;
		goButton.horizSizing = gui_HorizSizing.Right;
		goButton.gamepadAccelerator = ["A"];
		goButton.accelerators = [13];
		goButton.pressedAction = function(e) {
			joinFunc();
		};
		bottomBar.addChild(goButton);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.JoinServerGui"] = gui_JoinServerGui;
gui_JoinServerGui.__name__ = "gui.JoinServerGui";
gui_JoinServerGui.__super__ = gui_GuiImage;
Object.assign(gui_JoinServerGui.prototype, {
	__class__: gui_JoinServerGui
	,innerCtrl: null
});
class gui_KeyBindingsGui extends gui_GuiImage {
	constructor(pauseGui) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(pauseGui);
	}
	_hx_constructor(pauseGui) {
		if(pauseGui == null) {
			pauseGui = false;
		}
		this.selectedColumn = 0;
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super._hx_constructor(res);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let getConflictingBinding = function(bindingName,key) {
			if(src_Settings.controlsSettings.forward == key && bindingName != "Move Forward") {
				return "Move Forward";
			}
			if(src_Settings.controlsSettings.backward == key && bindingName != "Move Backward") {
				return "Move Backward";
			}
			if(src_Settings.controlsSettings.left == key && bindingName != "Move Left") {
				return "Move Left";
			}
			if(src_Settings.controlsSettings.right == key && bindingName != "Move Right") {
				return "Move Right";
			}
			if(src_Settings.controlsSettings.camForward == key && bindingName != "Rotate Camera Up") {
				return "Rotate Camera Up";
			}
			if(src_Settings.controlsSettings.camBackward == key && bindingName != "Rotate Camera Down") {
				return "Rotate Camera Down";
			}
			if(src_Settings.controlsSettings.camLeft == key && bindingName != "Rotate Camera Left") {
				return "Rotate Camera Left";
			}
			if(src_Settings.controlsSettings.camRight == key && bindingName != "Rotate Camera Right") {
				return "Rotate Camera Right";
			}
			if(src_Settings.controlsSettings.jump == key && bindingName != "Jump") {
				return "Jump";
			}
			if(src_Settings.controlsSettings.powerup == key && bindingName != "Use PowerUp") {
				return "Use PowerUp";
			}
			if(src_Settings.controlsSettings.freelook == key && bindingName != "Free Look") {
				return "Free Look";
			}
			if(src_Settings.controlsSettings.rewind == key && bindingName != "Rewind") {
				return "Rewind";
			}
			if(src_Settings.controlsSettings.chat == key && bindingName != "Chat") {
				return "Chat";
			}
			return null;
		};
		let remapFunc = function(bindingName,bindingFunc,ctrl) {
			let remapDlg = new gui_RemapDlg(bindingName);
			src_MarbleGame.canvas.pushDialog(remapDlg);
			remapDlg.remapCallback = function(key) {
				src_MarbleGame.canvas.popDialog(remapDlg);
				if(key == 27) {
					return;
				}
				let conflicting = getConflictingBinding(bindingName,key);
				if(conflicting == null) {
					let keyName = hxd_Key.getKeyName(key);
					if(keyName == "MouseLeft") {
						keyName = "Left Mouse";
					}
					if(keyName == "MouseRight") {
						keyName = "Right Mouse";
					}
					if(keyName == "MouseMiddle") {
						keyName = "Middle Mouse";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					ctrl.buttonText.text.set_text("" + bindingName + ": " + keyName);
					bindingFunc(key);
				} else {
					let keyName = hxd_Key.getKeyName(key);
					if(keyName == "MouseLeft") {
						keyName = "Left Mouse";
					}
					if(keyName == "MouseRight") {
						keyName = "Right Mouse";
					}
					if(keyName == "MouseMiddle") {
						keyName = "Middle Mouse";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					let yesNoDlg = new gui_MessageBoxYesNoDlg("\"" + keyName + "\" is already bound to \"" + conflicting + "\"!<br/>Do you want to undo this mapping?",function() {
						let keyName = hxd_Key.getKeyName(key);
						if(keyName == "MouseLeft") {
							keyName = "Left Mouse";
						}
						if(keyName == "MouseRight") {
							keyName = "Right Mouse";
						}
						if(keyName == "MouseMiddle") {
							keyName = "Middle Mouse";
						}
						if(keyName == "Space") {
							keyName = "Space Bar";
						}
						ctrl.buttonText.text.set_text("" + bindingName + ": " + keyName);
						bindingFunc(key);
					},function() {
					});
					src_MarbleGame.canvas.pushDialog(yesNoDlg);
				}
			};
		};
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("KEY BINDINGS");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		this.btnListLeft = new gui_GuiXboxList();
		this.btnListLeft.position = new h3d_Vector(70 - offsetX,135);
		this.btnListLeft.horizSizing = gui_HorizSizing.Left;
		this.btnListLeft.extent = new h3d_Vector(502,500);
		this.btnListLeft.active = false;
		this.innerCtrl.addChild(this.btnListLeft);
		this.btnListRight = new gui_GuiXboxList();
		this.btnListRight.position = new h3d_Vector(-400 - offsetX,135);
		this.btnListRight.horizSizing = gui_HorizSizing.Left;
		this.btnListRight.extent = new h3d_Vector(502,500);
		this.innerCtrl.addChild(this.btnListRight);
		let keyName = hxd_Key.getKeyName(src_Settings.controlsSettings.forward);
		if(keyName == "MouseLeft") {
			keyName = "Left Mouse";
		}
		if(keyName == "MouseRight") {
			keyName = "Right Mouse";
		}
		if(keyName == "MouseMiddle") {
			keyName = "Middle Mouse";
		}
		if(keyName == "Space") {
			keyName = "Space Bar";
		}
		let b1 = this.btnListRight.addButton(0,"Move Forward: " + keyName,function(e) {
		});
		b1.pressedAction = function(e) {
			remapFunc("Move Forward",function(key) {
				src_Settings.controlsSettings.forward = key;
			},b1);
		};
		let keyName1 = hxd_Key.getKeyName(src_Settings.controlsSettings.backward);
		if(keyName1 == "MouseLeft") {
			keyName1 = "Left Mouse";
		}
		if(keyName1 == "MouseRight") {
			keyName1 = "Right Mouse";
		}
		if(keyName1 == "MouseMiddle") {
			keyName1 = "Middle Mouse";
		}
		if(keyName1 == "Space") {
			keyName1 = "Space Bar";
		}
		let b2 = this.btnListRight.addButton(0,"Move Backward: " + keyName1,function(e) {
		});
		b2.pressedAction = function(e) {
			remapFunc("Move Backward",function(key) {
				src_Settings.controlsSettings.backward = key;
			},b2);
		};
		let keyName2 = hxd_Key.getKeyName(src_Settings.controlsSettings.left);
		if(keyName2 == "MouseLeft") {
			keyName2 = "Left Mouse";
		}
		if(keyName2 == "MouseRight") {
			keyName2 = "Right Mouse";
		}
		if(keyName2 == "MouseMiddle") {
			keyName2 = "Middle Mouse";
		}
		if(keyName2 == "Space") {
			keyName2 = "Space Bar";
		}
		let b3 = this.btnListRight.addButton(0,"Move Left: " + keyName2,function(e) {
		});
		b3.pressedAction = function(e) {
			remapFunc("Move Left",function(key) {
				src_Settings.controlsSettings.left = key;
			},b3);
		};
		let keyName3 = hxd_Key.getKeyName(src_Settings.controlsSettings.right);
		if(keyName3 == "MouseLeft") {
			keyName3 = "Left Mouse";
		}
		if(keyName3 == "MouseRight") {
			keyName3 = "Right Mouse";
		}
		if(keyName3 == "MouseMiddle") {
			keyName3 = "Middle Mouse";
		}
		if(keyName3 == "Space") {
			keyName3 = "Space Bar";
		}
		let b4 = this.btnListRight.addButton(0,"Move Right: " + keyName3,function(e) {
		});
		b4.pressedAction = function(e) {
			remapFunc("Move Right",function(key) {
				src_Settings.controlsSettings.right = key;
			},b4);
		};
		let keyName4 = hxd_Key.getKeyName(src_Settings.controlsSettings.jump);
		if(keyName4 == "MouseLeft") {
			keyName4 = "Left Mouse";
		}
		if(keyName4 == "MouseRight") {
			keyName4 = "Right Mouse";
		}
		if(keyName4 == "MouseMiddle") {
			keyName4 = "Middle Mouse";
		}
		if(keyName4 == "Space") {
			keyName4 = "Space Bar";
		}
		let b5 = this.btnListRight.addButton(0,"Jump: " + keyName4,function(e) {
		});
		b5.pressedAction = function(e) {
			remapFunc("Jump",function(key) {
				src_Settings.controlsSettings.jump = key;
			},b5);
		};
		let keyName5 = hxd_Key.getKeyName(src_Settings.controlsSettings.blast);
		if(keyName5 == "MouseLeft") {
			keyName5 = "Left Mouse";
		}
		if(keyName5 == "MouseRight") {
			keyName5 = "Right Mouse";
		}
		if(keyName5 == "MouseMiddle") {
			keyName5 = "Middle Mouse";
		}
		if(keyName5 == "Space") {
			keyName5 = "Space Bar";
		}
		let b6 = this.btnListRight.addButton(0,"Blast: " + keyName5,function(e) {
		});
		b6.pressedAction = function(e) {
			remapFunc("Blast",function(key) {
				src_Settings.controlsSettings.blast = key;
			},b6);
		};
		let keyName6 = hxd_Key.getKeyName(src_Settings.controlsSettings.camForward);
		if(keyName6 == "MouseLeft") {
			keyName6 = "Left Mouse";
		}
		if(keyName6 == "MouseRight") {
			keyName6 = "Right Mouse";
		}
		if(keyName6 == "MouseMiddle") {
			keyName6 = "Middle Mouse";
		}
		if(keyName6 == "Space") {
			keyName6 = "Space Bar";
		}
		let b7 = this.btnListLeft.addButton(0,"Look Up: " + keyName6,function(e) {
		});
		b7.pressedAction = function(e) {
			remapFunc("Look Up",function(key) {
				src_Settings.controlsSettings.camForward = key;
			},b7);
		};
		let keyName7 = hxd_Key.getKeyName(src_Settings.controlsSettings.camBackward);
		if(keyName7 == "MouseLeft") {
			keyName7 = "Left Mouse";
		}
		if(keyName7 == "MouseRight") {
			keyName7 = "Right Mouse";
		}
		if(keyName7 == "MouseMiddle") {
			keyName7 = "Middle Mouse";
		}
		if(keyName7 == "Space") {
			keyName7 = "Space Bar";
		}
		let b8 = this.btnListLeft.addButton(0,"Look Down: " + keyName7,function(e) {
		});
		b8.pressedAction = function(e) {
			remapFunc("Look Down",function(key) {
				src_Settings.controlsSettings.camBackward = key;
			},b8);
		};
		let keyName8 = hxd_Key.getKeyName(src_Settings.controlsSettings.camLeft);
		if(keyName8 == "MouseLeft") {
			keyName8 = "Left Mouse";
		}
		if(keyName8 == "MouseRight") {
			keyName8 = "Right Mouse";
		}
		if(keyName8 == "MouseMiddle") {
			keyName8 = "Middle Mouse";
		}
		if(keyName8 == "Space") {
			keyName8 = "Space Bar";
		}
		let b9 = this.btnListLeft.addButton(0,"Look Left: " + keyName8,function(e) {
		});
		b9.pressedAction = function(e) {
			remapFunc("Look Left",function(key) {
				src_Settings.controlsSettings.camLeft = key;
			},b9);
		};
		let keyName9 = hxd_Key.getKeyName(src_Settings.controlsSettings.camRight);
		if(keyName9 == "MouseLeft") {
			keyName9 = "Left Mouse";
		}
		if(keyName9 == "MouseRight") {
			keyName9 = "Right Mouse";
		}
		if(keyName9 == "MouseMiddle") {
			keyName9 = "Middle Mouse";
		}
		if(keyName9 == "Space") {
			keyName9 = "Space Bar";
		}
		let b10 = this.btnListLeft.addButton(0,"Look Right: " + keyName9,function(e) {
		});
		b10.pressedAction = function(e) {
			remapFunc("Look Right",function(key) {
				src_Settings.controlsSettings.camRight = key;
			},b10);
		};
		let keyName10 = hxd_Key.getKeyName(src_Settings.controlsSettings.powerup);
		if(keyName10 == "MouseLeft") {
			keyName10 = "Left Mouse";
		}
		if(keyName10 == "MouseRight") {
			keyName10 = "Right Mouse";
		}
		if(keyName10 == "MouseMiddle") {
			keyName10 = "Middle Mouse";
		}
		if(keyName10 == "Space") {
			keyName10 = "Space Bar";
		}
		let b11 = this.btnListLeft.addButton(0,"Use Powerup: " + keyName10,function(e) {
		});
		b11.pressedAction = function(e) {
			remapFunc("Use Powerup",function(key) {
				src_Settings.controlsSettings.powerup = key;
			},b11);
		};
		let keyName11 = hxd_Key.getKeyName(src_Settings.controlsSettings.rewind);
		if(keyName11 == "MouseLeft") {
			keyName11 = "Left Mouse";
		}
		if(keyName11 == "MouseRight") {
			keyName11 = "Right Mouse";
		}
		if(keyName11 == "MouseMiddle") {
			keyName11 = "Middle Mouse";
		}
		if(keyName11 == "Space") {
			keyName11 = "Space Bar";
		}
		let b12 = this.btnListLeft.addButton(0,"Rewind: " + keyName11,function(e) {
		});
		b12.pressedAction = function(e) {
			remapFunc("Rewind",function(key) {
				src_Settings.controlsSettings.rewind = key;
			},b12);
		};
		let keyName12 = hxd_Key.getKeyName(src_Settings.controlsSettings.chat);
		if(keyName12 == "MouseLeft") {
			keyName12 = "Left Mouse";
		}
		if(keyName12 == "MouseRight") {
			keyName12 = "Right Mouse";
		}
		if(keyName12 == "MouseMiddle") {
			keyName12 = "Middle Mouse";
		}
		if(keyName12 == "Space") {
			keyName12 = "Space Bar";
		}
		let b13 = this.btnListLeft.addButton(0,"Chat: " + keyName12,function(e) {
		});
		b13.pressedAction = function(e) {
			remapFunc("Chat",function(key) {
				src_Settings.controlsSettings.chat = key;
			},b13);
		};
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Back",160);
		backButton.position = new h3d_Vector(400,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["B"];
		backButton.accelerators = [27,8];
		let _gthis = this;
		if(pauseGui) {
			backButton.pressedAction = function(e) {
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.canvas.pushDialog(new gui_OptionsListGui(true));
			};
		} else {
			backButton.pressedAction = function(e) {
				src_MarbleGame.canvas.setContent(new gui_OptionsListGui());
			};
		}
		bottomBar.addChild(backButton);
	}
	update(dt,mouseState) {
		super.update(dt,mouseState);
		let prevSelected = this.selectedColumn;
		if(hxd_Key.isPressed(39) || src_Gamepad.isPressed(["dpadRight"])) {
			this.selectedColumn++;
		}
		if(hxd_Key.isPressed(37) || src_Gamepad.isPressed(["dpadLeft"])) {
			this.selectedColumn++;
		}
		if(this.selectedColumn < 0) {
			this.selectedColumn = 1;
		}
		if(this.selectedColumn > 1) {
			this.selectedColumn = 0;
		}
		if(this.selectedColumn == 1) {
			this.btnListLeft.active = true;
			this.btnListRight.active = false;
		} else {
			this.btnListLeft.active = false;
			this.btnListRight.active = true;
		}
		if(prevSelected == 0 && this.selectedColumn == 1) {
			this.btnListLeft.selected = this.btnListRight.selected;
		}
		if(prevSelected == 1 && this.selectedColumn == 0) {
			this.btnListRight.selected = this.btnListLeft.selected;
			if(this.btnListRight.selected > this.btnListRight.buttons.length - 1) {
				this.btnListRight.selected = this.btnListRight.buttons.length - 1;
			}
		}
		let tmp;
		if(this._prevMousePosition != null) {
			let _this = this._prevMousePosition;
			let v = mouseState.position;
			tmp = !(_this.x == v.x && _this.y == v.y && _this.z == v.z && _this.w == v.w);
		} else {
			tmp = true;
		}
		if(tmp) {
			let _g = 0;
			let _g1 = this.btnListLeft.buttons.length;
			while(_g < _g1) {
				let i = _g++;
				let btn = this.btnListLeft.buttons[i];
				let renderRect = btn.getHitTestRect();
				let _this = renderRect.position;
				let v_x = 24;
				let v_y = 20;
				renderRect.position = new h3d_Vector(_this.x + v_x,_this.y + v_y,_this.z,_this.w + 1.);
				let _this1 = renderRect.extent;
				_this1.x = 439;
				_this1.y = 53;
				_this1.z = 0.;
				_this1.w = 1.;
				if(renderRect.inRect(mouseState.position)) {
					this.selectedColumn = 1;
					this.btnListLeft.selected = i;
					this.btnListLeft.active = true;
					this.btnListRight.active = false;
					break;
				}
			}
			let _g2 = 0;
			let _g3 = this.btnListRight.buttons.length;
			while(_g2 < _g3) {
				let i = _g2++;
				let btn = this.btnListRight.buttons[i];
				let renderRect = btn.getHitTestRect();
				let _this = renderRect.position;
				let v_x = 24;
				let v_y = 20;
				renderRect.position = new h3d_Vector(_this.x + v_x,_this.y + v_y,_this.z,_this.w + 1.);
				let _this1 = renderRect.extent;
				_this1.x = 439;
				_this1.y = 53;
				_this1.z = 0.;
				_this1.w = 1.;
				if(renderRect.inRect(mouseState.position)) {
					this.selectedColumn = 0;
					this.btnListRight.selected = i;
					this.btnListRight.active = true;
					this.btnListLeft.active = false;
					break;
				}
			}
			let _this = mouseState.position;
			this._prevMousePosition = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
		}
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.btnListLeft.position = new h3d_Vector(70 - offsetX,135);
		this.btnListLeft.position = new h3d_Vector(-400 - offsetX,135);
		super.onResize(width,height);
	}
}
$hxClasses["gui.KeyBindingsGui"] = gui_KeyBindingsGui;
gui_KeyBindingsGui.__name__ = "gui.KeyBindingsGui";
gui_KeyBindingsGui.__super__ = gui_GuiImage;
Object.assign(gui_KeyBindingsGui.prototype, {
	__class__: gui_KeyBindingsGui
	,innerCtrl: null
	,btnListLeft: null
	,btnListRight: null
	,selectedColumn: null
	,_prevMousePosition: null
});
class gui_LeaderboardsGui extends gui_GuiImage {
	constructor(index,levelSelectDifficulty,levelSelectGui) {
		if(levelSelectGui == null) {
			levelSelectGui = false;
		}
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("LEADERBOARDS");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let levelTitle = new gui_GuiText(coliseum);
		levelTitle.position = new h3d_Vector(-100,30);
		levelTitle.extent = new h3d_Vector(1120,80);
		levelTitle.text.set_textColor(16777215);
		levelTitle.text.set_text("Level 1");
		levelTitle.text.set_textAlign(h2d_Align.Right);
		levelTitle.justify = gui_Justification.Right;
		levelTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(levelTitle);
		let scoreWnd = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/helpWindow.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		scoreWnd.horizSizing = gui_HorizSizing.Right;
		scoreWnd.vertSizing = gui_VertSizing.Bottom;
		scoreWnd.position = new h3d_Vector(260,107);
		scoreWnd.extent = new h3d_Vector(736,325);
		this.innerCtrl.addChild(scoreWnd);
		let _gthis = this;
		let imgLoader = function(path) {
			let t;
			switch(path) {
			case "android":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_android_white.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "mac":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_mac_white.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "notready":
				t = src_ResourceLoader.getResource("data/ui/xbox/NotReady.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "pc":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_desktop_white.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "ready":
				t = src_ResourceLoader.getResource("data/ui/xbox/Ready.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "rewind":
				t = src_ResourceLoader.getResource("data/ui/xbox/rewind_ico.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "unknown":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_unknown_white.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "web":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_web_white.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			default:
				return null;
			}
			if(t != null) {
				t.scaleToSize(t.width * src_Settings.uiScale,t.height * src_Settings.uiScale);
			}
			return t;
		};
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		let arial12 = arial14b.toSdfFont(16 * src_Settings.uiScale,4);
		let mlFontLoader = function(text) {
			switch(text) {
			case "arial12":
				return arial12;
			case "arial14":
				return arial14;
			}
			return null;
		};
		let headerText = "<font face=\"arial12\">Rank<offset value=\"50\">Name</offset><offset value=\"500\">Score</offset><offset value=\"600\">Platform</offset></font>";
		let scoreCtrl = new gui_GuiMLText(arial14,mlFontLoader);
		scoreCtrl.position = new h3d_Vector(30,20);
		scoreCtrl.extent = new h3d_Vector(706,305);
		scoreCtrl.text.set_imageVerticalAlign(gui_ImageVerticalAlign.Top);
		scoreCtrl.text.loadImage = imgLoader;
		scoreCtrl.text.set_text(headerText + "<br/><br/><br/><br/><br/>" + "<p align=\"center\">Loading...</p>");
		scoreWnd.addChild(scoreCtrl);
		let allMissions = src_MissionList.missionList.h["ultra"].h["advanced"];
		let allMissions1 = src_MissionList.missionList.h["ultra"].h["multiplayer"];
		let allMissions2 = src_MissionList.missionList.h["ultra"].h["beginner"].concat(src_MissionList.missionList.h["ultra"].h["intermediate"]).concat(allMissions).concat(allMissions1);
		let actualIndex = allMissions2.indexOf(src_MissionList.missionList.h["ultra"].h[levelSelectDifficulty][index]);
		levelTitle.text.set_text("Level " + (actualIndex + 1));
		let result = new Array(allMissions2.length);
		let _g = 0;
		let _g1 = allMissions2.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = allMissions2[i].title;
		}
		let scoreCategories = ["Overall","Rewind","Non-Rewind"];
		let scoreView = 0;
		let currentMission = allMissions2[actualIndex];
		let scoreTok = 0;
		let fetchScores = function() {
			scoreTok += 1;
			let ourToken = scoreTok - 1;
			src_Leaderboards.getScores(currentMission.path,scoreView,function(scoreList) {
				if(ourToken + 1 != scoreTok) {
					return;
				}
				let scoreTexts = [];
				let i = 1;
				let isHuntScore = currentMission.difficultyIndex == 3;
				let _g = 0;
				while(_g < scoreList.length) {
					let score = scoreList[_g];
					++_g;
					let scoreText = "<offset value=\"10\">" + i + ". </offset>\n\t\t\t\t\t<offset value=\"50\">" + score.name + "</offset>\n\t\t\t\t\t<offset value=\"475\">" + (score.rewind > 0 ? "<img src='rewind'/>" : "") + "</offset>\n\t\t\t\t\t<offset value=\"500\">" + (isHuntScore ? Std.string(1000 - score.score) : src_Util.formatTime(score.score)) + "</offset>\n\t\t\t\t\t<offset value=\"625\"><img src=\"";
					let scoreText1;
					switch(score.platform) {
					case 0:
						scoreText1 = "unknown";
						break;
					case 1:
						scoreText1 = "pc";
						break;
					case 2:
						scoreText1 = "mac";
						break;
					case 3:
						scoreText1 = "web";
						break;
					case 4:
						scoreText1 = "android";
						break;
					}
					let scoreText2 = scoreText + scoreText1 + "\"/></offset>";
					scoreTexts.push(scoreText2);
					++i;
				}
				while(i <= 10) {
					let scoreText = "<offset value=\"10\">" + i + ". </offset><offset value=\"50\">Nardo Polo</offset><offset value=\"500\">99:59.99</offset><offset value=\"625\"><img src=\"unknown\"/></offset>";
					scoreTexts.push(scoreText);
					++i;
				}
				scoreCtrl.text.set_text(headerText + "<br/>" + scoreTexts.join("<br/>"));
			});
			scoreCtrl.text.set_text(headerText + "<br/><br/><br/><br/><br/>" + "<p align=\"center\">Loading...</p>");
		};
		let levelSelectOpts = new gui_GuiXboxOptionsList(2,"Overall",result);
		levelSelectOpts.position = new h3d_Vector(380,485);
		levelSelectOpts.extent = new h3d_Vector(815,94);
		levelSelectOpts.vertSizing = gui_VertSizing.Bottom;
		levelSelectOpts.horizSizing = gui_HorizSizing.Right;
		levelSelectOpts.alwaysActive = true;
		levelSelectOpts.onChangeFunc = function(l) {
			levelTitle.text.set_text("Level " + (l + 1));
			currentMission = allMissions2[l];
			fetchScores();
			return true;
		};
		levelSelectOpts.setCurrentOption(actualIndex);
		this.innerCtrl.addChild(levelSelectOpts);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Back",160);
		backButton.position = new h3d_Vector(400,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["B"];
		backButton.accelerators = [27,8];
		if(levelSelectGui) {
			backButton.pressedAction = function(e) {
				src_MarbleGame.canvas.setContent(new gui_LevelSelectGui(levelSelectDifficulty));
			};
		} else {
			backButton.pressedAction = function(e) {
				src_MarbleGame.canvas.setContent(new gui_MainMenuGui());
			};
		}
		bottomBar.addChild(backButton);
		let changeViewButton = new gui_GuiXboxButton("Change View",200);
		changeViewButton.position = new h3d_Vector(560,0);
		changeViewButton.vertSizing = gui_VertSizing.Bottom;
		changeViewButton.horizSizing = gui_HorizSizing.Right;
		changeViewButton.gamepadAccelerator = ["X"];
		changeViewButton.pressedAction = function(e) {
			scoreView = scoreView == 0 ? 1 : scoreView == 1 ? 2 : 0;
			levelSelectOpts.labelText.text.set_text(scoreCategories[js_Boot.__cast(scoreView , Int)]);
			fetchScores();
		};
		bottomBar.addChild(changeViewButton);
		let replayButton = new gui_GuiXboxButton("Watch Replay",220);
		replayButton.position = new h3d_Vector(750,0);
		replayButton.vertSizing = gui_VertSizing.Bottom;
		replayButton.gamepadAccelerator = ["Y"];
		replayButton.horizSizing = gui_HorizSizing.Right;
		replayButton.pressedAction = function(e) {
			src_Leaderboards.watchTopReplay(currentMission.path,scoreView,function(b) {
				if(b != null) {
					let replayF = new src_Replay("");
					if(replayF.read(b)) {
						let repmis = replayF.mission;
						if(repmis.startsWith("data/")) {
							repmis = HxOverrides.substr(repmis,5,null);
						}
						let mi = src_MissionList.missions.h[repmis];
						if(mi == null) {
							if(!repmis.includes("data/")) {
								repmis = "data/" + repmis;
							}
							mi = src_MissionList.missions.h[repmis];
						}
						src_MarbleGame.instance.watchMissionReplay(mi,replayF,gui_DifficultySelectGui);
					} else {
						src_MarbleGame.canvas.pushDialog(new gui_MessageBoxOkDlg("Could not load replay for this level."));
					}
				} else {
					src_MarbleGame.canvas.pushDialog(new gui_MessageBoxOkDlg("No top replay found for this level."));
				}
			});
		};
		bottomBar.addChild(replayButton);
		fetchScores();
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.LeaderboardsGui"] = gui_LeaderboardsGui;
gui_LeaderboardsGui.__name__ = "gui.LeaderboardsGui";
gui_LeaderboardsGui.__super__ = gui_GuiImage;
Object.assign(gui_LeaderboardsGui.prototype, {
	__class__: gui_LeaderboardsGui
	,innerCtrl: null
});
class gui_LevelSelectGui extends gui_GuiImage {
	constructor(difficulty) {
		let res = src_ResourceLoader.getImage("data/ui/game/CloudBG.jpg").resource.toTile();
		super(res);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		let mlFontLoader = function(text) {
			return arial14;
		};
		src_MarbleGame.instance.toRecord = false;
		let fadeEdge = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/BG_fadeOutSoftEdge.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		fadeEdge.position = new h3d_Vector(0,0);
		fadeEdge.extent = new h3d_Vector(640,480);
		fadeEdge.vertSizing = gui_VertSizing.Height;
		fadeEdge.horizSizing = gui_HorizSizing.Width;
		this.addChild(fadeEdge);
		let loadAnim = new gui_GuiLoadAnim();
		loadAnim.position = new h3d_Vector(610,253);
		loadAnim.extent = new h3d_Vector(63,63);
		loadAnim.horizSizing = gui_HorizSizing.Center;
		loadAnim.vertSizing = gui_VertSizing.Bottom;
		this.addChild(loadAnim);
		let loadTextBg = new gui_GuiText(arial14);
		loadTextBg.position = new h3d_Vector(608,335);
		loadTextBg.extent = new h3d_Vector(63,40);
		loadTextBg.horizSizing = gui_HorizSizing.Center;
		loadTextBg.vertSizing = gui_VertSizing.Bottom;
		loadTextBg.justify = gui_Justification.Center;
		loadTextBg.text.set_text("Loading");
		loadTextBg.text.set_textColor(0);
		this.addChild(loadTextBg);
		let loadText = new gui_GuiText(arial14);
		loadText.position = new h3d_Vector(610,334);
		loadText.extent = new h3d_Vector(63,40);
		loadText.horizSizing = gui_HorizSizing.Center;
		loadText.vertSizing = gui_VertSizing.Bottom;
		loadText.justify = gui_Justification.Center;
		loadText.text.set_text("Loading");
		this.addChild(loadText);
		if(gui_LevelSelectGui.currentDifficultyStatic != difficulty) {
			gui_LevelSelectGui.currentSelectionStatic = 0;
		}
		gui_LevelSelectGui.currentDifficultyStatic = difficulty;
		let difficultyMissions = src_MissionList.missionList.h["ultra"].h[gui_LevelSelectGui.currentDifficultyStatic];
		if(gui_LevelSelectGui.currentSelectionStatic >= difficultyMissions.length) {
			gui_LevelSelectGui.currentSelectionStatic = 0;
		}
		let curMission = difficultyMissions[gui_LevelSelectGui.currentSelectionStatic];
		let lock = true;
		let currentToken = 0;
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("SELECT LEVEL");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Back",160);
		backButton.position = new h3d_Vector(400,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["B"];
		backButton.accelerators = [27,8];
		backButton.pressedAction = function(e) {
			src_MarbleGame.canvas.setContent(new gui_DifficultySelectGui());
		};
		bottomBar.addChild(backButton);
		let recordButton = new gui_GuiXboxButton("Record",200);
		recordButton.position = new h3d_Vector(560,0);
		recordButton.vertSizing = gui_VertSizing.Bottom;
		recordButton.horizSizing = gui_HorizSizing.Right;
		recordButton.gamepadAccelerator = ["X"];
		recordButton.pressedAction = function(e) {
			src_MarbleGame.instance.toRecord = true;
			src_MarbleGame.canvas.pushDialog(new gui_MessageBoxOkDlg("The next mission you play will be recorded."));
		};
		bottomBar.addChild(recordButton);
		let lbButton = new gui_GuiXboxButton("Leaderboard",220);
		lbButton.position = new h3d_Vector(750,0);
		lbButton.vertSizing = gui_VertSizing.Bottom;
		lbButton.gamepadAccelerator = ["Y"];
		lbButton.horizSizing = gui_HorizSizing.Right;
		lbButton.pressedAction = function(e) {
			src_MarbleGame.canvas.setContent(new gui_LeaderboardsGui(gui_LevelSelectGui.currentSelectionStatic,gui_LevelSelectGui.currentDifficultyStatic,true));
		};
		bottomBar.addChild(lbButton);
		let nextButton = new gui_GuiXboxButton("Play",160);
		nextButton.position = new h3d_Vector(960,0);
		nextButton.vertSizing = gui_VertSizing.Bottom;
		nextButton.horizSizing = gui_HorizSizing.Right;
		nextButton.gamepadAccelerator = ["A"];
		nextButton.accelerators = [13];
		nextButton.pressedAction = function(e) {
			src_MarbleGame.instance.playMission(curMission);
		};
		bottomBar.addChild(nextButton);
		let levelWnd = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/levelPreviewWindow.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		levelWnd.position = new h3d_Vector(555,469);
		levelWnd.extent = new h3d_Vector(535,137);
		levelWnd.vertSizing = gui_VertSizing.Bottom;
		levelWnd.horizSizing = gui_HorizSizing.Right;
		this.innerCtrl.addChild(levelWnd);
		let statIcon = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/statIcon.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		statIcon.position = new h3d_Vector(29,54);
		statIcon.extent = new h3d_Vector(20,20);
		levelWnd.addChild(statIcon);
		let eggIcon = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/eggIcon.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		eggIcon.position = new h3d_Vector(29,79);
		eggIcon.extent = new h3d_Vector(20,20);
		levelWnd.addChild(eggIcon);
		let levelInfoLeft = new gui_GuiMLText(arial14,mlFontLoader);
		levelInfoLeft.position = new h3d_Vector(69,54);
		levelInfoLeft.extent = new h3d_Vector(180,100);
		levelInfoLeft.text.set_text("<p align=\"right\"><font color=\"#EBEBEB\">My Best Time:</font><br/><font color=\"#EBEBEB\">Par Time:</font></p>");
		levelInfoLeft.text.set_lineSpacing(6);
		levelWnd.addChild(levelInfoLeft);
		let levelInfoMid = new gui_GuiMLText(arial14,mlFontLoader);
		levelInfoMid.position = new h3d_Vector(269,54);
		levelInfoMid.extent = new h3d_Vector(180,100);
		levelInfoMid.text.set_text("<p align=\"left\"><font color=\"#EBEBEB\">None</font><br/><font color=\"#88BCEE\">99:59:99</font></p>");
		levelInfoMid.text.set_lineSpacing(6);
		levelWnd.addChild(levelInfoMid);
		let levelInfoRight = new gui_GuiMLText(arial14,mlFontLoader);
		levelInfoRight.position = new h3d_Vector(379,54);
		levelInfoRight.extent = new h3d_Vector(180,100);
		levelInfoRight.text.set_text("<p align=\"left\"><font color=\"#EBEBEB\">Level 1<br/>Difficulty 1</font></p>");
		levelInfoRight.text.set_lineSpacing(6);
		levelWnd.addChild(levelInfoRight);
		let _gthis = this;
		let setLevel = function(idx) {
			_gthis.bmp.set_visible(true);
			loadAnim.anim.set_visible(true);
			loadText.text.set_visible(true);
			loadTextBg.text.set_visible(true);
			lock = true;
			curMission = difficultyMissions[idx];
			gui_LevelSelectGui.currentSelectionStatic = idx;
			currentToken += 1;
			let misFile = haxe_io_Path.withoutExtension(haxe_io_Path.withoutDirectory(curMission.path));
			let mis = difficultyMissions[idx];
			let requestToken = currentToken;
			if(Object.prototype.hasOwnProperty.call(src_Settings.easterEggs.h,mis.path)) {
				eggIcon.bmp.set_visible(true);
			} else {
				eggIcon.bmp.set_visible(false);
			}
			src_MarbleGame.instance.setPreviewMission(misFile,function() {
				lock = false;
				if(requestToken != currentToken) {
					return;
				}
				_gthis.bmp.set_visible(false);
				loadAnim.anim.set_visible(false);
				loadText.text.set_visible(false);
				loadTextBg.text.set_visible(false);
			});
			let scoreType = mis.missionInfo.gamemode != null && mis.missionInfo.gamemode.toLowerCase() == "scrum" ? modes_ScoreType.Score : modes_ScoreType.Time;
			let myScore = src_Settings.getScores(mis.path);
			let scoreDisp = "None";
			if(myScore.length != 0) {
				if(scoreType == modes_ScoreType.Time) {
					scoreDisp = src_Util.formatTime(myScore[0].time);
				} else {
					let scoreInt = Math.round(myScore[0].time) | 0;
					scoreDisp = "" + scoreInt;
				}
			}
			let isPar = myScore.length != 0 && myScore[0].time < mis.qualifyTime;
			let scoreColor = "#EBEBEB";
			if(isPar) {
				scoreColor = "#8DFF8D";
			}
			if(scoreType == modes_ScoreType.Score && myScore.length == 0) {
				scoreColor = "#EBEBEB";
			}
			if(scoreType == modes_ScoreType.Time) {
				levelInfoLeft.text.set_text("<p align=\"right\"><font color=\"#EBEBEB\">My Best Time:</font><br/><font color=\"#EBEBEB\">Par Time:</font></p>");
				levelInfoMid.text.set_text("<p align=\"left\"><font color=\"" + scoreColor + "\">" + scoreDisp + "</font><br/><font color=\"#88BCEE\">" + src_Util.formatTime(mis.qualifyTime) + "</font></p>");
			}
			if(scoreType == modes_ScoreType.Score) {
				levelInfoLeft.text.set_text("<p align=\"right\"><font color=\"#EBEBEB\">My Best Score:</font></p>");
				levelInfoMid.text.set_text("<p align=\"left\"><font color=\"" + scoreColor + "\">" + scoreDisp + "</font></p>");
			}
			levelInfoRight.text.set_text("<p align=\"left\"><font color=\"#EBEBEB\">Level " + mis.missionInfo.level + "<br/>Difficulty " + (mis.missionInfo.difficulty == null ? "" : mis.missionInfo.difficulty) + "</font></p>");
			return true;
		};
		let result = new Array(difficultyMissions.length);
		let _g = 0;
		let _g1 = difficultyMissions.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = difficultyMissions[i].title;
		}
		let levelSelectOpts = new gui_GuiXboxOptionsList(6,"Level",result);
		levelSelectOpts.position = new h3d_Vector(380,435);
		levelSelectOpts.extent = new h3d_Vector(815,94);
		levelSelectOpts.vertSizing = gui_VertSizing.Bottom;
		levelSelectOpts.horizSizing = gui_HorizSizing.Right;
		levelSelectOpts.alwaysActive = true;
		levelSelectOpts.onChangeFunc = setLevel;
		levelSelectOpts.setCurrentOption(gui_LevelSelectGui.currentSelectionStatic);
		setLevel(gui_LevelSelectGui.currentSelectionStatic);
		this.innerCtrl.addChild(levelSelectOpts);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.LevelSelectGui"] = gui_LevelSelectGui;
gui_LevelSelectGui.__name__ = "gui.LevelSelectGui";
gui_LevelSelectGui.__super__ = gui_GuiImage;
Object.assign(gui_LevelSelectGui.prototype, {
	__class__: gui_LevelSelectGui
	,innerCtrl: null
});
class gui_LoadingGui extends gui_GuiImage {
	constructor(missionName,game) {
		let res = src_ResourceLoader.getImage("data/ui/game/CloudBG.jpg").resource.toTile();
		super(res);
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		let fadeEdge = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/BG_fadeOutSoftEdge.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		fadeEdge.position = new h3d_Vector(0,0);
		fadeEdge.extent = new h3d_Vector(640,480);
		fadeEdge.vertSizing = gui_VertSizing.Height;
		fadeEdge.horizSizing = gui_HorizSizing.Width;
		this.addChild(fadeEdge);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		let loadAnim = new gui_GuiLoadAnim();
		loadAnim.position = new h3d_Vector(610,253);
		loadAnim.extent = new h3d_Vector(63,63);
		loadAnim.horizSizing = gui_HorizSizing.Center;
		loadAnim.vertSizing = gui_VertSizing.Bottom;
		this.addChild(loadAnim);
		let loadTextBg = new gui_GuiText(arial14);
		loadTextBg.position = new h3d_Vector(608,335);
		loadTextBg.extent = new h3d_Vector(63,40);
		loadTextBg.horizSizing = gui_HorizSizing.Center;
		loadTextBg.vertSizing = gui_VertSizing.Bottom;
		loadTextBg.justify = gui_Justification.Center;
		loadTextBg.text.set_text("Loading");
		loadTextBg.text.set_textColor(0);
		this.addChild(loadTextBg);
		let loadText = new gui_GuiText(arial14);
		loadText.position = new h3d_Vector(610,334);
		loadText.extent = new h3d_Vector(63,40);
		loadText.horizSizing = gui_HorizSizing.Center;
		loadText.vertSizing = gui_VertSizing.Bottom;
		loadText.justify = gui_Justification.Center;
		loadText.text.set_text("Loading");
		this.addChild(loadText);
	}
}
$hxClasses["gui.LoadingGui"] = gui_LoadingGui;
gui_LoadingGui.__name__ = "gui.LoadingGui";
gui_LoadingGui.__super__ = gui_GuiImage;
Object.assign(gui_LoadingGui.prototype, {
	__class__: gui_LoadingGui
});
class gui_MPServerListGui extends gui_GuiImage {
	constructor() {
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		this.serverWnd = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/helpWindow.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		this.serverWnd.horizSizing = gui_HorizSizing.Right;
		this.serverWnd.vertSizing = gui_VertSizing.Bottom;
		this.serverWnd.position = new h3d_Vector(260,107);
		this.serverWnd.extent = new h3d_Vector(736,460);
		this.innerCtrl.addChild(this.serverWnd);
		let _gthis = this;
		let imgLoader = function(path) {
			let t;
			switch(path) {
			case "android":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_android_white.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "mac":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_mac_white.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "notready":
				t = src_ResourceLoader.getResource("data/ui/xbox/NotReady.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "pc":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_desktop_white.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "ready":
				t = src_ResourceLoader.getResource("data/ui/xbox/Ready.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "unknown":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_unknown_white.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "web":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_web_white.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			default:
				return null;
			}
			if(t != null) {
				t.scaleToSize(t.width * src_Settings.uiScale,t.height * src_Settings.uiScale);
			}
			return t;
		};
		let curSelection = -1;
		let serverDisplays = [];
		let serverList = new gui_GuiMLTextListCtrl(arial14,serverDisplays,imgLoader);
		serverList.selectedColor = 15897877;
		serverList.selectedFillColor = 8750469;
		serverList.position = new h3d_Vector(25,22);
		serverList.extent = new h3d_Vector(680,480);
		serverList.scrollable = true;
		serverList.onSelectedFunc = function(sel) {
			curSelection = sel;
		};
		this.serverWnd.addChild(serverList);
		let ourServerList = [];
		let platformToString = ["unknown","pc","mac","web","android"];
		let updateServerListDisplay = function() {
			let result = new Array(ourServerList.length);
			let _g = 0;
			let _g1 = ourServerList.length;
			while(_g < _g1) {
				let i = _g++;
				let x = ourServerList[i];
				result[i] = "<img src=\"" + platformToString[x.platform] + "\"></img><font color=\"#FFFFFF\">" + x.players + "/" + x.maxPlayers + "  " + x.name + "</font>";
			}
			serverDisplays = result;
			serverList.setTexts(serverDisplays);
		};
		let serverListStatusText = new gui_GuiText(arial14);
		serverListStatusText.text.set_text("Searching for matches...");
		serverListStatusText.justify = gui_Justification.Center;
		serverListStatusText.horizSizing = gui_HorizSizing.Center;
		serverListStatusText.vertSizing = gui_VertSizing.Center;
		serverListStatusText.position = new h3d_Vector();
		serverListStatusText.extent = new h3d_Vector(100,30);
		serverList.addChild(serverListStatusText);
		net_MasterServerClient.connectToMasterServer(function() {
			net_MasterServerClient.instance.getServerList(function(servers) {
				ourServerList = servers;
				updateServerListDisplay();
				if(ourServerList.length == 0) {
					serverListStatusText.text.set_visible(true);
					serverListStatusText.text.set_text("No matches found, you should start a match for others.");
				} else {
					serverListStatusText.text.set_visible(false);
				}
			});
		});
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Back",160);
		backButton.position = new h3d_Vector(400,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["B"];
		backButton.accelerators = [27,8];
		backButton.pressedAction = function(e) {
			src_MarbleGame.canvas.setContent(new gui_MainMenuGui());
		};
		bottomBar.addChild(backButton);
		let refreshing = false;
		let refreshButton = new gui_GuiXboxButton("Refresh",220);
		refreshButton.position = new h3d_Vector(750,0);
		refreshButton.vertSizing = gui_VertSizing.Bottom;
		refreshButton.horizSizing = gui_HorizSizing.Right;
		refreshButton.pressedAction = function(e) {
			if(refreshing) {
				return;
			}
			refreshing = true;
			serverListStatusText.text.set_visible(true);
			serverListStatusText.text.set_text("Searching for matches...");
			net_MasterServerClient.connectToMasterServer(function() {
				net_MasterServerClient.instance.getServerList(function(servers) {
					ourServerList = servers;
					updateServerListDisplay();
					refreshing = false;
					if(ourServerList.length == 0) {
						serverListStatusText.text.set_visible(true);
						serverListStatusText.text.set_text("No matches found, you should start a match for others.");
					} else {
						serverListStatusText.text.set_visible(false);
					}
				});
			},function() {
				refreshing = false;
				serverListStatusText.text.set_visible(true);
				serverListStatusText.text.set_text("Failed to connect to master server.");
			});
		};
		bottomBar.addChild(refreshButton);
		let nextButton = new gui_GuiXboxButton("Join",160);
		nextButton.position = new h3d_Vector(960,0);
		nextButton.vertSizing = gui_VertSizing.Bottom;
		nextButton.horizSizing = gui_HorizSizing.Right;
		nextButton.accelerators = [13];
		nextButton.gamepadAccelerator = ["X"];
		nextButton.pressedAction = function(e) {
			if(curSelection != -1) {
				let selectedServerVersion = ourServerList[curSelection].version;
				if(selectedServerVersion != src_MarbleGame.currentVersion) {
					let pup = new gui_MessageBoxOkDlg("You are using a different version of the game than the server. Please update your game.");
					src_MarbleGame.canvas.pushDialog(pup);
					return;
				}
				src_MarbleGame.canvas.setContent(new gui_MultiplayerLoadingGui("Connecting"));
				let failed = true;
				haxe_Timer.delay(function() {
					if(failed) {
						if(((src_MarbleGame.canvas.content) instanceof gui_MultiplayerLoadingGui)) {
							let loadGui = src_MarbleGame.canvas.content;
							if(loadGui != null) {
								loadGui.setErrorStatus("Failed to connect to server. Please try again.");
								net_Net.disconnect();
							}
						}
					}
				},15000);
				net_Net.joinServer(ourServerList[curSelection].name,false,function() {
					failed = false;
					net_Net.remoteServerInfo = ourServerList[curSelection];
				});
			}
		};
		bottomBar.addChild(nextButton);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.MPServerListGui"] = gui_MPServerListGui;
gui_MPServerListGui.__name__ = "gui.MPServerListGui";
gui_MPServerListGui.__super__ = gui_GuiImage;
Object.assign(gui_MPServerListGui.prototype, {
	__class__: gui_MPServerListGui
	,innerCtrl: null
	,serverWnd: null
});
class gui_MainMenuGui extends gui_GuiImage {
	constructor() {
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		let domcasual32 = domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		src_MarbleGame.instance.toRecord = false;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let logo = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/logo.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		logo.position = new h3d_Vector(200,50);
		logo.extent = new h3d_Vector(512,400);
		this.innerCtrl.addChild(logo);
		let glogo = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/g.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		glogo.position = new h3d_Vector(240,536);
		glogo.extent = new h3d_Vector(128,128);
		this.innerCtrl.addChild(glogo);
		this.btnList = new gui_GuiXboxList();
		this.btnList.position = new h3d_Vector(70 - offsetX,95);
		this.btnList.horizSizing = gui_HorizSizing.Left;
		this.btnList.extent = new h3d_Vector(502,530);
		this.innerCtrl.addChild(this.btnList);
		let _gthis = this;
		this.btnList.addButton(0,"Single Player Game",function(sender) {
			(js_Boot.__cast(_gthis.parent , gui_Canvas)).setContent(new gui_DifficultySelectGui());
		});
		this.btnList.addButton(0,"Multiplayer Game",function(sender) {
			if(MPCustoms.missionList.length == 0) {
				(js_Boot.__cast(_gthis.parent , gui_Canvas)).pushDialog(new gui_MessageBoxOkDlg("Custom levels not loaded yet, please wait."));
				MPCustoms.loadMissionList();
			} else if(StringTools.trim(src_Settings.highscoreName) == "" || src_Settings.highscoreName == "Player" || src_Settings.highscoreName == "Player Name") {
				src_MarbleGame.canvas.setContent(new gui_EnterNameDlg());
			} else {
				(js_Boot.__cast(_gthis.parent , gui_Canvas)).setContent(new gui_MultiplayerGui());
			}
		});
		this.btnList.addButton(2,"Leaderboards",function(e) {
			(js_Boot.__cast(_gthis.parent , gui_Canvas)).setContent(new gui_LeaderboardsGui(0,"beginner",false));
		},20);
		this.btnList.addButton(2,"Achievements",function(e) {
			(js_Boot.__cast(_gthis.parent , gui_Canvas)).setContent(new gui_AchievementsGui());
		});
		this.btnList.addButton(3,"Replays",function(sender) {
			hxd_File.browse(function(replayToLoad) {
				replayToLoad.load(function(replayData) {
					let replay = new src_Replay("");
					if(!replay.read(replayData)) {
						(js_Boot.__cast(_gthis.parent , gui_Canvas)).pushDialog(new gui_MessageBoxOkDlg("Cannot load replay."));
					} else {
						let repmis = replay.mission;
						repmis = StringTools.replace(repmis,"data/","");
						if(src_MissionList.missions == null) {
							src_MissionList.buildMissionList();
						}
						let mi = replay.customId == 0 ? src_MissionList.missions.h[repmis] : src_Marbleland.missions.h[replay.customId];
						if(mi.isClaMission) {
							mi.download(function() {
								src_MarbleGame.instance.watchMissionReplay(mi,replay,gui_MainMenuGui);
							});
						} else if(mi != null) {
							(js_Boot.__cast(_gthis.parent , gui_Canvas)).marbleGame.watchMissionReplay(mi,replay,gui_MainMenuGui);
						} else {
							(js_Boot.__cast(_gthis.parent , gui_Canvas)).pushDialog(new gui_MessageBoxOkDlg("Cannot load replay."));
						}
					}
				});
			},{ title : "Select replay file", fileTypes : [{ name : "Replay (*.mbr)", extensions : ["mbr"]}]});
		});
		this.btnList.addButton(3,"Help & Options",function(sender) {
			(js_Boot.__cast(_gthis.parent , gui_Canvas)).setContent(new gui_OptionsListGui());
		});
		this.btnList.addButton(2,"Changelog",function(sender) {
			src_MarbleGame.canvas.setContent(new gui_VersionGui());
		});
		this.btnList.addButton(4,"Download",function(sender) {
			window.open("https://github.com/RandomityGuy/MBHaxe");
		});
		let loadButtonImages = function(path) {
			let normal = src_ResourceLoader.getResource("" + path + "_n.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
			let hover = src_ResourceLoader.getResource("" + path + "_h.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
			let pressed = src_ResourceLoader.getResource("" + path + "_d.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
			return [normal,hover,pressed];
		};
		let versionText = new gui_GuiMLText(domcasual32,null);
		versionText.horizSizing = gui_HorizSizing.Left;
		versionText.vertSizing = gui_VertSizing.Bottom;
		versionText.position = new h3d_Vector(502,61);
		versionText.extent = new h3d_Vector(97,72);
		versionText.text.set_text("<p align=\"center\">" + src_MarbleGame.currentVersion + "</p>");
		versionText.text.set_filter(new h2d_filter_DropShadow(1.414,0.785,858993535,1,0,0.7,1,true));
		this.addChild(versionText);
		let kofi = new gui_GuiButton(loadButtonImages("data/ui/kofi1"));
		kofi.horizSizing = gui_HorizSizing.Left;
		kofi.vertSizing = gui_VertSizing.Top;
		kofi.position = new h3d_Vector(473,424);
		kofi.extent = new h3d_Vector(143,36);
		kofi.pressedAction = function(sender) {
			window.open("https://ko-fi.com/H2H5FRTTL");
		};
		this.addChild(kofi);
		let github = new gui_GuiButton(loadButtonImages("data/ui/github"));
		github.horizSizing = gui_HorizSizing.Left;
		github.vertSizing = gui_VertSizing.Top;
		github.position = new h3d_Vector(522,380);
		github.extent = new h3d_Vector(94,38);
		github.pressedAction = function(sender) {
			window.open("https://github.com/RandomityGuy/MBHaxe");
		};
		this.addChild(github);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.btnList.position = new h3d_Vector(70 - offsetX,95);
		super.onResize(width,height);
	}
}
$hxClasses["gui.MainMenuGui"] = gui_MainMenuGui;
gui_MainMenuGui.__name__ = "gui.MainMenuGui";
gui_MainMenuGui.__super__ = gui_GuiImage;
Object.assign(gui_MainMenuGui.prototype, {
	__class__: gui_MainMenuGui
	,innerCtrl: null
	,btnList: null
});
class gui_MarblePickerGui extends gui_GuiImage {
	constructor() {
		let res = src_ResourceLoader.getImage("data/ui/game/CloudBG.jpg").resource.toTile();
		super(res);
		let fadeEdge = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/BG_fadeOutSoftEdge.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		fadeEdge.position = new h3d_Vector(0,0);
		fadeEdge.extent = new h3d_Vector(640,480);
		fadeEdge.vertSizing = gui_VertSizing.Height;
		fadeEdge.horizSizing = gui_HorizSizing.Width;
		this.addChild(fadeEdge);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("SELECT MARBLE APPEARANCE");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let myMarb = null;
		let prevPreview = src_MarbleGame.instance.previewWorld.currentMission;
		let _gthis = this;
		src_MarbleGame.instance.setPreviewMission("marblepicker",function() {
			_gthis.bmp.set_visible(false);
			src_MarbleGame.instance.previewWorld.spawnMarble(function(marb) {
				let _this = src_MarbleGame.instance.scene.camera.pos;
				let v_x = 0;
				let v_y = 1;
				let v_z = 1;
				let x = _this.x + v_x;
				let y = _this.y + v_y;
				let z = _this.z + v_z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let spawnPos_x = x;
				let spawnPos_y = y;
				let spawnPos_z = z;
				let velAdd = new h3d_Vector((1 - 2 * Math.random()) * 2,(1 - 2 * Math.random()) * 1.5,1 - 2 * Math.random());
				let v_x1 = 0;
				let v_y1 = 3;
				let v_z1 = 0;
				velAdd = new h3d_Vector(velAdd.x + v_x1,velAdd.y + v_y1,velAdd.z + v_z1,velAdd.w + 1.);
				marb.setMarblePosition(spawnPos_x,spawnPos_y,spawnPos_z);
				let _this1 = marb.velocity;
				_this1.x = velAdd.x;
				_this1.y = velAdd.y;
				_this1.z = velAdd.z;
				_this1.w = velAdd.w;
				myMarb = marb;
			});
		},true);
		let _this = gui_MarblePickerGui.marbleData;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _this[i].name;
		}
		let mbOpt = new gui_GuiXboxOptionsList(1,"Marble Type",result,0.5,118);
		mbOpt.vertSizing = gui_VertSizing.Bottom;
		mbOpt.horizSizing = gui_HorizSizing.Right;
		mbOpt.alwaysActive = true;
		mbOpt.position = new h3d_Vector(380,160);
		mbOpt.extent = new h3d_Vector(815,94);
		mbOpt.setCurrentOption(src_Settings.optionsSettings.marbleIndex);
		let curToken = 0;
		mbOpt.onChangeFunc = function(idx) {
			let selectedMarble = gui_MarblePickerGui.marbleData[idx];
			src_Settings.optionsSettings.marbleIndex = idx;
			src_Settings.optionsSettings.marbleCategoryIndex = 0;
			src_Settings.optionsSettings.marbleSkin = selectedMarble.skin;
			src_Settings.optionsSettings.marbleModel = selectedMarble.dts;
			src_Settings.optionsSettings.marbleShader = selectedMarble.shader;
			curToken += 1;
			let changeToken = curToken - 1;
			src_ResourceLoader.load(src_Settings.optionsSettings.marbleModel).entry.load(function() {
				if(changeToken + 1 != curToken) {
					return;
				}
				src_MarbleGame.instance.previewWorld.removeMarble(myMarb);
				src_MarbleGame.instance.previewWorld.spawnMarble(function(marb) {
					if(changeToken + 1 != curToken) {
						src_MarbleGame.instance.previewWorld.removeMarble(marb);
						return;
					}
					let _this = src_MarbleGame.instance.scene.camera.pos;
					let v_x = 0;
					let v_y = 1;
					let v_z = 1;
					let x = _this.x + v_x;
					let y = _this.y + v_y;
					let z = _this.z + v_z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let spawnPos_x = x;
					let spawnPos_y = y;
					let spawnPos_z = z;
					let velAdd = new h3d_Vector((1 - 2 * Math.random()) * 2,(1 - 2 * Math.random()) * 1.5,1 - 2 * Math.random());
					let v_x1 = 0;
					let v_y1 = 3;
					let v_z1 = 0;
					velAdd = new h3d_Vector(velAdd.x + v_x1,velAdd.y + v_y1,velAdd.z + v_z1,velAdd.w + 1.);
					marb.setMarblePosition(spawnPos_x,spawnPos_y,spawnPos_z);
					let _this1 = marb.velocity;
					_this1.x = velAdd.x;
					_this1.y = velAdd.y;
					_this1.z = velAdd.z;
					_this1.w = velAdd.w;
					myMarb = marb;
				});
			});
			return true;
		};
		this.innerCtrl.addChild(mbOpt);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Ok",160);
		backButton.position = new h3d_Vector(960,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["A"];
		backButton.accelerators = [13];
		backButton.pressedAction = function(e) {
			_gthis.bmp.set_visible(true);
			mbOpt.onChangeFunc = function(e) {
				return false;
			};
			src_MarbleGame.instance.setPreviewMission(prevPreview,function() {
				src_MarbleGame.canvas.setContent(new gui_OptionsListGui());
			},false);
		};
		bottomBar.addChild(backButton);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.MarblePickerGui"] = gui_MarblePickerGui;
gui_MarblePickerGui.__name__ = "gui.MarblePickerGui";
gui_MarblePickerGui.__super__ = gui_GuiImage;
Object.assign(gui_MarblePickerGui.prototype, {
	__class__: gui_MarblePickerGui
	,innerCtrl: null
});
class gui_MessageBoxOkDlg extends gui_GuiImage {
	constructor(text) {
		let res = src_ResourceLoader.getImage("data/ui/xbox/roundedBG.png").resource.toTile();
		super(res);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		let yesNoFrame = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/popupGUI.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		yesNoFrame.horizSizing = gui_HorizSizing.Center;
		yesNoFrame.vertSizing = gui_VertSizing.Center;
		yesNoFrame.position = new h3d_Vector(70,30);
		yesNoFrame.extent = new h3d_Vector(512,400);
		this.addChild(yesNoFrame);
		let yesNoText = new gui_GuiMLText(arial14,null);
		yesNoText.position = new h3d_Vector(103,85);
		yesNoText.extent = new h3d_Vector(313,186);
		yesNoText.text.set_text(text);
		yesNoText.text.set_textColor(15461355);
		yesNoFrame.addChild(yesNoText);
		let okButton = new gui_GuiXboxButton("Ok",120);
		okButton.position = new h3d_Vector(211,248);
		okButton.extent = new h3d_Vector(120,94);
		okButton.vertSizing = gui_VertSizing.Top;
		okButton.accelerators = [13];
		okButton.gamepadAccelerator = ["A"];
		let _gthis = this;
		okButton.pressedAction = function(sender) {
			src_MarbleGame.canvas.popDialog(_gthis);
		};
		yesNoFrame.addChild(okButton);
		if(yesNoText.text.getBounds().yMax > yesNoText.extent.y) {
			let diff = yesNoText.text.getBounds().yMax - yesNoText.extent.y;
			yesNoFrame.extent.y += diff;
			okButton.position.y += diff;
		}
	}
}
$hxClasses["gui.MessageBoxOkDlg"] = gui_MessageBoxOkDlg;
gui_MessageBoxOkDlg.__name__ = "gui.MessageBoxOkDlg";
gui_MessageBoxOkDlg.__super__ = gui_GuiImage;
Object.assign(gui_MessageBoxOkDlg.prototype, {
	__class__: gui_MessageBoxOkDlg
});
class gui_MessageBoxYesNoDlg extends gui_GuiImage {
	constructor(text,yesFunc,noFunc) {
		let res = src_ResourceLoader.getImage("data/ui/xbox/roundedBG.png").resource.toTile();
		super(res);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		let yesNoFrame = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/popupGUI.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		yesNoFrame.horizSizing = gui_HorizSizing.Center;
		yesNoFrame.vertSizing = gui_VertSizing.Center;
		yesNoFrame.position = new h3d_Vector(70,30);
		yesNoFrame.extent = new h3d_Vector(512,400);
		this.addChild(yesNoFrame);
		let yesNoText = new gui_GuiMLText(arial14,null);
		yesNoText.position = new h3d_Vector(103,85);
		yesNoText.extent = new h3d_Vector(313,186);
		yesNoText.text.set_text(text);
		yesNoText.text.set_textColor(15461355);
		yesNoFrame.addChild(yesNoText);
		let okButton = new gui_GuiXboxButton("Yes",120);
		okButton.position = new h3d_Vector(211,248);
		okButton.extent = new h3d_Vector(120,94);
		okButton.vertSizing = gui_VertSizing.Top;
		okButton.accelerators = [13];
		okButton.gamepadAccelerator = ["A"];
		let _gthis = this;
		okButton.pressedAction = function(sender) {
			src_MarbleGame.canvas.popDialog(_gthis);
			yesFunc();
		};
		yesNoFrame.addChild(okButton);
		let cancelButton = new gui_GuiXboxButton("No",120);
		cancelButton.position = new h3d_Vector(321,248);
		cancelButton.extent = new h3d_Vector(120,94);
		cancelButton.vertSizing = gui_VertSizing.Top;
		cancelButton.accelerators = [27,8];
		cancelButton.gamepadAccelerator = ["B"];
		cancelButton.pressedAction = function(sender) {
			src_MarbleGame.canvas.popDialog(_gthis);
			noFunc();
		};
		yesNoFrame.addChild(cancelButton);
	}
}
$hxClasses["gui.MessageBoxYesNoDlg"] = gui_MessageBoxYesNoDlg;
gui_MessageBoxYesNoDlg.__name__ = "gui.MessageBoxYesNoDlg";
gui_MessageBoxYesNoDlg.__super__ = gui_GuiImage;
Object.assign(gui_MessageBoxYesNoDlg.prototype, {
	__class__: gui_MessageBoxYesNoDlg
});
class gui_MiscOptionsGui extends gui_GuiImage {
	constructor(pauseGui) {
		if(pauseGui == null) {
			pauseGui = false;
		}
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("MISC OPTIONS");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let numberRange = function(start,stop,step) {
			let range = [];
			while(start <= stop) {
				range.push("" + start);
				start += step;
			}
			return range;
		};
		let optionCollection = new gui_GuiXboxOptionsListCollection();
		optionCollection.position = new h3d_Vector(380,160);
		optionCollection.extent = new h3d_Vector(815,500);
		this.innerCtrl.addChild(optionCollection);
		let rwOpt = optionCollection.addOption(1,"Rewind",["Disabled","Enabled"],function(idx) {
			src_Settings.optionsSettings.rewindEnabled = idx == 1;
			return true;
		},0.5,118);
		rwOpt.setCurrentOption(src_Settings.optionsSettings.rewindEnabled ? 1 : 0);
		let rsOpt = optionCollection.addOption(1,"Rewind Speed",numberRange(10,100,5),function(idx) {
			src_Settings.optionsSettings.rewindTimescale = 0.1 + idx / 18.0 * 0.9;
			return true;
		},0.5,118);
		let value = Math.floor((src_Settings.optionsSettings.rewindTimescale - 0.1) / 0.9 * 18);
		rsOpt.setCurrentOption((value < 0 ? 0 : value > 18 ? 18 : value) | 0);
		let sgOpt = optionCollection.addOption(1,"Seeded Gem Hunt",["Disabled","Enabled"],function(idx) {
			src_Settings.optionsSettings.huntRandom = idx == 0;
			return true;
		},0.5,118);
		sgOpt.setCurrentOption(src_Settings.optionsSettings.huntRandom ? 0 : 1);
		let flOpt = optionCollection.addOption(1,"Fast Loading",["Disabled","Enabled"],function(idx) {
			src_Settings.optionsSettings.fastLoad = idx == 1;
			return true;
		},0.5,118);
		flOpt.setCurrentOption(src_Settings.optionsSettings.fastLoad ? 1 : 0);
		let oobResOpt = optionCollection.addOption(1,"OOB Respawn Key",["Jump","Powerup"],function(idx) {
			src_Settings.controlsSettings.oobRespawnKeyByPowerup = idx == 1;
			return true;
		},0.5,118);
		oobResOpt.setCurrentOption(src_Settings.controlsSettings.oobRespawnKeyByPowerup ? 1 : 0);
		let moddedOpt = optionCollection.addOption(1,"Emulate Modded Controller",["No","Yes"],function(idx) {
			src_Settings.controlsSettings.moddedController = idx == 1;
			return true;
		},0.5,118);
		moddedOpt.setCurrentOption(src_Settings.controlsSettings.moddedController ? 1 : 0);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Ok",160);
		backButton.position = new h3d_Vector(960,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["A"];
		backButton.accelerators = [13];
		let _gthis = this;
		if(pauseGui) {
			backButton.pressedAction = function(e) {
				src_Settings.applySettings();
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.canvas.pushDialog(new gui_OptionsListGui(true));
			};
		} else {
			backButton.pressedAction = function(e) {
				src_Settings.applySettings();
				src_MarbleGame.canvas.setContent(new gui_OptionsListGui());
			};
		}
		bottomBar.addChild(backButton);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.MiscOptionsGui"] = gui_MiscOptionsGui;
gui_MiscOptionsGui.__name__ = "gui.MiscOptionsGui";
gui_MiscOptionsGui.__super__ = gui_GuiImage;
Object.assign(gui_MiscOptionsGui.prototype, {
	__class__: gui_MiscOptionsGui
	,innerCtrl: null
});
class gui_MultiplayerGui extends gui_GuiImage {
	constructor() {
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("MULTIPLAYER");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial12 = arial14b.toSdfFont(18 * src_Settings.uiScale,4);
		let warningTxt = new gui_GuiText(arial12);
		warningTxt.text.set_textColor(15461355);
		warningTxt.position = new h3d_Vector(150,250);
		warningTxt.extent = new h3d_Vector(100,100);
		warningTxt.text.set_text("Warning: You are playing on a browser.\nFor smooth multiplayer experience, it is\nrecommended to download the game on your device.");
		this.innerCtrl.addChild(warningTxt);
		let btnList = new gui_GuiXboxList();
		btnList.position = new h3d_Vector(70 - offsetX,165);
		btnList.horizSizing = gui_HorizSizing.Left;
		btnList.extent = new h3d_Vector(502,500);
		this.innerCtrl.addChild(btnList);
		btnList.addButton(3,"Search Matches",function(e) {
			src_MarbleGame.canvas.setContent(new gui_MPServerListGui());
		});
		btnList.addButton(3,"Create Match",function(e) {
			src_MarbleGame.canvas.setContent(new gui_CreateMatchGui());
		});
		btnList.addButton(3,"Join Match",function(e) {
			src_MarbleGame.canvas.setContent(new gui_JoinServerGui());
		});
		btnList.addButton(5,"Change Display Name",function(e) {
			src_MarbleGame.canvas.setContent(new gui_EnterNameDlg());
		});
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Back",160);
		backButton.position = new h3d_Vector(400,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["B"];
		backButton.accelerators = [27,8];
		backButton.pressedAction = function(e) {
			src_MarbleGame.canvas.setContent(new gui_MainMenuGui());
		};
		bottomBar.addChild(backButton);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.MultiplayerGui"] = gui_MultiplayerGui;
gui_MultiplayerGui.__name__ = "gui.MultiplayerGui";
gui_MultiplayerGui.__super__ = gui_GuiImage;
Object.assign(gui_MultiplayerGui.prototype, {
	__class__: gui_MultiplayerGui
	,innerCtrl: null
});
class gui_MultiplayerLevelSelectGui extends gui_GuiImage {
	constructor(isHost) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(isHost);
	}
	_hx_constructor(isHost) {
		this.showingCustoms = false;
		this.inviteVisibility = true;
		let res = src_ResourceLoader.getImage("data/ui/game/CloudBG.jpg").resource.toTile();
		super._hx_constructor(res);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		let arial12 = arial14b.toSdfFont(16 * src_Settings.uiScale,4);
		let mlFontLoader = function(text) {
			switch(text) {
			case "arial12":
				return arial12;
			case "arial14":
				return arial14;
			}
			return null;
		};
		src_MarbleGame.instance.toRecord = false;
		let fadeEdge = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/BG_fadeOutSoftEdge.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		fadeEdge.position = new h3d_Vector(0,0);
		fadeEdge.extent = new h3d_Vector(640,480);
		fadeEdge.vertSizing = gui_VertSizing.Height;
		fadeEdge.horizSizing = gui_HorizSizing.Width;
		this.addChild(fadeEdge);
		let loadAnim = new gui_GuiLoadAnim();
		loadAnim.position = new h3d_Vector(610,253);
		loadAnim.extent = new h3d_Vector(63,63);
		loadAnim.horizSizing = gui_HorizSizing.Center;
		loadAnim.vertSizing = gui_VertSizing.Bottom;
		this.addChild(loadAnim);
		let loadTextBg = new gui_GuiText(arial14);
		loadTextBg.position = new h3d_Vector(608,335);
		loadTextBg.extent = new h3d_Vector(63,40);
		loadTextBg.horizSizing = gui_HorizSizing.Center;
		loadTextBg.vertSizing = gui_VertSizing.Bottom;
		loadTextBg.justify = gui_Justification.Center;
		loadTextBg.text.set_text("Loading");
		loadTextBg.text.set_textColor(0);
		this.addChild(loadTextBg);
		let loadText = new gui_GuiText(arial14);
		loadText.position = new h3d_Vector(610,334);
		loadText.extent = new h3d_Vector(63,40);
		loadText.horizSizing = gui_HorizSizing.Center;
		loadText.vertSizing = gui_VertSizing.Bottom;
		loadText.justify = gui_Justification.Center;
		loadText.text.set_text("Loading");
		this.addChild(loadText);
		let difficultyMissions = src_MissionList.missionList.h["ultra"].h["multiplayer"];
		if(gui_MultiplayerLevelSelectGui.currentSelectionStatic >= difficultyMissions.length) {
			gui_MultiplayerLevelSelectGui.currentSelectionStatic = 0;
		}
		let curMission = difficultyMissions[gui_MultiplayerLevelSelectGui.currentSelectionStatic];
		let lock = true;
		let currentToken = 0;
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("LOBBY");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let playerWnd = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/achievementWindow.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		playerWnd.horizSizing = gui_HorizSizing.Right;
		playerWnd.vertSizing = gui_VertSizing.Bottom;
		playerWnd.position = new h3d_Vector(330,58);
		playerWnd.extent = new h3d_Vector(640,480);
		this.innerCtrl.addChild(playerWnd);
		let playerListArr = [];
		if(net_Net.isHost) {
			playerListArr.push({ name : src_Settings.highscoreName, state : net_Net.lobbyHostReady, platform : 3});
		}
		if(net_Net.isClient) {
			playerListArr.push({ name : src_Settings.highscoreName, state : net_Net.clientConnection.lobbyReady, platform : 3});
		}
		if(net_Net.clientIdMap != null) {
			let this1 = net_Net.clientIdMap;
			let _g_keys = this1.keys();
			while(_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = this1.get(key);
				playerListArr.push({ name : _g_value.name, state : _g_value.lobbyReady, platform : _g_value.platform});
			}
		}
		let _gthis = this;
		let imgLoader = function(path) {
			let t;
			switch(path) {
			case "android":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_android.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "mac":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_mac.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "notready":
				t = src_ResourceLoader.getResource("data/ui/xbox/NotReady.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "pc":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_desktop.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "ready":
				t = src_ResourceLoader.getResource("data/ui/xbox/Ready.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "unknown":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_unknown.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "web":
				t = src_ResourceLoader.getResource("data/ui/xbox/platform_web.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			default:
				return null;
			}
			if(t != null) {
				t.scaleToSize(t.width * src_Settings.uiScale,t.height * src_Settings.uiScale);
			}
			return t;
		};
		this.chatWnd = new gui_ChatCtrl();
		this.chatWnd.horizSizing = gui_HorizSizing.Left;
		this.chatWnd.position = new h3d_Vector(330,58);
		this.chatWnd.extent = new h3d_Vector(200,250);
		this.innerCtrl.addChild(this.chatWnd);
		let arial141 = arial14;
		let result = new Array(playerListArr.length);
		let _g = 0;
		let _g1 = playerListArr.length;
		while(_g < _g1) {
			let i = _g++;
			let player = playerListArr[i];
			let tmp = "<img src=\"" + (player.state ? "ready" : "notready") + "\"></img><img src=\"";
			let tmp1;
			switch(player.platform) {
			case 0:
				tmp1 = "unknown";
				break;
			case 1:
				tmp1 = "pc";
				break;
			case 2:
				tmp1 = "mac";
				break;
			case 3:
				tmp1 = "web";
				break;
			case 4:
				tmp1 = "android";
				break;
			}
			result[i] = tmp + tmp1 + "\"></img>" + player.name;
		}
		this.playerList = new gui_GuiMLTextListCtrl(arial141,result,imgLoader);
		this.playerList.selectedColor = 15897877;
		this.playerList.selectedFillColor = 15461355;
		this.playerList.position = new h3d_Vector(25,22);
		this.playerList.extent = new h3d_Vector(550,480);
		this.playerList.scrollable = true;
		this.playerList.onSelectedFunc = function(sel) {
		};
		playerWnd.addChild(this.playerList);
		let custWnd = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/helpWindow.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		custWnd.horizSizing = gui_HorizSizing.Right;
		custWnd.vertSizing = gui_VertSizing.Bottom;
		custWnd.position = new h3d_Vector(330,58);
		custWnd.extent = new h3d_Vector(640,330);
		let customListScroll = new gui_GuiConsoleScrollCtrl(src_ResourceLoader.getResource("data/ui/common/osxscroll.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		customListScroll.position = new h3d_Vector(25,22);
		customListScroll.extent = new h3d_Vector(600,280);
		customListScroll.scrollToBottom = false;
		custWnd.addChild(customListScroll);
		let arial142 = arial14;
		let _this = MPCustoms.missionList;
		let result1 = new Array(_this.length);
		let _g2 = 0;
		let _g3 = _this.length;
		while(_g2 < _g3) {
			let i = _g2++;
			result1[i] = _this[i].title;
		}
		this.customList = new gui_GuiTextListCtrl(arial142,result1,16777215);
		let custSelectedIdx = 0;
		this.customList.selectedColor = 15897877;
		this.customList.selectedFillColor = 8750469;
		this.customList.textColor = 16777215;
		this.customList.position = new h3d_Vector(0,0);
		this.customList.extent = new h3d_Vector(550,2880);
		this.customList.scrollable = true;
		this.customList.onSelectedFunc = function(idx) {
			net_NetCommands.setLobbyCustLevelName(MPCustoms.missionList[idx].path);
			gui_MultiplayerLevelSelectGui.custSelected = true;
			custSelectedIdx = idx;
			gui_MultiplayerLevelSelectGui.custPath = MPCustoms.missionList[idx].path;
			_gthis.updateLobbyNames();
		};
		customListScroll.addChild(this.customList);
		customListScroll.setScrollMax(this.customList.calculateFullHeight());
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Back",160);
		backButton.position = new h3d_Vector(400,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["B"];
		backButton.accelerators = [27,8];
		backButton.pressedAction = function(e) {
			net_Net.disconnect();
			if(net_Net.isHost) {
				src_MarbleGame.canvas.setContent(new gui_CreateMatchGui());
			} else {
				src_MarbleGame.canvas.setContent(new gui_MultiplayerGui());
			}
		};
		bottomBar.addChild(backButton);
		if(net_Net.isHost) {
			let customsButton = new gui_GuiXboxButton("Customs",200);
			customsButton.position = new h3d_Vector(560,0);
			customsButton.vertSizing = gui_VertSizing.Bottom;
			customsButton.horizSizing = gui_HorizSizing.Right;
			customsButton.gamepadAccelerator = ["X"];
			customsButton.pressedAction = function(e) {
				_gthis.showingCustoms = !_gthis.showingCustoms;
				if(_gthis.showingCustoms) {
					_gthis.innerCtrl.removeChild(playerWnd);
					_gthis.innerCtrl.addChild(custWnd);
				} else {
					_gthis.innerCtrl.addChild(playerWnd);
					_gthis.innerCtrl.removeChild(custWnd);
					_gthis.updateLobbyNames();
				}
				src_MarbleGame.canvas.render(src_MarbleGame.canvas.scene2d);
			};
			bottomBar.addChild(customsButton);
			let inviteButton = new gui_GuiXboxButton("Invite Visibility",220);
			inviteButton.position = new h3d_Vector(750,0);
			inviteButton.vertSizing = gui_VertSizing.Bottom;
			inviteButton.horizSizing = gui_HorizSizing.Right;
			inviteButton.gamepadAccelerator = ["Y"];
			inviteButton.pressedAction = function(e) {
				_gthis.inviteVisibility = !_gthis.inviteVisibility;
				_gthis.updateLobbyNames();
			};
			bottomBar.addChild(inviteButton);
		}
		let nextButton = new gui_GuiXboxButton("Ready",160);
		nextButton.position = new h3d_Vector(960,0);
		nextButton.vertSizing = gui_VertSizing.Bottom;
		nextButton.horizSizing = gui_HorizSizing.Right;
		nextButton.gamepadAccelerator = ["A"];
		nextButton.accelerators = [13];
		nextButton.pressedAction = function(e) {
			net_NetCommands.toggleReadiness(net_Net.isClient ? net_Net.clientId : 0);
		};
		bottomBar.addChild(nextButton);
		gui_MultiplayerLevelSelectGui.playSelectedLevel = function(index) {
			if(gui_MultiplayerLevelSelectGui.custSelected) {
				net_NetCommands.playCustomLevel(MPCustoms.missionList[custSelectedIdx].path);
			} else {
				curMission = difficultyMissions[index];
				src_MarbleGame.instance.playMission(curMission,true);
			}
		};
		let levelWnd = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/levelPreviewWindow.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		levelWnd.position = new h3d_Vector(555,469);
		levelWnd.extent = new h3d_Vector(535,137);
		levelWnd.vertSizing = gui_VertSizing.Bottom;
		levelWnd.horizSizing = gui_HorizSizing.Right;
		this.innerCtrl.addChild(levelWnd);
		let levelInfoLeft = new gui_GuiMLText(arial14,mlFontLoader);
		levelInfoLeft.position = new h3d_Vector(33,40);
		levelInfoLeft.extent = new h3d_Vector(480,100);
		levelInfoLeft.text.set_text("");
		levelInfoLeft.text.set_lineSpacing(0);
		levelInfoLeft.text.set_filter(new h2d_filter_DropShadow(2,0.785,0,1,0,0.4,1,true));
		levelWnd.addChild(levelInfoLeft);
		let result2 = new Array(difficultyMissions.length);
		let _g4 = 0;
		let _g5 = difficultyMissions.length;
		while(_g4 < _g5) {
			let i = _g4++;
			result2[i] = difficultyMissions[i].title;
		}
		let levelSelectOpts = new gui_GuiXboxOptionsList(6,"Level",result2,0.3,155.5,isHost);
		let setLevel = function(idx) {
			gui_MultiplayerLevelSelectGui.custSelected = false;
			levelSelectOpts.currentOption = idx;
			_gthis.bmp.set_visible(true);
			loadAnim.anim.set_visible(true);
			loadText.text.set_visible(true);
			loadTextBg.text.set_visible(true);
			lock = true;
			curMission = difficultyMissions[idx];
			gui_MultiplayerLevelSelectGui.currentSelectionStatic = idx;
			currentToken += 1;
			let misFile = haxe_io_Path.withoutExtension(haxe_io_Path.withoutDirectory(curMission.path));
			let requestToken = currentToken;
			src_MarbleGame.instance.setPreviewMission(misFile,function() {
				lock = false;
				if(requestToken != currentToken) {
					return;
				}
				_gthis.bmp.set_visible(false);
				loadAnim.anim.set_visible(false);
				loadText.text.set_visible(false);
				loadTextBg.text.set_visible(false);
			});
			let hostName = src_Settings.highscoreName;
			if(!net_Net.isHost) {
				hostName = net_Net.clientIdMap.h[0].name;
			}
			if(net_Net.isHost) {
				_gthis.updatePlayerCountFn = function(pub,priv,publicTotal,privateTotal) {
					if(_gthis.inviteVisibility) {
						levelInfoLeft.text.set_text("<p><font face=\"arial14\">Host: " + hostName + "</font></p>" + ("<p><font face=\"arial14\">Level: " + levelSelectOpts.optionText.text.text + "</font></p>") + ("<p><font face=\"arial12\">Public Slots: " + pub + "/" + publicTotal + ", Private Slots: " + priv + "/" + privateTotal + ", Invite Code: " + net_Net.serverInfo.inviteCode + "</font></p>"));
					} else {
						levelInfoLeft.text.set_text("<p><font face=\"arial14\">Host: " + hostName + "</font></p>" + ("<p><font face=\"arial14\">Level: " + levelSelectOpts.optionText.text.text + "</font></p>") + ("<p><font face=\"arial12\">Public Slots: " + pub + "/" + publicTotal + ", Private Slots: " + priv + "/" + privateTotal + "</font></p>"));
					}
				};
				let pubCount = 1;
				let privCount = 0;
				let this1 = net_Net.clientIdMap;
				let _g_keys = this1.keys();
				while(_g_keys.hasNext()) {
					let key = _g_keys.next();
					let _g_value = this1.get(key);
					if(_g_value.isPrivate) {
						++privCount;
					} else {
						++pubCount;
					}
				}
				_gthis.updatePlayerCountFn(pubCount,privCount,net_Net.serverInfo.maxPlayers - net_Net.serverInfo.privateSlots,net_Net.serverInfo.privateSlots);
			}
			if(net_Net.isClient) {
				_gthis.updatePlayerCountFn = function(pub,priv,publicTotal,privateTotal) {
					levelInfoLeft.text.set_text("<p><font face=\"arial14\">Host: " + hostName + "</font></p>" + ("<p><font face=\"arial14\">Level: " + levelSelectOpts.optionText.text.text + "</font></p>"));
				};
				_gthis.updatePlayerCountFn(0,0,0,0);
			}
			return true;
		};
		levelSelectOpts.position = new h3d_Vector(380,430);
		levelSelectOpts.extent = new h3d_Vector(815,94);
		levelSelectOpts.vertSizing = gui_VertSizing.Bottom;
		levelSelectOpts.horizSizing = gui_HorizSizing.Right;
		levelSelectOpts.alwaysActive = true;
		levelSelectOpts.onChangeFunc = function(i) {
			net_NetCommands.setLobbyLevelIndex(i);
			return true;
		};
		gui_MultiplayerLevelSelectGui.setLevelFn = function(idx) {
			levelSelectOpts.setCurrentOption(idx);
			setLevel(idx);
		};
		gui_MultiplayerLevelSelectGui.setLevelStr = function(str) {
			let _this = MPCustoms.missionList;
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(v.path == str) {
					_g.push(v);
				}
			}
			let cust = _g[0];
			levelSelectOpts.optionText.text.set_text(cust.title);
			gui_MultiplayerLevelSelectGui.custSelected = true;
			gui_MultiplayerLevelSelectGui.custPath = str;
			if(net_Net.isHost) {
				_gthis.updateLobbyNames();
			} else {
				_gthis.updatePlayerCountFn(0,0,0,0);
			}
		};
		let customIsSelected = gui_MultiplayerLevelSelectGui.custSelected == true;
		levelSelectOpts.setCurrentOption(gui_MultiplayerLevelSelectGui.currentSelectionStatic);
		setLevel(gui_MultiplayerLevelSelectGui.currentSelectionStatic);
		this.innerCtrl.addChild(levelSelectOpts);
		if(customIsSelected) {
			gui_MultiplayerLevelSelectGui.setLevelStr(gui_MultiplayerLevelSelectGui.custPath);
		}
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
	updateLobbyNames() {
		let playerListArr = [];
		if(net_Net.isHost) {
			playerListArr.push({ name : src_Settings.highscoreName, state : net_Net.lobbyHostReady, platform : 3});
		}
		if(net_Net.isClient) {
			playerListArr.push({ name : src_Settings.highscoreName, state : net_Net.lobbyClientReady, platform : 3});
		}
		if(net_Net.clientIdMap != null) {
			let this1 = net_Net.clientIdMap;
			let _g_keys = this1.keys();
			while(_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = this1.get(key);
				playerListArr.push({ name : _g_value.name, state : _g_value.lobbyReady, platform : _g_value.platform});
			}
		}
		if(!this.showingCustoms) {
			let tmp = this.playerList;
			let result = new Array(playerListArr.length);
			let _g = 0;
			let _g1 = playerListArr.length;
			while(_g < _g1) {
				let i = _g++;
				let player = playerListArr[i];
				let tmp = "<img src=\"" + (player.state ? "ready" : "notready") + "\"></img><img src=\"";
				let tmp1;
				switch(player.platform) {
				case 0:
					tmp1 = "unknown";
					break;
				case 1:
					tmp1 = "pc";
					break;
				case 2:
					tmp1 = "mac";
					break;
				case 3:
					tmp1 = "web";
					break;
				case 4:
					tmp1 = "android";
					break;
				}
				result[i] = tmp + tmp1 + "\"></img>" + player.name;
			}
			tmp.setTexts(result);
		}
		let pubCount = 1;
		let privCount = 0;
		let this1 = net_Net.clientIdMap;
		let _g_keys = this1.keys();
		while(_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = this1.get(key);
			if(_g_value.isPrivate) {
				++privCount;
			} else {
				++pubCount;
			}
		}
		if(net_Net.isHost) {
			this.updatePlayerCountFn(pubCount,privCount,net_Net.serverInfo.maxPlayers - net_Net.serverInfo.privateSlots,net_Net.serverInfo.privateSlots);
		}
	}
	addChatMessage(str) {
		this.chatWnd.addChatMessage(str);
	}
	dispose() {
		super.dispose();
		gui_MultiplayerLevelSelectGui.playSelectedLevel = null;
		gui_MultiplayerLevelSelectGui.setLevelFn = null;
	}
	update(dt,mouseState) {
		this.chatWnd.updateChat(dt);
		super.update(dt,mouseState);
	}
}
$hxClasses["gui.MultiplayerLevelSelectGui"] = gui_MultiplayerLevelSelectGui;
gui_MultiplayerLevelSelectGui.__name__ = "gui.MultiplayerLevelSelectGui";
gui_MultiplayerLevelSelectGui.__super__ = gui_GuiImage;
Object.assign(gui_MultiplayerLevelSelectGui.prototype, {
	__class__: gui_MultiplayerLevelSelectGui
	,playerList: null
	,customList: null
	,updatePlayerCountFn: null
	,innerCtrl: null
	,inviteVisibility: null
	,chatWnd: null
	,showingCustoms: null
});
class gui_MultiplayerLoadingGui extends gui_GuiImage {
	constructor(initialStatus,showCancel) {
		if(showCancel == null) {
			showCancel = true;
		}
		let res = src_ResourceLoader.getImage("data/ui/game/CloudBG.jpg").resource.toTile();
		super(res);
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		let fadeEdge = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/BG_fadeOutSoftEdge.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		fadeEdge.position = new h3d_Vector(0,0);
		fadeEdge.extent = new h3d_Vector(640,480);
		fadeEdge.vertSizing = gui_VertSizing.Height;
		fadeEdge.horizSizing = gui_HorizSizing.Width;
		this.addChild(fadeEdge);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		this.loadAnim = new gui_GuiLoadAnim();
		this.loadAnim.position = new h3d_Vector(610,253);
		this.loadAnim.extent = new h3d_Vector(63,63);
		this.loadAnim.horizSizing = gui_HorizSizing.Center;
		this.loadAnim.vertSizing = gui_VertSizing.Bottom;
		this.addChild(this.loadAnim);
		this.loadTextBg = new gui_GuiText(arial14);
		this.loadTextBg.position = new h3d_Vector(608,335);
		this.loadTextBg.extent = new h3d_Vector(63,40);
		this.loadTextBg.horizSizing = gui_HorizSizing.Center;
		this.loadTextBg.vertSizing = gui_VertSizing.Bottom;
		this.loadTextBg.justify = gui_Justification.Center;
		this.loadTextBg.text.set_text(initialStatus);
		this.loadTextBg.text.set_textColor(0);
		this.addChild(this.loadTextBg);
		this.loadText = new gui_GuiText(arial14);
		this.loadText.position = new h3d_Vector(610,334);
		this.loadText.extent = new h3d_Vector(63,40);
		this.loadText.horizSizing = gui_HorizSizing.Center;
		this.loadText.vertSizing = gui_VertSizing.Bottom;
		this.loadText.justify = gui_Justification.Center;
		this.loadText.text.set_text(initialStatus);
		this.addChild(this.loadText);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		this.bottomBar = new gui_GuiControl();
		this.bottomBar.position = new h3d_Vector(0,590);
		this.bottomBar.extent = new h3d_Vector(640,200);
		this.bottomBar.horizSizing = gui_HorizSizing.Width;
		this.bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(this.bottomBar);
		if(showCancel) {
			this.backButton = new gui_GuiXboxButton("Cancel",160);
			this.backButton.position = new h3d_Vector(960,0);
			this.backButton.vertSizing = gui_VertSizing.Bottom;
			this.backButton.horizSizing = gui_HorizSizing.Right;
			this.backButton.gamepadAccelerator = ["A"];
			this.backButton.accelerators = [13];
			this.backButton.pressedAction = function(e) {
				net_Net.disconnect();
				src_MarbleGame.canvas.setContent(new gui_MultiplayerGui());
			};
			this.bottomBar.addChild(this.backButton);
		}
	}
	setLoadingStatus(str) {
		this.loadText.text.set_text(str);
		this.loadTextBg.text.set_text(str);
	}
	setErrorStatus(str) {
		this.loadText.text.set_text(str);
		this.loadTextBg.text.set_text(str);
		this.loadAnim.anim.set_visible(false);
		this.backButton.text.text.set_text("Ok");
		this.backButton.pressedAction = function(e) {
			src_MarbleGame.canvas.setContent(new gui_MultiplayerGui());
		};
		src_MarbleGame.canvas.render(src_MarbleGame.canvas.scene2d);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.MultiplayerLoadingGui"] = gui_MultiplayerLoadingGui;
gui_MultiplayerLoadingGui.__name__ = "gui.MultiplayerLoadingGui";
gui_MultiplayerLoadingGui.__super__ = gui_GuiImage;
Object.assign(gui_MultiplayerLoadingGui.prototype, {
	__class__: gui_MultiplayerLoadingGui
	,loadText: null
	,loadTextBg: null
	,loadAnim: null
	,bottomBar: null
	,innerCtrl: null
	,backButton: null
});
class gui_OptionsListGui extends gui_GuiImage {
	constructor(pauseGui) {
		if(pauseGui == null) {
			pauseGui = false;
		}
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("HELP & OPTIONS");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let btnList = new gui_GuiXboxList();
		btnList.position = new h3d_Vector(70 - offsetX,165);
		btnList.horizSizing = gui_HorizSizing.Left;
		btnList.extent = new h3d_Vector(502,500);
		this.innerCtrl.addChild(btnList);
		if(!pauseGui) {
			btnList.addButton(3,"Marble Appearance",function(e) {
				src_MarbleGame.canvas.setContent(new gui_MarblePickerGui());
			});
		}
		btnList.addButton(3,"Input and Sound Options",function(e) {
			src_MarbleGame.canvas.setContent(new gui_InputOptionsGui(pauseGui));
		});
		if(src_Util.isTouchDevice()) {
			if(!pauseGui) {
				btnList.addButton(3,"Touch Controls",function(e) {
					src_MarbleGame.canvas.setContent(new gui_TouchOptionsGui(pauseGui));
				});
			}
		} else {
			btnList.addButton(3,"Key Bindings",function(e) {
				src_MarbleGame.canvas.setContent(new gui_KeyBindingsGui(pauseGui));
			});
		}
		btnList.addButton(3,"Video Options",function(e) {
			src_MarbleGame.canvas.setContent(new gui_VideoOptionsGui(pauseGui));
		});
		if(!pauseGui) {
			btnList.addButton(3,"Misc Options",function(e) {
				src_MarbleGame.canvas.setContent(new gui_MiscOptionsGui(pauseGui));
			});
		}
		btnList.addButton(5,"How to Play",function(e) {
			src_MarbleGame.canvas.setContent(new gui_AboutMenuOptionsGui(pauseGui));
		});
		btnList.addButton(5,"Credits",function(e) {
			src_MarbleGame.canvas.setContent(new gui_HelpCreditsGui(5,pauseGui));
		});
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Back",160);
		backButton.position = new h3d_Vector(400,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["B"];
		backButton.accelerators = [27,8];
		let _gthis = this;
		if(pauseGui) {
			backButton.pressedAction = function(e) {
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.instance.showPauseUI();
			};
		} else {
			backButton.pressedAction = function(e) {
				src_MarbleGame.canvas.setContent(new gui_MainMenuGui());
			};
		}
		bottomBar.addChild(backButton);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.OptionsListGui"] = gui_OptionsListGui;
gui_OptionsListGui.__name__ = "gui.OptionsListGui";
gui_OptionsListGui.__super__ = gui_GuiImage;
Object.assign(gui_OptionsListGui.prototype, {
	__class__: gui_OptionsListGui
	,innerCtrl: null
});
class gui_MiddleMessage {
	constructor(ctrl,ctrl2,age,yPos) {
		this.ctrl = ctrl;
		this.ctrl2 = ctrl2;
		this.age = age;
		this.yPos = yPos;
	}
}
$hxClasses["gui.MiddleMessage"] = gui_MiddleMessage;
gui_MiddleMessage.__name__ = "gui.MiddleMessage";
Object.assign(gui_MiddleMessage.prototype, {
	__class__: gui_MiddleMessage
	,ctrl: null
	,ctrl2: null
	,age: null
	,yPos: null
});
class gui_PlayerInfo {
	constructor(id,name,us,score) {
		this.id = id;
		this.name = name;
		this.us = us;
		this.score = score;
	}
}
$hxClasses["gui.PlayerInfo"] = gui_PlayerInfo;
gui_PlayerInfo.__name__ = "gui.PlayerInfo";
Object.assign(gui_PlayerInfo.prototype, {
	__class__: gui_PlayerInfo
	,id: null
	,name: null
	,us: null
	,score: null
});
class gui_PlayGui {
	constructor() {
		this.pgoChildren = [];
		this.blastValue = 0;
		this.totalGems = 0;
		this.middleMessages = [];
		this.resizeControlEvents = [];
		this.soundResources = [];
		this.textureResources = [];
		this.imageResources = [];
		this.playerList = [];
		this.gemCountNumbers = [];
		this.timerNumbers = [];
	}
	dispose() {
		if(this._init) {
			this.playGuiCtrlOuter.dispose();
			if(this.playerListContainer != null) {
				this.playerListContainer.dispose();
				this.playerListContainer = null;
				this.playerListCtrl.dispose();
				this.playerListCtrl = null;
				this.playerListShadowCtrl.dispose();
				this.playerListShadowCtrl = null;
				this.playerListScoresCtrl.dispose();
				this.playerListScoresCtrl = null;
				this.playerListScoresShadowCtrl.dispose();
				this.playerListScoresShadowCtrl = null;
			}
			if(this.chatCtrl != null) {
				this.chatCtrl.dispose();
				this.chatCtrl = null;
			}
			let _g = 0;
			let _g1 = this.textureResources;
			while(_g < _g1.length) {
				let textureResource = _g1[_g];
				++_g;
				textureResource.release();
			}
			let _g2 = 0;
			let _g3 = this.imageResources;
			while(_g2 < _g3.length) {
				let imageResource = _g3[_g2];
				++_g2;
				imageResource.release();
			}
			let _g4 = 0;
			let _g5 = this.soundResources;
			while(_g4 < _g5.length) {
				let audioResource = _g5[_g4];
				++_g4;
				audioResource.release();
			}
			hxd_Window.getInstance().removeResizeEvent(this.resizeEv);
		}
	}
	init(scene2d,game,onFinish) {
		this.scene2d = scene2d;
		this._init = true;
		this.playGuiCtrlOuter = new gui_GuiControl();
		this.playGuiCtrlOuter.position = new h3d_Vector();
		this.playGuiCtrlOuter.extent = new h3d_Vector(640,480);
		this.playGuiCtrlOuter.horizSizing = gui_HorizSizing.Width;
		this.playGuiCtrlOuter.vertSizing = gui_VertSizing.Height;
		let wnd = src_MarbleGame.instance.scene2d;
		let safeVerMargin = 1 + wnd.height * 0.15 / 2;
		let safeHorMargin = 1 + wnd.width * 0.15 / 2;
		this.playGuiCtrl = new gui_GuiControl();
		this.playGuiCtrl.position = new h3d_Vector(safeHorMargin,safeVerMargin);
		let subX = 640 - (wnd.width - safeHorMargin * 2) * 640 / wnd.width;
		let subY = 480 - (wnd.height - safeVerMargin * 2) * 480 / wnd.height;
		this.playGuiCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.playGuiCtrl.horizSizing = gui_HorizSizing.Width;
		this.playGuiCtrl.vertSizing = gui_VertSizing.Height;
		this.playGuiCtrlOuter.addChild(this.playGuiCtrl);
		let numberTiles = [];
		let tile = src_ResourceLoader.getResource("data/ui/game/numbers/" + 0 + ".png",src_ResourceLoader.getImage,this.imageResources).toTile();
		numberTiles.push(tile);
		let tile1 = src_ResourceLoader.getResource("data/ui/game/numbers/" + 1 + ".png",src_ResourceLoader.getImage,this.imageResources).toTile();
		numberTiles.push(tile1);
		let tile2 = src_ResourceLoader.getResource("data/ui/game/numbers/" + 2 + ".png",src_ResourceLoader.getImage,this.imageResources).toTile();
		numberTiles.push(tile2);
		let tile3 = src_ResourceLoader.getResource("data/ui/game/numbers/" + 3 + ".png",src_ResourceLoader.getImage,this.imageResources).toTile();
		numberTiles.push(tile3);
		let tile4 = src_ResourceLoader.getResource("data/ui/game/numbers/" + 4 + ".png",src_ResourceLoader.getImage,this.imageResources).toTile();
		numberTiles.push(tile4);
		let tile5 = src_ResourceLoader.getResource("data/ui/game/numbers/" + 5 + ".png",src_ResourceLoader.getImage,this.imageResources).toTile();
		numberTiles.push(tile5);
		let tile6 = src_ResourceLoader.getResource("data/ui/game/numbers/" + 6 + ".png",src_ResourceLoader.getImage,this.imageResources).toTile();
		numberTiles.push(tile6);
		let tile7 = src_ResourceLoader.getResource("data/ui/game/numbers/" + 7 + ".png",src_ResourceLoader.getImage,this.imageResources).toTile();
		numberTiles.push(tile7);
		let tile8 = src_ResourceLoader.getResource("data/ui/game/numbers/" + 8 + ".png",src_ResourceLoader.getImage,this.imageResources).toTile();
		numberTiles.push(tile8);
		let tile9 = src_ResourceLoader.getResource("data/ui/game/numbers/" + 9 + ".png",src_ResourceLoader.getImage,this.imageResources).toTile();
		numberTiles.push(tile9);
		this.timerNumbers.push(new gui_GuiAnim(numberTiles));
		this.timerNumbers.push(new gui_GuiAnim(numberTiles));
		this.timerNumbers.push(new gui_GuiAnim(numberTiles));
		this.timerNumbers.push(new gui_GuiAnim(numberTiles));
		this.timerNumbers.push(new gui_GuiAnim(numberTiles));
		this.timerNumbers.push(new gui_GuiAnim(numberTiles));
		this.timerNumbers.push(new gui_GuiAnim(numberTiles));
		this.gemCountNumbers.push(new gui_GuiAnim(numberTiles));
		this.gemCountNumbers.push(new gui_GuiAnim(numberTiles));
		this.gemCountNumbers.push(new gui_GuiAnim(numberTiles));
		this.gemCountNumbers.push(new gui_GuiAnim(numberTiles));
		this.gemCountNumbers.push(new gui_GuiAnim(numberTiles));
		this.gemCountNumbers.push(new gui_GuiAnim(numberTiles));
		this.initTimer();
		if(!src_MarbleGame.instance.world.isMultiplayer) {
			this.initGemCounter();
		}
		this.initPowerupBox();
		if(game == "ultra") {
			this.initBlastBar();
		}
		this.initTexts();
		if(src_MarbleGame.instance.world.isMultiplayer) {
			this.initPlayerList();
			this.initChatHud();
		}
		if(src_Util.isTouchDevice()) {
			src_MarbleGame.instance.touchInput.showControls(this.playGuiCtrlOuter,game == "ultra");
		}
		this.playGuiCtrlOuter.render(scene2d);
		let _gthis = this;
		this.resizeEv = function() {
			let safeVerMargin = 1 + wnd.height * 0.15 / 2;
			let safeHorMargin = 1 + wnd.width * 0.15 / 2;
			_gthis.playGuiCtrl.position = new h3d_Vector(safeHorMargin,safeVerMargin);
			let subX = 640 - (wnd.width - safeHorMargin * 2) * 640 / wnd.width;
			let subY = 480 - (wnd.height - safeVerMargin * 2) * 480 / wnd.height;
			_gthis.playGuiCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
			_gthis.resizeControls();
			_gthis.playGuiCtrlOuter.render(src_MarbleGame.canvas.scene2d);
		};
		hxd_Window.getInstance().addResizeEvent(this.resizeEv);
		onFinish();
	}
	resizeControls() {
		let _g = 0;
		let _g1 = this.resizeControlEvents;
		while(_g < _g1.length) {
			let resizeControl = _g1[_g];
			++_g;
			resizeControl();
		}
	}
	initTimer() {
		let scene2d = src_MarbleGame.instance.scene2d;
		let safeVerMargin = 1 + scene2d.height * 0.15 / 2;
		let timerCtrl = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/game/timebackdrop0.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		timerCtrl.position = new h3d_Vector(215,0);
		timerCtrl.extent = new h3d_Vector(256,64);
		timerCtrl.horizSizing = gui_HorizSizing.Center;
		timerCtrl.xScale = (scene2d.height - safeVerMargin * 2) / 480;
		timerCtrl.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		let innerCtrl = new gui_GuiControl();
		innerCtrl.position = new h3d_Vector(26,0);
		innerCtrl.extent = new h3d_Vector(256,64);
		innerCtrl.xScale = (scene2d.height - safeVerMargin * 2) / 480;
		innerCtrl.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		timerCtrl.addChild(innerCtrl);
		this.timerNumbers[0].position = new h3d_Vector(20,4);
		this.timerNumbers[0].extent = new h3d_Vector(43,55);
		this.timerNumbers[0].xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerNumbers[0].yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerNumbers[1].position = new h3d_Vector(40,4);
		this.timerNumbers[1].extent = new h3d_Vector(43,55);
		this.timerNumbers[1].xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerNumbers[1].yScale = (scene2d.height - safeVerMargin * 2) / 480;
		let colonCols = src_ResourceLoader.getResource("data/ui/game/numbers/colon.png",src_ResourceLoader.getImage,this.imageResources).toTile();
		this.timerColon = new gui_GuiImage(colonCols);
		this.timerColon.position = new h3d_Vector(55,4);
		this.timerColon.extent = new h3d_Vector(43,55);
		this.timerColon.xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerColon.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerNumbers[2].position = new h3d_Vector(70,4);
		this.timerNumbers[2].extent = new h3d_Vector(43,55);
		this.timerNumbers[2].xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerNumbers[2].yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerNumbers[3].position = new h3d_Vector(90,4);
		this.timerNumbers[3].extent = new h3d_Vector(43,55);
		this.timerNumbers[3].xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerNumbers[3].yScale = (scene2d.height - safeVerMargin * 2) / 480;
		let pointCols = src_ResourceLoader.getResource("data/ui/game/numbers/point.png",src_ResourceLoader.getImage,this.imageResources).toTile();
		this.timerPoint = new gui_GuiImage(pointCols);
		this.timerPoint.position = new h3d_Vector(105,4);
		this.timerPoint.extent = new h3d_Vector(43,55);
		this.timerPoint.xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerPoint.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerNumbers[4].position = new h3d_Vector(120,4);
		this.timerNumbers[4].extent = new h3d_Vector(43,55);
		this.timerNumbers[4].xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerNumbers[4].yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerNumbers[5].position = new h3d_Vector(140,4);
		this.timerNumbers[5].extent = new h3d_Vector(43,55);
		this.timerNumbers[5].xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerNumbers[5].yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.timerNumbers[6].position = new h3d_Vector(191,0);
		this.timerNumbers[6].extent = new h3d_Vector(43,55);
		innerCtrl.addChild(this.timerNumbers[0]);
		innerCtrl.addChild(this.timerNumbers[1]);
		innerCtrl.addChild(this.timerColon);
		innerCtrl.addChild(this.timerNumbers[2]);
		innerCtrl.addChild(this.timerNumbers[3]);
		innerCtrl.addChild(this.timerPoint);
		innerCtrl.addChild(this.timerNumbers[4]);
		innerCtrl.addChild(this.timerNumbers[5]);
		let _gthis = this;
		this.resizeControlEvents.push(function() {
			let safeVerMargin = 1 + scene2d.height * 0.15 / 2;
			innerCtrl.xScale = (scene2d.height - safeVerMargin * 2) / 480;
			innerCtrl.yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerNumbers[0].xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerNumbers[0].yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerNumbers[1].xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerNumbers[1].yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerNumbers[2].xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerNumbers[2].yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerNumbers[3].xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerNumbers[3].yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerNumbers[4].xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerNumbers[4].yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerNumbers[5].xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerNumbers[5].yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerColon.xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerColon.yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerPoint.xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.timerPoint.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		});
		this.playGuiCtrl.addChild(timerCtrl);
	}
	setCenterText(text) {
		if(text != "") {
			this.centerText.text.set_text(text);
			this.centerText.text.set_visible(true);
			this.centerTextBg.bmp.set_visible(true);
		} else {
			this.centerText.text.set_visible(false);
			this.centerTextBg.bmp.set_visible(false);
		}
	}
	initGemCounter() {
		let scene2d = src_MarbleGame.instance.scene2d;
		let safeVerMargin = 1 + scene2d.height * 0.15 / 2;
		let gemBox = new gui_GuiControl();
		gemBox.position = new h3d_Vector(0,0);
		gemBox.extent = new h3d_Vector(300,200);
		gemBox.xScale = (scene2d.height - safeVerMargin * 2) / 480;
		gemBox.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		let innerCtrl = new gui_GuiControl();
		innerCtrl.position = new h3d_Vector(26,0);
		innerCtrl.extent = new h3d_Vector(256,64);
		innerCtrl.xScale = (scene2d.height - safeVerMargin * 2) / 480;
		innerCtrl.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		gemBox.addChild(innerCtrl);
		this.gemCountNumbers[0].position = new h3d_Vector(20,4);
		this.gemCountNumbers[0].extent = new h3d_Vector(43,55);
		this.gemCountNumbers[0].xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemCountNumbers[0].yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemCountNumbers[1].position = new h3d_Vector(38,4);
		this.gemCountNumbers[1].extent = new h3d_Vector(43,55);
		this.gemCountNumbers[1].xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemCountNumbers[1].yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemCountNumbers[2].position = new h3d_Vector(56,4);
		this.gemCountNumbers[2].extent = new h3d_Vector(43,55);
		this.gemCountNumbers[2].xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemCountNumbers[2].yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemCountSlash = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/game/numbers/slash.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		this.gemCountSlash.position = new h3d_Vector(73,4);
		this.gemCountSlash.extent = new h3d_Vector(43,55);
		this.gemCountSlash.xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemCountSlash.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemCountNumbers[3].position = new h3d_Vector(89,4);
		this.gemCountNumbers[3].extent = new h3d_Vector(43,55);
		this.gemCountNumbers[3].xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemCountNumbers[3].yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemCountNumbers[4].position = new h3d_Vector(107,4);
		this.gemCountNumbers[4].extent = new h3d_Vector(43,55);
		this.gemCountNumbers[4].xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemCountNumbers[4].yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemCountNumbers[5].position = new h3d_Vector(125,4);
		this.gemCountNumbers[5].extent = new h3d_Vector(43,55);
		this.gemCountNumbers[5].xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemCountNumbers[5].yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemHUD = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/game/gem.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		this.gemHUD.position = new h3d_Vector(144,2);
		this.gemHUD.extent = new h3d_Vector(64,64);
		this.gemHUD.xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.gemHUD.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		innerCtrl.addChild(this.gemCountNumbers[0]);
		innerCtrl.addChild(this.gemCountNumbers[1]);
		innerCtrl.addChild(this.gemCountNumbers[2]);
		innerCtrl.addChild(this.gemCountSlash);
		innerCtrl.addChild(this.gemCountNumbers[3]);
		innerCtrl.addChild(this.gemCountNumbers[4]);
		innerCtrl.addChild(this.gemCountNumbers[5]);
		innerCtrl.addChild(this.gemHUD);
		let _gthis = this;
		this.resizeControlEvents.push(function() {
			let safeVerMargin = 1 + scene2d.height * 0.15 / 2;
			gemBox.xScale = (scene2d.height - safeVerMargin * 2) / 480;
			gemBox.yScale = (scene2d.height - safeVerMargin * 2) / 480;
			innerCtrl.xScale = (scene2d.height - safeVerMargin * 2) / 480;
			innerCtrl.yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemCountNumbers[0].xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemCountNumbers[0].yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemCountNumbers[1].xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemCountNumbers[1].yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemCountNumbers[2].xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemCountNumbers[2].yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemCountNumbers[3].xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemCountNumbers[3].yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemCountNumbers[4].xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemCountNumbers[4].yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemCountNumbers[5].xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemCountNumbers[5].yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemHUD.xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.gemHUD.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		});
		this.playGuiCtrl.addChild(gemBox);
	}
	initPowerupBox() {
		let scene2d = src_MarbleGame.instance.scene2d;
		let safeVerMargin = 1 + scene2d.height * 0.15 / 2;
		let powerupImgs = [src_ResourceLoader.getResource("data/ui/game/pc/powerup.png",src_ResourceLoader.getImage,this.imageResources).toTile(),src_ResourceLoader.getResource("data/ui/game/pc/powerup_copter.png",src_ResourceLoader.getImage,this.imageResources).toTile(),src_ResourceLoader.getResource("data/ui/game/pc/powerup_jump.png",src_ResourceLoader.getImage,this.imageResources).toTile(),src_ResourceLoader.getResource("data/ui/game/pc/powerup_mega.png",src_ResourceLoader.getImage,this.imageResources).toTile(),src_ResourceLoader.getResource("data/ui/game/pc/powerup_speed.png",src_ResourceLoader.getImage,this.imageResources).toTile()];
		this.powerupBox = new gui_GuiAnim(powerupImgs);
		this.powerupBox.position = new h3d_Vector(this.playGuiCtrl.extent.x - 171,0);
		this.powerupBox.extent = new h3d_Vector(170,170);
		this.powerupBox.horizSizing = gui_HorizSizing.Left;
		this.powerupBox.vertSizing = gui_VertSizing.Bottom;
		this.powerupBox.xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.powerupBox.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		let _gthis = this;
		this.resizeControlEvents.push(function() {
			let safeVerMargin = 1 + scene2d.height * 0.15 / 2;
			_gthis.powerupBox.position = new h3d_Vector(_gthis.playGuiCtrl.extent.x - 171,0);
			_gthis.powerupBox.xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.powerupBox.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		});
		this.playGuiCtrl.addChild(this.powerupBox);
	}
	initTexts() {
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(26 * src_Settings.uiScale,4);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let centerTextCtrl = new gui_GuiControl();
		centerTextCtrl.position = new h3d_Vector(0,0);
		centerTextCtrl.extent = new h3d_Vector(640,480);
		centerTextCtrl.vertSizing = gui_VertSizing.Center;
		centerTextCtrl.horizSizing = gui_HorizSizing.Center;
		let centerTextBitmap = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/bgShadeCircle.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		centerTextBitmap.position = new h3d_Vector(225,142);
		centerTextBitmap.extent = new h3d_Vector(200,64);
		centerTextBitmap.vertSizing = gui_VertSizing.Bottom;
		centerTextBitmap.horizSizing = gui_HorizSizing.Left;
		this.centerTextBg = centerTextBitmap;
		centerTextCtrl.addChild(centerTextBitmap);
		let centerTextText = new gui_GuiText(coliseum);
		centerTextText.text.set_textColor(15461355);
		centerTextText.position = new h3d_Vector(0,146);
		centerTextText.extent = new h3d_Vector(640,80);
		centerTextText.vertSizing = gui_VertSizing.Bottom;
		centerTextText.horizSizing = gui_HorizSizing.Left;
		centerTextText.justify = gui_Justification.Center;
		centerTextCtrl.addChild(centerTextText);
		this.centerText = centerTextText;
		this.playGuiCtrlOuter.addChild(centerTextCtrl);
		let helpTextCtrl = new gui_GuiControl();
		helpTextCtrl.position = new h3d_Vector(0,this.playGuiCtrl.extent.y * 190 / 480);
		helpTextCtrl.extent = new h3d_Vector(640,60);
		helpTextCtrl.vertSizing = gui_VertSizing.Center;
		helpTextCtrl.horizSizing = gui_HorizSizing.Width;
		this.helpTextBackground = new gui_GuiText(arial14);
		this.helpTextBackground.text.set_textColor(0);
		this.helpTextBackground.position = new h3d_Vector(2,2);
		this.helpTextBackground.extent = new h3d_Vector(640,14);
		this.helpTextBackground.vertSizing = gui_VertSizing.Height;
		this.helpTextBackground.horizSizing = gui_HorizSizing.Width;
		this.helpTextBackground.justify = gui_Justification.Center;
		this.helpTextForeground = new gui_GuiText(arial14);
		this.helpTextForeground.text.set_textColor(15461355);
		this.helpTextForeground.position = new h3d_Vector(0,0);
		this.helpTextForeground.extent = new h3d_Vector(640,16);
		this.helpTextForeground.vertSizing = gui_VertSizing.Height;
		this.helpTextForeground.horizSizing = gui_HorizSizing.Width;
		this.helpTextForeground.justify = gui_Justification.Center;
		helpTextCtrl.addChild(this.helpTextBackground);
		helpTextCtrl.addChild(this.helpTextForeground);
		let alertTextCtrl = new gui_GuiControl();
		alertTextCtrl.position = new h3d_Vector(0,this.playGuiCtrl.extent.y * 375 / 480);
		alertTextCtrl.extent = new h3d_Vector(640,105);
		alertTextCtrl.vertSizing = gui_VertSizing.Top;
		alertTextCtrl.horizSizing = gui_HorizSizing.Width;
		this.alertTextBackground = new gui_GuiText(arial14);
		this.alertTextBackground.text.set_textColor(0);
		this.alertTextBackground.position = new h3d_Vector(2,2);
		this.alertTextBackground.extent = new h3d_Vector(640,32);
		this.alertTextBackground.vertSizing = gui_VertSizing.Height;
		this.alertTextBackground.horizSizing = gui_HorizSizing.Width;
		this.alertTextBackground.justify = gui_Justification.Center;
		this.alertTextForeground = new gui_GuiText(arial14);
		this.alertTextForeground.text.set_textColor(15461355);
		this.alertTextForeground.position = new h3d_Vector(0,0);
		this.alertTextForeground.extent = new h3d_Vector(640,32);
		this.alertTextForeground.vertSizing = gui_VertSizing.Height;
		this.alertTextForeground.horizSizing = gui_HorizSizing.Width;
		this.alertTextForeground.justify = gui_Justification.Center;
		alertTextCtrl.addChild(this.alertTextBackground);
		alertTextCtrl.addChild(this.alertTextForeground);
		this.playGuiCtrlOuter.addChild(helpTextCtrl);
		this.playGuiCtrlOuter.addChild(alertTextCtrl);
		let _gthis = this;
		this.resizeControlEvents.push(function() {
			helpTextCtrl.position = new h3d_Vector(0,_gthis.playGuiCtrl.extent.y * 190 / 480);
			alertTextCtrl.position = new h3d_Vector(0,_gthis.playGuiCtrl.extent.y * 375 / 480);
		});
	}
	initBlastBar() {
		let scene2d = src_MarbleGame.instance.scene2d;
		let safeVerMargin = 1 + scene2d.height * 0.15 / 2;
		this.blastBar = new gui_GuiControl();
		this.blastBar.position = new h3d_Vector(0,400);
		this.blastBar.extent = new h3d_Vector(170,83);
		this.blastBar.vertSizing = gui_VertSizing.Bottom;
		this.blastBar.xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.blastBar.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.playGuiCtrl.addChild(this.blastBar);
		this.blastFillBlastLess = src_ResourceLoader.getResource("data/ui/game/powerbarMaskLess.png",src_ResourceLoader.getImage,this.imageResources).toTile();
		this.blastFillBlast = src_ResourceLoader.getResource("data/ui/game/powerbarMaskBlast.png",src_ResourceLoader.getImage,this.imageResources).toTile();
		this.blastFill = new gui_GuiImage(this.blastFillBlastLess.clone());
		this.blastFill.position = new h3d_Vector(36,38);
		this.blastFill.extent = new h3d_Vector(100,27);
		this.blastFill.xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.blastFill.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.blastBar.addChild(this.blastFill);
		this.blastFillUltra = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/game/powerbarMaskUltra.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		this.blastFillUltra.position = new h3d_Vector(36,38);
		this.blastFillUltra.extent = new h3d_Vector(100,27);
		this.blastFillUltra.xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.blastFillUltra.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.blastBar.addChild(this.blastFillUltra);
		this.blastFrame = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/game/pc/powerbar.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		this.blastFrame.position = new h3d_Vector(0,0);
		this.blastFrame.extent = new h3d_Vector(170,83);
		this.blastFrame.xScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.blastFrame.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		this.blastBar.addChild(this.blastFrame);
		let _gthis = this;
		this.resizeControlEvents.push(function() {
			let safeVerMargin = 1 + scene2d.height * 0.15 / 2;
			_gthis.blastBar.xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.blastBar.yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.blastFill.xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.blastFill.yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.blastFillUltra.xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.blastFillUltra.yScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.blastFrame.xScale = (scene2d.height - safeVerMargin * 2) / 480;
			_gthis.blastFrame.yScale = (scene2d.height - safeVerMargin * 2) / 480;
		});
	}
	initChatHud() {
		this.chatCtrl = new gui_ChatCtrl();
		this.chatCtrl.position = new h3d_Vector(this.playGuiCtrl.extent.x - 201,150);
		this.chatCtrl.extent = new h3d_Vector(200,250);
		this.chatCtrl.horizSizing = gui_HorizSizing.Left;
		this.playGuiCtrl.addChild(this.chatCtrl);
	}
	setBlastValue(value) {
		if(value <= 1) {
			let oldVal = this.blastValue;
			this.blastValue = value;
			this.blastFill.bmp.tile.setSize(75 * value,20);
			let _this = this.blastFill.bmp;
			_this.posChanged = true;
			_this.scaleX = value;
			if(oldVal < 0.25 && value >= 0.25) {
				this.blastFill.bmp.tile.setTexture(this.blastFillBlast.innerTex);
				src_MarbleGame.instance.touchInput.blastbutton.setEnabled(true);
			}
			if(oldVal >= 0.25 && value < 0.25) {
				this.blastFill.bmp.tile.setTexture(this.blastFillBlastLess.innerTex);
				src_MarbleGame.instance.touchInput.blastbutton.setEnabled(false);
			}
			this.blastFillUltra.bmp.set_visible(false);
		} else {
			this.blastFillUltra.bmp.set_visible(true);
			let fillPercent = (value - 1) * 6;
			this.blastFillUltra.bmp.tile.setSize(75 * fillPercent,20);
			let _this = this.blastFillUltra.bmp;
			_this.posChanged = true;
			_this.scaleX = fillPercent;
			src_MarbleGame.instance.touchInput.blastbutton.setEnabled(true);
		}
	}
	initPlayerList() {
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(22 * src_Settings.uiScale,4);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		this.playerListContainer = new gui_GuiControl();
		this.playerListContainer.horizSizing = gui_HorizSizing.Right;
		this.playerListContainer.vertSizing = gui_VertSizing.Bottom;
		this.playerListContainer.position = new h3d_Vector(0,0);
		this.playerListContainer.extent = new h3d_Vector(392,360);
		this.playGuiCtrl.addChild(this.playerListContainer);
		let scoreBackdrop = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/game/scoreBackdrop.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		scoreBackdrop.position = new h3d_Vector(0,0);
		scoreBackdrop.extent = new h3d_Vector(386,128);
		this.playerListContainer.addChild(scoreBackdrop);
		let scorePlusMinus = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/game/scoreBackdropMinus.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		scorePlusMinus.position = new h3d_Vector(20,17);
		scorePlusMinus.extent = new h3d_Vector(22,111);
		scoreBackdrop.addChild(scorePlusMinus);
		let _gthis = this;
		let imgLoader = function(path) {
			let t;
			switch(path) {
			case "them":
				t = src_ResourceLoader.getResource("data/ui/xbox/EmptyDot.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			case "us":
				t = src_ResourceLoader.getResource("data/ui/xbox/GreenDot.png",src_ResourceLoader.getImage,_gthis.imageResources).toTile();
				break;
			default:
				return null;
			}
			if(t != null) {
				t.scaleToSize(t.width * src_Settings.uiScale,t.height * src_Settings.uiScale);
			}
			return t;
		};
		this.playerListShadowCtrl = new gui_GuiMLTextListCtrl(arial14,[],imgLoader);
		this.playerListShadowCtrl.position = new h3d_Vector(28,44);
		this.playerListShadowCtrl.extent = new h3d_Vector(392,271);
		this.playerListShadowCtrl.scrollable = true;
		this.playerListShadowCtrl.onSelectedFunc = function(sel) {
		};
		this.playerListContainer.addChild(this.playerListShadowCtrl);
		this.playerListScoresShadowCtrl = new gui_GuiMLTextListCtrl(arial14,[],imgLoader);
		this.playerListScoresShadowCtrl.position = new h3d_Vector(278,44);
		this.playerListScoresShadowCtrl.extent = new h3d_Vector(392,271);
		this.playerListScoresShadowCtrl.scrollable = true;
		this.playerListScoresShadowCtrl.onSelectedFunc = function(sel) {
		};
		this.playerListContainer.addChild(this.playerListScoresShadowCtrl);
		this.playerListCtrl = new gui_GuiMLTextListCtrl(arial14,[],imgLoader);
		this.playerListCtrl.position = new h3d_Vector(27,43);
		this.playerListCtrl.extent = new h3d_Vector(392,271);
		this.playerListCtrl.scrollable = true;
		this.playerListCtrl.onSelectedFunc = function(sel) {
		};
		this.playerListContainer.addChild(this.playerListCtrl);
		this.playerListScoresCtrl = new gui_GuiMLTextListCtrl(arial14,[],imgLoader);
		this.playerListScoresCtrl.position = new h3d_Vector(277,43);
		this.playerListScoresCtrl.extent = new h3d_Vector(392,271);
		this.playerListScoresCtrl.scrollable = true;
		this.playerListScoresCtrl.onSelectedFunc = function(sel) {
		};
		this.playerListContainer.addChild(this.playerListScoresCtrl);
	}
	redrawPlayerList() {
		let pl = [];
		let plScores = [];
		let plShadow = [];
		let plShadowScores = [];
		this.playerList.sort(function(a,b) {
			if(a.score > b.score) {
				return -1;
			} else if(a.score < b.score) {
				return 1;
			} else {
				return 0;
			}
		});
		let _g = 0;
		let _g1 = this.playerList;
		while(_g < _g1.length) {
			let item = _g1[_g];
			++_g;
			let tmp = "<font color=\"#EBEBEB\"><img src=\"" + (item.us ? "us" : "them") + "\"></img>";
			let str = item.name;
			str = str.substring(0,22);
			while(str.length < 25) str += " ";
			pl.push(tmp + str + "</font>");
			plScores.push("<font color=\"#EBEBEB\">" + item.score + "</font>");
			let str1 = item.name;
			str1 = str1.substring(0,22);
			while(str1.length < 25) str1 += " ";
			plShadow.push("<font color=\"#000000\"><img src=\"them\"></img>" + str1 + "</font>");
			plShadowScores.push("<font color=\"#000000\">" + item.score + "</font>");
		}
		this.playerListCtrl.setTexts(pl);
		this.playerListScoresCtrl.setTexts(plScores);
		this.playerListShadowCtrl.setTexts(plShadow);
		this.playerListScoresShadowCtrl.setTexts(plShadowScores);
	}
	doMPEndGameMessage() {
		this.playerList.sort(function(a,b) {
			if(a.score > b.score) {
				return -1;
			} else if(a.score < b.score) {
				return 1;
			} else {
				return 0;
			}
		});
		let p1 = this.playerList[0];
		let p2 = this.playerList.length > 1 ? this.playerList[1] : null;
		if(p2 == null) {
			let onePt = p1.score == 1;
			if(onePt) {
				src_MarbleGame.instance.world.displayAlert("" + p1.name + " won with 1 point!");
			} else {
				src_MarbleGame.instance.world.displayAlert("" + p1.name + " won with " + p1.score + " points!");
			}
		} else {
			let tie = p1.score == p2.score;
			if(tie) {
				src_MarbleGame.instance.world.displayAlert("Game tied!");
			} else {
				let onePt = p1.score == 1;
				if(onePt) {
					src_MarbleGame.instance.world.displayAlert("" + p1.name + " won with 1 point!");
				} else {
					src_MarbleGame.instance.world.displayAlert("" + p1.name + " won with " + p1.score + " points!");
				}
				if(p1.id == net_Net.clientId) {
					gui_AchievementsGui.queueMPAchievement(512);
				}
			}
			let _this = this.playerList;
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(v.id == net_Net.clientId) {
					_g.push(v);
				}
			}
			if(_g.length != 0) {
				let ourScoreReal = _g[0].score;
				if(ourScoreReal >= 75) {
					gui_AchievementsGui.queueMPAchievement(1024);
				}
				let ourLevel = src_MarbleGame.instance.world.mission;
				if(ourScoreReal >= 40) {
					if(ourLevel.path.indexOf("playground.mis") != -1 || ourLevel.path.indexOf("bowl.mis") != -1 || ourLevel.path.indexOf("concentric.mis") != -1 || ourLevel.path.indexOf("vortexeffect.mis") != -1 || ourLevel.path.indexOf("blastclub.mis") != -1) {
						gui_AchievementsGui.queueMPAchievement(8192);
					}
				}
				if(ourScoreReal >= 50 && ourLevel.path.indexOf("spires.mis") != -1) {
					gui_AchievementsGui.queueMPAchievement(16384);
				}
				if(src_Settings.playStatistics.totalMPScore >= 2000) {
					gui_AchievementsGui.queueMPAchievement(2048);
				}
			}
		}
	}
	addPlayer(id,name,us) {
		if(this.playerListCtrl != null) {
			this.playerList.push(new gui_PlayerInfo(id,name,us,0));
			this.redrawPlayerList();
		}
	}
	removePlayer(id) {
		if(this.playerListCtrl != null) {
			let _this = this.playerList;
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(v.id == id) {
					_g.push(v);
				}
			}
			if(_g.length != 0) {
				HxOverrides.remove(this.playerList,_g[0]);
			}
			this.redrawPlayerList();
		}
	}
	incrementPlayerScore(id,score) {
		let _this = this.playerList;
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this.length) {
			let v = _this[_g1];
			++_g1;
			if(v.id == id) {
				_g.push(v);
			}
		}
		if(_g.length != 0) {
			_g[0].score += score;
		}
		if(id == net_Net.clientId) {
			src_Settings.playStatistics.totalMPScore += score;
			if(score == 5 && src_MarbleGame.instance.world.mission.title == "Marble It Up!") {
				gui_AchievementsGui.queueMPAchievement(4096);
			}
			if(net_Net.isClient) {
				src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/gem_collect.wav",src_ResourceLoader.getAudio,this.soundResources));
			}
		} else if(net_Net.isClient) {
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/opponent_gem_collect.wav",src_ResourceLoader.getAudio,this.soundResources));
		}
		this.redrawPlayerList();
	}
	updatePlayerScores(scoreboardPacket) {
		let _g = 0;
		let _g1 = this.playerList;
		while(_g < _g1.length) {
			let player = _g1[_g];
			++_g;
			player.score = scoreboardPacket.scoreBoard.h.hasOwnProperty(player.id) ? scoreboardPacket.scoreBoard.h[player.id] : 0;
		}
		this.redrawPlayerList();
	}
	resetPlayerScores() {
		let _g = 0;
		let _g1 = this.playerList;
		while(_g < _g1.length) {
			let player = _g1[_g];
			++_g;
			player.score = 0;
		}
		this.redrawPlayerList();
	}
	setHelpTextOpacity(value) {
		this.helpTextForeground.text._textColorVec.w = value;
		this.helpTextBackground.text._textColorVec.w = value;
	}
	setAlertTextOpacity(value) {
		this.alertTextForeground.text._textColorVec.w = value;
		this.alertTextBackground.text._textColorVec.w = value;
	}
	setAlertText(text) {
		this.alertTextForeground.text.set_text(text);
		this.alertTextBackground.text.set_text(text);
	}
	setHelpText(text) {
		this.helpTextForeground.text.set_text(text);
		this.helpTextBackground.text.set_text(text);
	}
	setPowerupImage(powerupIdentifier) {
		if(powerupIdentifier == "SuperJump") {
			this.powerupBox.anim.set_currentFrame(2);
		} else if(powerupIdentifier == "SuperSpeed") {
			this.powerupBox.anim.set_currentFrame(4);
		} else if(powerupIdentifier == "Helicopter") {
			this.powerupBox.anim.set_currentFrame(1);
		} else if(powerupIdentifier == "MegaMarble") {
			this.powerupBox.anim.set_currentFrame(3);
		} else {
			this.powerupBox.anim.set_currentFrame(0);
		}
	}
	resizeGemCounter(total) {
		if(total >= 100) {
			this.gemCountNumbers[0].anim.set_visible(true);
			this.gemCountNumbers[1].anim.set_visible(true);
			this.gemCountNumbers[2].anim.set_visible(true);
			this.gemCountNumbers[3].anim.set_visible(true);
			this.gemCountNumbers[4].anim.set_visible(true);
			this.gemCountNumbers[5].anim.set_visible(true);
			this.gemCountNumbers[0].position.x = 20;
			this.gemCountNumbers[1].position.x = 38;
			this.gemCountNumbers[2].position.x = 56;
			this.gemCountNumbers[3].position.x = 89;
			this.gemCountNumbers[4].position.x = 107;
			this.gemCountNumbers[5].position.x = 125;
			this.gemCountSlash.position.x = 73;
			this.gemHUD.position.x = 144;
		} else if(total >= 10) {
			this.gemCountNumbers[0].anim.set_visible(false);
			this.gemCountNumbers[1].anim.set_visible(true);
			this.gemCountNumbers[2].anim.set_visible(true);
			this.gemCountNumbers[3].anim.set_visible(false);
			this.gemCountNumbers[4].anim.set_visible(true);
			this.gemCountNumbers[5].anim.set_visible(true);
			this.gemCountNumbers[2].position.x = 32;
			this.gemCountNumbers[5].position.x = 83;
			this.gemCountNumbers[1].position.x = 14;
			this.gemCountNumbers[4].position.x = 65;
			this.gemCountSlash.position.x = 49;
			this.gemHUD.position.x = 101;
		} else {
			this.gemCountNumbers[0].anim.set_visible(false);
			this.gemCountNumbers[1].anim.set_visible(false);
			this.gemCountNumbers[2].anim.set_visible(true);
			this.gemCountNumbers[3].anim.set_visible(false);
			this.gemCountNumbers[4].anim.set_visible(false);
			this.gemCountNumbers[5].anim.set_visible(true);
			this.gemCountNumbers[2].position.x = 8;
			this.gemCountNumbers[5].position.x = 41;
			this.gemCountSlash.position.x = 25;
			this.gemHUD.position.x = 59;
		}
		this.gemHUD.parent.render(this.scene2d,this.gemHUD.parent.parent._flow);
	}
	resizeGemHuntCounter(total) {
		if(total >= 100) {
			this.gemCountNumbers[0].anim.set_visible(true);
			this.gemCountNumbers[1].anim.set_visible(true);
			this.gemCountNumbers[2].anim.set_visible(true);
			this.gemCountNumbers[0].position.x = 20;
			this.gemCountNumbers[1].position.x = 38;
			this.gemCountNumbers[2].position.x = 56;
		} else if(total >= 10) {
			this.gemCountNumbers[0].anim.set_visible(false);
			this.gemCountNumbers[1].anim.set_visible(true);
			this.gemCountNumbers[2].anim.set_visible(true);
			this.gemCountNumbers[0].position.x = 20;
			this.gemCountNumbers[1].position.x = 38;
			this.gemCountNumbers[2].position.x = 56;
		} else {
			this.gemCountNumbers[0].anim.set_visible(false);
			this.gemCountNumbers[1].anim.set_visible(false);
			this.gemCountNumbers[2].anim.set_visible(true);
			this.gemCountNumbers[0].position.x = 20;
			this.gemCountNumbers[1].position.x = 38;
			this.gemCountNumbers[2].position.x = 56;
		}
		this.gemHUD.position.x = 74;
		this.gemHUD.parent.render(this.scene2d,this.gemHUD.parent.parent._flow);
	}
	formatGemCounter(collected,total) {
		if(src_MarbleGame.instance.world.isMultiplayer) {
			return;
		}
		if(total == 0) {
			let _g = 0;
			let _g1 = this.gemCountNumbers;
			while(_g < _g1.length) {
				let number = _g1[_g];
				++_g;
				number.anim.set_visible(false);
			}
			this.gemCountSlash.bmp.set_visible(false);
			this.gemHUD.bmp.set_visible(false);
		} else {
			if(this.totalGems != total) {
				this.resizeGemCounter(total);
				this.totalGems = total;
			}
			this.gemCountSlash.bmp.set_visible(true);
			this.gemHUD.bmp.set_visible(true);
		}
		let totalHundredths = Math.floor(total / 100);
		let totalTenths = Math.floor(total / 10) % 10;
		let totalOnes = total % 10;
		let collectedHundredths = Math.floor(collected / 100);
		let collectedTenths = Math.floor(collected / 10) % 10;
		let collectedOnes = collected % 10;
		this.gemCountNumbers[0].anim.set_currentFrame(collectedHundredths);
		this.gemCountNumbers[1].anim.set_currentFrame(collectedTenths);
		this.gemCountNumbers[2].anim.set_currentFrame(collectedOnes);
		this.gemCountNumbers[3].anim.set_currentFrame(totalHundredths);
		this.gemCountNumbers[4].anim.set_currentFrame(totalTenths);
		this.gemCountNumbers[5].anim.set_currentFrame(totalOnes);
	}
	formatGemHuntCounter(collected) {
		if(src_MarbleGame.instance.world.isMultiplayer) {
			return;
		}
		this.gemCountNumbers[0].anim.set_visible(true);
		this.gemCountNumbers[1].anim.set_visible(true);
		this.gemCountNumbers[2].anim.set_visible(true);
		this.gemCountNumbers[3].anim.set_visible(false);
		this.gemCountNumbers[4].anim.set_visible(false);
		this.gemCountNumbers[5].anim.set_visible(false);
		this.gemHUD.bmp.set_visible(true);
		let collectedHundredths = Math.floor(collected / 100);
		let collectedTenths = Math.floor(collected / 10) % 10;
		let collectedOnes = collected % 10;
		this.gemCountNumbers[0].anim.set_currentFrame(collectedHundredths);
		this.gemCountNumbers[1].anim.set_currentFrame(collectedTenths);
		this.gemCountNumbers[2].anim.set_currentFrame(collectedOnes);
		this.resizeGemHuntCounter(collected);
	}
	formatTimer(time) {
		if(time < 0) {
			time = 0;
		}
		let et = time * 1000;
		let thousandth = et % 10;
		let hundredth = Math.floor(et % 1000 / 10);
		let totalSeconds = Math.floor(et / 1000);
		let seconds = totalSeconds % 60;
		let minutes = (totalSeconds - seconds) / 60;
		let secondsOne = seconds % 10;
		let secondsTen = (seconds - secondsOne) / 10;
		let minutesOne = minutes % 10;
		let minutesTen = (minutes - minutesOne) / 10 % 10;
		let hundredthOne = hundredth % 10;
		let hundredthTen = (hundredth - hundredthOne) / 10;
		this.timerNumbers[0].anim.set_currentFrame(minutesTen);
		this.timerNumbers[1].anim.set_currentFrame(minutesOne);
		this.timerNumbers[2].anim.set_currentFrame(secondsTen);
		this.timerNumbers[3].anim.set_currentFrame(secondsOne);
		this.timerNumbers[4].anim.set_currentFrame(hundredthTen);
		this.timerNumbers[5].anim.set_currentFrame(hundredthOne);
		this.timerNumbers[6].anim.set_currentFrame(thousandth);
	}
	render(engine) {
	}
	update(timeState) {
		if(this.fpsMeter != null) {
			this.fpsMeter.text.set_text("" + Math.floor(src_ProfilerUI.instance.fps) + " fps");
		}
		this.updateMiddleMessages(timeState.dt);
		if(net_Net.isMP) {
			this.chatCtrl.updateChat(timeState.dt);
		}
	}
	updateMiddleMessages(dt) {
		let itermessages = this.middleMessages.slice();
		while(itermessages.length > 0) {
			let thismsg = itermessages.shift();
			thismsg.age += dt;
			if(thismsg.age > 3) {
				HxOverrides.remove(this.middleMessages,thismsg);
				thismsg.ctrl.parent.removeChild(thismsg.ctrl);
				thismsg.ctrl2.parent.removeChild(thismsg.ctrl2);
			} else {
				let t = thismsg.age;
				thismsg.ctrl.text.alpha = 1 - thismsg.age / 3;
				let _this = thismsg.ctrl.text;
				_this.posChanged = true;
				_this.y = thismsg.yPos - (-16.5 * t * t + 100 * t);
				thismsg.ctrl2.text.alpha = 1 - thismsg.age / 3;
				let _this1 = thismsg.ctrl2.text;
				_this1.posChanged = true;
				_this1.y = thismsg.yPos - (-16.5 * t * t + 100 * t);
			}
		}
	}
	addMiddleMessage(text,color) {
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(33 * src_Settings.uiScale,4);
		let middleMsg = new gui_GuiText(arial14);
		middleMsg.position = new h3d_Vector(199,49);
		middleMsg.extent = new h3d_Vector(400,100);
		middleMsg.horizSizing = gui_HorizSizing.Center;
		middleMsg.vertSizing = gui_VertSizing.Center;
		middleMsg.text.set_text(text);
		middleMsg.justify = gui_Justification.Center;
		middleMsg.text.set_textColor(0);
		this.playGuiCtrl.addChild(middleMsg);
		middleMsg.render(this.scene2d,this.playGuiCtrl._flow);
		let fh = middleMsg.text;
		fh.posChanged = true;
		fh.y -= 25 / this.playGuiCtrl.extent.y * this.scene2d.height;
		let middleMsg2 = new gui_GuiText(arial14);
		middleMsg2.position = new h3d_Vector(200,50);
		middleMsg2.extent = new h3d_Vector(400,100);
		middleMsg2.horizSizing = gui_HorizSizing.Center;
		middleMsg2.vertSizing = gui_VertSizing.Center;
		middleMsg2.text.set_text(text);
		middleMsg2.justify = gui_Justification.Center;
		middleMsg2.text.set_textColor(color);
		this.playGuiCtrl.addChild(middleMsg2);
		middleMsg2.render(this.scene2d,this.playGuiCtrl._flow);
		let fh1 = middleMsg2.text;
		fh1.posChanged = true;
		fh1.y -= 25 / this.playGuiCtrl.extent.y * this.scene2d.height;
		this.middleMessages.push(new gui_MiddleMessage(middleMsg,middleMsg2,0,middleMsg.text.y));
	}
	setGuiVisibility(show) {
		if(show) {
			if(this.pgoChildren.length != 0) {
				let _g = 0;
				let _g1 = this.pgoChildren;
				while(_g < _g1.length) {
					let ch = _g1[_g];
					++_g;
					this.playGuiCtrlOuter.addChild(ch);
				}
				if(src_Util.isTouchDevice()) {
					src_MarbleGame.instance.touchInput.showControls(this.playGuiCtrlOuter,true);
				}
				this.playGuiCtrlOuter.render(src_MarbleGame.canvas.scene2d);
				this.pgoChildren = [];
			}
		} else {
			this.pgoChildren = this.playGuiCtrlOuter.children.slice();
			this.playGuiCtrlOuter.removeChildren();
			this.playGuiCtrlOuter.render(src_MarbleGame.canvas.scene2d);
		}
	}
}
$hxClasses["gui.PlayGui"] = gui_PlayGui;
gui_PlayGui.__name__ = "gui.PlayGui";
Object.assign(gui_PlayGui.prototype, {
	__class__: gui_PlayGui
	,scene2d: null
	,timerNumbers: null
	,timerPoint: null
	,timerColon: null
	,gemCountNumbers: null
	,gemCountSlash: null
	,gemHUD: null
	,powerupBox: null
	,centerText: null
	,centerTextBg: null
	,helpTextForeground: null
	,helpTextBackground: null
	,alertTextForeground: null
	,alertTextBackground: null
	,blastBar: null
	,blastFill: null
	,blastFillUltra: null
	,blastFrame: null
	,blastFillBlast: null
	,blastFillBlastLess: null
	,playerListContainer: null
	,playerListCtrl: null
	,playerListScoresCtrl: null
	,playerListShadowCtrl: null
	,playerListScoresShadowCtrl: null
	,playerList: null
	,imageResources: null
	,textureResources: null
	,soundResources: null
	,playGuiCtrlOuter: null
	,playGuiCtrl: null
	,chatCtrl: null
	,resizeEv: null
	,resizeControlEvents: null
	,_init: null
	,fpsMeter: null
	,middleMessages: null
	,totalGems: null
	,blastValue: null
	,pgoChildren: null
});
class gui_PresentsGui extends gui_GuiImage {
	constructor() {
		let img = src_ResourceLoader.getImage("data/ui/EngineSplashBG.jpg");
		super(img.resource.toTile());
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let ggLogo = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/GG_logo.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		ggLogo.horizSizing = gui_HorizSizing.Center;
		ggLogo.vertSizing = gui_VertSizing.Center;
		ggLogo.position = new h3d_Vector(69,99);
		ggLogo.extent = new h3d_Vector(500,383);
		this.addChild(ggLogo);
	}
}
$hxClasses["gui.PresentsGui"] = gui_PresentsGui;
gui_PresentsGui.__name__ = "gui.PresentsGui";
gui_PresentsGui.__super__ = gui_GuiImage;
Object.assign(gui_PresentsGui.prototype, {
	__class__: gui_PresentsGui
});
class gui_Rect {
	constructor(position,extent) {
		this.position = new h3d_Vector(position.x,position.y,position.z,position.w);
		this.extent = new h3d_Vector(extent.x,extent.y,extent.z,extent.w);
		this.scroll = new h3d_Vector();
	}
	inRect(point) {
		if(this.position.x < point.x && this.position.x + this.extent.x > point.x) {
			if(this.position.y < point.y) {
				return this.position.y + this.extent.y > point.y;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	intersect(other) {
		let rectangle = new h2d_col_Bounds();
		let x = this.position.x;
		let y = this.position.y;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let p_x = x;
		let p_y = y;
		if(p_x < rectangle.xMin) {
			rectangle.xMin = p_x;
		}
		if(p_x > rectangle.xMax) {
			rectangle.xMax = p_x;
		}
		if(p_y < rectangle.yMin) {
			rectangle.yMin = p_y;
		}
		if(p_y > rectangle.yMax) {
			rectangle.yMax = p_y;
		}
		let x1 = this.position.x + this.extent.x;
		let y1 = this.position.y + this.extent.y;
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let p_x1 = x1;
		let p_y1 = y1;
		if(p_x1 < rectangle.xMin) {
			rectangle.xMin = p_x1;
		}
		if(p_x1 > rectangle.xMax) {
			rectangle.xMax = p_x1;
		}
		if(p_y1 < rectangle.yMin) {
			rectangle.yMin = p_y1;
		}
		if(p_y1 > rectangle.yMax) {
			rectangle.yMax = p_y1;
		}
		let otherrectangle = new h2d_col_Bounds();
		let x2 = other.position.x;
		let y2 = other.position.y;
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let p_x2 = x2;
		let p_y2 = y2;
		if(p_x2 < otherrectangle.xMin) {
			otherrectangle.xMin = p_x2;
		}
		if(p_x2 > otherrectangle.xMax) {
			otherrectangle.xMax = p_x2;
		}
		if(p_y2 < otherrectangle.yMin) {
			otherrectangle.yMin = p_y2;
		}
		if(p_y2 > otherrectangle.yMax) {
			otherrectangle.yMax = p_y2;
		}
		let x3 = other.position.x + other.extent.x;
		let y3 = other.position.y + other.extent.y;
		if(y3 == null) {
			y3 = 0.;
		}
		if(x3 == null) {
			x3 = 0.;
		}
		let p_x3 = x3;
		let p_y3 = y3;
		if(p_x3 < otherrectangle.xMin) {
			otherrectangle.xMin = p_x3;
		}
		if(p_x3 > otherrectangle.xMax) {
			otherrectangle.xMax = p_x3;
		}
		if(p_y3 < otherrectangle.yMin) {
			otherrectangle.yMin = p_y3;
		}
		if(p_y3 > otherrectangle.yMax) {
			otherrectangle.yMax = p_y3;
		}
		let isec = rectangle.intersection(otherrectangle);
		return new gui_Rect(new h3d_Vector(isec.xMin,isec.yMin),new h3d_Vector(isec.xMax - isec.xMin,isec.yMax - isec.yMin));
	}
}
$hxClasses["gui.Rect"] = gui_Rect;
gui_Rect.__name__ = "gui.Rect";
Object.assign(gui_Rect.prototype, {
	__class__: gui_Rect
	,position: null
	,extent: null
	,scroll: null
});
class gui_RemapDlg extends gui_GuiImage {
	constructor(bindingName) {
		let res = src_ResourceLoader.getImage("data/ui/xbox/roundedBG.png").resource.toTile();
		super(res);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		let remapDlg = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/popupGUI.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		remapDlg.horizSizing = gui_HorizSizing.Center;
		remapDlg.vertSizing = gui_VertSizing.Center;
		remapDlg.position = new h3d_Vector(70,30);
		remapDlg.extent = new h3d_Vector(512,400);
		this.addChild(remapDlg);
		let remapText = new gui_GuiMLText(arial14,null);
		remapText.position = new h3d_Vector(103,85);
		remapText.extent = new h3d_Vector(313,186);
		remapText.text.set_textColor(15461355);
		remapText.text.set_text("<p align=\"center\">Press a new key or button for <br/>\"" + bindingName + "\"</p>");
		remapDlg.addChild(remapText);
	}
	update(dt,mouseState) {
		super.update(dt,mouseState);
		let _g = 0;
		while(_g < 1024) {
			let i = _g++;
			if(i == 6 || i == 5) {
				continue;
			}
			if(hxd_Key.isPressed(i)) {
				this.remapCallback(i);
			}
		}
	}
}
$hxClasses["gui.RemapDlg"] = gui_RemapDlg;
gui_RemapDlg.__name__ = "gui.RemapDlg";
gui_RemapDlg.__super__ = gui_GuiImage;
Object.assign(gui_RemapDlg.prototype, {
	__class__: gui_RemapDlg
	,remapCallback: null
});
class gui_ReplayNameDlg extends gui_GuiImage {
	constructor(callback) {
		let res = src_ResourceLoader.getImage("data/ui/xbox/roundedBG.png").resource.toTile();
		super(res);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		let yesNoFrame = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/popupGUI.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		yesNoFrame.horizSizing = gui_HorizSizing.Center;
		yesNoFrame.vertSizing = gui_VertSizing.Center;
		yesNoFrame.position = new h3d_Vector(70,30);
		yesNoFrame.extent = new h3d_Vector(512,400);
		this.addChild(yesNoFrame);
		let yesNoText = new gui_GuiMLText(arial14,null);
		yesNoText.position = new h3d_Vector(103,85);
		yesNoText.extent = new h3d_Vector(313,186);
		yesNoText.text.set_text("Enter a name for the recording");
		yesNoText.text.set_textColor(15461355);
		yesNoFrame.addChild(yesNoText);
		let textFrame = new gui_GuiControl();
		textFrame.position = new h3d_Vector(33,107);
		textFrame.extent = new h3d_Vector(232,40);
		textFrame.horizSizing = gui_HorizSizing.Center;
		yesNoFrame.addChild(textFrame);
		let textInput = new gui_GuiTextInput(arial14);
		textInput.position = new h3d_Vector(6,5);
		textInput.extent = new h3d_Vector(216,40);
		textInput.horizSizing = gui_HorizSizing.Width;
		textInput.vertSizing = gui_VertSizing.Height;
		textInput.text.set_textColor(15461355);
		textInput.setCaretColor(15461355);
		let _this = textInput.text.selectionColor;
		_this.x = 0.55294117647058827;
		_this.y = 1.;
		_this.z = 0.55294117647058827;
		_this.w = 0.;
		textInput.text.selectionTile = h2d_Tile.fromColor(8961262,0,Math.ceil(textInput.text.font.lineHeight));
		textFrame.addChild(textInput);
		textInput.text.set_text(src_MarbleGame.instance.world.mission.title);
		if(src_MarbleGame.instance.world.finishTime == null) {
			let fh = textInput.text;
			fh.set_text(fh.text + " Unfinished Run");
		} else {
			let fh = textInput.text;
			fh.set_text(fh.text + (" " + src_MarbleGame.instance.world.gameMode.getFinishScore()));
		}
		let okButton = new gui_GuiXboxButton("Ok",120);
		okButton.position = new h3d_Vector(211,248);
		okButton.extent = new h3d_Vector(120,94);
		okButton.vertSizing = gui_VertSizing.Top;
		okButton.accelerators = [13];
		okButton.gamepadAccelerator = ["A"];
		let _gthis = this;
		okButton.pressedAction = function(sender) {
			if(StringTools.trim(textInput.text.text) != "") {
				src_MarbleGame.instance.recordingName = textInput.text.text;
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.instance.world.saveReplay();
				callback();
			}
		};
		yesNoFrame.addChild(okButton);
		let cancelButton = new gui_GuiXboxButton("Cancel",120);
		cancelButton.position = new h3d_Vector(321,248);
		cancelButton.extent = new h3d_Vector(120,94);
		cancelButton.vertSizing = gui_VertSizing.Top;
		cancelButton.accelerators = [13];
		cancelButton.gamepadAccelerator = ["A"];
		cancelButton.pressedAction = function(sender) {
			src_MarbleGame.canvas.popDialog(_gthis);
			callback();
		};
		yesNoFrame.addChild(cancelButton);
	}
}
$hxClasses["gui.ReplayNameDlg"] = gui_ReplayNameDlg;
gui_ReplayNameDlg.__name__ = "gui.ReplayNameDlg";
gui_ReplayNameDlg.__super__ = gui_GuiImage;
Object.assign(gui_ReplayNameDlg.prototype, {
	__class__: gui_ReplayNameDlg
});
class gui_TouchCtrlsEditGui extends gui_GuiImage {
	constructor(paused) {
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("TOUCH CONTROLS");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let nextButton = new gui_GuiXboxButton("Save",160);
		nextButton.position = new h3d_Vector(960,100);
		nextButton.vertSizing = gui_VertSizing.Bottom;
		nextButton.horizSizing = gui_HorizSizing.Right;
		nextButton.gamepadAccelerator = ["A"];
		nextButton.accelerators = [13];
		let _gthis = this;
		nextButton.pressedAction = function(e) {
			if(paused) {
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.canvas.pushDialog(new gui_TouchOptionsGui(true));
			} else {
				src_MarbleGame.canvas.setContent(new gui_TouchOptionsGui());
			}
		};
		this.innerCtrl.addChild(nextButton);
		let joystick = new touch_MovementInputEdit();
		let jumpBtn = src_Settings.touchSettings.jumpButtonPos[0];
		let jumpBtn1 = src_Settings.touchSettings.jumpButtonPos[1];
		let jumpBtn2 = new touch_TouchEditButton(src_ResourceLoader.getImage("data/ui/touch/up-arrow.png").resource,new h3d_Vector(jumpBtn,jumpBtn1),src_Settings.touchSettings.jumpButtonSize);
		let powerupBtn = src_Settings.touchSettings.powerupButtonPos[0];
		let powerupBtn1 = src_Settings.touchSettings.powerupButtonPos[1];
		let powerupBtn2 = new touch_TouchEditButton(src_ResourceLoader.getImage("data/ui/touch/energy.png").resource,new h3d_Vector(powerupBtn,powerupBtn1),src_Settings.touchSettings.powerupButtonSize);
		let blastBtn = src_Settings.touchSettings.blastButtonPos[0];
		let blastBtn1 = src_Settings.touchSettings.blastButtonPos[1];
		let blastBtn2 = new touch_TouchEditButton(src_ResourceLoader.getImage("data/ui/touch/explosion.png").resource,new h3d_Vector(blastBtn,blastBtn1),src_Settings.touchSettings.blastButtonSize);
		let rewindBtn = src_Settings.touchSettings.rewindButtonPos[0];
		let rewindBtn1 = src_Settings.touchSettings.rewindButtonPos[1];
		let rewindBtn2 = new touch_TouchEditButton(src_ResourceLoader.getImage("data/ui/touch/rewind.png").resource,new h3d_Vector(rewindBtn,rewindBtn1),src_Settings.touchSettings.rewindButtonSize);
		jumpBtn2.onClick = function(sender,mousePos) {
			sender.setSelected(true);
			powerupBtn2.setSelected(false);
			joystick.setSelected(false);
			blastBtn2.setSelected(false);
			rewindBtn2.setSelected(false);
		};
		jumpBtn2.onChangeCb = function(sender,value,rvalue) {
			src_Settings.touchSettings.jumpButtonPos = [value.x,value.y];
			src_Settings.touchSettings.jumpButtonSize = rvalue;
		};
		powerupBtn2.onClick = function(sender,mousePos) {
			sender.setSelected(true);
			jumpBtn2.setSelected(false);
			joystick.setSelected(false);
			blastBtn2.setSelected(false);
			rewindBtn2.setSelected(false);
		};
		powerupBtn2.onChangeCb = function(sender,value,rvalue) {
			src_Settings.touchSettings.powerupButtonPos = [value.x,value.y];
			src_Settings.touchSettings.powerupButtonSize = rvalue;
		};
		blastBtn2.onClick = function(sender,mousePos) {
			sender.setSelected(true);
			jumpBtn2.setSelected(false);
			powerupBtn2.setSelected(false);
			joystick.setSelected(false);
			rewindBtn2.setSelected(false);
		};
		blastBtn2.onChangeCb = function(sender,value,rvalue) {
			src_Settings.touchSettings.blastButtonPos = [value.x,value.y];
			src_Settings.touchSettings.blastButtonSize = rvalue;
		};
		rewindBtn2.onClick = function(sender,mousePos) {
			sender.setSelected(true);
			jumpBtn2.setSelected(false);
			powerupBtn2.setSelected(false);
			joystick.setSelected(false);
			blastBtn2.setSelected(false);
		};
		rewindBtn2.onChangeCb = function(sender,value,rvalue) {
			src_Settings.touchSettings.rewindButtonPos = [value.x,value.y];
			src_Settings.touchSettings.rewindButtonSize = rvalue;
		};
		joystick.onClick = function(mousePos) {
			joystick.setSelected(true);
			jumpBtn2.setSelected(false);
			powerupBtn2.setSelected(false);
			blastBtn2.setSelected(false);
			rewindBtn2.setSelected(false);
		};
		joystick.onChangeCb = function(value,rvalue) {
			src_Settings.touchSettings.joystickPos = [value.x,value.y];
			src_Settings.touchSettings.joystickSize = rvalue;
		};
		this.addChild(joystick);
		this.addChild(jumpBtn2);
		this.addChild(powerupBtn2);
		this.addChild(blastBtn2);
		this.addChild(rewindBtn2);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.TouchCtrlsEditGui"] = gui_TouchCtrlsEditGui;
gui_TouchCtrlsEditGui.__name__ = "gui.TouchCtrlsEditGui";
gui_TouchCtrlsEditGui.__super__ = gui_GuiImage;
Object.assign(gui_TouchCtrlsEditGui.prototype, {
	__class__: gui_TouchCtrlsEditGui
	,innerCtrl: null
});
class gui_TouchOptionsGui extends gui_GuiImage {
	constructor(pauseGui) {
		if(pauseGui == null) {
			pauseGui = false;
		}
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("TOUCH OPTIONS");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let optionCollection = new gui_GuiXboxOptionsListCollection();
		optionCollection.position = new h3d_Vector(380,160);
		optionCollection.extent = new h3d_Vector(815,500);
		this.innerCtrl.addChild(optionCollection);
		let dynamicJoystick = optionCollection.addOption(1,"Joystick Position",["Fixed","Dynamic"],function(idx) {
			src_Settings.touchSettings.dynamicJoystick = idx == 1;
			return true;
		},0.5,118);
		dynamicJoystick.setCurrentOption(src_Settings.touchSettings.dynamicJoystick ? 1 : 0);
		let cameraMultiplier = optionCollection.addOption(1,"Button-Camera Factor",["0.5","1","1.5","2","2.5","3","3.5"],function(idx) {
			src_Settings.touchSettings.buttonJoystickMultiplier = 0.5 + idx * 0.5;
			return true;
		},0.5,118);
		let value = (src_Settings.touchSettings.buttonJoystickMultiplier - 0.5) / 0.5;
		cameraMultiplier.setCurrentOption((value < 0 ? 0 : value > 6 ? 6 : value) | 0);
		let swipeExtent = optionCollection.addOption(1,"Camera Swipe Extent",["5","10","15","20","25","30","35"],function(idx) {
			src_Settings.touchSettings.cameraSwipeExtent = 5 + idx * 5;
			return true;
		},0.5,118);
		let value1 = (src_Settings.touchSettings.cameraSwipeExtent - 5) / 5;
		swipeExtent.setCurrentOption((value1 < 0 ? 0 : value1 > 6 ? 6 : value1) | 0);
		let hideCtrls = optionCollection.addOption(1,"Hide Controls",["No","Yes"],function(idx) {
			src_Settings.touchSettings.hideControls = idx == 1;
			return true;
		},0.5,118);
		hideCtrls.setCurrentOption(src_Settings.touchSettings.hideControls ? 1 : 0);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Ok",160);
		backButton.position = new h3d_Vector(960,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["A"];
		backButton.accelerators = [13];
		let _gthis = this;
		if(pauseGui) {
			backButton.pressedAction = function(e) {
				src_Settings.applySettings();
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.canvas.pushDialog(new gui_OptionsListGui(true));
			};
		} else {
			backButton.pressedAction = function(e) {
				src_Settings.applySettings();
				src_MarbleGame.canvas.setContent(new gui_OptionsListGui());
			};
		}
		bottomBar.addChild(backButton);
		if(!pauseGui) {
			let ctrlButton = new gui_GuiXboxButton("Edit Controls",220);
			ctrlButton.position = new h3d_Vector(750,0);
			ctrlButton.vertSizing = gui_VertSizing.Bottom;
			ctrlButton.horizSizing = gui_HorizSizing.Right;
			ctrlButton.gamepadAccelerator = ["Y"];
			ctrlButton.pressedAction = function(e) {
				src_MarbleGame.canvas.setContent(new gui_TouchCtrlsEditGui(pauseGui));
			};
			bottomBar.addChild(ctrlButton);
		}
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.TouchOptionsGui"] = gui_TouchOptionsGui;
gui_TouchOptionsGui.__name__ = "gui.TouchOptionsGui";
gui_TouchOptionsGui.__super__ = gui_GuiImage;
Object.assign(gui_TouchOptionsGui.prototype, {
	__class__: gui_TouchOptionsGui
	,innerCtrl: null
});
class gui_VersionGui extends gui_GuiImage {
	constructor() {
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("CHANGELOG");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let wnd = new gui_GuiImage(src_ResourceLoader.getResource("data/ui/xbox/helpWindow.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		wnd.position = new h3d_Vector(260,107);
		wnd.extent = new h3d_Vector(736,460);
		wnd.horizSizing = gui_HorizSizing.Right;
		wnd.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(wnd);
		let arial14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
		let arial14b = new hxd_res_BitmapFont(arial14fontdata.entry);
		arial14b.loader = src_ResourceLoader.loader;
		let arial14 = arial14b.toSdfFont(21 * src_Settings.uiScale,4);
		let arial14big = arial14b.toSdfFont(30 * src_Settings.uiScale,4);
		let arial14med = arial14b.toSdfFont(26 * src_Settings.uiScale,4);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Ok",160);
		backButton.position = new h3d_Vector(960,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["A"];
		backButton.accelerators = [13];
		backButton.pressedAction = function(e) {
			src_MarbleGame.canvas.setContent(new gui_MainMenuGui());
		};
		bottomBar.addChild(backButton);
		let textCtrl = new gui_GuiConsoleScrollCtrl(src_ResourceLoader.getResource("data/ui/common/osxscroll.png",src_ResourceLoader.getImage,this.imageResources).toTile());
		textCtrl.position = new h3d_Vector(30,33);
		textCtrl.extent = new h3d_Vector(683,403);
		textCtrl.scrollToBottom = false;
		wnd.addChild(textCtrl);
		let mlFontLoader = function(text) {
			switch(text) {
			case "ArialBig":
				return arial14big;
			case "ArialMed":
				return arial14med;
			default:
				return arial14;
			}
		};
		let wndTxtBg = new gui_GuiMLText(arial14,mlFontLoader);
		wndTxtBg.position = new h3d_Vector(2,7);
		wndTxtBg.extent = new h3d_Vector(683,343);
		wndTxtBg.text.set_textColor(1052688);
		wndTxtBg.text.set_text("Loading changelog, please wait.<br/>");
		wndTxtBg.scrollable = true;
		textCtrl.addChild(wndTxtBg);
		let wndTxt = new gui_GuiMLText(arial14,mlFontLoader);
		wndTxt.position = new h3d_Vector(0,5);
		wndTxt.extent = new h3d_Vector(683,343);
		wndTxt.text.set_textColor(15461355);
		wndTxt.text.set_text("Loading changelog, please wait.<br/>");
		wndTxt.scrollable = true;
		textCtrl.addChild(wndTxt);
		src_Http.get("https://raw.githubusercontent.com/RandomityGuy/MBHaxe/mbu-port/CHANGELOG.md",function(res) {
			let mdtext = res.toString();
			let res1 = "";
			wndTxt.text.set_text("");
			wndTxtBg.text.set_text("");
			let _g = 0;
			let _g1 = mdtext.split("\n");
			while(_g < _g1.length) {
				let line = _g1[_g];
				++_g;
				if(line.startsWith("#")) {
					line = StringTools.replace(line,"#","");
					line = "<font face=\"ArialMed\">" + line + "</font>";
				}
				res1 += line + "<br/>";
			}
			let fh = wndTxt.text;
			fh.set_text(fh.text + res1);
			let fh1 = wndTxtBg.text;
			fh1.set_text(fh1.text + res1);
			textCtrl.setScrollMax(wndTxt.text.get_textHeight());
		},function(e) {
			wndTxt.text.set_text("Failed to fetch changelog.");
			wndTxtBg.text.set_text("Failed to fetch changelog.");
		});
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
	static checkVersion() {
		src_Http.get("https://raw.githubusercontent.com/RandomityGuy/MBHaxe/mbu-port/CHANGELOG.md",function(res) {
			let mdtext = res.toString();
			let firstline = mdtext.split("\n")[0];
			firstline = StringTools.replace(firstline,"#","");
			firstline = StringTools.trim(firstline);
			if(firstline != src_MarbleGame.currentVersion) {
				let mbo = new gui_MessageBoxOkDlg("New version available! Please update your game.");
				src_MarbleGame.canvas.pushDialog(mbo);
			}
		},function(e) {
		});
	}
}
$hxClasses["gui.VersionGui"] = gui_VersionGui;
gui_VersionGui.__name__ = "gui.VersionGui";
gui_VersionGui.__super__ = gui_GuiImage;
Object.assign(gui_VersionGui.prototype, {
	__class__: gui_VersionGui
	,innerCtrl: null
});
class gui_VideoOptionsGui extends gui_GuiImage {
	constructor(pauseGui) {
		if(pauseGui == null) {
			pauseGui = false;
		}
		let res = src_ResourceLoader.getImage("data/ui/xbox/BG_fadeOutSoftEdge.png").resource.toTile();
		super(res);
		let domcasual32fontdata = src_ResourceLoader.getFileEntry("data/font/DomCasualD.fnt");
		let domcasual32b = new hxd_res_BitmapFont(domcasual32fontdata.entry);
		domcasual32b.loader = src_ResourceLoader.loader;
		domcasual32b.toSdfFont(42 * src_Settings.uiScale,4);
		this.horizSizing = gui_HorizSizing.Width;
		this.vertSizing = gui_VertSizing.Height;
		this.position = new h3d_Vector();
		this.extent = new h3d_Vector(640,480);
		let scene2d = src_MarbleGame.instance.scene2d;
		let offsetX = (scene2d.width - 1280) / 2;
		let offsetY = (scene2d.height - 720) / 2;
		let subX = 640 - (scene2d.width - offsetX) * 640 / scene2d.width;
		let subY = 480 - (scene2d.height - offsetY) * 480 / scene2d.height;
		this.innerCtrl = new gui_GuiControl();
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		this.innerCtrl.horizSizing = gui_HorizSizing.Width;
		this.innerCtrl.vertSizing = gui_VertSizing.Height;
		this.addChild(this.innerCtrl);
		let coliseumfontdata = src_ResourceLoader.getFileEntry("data/font/ColiseumRR.fnt");
		let coliseumb = new hxd_res_BitmapFont(coliseumfontdata.entry);
		coliseumb.loader = src_ResourceLoader.loader;
		let coliseum = coliseumb.toSdfFont(44 * src_Settings.uiScale,4);
		let rootTitle = new gui_GuiText(coliseum);
		rootTitle.position = new h3d_Vector(100,30);
		rootTitle.extent = new h3d_Vector(1120,80);
		rootTitle.text.set_textColor(16777215);
		rootTitle.text.set_text("VIDEO OPTIONS");
		rootTitle.text.alpha = 0.5;
		this.innerCtrl.addChild(rootTitle);
		let optionCollection = new gui_GuiXboxOptionsListCollection();
		optionCollection.position = new h3d_Vector(380,160);
		optionCollection.extent = new h3d_Vector(815,500);
		this.innerCtrl.addChild(optionCollection);
		let resolutionOpt = optionCollection.addOption(1,"Fullscreen Res",["1024 x 800","1280 x 720","1366 x 768","1440 x 900","1600 x 900","1920 x 1080"],function(idx) {
			switch(idx) {
			case 0:
				src_Settings.optionsSettings.screenWidth = 1024;
				src_Settings.optionsSettings.screenHeight = 800;
				break;
			case 1:
				src_Settings.optionsSettings.screenWidth = 1280;
				src_Settings.optionsSettings.screenHeight = 720;
				break;
			case 2:
				src_Settings.optionsSettings.screenWidth = 1366;
				src_Settings.optionsSettings.screenHeight = 768;
				break;
			case 3:
				src_Settings.optionsSettings.screenWidth = 1440;
				src_Settings.optionsSettings.screenHeight = 900;
				break;
			case 4:
				src_Settings.optionsSettings.screenWidth = 1600;
				src_Settings.optionsSettings.screenHeight = 900;
				break;
			case 5:
				src_Settings.optionsSettings.screenWidth = 1920;
				src_Settings.optionsSettings.screenHeight = 1080;
				break;
			}
			return true;
		},0.35);
		resolutionOpt.optionText.text.set_text("" + src_Settings.optionsSettings.screenWidth + " x " + src_Settings.optionsSettings.screenHeight);
		let curOpt = ["1024 x 800","1280 x 720","1366 x 768","1440 x 900","1600 x 900","1920 x 1080"].indexOf(resolutionOpt.optionText.text.text);
		if(curOpt != -1) {
			resolutionOpt.setCurrentOption(curOpt);
		}
		let displayOpt = optionCollection.addOption(1,"Resolution",["Fullscreen","Windowed"],function(idx) {
			src_Settings.optionsSettings.isFullScreen = idx == 0;
			return true;
		},0.35);
		displayOpt.setCurrentOption(src_Settings.optionsSettings.isFullScreen ? 0 : 1);
		let numberRange = function(start,stop,step) {
			let range = [];
			while(start <= stop) {
				range.push("" + start);
				start += step;
			}
			return range;
		};
		let fovOpt = optionCollection.addOption(1,"Field of Vision",numberRange(60,140,5),function(idx) {
			src_Settings.optionsSettings.fovX = 60 + idx / 16.0 * 80;
			return true;
		},0.35);
		let value = Math.floor((src_Settings.optionsSettings.fovX - 60) / 80 * 16);
		fovOpt.setCurrentOption((value < 0 ? 0 : value > 16 ? 16 : value) | 0);
		let rfOpt = optionCollection.addOption(1,"Reflection Detail",["None","Sky Only","Level and Sky","Level, Sky and Items","Everything"],function(idx) {
			src_Settings.optionsSettings.reflectionDetail = idx;
			return true;
		},0.35);
		rfOpt.setCurrentOption(src_Settings.optionsSettings.reflectionDetail);
		let pxOpt = optionCollection.addOption(1,"Pixel Ratio",["Max 0.5","Max 1","Max 1.5","Max 2","Max Infinity"],function(idx) {
			if(idx == 0) {
				src_Settings.optionsSettings.maxPixelRatio = 0.5;
			} else if(idx == 1) {
				src_Settings.optionsSettings.maxPixelRatio = 1;
			} else if(idx == 2) {
				src_Settings.optionsSettings.maxPixelRatio = 1.5;
			} else if(idx == 3) {
				src_Settings.optionsSettings.maxPixelRatio = 2;
			} else if(idx == 4) {
				src_Settings.optionsSettings.maxPixelRatio = 100;
			}
			return true;
		},0.35);
		let curPixelRatioIndex = 1;
		if(src_Settings.optionsSettings.maxPixelRatio == 0.5) {
			curPixelRatioIndex = 0;
		} else if(src_Settings.optionsSettings.maxPixelRatio == 1) {
			curPixelRatioIndex = 1;
		} else if(src_Settings.optionsSettings.maxPixelRatio == 1.5) {
			curPixelRatioIndex = 2;
		} else if(src_Settings.optionsSettings.maxPixelRatio == 2) {
			curPixelRatioIndex = 3;
		} else if(src_Settings.optionsSettings.maxPixelRatio == 100) {
			curPixelRatioIndex = 4;
		}
		pxOpt.setCurrentOption(curPixelRatioIndex);
		let bottomBar = new gui_GuiControl();
		bottomBar.position = new h3d_Vector(0,590);
		bottomBar.extent = new h3d_Vector(640,200);
		bottomBar.horizSizing = gui_HorizSizing.Width;
		bottomBar.vertSizing = gui_VertSizing.Bottom;
		this.innerCtrl.addChild(bottomBar);
		let backButton = new gui_GuiXboxButton("Ok",160);
		backButton.position = new h3d_Vector(960,0);
		backButton.vertSizing = gui_VertSizing.Bottom;
		backButton.horizSizing = gui_HorizSizing.Right;
		backButton.gamepadAccelerator = ["A"];
		backButton.accelerators = [13];
		let _gthis = this;
		if(pauseGui) {
			backButton.pressedAction = function(e) {
				src_Settings.applySettings();
				src_MarbleGame.canvas.popDialog(_gthis);
				src_MarbleGame.canvas.pushDialog(new gui_OptionsListGui(true));
			};
		} else {
			backButton.pressedAction = function(e) {
				src_Settings.applySettings();
				src_MarbleGame.canvas.setContent(new gui_OptionsListGui());
			};
		}
		bottomBar.addChild(backButton);
	}
	onResize(width,height) {
		let offsetX = (width - 1280) / 2;
		let offsetY = (height - 720) / 2;
		let subX = 640 - (width - offsetX) * 640 / width;
		let subY = 480 - (height - offsetY) * 480 / height;
		this.innerCtrl.position = new h3d_Vector(offsetX,offsetY);
		this.innerCtrl.extent = new h3d_Vector(640 - subX,480 - subY);
		super.onResize(width,height);
	}
}
$hxClasses["gui.VideoOptionsGui"] = gui_VideoOptionsGui;
gui_VideoOptionsGui.__name__ = "gui.VideoOptionsGui";
gui_VideoOptionsGui.__super__ = gui_GuiImage;
Object.assign(gui_VideoOptionsGui.prototype, {
	__class__: gui_VideoOptionsGui
	,innerCtrl: null
});
class h2d_Anim extends h2d_Drawable {
	constructor(frames,speed,parent) {
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor(frames,speed,parent);
	}
	_hx_constructor(frames,speed,parent) {
		if(speed == null) {
			speed = 15;
		}
		this.fading = false;
		this.loop = true;
		this.pause = false;
		super._hx_constructor(parent);
		this.frames = frames == null ? [] : frames;
		this.curFrame = 0;
		this.speed = speed;
	}
	onAnimEnd() {
	}
	set_currentFrame(frame) {
		this.curFrame = this.frames.length == 0 ? 0 : frame % this.frames.length;
		if(this.curFrame < 0) {
			this.curFrame += this.frames.length;
		}
		return this.curFrame;
	}
	getBoundsRec(relativeTo,out,forSize) {
		super.getBoundsRec(relativeTo,out,forSize);
		let tile = this.getFrame();
		if(tile != null) {
			this.addBounds(relativeTo,out,tile.dx,tile.dy,tile.width,tile.height);
		}
	}
	sync(ctx) {
		super.sync(ctx);
		let prev = this.curFrame;
		if(!this.pause) {
			this.curFrame += this.speed * ctx.elapsedTime;
		}
		if(this.curFrame < this.frames.length) {
			return;
		}
		if(this.loop) {
			if(this.frames.length == 0) {
				this.curFrame = 0;
			} else {
				this.curFrame %= this.frames.length;
			}
			this.onAnimEnd();
		} else if(this.curFrame >= this.frames.length) {
			this.curFrame = this.frames.length;
			if(this.curFrame != prev) {
				this.onAnimEnd();
			}
		}
	}
	getFrame() {
		let i = this.curFrame | 0;
		if(i == this.frames.length) {
			--i;
		}
		return this.frames[i];
	}
	draw(ctx) {
		let t = this.getFrame();
		if(this.fading) {
			let i = (this.curFrame | 0) + 1;
			if(i >= this.frames.length) {
				if(!this.loop) {
					return;
				}
				i = 0;
			}
			let t2 = this.frames[i];
			let old = ctx.globalAlpha;
			let alpha = this.curFrame - (this.curFrame | 0);
			ctx.globalAlpha *= 1 - alpha;
			this.emitTile(ctx,t);
			ctx.globalAlpha = old * alpha;
			this.emitTile(ctx,t2);
			ctx.globalAlpha = old;
		} else {
			this.emitTile(ctx,t);
		}
	}
}
$hxClasses["h2d.Anim"] = h2d_Anim;
h2d_Anim.__name__ = "h2d.Anim";
h2d_Anim.__super__ = h2d_Drawable;
Object.assign(h2d_Anim.prototype, {
	__class__: h2d_Anim
	,frames: null
	,speed: null
	,pause: null
	,loop: null
	,fading: null
	,curFrame: null
});
class h2d_Bitmap extends h2d_Drawable {
	constructor(tile,parent) {
		super(parent);
		this.set_tile(tile);
	}
	getBoundsRec(relativeTo,out,forSize) {
		super.getBoundsRec(relativeTo,out,forSize);
		if(this.tile != null) {
			if(this.width == null && this.height == null) {
				this.addBounds(relativeTo,out,this.tile.dx,this.tile.dy,this.tile.width,this.tile.height);
			} else {
				this.addBounds(relativeTo,out,this.tile.dx,this.tile.dy,this.width != null ? this.width : this.tile.width * this.height / this.tile.height,this.height != null ? this.height : this.tile.height * this.width / this.tile.width);
			}
		}
	}
	set_width(w) {
		if(this.width == w) {
			return w;
		}
		this.width = w;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return w;
	}
	set_height(h) {
		if(this.height == h) {
			return h;
		}
		this.height = h;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return h;
	}
	set_tile(t) {
		if(this.tile == t) {
			return t;
		}
		this.tile = t;
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
		return t;
	}
	draw(ctx) {
		if(this.width == null && this.height == null) {
			this.emitTile(ctx,this.tile);
			return;
		}
		if(this.tile == null) {
			this.set_tile(h2d_Tile.fromColor(16711935));
		}
		let ow = this.tile.width;
		let oh = this.tile.height;
		this.tile.width = this.width != null ? this.width : ow * this.height / oh;
		this.tile.height = this.height != null ? this.height : oh * this.width / ow;
		this.emitTile(ctx,this.tile);
		this.tile.width = ow;
		this.tile.height = oh;
	}
}
$hxClasses["h2d.Bitmap"] = h2d_Bitmap;
h2d_Bitmap.__name__ = "h2d.Bitmap";
h2d_Bitmap.__super__ = h2d_Drawable;
Object.assign(h2d_Bitmap.prototype, {
	__class__: h2d_Bitmap
	,tile: null
	,width: null
	,height: null
});
var h2d_BlendMode = $hxEnums["h2d.BlendMode"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h2d.BlendMode",toString:$estr}
	,Alpha: {_hx_name:"Alpha",_hx_index:1,__enum__:"h2d.BlendMode",toString:$estr}
	,Add: {_hx_name:"Add",_hx_index:2,__enum__:"h2d.BlendMode",toString:$estr}
	,AlphaAdd: {_hx_name:"AlphaAdd",_hx_index:3,__enum__:"h2d.BlendMode",toString:$estr}
	,SoftAdd: {_hx_name:"SoftAdd",_hx_index:4,__enum__:"h2d.BlendMode",toString:$estr}
	,Multiply: {_hx_name:"Multiply",_hx_index:5,__enum__:"h2d.BlendMode",toString:$estr}
	,AlphaMultiply: {_hx_name:"AlphaMultiply",_hx_index:6,__enum__:"h2d.BlendMode",toString:$estr}
	,Erase: {_hx_name:"Erase",_hx_index:7,__enum__:"h2d.BlendMode",toString:$estr}
	,Screen: {_hx_name:"Screen",_hx_index:8,__enum__:"h2d.BlendMode",toString:$estr}
	,Sub: {_hx_name:"Sub",_hx_index:9,__enum__:"h2d.BlendMode",toString:$estr}
	,Max: {_hx_name:"Max",_hx_index:10,__enum__:"h2d.BlendMode",toString:$estr}
	,Min: {_hx_name:"Min",_hx_index:11,__enum__:"h2d.BlendMode",toString:$estr}
};
h2d_BlendMode.__constructs__ = [h2d_BlendMode.None,h2d_BlendMode.Alpha,h2d_BlendMode.Add,h2d_BlendMode.AlphaAdd,h2d_BlendMode.SoftAdd,h2d_BlendMode.Multiply,h2d_BlendMode.AlphaMultiply,h2d_BlendMode.Erase,h2d_BlendMode.Screen,h2d_BlendMode.Sub,h2d_BlendMode.Max,h2d_BlendMode.Min];
h2d_BlendMode.__empty_constructs__ = [h2d_BlendMode.None,h2d_BlendMode.Alpha,h2d_BlendMode.Add,h2d_BlendMode.AlphaAdd,h2d_BlendMode.SoftAdd,h2d_BlendMode.Multiply,h2d_BlendMode.AlphaMultiply,h2d_BlendMode.Erase,h2d_BlendMode.Screen,h2d_BlendMode.Sub,h2d_BlendMode.Max,h2d_BlendMode.Min];
class h2d_Camera {
	constructor(scene) {
		this.followRotation = false;
		this.posChanged = true;
		this.x = 0;
		this.posChanged = true;
		this.y = 0;
		this.posChanged = true;
		this.scaleX = 1;
		this.posChanged = true;
		this.scaleY = 1;
		this.posChanged = true;
		this.rotation = 0;
		this.posChanged = true;
		this.anchorX = 0;
		this.posChanged = true;
		this.anchorY = 0;
		this.viewX = 0;
		this.viewY = 0;
		this.viewW = 1;
		this.viewH = 1;
		this.visible = true;
		if(scene != null) {
			scene.addCamera(this);
		}
	}
	layerVisible(layer) {
		return true;
	}
	enter(ctx) {
		ctx.pushCamera(this);
		if(this.clipViewport) {
			let old = ctx.inFilter;
			ctx.inFilter = null;
			ctx.pushRenderZone(this.viewX * this.scene.width,this.viewY * this.scene.height,this.viewW * this.scene.width,this.viewH * this.scene.height);
			ctx.inFilter = old;
		}
	}
	exit(ctx) {
		if(this.clipViewport) {
			let old = ctx.inFilter;
			ctx.inFilter = null;
			ctx.popRenderZone();
			ctx.inFilter = old;
		}
		ctx.popCamera();
	}
	sync(ctx,force) {
		if(force == null) {
			force = false;
		}
		if(this.scene == null) {
			return;
		}
		if(this.follow != null) {
			this.posChanged = true;
			this.x = this.follow.absX;
			this.posChanged = true;
			this.y = this.follow.absY;
			if(this.followRotation) {
				this.posChanged = true;
				this.rotation = -this.follow.rotation;
			}
		}
		if(this.posChanged || force) {
			if(this.rotation == 0) {
				this.matA = this.scaleX;
				this.matB = 0;
				this.matC = 0;
				this.matD = this.scaleY;
			} else {
				let cr = Math.cos(this.rotation);
				let sr = Math.sin(this.rotation);
				this.matA = this.scaleX * cr;
				this.matB = this.scaleX * sr;
				this.matC = this.scaleY * -sr;
				this.matD = this.scaleY * cr;
			}
			this.absX = Math.round(-(this.x * this.matA + this.y * this.matC) + this.scene.width * this.anchorX * this.viewW + this.scene.width * this.viewX);
			this.absY = Math.round(-(this.x * this.matB + this.y * this.matD) + this.scene.height * this.anchorY * this.viewH + this.scene.height * this.viewY);
			this.invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
			this.posChanged = false;
		}
	}
	eventToCamera(e) {
		let x = (e.relX - this.scene.offsetX) / this.scene.viewportScaleX - this.absX;
		let y = (e.relY - this.scene.offsetY) / this.scene.viewportScaleY - this.absY;
		e.relX = (x * this.matD - y * this.matC) * this.invDet;
		e.relY = (-x * this.matB + y * this.matA) * this.invDet;
	}
}
$hxClasses["h2d.Camera"] = h2d_Camera;
h2d_Camera.__name__ = "h2d.Camera";
Object.assign(h2d_Camera.prototype, {
	__class__: h2d_Camera
	,x: null
	,y: null
	,scaleX: null
	,scaleY: null
	,rotation: null
	,clipViewport: null
	,anchorX: null
	,anchorY: null
	,visible: null
	,follow: null
	,followRotation: null
	,posChanged: null
	,viewX: null
	,viewY: null
	,viewW: null
	,viewH: null
	,matA: null
	,matB: null
	,matC: null
	,matD: null
	,absX: null
	,absY: null
	,invDet: null
	,scene: null
});
var h2d_FlowAlign = $hxEnums["h2d.FlowAlign"] = { __ename__:true,__constructs__:null
	,Top: {_hx_name:"Top",_hx_index:0,__enum__:"h2d.FlowAlign",toString:$estr}
	,Left: {_hx_name:"Left",_hx_index:1,__enum__:"h2d.FlowAlign",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:2,__enum__:"h2d.FlowAlign",toString:$estr}
	,Middle: {_hx_name:"Middle",_hx_index:3,__enum__:"h2d.FlowAlign",toString:$estr}
	,Bottom: {_hx_name:"Bottom",_hx_index:4,__enum__:"h2d.FlowAlign",toString:$estr}
};
h2d_FlowAlign.__constructs__ = [h2d_FlowAlign.Top,h2d_FlowAlign.Left,h2d_FlowAlign.Right,h2d_FlowAlign.Middle,h2d_FlowAlign.Bottom];
h2d_FlowAlign.__empty_constructs__ = [h2d_FlowAlign.Top,h2d_FlowAlign.Left,h2d_FlowAlign.Right,h2d_FlowAlign.Middle,h2d_FlowAlign.Bottom];
var h2d_FlowLayout = $hxEnums["h2d.FlowLayout"] = { __ename__:true,__constructs__:null
	,Horizontal: {_hx_name:"Horizontal",_hx_index:0,__enum__:"h2d.FlowLayout",toString:$estr}
	,Vertical: {_hx_name:"Vertical",_hx_index:1,__enum__:"h2d.FlowLayout",toString:$estr}
	,Stack: {_hx_name:"Stack",_hx_index:2,__enum__:"h2d.FlowLayout",toString:$estr}
};
h2d_FlowLayout.__constructs__ = [h2d_FlowLayout.Horizontal,h2d_FlowLayout.Vertical,h2d_FlowLayout.Stack];
h2d_FlowLayout.__empty_constructs__ = [h2d_FlowLayout.Horizontal,h2d_FlowLayout.Vertical,h2d_FlowLayout.Stack];
var h2d_FlowOverflow = $hxEnums["h2d.FlowOverflow"] = { __ename__:true,__constructs__:null
	,Expand: {_hx_name:"Expand",_hx_index:0,__enum__:"h2d.FlowOverflow",toString:$estr}
	,Limit: {_hx_name:"Limit",_hx_index:1,__enum__:"h2d.FlowOverflow",toString:$estr}
	,Hidden: {_hx_name:"Hidden",_hx_index:2,__enum__:"h2d.FlowOverflow",toString:$estr}
	,Scroll: {_hx_name:"Scroll",_hx_index:3,__enum__:"h2d.FlowOverflow",toString:$estr}
};
h2d_FlowOverflow.__constructs__ = [h2d_FlowOverflow.Expand,h2d_FlowOverflow.Limit,h2d_FlowOverflow.Hidden,h2d_FlowOverflow.Scroll];
h2d_FlowOverflow.__empty_constructs__ = [h2d_FlowOverflow.Expand,h2d_FlowOverflow.Limit,h2d_FlowOverflow.Hidden,h2d_FlowOverflow.Scroll];
class h2d_FlowProperties {
	constructor(elt) {
		this.constraint = true;
		this.lineBreak = false;
		this.calculatedHeight = 0;
		this.calculatedWidth = 0;
		this.offsetY = 0;
		this.offsetX = 0;
		this.isAbsolute = false;
		this.paddingBottom = 0;
		this.paddingRight = 0;
		this.paddingTop = 0;
		this.paddingLeft = 0;
		this.elt = elt;
	}
	set_isAbsolute(a) {
		if(a) {
			this.elt.constraintSize(-1,-1);
			this.isBreak = false;
		}
		return this.isAbsolute = a;
	}
}
$hxClasses["h2d.FlowProperties"] = h2d_FlowProperties;
h2d_FlowProperties.__name__ = "h2d.FlowProperties";
Object.assign(h2d_FlowProperties.prototype, {
	__class__: h2d_FlowProperties
	,elt: null
	,paddingLeft: null
	,paddingTop: null
	,paddingRight: null
	,paddingBottom: null
	,isAbsolute: null
	,horizontalAlign: null
	,verticalAlign: null
	,offsetX: null
	,offsetY: null
	,minWidth: null
	,minHeight: null
	,calculatedWidth: null
	,calculatedHeight: null
	,isBreak: null
	,lineBreak: null
	,constraint: null
	,autoSize: null
});
class h2d_Flow extends h2d_Object {
	constructor(parent) {
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor(parent);
	}
	_hx_constructor(parent) {
		this.realMinHeight = -1;
		this.realMinWidth = -1;
		this.realMaxHeight = -1;
		this.realMaxWidth = -1;
		this.constraintHeight = -1;
		this.constraintWidth = -1;
		this.contentHeight = 0.;
		this.contentWidth = 0.;
		this.calculatedHeight = 0.;
		this.calculatedWidth = 0.;
		this.properties = [];
		this.scrollPosY = 0.;
		this.scrollWheelSpeed = 30.;
		this.fillHeight = false;
		this.fillWidth = false;
		this.reverse = false;
		this.multiline = false;
		this.isInline = true;
		this.layout = h2d_FlowLayout.Horizontal;
		this.borderBottom = 0;
		this.borderTop = 0;
		this.borderRight = 0;
		this.borderLeft = 0;
		this.verticalSpacing = 0;
		this.horizontalSpacing = 0;
		this.paddingBottom = 0;
		this.paddingTop = 0;
		this.paddingRight = 0;
		this.paddingLeft = 0;
		this.overflow = h2d_FlowOverflow.Expand;
		this.needReflow = true;
		this.tmpBounds = new h2d_col_Bounds();
		super._hx_constructor(parent);
	}
	getProperties(e) {
		this.set_needReflow(true);
		return this.properties[this.getChildIndex(e)];
	}
	set_layout(v) {
		if(this.layout == v) {
			return v;
		}
		this.set_needReflow(true);
		return this.layout = v == null ? h2d_FlowLayout.Horizontal : v;
	}
	set_verticalAlign(v) {
		if(this.verticalAlign == v) {
			return v;
		}
		this.set_needReflow(true);
		return this.verticalAlign = v;
	}
	makeScrollBar() {
		let bar = new h2d_Flow();
		bar.set_backgroundTile(h2d_Tile.fromColor(0));
		bar.alpha = 0.5;
		return bar;
	}
	makeScrollBarCursor() {
		let cursor = new h2d_Flow();
		cursor.set_minWidth(10);
		cursor.set_minHeight(20);
		cursor.set_backgroundTile(h2d_Tile.fromColor(-1));
		return cursor;
	}
	set_overflow(v) {
		if(this.overflow == v) {
			return v;
		}
		this.set_needReflow(true);
		let _gthis = this;
		if(v == h2d_FlowOverflow.Scroll) {
			this.set_enableInteractive(true);
			if(this.scrollBar == null) {
				this.scrollBar = this.makeScrollBar();
				this.addChild(this.scrollBar);
				this.scrollBar.set_verticalAlign(h2d_FlowAlign.Top);
				this.scrollBar.set_enableInteractive(true);
				let setCursor = function(e) {
					let cursorY = e.relY - _gthis.scrollBarCursor.minHeight * 0.5;
					if(cursorY < 0) {
						cursorY = 0;
					}
					_gthis.set_scrollPosY(cursorY / (_gthis.scrollBar.minHeight - _gthis.scrollBarCursor.minHeight) * (_gthis.contentHeight - _gthis.calculatedHeight));
				};
				this.scrollBar.interactive.set_cursor(hxd_Cursor.Button);
				this.scrollBar.interactive.onPush = function(e) {
					let scene = _gthis.getScene();
					if(scene == null) {
						return;
					}
					_gthis.scrollBar.interactive.startCapture(function(e) {
						switch(e.kind._hx_index) {
						case 0:case 2:
							setCursor(e);
							break;
						case 1:case 10:
							scene.stopCapture();
							break;
						default:
						}
						e.propagate = false;
					});
					setCursor(e);
				};
				let p = this.getProperties(this.scrollBar);
				p.set_isAbsolute(true);
				p.horizontalAlign = h2d_FlowAlign.Right;
				p.verticalAlign = h2d_FlowAlign.Top;
				this.scrollBarCursor = this.makeScrollBarCursor();
				this.scrollBar.addChild(this.scrollBarCursor);
			}
		} else if(this.scrollBar != null) {
			let _this = this.scrollBar;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.scrollBar = null;
			this.scrollBarCursor = null;
		}
		return this.overflow = v;
	}
	set_multiline(v) {
		if(this.multiline == v) {
			return v;
		}
		this.set_needReflow(true);
		return this.multiline = v;
	}
	set_needReflow(v) {
		if(this.needReflow == v) {
			return v;
		}
		if(v) {
			if(this.parentContainer != null) {
				this.parentContainer.contentChanged(this);
			}
		}
		return this.needReflow = v;
	}
	set_padding(v) {
		this.set_paddingLeft(v);
		this.set_paddingTop(v);
		this.set_paddingRight(v);
		this.set_paddingBottom(v);
		return v;
	}
	set_scrollPosY(v) {
		if(this.needReflow) {
			this.reflow();
		}
		if(v < 0) {
			v = 0;
		}
		if(v > this.contentHeight - this.calculatedHeight) {
			v = this.contentHeight - this.calculatedHeight;
		}
		if(this.scrollPosY == v) {
			return v;
		}
		let delta = (v | 0) - (this.scrollPosY | 0);
		let i = 0;
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			let p = this.properties[i++];
			if(p.isAbsolute) {
				continue;
			}
			c.posChanged = true;
			c.y -= delta;
		}
		this.scrollPosY = v;
		this.updateScrollCursor();
		return v;
	}
	updateScrollCursor() {
		if(this.scrollBarCursor == null) {
			return;
		}
		let prev = this.needReflow;
		let p = this.scrollBar.getProperties(this.scrollBarCursor);
		p.paddingTop = this.scrollPosY * (this.calculatedHeight - this.scrollBarCursor.minHeight) / (this.contentHeight - this.calculatedHeight) | 0;
		this.set_needReflow(prev);
	}
	get_innerWidth() {
		if(this.needReflow) {
			this.reflow();
		}
		return Math.ceil(this.calculatedWidth) - (this.paddingLeft + this.paddingRight + (this.borderLeft + this.borderRight));
	}
	get_innerHeight() {
		if(this.needReflow) {
			this.reflow();
		}
		return Math.ceil(this.calculatedHeight) - (this.paddingTop + this.paddingBottom + (this.borderTop + this.borderBottom));
	}
	set_paddingLeft(v) {
		if(this.paddingLeft == v) {
			return v;
		}
		this.set_needReflow(true);
		return this.paddingLeft = v;
	}
	set_paddingRight(v) {
		if(this.paddingRight == v) {
			return v;
		}
		this.set_needReflow(true);
		return this.paddingRight = v;
	}
	set_paddingTop(v) {
		if(this.paddingTop == v) {
			return v;
		}
		this.set_needReflow(true);
		return this.paddingTop = v;
	}
	set_paddingBottom(v) {
		if(this.paddingBottom == v) {
			return v;
		}
		this.set_needReflow(true);
		return this.paddingBottom = v;
	}
	constraintSize(width,height) {
		this.constraintWidth = width;
		this.constraintHeight = height;
		this.isConstraint = true;
		this.updateConstraint();
	}
	onHierarchyMoved(parentChanged) {
		super.onHierarchyMoved(parentChanged);
		this.isConstraint = false;
		this.constraintWidth = -1;
		this.constraintHeight = -1;
		this.updateConstraint();
	}
	contentChanged(s) {
		while(s.parent != this) s = s.parent;
		let p = this.getProperties(s);
		if(p != null && p.isAbsolute) {
			return;
		}
		this.set_needReflow(true);
		if(this.parentContainer != null) {
			this.parentContainer.contentChanged(this);
		}
	}
	getBoundsRec(relativeTo,out,forSize) {
		if(this.needReflow) {
			this.reflow();
		}
		if(forSize) {
			if(!this.isInline) {
				super.getBoundsRec(relativeTo,out,true);
			}
			if(this.calculatedWidth != 0) {
				if(this.posChanged) {
					this.calcAbsPos();
					let _g = 0;
					let _g1 = this.children;
					while(_g < _g1.length) {
						let c = _g1[_g];
						++_g;
						c.posChanged = true;
					}
					this.posChanged = false;
				}
				this.addBounds(relativeTo,out,0,0,this.calculatedWidth,this.calculatedHeight);
			}
		} else {
			super.getBoundsRec(relativeTo,out,forSize);
		}
	}
	setParentContainer(c) {
		this.parentContainer = c;
	}
	addChildAt(s,pos) {
		if(this.background != null) {
			++pos;
		}
		if(this.interactive != null) {
			++pos;
		}
		if(this.scrollBar != null && pos == this.children.length) {
			--pos;
		}
		let fp = this.getProperties(s);
		super.addChildAt(s,pos);
		if(fp == null) {
			fp = new h2d_FlowProperties(s);
		} else {
			HxOverrides.remove(this.properties,fp);
		}
		this.properties.splice(pos,0,fp);
		this.set_needReflow(true);
		s.setParentContainer(this);
	}
	removeChild(s) {
		let index = this.getChildIndex(s);
		super.removeChild(s);
		if(index >= 0) {
			this.set_needReflow(true);
			this.properties.splice(index,1);
			s.constraintSize(-1,-1);
		}
		if(s != null) {
			if(s == this.background) {
				this.set_backgroundTile(null);
			}
			if(s == this.interactive) {
				this.set_enableInteractive(false);
			}
		}
	}
	sync(ctx) {
		if(!this.isConstraint && (this.fillWidth || this.fillHeight)) {
			let scene = ctx.scene;
			let cw = this.fillWidth ? scene.width : -1;
			let ch = this.fillHeight ? scene.height : -1;
			if(cw != this.constraintWidth || ch != this.constraintHeight) {
				this.set_needReflow(true);
			}
		}
		if(this.needReflow) {
			this.reflow();
		}
		super.sync(ctx);
	}
	drawRec(ctx) {
		if(this.overflow == h2d_FlowOverflow.Hidden || this.overflow == h2d_FlowOverflow.Scroll) {
			if(this.posChanged) {
				this.calcAbsPos();
				let _g = 0;
				let _g1 = this.children;
				while(_g < _g1.length) {
					let c = _g1[_g];
					++_g;
					c.posChanged = true;
				}
				this.posChanged = false;
			}
			h2d_Mask.maskWith(ctx,this,Math.ceil(this.calculatedWidth),Math.ceil(this.calculatedHeight),0,0);
			super.drawRec(ctx);
			h2d_Mask.unmask(ctx);
		} else {
			super.drawRec(ctx);
		}
	}
	set_maxWidth(w) {
		if(this.maxWidth == w) {
			return w;
		}
		this.maxWidth = w;
		this.updateConstraint();
		return w;
	}
	set_maxHeight(h) {
		if(this.maxHeight == h) {
			return h;
		}
		this.maxHeight = h;
		this.updateConstraint();
		return h;
	}
	updateConstraint() {
		let oldW = this.realMaxWidth;
		let oldH = this.realMaxHeight;
		let tmp;
		if(this.maxWidth == null) {
			tmp = this.constraintWidth;
		} else if(this.constraintWidth < 0) {
			tmp = this.maxWidth;
		} else {
			let a = this.maxWidth;
			let b = this.constraintWidth;
			tmp = a > b ? b : a;
		}
		this.realMaxWidth = tmp;
		let tmp1;
		if(this.maxHeight == null) {
			tmp1 = this.constraintHeight;
		} else if(this.constraintHeight < 0) {
			tmp1 = this.maxHeight;
		} else {
			let a = this.maxHeight;
			let b = this.constraintHeight;
			tmp1 = a > b ? b : a;
		}
		this.realMaxHeight = tmp1;
		if(this.minWidth != null && this.realMaxWidth < this.minWidth && this.realMaxWidth >= 0) {
			this.realMaxWidth = this.minWidth;
		}
		if(this.minHeight != null && this.realMaxHeight < this.minHeight && this.realMaxWidth >= 0) {
			this.realMaxHeight = this.minHeight;
		}
		if(this.realMaxWidth != oldW || this.realMaxHeight != oldH) {
			this.set_needReflow(true);
		}
		let oldW1 = this.realMinWidth;
		let oldH1 = this.realMinHeight;
		let tmp2;
		if(this.fillWidth) {
			let a = Math.ceil(this.constraintWidth);
			let b = this.minWidth != null ? this.minWidth : -1;
			tmp2 = a < b ? b : a;
		} else {
			tmp2 = this.minWidth != null ? this.minWidth : -1;
		}
		this.realMinWidth = tmp2;
		let tmp3;
		if(this.fillHeight) {
			let a = Math.ceil(this.constraintHeight);
			let b = this.minHeight != null ? this.minHeight : -1;
			tmp3 = a < b ? b : a;
		} else {
			tmp3 = this.minHeight != null ? this.minHeight : -1;
		}
		this.realMinHeight = tmp3;
		if(this.realMinWidth != oldW1 || this.realMinHeight != oldH1) {
			this.set_needReflow(true);
		}
	}
	set_minWidth(w) {
		if(this.minWidth == w) {
			return w;
		}
		this.set_needReflow(true);
		this.minWidth = w;
		this.updateConstraint();
		return w;
	}
	set_minHeight(h) {
		if(this.minHeight == h) {
			return h;
		}
		this.set_needReflow(true);
		this.minHeight = h;
		this.updateConstraint();
		return h;
	}
	set_enableInteractive(b) {
		if(this.enableInteractive == b) {
			return b;
		}
		if(b) {
			if(this.interactive == null) {
				let interactive = new h2d_Interactive(0,0);
				this.addChildAt(interactive,0);
				this.interactive = interactive;
				interactive.set_cursor(hxd_Cursor.Default);
				this.getProperties(interactive).set_isAbsolute(true);
				if(!this.needReflow) {
					interactive.width = this.calculatedWidth;
					interactive.height = this.calculatedHeight;
				}
				interactive.onWheel = $bind(this,this.onMouseWheel);
			}
		} else if(this.interactive != null) {
			let _this = this.interactive;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.interactive = null;
		}
		return this.enableInteractive = b;
	}
	onMouseWheel(e) {
		if(this.overflow == h2d_FlowOverflow.Scroll) {
			this.set_scrollPosY(this.scrollPosY + e.wheelDelta * this.scrollWheelSpeed);
			e.propagate = false;
		}
	}
	set_backgroundTile(t) {
		if(this.backgroundTile == t) {
			return t;
		}
		if(t != null) {
			if(this.background == null) {
				let background = new h2d_ScaleGrid(t,this.borderLeft,this.borderTop,this.borderRight,this.borderBottom);
				this.addChildAt(background,0);
				this.getProperties(background).set_isAbsolute(true);
				this.background = background;
				if(!this.needReflow) {
					background.set_width(Math.ceil(this.calculatedWidth));
					background.set_height(Math.ceil(this.calculatedHeight));
				}
			}
			this.background.tile = t;
		} else if(this.background != null) {
			let _this = this.background;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			this.background = null;
		}
		return this.backgroundTile = t;
	}
	set_borderWidth(v) {
		if(this.borderLeft == v) {
			return v;
		}
		return this.set_borderLeft(this.set_borderRight(v));
	}
	set_borderLeft(v) {
		if(this.background != null) {
			this.background.set_borderLeft(v);
		}
		this.set_needReflow(true);
		return this.borderLeft = v;
	}
	set_borderRight(v) {
		if(this.borderRight == v) {
			return v;
		}
		if(this.background != null) {
			this.background.set_borderRight(v);
		}
		this.set_needReflow(true);
		return this.borderRight = v;
	}
	set_borderHeight(v) {
		if(this.borderTop == v) {
			return v;
		}
		return this.set_borderTop(this.set_borderBottom(v));
	}
	set_borderTop(v) {
		if(this.borderTop == v) {
			return v;
		}
		if(this.background != null) {
			this.background.set_borderTop(v);
		}
		this.set_needReflow(true);
		return this.borderTop = v;
	}
	set_borderBottom(v) {
		if(this.borderBottom == v) {
			return v;
		}
		if(this.background != null) {
			this.background.set_borderBottom(v);
		}
		this.set_needReflow(true);
		return this.borderBottom = v;
	}
	reflow() {
		this.onBeforeReflow();
		this.syncPos();
		if(!this.isConstraint && (this.fillWidth || this.fillHeight)) {
			let scene = this.getScene();
			let cw = this.fillWidth ? scene.width : -1;
			let ch = this.fillHeight ? scene.height : -1;
			if(cw != this.constraintWidth || ch != this.constraintHeight) {
				this.constraintSize(cw,ch);
				this.isConstraint = false;
			}
		}
		let borderTop = this.borderTop;
		let borderBottom = this.borderBottom;
		let borderLeft = this.borderLeft;
		let borderRight = this.borderRight;
		let tmpBounds = this.tmpBounds;
		if(tmpBounds == null) {
			throw haxe_Exception.thrown("Recursive reflow");
		}
		this.tmpBounds = null;
		let isConstraintWidth = this.realMaxWidth >= 0;
		let isConstraintHeight = this.realMaxHeight >= 0;
		let maxTotWidth = this.realMaxWidth < 0 ? 100000000 : Math.floor(this.realMaxWidth);
		let maxTotHeight = this.realMaxHeight < 0 ? 100000000 : Math.floor(this.realMaxHeight);
		let maxInWidth = maxTotWidth - (this.paddingLeft + this.paddingRight + (borderLeft + borderRight));
		let maxInHeight = maxTotHeight - (this.paddingTop + this.paddingBottom + (borderTop + borderBottom));
		if(this.debug) {
			this.debugGraphics.clear();
		}
		let cw;
		let ch;
		switch(this.layout._hx_index) {
		case 0:
			let halign = this.horizontalAlign == null ? h2d_FlowAlign.Left : this.horizontalAlign;
			let valign = this.verticalAlign == null ? h2d_FlowAlign.Bottom : this.verticalAlign;
			let startX = this.paddingLeft + borderLeft;
			let x = startX;
			let y = this.paddingTop + borderTop;
			cw = startX;
			let maxLineHeight = 0;
			let minLineHeight = this.lineHeight != null ? this.lineHeight : this.realMinHeight >= 0 && !this.multiline ? this.realMinHeight - (this.paddingTop + this.paddingBottom + borderTop + borderBottom) : 0;
			let lastIndex = 0;
			let autoWidth = maxInWidth;
			let autoSum = 0.0;
			let count = 0;
			let _g = 0;
			let _g1 = this.children.length;
			while(_g < _g1) {
				let i = _g++;
				let p = this.properties[this.reverse ? this.children.length - i - 1 : i];
				if(p.isAbsolute && p.horizontalAlign == null && p.verticalAlign == null) {
					continue;
				}
				let c = this.children[this.reverse ? this.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				if(count > 0 && !p.isAbsolute) {
					autoWidth -= this.horizontalSpacing;
				}
				if(p.autoSize == null) {
					let pw = p.paddingLeft + p.paddingRight;
					let ph = p.paddingTop + p.paddingBottom;
					if(!p.isAbsolute) {
						c.constraintSize(isConstraintWidth && p.constraint ? ((p.autoSize != null ? Math.floor(autoWidth * p.autoSize / autoSum) : maxInWidth) - pw) / Math.abs(c.scaleX) : -1,isConstraintHeight && p.constraint ? ((p.autoSize != null ? (maxLineHeight < minLineHeight ? minLineHeight : maxLineHeight) * p.autoSize : maxInHeight) - ph) / Math.abs(c.scaleY) : -1);
					}
					tmpBounds.xMin = 1e20;
					tmpBounds.yMin = 1e20;
					tmpBounds.xMax = -1e20;
					tmpBounds.yMax = -1e20;
					c.getBoundsRec(this,tmpBounds,true);
					if(tmpBounds.xMax <= tmpBounds.xMin || tmpBounds.yMax <= tmpBounds.yMin) {
						if(0 < tmpBounds.xMin) {
							tmpBounds.xMin = 0;
						}
						if(0 > tmpBounds.xMax) {
							tmpBounds.xMax = 0;
						}
						if(0 < tmpBounds.yMin) {
							tmpBounds.yMin = 0;
						}
						if(0 > tmpBounds.yMax) {
							tmpBounds.yMax = 0;
						}
					} else {
						let dx = -c.x;
						let dy = -c.y;
						tmpBounds.xMin += dx;
						tmpBounds.xMax += dx;
						tmpBounds.yMin += dy;
						tmpBounds.yMax += dy;
					}
					p.calculatedWidth = Math.ceil(tmpBounds.xMax) + pw;
					p.calculatedHeight = Math.ceil(tmpBounds.yMax) + ph;
					if(p.minWidth != null && p.calculatedWidth < p.minWidth) {
						p.calculatedWidth = p.minWidth;
					}
					if(p.minHeight != null && p.calculatedHeight < p.minHeight) {
						p.calculatedHeight = p.minHeight;
					}
					if(!p.isAbsolute) {
						if(p.calculatedHeight > maxLineHeight) {
							maxLineHeight = p.calculatedHeight;
						}
						autoWidth -= p.calculatedWidth;
					}
				} else {
					autoSum += p.autoSize;
				}
				++count;
			}
			let _g2 = 0;
			let _g3 = this.children.length;
			while(_g2 < _g3) {
				let i = _g2++;
				let p = this.properties[this.reverse ? this.children.length - i - 1 : i];
				if(p.isAbsolute && p.horizontalAlign == null && p.verticalAlign == null) {
					continue;
				}
				let c = this.children[this.reverse ? this.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				if(p.autoSize != null) {
					let pw = p.paddingLeft + p.paddingRight;
					let ph = p.paddingTop + p.paddingBottom;
					if(!p.isAbsolute) {
						c.constraintSize(isConstraintWidth && p.constraint ? ((p.autoSize != null ? Math.floor(autoWidth * p.autoSize / autoSum) : maxInWidth) - pw) / Math.abs(c.scaleX) : -1,isConstraintHeight && p.constraint ? ((p.autoSize != null ? (maxLineHeight < minLineHeight ? minLineHeight : maxLineHeight) * p.autoSize : maxInHeight) - ph) / Math.abs(c.scaleY) : -1);
					}
					tmpBounds.xMin = 1e20;
					tmpBounds.yMin = 1e20;
					tmpBounds.xMax = -1e20;
					tmpBounds.yMax = -1e20;
					c.getBoundsRec(this,tmpBounds,true);
					if(tmpBounds.xMax <= tmpBounds.xMin || tmpBounds.yMax <= tmpBounds.yMin) {
						if(0 < tmpBounds.xMin) {
							tmpBounds.xMin = 0;
						}
						if(0 > tmpBounds.xMax) {
							tmpBounds.xMax = 0;
						}
						if(0 < tmpBounds.yMin) {
							tmpBounds.yMin = 0;
						}
						if(0 > tmpBounds.yMax) {
							tmpBounds.yMax = 0;
						}
					} else {
						let dx = -c.x;
						let dy = -c.y;
						tmpBounds.xMin += dx;
						tmpBounds.xMax += dx;
						tmpBounds.yMin += dy;
						tmpBounds.yMax += dy;
					}
					p.calculatedWidth = Math.ceil(tmpBounds.xMax) + pw;
					p.calculatedHeight = Math.ceil(tmpBounds.yMax) + ph;
					if(p.minWidth != null && p.calculatedWidth < p.minWidth) {
						p.calculatedWidth = p.minWidth;
					}
					if(p.minHeight != null && p.calculatedHeight < p.minHeight) {
						p.calculatedHeight = p.minHeight;
					}
				}
				if(!p.isAbsolute) {
					let br = false;
					if((this.multiline && x - startX + p.calculatedWidth > maxInWidth || p.lineBreak) && x - startX > 0) {
						br = true;
						if(maxLineHeight < minLineHeight) {
							maxLineHeight = minLineHeight;
						} else if(this.overflow != h2d_FlowOverflow.Expand && minLineHeight != 0) {
							maxLineHeight = minLineHeight;
						}
						let absHeight = maxLineHeight > maxInHeight && this.overflow != h2d_FlowOverflow.Expand ? maxInHeight : maxLineHeight;
						let _g = lastIndex;
						while(_g < i) {
							let i = _g++;
							let p = this.properties[this.reverse ? this.children.length - i - 1 : i];
							if(p.isAbsolute && p.verticalAlign == null) {
								continue;
							}
							let c = this.children[this.reverse ? this.children.length - i - 1 : i];
							if(!c.visible) {
								continue;
							}
							let a = p.verticalAlign != null ? p.verticalAlign : valign;
							c.posChanged = true;
							c.y = y + p.offsetY + p.paddingTop;
							let height = p.isAbsolute ? absHeight : maxLineHeight;
							if(a != null) {
								switch(a._hx_index) {
								case 3:
									c.posChanged = true;
									c.y += (height - p.calculatedHeight) * 0.5 | 0;
									break;
								case 4:
									c.posChanged = true;
									c.y += height - (p.calculatedHeight | 0);
									break;
								default:
								}
							}
						}
						lastIndex = i;
						y += maxLineHeight + this.verticalSpacing;
						maxLineHeight = 0;
						x = startX;
					}
					p.isBreak = br;
					x += p.calculatedWidth;
					if(x > cw) {
						cw = x;
					}
					x += this.horizontalSpacing;
					if(p.calculatedHeight > maxLineHeight) {
						maxLineHeight = p.calculatedHeight;
					}
				}
			}
			let maxIndex = this.children.length;
			if(maxLineHeight < minLineHeight) {
				maxLineHeight = minLineHeight;
			} else if(this.overflow != h2d_FlowOverflow.Expand && minLineHeight != 0) {
				maxLineHeight = minLineHeight;
			}
			let absHeight = maxLineHeight > maxInHeight && this.overflow != h2d_FlowOverflow.Expand ? maxInHeight : maxLineHeight;
			let _g4 = lastIndex;
			while(_g4 < maxIndex) {
				let i = _g4++;
				let p = this.properties[this.reverse ? this.children.length - i - 1 : i];
				if(p.isAbsolute && p.verticalAlign == null) {
					continue;
				}
				let c = this.children[this.reverse ? this.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				let a = p.verticalAlign != null ? p.verticalAlign : valign;
				c.posChanged = true;
				c.y = y + p.offsetY + p.paddingTop;
				let height = p.isAbsolute ? absHeight : maxLineHeight;
				if(a != null) {
					switch(a._hx_index) {
					case 3:
						c.posChanged = true;
						c.y += (height - p.calculatedHeight) * 0.5 | 0;
						break;
					case 4:
						c.posChanged = true;
						c.y += height - (p.calculatedHeight | 0);
						break;
					default:
					}
				}
			}
			cw += this.paddingRight + borderRight;
			ch = y + maxLineHeight + this.paddingBottom + borderBottom;
			if(this.realMinWidth >= 0 && cw < this.realMinWidth) {
				cw = this.realMinWidth;
			}
			let endX = cw - (this.paddingRight + borderRight);
			let xmin = startX;
			let xmax = endX;
			let midSpace = 0;
			let curAlign = null;
			let _g5 = 0;
			let _g6 = this.children.length;
			while(_g5 < _g6) {
				let i = _g5++;
				let p = this.properties[this.reverse ? this.children.length - i - 1 : i];
				let c = this.children[this.reverse ? this.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				if(p.isAbsolute) {
					let _g = p.horizontalAlign;
					if(_g != null) {
						switch(_g._hx_index) {
						case 1:
							c.posChanged = true;
							c.x = startX + p.offsetX;
							break;
						case 2:
							c.posChanged = true;
							c.x = endX - p.calculatedWidth + p.offsetX;
							break;
						case 3:
							c.posChanged = true;
							c.x = startX + ((endX - startX - p.calculatedWidth) * 0.5 | 0) + p.offsetX + startX;
							break;
						default:
						}
					}
					continue;
				}
				if(p.isBreak) {
					xmin = startX;
					xmax = endX;
					midSpace = 0;
				}
				let px;
				let align = p.horizontalAlign == null ? halign : p.horizontalAlign;
				if(curAlign != align) {
					curAlign = align;
					midSpace = 0;
				}
				if(align == null) {
					px = xmin;
					xmin += p.calculatedWidth + this.horizontalSpacing;
				} else {
					switch(align._hx_index) {
					case 2:
						if(midSpace == 0) {
							let p1 = p.calculatedWidth;
							let size = 0;
							let _g = i + 1;
							let _g1 = this.children.length;
							while(_g < _g1) {
								let j = _g++;
								let p = this.properties[this.reverse ? this.children.length - j - 1 : j];
								if(p.isAbsolute || !this.children[this.reverse ? this.children.length - j - 1 : j].visible) {
									continue;
								}
								if(p.isBreak) {
									break;
								}
								size += this.horizontalSpacing + p.calculatedWidth;
							}
							let remSize = p1 + size;
							midSpace = xmax - xmin - remSize;
							xmin += midSpace;
						}
						px = xmin;
						xmin += p.calculatedWidth + this.horizontalSpacing;
						break;
					case 3:
						if(midSpace == 0) {
							let p1 = p.calculatedWidth;
							let size = 0;
							let _g = i + 1;
							let _g1 = this.children.length;
							while(_g < _g1) {
								let j = _g++;
								let p = this.properties[this.reverse ? this.children.length - j - 1 : j];
								if(p.isAbsolute || !this.children[this.reverse ? this.children.length - j - 1 : j].visible) {
									continue;
								}
								if(p.isBreak) {
									break;
								}
								size += this.horizontalSpacing + p.calculatedWidth;
							}
							let remSize = p1 + size;
							midSpace = (xmax - xmin - remSize) * 0.5 | 0;
							xmin += midSpace;
						}
						px = xmin;
						xmin += p.calculatedWidth + this.horizontalSpacing;
						break;
					default:
						px = xmin;
						xmin += p.calculatedWidth + this.horizontalSpacing;
					}
				}
				c.posChanged = true;
				c.x = px + p.offsetX + p.paddingLeft;
				if(p.isAbsolute) {
					xmin = px;
				}
			}
			break;
		case 1:
			let halign1 = this.horizontalAlign == null ? h2d_FlowAlign.Left : this.horizontalAlign;
			let valign1 = this.verticalAlign == null ? h2d_FlowAlign.Top : this.verticalAlign;
			let startY = this.paddingTop + borderTop;
			let y1 = startY;
			let x1 = this.paddingLeft + borderLeft;
			ch = startY;
			let maxColWidth = 0;
			let minColWidth = this.colWidth != null ? this.colWidth : this.realMinWidth >= 0 && !this.multiline ? this.realMinWidth - (this.paddingLeft + this.paddingRight + borderLeft + borderRight) : 0;
			let lastIndex1 = 0;
			let autoHeight = maxInHeight;
			let autoSum1 = 0.0;
			let count1 = 0;
			let _g7 = 0;
			let _g8 = this.children.length;
			while(_g7 < _g8) {
				let i = _g7++;
				let p = this.properties[this.reverse ? this.children.length - i - 1 : i];
				if(p.isAbsolute && p.horizontalAlign == null && p.verticalAlign == null) {
					continue;
				}
				let c = this.children[this.reverse ? this.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				if(count1 > 0 && !p.isAbsolute) {
					autoHeight -= this.verticalSpacing;
				}
				if(p.autoSize == null) {
					let pw = p.paddingLeft + p.paddingRight;
					let ph = p.paddingTop + p.paddingBottom;
					if(!p.isAbsolute) {
						c.constraintSize(isConstraintWidth && p.constraint ? ((p.autoSize != null ? (maxColWidth < minColWidth ? minColWidth : maxColWidth) * p.autoSize : maxInWidth) - pw) / Math.abs(c.scaleX) : -1,isConstraintHeight && p.constraint ? ((p.autoSize != null ? Math.floor(autoHeight * p.autoSize / autoSum1) : maxInHeight) - ph) / Math.abs(c.scaleY) : -1);
					}
					tmpBounds.xMin = 1e20;
					tmpBounds.yMin = 1e20;
					tmpBounds.xMax = -1e20;
					tmpBounds.yMax = -1e20;
					c.getBoundsRec(this,tmpBounds,true);
					if(tmpBounds.xMax <= tmpBounds.xMin || tmpBounds.yMax <= tmpBounds.yMin) {
						if(0 < tmpBounds.xMin) {
							tmpBounds.xMin = 0;
						}
						if(0 > tmpBounds.xMax) {
							tmpBounds.xMax = 0;
						}
						if(0 < tmpBounds.yMin) {
							tmpBounds.yMin = 0;
						}
						if(0 > tmpBounds.yMax) {
							tmpBounds.yMax = 0;
						}
					} else {
						let dx = -c.x;
						let dy = -c.y;
						tmpBounds.xMin += dx;
						tmpBounds.xMax += dx;
						tmpBounds.yMin += dy;
						tmpBounds.yMax += dy;
					}
					p.calculatedWidth = Math.ceil(tmpBounds.xMax) + pw;
					p.calculatedHeight = Math.ceil(tmpBounds.yMax) + ph;
					if(p.minWidth != null && p.calculatedWidth < p.minWidth) {
						p.calculatedWidth = p.minWidth;
					}
					if(p.minHeight != null && p.calculatedHeight < p.minHeight) {
						p.calculatedHeight = p.minHeight;
					}
					if(!p.isAbsolute) {
						if(p.calculatedWidth > maxColWidth) {
							maxColWidth = p.calculatedWidth;
						}
						autoHeight -= p.calculatedHeight;
					}
				} else {
					autoSum1 += p.autoSize;
				}
				++count1;
			}
			let _g9 = 0;
			let _g10 = this.children.length;
			while(_g9 < _g10) {
				let i = _g9++;
				let p = this.properties[this.reverse ? this.children.length - i - 1 : i];
				if(p.isAbsolute && p.horizontalAlign == null && p.verticalAlign == null) {
					continue;
				}
				let c = this.children[this.reverse ? this.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				if(p.autoSize != null) {
					let pw = p.paddingLeft + p.paddingRight;
					let ph = p.paddingTop + p.paddingBottom;
					if(!p.isAbsolute) {
						c.constraintSize(isConstraintWidth && p.constraint ? ((p.autoSize != null ? (maxColWidth < minColWidth ? minColWidth : maxColWidth) * p.autoSize : maxInWidth) - pw) / Math.abs(c.scaleX) : -1,isConstraintHeight && p.constraint ? ((p.autoSize != null ? Math.floor(autoHeight * p.autoSize / autoSum1) : maxInHeight) - ph) / Math.abs(c.scaleY) : -1);
					}
					tmpBounds.xMin = 1e20;
					tmpBounds.yMin = 1e20;
					tmpBounds.xMax = -1e20;
					tmpBounds.yMax = -1e20;
					c.getBoundsRec(this,tmpBounds,true);
					if(tmpBounds.xMax <= tmpBounds.xMin || tmpBounds.yMax <= tmpBounds.yMin) {
						if(0 < tmpBounds.xMin) {
							tmpBounds.xMin = 0;
						}
						if(0 > tmpBounds.xMax) {
							tmpBounds.xMax = 0;
						}
						if(0 < tmpBounds.yMin) {
							tmpBounds.yMin = 0;
						}
						if(0 > tmpBounds.yMax) {
							tmpBounds.yMax = 0;
						}
					} else {
						let dx = -c.x;
						let dy = -c.y;
						tmpBounds.xMin += dx;
						tmpBounds.xMax += dx;
						tmpBounds.yMin += dy;
						tmpBounds.yMax += dy;
					}
					p.calculatedWidth = Math.ceil(tmpBounds.xMax) + pw;
					p.calculatedHeight = Math.ceil(tmpBounds.yMax) + ph;
					if(p.minWidth != null && p.calculatedWidth < p.minWidth) {
						p.calculatedWidth = p.minWidth;
					}
					if(p.minHeight != null && p.calculatedHeight < p.minHeight) {
						p.calculatedHeight = p.minHeight;
					}
				}
				if(!p.isAbsolute) {
					let br = false;
					if((this.multiline && y1 - startY + p.calculatedHeight > maxInHeight || p.lineBreak) && y1 - startY > 0) {
						br = true;
						if(maxColWidth < minColWidth) {
							maxColWidth = minColWidth;
						} else if(this.overflow != h2d_FlowOverflow.Expand && minColWidth != 0) {
							maxColWidth = minColWidth;
						}
						let absWidth = maxColWidth > maxInWidth && this.overflow != h2d_FlowOverflow.Expand ? maxInWidth : maxColWidth;
						let _g = lastIndex1;
						while(_g < i) {
							let i = _g++;
							let p = this.properties[this.reverse ? this.children.length - i - 1 : i];
							if(p.isAbsolute && p.horizontalAlign == null) {
								continue;
							}
							let c = this.children[this.reverse ? this.children.length - i - 1 : i];
							if(!c.visible) {
								continue;
							}
							let a = p.horizontalAlign != null ? p.horizontalAlign : halign1;
							c.posChanged = true;
							c.x = x1 + p.offsetX + p.paddingLeft;
							let width = p.isAbsolute ? absWidth : maxColWidth;
							if(a != null) {
								switch(a._hx_index) {
								case 2:
									c.posChanged = true;
									c.x += width - p.calculatedWidth;
									break;
								case 3:
									c.posChanged = true;
									c.x += (width - p.calculatedWidth) * 0.5 | 0;
									break;
								default:
								}
							}
						}
						lastIndex1 = i;
						x1 += maxColWidth + this.horizontalSpacing;
						maxColWidth = 0;
						y1 = startY;
					}
					p.isBreak = br;
					c.posChanged = true;
					c.y = y1 + p.offsetY + p.paddingTop;
					y1 += p.calculatedHeight;
					if(y1 > ch) {
						ch = y1;
					}
					y1 += this.verticalSpacing;
					if(p.calculatedWidth > maxColWidth) {
						maxColWidth = p.calculatedWidth;
					}
				}
			}
			let maxIndex1 = this.children.length;
			if(maxColWidth < minColWidth) {
				maxColWidth = minColWidth;
			} else if(this.overflow != h2d_FlowOverflow.Expand && minColWidth != 0) {
				maxColWidth = minColWidth;
			}
			let absWidth = maxColWidth > maxInWidth && this.overflow != h2d_FlowOverflow.Expand ? maxInWidth : maxColWidth;
			let _g11 = lastIndex1;
			while(_g11 < maxIndex1) {
				let i = _g11++;
				let p = this.properties[this.reverse ? this.children.length - i - 1 : i];
				if(p.isAbsolute && p.horizontalAlign == null) {
					continue;
				}
				let c = this.children[this.reverse ? this.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				let a = p.horizontalAlign != null ? p.horizontalAlign : halign1;
				c.posChanged = true;
				c.x = x1 + p.offsetX + p.paddingLeft;
				let width = p.isAbsolute ? absWidth : maxColWidth;
				if(a != null) {
					switch(a._hx_index) {
					case 2:
						c.posChanged = true;
						c.x += width - p.calculatedWidth;
						break;
					case 3:
						c.posChanged = true;
						c.x += (width - p.calculatedWidth) * 0.5 | 0;
						break;
					default:
					}
				}
			}
			ch += this.paddingBottom + borderBottom;
			cw = x1 + maxColWidth + this.paddingRight + borderRight;
			if(this.realMinHeight >= 0 && ch < this.realMinHeight) {
				ch = this.realMinHeight;
			}
			let endY = ch - (this.paddingBottom + borderBottom);
			let ymin = startY;
			let ymax = endY;
			let midSpace1 = 0;
			let curAlign1 = null;
			let _g12 = 0;
			let _g13 = this.children.length;
			while(_g12 < _g13) {
				let i = _g12++;
				let p = this.properties[this.reverse ? this.children.length - i - 1 : i];
				let c = this.children[this.reverse ? this.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				if(p.isAbsolute) {
					let _g = p.verticalAlign;
					if(_g != null) {
						switch(_g._hx_index) {
						case 0:
							c.posChanged = true;
							c.y = startY + p.offsetY;
							break;
						case 3:
							c.posChanged = true;
							c.y = startY + ((endY - startY - p.calculatedHeight) * 0.5 | 0) + p.offsetY + startY;
							break;
						case 4:
							c.posChanged = true;
							c.y = endY - p.calculatedHeight + p.offsetY;
							break;
						default:
						}
					}
					continue;
				}
				if(p.isBreak) {
					ymin = startY;
					ymax = endY;
					midSpace1 = 0;
				}
				let py;
				let align = p.verticalAlign == null ? valign1 : p.verticalAlign;
				if(curAlign1 != align) {
					curAlign1 = align;
					midSpace1 = 0;
				}
				if(align == null) {
					py = ymin;
					ymin += p.calculatedHeight + this.verticalSpacing;
				} else {
					switch(align._hx_index) {
					case 3:
						if(midSpace1 == 0) {
							let p1 = p.calculatedHeight;
							let size = 0;
							let _g = i + 1;
							let _g1 = this.children.length;
							while(_g < _g1) {
								let j = _g++;
								let p = this.properties[this.reverse ? this.children.length - j - 1 : j];
								if(p.isAbsolute || !this.children[this.reverse ? this.children.length - j - 1 : j].visible) {
									continue;
								}
								if(p.isBreak) {
									break;
								}
								size += this.verticalSpacing + p.calculatedHeight;
							}
							let remSize = p1 + size;
							midSpace1 = (ymax - ymin - remSize) * 0.5 | 0;
							ymin += midSpace1;
						}
						py = ymin;
						ymin += p.calculatedHeight + this.verticalSpacing;
						break;
					case 4:
						if(midSpace1 == 0) {
							let p1 = p.calculatedHeight;
							let size = 0;
							let _g = i + 1;
							let _g1 = this.children.length;
							while(_g < _g1) {
								let j = _g++;
								let p = this.properties[this.reverse ? this.children.length - j - 1 : j];
								if(p.isAbsolute || !this.children[this.reverse ? this.children.length - j - 1 : j].visible) {
									continue;
								}
								if(p.isBreak) {
									break;
								}
								size += this.verticalSpacing + p.calculatedHeight;
							}
							let remSize = p1 + size;
							midSpace1 = ymax - ymin - remSize;
							ymin += midSpace1;
						}
						py = ymin;
						ymin += p.calculatedHeight + this.verticalSpacing;
						break;
					default:
						py = ymin;
						ymin += p.calculatedHeight + this.verticalSpacing;
					}
				}
				c.posChanged = true;
				c.y = py + p.offsetY + p.paddingTop;
			}
			break;
		case 2:
			let halign2 = this.horizontalAlign == null ? h2d_FlowAlign.Left : this.horizontalAlign;
			let valign2 = this.verticalAlign == null ? h2d_FlowAlign.Top : this.verticalAlign;
			let maxChildW = 0;
			let maxChildH = 0;
			let _g14 = 0;
			let _g15 = this.children.length;
			while(_g14 < _g15) {
				let i = _g14++;
				let c = this.children[this.reverse ? this.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				let p = this.properties[this.reverse ? this.children.length - i - 1 : i];
				let isAbs = p.isAbsolute;
				if(isAbs && p.verticalAlign == null && p.horizontalAlign == null) {
					continue;
				}
				let pw = p.paddingLeft + p.paddingRight;
				let ph = p.paddingTop + p.paddingBottom;
				if(!isAbs) {
					c.constraintSize(isConstraintWidth && p.constraint ? (maxInWidth - pw) / Math.abs(c.scaleX) : -1,isConstraintHeight && p.constraint ? (maxInHeight - ph) / Math.abs(c.scaleY) : -1);
				}
				tmpBounds.xMin = 1e20;
				tmpBounds.yMin = 1e20;
				tmpBounds.xMax = -1e20;
				tmpBounds.yMax = -1e20;
				c.getBoundsRec(this,tmpBounds,true);
				if(tmpBounds.xMax <= tmpBounds.xMin || tmpBounds.yMax <= tmpBounds.yMin) {
					if(0 < tmpBounds.xMin) {
						tmpBounds.xMin = 0;
					}
					if(0 > tmpBounds.xMax) {
						tmpBounds.xMax = 0;
					}
					if(0 < tmpBounds.yMin) {
						tmpBounds.yMin = 0;
					}
					if(0 > tmpBounds.yMax) {
						tmpBounds.yMax = 0;
					}
				} else {
					let dx = -c.x;
					let dy = -c.y;
					tmpBounds.xMin += dx;
					tmpBounds.xMax += dx;
					tmpBounds.yMin += dy;
					tmpBounds.yMax += dy;
				}
				p.calculatedWidth = Math.ceil(tmpBounds.xMax) + pw;
				p.calculatedHeight = Math.ceil(tmpBounds.yMax) + ph;
				if(p.minWidth != null && p.calculatedWidth < p.minWidth) {
					p.calculatedWidth = p.minWidth;
				}
				if(p.minHeight != null && p.calculatedHeight < p.minHeight) {
					p.calculatedHeight = p.minHeight;
				}
				if(isAbs) {
					continue;
				}
				if(p.calculatedWidth > maxChildW) {
					maxChildW = p.calculatedWidth;
				}
				if(p.calculatedHeight > maxChildH) {
					maxChildH = p.calculatedHeight;
				}
			}
			let xmin1 = this.paddingLeft + borderLeft;
			let ymin1 = this.paddingTop + borderTop;
			let xmax1;
			if(this.realMaxWidth > 0 && this.overflow != h2d_FlowOverflow.Expand) {
				xmax1 = Math.floor(this.realMaxWidth - (this.paddingRight + borderRight));
			} else {
				let a = xmin1 + maxChildW;
				let b = this.realMinWidth - (this.paddingRight + borderRight);
				xmax1 = a < b ? b : a;
			}
			let ymax1;
			if(this.realMaxWidth > 0 && this.overflow != h2d_FlowOverflow.Expand) {
				ymax1 = Math.floor(this.realMaxHeight - (this.paddingBottom + borderBottom));
			} else {
				let a = ymin1 + maxChildH;
				let b = this.realMinHeight - (this.paddingBottom + borderBottom);
				ymax1 = a < b ? b : a;
			}
			cw = xmax1 + this.paddingRight + borderRight;
			ch = ymax1 + this.paddingBottom + borderBottom;
			let _g16 = 0;
			let _g17 = this.children.length;
			while(_g16 < _g17) {
				let i = _g16++;
				let c = this.children[this.reverse ? this.children.length - i - 1 : i];
				if(!c.visible) {
					continue;
				}
				let p = this.properties[this.reverse ? this.children.length - i - 1 : i];
				let isAbs = p.isAbsolute;
				if(isAbs && p.verticalAlign == null && p.horizontalAlign == null) {
					continue;
				}
				let valign = p.verticalAlign == null ? valign2 : p.verticalAlign;
				let halign = p.horizontalAlign == null ? halign2 : p.horizontalAlign;
				let px;
				if(halign == null) {
					px = xmin1;
				} else {
					switch(halign._hx_index) {
					case 2:
						px = xmax1 - p.calculatedWidth;
						break;
					case 3:
						px = xmin1 + ((xmax1 - xmin1 - p.calculatedWidth) * 0.5 | 0);
						break;
					default:
						px = xmin1;
					}
				}
				let py;
				if(valign == null) {
					py = ymin1;
				} else {
					switch(valign._hx_index) {
					case 3:
						py = ymin1 + ((ymax1 - ymin1 - p.calculatedHeight) * 0.5 | 0);
						break;
					case 4:
						py = ymax1 - p.calculatedHeight;
						break;
					default:
						py = ymin1;
					}
				}
				if(!isAbs || p.horizontalAlign != null) {
					c.posChanged = true;
					c.x = px + p.offsetX + p.paddingLeft;
				}
				if(!isAbs || p.verticalAlign != null) {
					c.posChanged = true;
					c.y = py + p.offsetY + p.paddingTop;
				}
			}
			break;
		}
		if(this.scrollPosY != 0) {
			let i = 0;
			let sy = this.scrollPosY | 0;
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				let p = this.properties[i++];
				if(p.isAbsolute) {
					continue;
				}
				c.posChanged = true;
				c.y -= sy;
			}
		}
		if(this.realMinWidth >= 0 && cw < this.realMinWidth) {
			cw = this.realMinWidth;
		}
		if(this.realMinHeight >= 0 && ch < this.realMinHeight) {
			ch = this.realMinHeight;
		}
		this.contentWidth = cw;
		this.contentHeight = ch;
		if(this.overflow != h2d_FlowOverflow.Expand) {
			if(isConstraintWidth && cw > maxTotWidth) {
				cw = maxTotWidth;
			}
			if(isConstraintHeight && ch > maxTotHeight) {
				ch = maxTotHeight;
			}
		}
		if(this.interactive != null) {
			this.interactive.width = cw;
			this.interactive.height = ch;
		}
		if(this.background != null) {
			this.background.set_width(Math.ceil(cw));
			this.background.set_height(Math.ceil(ch));
		}
		this.calculatedWidth = cw;
		this.calculatedHeight = ch;
		if(this.scrollBar != null) {
			if(this.contentHeight <= this.calculatedHeight) {
				this.scrollBar.set_visible(false);
			} else {
				this.scrollBar.set_visible(true);
				this.scrollBar.set_minHeight(Math.ceil(this.calculatedHeight));
				let b = this.calculatedHeight * (1 - (this.contentHeight - this.calculatedHeight) / this.contentHeight) | 0;
				this.scrollBarCursor.set_minHeight(1 < b ? b : 1);
				this.updateScrollCursor();
			}
		}
		this.set_needReflow(false);
		if(this.overflow == h2d_FlowOverflow.Scroll || this.overflow == h2d_FlowOverflow.Hidden) {
			this.posChanged = true;
		}
		if(this.debug) {
			if(this.debugGraphics != this.children[this.children.length - 1]) {
				this.addChild(this.debugGraphics);
				this.set_needReflow(false);
			}
			if(this.paddingLeft != 0 || this.paddingRight != 0 || this.paddingTop != 0 || this.paddingBottom != 0) {
				this.debugGraphics.lineStyle(1,65280);
				this.debugGraphics.drawRect(this.paddingLeft,this.paddingTop,this.get_innerWidth(),this.get_innerHeight());
			}
			this.debugGraphics.lineStyle(1,33023);
			let _g = 0;
			let _g1 = this.children.length;
			while(_g < _g1) {
				let i = _g++;
				let p = this.properties[this.reverse ? this.children.length - i - 1 : i];
				let c = this.children[this.reverse ? this.children.length - i - 1 : i];
				if(p.isAbsolute || !c.visible) {
					continue;
				}
				this.debugGraphics.drawRect(c.x - p.offsetX - p.paddingLeft,c.y - p.offsetY - p.paddingTop,p.calculatedWidth,p.calculatedHeight);
			}
			this.debugGraphics.lineStyle(1,16711680);
			this.debugGraphics.drawRect(0,0,cw,ch);
		}
		this.tmpBounds = tmpBounds;
		this.onAfterReflow();
	}
	onBeforeReflow() {
	}
	onAfterReflow() {
	}
}
$hxClasses["h2d.Flow"] = h2d_Flow;
h2d_Flow.__name__ = "h2d.Flow";
h2d_Flow.__super__ = h2d_Object;
Object.assign(h2d_Flow.prototype, {
	__class__: h2d_Flow
	,tmpBounds: null
	,needReflow: null
	,horizontalAlign: null
	,verticalAlign: null
	,minWidth: null
	,minHeight: null
	,maxWidth: null
	,maxHeight: null
	,lineHeight: null
	,colWidth: null
	,overflow: null
	,paddingLeft: null
	,paddingRight: null
	,paddingTop: null
	,paddingBottom: null
	,horizontalSpacing: null
	,verticalSpacing: null
	,enableInteractive: null
	,interactive: null
	,backgroundTile: null
	,borderLeft: null
	,borderRight: null
	,borderTop: null
	,borderBottom: null
	,layout: null
	,isInline: null
	,debug: null
	,multiline: null
	,reverse: null
	,fillWidth: null
	,fillHeight: null
	,scrollBar: null
	,scrollBarCursor: null
	,scrollWheelSpeed: null
	,scrollPosY: null
	,background: null
	,debugGraphics: null
	,properties: null
	,calculatedWidth: null
	,calculatedHeight: null
	,contentWidth: null
	,contentHeight: null
	,constraintWidth: null
	,constraintHeight: null
	,realMaxWidth: null
	,realMaxHeight: null
	,realMinWidth: null
	,realMinHeight: null
	,isConstraint: null
});
class h2d_Kerning {
	constructor(c,o) {
		this.prevChar = c;
		this.offset = o;
	}
}
$hxClasses["h2d.Kerning"] = h2d_Kerning;
h2d_Kerning.__name__ = "h2d.Kerning";
Object.assign(h2d_Kerning.prototype, {
	__class__: h2d_Kerning
	,prevChar: null
	,offset: null
	,next: null
});
class h2d_FontChar {
	constructor(t,w) {
		this.t = t;
		this.width = w;
	}
	addKerning(prevChar,offset) {
		let k = new h2d_Kerning(prevChar,offset);
		k.next = this.kerning;
		this.kerning = k;
	}
	getKerningOffset(prevChar) {
		let k = this.kerning;
		while(k != null) {
			if(k.prevChar == prevChar) {
				return k.offset;
			}
			k = k.next;
		}
		return 0;
	}
}
$hxClasses["h2d.FontChar"] = h2d_FontChar;
h2d_FontChar.__name__ = "h2d.FontChar";
Object.assign(h2d_FontChar.prototype, {
	__class__: h2d_FontChar
	,t: null
	,width: null
	,kerning: null
});
var h2d_FontType = $hxEnums["h2d.FontType"] = { __ename__:true,__constructs__:null
	,BitmapFont: {_hx_name:"BitmapFont",_hx_index:0,__enum__:"h2d.FontType",toString:$estr}
	,SignedDistanceField: ($_=function(channel,alphaCutoff,smoothing) { return {_hx_index:1,channel:channel,alphaCutoff:alphaCutoff,smoothing:smoothing,__enum__:"h2d.FontType",toString:$estr}; },$_._hx_name="SignedDistanceField",$_.__params__ = ["channel","alphaCutoff","smoothing"],$_)
};
h2d_FontType.__constructs__ = [h2d_FontType.BitmapFont,h2d_FontType.SignedDistanceField];
h2d_FontType.__empty_constructs__ = [h2d_FontType.BitmapFont];
class h2d_Font {
	constructor(name,size,type) {
		this.name = name;
		this.size = size;
		this.initSize = size;
		this.glyphs = new haxe_ds_IntMap();
		this.defaultChar = this.nullChar = new h2d_FontChar(new h2d_Tile(null,0,0,0,0),0);
		this.charset = hxd_Charset.getDefault();
		if(name != null) {
			this.tilePath = haxe_io_Path.withExtension(name,"png");
		}
		if(type == null) {
			this.type = h2d_FontType.BitmapFont;
		} else {
			this.type = type;
		}
	}
	resizeTo(size) {
		let ratio = size / this.initSize;
		let c = this.glyphs.iterator();
		while(c.hasNext()) {
			let c1 = c.next();
			c1.width *= ratio;
			c1.t.scaleToSize(c1.t.width * ratio,c1.t.height * ratio);
			c1.t.dx *= ratio;
			c1.t.dy *= ratio;
			let k = c1.kerning;
			while(k != null) {
				k.offset *= ratio;
				k = k.next;
			}
		}
		this.lineHeight = Math.ceil(this.lineHeight * ratio);
		this.baseLine = Math.ceil(this.baseLine * ratio);
		this.size = size;
	}
	hasChar(code) {
		return this.glyphs.h[code] != null;
	}
	calcBaseLine() {
		let padding = 0;
		let space = this.glyphs.h[32];
		if(space != null) {
			padding = space.t.height * .5;
		}
		let a = this.glyphs.h[65];
		if(a == null) {
			a = this.glyphs.h[97];
		}
		if(a == null) {
			a = this.glyphs.h[48];
		}
		if(a == null) {
			return this.lineHeight - 2 - padding;
		}
		return a.t.dy + a.t.height - padding;
	}
}
$hxClasses["h2d.Font"] = h2d_Font;
h2d_Font.__name__ = "h2d.Font";
Object.assign(h2d_Font.prototype, {
	__class__: h2d_Font
	,name: null
	,size: null
	,baseLine: null
	,lineHeight: null
	,tile: null
	,tilePath: null
	,type: null
	,charset: null
	,glyphs: null
	,nullChar: null
	,defaultChar: null
	,initSize: null
});
class h2d_GPoint {
	constructor() {
	}
	load(x,y,r,g,b,a) {
		this.x = x;
		this.y = y;
		this.r = r;
		this.g = g;
		this.b = b;
		this.a = a;
	}
}
$hxClasses["h2d.GPoint"] = h2d_GPoint;
h2d_GPoint.__name__ = "h2d.GPoint";
Object.assign(h2d_GPoint.prototype, {
	__class__: h2d_GPoint
	,x: null
	,y: null
	,r: null
	,g: null
	,b: null
	,a: null
});
class h2d__$Graphics_GraphicsContent extends h3d_prim_Primitive {
	constructor() {
		super();
		this.buffers = [];
		this.state = new h2d_impl_BatchDrawState();
	}
	setTile(tile) {
		if(tile != null) {
			this.state.setTexture(tile.innerTex);
		}
	}
	next() {
		let nvect = this.tmp.pos >> 3;
		if(nvect < 32768) {
			return false;
		}
		this.buffers.push({ buf : this.tmp, idx : this.index, vbuf : null, ibuf : null, state : this.state});
		this.tmp = hxd__$FloatBuffer_Float32Expand._new(0);
		this.index = new Array(0);
		let tex = this.state.tail.texture;
		this.state = new h2d_impl_BatchDrawState();
		this.state.setTexture(tex);
		super.dispose();
		return true;
	}
	alloc(engine) {
		if(this.index.length <= 0) {
			return;
		}
		let alloc = hxd_impl_Allocator.get();
		this.buffer = alloc.ofFloats(this.tmp,8,2);
		this.indexes = alloc.ofIndexes(this.index);
		let _g = 0;
		let _g1 = this.buffers;
		while(_g < _g1.length) {
			let b = _g1[_g];
			++_g;
			let tmp;
			if(b.vbuf != null) {
				let _this = b.vbuf;
				tmp = _this.buffer == null || _this.buffer.vbuf == null;
			} else {
				tmp = true;
			}
			if(tmp) {
				b.vbuf = alloc.ofFloats(b.buf,8,2);
			}
			if(b.ibuf == null || b.ibuf.isDisposed()) {
				b.ibuf = alloc.ofIndexes(b.idx);
			}
		}
		this.bufferDirty = false;
		this.indexDirty = false;
	}
	doRender(ctx) {
		if(this.index.length == 0) {
			return;
		}
		this.flush();
		let _g = 0;
		let _g1 = this.buffers;
		while(_g < _g1.length) {
			let b = _g1[_g];
			++_g;
			b.state.drawIndexed(ctx,b.vbuf,b.ibuf);
		}
		this.state.drawIndexed(ctx,this.buffer,this.indexes);
	}
	flush() {
		let tmp;
		if(this.buffer != null) {
			let _this = this.buffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.alloc(h3d_Engine.CURRENT);
		} else {
			let allocator = hxd_impl_Allocator.get();
			if(this.bufferDirty) {
				allocator.disposeBuffer(this.buffer);
				this.buffer = allocator.ofFloats(this.tmp,8,2);
				this.bufferDirty = false;
			}
			if(this.indexDirty) {
				allocator.disposeIndexBuffer(this.indexes);
				this.indexes = allocator.ofIndexes(this.index);
				this.indexDirty = false;
			}
		}
	}
	dispose() {
		let _g = 0;
		let _g1 = this.buffers;
		while(_g < _g1.length) {
			let b = _g1[_g];
			++_g;
			if(b.vbuf != null) {
				hxd_impl_Allocator.get().disposeBuffer(b.vbuf);
			}
			if(b.ibuf != null) {
				hxd_impl_Allocator.get().disposeIndexBuffer(b.ibuf);
			}
			b.vbuf = null;
			b.ibuf = null;
			b.state.clear();
		}
		if(this.buffer != null) {
			hxd_impl_Allocator.get().disposeBuffer(this.buffer);
			this.buffer = null;
		}
		if(this.indexes != null) {
			hxd_impl_Allocator.get().disposeIndexBuffer(this.indexes);
			this.indexes = null;
		}
		this.state.clear();
		super.dispose();
	}
	clear() {
		this.dispose();
		this.tmp = hxd__$FloatBuffer_Float32Expand._new(0);
		this.index = new Array(0);
		this.buffers = [];
	}
}
$hxClasses["h2d._Graphics.GraphicsContent"] = h2d__$Graphics_GraphicsContent;
h2d__$Graphics_GraphicsContent.__name__ = "h2d._Graphics.GraphicsContent";
h2d__$Graphics_GraphicsContent.__super__ = h3d_prim_Primitive;
Object.assign(h2d__$Graphics_GraphicsContent.prototype, {
	__class__: h2d__$Graphics_GraphicsContent
	,tmp: null
	,index: null
	,state: null
	,buffers: null
	,bufferDirty: null
	,indexDirty: null
});
class h2d_Graphics extends h2d_Drawable {
	constructor(parent) {
		if(h2d_Object._hx_skip_constructor) {
			super();
			return;
		}
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor(parent);
	}
	_hx_constructor(parent) {
		this.bevel = 0.25;
		this.my = 0.;
		this.mx = 0.;
		this.md = 1.;
		this.mc = 0.;
		this.mb = 0.;
		this.ma = 1.;
		super._hx_constructor(parent);
		this.content = new h2d__$Graphics_GraphicsContent();
		this.tile = h2d_Tile.fromColor(16777215);
		this.clear();
	}
	onRemove() {
		super.onRemove();
		this.clear();
	}
	clear() {
		this.content.clear();
		this.tmpPoints = [];
		this.pindex = 0;
		this.lineSize = 0;
		this.xMin = Infinity;
		this.yMin = Infinity;
		this.yMax = -Infinity;
		this.xMax = -Infinity;
		this.xMinSize = Infinity;
		this.yMinSize = Infinity;
		this.yMaxSize = -Infinity;
		this.xMaxSize = -Infinity;
	}
	getBoundsRec(relativeTo,out,forSize) {
		super.getBoundsRec(relativeTo,out,forSize);
		if(this.tile != null) {
			if(forSize) {
				this.addBounds(relativeTo,out,this.xMinSize,this.yMinSize,this.xMaxSize - this.xMinSize,this.yMaxSize - this.yMinSize);
			} else {
				this.addBounds(relativeTo,out,this.xMin,this.yMin,this.xMax - this.xMin,this.yMax - this.yMin);
			}
		}
	}
	isConvex(points) {
		let first = true;
		let sign = false;
		let _g = 0;
		let _g1 = points.length;
		while(_g < _g1) {
			let i = _g++;
			let p1 = points[i];
			let p2 = points[(i + 1) % points.length];
			let p3 = points[(i + 2) % points.length];
			let s = (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0;
			if(first) {
				first = false;
				sign = s;
			} else if(sign != s) {
				return false;
			}
		}
		return true;
	}
	flushLine(start) {
		let pts = this.tmpPoints;
		let last = pts.length - 1;
		let prev = pts[last];
		let p = pts[0];
		this.content.setTile(h2d_Tile.fromColor(16777215));
		let closed = p.x == prev.x && p.y == prev.y;
		let count = pts.length;
		if(!closed) {
			let prevLast = pts[last - 1];
			if(prevLast == null) {
				prevLast = p;
			}
			let gp = new h2d_GPoint();
			gp.load(prev.x * 2 - prevLast.x,prev.y * 2 - prevLast.y,0,0,0,0);
			pts.push(gp);
			let pNext = pts[1];
			if(pNext == null) {
				pNext = p;
			}
			let gp1 = new h2d_GPoint();
			gp1.load(p.x * 2 - pNext.x,p.y * 2 - pNext.y,0,0,0,0);
			prev = gp1;
		} else if(p != prev) {
			--count;
			--last;
			prev = pts[last];
		}
		let _g = 0;
		let _g1 = count;
		while(_g < _g1) {
			let i = _g++;
			let next = pts[(i + 1) % pts.length];
			let nx1 = prev.y - p.y;
			let ny1 = p.x - prev.x;
			let ns1 = 1. / Math.sqrt(nx1 * nx1 + ny1 * ny1);
			let nx2 = p.y - next.y;
			let ny2 = next.x - p.x;
			let ns2 = 1. / Math.sqrt(nx2 * nx2 + ny2 * ny2);
			let nx = nx1 * ns1 + nx2 * ns2;
			let ny = ny1 * ns1 + ny2 * ns2;
			let ns = 1. / Math.sqrt(nx * nx + ny * ny);
			nx *= ns;
			ny *= ns;
			let size = nx * nx1 * ns1 + ny * ny1 * ns1;
			if(size < 0.1) {
				size = 0.1;
			}
			let d = this.lineSize * 0.5 / size;
			nx *= d;
			ny *= d;
			if(size > this.bevel) {
				let _this = this.content;
				let x = p.x + nx;
				let y = p.y + ny;
				let r = p.r;
				let g = p.g;
				let b = p.b;
				let a = p.a;
				let this1 = _this.tmp;
				if(this1.pos == this1.array.length) {
					let newSize = this1.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this1.array);
					this1.array = newArray;
				}
				this1.array[this1.pos++] = x;
				let this2 = _this.tmp;
				if(this2.pos == this2.array.length) {
					let newSize = this2.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this2.array);
					this2.array = newArray;
				}
				this2.array[this2.pos++] = y;
				let this3 = _this.tmp;
				if(this3.pos == this3.array.length) {
					let newSize = this3.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this3.array);
					this3.array = newArray;
				}
				this3.array[this3.pos++] = 0;
				let this4 = _this.tmp;
				if(this4.pos == this4.array.length) {
					let newSize = this4.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this4.array);
					this4.array = newArray;
				}
				this4.array[this4.pos++] = 0;
				let this5 = _this.tmp;
				if(this5.pos == this5.array.length) {
					let newSize = this5.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this5.array);
					this5.array = newArray;
				}
				this5.array[this5.pos++] = r;
				let this6 = _this.tmp;
				if(this6.pos == this6.array.length) {
					let newSize = this6.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this6.array);
					this6.array = newArray;
				}
				this6.array[this6.pos++] = g;
				let this7 = _this.tmp;
				if(this7.pos == this7.array.length) {
					let newSize = this7.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this7.array);
					this7.array = newArray;
				}
				this7.array[this7.pos++] = b;
				let this8 = _this.tmp;
				if(this8.pos == this8.array.length) {
					let newSize = this8.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this8.array);
					this8.array = newArray;
				}
				this8.array[this8.pos++] = a;
				_this.bufferDirty = true;
				let _this1 = this.content;
				let x1 = p.x - nx;
				let y1 = p.y - ny;
				let r1 = p.r;
				let g1 = p.g;
				let b1 = p.b;
				let a1 = p.a;
				let this9 = _this1.tmp;
				if(this9.pos == this9.array.length) {
					let newSize = this9.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this9.array);
					this9.array = newArray;
				}
				this9.array[this9.pos++] = x1;
				let this10 = _this1.tmp;
				if(this10.pos == this10.array.length) {
					let newSize = this10.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this10.array);
					this10.array = newArray;
				}
				this10.array[this10.pos++] = y1;
				let this11 = _this1.tmp;
				if(this11.pos == this11.array.length) {
					let newSize = this11.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this11.array);
					this11.array = newArray;
				}
				this11.array[this11.pos++] = 0;
				let this12 = _this1.tmp;
				if(this12.pos == this12.array.length) {
					let newSize = this12.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this12.array);
					this12.array = newArray;
				}
				this12.array[this12.pos++] = 0;
				let this13 = _this1.tmp;
				if(this13.pos == this13.array.length) {
					let newSize = this13.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this13.array);
					this13.array = newArray;
				}
				this13.array[this13.pos++] = r1;
				let this14 = _this1.tmp;
				if(this14.pos == this14.array.length) {
					let newSize = this14.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this14.array);
					this14.array = newArray;
				}
				this14.array[this14.pos++] = g1;
				let this15 = _this1.tmp;
				if(this15.pos == this15.array.length) {
					let newSize = this15.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this15.array);
					this15.array = newArray;
				}
				this15.array[this15.pos++] = b1;
				let this16 = _this1.tmp;
				if(this16.pos == this16.array.length) {
					let newSize = this16.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this16.array);
					this16.array = newArray;
				}
				this16.array[this16.pos++] = a1;
				_this1.bufferDirty = true;
				let pnext = i == last ? start : this.pindex + 2;
				if(i < count - 1 || closed) {
					let _this = this.content;
					_this.index.push(this.pindex);
					let _this1 = _this.state;
					_this1.tail.count += 1;
					_this1.totalCount += 1;
					_this.indexDirty = true;
					let _this2 = this.content;
					_this2.index.push(this.pindex + 1);
					let _this3 = _this2.state;
					_this3.tail.count += 1;
					_this3.totalCount += 1;
					_this2.indexDirty = true;
					let _this4 = this.content;
					_this4.index.push(pnext);
					let _this5 = _this4.state;
					_this5.tail.count += 1;
					_this5.totalCount += 1;
					_this4.indexDirty = true;
					let _this6 = this.content;
					_this6.index.push(this.pindex + 1);
					let _this7 = _this6.state;
					_this7.tail.count += 1;
					_this7.totalCount += 1;
					_this6.indexDirty = true;
					let _this8 = this.content;
					_this8.index.push(pnext);
					let _this9 = _this8.state;
					_this9.tail.count += 1;
					_this9.totalCount += 1;
					_this8.indexDirty = true;
					let _this10 = this.content;
					_this10.index.push(pnext + 1);
					let _this11 = _this10.state;
					_this11.tail.count += 1;
					_this11.totalCount += 1;
					_this10.indexDirty = true;
				}
				this.pindex += 2;
			} else {
				let n0x = next.x - p.x;
				let n0y = next.y - p.y;
				let sign = n0x * nx + n0y * ny;
				let nnx = -ny;
				let nny = nx;
				let size = nnx * nx1 * ns1 + nny * ny1 * ns1;
				let d = this.lineSize * 0.5 / size;
				nnx *= d;
				nny *= d;
				let pnext = i == last ? start : this.pindex + 3;
				if(sign > 0) {
					let _this = this.content;
					let x = p.x + nx;
					let y = p.y + ny;
					let r = p.r;
					let g = p.g;
					let b = p.b;
					let a = p.a;
					let this1 = _this.tmp;
					if(this1.pos == this1.array.length) {
						let newSize = this1.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this1.array);
						this1.array = newArray;
					}
					this1.array[this1.pos++] = x;
					let this2 = _this.tmp;
					if(this2.pos == this2.array.length) {
						let newSize = this2.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this2.array);
						this2.array = newArray;
					}
					this2.array[this2.pos++] = y;
					let this3 = _this.tmp;
					if(this3.pos == this3.array.length) {
						let newSize = this3.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this3.array);
						this3.array = newArray;
					}
					this3.array[this3.pos++] = 0;
					let this4 = _this.tmp;
					if(this4.pos == this4.array.length) {
						let newSize = this4.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this4.array);
						this4.array = newArray;
					}
					this4.array[this4.pos++] = 0;
					let this5 = _this.tmp;
					if(this5.pos == this5.array.length) {
						let newSize = this5.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this5.array);
						this5.array = newArray;
					}
					this5.array[this5.pos++] = r;
					let this6 = _this.tmp;
					if(this6.pos == this6.array.length) {
						let newSize = this6.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this6.array);
						this6.array = newArray;
					}
					this6.array[this6.pos++] = g;
					let this7 = _this.tmp;
					if(this7.pos == this7.array.length) {
						let newSize = this7.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this7.array);
						this7.array = newArray;
					}
					this7.array[this7.pos++] = b;
					let this8 = _this.tmp;
					if(this8.pos == this8.array.length) {
						let newSize = this8.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this8.array);
						this8.array = newArray;
					}
					this8.array[this8.pos++] = a;
					_this.bufferDirty = true;
					let _this1 = this.content;
					let x1 = p.x - nnx;
					let y1 = p.y - nny;
					let r1 = p.r;
					let g1 = p.g;
					let b1 = p.b;
					let a1 = p.a;
					let this9 = _this1.tmp;
					if(this9.pos == this9.array.length) {
						let newSize = this9.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this9.array);
						this9.array = newArray;
					}
					this9.array[this9.pos++] = x1;
					let this10 = _this1.tmp;
					if(this10.pos == this10.array.length) {
						let newSize = this10.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this10.array);
						this10.array = newArray;
					}
					this10.array[this10.pos++] = y1;
					let this11 = _this1.tmp;
					if(this11.pos == this11.array.length) {
						let newSize = this11.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this11.array);
						this11.array = newArray;
					}
					this11.array[this11.pos++] = 0;
					let this12 = _this1.tmp;
					if(this12.pos == this12.array.length) {
						let newSize = this12.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this12.array);
						this12.array = newArray;
					}
					this12.array[this12.pos++] = 0;
					let this13 = _this1.tmp;
					if(this13.pos == this13.array.length) {
						let newSize = this13.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this13.array);
						this13.array = newArray;
					}
					this13.array[this13.pos++] = r1;
					let this14 = _this1.tmp;
					if(this14.pos == this14.array.length) {
						let newSize = this14.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this14.array);
						this14.array = newArray;
					}
					this14.array[this14.pos++] = g1;
					let this15 = _this1.tmp;
					if(this15.pos == this15.array.length) {
						let newSize = this15.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this15.array);
						this15.array = newArray;
					}
					this15.array[this15.pos++] = b1;
					let this16 = _this1.tmp;
					if(this16.pos == this16.array.length) {
						let newSize = this16.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this16.array);
						this16.array = newArray;
					}
					this16.array[this16.pos++] = a1;
					_this1.bufferDirty = true;
					let _this2 = this.content;
					let x2 = p.x + nnx;
					let y2 = p.y + nny;
					let r2 = p.r;
					let g2 = p.g;
					let b2 = p.b;
					let a2 = p.a;
					let this17 = _this2.tmp;
					if(this17.pos == this17.array.length) {
						let newSize = this17.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this17.array);
						this17.array = newArray;
					}
					this17.array[this17.pos++] = x2;
					let this18 = _this2.tmp;
					if(this18.pos == this18.array.length) {
						let newSize = this18.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this18.array);
						this18.array = newArray;
					}
					this18.array[this18.pos++] = y2;
					let this19 = _this2.tmp;
					if(this19.pos == this19.array.length) {
						let newSize = this19.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this19.array);
						this19.array = newArray;
					}
					this19.array[this19.pos++] = 0;
					let this20 = _this2.tmp;
					if(this20.pos == this20.array.length) {
						let newSize = this20.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this20.array);
						this20.array = newArray;
					}
					this20.array[this20.pos++] = 0;
					let this21 = _this2.tmp;
					if(this21.pos == this21.array.length) {
						let newSize = this21.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this21.array);
						this21.array = newArray;
					}
					this21.array[this21.pos++] = r2;
					let this22 = _this2.tmp;
					if(this22.pos == this22.array.length) {
						let newSize = this22.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this22.array);
						this22.array = newArray;
					}
					this22.array[this22.pos++] = g2;
					let this23 = _this2.tmp;
					if(this23.pos == this23.array.length) {
						let newSize = this23.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this23.array);
						this23.array = newArray;
					}
					this23.array[this23.pos++] = b2;
					let this24 = _this2.tmp;
					if(this24.pos == this24.array.length) {
						let newSize = this24.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this24.array);
						this24.array = newArray;
					}
					this24.array[this24.pos++] = a2;
					_this2.bufferDirty = true;
					let _this3 = this.content;
					_this3.index.push(this.pindex);
					let _this4 = _this3.state;
					_this4.tail.count += 1;
					_this4.totalCount += 1;
					_this3.indexDirty = true;
					let _this5 = this.content;
					_this5.index.push(pnext);
					let _this6 = _this5.state;
					_this6.tail.count += 1;
					_this6.totalCount += 1;
					_this5.indexDirty = true;
					let _this7 = this.content;
					_this7.index.push(this.pindex + 2);
					let _this8 = _this7.state;
					_this8.tail.count += 1;
					_this8.totalCount += 1;
					_this7.indexDirty = true;
					let _this9 = this.content;
					_this9.index.push(this.pindex + 2);
					let _this10 = _this9.state;
					_this10.tail.count += 1;
					_this10.totalCount += 1;
					_this9.indexDirty = true;
					let _this11 = this.content;
					_this11.index.push(pnext);
					let _this12 = _this11.state;
					_this12.tail.count += 1;
					_this12.totalCount += 1;
					_this11.indexDirty = true;
					let _this13 = this.content;
					_this13.index.push(pnext + 1);
					let _this14 = _this13.state;
					_this14.tail.count += 1;
					_this14.totalCount += 1;
					_this13.indexDirty = true;
				} else {
					let _this = this.content;
					let x = p.x + nnx;
					let y = p.y + nny;
					let r = p.r;
					let g = p.g;
					let b = p.b;
					let a = p.a;
					let this1 = _this.tmp;
					if(this1.pos == this1.array.length) {
						let newSize = this1.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this1.array);
						this1.array = newArray;
					}
					this1.array[this1.pos++] = x;
					let this2 = _this.tmp;
					if(this2.pos == this2.array.length) {
						let newSize = this2.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this2.array);
						this2.array = newArray;
					}
					this2.array[this2.pos++] = y;
					let this3 = _this.tmp;
					if(this3.pos == this3.array.length) {
						let newSize = this3.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this3.array);
						this3.array = newArray;
					}
					this3.array[this3.pos++] = 0;
					let this4 = _this.tmp;
					if(this4.pos == this4.array.length) {
						let newSize = this4.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this4.array);
						this4.array = newArray;
					}
					this4.array[this4.pos++] = 0;
					let this5 = _this.tmp;
					if(this5.pos == this5.array.length) {
						let newSize = this5.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this5.array);
						this5.array = newArray;
					}
					this5.array[this5.pos++] = r;
					let this6 = _this.tmp;
					if(this6.pos == this6.array.length) {
						let newSize = this6.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this6.array);
						this6.array = newArray;
					}
					this6.array[this6.pos++] = g;
					let this7 = _this.tmp;
					if(this7.pos == this7.array.length) {
						let newSize = this7.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this7.array);
						this7.array = newArray;
					}
					this7.array[this7.pos++] = b;
					let this8 = _this.tmp;
					if(this8.pos == this8.array.length) {
						let newSize = this8.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this8.array);
						this8.array = newArray;
					}
					this8.array[this8.pos++] = a;
					_this.bufferDirty = true;
					let _this1 = this.content;
					let x1 = p.x - nx;
					let y1 = p.y - ny;
					let r1 = p.r;
					let g1 = p.g;
					let b1 = p.b;
					let a1 = p.a;
					let this9 = _this1.tmp;
					if(this9.pos == this9.array.length) {
						let newSize = this9.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this9.array);
						this9.array = newArray;
					}
					this9.array[this9.pos++] = x1;
					let this10 = _this1.tmp;
					if(this10.pos == this10.array.length) {
						let newSize = this10.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this10.array);
						this10.array = newArray;
					}
					this10.array[this10.pos++] = y1;
					let this11 = _this1.tmp;
					if(this11.pos == this11.array.length) {
						let newSize = this11.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this11.array);
						this11.array = newArray;
					}
					this11.array[this11.pos++] = 0;
					let this12 = _this1.tmp;
					if(this12.pos == this12.array.length) {
						let newSize = this12.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this12.array);
						this12.array = newArray;
					}
					this12.array[this12.pos++] = 0;
					let this13 = _this1.tmp;
					if(this13.pos == this13.array.length) {
						let newSize = this13.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this13.array);
						this13.array = newArray;
					}
					this13.array[this13.pos++] = r1;
					let this14 = _this1.tmp;
					if(this14.pos == this14.array.length) {
						let newSize = this14.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this14.array);
						this14.array = newArray;
					}
					this14.array[this14.pos++] = g1;
					let this15 = _this1.tmp;
					if(this15.pos == this15.array.length) {
						let newSize = this15.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this15.array);
						this15.array = newArray;
					}
					this15.array[this15.pos++] = b1;
					let this16 = _this1.tmp;
					if(this16.pos == this16.array.length) {
						let newSize = this16.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this16.array);
						this16.array = newArray;
					}
					this16.array[this16.pos++] = a1;
					_this1.bufferDirty = true;
					let _this2 = this.content;
					let x2 = p.x - nnx;
					let y2 = p.y - nny;
					let r2 = p.r;
					let g2 = p.g;
					let b2 = p.b;
					let a2 = p.a;
					let this17 = _this2.tmp;
					if(this17.pos == this17.array.length) {
						let newSize = this17.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this17.array);
						this17.array = newArray;
					}
					this17.array[this17.pos++] = x2;
					let this18 = _this2.tmp;
					if(this18.pos == this18.array.length) {
						let newSize = this18.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this18.array);
						this18.array = newArray;
					}
					this18.array[this18.pos++] = y2;
					let this19 = _this2.tmp;
					if(this19.pos == this19.array.length) {
						let newSize = this19.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this19.array);
						this19.array = newArray;
					}
					this19.array[this19.pos++] = 0;
					let this20 = _this2.tmp;
					if(this20.pos == this20.array.length) {
						let newSize = this20.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this20.array);
						this20.array = newArray;
					}
					this20.array[this20.pos++] = 0;
					let this21 = _this2.tmp;
					if(this21.pos == this21.array.length) {
						let newSize = this21.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this21.array);
						this21.array = newArray;
					}
					this21.array[this21.pos++] = r2;
					let this22 = _this2.tmp;
					if(this22.pos == this22.array.length) {
						let newSize = this22.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this22.array);
						this22.array = newArray;
					}
					this22.array[this22.pos++] = g2;
					let this23 = _this2.tmp;
					if(this23.pos == this23.array.length) {
						let newSize = this23.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this23.array);
						this23.array = newArray;
					}
					this23.array[this23.pos++] = b2;
					let this24 = _this2.tmp;
					if(this24.pos == this24.array.length) {
						let newSize = this24.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(this24.array);
						this24.array = newArray;
					}
					this24.array[this24.pos++] = a2;
					_this2.bufferDirty = true;
					let _this3 = this.content;
					_this3.index.push(this.pindex + 1);
					let _this4 = _this3.state;
					_this4.tail.count += 1;
					_this4.totalCount += 1;
					_this3.indexDirty = true;
					let _this5 = this.content;
					_this5.index.push(pnext);
					let _this6 = _this5.state;
					_this6.tail.count += 1;
					_this6.totalCount += 1;
					_this5.indexDirty = true;
					let _this7 = this.content;
					_this7.index.push(this.pindex + 2);
					let _this8 = _this7.state;
					_this8.tail.count += 1;
					_this8.totalCount += 1;
					_this7.indexDirty = true;
					let _this9 = this.content;
					_this9.index.push(this.pindex + 1);
					let _this10 = _this9.state;
					_this10.tail.count += 1;
					_this10.totalCount += 1;
					_this9.indexDirty = true;
					let _this11 = this.content;
					_this11.index.push(pnext);
					let _this12 = _this11.state;
					_this12.tail.count += 1;
					_this12.totalCount += 1;
					_this11.indexDirty = true;
					let _this13 = this.content;
					_this13.index.push(pnext + 1);
					let _this14 = _this13.state;
					_this14.tail.count += 1;
					_this14.totalCount += 1;
					_this13.indexDirty = true;
				}
				let _this = this.content;
				_this.index.push(this.pindex);
				let _this1 = _this.state;
				_this1.tail.count += 1;
				_this1.totalCount += 1;
				_this.indexDirty = true;
				let _this2 = this.content;
				_this2.index.push(this.pindex + 1);
				let _this3 = _this2.state;
				_this3.tail.count += 1;
				_this3.totalCount += 1;
				_this2.indexDirty = true;
				let _this4 = this.content;
				_this4.index.push(this.pindex + 2);
				let _this5 = _this4.state;
				_this5.tail.count += 1;
				_this5.totalCount += 1;
				_this4.indexDirty = true;
				this.pindex += 3;
			}
			prev = p;
			p = next;
		}
		this.content.setTile(this.tile);
	}
	flushFill(i0) {
		if(this.tmpPoints.length < 3) {
			return;
		}
		let pts = this.tmpPoints;
		let p0 = pts[0];
		let p1 = pts[pts.length - 1];
		let last = null;
		let tmp;
		let f = p0.x - p1.x;
		if((f < 0 ? -f : f) < 1e-9) {
			let f = p0.y - p1.y;
			tmp = (f < 0 ? -f : f) < 1e-9;
		} else {
			tmp = false;
		}
		if(tmp) {
			last = pts.pop();
		}
		if(this.isConvex(pts)) {
			let _g = 1;
			let _g1 = pts.length - 1;
			while(_g < _g1) {
				let i = _g++;
				let _this = this.content;
				_this.index.push(i0);
				let _this1 = _this.state;
				_this1.tail.count += 1;
				_this1.totalCount += 1;
				_this.indexDirty = true;
				let _this2 = this.content;
				_this2.index.push(i0 + i);
				let _this3 = _this2.state;
				_this3.tail.count += 1;
				_this3.totalCount += 1;
				_this2.indexDirty = true;
				let _this4 = this.content;
				_this4.index.push(i0 + i + 1);
				let _this5 = _this4.state;
				_this5.tail.count += 1;
				_this5.totalCount += 1;
				_this4.indexDirty = true;
			}
		} else {
			let ear = h2d_Graphics.EARCUT;
			if(ear == null) {
				ear = new hxd_earcut_Earcut();
				h2d_Graphics.EARCUT = ear;
			}
			let _g = 0;
			let _g1 = ear.triangulate_h2d_GPoint(pts);
			while(_g < _g1.length) {
				let i = _g1[_g];
				++_g;
				let _this = this.content;
				_this.index.push(i + i0);
				let _this1 = _this.state;
				_this1.tail.count += 1;
				_this1.totalCount += 1;
				_this.indexDirty = true;
			}
		}
		if(last != null) {
			pts.push(last);
		}
	}
	flush() {
		if(this.tmpPoints.length == 0) {
			return;
		}
		if(this.doFill) {
			this.flushFill(this.pindex);
			this.pindex += this.tmpPoints.length;
			if(this.content.next()) {
				this.pindex = 0;
			}
		}
		if(this.lineSize > 0) {
			this.flushLine(this.pindex);
			if(this.content.next()) {
				this.pindex = 0;
			}
		}
		this.tmpPoints = [];
	}
	beginFill(color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 0;
		}
		this.flush();
		this.tile = h2d_Tile.fromColor(16777215);
		this.content.setTile(this.tile);
		let alpha1 = alpha;
		if(alpha == null) {
			alpha1 = 1.;
		}
		this.curA = alpha1;
		this.curR = (color >> 16 & 255) / 255.;
		this.curG = (color >> 8 & 255) / 255.;
		this.curB = (color & 255) / 255.;
		this.doFill = true;
	}
	beginTileFill(dx,dy,scaleX,scaleY,tile) {
		if(tile == null) {
			tile = this.tile;
		}
		if(tile == null) {
			throw haxe_Exception.thrown("Tile not specified");
		}
		this.flush();
		this.tile = tile;
		this.content.setTile(tile);
		this.curA = 1.;
		this.curR = 1.;
		this.curG = 1.;
		this.curB = 1.;
		this.doFill = true;
		if(dx == null) {
			dx = 0;
		}
		if(dy == null) {
			dy = 0;
		}
		if(scaleX == null) {
			scaleX = 1;
		}
		if(scaleY == null) {
			scaleY = 1;
		}
		dx -= tile.x;
		dy -= tile.y;
		let tex = tile.innerTex;
		let pixWidth = 1 / tex.width;
		let pixHeight = 1 / tex.height;
		this.ma = pixWidth / scaleX;
		this.mb = 0;
		this.mc = 0;
		this.md = pixHeight / scaleY;
		this.mx = -dx * this.ma;
		this.my = -dy * this.md;
	}
	lineStyle(size,color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 0;
		}
		if(size == null) {
			size = 0;
		}
		this.flush();
		this.lineSize = size;
		this.lineA = alpha;
		this.lineR = (color >> 16 & 255) / 255.;
		this.lineG = (color >> 8 & 255) / 255.;
		this.lineB = (color & 255) / 255.;
	}
	endFill() {
		this.flush();
		this.doFill = false;
	}
	drawRect(x,y,w,h) {
		this.flush();
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		let x1 = x + w;
		this.addVertex(x1,y,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y * this.mc + this.mx,x1 * this.mb + y * this.md + this.my);
		let x2 = x + w;
		let y1 = y + h;
		this.addVertex(x2,y1,this.curR,this.curG,this.curB,this.curA,x2 * this.ma + y1 * this.mc + this.mx,x2 * this.mb + y1 * this.md + this.my);
		let y2 = y + h;
		this.addVertex(x,y2,this.curR,this.curG,this.curB,this.curA,x * this.ma + y2 * this.mc + this.mx,x * this.mb + y2 * this.md + this.my);
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		this.tmpPoints[0].x += 0.01;
		this.tmpPoints[0].y += 0.01;
		this.tmpPoints[1].y += 0.01;
		this.tmpPoints[3].x += 0.01;
		this.tmpPoints[4].x += 0.01;
		this.tmpPoints[4].y += 0.01;
		this.flush();
	}
	drawRoundedRect(x,y,w,h,radius,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		if(radius <= 0) {
			this.drawRect(x,y,w,h);
			return;
		}
		x += radius;
		y += radius;
		w -= radius * 2;
		h -= radius * 2;
		this.flush();
		if(nsegments == 0) {
			let f = radius * 1.5707963267948966 / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		let angle = 1.5707963267948966 / (nsegments - 1);
		let y1 = y - radius;
		this.addVertex(x,y1,this.curR,this.curG,this.curB,this.curA,x * this.ma + y1 * this.mc + this.mx,x * this.mb + y1 * this.md + this.my);
		let x1 = x + w;
		let y2 = y - radius;
		this.addVertex(x1,y2,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y2 * this.mc + this.mx,x1 * this.mb + y2 * this.md + this.my);
		let x2 = x + w;
		let _g = 0;
		let _g1 = nsegments;
		while(_g < _g1) {
			let i = _g++;
			let a = i * angle + 4.71238898038469;
			let x = x2 + Math.cos(a) * radius;
			let y1 = y + Math.sin(a) * radius;
			this.addVertex(x,y1,this.curR,this.curG,this.curB,this.curA,x * this.ma + y1 * this.mc + this.mx,x * this.mb + y1 * this.md + this.my);
		}
		let x3 = x + w + radius;
		let y3 = y + h;
		this.addVertex(x3,y3,this.curR,this.curG,this.curB,this.curA,x3 * this.ma + y3 * this.mc + this.mx,x3 * this.mb + y3 * this.md + this.my);
		let x4 = x + w;
		let y4 = y + h;
		let _g2 = 0;
		let _g3 = nsegments;
		while(_g2 < _g3) {
			let i = _g2++;
			let a = i * angle;
			let x = x4 + Math.cos(a) * radius;
			let y = y4 + Math.sin(a) * radius;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		let y5 = y + h + radius;
		this.addVertex(x,y5,this.curR,this.curG,this.curB,this.curA,x * this.ma + y5 * this.mc + this.mx,x * this.mb + y5 * this.md + this.my);
		let y6 = y + h;
		let _g4 = 0;
		let _g5 = nsegments;
		while(_g4 < _g5) {
			let i = _g4++;
			let a = i * angle + 1.5707963267948966;
			let x1 = x + Math.cos(a) * radius;
			let y = y6 + Math.sin(a) * radius;
			this.addVertex(x1,y,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y * this.mc + this.mx,x1 * this.mb + y * this.md + this.my);
		}
		let x5 = x - radius;
		this.addVertex(x5,y,this.curR,this.curG,this.curB,this.curA,x5 * this.ma + y * this.mc + this.mx,x5 * this.mb + y * this.md + this.my);
		let _g6 = 0;
		let _g7 = nsegments;
		while(_g6 < _g7) {
			let i = _g6++;
			let a = i * angle + 3.1415926535897931;
			let x1 = x + Math.cos(a) * radius;
			let y1 = y + Math.sin(a) * radius;
			this.addVertex(x1,y1,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y1 * this.mc + this.mx,x1 * this.mb + y1 * this.md + this.my);
		}
		this.flush();
	}
	drawCircle(cx,cy,radius,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		this.flush();
		if(nsegments == 0) {
			let f = radius * 3.14 * 2 / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		let angle = 6.2831853071795862 / nsegments;
		let _g = 0;
		let _g1 = nsegments + 1;
		while(_g < _g1) {
			let i = _g++;
			let a = i * angle;
			let x = cx + Math.cos(a) * radius;
			let y = cy + Math.sin(a) * radius;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.flush();
	}
	drawPieInner(cx,cy,radius,innerRadius,angleStart,angleLength,nsegments) {
		if(nsegments == null) {
			nsegments = 0;
		}
		this.flush();
		if((angleLength < 0 ? -angleLength : angleLength) >= 6.2841853071795866) {
			angleLength = 6.2841853071795866;
		}
		let cs = Math.cos(angleStart);
		let ss = Math.sin(angleStart);
		let ce = Math.cos(angleStart + angleLength);
		let se = Math.sin(angleStart + angleLength);
		let x = cx + cs * innerRadius;
		let y = cy + ss * innerRadius;
		this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		if(nsegments == 0) {
			let f = radius * angleLength / 4;
			nsegments = Math.ceil(f < 0 ? -f : f);
		}
		if(nsegments < 3) {
			nsegments = 3;
		}
		let angle = angleLength / (nsegments - 1);
		let _g = 0;
		let _g1 = nsegments;
		while(_g < _g1) {
			let i = _g++;
			let a = i * angle + angleStart;
			let x = cx + Math.cos(a) * radius;
			let y = cy + Math.sin(a) * radius;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		let x1 = cx + ce * innerRadius;
		let y1 = cy + se * innerRadius;
		this.addVertex(x1,y1,this.curR,this.curG,this.curB,this.curA,x1 * this.ma + y1 * this.mc + this.mx,x1 * this.mb + y1 * this.md + this.my);
		let _g2 = 0;
		let _g3 = nsegments;
		while(_g2 < _g3) {
			let i = _g2++;
			let a = (nsegments - 1 - i) * angle + angleStart;
			let x = cx + Math.cos(a) * innerRadius;
			let y = cy + Math.sin(a) * innerRadius;
			this.addVertex(x,y,this.curR,this.curG,this.curB,this.curA,x * this.ma + y * this.mc + this.mx,x * this.mb + y * this.md + this.my);
		}
		this.flush();
	}
	addVertex(x,y,r,g,b,a,u,v) {
		if(v == null) {
			v = 0.;
		}
		if(u == null) {
			u = 0.;
		}
		let half = this.lineSize / 2.0;
		if(x - half < this.xMin) {
			this.xMin = x - half;
		}
		if(y - half < this.yMin) {
			this.yMin = y - half;
		}
		if(x + half > this.xMax) {
			this.xMax = x + half;
		}
		if(y + half > this.yMax) {
			this.yMax = y + half;
		}
		if(x < this.xMinSize) {
			this.xMinSize = x;
		}
		if(y < this.yMinSize) {
			this.yMinSize = y;
		}
		if(x > this.xMaxSize) {
			this.xMaxSize = x;
		}
		if(y > this.yMaxSize) {
			this.yMaxSize = y;
		}
		if(this.doFill) {
			let _this = this.content;
			let this1 = _this.tmp;
			if(this1.pos == this1.array.length) {
				let newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = x;
			let this2 = _this.tmp;
			if(this2.pos == this2.array.length) {
				let newSize = this2.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this2.array);
				this2.array = newArray;
			}
			this2.array[this2.pos++] = y;
			let this3 = _this.tmp;
			if(this3.pos == this3.array.length) {
				let newSize = this3.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this3.array);
				this3.array = newArray;
			}
			this3.array[this3.pos++] = u;
			let this4 = _this.tmp;
			if(this4.pos == this4.array.length) {
				let newSize = this4.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this4.array);
				this4.array = newArray;
			}
			this4.array[this4.pos++] = v;
			let this5 = _this.tmp;
			if(this5.pos == this5.array.length) {
				let newSize = this5.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this5.array);
				this5.array = newArray;
			}
			this5.array[this5.pos++] = r;
			let this6 = _this.tmp;
			if(this6.pos == this6.array.length) {
				let newSize = this6.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this6.array);
				this6.array = newArray;
			}
			this6.array[this6.pos++] = g;
			let this7 = _this.tmp;
			if(this7.pos == this7.array.length) {
				let newSize = this7.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this7.array);
				this7.array = newArray;
			}
			this7.array[this7.pos++] = b;
			let this8 = _this.tmp;
			if(this8.pos == this8.array.length) {
				let newSize = this8.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this8.array);
				this8.array = newArray;
			}
			this8.array[this8.pos++] = a;
			_this.bufferDirty = true;
		}
		let gp = new h2d_GPoint();
		gp.load(x,y,this.lineR,this.lineG,this.lineB,this.lineA);
		this.tmpPoints.push(gp);
	}
	draw(ctx) {
		if(!ctx.beginDrawBatchState(this)) {
			return;
		}
		this.content.doRender(ctx);
	}
	sync(ctx) {
		super.sync(ctx);
		this.flush();
		this.content.flush();
	}
}
$hxClasses["h2d.Graphics"] = h2d_Graphics;
h2d_Graphics.__name__ = "h2d.Graphics";
h2d_Graphics.__super__ = h2d_Drawable;
Object.assign(h2d_Graphics.prototype, {
	__class__: h2d_Graphics
	,content: null
	,tmpPoints: null
	,pindex: null
	,curR: null
	,curG: null
	,curB: null
	,curA: null
	,lineSize: null
	,lineR: null
	,lineG: null
	,lineB: null
	,lineA: null
	,doFill: null
	,xMin: null
	,yMin: null
	,xMax: null
	,yMax: null
	,xMinSize: null
	,yMinSize: null
	,xMaxSize: null
	,yMaxSize: null
	,ma: null
	,mb: null
	,mc: null
	,md: null
	,mx: null
	,my: null
	,tile: null
	,bevel: null
});
var h2d_LineHeightMode = $hxEnums["h2d.LineHeightMode"] = { __ename__:true,__constructs__:null
	,Accurate: {_hx_name:"Accurate",_hx_index:0,__enum__:"h2d.LineHeightMode",toString:$estr}
	,TextOnly: {_hx_name:"TextOnly",_hx_index:1,__enum__:"h2d.LineHeightMode",toString:$estr}
	,Constant: {_hx_name:"Constant",_hx_index:2,__enum__:"h2d.LineHeightMode",toString:$estr}
};
h2d_LineHeightMode.__constructs__ = [h2d_LineHeightMode.Accurate,h2d_LineHeightMode.TextOnly,h2d_LineHeightMode.Constant];
h2d_LineHeightMode.__empty_constructs__ = [h2d_LineHeightMode.Accurate,h2d_LineHeightMode.TextOnly,h2d_LineHeightMode.Constant];
var h2d_ImageVerticalAlign = $hxEnums["h2d.ImageVerticalAlign"] = { __ename__:true,__constructs__:null
	,Top: {_hx_name:"Top",_hx_index:0,__enum__:"h2d.ImageVerticalAlign",toString:$estr}
	,Bottom: {_hx_name:"Bottom",_hx_index:1,__enum__:"h2d.ImageVerticalAlign",toString:$estr}
	,Middle: {_hx_name:"Middle",_hx_index:2,__enum__:"h2d.ImageVerticalAlign",toString:$estr}
};
h2d_ImageVerticalAlign.__constructs__ = [h2d_ImageVerticalAlign.Top,h2d_ImageVerticalAlign.Bottom,h2d_ImageVerticalAlign.Middle];
h2d_ImageVerticalAlign.__empty_constructs__ = [h2d_ImageVerticalAlign.Top,h2d_ImageVerticalAlign.Bottom,h2d_ImageVerticalAlign.Middle];
class h2d_HtmlText extends h2d_Text {
	constructor(font,parent) {
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor(font,parent);
	}
	_hx_constructor(font,parent) {
		this.elements = [];
		this.imageVerticalAlign = h2d_ImageVerticalAlign.Bottom;
		this.lineHeightMode = h2d_LineHeightMode.Accurate;
		this.imageSpacing = 1;
		this.condenseWhite = true;
		super._hx_constructor(font,parent);
	}
	draw(ctx) {
		if(this.dropShadow != null) {
			let oldX = this.absX;
			let oldY = this.absY;
			this.absX += this.dropShadow.dx * this.matA + this.dropShadow.dy * this.matC;
			this.absY += this.dropShadow.dx * this.matB + this.dropShadow.dy * this.matD;
			if(this.dropMatrix == null) {
				this.dropMatrix = new h3d_shader_ColorMatrix();
				this.addShader(this.dropMatrix);
			}
			let _this = this.dropMatrix;
			_this.constModified = true;
			_this.enabled__ = true;
			let m = this.dropMatrix.matrix__;
			m.zero();
			m._41 = (this.dropShadow.color >> 16 & 255) / 255;
			m._42 = (this.dropShadow.color >> 8 & 255) / 255;
			m._43 = (this.dropShadow.color & 255) / 255;
			m._44 = this.dropShadow.alpha;
			let _g = 0;
			let _g1 = this.elements;
			while(_g < _g1.length) {
				let e = _g1[_g];
				++_g;
				if(((e) instanceof h2d_TileGroup)) {
					(js_Boot.__cast(e , h2d_TileGroup)).drawWith(ctx,this);
				}
			}
			this.glyphs.drawWith(ctx,this);
			let _this1 = this.dropMatrix;
			_this1.constModified = true;
			_this1.enabled__ = false;
			this.absX = oldX;
			this.absY = oldY;
		} else {
			this.removeShader(this.dropMatrix);
			this.dropMatrix = null;
		}
		this.glyphs.drawWith(ctx,this);
	}
	loadImage(url) {
		return h2d_HtmlText.defaultLoadImage(url);
	}
	loadFont(name) {
		let f = h2d_HtmlText.defaultLoadFont(name);
		if(f == null) {
			return this.font;
		} else {
			return f;
		}
	}
	onHyperlink(url) {
	}
	formatText(text) {
		return h2d_HtmlText.defaultFormatText(text);
	}
	set_text(t) {
		super.set_text(this.formatText(t));
		return t;
	}
	parseText(text) {
		try {
			return Xml.parse(text);
		} catch( _g ) {
			throw haxe_Exception.thrown("Could not parse " + text + " (" + Std.string(haxe_Exception.caught(_g).unwrap()) + ")");
		}
	}
	validateText() {
		this.textXml = this.parseText(this.text);
		this.validateNodes(this.textXml);
	}
	validateNodes(xml) {
		switch(xml.nodeType) {
		case 0:
			if(xml.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
			}
			let nodeName = xml.nodeName.toLowerCase();
			switch(nodeName) {
			case "b":case "bold":
				this.loadFont("bold");
				break;
			case "font":
				if(xml.exists("face")) {
					this.loadFont(xml.get("face"));
				}
				break;
			case "img":
				this.loadImage(xml.get("src"));
				break;
			case "i":case "italic":
				this.loadFont("italic");
				break;
			}
			if(xml.nodeType != Xml.Document && xml.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
			}
			let _this = xml.children;
			let _g_current = 0;
			while(_g_current < _this.length) {
				let child = _this[_g_current++];
				this.validateNodes(child);
			}
			break;
		case 6:
			if(xml.nodeType != Xml.Document && xml.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (xml.nodeType == null ? "null" : XmlType.toString(xml.nodeType)));
			}
			let _this1 = xml.children;
			let _g_current1 = 0;
			while(_g_current1 < _this1.length) {
				let child = _this1[_g_current1++];
				this.validateNodes(child);
			}
			break;
		default:
		}
	}
	initGlyphs(text,rebuild) {
		if(rebuild == null) {
			rebuild = true;
		}
		if(rebuild) {
			this.glyphs.clear();
			let _g = 0;
			let _g1 = this.elements;
			while(_g < _g1.length) {
				let e = _g1[_g];
				++_g;
				if(e != null && e.parent != null) {
					e.parent.removeChild(e);
				}
			}
			this.elements = [];
		}
		this.glyphs.setDefaultColor(this.textColor);
		let doc;
		if(this.textXml == null) {
			doc = this.parseText(text);
		} else {
			doc = this.textXml;
		}
		this.yPos = 0;
		this.xMax = 0;
		this.xMin = Infinity;
		this.sizePos = 0;
		this.calcYMin = 0;
		let metrics = [{ width : 0, height : this.font.lineHeight, baseLine : this.font.baseLine}];
		this.prevChar = -1;
		this.newLine = true;
		let splitNode = { node : null, pos : 0, font : this.font, prevChar : -1, width : 0, height : 0, baseLine : 0};
		if(doc.nodeType != Xml.Document && doc.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (doc.nodeType == null ? "null" : XmlType.toString(doc.nodeType)));
		}
		let _this = doc.children;
		let _g_current = 0;
		while(_g_current < _this.length) {
			let e = _this[_g_current++];
			this.buildSizes(e,this.font,metrics,splitNode);
		}
		let max = 0.;
		let _g = 0;
		while(_g < metrics.length) {
			let info = metrics[_g];
			++_g;
			if(info.width > max) {
				max = info.width;
			}
		}
		this.calcWidth = max;
		this.prevChar = -1;
		this.newLine = true;
		let align = this.textAlign;
		let size = metrics[0].width;
		switch(align._hx_index) {
		case 0:
			this.xPos = 0;
			if(this.xMin > 0) {
				this.xMin = 0;
			}
			break;
		case 1:case 2:case 3:case 4:
			let max1 = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.calcWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
			let k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
			this.xPos = Math.floor((max1 - size) * k);
			if(this.xPos < this.xMin) {
				this.xMin = this.xPos;
			}
			break;
		}
		if(doc.nodeType != Xml.Document && doc.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (doc.nodeType == null ? "null" : XmlType.toString(doc.nodeType)));
		}
		let _this1 = doc.children;
		let _g_current1 = 0;
		while(_g_current1 < _this1.length) {
			let e = _this1[_g_current1++];
			this.addNode(e,this.font,this.textAlign,rebuild,metrics);
		}
		if(this.xPos > this.xMax) {
			this.xMax = this.xPos;
		}
		this.textXml = null;
		let y = this.yPos;
		this.calcXMin = this.xMin;
		this.calcWidth = this.xMax - this.xMin;
		this.calcHeight = y + metrics[this.sizePos].height;
		this.calcSizeHeight = y + metrics[this.sizePos].baseLine;
		this.calcDone = true;
		if(rebuild) {
			this.needsRebuild = false;
		}
	}
	buildSizes(e,font,metrics,splitNode) {
		let _gthis = this;
		let wordSplit = function() {
			let fnt = splitNode.font;
			let _this = splitNode.node;
			if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
			}
			let str = _this.nodeValue;
			let info = metrics[metrics.length - 1];
			let w = info.width;
			let cc = HxOverrides.cca(str,splitNode.pos);
			info.width = splitNode.width;
			info.height = splitNode.height;
			info.baseLine = splitNode.baseLine;
			let c = fnt.glyphs.h[cc];
			if(c == null) {
				c = fnt.charset.resolveChar(cc,fnt.glyphs);
				if(c == null) {
					c = cc == 13 || cc == 10 ? fnt.nullChar : fnt.defaultChar;
				}
			}
			let char = c;
			if(_gthis.lineBreak && fnt.charset.isSpace(cc)) {
				w -= splitNode.width + _gthis.letterSpacing + char.width + char.getKerningOffset(splitNode.prevChar);
				let _this = splitNode.node;
				let v = HxOverrides.substr(str,0,splitNode.pos) + "\n" + HxOverrides.substr(str,splitNode.pos + 1,null);
				if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
				}
				_this.nodeValue = v;
			} else {
				w -= splitNode.width + _gthis.letterSpacing + char.getKerningOffset(splitNode.prevChar);
				let _this = splitNode.node;
				let v = HxOverrides.substr(str,0,splitNode.pos + 1) + "\n" + HxOverrides.substr(str,splitNode.pos + 1,null);
				if(_this.nodeType == Xml.Document || _this.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (_this.nodeType == null ? "null" : XmlType.toString(_this.nodeType)));
				}
				_this.nodeValue = v;
			}
			splitNode.node = null;
			return w;
		};
		if(e.nodeType == Xml.Element) {
			if(e.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			let nodeName = e.nodeName.toLowerCase();
			switch(nodeName) {
			case "b":case "bold":
				font = this.loadFont("bold");
				break;
			case "br":
				let fontInfo = _gthis.lineHeightMode == h2d_LineHeightMode.Constant ? _gthis.font : font;
				metrics.push({ width : 0, height : fontInfo.lineHeight, baseLine : fontInfo.baseLine});
				splitNode.node = null;
				_gthis.newLine = true;
				_gthis.prevChar = -1;
				break;
			case "font":
				let a = e.attributes();
				while(a.hasNext()) {
					let a1 = a.next();
					let v = e.get(a1);
					if(a1.toLowerCase() == "face") {
						font = this.loadFont(v);
					}
				}
				break;
			case "img":
				let i = this.loadImage(e.get("src"));
				if(i == null) {
					i = h2d_Tile.fromColor(16711935,8,8);
				}
				let size = metrics[metrics.length - 1].width + i.width + this.imageSpacing;
				if(this.realMaxWidth >= 0 && size > this.realMaxWidth && metrics[metrics.length - 1].width > 0) {
					if(splitNode.node != null) {
						size = wordSplit() + i.width + this.imageSpacing;
						let info = metrics[metrics.length - 1];
						if(this.lineHeightMode._hx_index == 0) {
							let grow = i.height - i.dy - info.baseLine;
							let h = info.height;
							let bl = info.baseLine;
							if(grow > 0) {
								h += grow;
								bl += grow;
							}
							metrics.push({ width : size, height : Math.max(h,bl + i.dy), baseLine : bl});
						} else {
							metrics.push({ width : size, height : info.height, baseLine : info.baseLine});
						}
					}
				} else {
					let info = metrics[metrics.length - 1];
					info.width = size;
					if(this.lineHeightMode == h2d_LineHeightMode.Accurate) {
						let grow = i.height - i.dy - info.baseLine;
						if(grow > 0) {
							switch(this.imageVerticalAlign._hx_index) {
							case 0:
								info.height += grow;
								break;
							case 1:
								info.baseLine += grow;
								info.height += grow;
								break;
							case 2:
								info.height += grow;
								info.baseLine += grow / 2 | 0;
								break;
							}
						}
						grow = info.baseLine + i.dy;
						if(info.height < grow) {
							info.height = grow;
						}
					}
				}
				this.newLine = false;
				this.prevChar = -1;
				break;
			case "i":case "italic":
				font = this.loadFont("italic");
				break;
			case "p":
				if(!this.newLine) {
					let fontInfo = _gthis.lineHeightMode == h2d_LineHeightMode.Constant ? _gthis.font : font;
					metrics.push({ width : 0, height : fontInfo.lineHeight, baseLine : fontInfo.baseLine});
					splitNode.node = null;
					_gthis.newLine = true;
					_gthis.prevChar = -1;
				}
				break;
			default:
			}
			if(e.nodeType != Xml.Document && e.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			let _this = e.children;
			let _g_current = 0;
			while(_g_current < _this.length) {
				let child = _this[_g_current++];
				this.buildSizes(child,font,metrics,splitNode);
			}
			if(nodeName == "p") {
				if(!this.newLine) {
					let fontInfo = _gthis.lineHeightMode == h2d_LineHeightMode.Constant ? _gthis.font : font;
					metrics.push({ width : 0, height : fontInfo.lineHeight, baseLine : fontInfo.baseLine});
					splitNode.node = null;
					_gthis.newLine = true;
					_gthis.prevChar = -1;
				}
			}
		} else {
			if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			if(e.nodeValue.length != 0) {
				this.newLine = false;
				if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
				}
				let text = this.htmlToText(e.nodeValue);
				let fontInfo = _gthis.lineHeightMode == h2d_LineHeightMode.Constant ? _gthis.font : font;
				let info = metrics.pop();
				let leftMargin = info.width;
				let maxWidth = this.realMaxWidth < 0 ? Infinity : this.realMaxWidth;
				let textSplit = [];
				let restPos = 0;
				let x = leftMargin;
				let breakChars = 0;
				let _g = 0;
				let _g1 = text.length;
				while(_g < _g1) {
					let i = _g++;
					let cc = HxOverrides.cca(text,i);
					let c = font.glyphs.h[cc];
					if(c == null) {
						c = font.charset.resolveChar(cc,font.glyphs);
						if(c == null) {
							c = cc == 13 || cc == 10 ? font.nullChar : font.defaultChar;
						}
					}
					let g = c;
					let newline = cc == 10;
					let esize = g.width + g.getKerningOffset(this.prevChar);
					let nc = HxOverrides.cca(text,i + 1);
					if(font.charset.isBreakChar(cc) && (nc == null || !font.charset.isComplementChar(nc))) {
						if(x > maxWidth && textSplit.length == 0 && splitNode.node != null) {
							metrics.push({ width : x, height : info.height, baseLine : info.baseLine});
							x = wordSplit();
						}
						let size = x + esize + this.letterSpacing;
						let k = i + 1;
						let max = text.length;
						let prevChar = cc;
						while(size <= maxWidth && k < max) {
							let cc = HxOverrides.cca(text,k++);
							if(this.lineBreak && (font.charset.isSpace(cc) || cc == 10)) {
								break;
							}
							let c = font.glyphs.h[cc];
							if(c == null) {
								c = font.charset.resolveChar(cc,font.glyphs);
								if(c == null) {
									c = cc == 13 || cc == 10 ? font.nullChar : font.defaultChar;
								}
							}
							let e = c;
							size += e.width + this.letterSpacing + e.getKerningOffset(prevChar);
							prevChar = cc;
							let nc = HxOverrides.cca(text,k);
							if(font.charset.isBreakChar(cc) && (nc == null || !font.charset.isComplementChar(nc))) {
								break;
							}
						}
						if(this.lineBreak && size > maxWidth && i != max - 1) {
							newline = true;
							if(font.charset.isSpace(cc)) {
								textSplit.push(HxOverrides.substr(text,restPos,i - restPos));
								g = null;
							} else {
								textSplit.push(HxOverrides.substr(text,restPos,i + 1 - restPos));
								++breakChars;
							}
							splitNode.node = null;
							restPos = i + 1;
						} else {
							splitNode.node = e;
							splitNode.pos = i + breakChars;
							splitNode.prevChar = this.prevChar;
							splitNode.width = x;
							splitNode.height = info.height;
							splitNode.baseLine = info.baseLine;
							splitNode.font = font;
						}
					}
					if(g != null && cc != 10) {
						x += esize + this.letterSpacing;
					}
					if(newline) {
						metrics.push({ width : x, height : info.height, baseLine : info.baseLine});
						info.height = fontInfo.lineHeight;
						info.baseLine = fontInfo.baseLine;
						x = 0;
						this.prevChar = -1;
						this.newLine = true;
					} else {
						this.prevChar = cc;
						this.newLine = false;
					}
				}
				if(restPos < text.length) {
					if(x > maxWidth) {
						if(splitNode.node != null && splitNode.node != e) {
							metrics.push({ width : x, height : info.height, baseLine : info.baseLine});
							x = wordSplit();
						}
					}
					textSplit.push(HxOverrides.substr(text,restPos,null));
					metrics.push({ width : x, height : info.height, baseLine : info.baseLine});
				}
				if(this.newLine || metrics.length == 0) {
					metrics.push({ width : 0, height : fontInfo.lineHeight, baseLine : fontInfo.baseLine});
					textSplit.push("");
				}
				let v = textSplit.join("\n");
				if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
				}
				e.nodeValue = v;
			}
		}
	}
	htmlToText(t) {
		if(this.condenseWhite) {
			t = t.replace(h2d_HtmlText.REG_SPACES.r," ");
		}
		return t;
	}
	addNode(e,font,align,rebuild,metrics) {
		let _gthis = this;
		if(e.nodeType == Xml.Element) {
			let prevColor = null;
			let prevGlyphs = null;
			let oldAlign = align;
			if(e.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			let nodeName = e.nodeName.toLowerCase();
			switch(nodeName) {
			case "a":
				if(e.exists("href")) {
					if(_gthis.aInteractive != null) {
						_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
						_gthis.aInteractive = null;
					}
					if(this.aHrefs == null) {
						this.aHrefs = [];
					}
					this.aHrefs.push(e.get("href"));
					if(!(_gthis.aHrefs == null || _gthis.aHrefs.length == 0)) {
						_gthis.aInteractive = new h2d_Interactive(0,metrics[_gthis.sizePos].height,_gthis);
						let href = _gthis.aHrefs[_gthis.aHrefs.length - 1];
						_gthis.aInteractive.onClick = function(event) {
							_gthis.onHyperlink(href);
						};
						let _this = _gthis.aInteractive;
						let v = _gthis.xPos;
						_this.posChanged = true;
						_this.x = v;
						let _this1 = _gthis.aInteractive;
						let v1 = _gthis.yPos;
						_this1.posChanged = true;
						_this1.y = v1;
						_gthis.elements.push(_gthis.aInteractive);
					}
				}
				break;
			case "b":case "bold":
				font = _gthis.loadFont("bold");
				prevGlyphs = _gthis.glyphs;
				let prev = _gthis.glyphs;
				_gthis.glyphs = new h2d_TileGroup(font == null ? null : font.tile,_gthis);
				if(font != null) {
					let _g = font.type;
					if(_g._hx_index == 1) {
						let _g1 = _g.smoothing;
						let shader = new h3d_shader_SignedDistanceField();
						shader.constModified = true;
						shader.channel__ = _g.channel;
						shader.alphaCutoff__ = _g.alphaCutoff;
						shader.smoothing__ = _g1;
						shader.constModified = true;
						shader.autoSmoothing__ = _g1 == -1;
						_gthis.glyphs.smooth = _gthis.smooth;
						_gthis.glyphs.addShader(shader);
					}
				}
				let _this = _gthis.glyphs.curColor;
				let v = prev.curColor;
				_this.x = v.x;
				_this.y = v.y;
				_this.z = v.z;
				_this.w = v.w;
				_gthis.elements.push(_gthis.glyphs);
				break;
			case "br":
				if(_gthis.aInteractive != null) {
					_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
					_gthis.aInteractive = null;
				}
				if(_gthis.xPos > _gthis.xMax) {
					_gthis.xMax = _gthis.xPos;
				}
				_gthis.yPos += metrics[_gthis.sizePos].height + _gthis.lineSpacing;
				let size = metrics[++_gthis.sizePos].width;
				switch(align._hx_index) {
				case 0:
					_gthis.xPos = 0;
					if(_gthis.xMin > 0) {
						_gthis.xMin = 0;
					}
					break;
				case 1:case 2:case 3:case 4:
					let max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(_gthis.calcWidth) : _gthis.calcWidth < 0 ? 0 : Math.ceil(_gthis.realMaxWidth);
					let k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
					_gthis.xPos = Math.floor((max - size) * k);
					if(_gthis.xPos < _gthis.xMin) {
						_gthis.xMin = _gthis.xPos;
					}
					break;
				}
				if(!(_gthis.aHrefs == null || _gthis.aHrefs.length == 0)) {
					_gthis.aInteractive = new h2d_Interactive(0,metrics[_gthis.sizePos].height,_gthis);
					let href = _gthis.aHrefs[_gthis.aHrefs.length - 1];
					_gthis.aInteractive.onClick = function(event) {
						_gthis.onHyperlink(href);
					};
					let _this = _gthis.aInteractive;
					let v = _gthis.xPos;
					_this.posChanged = true;
					_this.x = v;
					let _this1 = _gthis.aInteractive;
					let v1 = _gthis.yPos;
					_this1.posChanged = true;
					_this1.y = v1;
					_gthis.elements.push(_gthis.aInteractive);
				}
				this.newLine = true;
				this.prevChar = -1;
				break;
			case "font":
				let a = e.attributes();
				while(a.hasNext()) {
					let a1 = a.next();
					let v = e.get(a1);
					switch(a1.toLowerCase()) {
					case "color":
						if(prevColor == null) {
							let _this = this.glyphs.curColor;
							prevColor = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
						}
						if(HxOverrides.cca(v,0) == 35 && v.length == 4) {
							v = "#" + v.charAt(1) + v.charAt(1) + v.charAt(2) + v.charAt(2) + v.charAt(3) + v.charAt(3);
						}
						this.glyphs.setDefaultColor(Std.parseInt("0x" + HxOverrides.substr(v,1,null)));
						break;
					case "face":
						font = _gthis.loadFont(v);
						if(prevGlyphs == null) {
							prevGlyphs = _gthis.glyphs;
						}
						let prev = _gthis.glyphs;
						_gthis.glyphs = new h2d_TileGroup(font == null ? null : font.tile,_gthis);
						if(font != null) {
							let _g = font.type;
							if(_g._hx_index == 1) {
								let _g1 = _g.smoothing;
								let shader = new h3d_shader_SignedDistanceField();
								shader.constModified = true;
								shader.channel__ = _g.channel;
								shader.alphaCutoff__ = _g.alphaCutoff;
								shader.smoothing__ = _g1;
								shader.constModified = true;
								shader.autoSmoothing__ = _g1 == -1;
								_gthis.glyphs.smooth = _gthis.smooth;
								_gthis.glyphs.addShader(shader);
							}
						}
						let _this = _gthis.glyphs.curColor;
						let v1 = prev.curColor;
						_this.x = v1.x;
						_this.y = v1.y;
						_this.z = v1.z;
						_this.w = v1.w;
						_gthis.elements.push(_gthis.glyphs);
						break;
					case "opacity":
						if(prevColor == null) {
							let _this = this.glyphs.curColor;
							prevColor = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
						}
						this.glyphs.curColor.w *= parseFloat(v);
						break;
					default:
					}
				}
				break;
			case "img":
				let i = this.loadImage(e.get("src"));
				if(i == null) {
					i = h2d_Tile.fromColor(16711935,8,8);
				}
				let py = this.yPos;
				switch(this.imageVerticalAlign._hx_index) {
				case 0:
					break;
				case 1:
					py += metrics[this.sizePos].baseLine - i.height;
					break;
				case 2:
					py += metrics[this.sizePos].baseLine - i.height / 2;
					break;
				}
				if(py + i.dy < this.calcYMin) {
					this.calcYMin = py + i.dy;
				}
				if(rebuild) {
					let b = new h2d_Bitmap(i,this);
					b.posChanged = true;
					b.x = this.xPos;
					b.posChanged = true;
					b.y = py;
					this.elements.push(b);
				}
				this.newLine = false;
				this.prevChar = -1;
				this.xPos += i.width + this.imageSpacing;
				break;
			case "i":case "italic":
				font = _gthis.loadFont("italic");
				prevGlyphs = _gthis.glyphs;
				let prev1 = _gthis.glyphs;
				_gthis.glyphs = new h2d_TileGroup(font == null ? null : font.tile,_gthis);
				if(font != null) {
					let _g = font.type;
					if(_g._hx_index == 1) {
						let _g1 = _g.smoothing;
						let shader = new h3d_shader_SignedDistanceField();
						shader.constModified = true;
						shader.channel__ = _g.channel;
						shader.alphaCutoff__ = _g.alphaCutoff;
						shader.smoothing__ = _g1;
						shader.constModified = true;
						shader.autoSmoothing__ = _g1 == -1;
						_gthis.glyphs.smooth = _gthis.smooth;
						_gthis.glyphs.addShader(shader);
					}
				}
				let _this1 = _gthis.glyphs.curColor;
				let v1 = prev1.curColor;
				_this1.x = v1.x;
				_this1.y = v1.y;
				_this1.z = v1.z;
				_this1.w = v1.w;
				_gthis.elements.push(_gthis.glyphs);
				break;
			case "p":
				let a1 = e.attributes();
				while(a1.hasNext()) {
					let a = a1.next();
					if(a.toLowerCase() == "align") {
						let v = e.get(a);
						if(v != null) {
							switch(v.toLowerCase()) {
							case "center":
								align = h2d_Align.Center;
								break;
							case "left":
								align = h2d_Align.Left;
								break;
							case "multiline-center":
								align = h2d_Align.MultilineCenter;
								break;
							case "multiline-right":
								align = h2d_Align.MultilineRight;
								break;
							case "right":
								align = h2d_Align.Right;
								break;
							}
						}
					}
				}
				if(!this.newLine) {
					if(_gthis.aInteractive != null) {
						_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
						_gthis.aInteractive = null;
					}
					if(_gthis.xPos > _gthis.xMax) {
						_gthis.xMax = _gthis.xPos;
					}
					_gthis.yPos += metrics[_gthis.sizePos].height + _gthis.lineSpacing;
					let size = metrics[++_gthis.sizePos].width;
					switch(align._hx_index) {
					case 0:
						_gthis.xPos = 0;
						if(_gthis.xMin > 0) {
							_gthis.xMin = 0;
						}
						break;
					case 1:case 2:case 3:case 4:
						let max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(_gthis.calcWidth) : _gthis.calcWidth < 0 ? 0 : Math.ceil(_gthis.realMaxWidth);
						let k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
						_gthis.xPos = Math.floor((max - size) * k);
						if(_gthis.xPos < _gthis.xMin) {
							_gthis.xMin = _gthis.xPos;
						}
						break;
					}
					if(!(_gthis.aHrefs == null || _gthis.aHrefs.length == 0)) {
						_gthis.aInteractive = new h2d_Interactive(0,metrics[_gthis.sizePos].height,_gthis);
						let href = _gthis.aHrefs[_gthis.aHrefs.length - 1];
						_gthis.aInteractive.onClick = function(event) {
							_gthis.onHyperlink(href);
						};
						let _this = _gthis.aInteractive;
						let v = _gthis.xPos;
						_this.posChanged = true;
						_this.x = v;
						let _this1 = _gthis.aInteractive;
						let v1 = _gthis.yPos;
						_this1.posChanged = true;
						_this1.y = v1;
						_gthis.elements.push(_gthis.aInteractive);
					}
					this.newLine = true;
					this.prevChar = -1;
				} else {
					let size = metrics[this.sizePos].width;
					switch(align._hx_index) {
					case 0:
						this.xPos = 0;
						if(this.xMin > 0) {
							this.xMin = 0;
						}
						break;
					case 1:case 2:case 3:case 4:
						let max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.calcWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
						let k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
						this.xPos = Math.floor((max - size) * k);
						if(this.xPos < this.xMin) {
							this.xMin = this.xPos;
						}
						break;
					}
				}
				break;
			default:
			}
			if(e.nodeType != Xml.Document && e.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			let _this2 = e.children;
			let _g_current = 0;
			while(_g_current < _this2.length) {
				let child = _this2[_g_current++];
				this.addNode(child,font,align,rebuild,metrics);
			}
			align = oldAlign;
			switch(nodeName) {
			case "a":
				if(this.aHrefs.length > 0) {
					if(_gthis.aInteractive != null) {
						_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
						_gthis.aInteractive = null;
					}
					this.aHrefs.pop();
					if(!(_gthis.aHrefs == null || _gthis.aHrefs.length == 0)) {
						_gthis.aInteractive = new h2d_Interactive(0,metrics[_gthis.sizePos].height,_gthis);
						let href = _gthis.aHrefs[_gthis.aHrefs.length - 1];
						_gthis.aInteractive.onClick = function(event) {
							_gthis.onHyperlink(href);
						};
						let _this = _gthis.aInteractive;
						let v = _gthis.xPos;
						_this.posChanged = true;
						_this.x = v;
						let _this1 = _gthis.aInteractive;
						let v1 = _gthis.yPos;
						_this1.posChanged = true;
						_this1.y = v1;
						_gthis.elements.push(_gthis.aInteractive);
					}
				}
				break;
			case "p":
				if(this.newLine) {
					let size = metrics[this.sizePos].width;
					switch(oldAlign._hx_index) {
					case 0:
						this.xPos = 0;
						if(this.xMin > 0) {
							this.xMin = 0;
						}
						break;
					case 1:case 2:case 3:case 4:
						let max = oldAlign == h2d_Align.MultilineCenter || oldAlign == h2d_Align.MultilineRight ? Math.ceil(this.calcWidth) : this.calcWidth < 0 ? 0 : Math.ceil(this.realMaxWidth);
						let k = oldAlign == h2d_Align.Center || oldAlign == h2d_Align.MultilineCenter ? 0.5 : 1;
						this.xPos = Math.floor((max - size) * k);
						if(this.xPos < this.xMin) {
							this.xMin = this.xPos;
						}
						break;
					}
				} else if(this.sizePos < metrics.length - 2 || metrics[this.sizePos + 1].width != 0) {
					if(_gthis.aInteractive != null) {
						_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
						_gthis.aInteractive = null;
					}
					if(_gthis.xPos > _gthis.xMax) {
						_gthis.xMax = _gthis.xPos;
					}
					_gthis.yPos += metrics[_gthis.sizePos].height + _gthis.lineSpacing;
					let size = metrics[++_gthis.sizePos].width;
					switch(oldAlign._hx_index) {
					case 0:
						_gthis.xPos = 0;
						if(_gthis.xMin > 0) {
							_gthis.xMin = 0;
						}
						break;
					case 1:case 2:case 3:case 4:
						let max = oldAlign == h2d_Align.MultilineCenter || oldAlign == h2d_Align.MultilineRight ? Math.ceil(_gthis.calcWidth) : _gthis.calcWidth < 0 ? 0 : Math.ceil(_gthis.realMaxWidth);
						let k = oldAlign == h2d_Align.Center || oldAlign == h2d_Align.MultilineCenter ? 0.5 : 1;
						_gthis.xPos = Math.floor((max - size) * k);
						if(_gthis.xPos < _gthis.xMin) {
							_gthis.xMin = _gthis.xPos;
						}
						break;
					}
					if(!(_gthis.aHrefs == null || _gthis.aHrefs.length == 0)) {
						_gthis.aInteractive = new h2d_Interactive(0,metrics[_gthis.sizePos].height,_gthis);
						let href = _gthis.aHrefs[_gthis.aHrefs.length - 1];
						_gthis.aInteractive.onClick = function(event) {
							_gthis.onHyperlink(href);
						};
						let _this = _gthis.aInteractive;
						let v = _gthis.xPos;
						_this.posChanged = true;
						_this.x = v;
						let _this1 = _gthis.aInteractive;
						let v1 = _gthis.yPos;
						_this1.posChanged = true;
						_this1.y = v1;
						_gthis.elements.push(_gthis.aInteractive);
					}
					this.newLine = true;
					this.prevChar = -1;
				}
				break;
			default:
			}
			if(prevGlyphs != null) {
				this.glyphs = prevGlyphs;
			}
			if(prevColor != null) {
				let _this = this.glyphs.curColor;
				_this.x = prevColor.x;
				_this.y = prevColor.y;
				_this.z = prevColor.z;
				_this.w = prevColor.w;
			}
		} else {
			if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
			}
			if(e.nodeValue.length != 0) {
				this.newLine = false;
				if(e.nodeType == Xml.Document || e.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (e.nodeType == null ? "null" : XmlType.toString(e.nodeType)));
				}
				let t = e.nodeValue;
				let dy = metrics[this.sizePos].baseLine - font.baseLine;
				let _g = 0;
				let _g1 = t.length;
				while(_g < _g1) {
					let i = _g++;
					let cc = HxOverrides.cca(t,i);
					if(cc == 10) {
						if(_gthis.aInteractive != null) {
							_gthis.aInteractive.width = _gthis.xPos - _gthis.aInteractive.x;
							_gthis.aInteractive = null;
						}
						if(_gthis.xPos > _gthis.xMax) {
							_gthis.xMax = _gthis.xPos;
						}
						_gthis.yPos += metrics[_gthis.sizePos].height + _gthis.lineSpacing;
						let size = metrics[++_gthis.sizePos].width;
						switch(align._hx_index) {
						case 0:
							_gthis.xPos = 0;
							if(_gthis.xMin > 0) {
								_gthis.xMin = 0;
							}
							break;
						case 1:case 2:case 3:case 4:
							let max = align == h2d_Align.MultilineCenter || align == h2d_Align.MultilineRight ? Math.ceil(_gthis.calcWidth) : _gthis.calcWidth < 0 ? 0 : Math.ceil(_gthis.realMaxWidth);
							let k = align == h2d_Align.Center || align == h2d_Align.MultilineCenter ? 0.5 : 1;
							_gthis.xPos = Math.floor((max - size) * k);
							if(_gthis.xPos < _gthis.xMin) {
								_gthis.xMin = _gthis.xPos;
							}
							break;
						}
						if(!(_gthis.aHrefs == null || _gthis.aHrefs.length == 0)) {
							_gthis.aInteractive = new h2d_Interactive(0,metrics[_gthis.sizePos].height,_gthis);
							let href = _gthis.aHrefs[_gthis.aHrefs.length - 1];
							_gthis.aInteractive.onClick = function(event) {
								_gthis.onHyperlink(href);
							};
							let _this = _gthis.aInteractive;
							let v = _gthis.xPos;
							_this.posChanged = true;
							_this.x = v;
							let _this1 = _gthis.aInteractive;
							let v1 = _gthis.yPos;
							_this1.posChanged = true;
							_this1.y = v1;
							_gthis.elements.push(_gthis.aInteractive);
						}
						dy = metrics[this.sizePos].baseLine - font.baseLine;
						this.prevChar = -1;
						continue;
					} else {
						let c = font.glyphs.h[cc];
						if(c == null) {
							c = font.charset.resolveChar(cc,font.glyphs);
							if(c == null) {
								c = cc == 13 || cc == 10 ? font.nullChar : font.defaultChar;
							}
						}
						let fc = c;
						if(fc != null) {
							this.xPos += fc.getKerningOffset(this.prevChar);
							if(rebuild) {
								let _this = this.glyphs;
								_this.content.add(this.xPos,this.yPos + dy,_this.curColor.x,_this.curColor.y,_this.curColor.z,_this.curColor.w,fc.t);
							}
							if(this.yPos == 0 && fc.t.dy + dy < this.calcYMin) {
								this.calcYMin = fc.t.dy + dy;
							}
							this.xPos += fc.width + this.letterSpacing;
						}
						this.prevChar = cc;
					}
				}
			}
		}
	}
	set_textColor(c) {
		if(this.textColor == c) {
			return c;
		}
		this.textColor = c;
		this.rebuild();
		return c;
	}
	set_lineHeightMode(v) {
		if(this.lineHeightMode != v) {
			this.lineHeightMode = v;
			this.rebuild();
		}
		return v;
	}
	getBoundsRec(relativeTo,out,forSize) {
		if(forSize) {
			let _g = 0;
			let _g1 = this.elements;
			while(_g < _g1.length) {
				let i = _g1[_g];
				++_g;
				if(((i) instanceof h2d_Bitmap)) {
					i.set_visible(false);
				}
			}
		}
		super.getBoundsRec(relativeTo,out,forSize);
		if(forSize) {
			let _g = 0;
			let _g1 = this.elements;
			while(_g < _g1.length) {
				let i = _g1[_g];
				++_g;
				i.set_visible(true);
			}
		}
	}
	static defaultLoadImage(url) {
		return null;
	}
	static defaultLoadFont(name) {
		return null;
	}
	static defaultFormatText(text) {
		return text;
	}
}
$hxClasses["h2d.HtmlText"] = h2d_HtmlText;
h2d_HtmlText.__name__ = "h2d.HtmlText";
h2d_HtmlText.__super__ = h2d_Text;
Object.assign(h2d_HtmlText.prototype, {
	__class__: h2d_HtmlText
	,condenseWhite: null
	,imageSpacing: null
	,lineHeightMode: null
	,imageVerticalAlign: null
	,elements: null
	,xPos: null
	,yPos: null
	,xMax: null
	,xMin: null
	,textXml: null
	,sizePos: null
	,dropMatrix: null
	,prevChar: null
	,newLine: null
	,aHrefs: null
	,aInteractive: null
});
class hxd_Interactive {
}
$hxClasses["hxd.Interactive"] = hxd_Interactive;
hxd_Interactive.__name__ = "hxd.Interactive";
hxd_Interactive.__isInterface__ = true;
Object.assign(hxd_Interactive.prototype, {
	__class__: hxd_Interactive
	,cursor: null
	,handleEvent: null
	,getInteractiveScene: null
});
class h2d_Interactive extends h2d_Object {
	constructor(width,height,parent,shape) {
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor(width,height,parent,shape);
	}
	_hx_constructor(width,height,parent,shape) {
		this.shapeY = 0;
		this.shapeX = 0;
		this.forceAnywherefocus = false;
		this.lastClickFrame = -1;
		this.mouseDownButton = -1;
		this.allowMultiClick = false;
		this.enableRightButton = false;
		this.propagateEvents = false;
		this.cancelEvents = false;
		this.cursor = hxd_Cursor.Button;
		super._hx_constructor(parent);
		this.width = width;
		this.height = height;
		this.shape = shape;
	}
	onAdd() {
		this.scene = this.getScene();
		if(this.scene != null) {
			this.scene.addEventTarget(this);
		}
		super.onAdd();
	}
	draw(ctx) {
		this.maskedBounds = ctx.getCurrentRenderZone(this.maskedBounds);
		if(this.backgroundColor != null) {
			this.emitTile(ctx,h2d_Tile.fromColor(this.backgroundColor,this.width | 0,this.height | 0,(this.backgroundColor >>> 24) / 255));
		}
	}
	getBoundsRec(relativeTo,out,forSize) {
		super.getBoundsRec(relativeTo,out,forSize);
		if(this.backgroundColor != null || forSize) {
			this.addBounds(relativeTo,out,0,0,this.width | 0,this.height | 0);
		}
	}
	onHierarchyMoved(parentChanged) {
		super.onHierarchyMoved(parentChanged);
		if(this.scene != null) {
			this.scene.removeEventTarget(this);
			this.scene = this.getScene();
			if(this.scene != null) {
				this.scene.addEventTarget(this);
			}
		}
	}
	onRemove() {
		if(this.scene != null) {
			this.scene.removeEventTarget(this,true);
			this.scene = null;
		}
		super.onRemove();
	}
	checkBounds(e) {
		switch(e.kind._hx_index) {
		case 4:case 6:case 7:case 10:
			return false;
		default:
			return true;
		}
	}
	getInteractiveScene() {
		return this.scene;
	}
	handleEvent(e) {
		if(!this.forceAnywherefocus) {
			if(this.maskedBounds != null && this.checkBounds(e)) {
				let pt = new h2d_col_Point(e.relX,e.relY);
				this.localToGlobal(pt);
				if(pt.x < this.maskedBounds.xMin || pt.y < this.maskedBounds.yMin || pt.x > this.maskedBounds.xMax || pt.y > this.maskedBounds.yMax) {
					e.cancel = true;
					return;
				}
			}
			if(this.shape == null && this.isEllipse && this.checkBounds(e)) {
				let cx = this.width * 0.5;
				let cy = this.height * 0.5;
				let dx = (e.relX - cx) / cx;
				let dy = (e.relY - cy) / cy;
				if(dx * dx + dy * dy > 1) {
					e.cancel = true;
					return;
				}
			}
		}
		if(this.propagateEvents) {
			e.propagate = true;
		}
		if(this.cancelEvents) {
			e.cancel = true;
		}
		switch(e.kind._hx_index) {
		case 0:
			if(this.enableRightButton || e.button == 0) {
				this.mouseDownButton = e.button;
				this.onPush(e);
				if(e.cancel) {
					this.mouseDownButton = -1;
				}
			}
			break;
		case 1:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				let frame = hxd_Timer.frameCount;
				if(this.mouseDownButton == e.button && (this.lastClickFrame != frame || this.allowMultiClick)) {
					this.onClick(e);
					this.lastClickFrame = frame;
				}
			}
			this.mouseDownButton = -1;
			break;
		case 2:
			this.onMove(e);
			break;
		case 3:
			this.onOver(e);
			break;
		case 4:
			this.onOut(e);
			break;
		case 5:
			e.propagate = true;
			this.onWheel(e);
			break;
		case 6:
			this.onFocus(e);
			break;
		case 7:
			this.onFocusLost(e);
			break;
		case 8:
			this.onKeyDown(e);
			break;
		case 9:
			this.onKeyUp(e);
			break;
		case 10:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				if(this.mouseDownButton == e.button) {
					this.onReleaseOutside(e);
				}
			}
			this.mouseDownButton = -1;
			break;
		case 11:
			this.onTextInput(e);
			break;
		case 12:
			this.onCheck(e);
			break;
		}
	}
	calcAbsPos() {
		super.calcAbsPos();
		this.invDet = 1 / (this.matA * this.matD - this.matB * this.matC);
	}
	set_cursor(c) {
		this.cursor = c;
		if(this.scene != null && this.scene.events != null) {
			this.scene.events.updateCursor(this);
		}
		return c;
	}
	eventToLocal(e) {
		let dx = e.relX - this.absX;
		let dy = e.relY - this.absY;
		e.relX = (dx * this.matD - dy * this.matC) * this.invDet;
		e.relY = (-dx * this.matB + dy * this.matA) * this.invDet;
	}
	startCapture(callb,onCancel,touchId) {
		let _gthis = this;
		this.scene.startCapture(function(event) {
			let x = event.relX;
			let y = event.relY;
			_gthis.eventToLocal(event);
			callb(event);
			event.relX = x;
			event.relY = y;
		},onCancel,touchId);
	}
	stopCapture() {
		this.scene.stopCapture();
	}
	focus() {
		if(this.scene == null || this.scene.events == null) {
			return;
		}
		this.scene.events.focus(this);
	}
	blur() {
		if(this.hasFocus()) {
			this.scene.events.blur();
		}
	}
	hasFocus() {
		if(this.scene != null && this.scene.events != null) {
			return this.scene.events.currentFocus == this;
		} else {
			return false;
		}
	}
	onOver(e) {
	}
	onOut(e) {
	}
	onPush(e) {
	}
	onRelease(e) {
	}
	onReleaseOutside(e) {
	}
	onClick(e) {
	}
	onMove(e) {
	}
	onWheel(e) {
	}
	onFocus(e) {
	}
	onFocusLost(e) {
	}
	onKeyUp(e) {
	}
	onKeyDown(e) {
	}
	onCheck(e) {
	}
	onTextInput(e) {
	}
}
$hxClasses["h2d.Interactive"] = h2d_Interactive;
h2d_Interactive.__name__ = "h2d.Interactive";
h2d_Interactive.__interfaces__ = [hxd_Interactive];
h2d_Interactive.__super__ = h2d_Object;
Object.assign(h2d_Interactive.prototype, {
	__class__: h2d_Interactive
	,width: null
	,height: null
	,cursor: null
	,isEllipse: null
	,cancelEvents: null
	,propagateEvents: null
	,enableRightButton: null
	,allowMultiClick: null
	,backgroundColor: null
	,scene: null
	,mouseDownButton: null
	,lastClickFrame: null
	,invDet: null
	,maskedBounds: null
	,forceAnywherefocus: null
	,shape: null
	,shapeX: null
	,shapeY: null
});
class h2d_Layers extends h2d_Object {
	_hx_constructor(parent) {
		super._hx_constructor(parent);
		this.layersIndexes = [];
		this.layerCount = 0;
	}
	addChild(s) {
		this.add(s,-1);
	}
	add(s,layer,index) {
		if(index == null) {
			index = -1;
		}
		if(layer == null) {
			layer = -1;
		}
		if(s.parent == this) {
			let old = s.allocated;
			s.allocated = false;
			this.removeChild(s);
			s.allocated = old;
		}
		if(layer == -1) {
			layer = this.layerCount == 0 ? 0 : this.layerCount - 1;
		}
		while(layer >= this.layerCount) this.layersIndexes[this.layerCount++] = this.children.length;
		if(index != -1) {
			if(layer == 0) {
				let b = this.layersIndexes[layer];
				let b1 = index > b ? b : index;
				super.addChildAt(s,0 < b1 ? b1 : 0);
			} else if(index < 0) {
				super.addChildAt(s,this.layersIndexes[layer - 1]);
			} else {
				let a = this.layersIndexes[layer - 1] + index;
				let b = this.layersIndexes[layer];
				super.addChildAt(s,a > b ? b : a);
			}
		} else {
			super.addChildAt(s,this.layersIndexes[layer]);
		}
		let _g = layer;
		let _g1 = this.layerCount;
		while(_g < _g1) {
			let i = _g++;
			this.layersIndexes[i]++;
		}
	}
	addChildAt(s,index) {
		this.add(s,-1,index);
	}
	removeChild(s) {
		let _g = 0;
		let _g1 = this.children.length;
		while(_g < _g1) {
			let i = _g++;
			if(this.children[i] == s) {
				this.children.splice(i,1);
				if(s.allocated) {
					s.onRemove();
				}
				s.parent = null;
				s.posChanged = true;
				if(s.parentContainer != null) {
					s.setParentContainer(null);
				}
				let k = this.layerCount - 1;
				while(k >= 0 && this.layersIndexes[k] > i) {
					this.layersIndexes[k]--;
					--k;
				}
				if(this.parentContainer != null) {
					this.parentContainer.contentChanged(this);
				}
				break;
			}
		}
	}
}
$hxClasses["h2d.Layers"] = h2d_Layers;
h2d_Layers.__name__ = "h2d.Layers";
h2d_Layers.__super__ = h2d_Object;
Object.assign(h2d_Layers.prototype, {
	__class__: h2d_Layers
	,layersIndexes: null
	,layerCount: null
});
class h2d_Mask extends h2d_Object {
	constructor(width,height,parent) {
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor(width,height,parent);
	}
	_hx_constructor(width,height,parent) {
		this.scrollY = 0;
		this.scrollX = 0;
		super._hx_constructor(parent);
		this.width = width;
		this.height = height;
	}
	calcAbsPos() {
		super.calcAbsPos();
		this.absX -= this.scrollX;
		this.absY -= this.scrollY;
	}
	getBoundsRec(relativeTo,out,forSize) {
		let xMin = out.xMin;
		let yMin = out.yMin;
		let xMax = out.xMax;
		let yMax = out.yMax;
		out.xMin = 1e20;
		out.yMin = 1e20;
		out.xMax = -1e20;
		out.yMax = -1e20;
		if(this.posChanged) {
			this.calcAbsPos();
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				c.posChanged = true;
			}
			this.posChanged = false;
		}
		this.addBounds(relativeTo,out,this.scrollX,this.scrollY,this.width,this.height);
		let bxMin = out.xMin;
		let byMin = out.yMin;
		let bxMax = out.xMax;
		let byMax = out.yMax;
		out.xMin = xMin;
		out.xMax = xMax;
		out.yMin = yMin;
		out.yMax = yMax;
		super.getBoundsRec(relativeTo,out,forSize);
		if(out.xMin < bxMin) {
			out.xMin = xMin > bxMin ? bxMin : xMin;
		}
		if(out.yMin < byMin) {
			out.yMin = yMin > byMin ? byMin : yMin;
		}
		if(out.xMax > bxMax) {
			out.xMax = xMax < bxMax ? bxMax : xMax;
		}
		if(out.yMax > byMax) {
			out.yMax = yMax < byMax ? byMax : yMax;
		}
	}
	drawRec(ctx) {
		h2d_Mask.maskWith(ctx,this,this.width,this.height,this.scrollX,this.scrollY);
		super.drawRec(ctx);
		h2d_Mask.unmask(ctx);
	}
	static maskWith(ctx,object,width,height,scrollX,scrollY) {
		if(scrollY == null) {
			scrollY = 0;
		}
		if(scrollX == null) {
			scrollX = 0;
		}
		let x1 = object.absX + scrollX;
		let y1 = object.absY + scrollY;
		let x2 = width * object.matA + height * object.matC + x1;
		let y2 = width * object.matB + height * object.matD + y1;
		let tmp;
		if(x1 > x2) {
			tmp = x1;
			x1 = x2;
			x2 = tmp;
		}
		if(y1 > y2) {
			tmp = y1;
			y1 = y2;
			y2 = tmp;
		}
		ctx.clipRenderZone(x1,y1,x2 - x1,y2 - y1);
	}
	static unmask(ctx) {
		ctx.popRenderZone();
	}
}
$hxClasses["h2d.Mask"] = h2d_Mask;
h2d_Mask.__name__ = "h2d.Mask";
h2d_Mask.__super__ = h2d_Object;
Object.assign(h2d_Mask.prototype, {
	__class__: h2d_Mask
	,width: null
	,height: null
	,scrollX: null
	,scrollY: null
});
class h3d_impl_RenderContext {
	constructor() {
		if(h3d_impl_RenderContext._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
		this.engine = h3d_Engine.CURRENT;
		this.frame = 0;
		this.time = 0.;
		this.elapsedTime = 1. / hxd_System.getDefaultFrameRate();
		this.textures = new h3d_impl_TextureCache(this);
	}
}
$hxClasses["h3d.impl.RenderContext"] = h3d_impl_RenderContext;
h3d_impl_RenderContext.__name__ = "h3d.impl.RenderContext";
Object.assign(h3d_impl_RenderContext.prototype, {
	__class__: h3d_impl_RenderContext
	,engine: null
	,time: null
	,elapsedTime: null
	,frame: null
	,textures: null
});
class h2d_RenderContext extends h3d_impl_RenderContext {
	constructor(scene) {
		h3d_impl_RenderContext._hx_skip_constructor = true;
		super();
		h3d_impl_RenderContext._hx_skip_constructor = false;
		this._hx_constructor(scene);
	}
	_hx_constructor(scene) {
		this.renderZoneIndex = 0;
		this.renderZoneStack = [];
		this.tmpBounds = new h2d_col_Bounds();
		this.defaultSmooth = false;
		this.globalAlpha = 1.;
		super._hx_constructor();
		this.scene = scene;
		this.bufPos = 0;
		this.manager = new h3d_pass_ShaderManager();
		this.pass = new h3d_mat_Pass("",null);
		this.pass.depth(true,h3d_mat_Compare.Always);
		this.pass.set_culling(h3d_mat_Face.None);
		this.baseShader = new h3d_shader_Base2d();
		this.baseShader.setPriority(100);
		this.baseShader.zValue__ = 0.;
		this.baseShaderList = new hxsl_ShaderList(this.baseShader);
		this.targetsStack = [];
		this.targetsStackIndex = 0;
		this.cameraStack = [];
		this.cameraStackIndex = 0;
		this.filterStack = [];
		this.filterStackIndex = 0;
	}
	begin() {
		this.texture = null;
		this.currentObj = null;
		this.bufPos = 0;
		this.stride = 0;
		this.viewA = this.scene.viewportA;
		this.viewB = 0;
		this.viewC = 0;
		this.viewD = this.scene.viewportD;
		this.viewX = this.scene.viewportX;
		this.viewY = this.scene.viewportY;
		this.targetFlipY = this.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) ? -1 : 1;
		this.baseFlipY = this.engine.getCurrentTarget() != null ? this.targetFlipY : 1;
		this.inFilter = null;
		this.manager.globals.set("time",this.time);
		this.manager.globals.set("global.time",this.time);
		let _this = this.baseShader;
		_this.constModified = true;
		_this.pixelAlign__ = false;
		let _this1 = this.baseShader.halfPixelInverse__;
		let x = 0.5 / this.engine.width;
		let y = 0.5 / this.engine.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this1.x = x;
		_this1.y = y;
		_this1.z = 0.;
		_this1.w = 1.;
		let _this2 = this.baseShader.viewportA__;
		let x1 = this.scene.viewportA;
		let z = this.scene.viewportX;
		if(z == null) {
			z = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		_this2.x = x1;
		_this2.y = 0;
		_this2.z = z;
		_this2.w = 1.;
		let _this3 = this.baseShader.viewportB__;
		let y1 = this.scene.viewportD * -this.baseFlipY;
		let z1 = this.scene.viewportY * -this.baseFlipY;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		_this3.x = 0;
		_this3.y = y1;
		_this3.z = z1;
		_this3.w = 1.;
		let _this4 = this.baseShader.filterMatrixA__;
		_this4.x = 1;
		_this4.y = 0;
		_this4.z = 0;
		_this4.w = 1.;
		let _this5 = this.baseShader.filterMatrixB__;
		_this5.x = 0;
		_this5.y = 1;
		_this5.z = 0;
		_this5.w = 1.;
		this.baseShaderList.next = null;
		this.initShaders(this.baseShaderList);
		this.engine.selectMaterial(this.pass);
		this.textures.begin();
	}
	initShaders(shaders) {
		this.currentShaders = shaders;
		this.compiledShader = this.manager.compileShaders(shaders);
		if(this.buffers == null) {
			this.buffers = new h3d_shader_Buffers(this.compiledShader);
		} else {
			let _this = this.buffers;
			let s = this.compiledShader;
			_this.vertex.grow(s.vertex);
			_this.fragment.grow(s.fragment);
		}
		this.manager.fillGlobals(this.buffers,this.compiledShader);
		this.engine.selectShader(this.compiledShader);
		this.engine.uploadShaderBuffers(this.buffers,0);
	}
	end() {
		this.texture = null;
		this.currentObj = null;
		this.baseShaderList.next = null;
		if(this.targetsStackIndex != 0) {
			throw haxe_Exception.thrown("Missing popTarget()");
		}
		if(this.cameraStackIndex != 0) {
			throw haxe_Exception.thrown("Missing popCamera()");
		}
	}
	pushCamera(cam) {
		let entry = this.cameraStack[this.cameraStackIndex++];
		if(entry == null) {
			entry = { va : 0, vb : 0, vc : 0, vd : 0, vx : 0, vy : 0};
			this.cameraStack.push(entry);
		}
		let tmpA = this.viewA;
		let tmpB = this.viewB;
		let tmpC = this.viewC;
		let tmpD = this.viewD;
		entry.va = tmpA;
		entry.vb = tmpB;
		entry.vc = tmpC;
		entry.vd = tmpD;
		entry.vx = this.viewX;
		entry.vy = this.viewY;
		this.viewA = cam.matA * tmpA + cam.matB * tmpC;
		this.viewB = cam.matA * tmpB + cam.matB * tmpD;
		this.viewC = cam.matC * tmpA + cam.matD * tmpC;
		this.viewD = cam.matC * tmpB + cam.matD * tmpD;
		this.viewX = cam.absX * tmpA + cam.absY * tmpC + this.viewX;
		this.viewY = cam.absX * tmpB + cam.absY * tmpD + this.viewY;
		let flipY = this.curTarget != null ? -this.targetFlipY : -this.baseFlipY;
		let _this = this.baseShader.viewportA__;
		let x = this.viewA;
		let y = this.viewC;
		let z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		let _this1 = this.baseShader.viewportB__;
		let x1 = this.viewB * flipY;
		let y1 = this.viewD * flipY;
		let z1 = this.viewY * flipY;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		_this1.x = x1;
		_this1.y = y1;
		_this1.z = z1;
		_this1.w = 1.;
	}
	popCamera() {
		if(this.cameraStackIndex == 0) {
			throw haxe_Exception.thrown("Too many popCamera()");
		}
		let inf = this.cameraStack[--this.cameraStackIndex];
		this.viewA = inf.va;
		this.viewB = inf.vb;
		this.viewC = inf.vc;
		this.viewD = inf.vd;
		this.viewX = inf.vx;
		this.viewY = inf.vy;
		let flipY = this.curTarget != null ? -this.targetFlipY : -this.baseFlipY;
		let _this = this.baseShader.viewportA__;
		let x = this.viewA;
		let y = this.viewC;
		let z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		let _this1 = this.baseShader.viewportB__;
		let x1 = this.viewB * flipY;
		let y1 = this.viewD * flipY;
		let z1 = this.viewY * flipY;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		_this1.x = x1;
		_this1.y = y1;
		_this1.z = z1;
		_this1.w = 1.;
	}
	pushFilter(spr) {
		if(this.filterStack.length == 0 && this.onEnterFilter != null) {
			if(!this.onEnterFilter(spr)) {
				return false;
			}
		}
		this.inFilter = this.filterStack[this.filterStackIndex++];
		if(this.inFilter == null) {
			this.inFilter = { spr : null, scaleX : 1, scaleY : 1};
			this.filterStack.push(this.inFilter);
		}
		this.inFilter.spr = spr;
		this.inFilter.scaleX = 1;
		this.inFilter.scaleY = 1;
		return true;
	}
	setFilterScale(scaleX,scaleY) {
		if(this.inFilter != null) {
			this.inFilter.scaleX = scaleX;
			this.inFilter.scaleY = scaleY;
		}
	}
	popFilter() {
		this.inFilter.spr = null;
		this.filterStackIndex--;
		if(this.filterStackIndex > 0) {
			this.inFilter = this.filterStack[this.filterStackIndex - 1];
		} else {
			this.inFilter = null;
			if(this.onLeaveFilter != null) {
				this.onLeaveFilter(this.filterStack[this.filterStackIndex].spr);
			}
		}
	}
	pushTarget(t,startX,startY,width,height) {
		if(height == null) {
			height = -1;
		}
		if(width == null) {
			width = -1;
		}
		if(startY == null) {
			startY = 0;
		}
		if(startX == null) {
			startX = 0;
		}
		this.engine.pushTarget(t);
		this.initShaders(this.baseShaderList);
		let entry = this.targetsStack[this.targetsStackIndex++];
		if(entry == null) {
			entry = { t : null, va : 0, vb : 0, vc : 0, vd : 0, vx : 0, vy : 0, hasRZ : false, rzX : 0, rzY : 0, rzW : 0, rzH : 0};
			this.targetsStack.push(entry);
		}
		entry.t = this.curTarget;
		entry.va = this.viewA;
		entry.vb = this.viewB;
		entry.vc = this.viewC;
		entry.vd = this.viewD;
		entry.vx = this.viewX;
		entry.vy = this.viewY;
		entry.hasRZ = this.hasRenderZone;
		entry.rzX = this.renderX;
		entry.rzY = this.renderY;
		entry.rzW = this.renderW;
		entry.rzH = this.renderH;
		if(width < 0) {
			width = t == null ? this.scene.width : t.width;
		}
		if(height < 0) {
			height = t == null ? this.scene.height : t.height;
		}
		this.viewA = 2 / width;
		this.viewB = 0;
		this.viewC = 0;
		this.viewD = 2 / height;
		this.viewX = -1 - startX * this.viewA;
		this.viewY = -1 - startY * this.viewD;
		let _this = this.baseShader.halfPixelInverse__;
		let x = 0.5 / (t == null ? this.engine.width : t.width);
		let y = 0.5 / (t == null ? this.engine.height : t.height);
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
		let _this1 = this.baseShader.viewportA__;
		let x1 = this.viewA;
		let y1 = this.viewC;
		let z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		_this1.x = x1;
		_this1.y = y1;
		_this1.z = z;
		_this1.w = 1.;
		let _this2 = this.baseShader.viewportB__;
		let x2 = this.viewB * -this.targetFlipY;
		let y2 = this.viewD * -this.targetFlipY;
		let z1 = this.viewY * -this.targetFlipY;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		_this2.x = x2;
		_this2.y = y2;
		_this2.z = z1;
		_this2.w = 1.;
		this.curTarget = t;
		this.currentBlend = null;
		if(this.hasRenderZone) {
			this.hasRenderZone = false;
			this.engine.setRenderZone();
		}
	}
	popTarget() {
		if(this.targetsStackIndex <= 0) {
			throw haxe_Exception.thrown("Too many popTarget()");
		}
		this.engine.popTarget();
		let tinf = this.targetsStack[--this.targetsStackIndex];
		let t = this.curTarget = tinf.t;
		this.viewA = tinf.va;
		this.viewB = tinf.vb;
		this.viewC = tinf.vc;
		this.viewD = tinf.vd;
		this.viewX = tinf.vx;
		this.viewY = tinf.vy;
		let flipY = t == null ? -this.baseFlipY : -this.targetFlipY;
		this.initShaders(this.baseShaderList);
		let _this = this.baseShader.halfPixelInverse__;
		let x = 0.5 / (t == null ? this.engine.width : t.width);
		let y = 0.5 / (t == null ? this.engine.height : t.height);
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
		let _this1 = this.baseShader.viewportA__;
		let x1 = this.viewA;
		let y1 = this.viewC;
		let z = this.viewX;
		if(z == null) {
			z = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		_this1.x = x1;
		_this1.y = y1;
		_this1.z = z;
		_this1.w = 1.;
		let _this2 = this.baseShader.viewportB__;
		let x2 = this.viewB * flipY;
		let y2 = this.viewD * flipY;
		let z1 = this.viewY * flipY;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		_this2.x = x2;
		_this2.y = y2;
		_this2.z = z1;
		_this2.w = 1.;
		if(tinf.hasRZ) {
			this.setRZ(tinf.rzX,tinf.rzY,tinf.rzW,tinf.rzH);
		}
	}
	pushRenderZone(x,y,w,h) {
		let inf = this.renderZoneStack[this.renderZoneIndex++];
		if(inf == null) {
			inf = { hasRZ : this.hasRenderZone, x : this.renderX, y : this.renderY, w : this.renderW, h : this.renderH};
			this.renderZoneStack[this.renderZoneIndex - 1] = inf;
		} else if(this.hasRenderZone) {
			inf.hasRZ = true;
			inf.x = this.renderX;
			inf.y = this.renderY;
			inf.w = this.renderW;
			inf.h = this.renderH;
		} else {
			inf.hasRZ = false;
		}
		this.setRZ(x,y,w,h);
	}
	popRenderZone() {
		if(this.renderZoneIndex == 0) {
			throw haxe_Exception.thrown("Too many popRenderZone()");
		}
		let inf = this.renderZoneStack[--this.renderZoneIndex];
		if(inf.hasRZ) {
			this.setRZ(inf.x,inf.y,inf.w,inf.h);
		} else {
			this.hasRenderZone = false;
			this.engine.setRenderZone();
		}
	}
	getCurrentRenderZone(bounds) {
		if(!this.hasRenderZone) {
			return null;
		}
		if(bounds == null) {
			bounds = new h2d_col_Bounds();
		}
		let x = this.renderX;
		let y = this.renderY;
		bounds.xMin = x;
		bounds.yMin = y;
		bounds.xMax = x + this.renderW;
		bounds.yMax = y + this.renderH;
		return bounds;
	}
	clipRenderZone(x,y,w,h) {
		if(!this.hasRenderZone) {
			this.pushRenderZone(x,y,w,h);
			return;
		}
		x = Math.max(x,this.renderX);
		y = Math.max(y,this.renderY);
		let x2 = Math.min(x + w,this.renderX + this.renderW);
		let y2 = Math.min(y + h,this.renderY + this.renderH);
		if(x2 < x) {
			x2 = x;
		}
		if(y2 < y) {
			y2 = y;
		}
		this.pushRenderZone(x,y,x2 - x,y2 - y);
	}
	setRZ(x,y,w,h) {
		this.hasRenderZone = true;
		this.renderX = x;
		this.renderY = y;
		this.renderW = w;
		this.renderH = h;
		let scaleX = this.scene.viewportA * this.engine.width / 2 / hxd_Window.getInstance().get_windowToPixelRatio();
		let scaleY = this.scene.viewportD * this.engine.height / 2 / hxd_Window.getInstance().get_windowToPixelRatio();
		if(this.inFilter != null) {
			let fa = this.baseShader.filterMatrixA__;
			let fb = this.baseShader.filterMatrixB__;
			let x2 = x + w;
			let y2 = y + h;
			let rx1 = x * fa.x + y * fa.y + fa.z;
			let ry1 = x * fb.x + y * fb.y + fb.z;
			let rx2 = x2 * fa.x + y2 * fa.y + fa.z;
			let ry2 = x2 * fb.x + y2 * fb.y + fb.z;
			x = rx1;
			y = ry1;
			w = rx2 - rx1;
			h = ry2 - ry1;
		}
		this.engine.setRenderZone(x * scaleX + (this.scene.viewportX + 1) * (this.engine.width / 2) + 1e-10 | 0,y * scaleY + (this.scene.viewportY + 1) * (this.engine.height / 2) + 1e-10 | 0,w * scaleX + 1e-10 | 0,h * scaleY + 1e-10 | 0);
	}
	drawScene() {
		this.scene.drawRec(this);
	}
	beforeDraw() {
		if(this.texture == null) {
			this.texture = h3d_mat_Texture.fromColor(16711935);
		}
		this.baseShader.texture__ = this.texture;
		this.texture.set_filter((this.currentObj.smooth == null ? this.defaultSmooth : this.currentObj.smooth) ? h3d_mat_Filter.Linear : h3d_mat_Filter.Nearest);
		this.texture.set_wrap(this.currentObj.tileWrap && (this.currentObj.filter == null || this.inFilter != null) ? h3d_mat_Wrap.Repeat : h3d_mat_Wrap.Clamp);
		let blend = this.currentObj.blendMode;
		if(this.inFilter != null && this.inFilter.spr == this.currentObj && blend == h2d_BlendMode.Erase) {
			blend = h2d_BlendMode.Add;
		}
		if(this.inFilterBlend != null) {
			blend = this.inFilterBlend;
		}
		if(blend != this.currentBlend) {
			this.currentBlend = blend;
			this.pass.setBlendMode(blend);
			if(blend == h2d_BlendMode.Alpha || blend == h2d_BlendMode.Add) {
				this.pass.set_blendAlphaSrc(h3d_mat_Blend.One);
				if(this.inFilterBlend != null) {
					this.pass.set_blendSrc(h3d_mat_Blend.One);
				}
			}
		}
		this.manager.fillParams(this.buffers,this.compiledShader,this.currentShaders);
		this.engine.selectMaterial(this.pass);
		this.engine.uploadShaderBuffers(this.buffers,1);
		this.engine.uploadShaderBuffers(this.buffers,2);
		this.engine.uploadShaderBuffers(this.buffers,3);
	}
	beginDrawBatchState(obj) {
		if(!this.beginDraw(obj,null,true)) {
			return false;
		}
		if(this.inFilter != null && this.inFilter.spr == obj) {
			let _this = this.baseShader.color__;
			let x = obj.color.x;
			let y = obj.color.y;
			let z = obj.color.z;
			let w = obj.color.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else if(this.inFilterBlend != null) {
			let _this = this.baseShader.color__;
			let x = this.globalAlpha;
			let y = this.globalAlpha;
			let z = this.globalAlpha;
			let w = this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else {
			let _this = this.baseShader.color__;
			let x = obj.color.x;
			let y = obj.color.y;
			let z = obj.color.z;
			let w = obj.color.w * this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
		let _this = this.baseShader.absoluteMatrixA__;
		let x = obj.matA;
		let y = obj.matC;
		let z = obj.absX;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		let _this1 = this.baseShader.absoluteMatrixB__;
		let x1 = obj.matB;
		let y1 = obj.matD;
		let z1 = obj.absY;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		_this1.x = x1;
		_this1.y = y1;
		_this1.z = z1;
		_this1.w = 1.;
		return true;
	}
	drawTile(obj,tile) {
		let matA;
		let matB;
		let matC;
		let matD;
		let absX;
		let absY;
		if(this.inFilter != null) {
			let f1 = this.baseShader.filterMatrixA__;
			let f2 = this.baseShader.filterMatrixB__;
			let tmpA = obj.matA * f1.x + obj.matB * f1.y;
			let tmpB = obj.matA * f2.x + obj.matB * f2.y;
			let tmpC = obj.matC * f1.x + obj.matD * f1.y;
			let tmpD = obj.matC * f2.x + obj.matD * f2.y;
			let tmpX = obj.absX * f1.x + obj.absY * f1.y + f1.z;
			let tmpY = obj.absX * f2.x + obj.absY * f2.y + f2.z;
			matA = tmpA * this.viewA + tmpB * this.viewC;
			matB = tmpA * this.viewB + tmpB * this.viewD;
			matC = tmpC * this.viewA + tmpD * this.viewC;
			matD = tmpC * this.viewB + tmpD * this.viewD;
			absX = tmpX * this.viewA + tmpY * this.viewC + this.viewX;
			absY = tmpX * this.viewB + tmpY * this.viewD + this.viewY;
		} else {
			matA = obj.matA * this.viewA + obj.matB * this.viewC;
			matB = obj.matA * this.viewB + obj.matB * this.viewD;
			matC = obj.matC * this.viewA + obj.matD * this.viewC;
			matD = obj.matC * this.viewB + obj.matD * this.viewD;
			absX = obj.absX * this.viewA + obj.absY * this.viewC + this.viewX;
			absY = obj.absX * this.viewB + obj.absY * this.viewD + this.viewY;
		}
		if(matB == 0 && matC == 0) {
			let tx = tile.dx + tile.width * 0.5;
			let ty = tile.dy + tile.height * 0.5;
			let a = matA < 0 ? -matA : matA;
			let b = matD < 0 ? -matD : matD;
			let tr = (tile.width > tile.height ? tile.width : tile.height) * 1.5 * (a < b ? b : a);
			let cx = absX + tx * matA;
			let cy = absY + ty * matD;
			if(cx + tr < -1 || cx - tr > 1 || cy + tr < -1 || cy - tr > 1) {
				return false;
			}
		} else {
			let xMin = 1e20;
			let yMin = 1e20;
			let xMax = -1e20;
			let yMax = -1e20;
			let px = tile.dx * matA + tile.dy * matC;
			let py = tile.dx * matB + tile.dy * matD;
			if(px < 1e20) {
				xMin = px;
			}
			if(px > -1e20) {
				xMax = px;
			}
			if(py < 1e20) {
				yMin = py;
			}
			if(py > -1e20) {
				yMax = py;
			}
			let x = tile.width;
			let px1 = (x + tile.dx) * matA + tile.dy * matC;
			let py1 = (x + tile.dx) * matB + tile.dy * matD;
			if(px1 < xMin) {
				xMin = px1;
			}
			if(px1 > xMax) {
				xMax = px1;
			}
			if(py1 < yMin) {
				yMin = py1;
			}
			if(py1 > yMax) {
				yMax = py1;
			}
			let y = tile.height;
			let px2 = tile.dx * matA + (y + tile.dy) * matC;
			let py2 = tile.dx * matB + (y + tile.dy) * matD;
			if(px2 < xMin) {
				xMin = px2;
			}
			if(px2 > xMax) {
				xMax = px2;
			}
			if(py2 < yMin) {
				yMin = py2;
			}
			if(py2 > yMax) {
				yMax = py2;
			}
			let x1 = tile.width;
			let y1 = tile.height;
			let px3 = (x1 + tile.dx) * matA + (y1 + tile.dy) * matC;
			let py3 = (x1 + tile.dx) * matB + (y1 + tile.dy) * matD;
			if(px3 < xMin) {
				xMin = px3;
			}
			if(px3 > xMax) {
				xMax = px3;
			}
			if(py3 < yMin) {
				yMin = py3;
			}
			if(py3 > yMax) {
				yMax = py3;
			}
			if(absX + xMax < -1 || absY + yMax < -1 || absX + xMin > 1 || absY + yMin > 1) {
				return false;
			}
		}
		if(!this.beginDraw(obj,tile.innerTex,true,true)) {
			return false;
		}
		if(this.inFilter != null && this.inFilter.spr == obj) {
			let _this = this.baseShader.color__;
			let x = obj.color.x;
			let y = obj.color.y;
			let z = obj.color.z;
			let w = obj.color.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else if(this.inFilterBlend != null) {
			let _this = this.baseShader.color__;
			let x = this.globalAlpha;
			let y = this.globalAlpha;
			let z = this.globalAlpha;
			let w = this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		} else {
			let _this = this.baseShader.color__;
			let x = obj.color.x;
			let y = obj.color.y;
			let z = obj.color.z;
			let w = obj.color.w * this.globalAlpha;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = w;
		}
		let _this = this.baseShader.absoluteMatrixA__;
		let x = tile.width * obj.matA;
		let y = tile.height * obj.matC;
		let z = obj.absX + tile.dx * obj.matA + tile.dy * obj.matC;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = z;
		_this.w = 1.;
		let _this1 = this.baseShader.absoluteMatrixB__;
		let x1 = tile.width * obj.matB;
		let y1 = tile.height * obj.matD;
		let z1 = obj.absY + tile.dx * obj.matB + tile.dy * obj.matD;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		_this1.x = x1;
		_this1.y = y1;
		_this1.z = z1;
		_this1.w = 1.;
		let _this2 = this.baseShader.uvPos__;
		let x2 = tile.u;
		let y2 = tile.v;
		let z2 = tile.u2 - tile.u;
		let w = tile.v2 - tile.v;
		if(w == null) {
			w = 1.;
		}
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		_this2.x = x2;
		_this2.y = y2;
		_this2.z = z2;
		_this2.w = w;
		this.beforeDraw();
		let tmp;
		if(this.fixedBuffer != null) {
			let _this = this.fixedBuffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.fixedBuffer = new h3d_Buffer(4,8,[h3d_BufferFlag.Quads,h3d_BufferFlag.RawFormat]);
			let k = hxd__$FloatBuffer_Float32Expand._new(0);
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 0;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 0;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 0;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 0;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 0;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 0;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 0;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 0;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			if(k.pos == k.array.length) {
				let newSize = k.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(k.array);
				k.array = newArray;
			}
			k.array[k.pos++] = 1;
			this.fixedBuffer.uploadVector(k,0,4);
		}
		let _this3 = this.engine;
		_this3.renderBuffer(this.fixedBuffer,_this3.mem.quadIndexes,2,0,-1);
		return true;
	}
	beginDraw(obj,texture,isRelative,hasUVPos) {
		if(hasUVPos == null) {
			hasUVPos = false;
		}
		if(this.onBeginDraw != null && !this.onBeginDraw(obj)) {
			return false;
		}
		let shaderChanged = false;
		let paramsChanged = false;
		let objShaders = obj.shaders;
		let curShaders = this.currentShaders.next;
		while(objShaders != null && curShaders != null) {
			let s = objShaders.s;
			let t = curShaders.s;
			objShaders = objShaders.next;
			curShaders = curShaders.next;
			let prevInst = t.instance;
			if(s != t) {
				paramsChanged = true;
			}
			s.updateConstants(this.manager.globals);
			if(s.instance != prevInst) {
				shaderChanged = true;
			}
		}
		if(objShaders != null || curShaders != null || this.baseShader.isRelative__ != isRelative || this.baseShader.hasUVPos__ != hasUVPos || this.baseShader.killAlpha__ != this.killAlpha) {
			shaderChanged = true;
		}
		if(shaderChanged) {
			let _this = this.baseShader;
			_this.constModified = true;
			_this.hasUVPos__ = hasUVPos;
			let _this1 = this.baseShader;
			_this1.constModified = true;
			_this1.isRelative__ = isRelative;
			let _this2 = this.baseShader;
			_this2.constModified = true;
			_this2.killAlpha__ = this.killAlpha;
			this.baseShader.updateConstants(this.manager.globals);
			this.baseShaderList.next = obj.shaders;
			this.initShaders(this.baseShaderList);
		} else if(paramsChanged) {
			if(this.currentShaders != this.baseShaderList) {
				throw haxe_Exception.thrown("!");
			}
			this.currentShaders.next = obj.shaders;
		}
		this.texture = texture;
		this.stride = 8;
		this.currentObj = obj;
		return true;
	}
}
$hxClasses["h2d.RenderContext"] = h2d_RenderContext;
h2d_RenderContext.__name__ = "h2d.RenderContext";
h2d_RenderContext.__super__ = h3d_impl_RenderContext;
Object.assign(h2d_RenderContext.prototype, {
	__class__: h2d_RenderContext
	,globalAlpha: null
	,bufPos: null
	,scene: null
	,defaultSmooth: null
	,killAlpha: null
	,front2back: null
	,onBeginDraw: null
	,onEnterFilter: null
	,onLeaveFilter: null
	,tmpBounds: null
	,texture: null
	,baseShader: null
	,manager: null
	,compiledShader: null
	,buffers: null
	,fixedBuffer: null
	,pass: null
	,currentShaders: null
	,baseShaderList: null
	,currentObj: null
	,stride: null
	,targetsStack: null
	,targetsStackIndex: null
	,cameraStack: null
	,cameraStackIndex: null
	,curTarget: null
	,renderZoneStack: null
	,renderZoneIndex: null
	,filterStack: null
	,filterStackIndex: null
	,inFilter: null
	,inFilterBlend: null
	,viewA: null
	,viewB: null
	,viewC: null
	,viewD: null
	,viewX: null
	,viewY: null
	,hasRenderZone: null
	,renderX: null
	,renderY: null
	,renderW: null
	,renderH: null
	,currentBlend: null
	,baseFlipY: null
	,targetFlipY: null
});
class h2d_TileGroup extends h2d_Drawable {
	constructor(t,parent) {
		if(h2d_Object._hx_skip_constructor) {
			super();
			return;
		}
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor(t,parent);
	}
	_hx_constructor(t,parent) {
		super._hx_constructor(parent);
		this.tile = t;
		this.rangeMin = this.rangeMax = -1;
		this.curColor = new h3d_Vector(1,1,1,1);
		this.content = new h2d_TileLayerContent();
	}
	getBoundsRec(relativeTo,out,forSize) {
		super.getBoundsRec(relativeTo,out,forSize);
		this.addBounds(relativeTo,out,this.content.xMin,this.content.yMin,this.content.xMax - this.content.xMin,this.content.yMax - this.content.yMin);
	}
	clear() {
		this.content.clear();
	}
	onRemove() {
		this.content.dispose();
		super.onRemove();
	}
	setDefaultColor(rgb,alpha) {
		if(alpha == null) {
			alpha = 1.0;
		}
		this.curColor.x = (rgb >> 16 & 255) / 255;
		this.curColor.y = (rgb >> 8 & 255) / 255;
		this.curColor.z = (rgb & 255) / 255;
		this.curColor.w = alpha;
	}
	draw(ctx) {
		this.drawWith(ctx,this);
	}
	sync(ctx) {
		super.sync(ctx);
		if(this.visible) {
			let _this = this.content;
			let tmp;
			if(_this.buffer != null) {
				let _this1 = _this.buffer;
				tmp = _this1.buffer == null || _this1.buffer.vbuf == null;
			} else {
				tmp = true;
			}
			if(tmp) {
				_this.alloc(h3d_Engine.CURRENT);
			}
		}
	}
	drawWith(ctx,obj) {
		let max = this.content.triCount();
		if(max == 0) {
			return;
		}
		if(!ctx.beginDrawBatchState(obj)) {
			return;
		}
		let min = this.rangeMin < 0 ? 0 : this.rangeMin * 2;
		if(this.rangeMax > 0 && this.rangeMax < max * 2) {
			max = this.rangeMax * 2;
		}
		let _this = this.content;
		let tmp;
		if(_this.buffer != null) {
			let _this1 = _this.buffer;
			tmp = _this1.buffer == null || _this1.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			_this.alloc(h3d_Engine.CURRENT);
		}
		_this.state.drawQuads(ctx,_this.buffer,min,max - min);
	}
}
$hxClasses["h2d.TileGroup"] = h2d_TileGroup;
h2d_TileGroup.__name__ = "h2d.TileGroup";
h2d_TileGroup.__super__ = h2d_Drawable;
Object.assign(h2d_TileGroup.prototype, {
	__class__: h2d_TileGroup
	,content: null
	,curColor: null
	,tile: null
	,rangeMin: null
	,rangeMax: null
});
class h2d_ScaleGrid extends h2d_TileGroup {
	constructor(tile,borderL,borderT,borderR,borderB,parent) {
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor(tile,borderL,borderT,borderR,borderB,parent);
	}
	_hx_constructor(tile,borderL,borderT,borderR,borderB,parent) {
		this.currentScaleY = 1.;
		this.currentScaleX = 1.;
		this.borderScale = 1.0;
		super._hx_constructor(tile,parent);
		this.set_borderLeft(borderL);
		this.set_borderRight(borderR != null ? borderR : borderL);
		this.set_borderTop(borderT);
		this.set_borderBottom(borderB != null ? borderB : borderT);
		this.set_width(tile.width);
		this.set_height(tile.height);
	}
	set_width(w) {
		if(this.width == w) {
			return w;
		}
		this.width = w;
		this.clear();
		return w;
	}
	set_height(h) {
		if(this.height == h) {
			return h;
		}
		this.height = h;
		this.clear();
		return h;
	}
	set_borderTop(top) {
		if(this.borderTop == top) {
			return top;
		}
		this.borderTop = top;
		this.clear();
		return top;
	}
	set_borderBottom(bot) {
		if(this.borderBottom == bot) {
			return bot;
		}
		this.borderBottom = bot;
		this.clear();
		return bot;
	}
	set_borderLeft(left) {
		if(this.borderLeft == left) {
			return left;
		}
		this.borderLeft = left;
		this.clear();
		return left;
	}
	set_borderRight(right) {
		if(this.borderRight == right) {
			return right;
		}
		this.borderRight = right;
		this.clear();
		return right;
	}
	getBoundsRec(relativeTo,out,forSize) {
		this.checkUpdate();
		super.getBoundsRec(relativeTo,out,forSize);
	}
	checkUpdate() {
		let needUpdate = false;
		if(this.ignoreScale) {
			this.syncPos();
			let _this_a = 1;
			let _this_b = 0;
			let _this_c = 0;
			let _this_d = 1;
			_this_a = this.matA;
			_this_b = this.matB;
			_this_c = this.matC;
			_this_d = this.matD;
			let s_x = 0.;
			let s_y = 0.;
			s_x = Math.sqrt(_this_a * _this_a + _this_b * _this_b);
			s_y = Math.sqrt(_this_c * _this_c + _this_d * _this_d);
			if(_this_a * _this_d - _this_b * _this_c < 0) {
				s_x *= -1;
				s_y *= -1;
			}
			if(this.currentScaleX != s_x || this.currentScaleY != s_y) {
				needUpdate = true;
				this.currentScaleX = s_x;
				this.currentScaleY = s_y;
			}
		}
		if(this.content.isEmpty() || this.tile != this.contentTile) {
			this.contentTile = this.tile;
			needUpdate = true;
		}
		if(needUpdate) {
			this.clear();
			this.updateContent();
		}
	}
	updateContent() {
		let bt = this.borderTop;
		let bb = this.borderBottom;
		let bl = this.borderLeft;
		let br = this.borderRight;
		let unscaledBl = bl * this.borderScale;
		let unscaledBr = br * this.borderScale;
		let unscaledBt = bt * this.borderScale;
		let unscaledBb = bb * this.borderScale;
		let invScaleX = 1.;
		let invScaleY = 1.;
		if(this.ignoreScale) {
			this.syncPos();
			let _this_a = 1;
			let _this_b = 0;
			let _this_c = 0;
			let _this_d = 1;
			_this_a = this.matA;
			_this_b = this.matB;
			_this_c = this.matC;
			_this_d = this.matD;
			let s_x = 0.;
			let s_y = 0.;
			s_x = Math.sqrt(_this_a * _this_a + _this_b * _this_b);
			s_y = Math.sqrt(_this_c * _this_c + _this_d * _this_d);
			if(_this_a * _this_d - _this_b * _this_c < 0) {
				s_x *= -1;
				s_y *= -1;
			}
			if(s_x == 0. || s_y == 0.) {
				return;
			}
			invScaleX = 1. / s_x;
			invScaleY = 1. / s_y;
			unscaledBl *= invScaleX;
			unscaledBr *= invScaleX;
			unscaledBt *= invScaleY;
			unscaledBb *= invScaleY;
		}
		let t = this.tile.sub(0,0,bl,bt);
		t.scaleToSize(unscaledBl,unscaledBt);
		let color = this.curColor;
		this.content.add(0,0,color.x,color.y,color.z,color.w,t);
		t = this.tile.sub(this.tile.width - br,0,br,bt);
		t.scaleToSize(unscaledBr,unscaledBt);
		let color1 = this.curColor;
		this.content.add(this.width - unscaledBr,0,color1.x,color1.y,color1.z,color1.w,t);
		t = this.tile.sub(0,this.tile.height - bb,bl,bb);
		t.scaleToSize(unscaledBl,unscaledBb);
		let color2 = this.curColor;
		this.content.add(0,this.height - unscaledBb,color2.x,color2.y,color2.z,color2.w,t);
		t = this.tile.sub(this.tile.width - br,this.tile.height - bb,br,bb);
		t.scaleToSize(unscaledBr,unscaledBb);
		let color3 = this.curColor;
		this.content.add(this.width - unscaledBr,this.height - unscaledBb,color3.x,color3.y,color3.z,color3.w,t);
		let innerTileWidth = this.tile.width - (br + bl);
		let innerTileHeight = this.tile.height - (bb + bt);
		let innerWidth = this.width - (unscaledBl + unscaledBr);
		let innerHeight = this.height - (unscaledBt + unscaledBb);
		if(!this.tileBorders) {
			let t = this.tile.sub(bl,0,innerTileWidth,bt);
			t.scaleToSize(innerWidth,unscaledBt);
			let color = this.curColor;
			this.content.add(unscaledBl,0,color.x,color.y,color.z,color.w,t);
			let t1 = this.tile.sub(bl,this.tile.height - bb,innerTileWidth,bb);
			t1.scaleToSize(innerWidth,unscaledBb);
			let color1 = this.curColor;
			this.content.add(unscaledBl,innerHeight + unscaledBt,color1.x,color1.y,color1.z,color1.w,t1);
			let t2 = this.tile.sub(0,bt,bl,innerTileHeight);
			t2.scaleToSize(unscaledBl,innerHeight);
			let color2 = this.curColor;
			this.content.add(0,unscaledBt,color2.x,color2.y,color2.z,color2.w,t2);
			let t3 = this.tile.sub(this.tile.width - br,bt,br,innerTileHeight);
			t3.scaleToSize(unscaledBr,innerHeight);
			let color3 = this.curColor;
			this.content.add(innerWidth + unscaledBl,unscaledBt,color3.x,color3.y,color3.z,color3.w,t3);
		} else {
			let unscaledInnerTileWidth = innerTileWidth * invScaleX;
			let unscaledInnerTileHeight = innerTileHeight * invScaleY;
			let rw = innerWidth / unscaledInnerTileWidth | 0;
			let _g = 0;
			while(_g < rw) {
				let x = _g++;
				let t = this.tile.sub(bl,0,innerTileWidth,bt);
				t.scaleToSize(unscaledInnerTileWidth,unscaledBt);
				let color = this.curColor;
				this.content.add(unscaledBl + x * unscaledInnerTileWidth,0,color.x,color.y,color.z,color.w,t);
				t = this.tile.sub(bl,this.tile.height - bb,innerTileWidth,bb);
				t.scaleToSize(unscaledInnerTileWidth,unscaledBb);
				let color1 = this.curColor;
				this.content.add(unscaledBl + x * unscaledInnerTileWidth,this.height - unscaledBb,color1.x,color1.y,color1.z,color1.w,t);
			}
			let dx = innerWidth - rw * unscaledInnerTileWidth;
			if(dx > 0) {
				let t = this.tile.sub(bl,0,dx / invScaleX,bt);
				t.scaleToSize(dx,unscaledBt);
				let color = this.curColor;
				this.content.add(unscaledBl + rw * unscaledInnerTileWidth,0,color.x,color.y,color.z,color.w,t);
				t = this.tile.sub(bl,this.tile.height - bb,dx / invScaleX,bb);
				t.scaleToSize(dx,unscaledBb);
				let color1 = this.curColor;
				this.content.add(unscaledBl + rw * unscaledInnerTileWidth,this.height - unscaledBb,color1.x,color1.y,color1.z,color1.w,t);
			}
			let rh = innerHeight / unscaledInnerTileHeight | 0;
			let _g1 = 0;
			while(_g1 < rh) {
				let y = _g1++;
				let t = this.tile.sub(0,bt,bl,innerTileHeight);
				t.scaleToSize(unscaledBl,unscaledInnerTileHeight);
				let color = this.curColor;
				this.content.add(0,unscaledBt + y * unscaledInnerTileHeight,color.x,color.y,color.z,color.w,t);
				t = this.tile.sub(this.tile.width - br,bt,br,innerTileHeight);
				t.scaleToSize(unscaledBr,unscaledInnerTileHeight);
				let color1 = this.curColor;
				this.content.add(this.width - unscaledBr,unscaledBt + y * unscaledInnerTileHeight,color1.x,color1.y,color1.z,color1.w,t);
			}
			let dy = innerHeight - rh * unscaledInnerTileHeight;
			if(dy > 0) {
				let t = this.tile.sub(0,bt,bl,dy / invScaleY);
				t.scaleToSize(unscaledBl,dy);
				let color = this.curColor;
				this.content.add(0,bt + rh * unscaledInnerTileHeight,color.x,color.y,color.z,color.w,t);
				t = this.tile.sub(this.tile.width - br,bt,br,dy / invScaleY);
				t.scaleToSize(unscaledBr,dy);
				let color1 = this.curColor;
				this.content.add(this.width - unscaledBr,unscaledBt + rh * unscaledInnerTileHeight,color1.x,color1.y,color1.z,color1.w,t);
			}
		}
		if(!this.tileCenter) {
			let t = this.tile.sub(bl,bt,innerTileWidth,innerTileHeight);
			t.scaleToSize(this.width - (unscaledBr + unscaledBl),this.height - (unscaledBt + unscaledBb));
			let color = this.curColor;
			this.content.add(unscaledBl,unscaledBt,color.x,color.y,color.z,color.w,t);
		} else {
			let unscaledInnerTileWidth = innerTileWidth * invScaleX;
			let unscaledInnerTileHeight = innerTileHeight * invScaleY;
			let rw = (this.width - (unscaledBr + unscaledBl)) / unscaledInnerTileWidth | 0;
			let rh = innerHeight / unscaledInnerTileHeight | 0;
			let _g = 0;
			while(_g < rh) {
				let y = _g++;
				let _g1 = 0;
				while(_g1 < rw) {
					let x = _g1++;
					let t = this.tile.sub(bl,bt,unscaledInnerTileWidth,unscaledInnerTileHeight);
					let color = this.curColor;
					this.content.add(unscaledBl + x * unscaledInnerTileWidth,unscaledBt + y * unscaledInnerTileHeight,color.x,color.y,color.z,color.w,t);
				}
			}
			let dx = innerWidth - rw * unscaledInnerTileWidth;
			if(dx > 0) {
				let _g = 0;
				while(_g < rh) {
					let y = _g++;
					let t = this.tile.sub(bl,bt,dx,unscaledInnerTileHeight);
					let color = this.curColor;
					this.content.add(unscaledBl + rw * unscaledInnerTileWidth,unscaledBt + y * unscaledInnerTileHeight,color.x,color.y,color.z,color.w,t);
				}
			}
			let dy = innerHeight - rh * unscaledInnerTileHeight;
			if(dy > 0) {
				let _g = 0;
				while(_g < rw) {
					let x = _g++;
					let t = this.tile.sub(bl,bt,unscaledInnerTileWidth,dy);
					let color = this.curColor;
					this.content.add(unscaledBl + x * unscaledInnerTileWidth,unscaledBt + rh * unscaledInnerTileHeight,color.x,color.y,color.z,color.w,t);
				}
			}
			if(dx > 0 && dy > 0) {
				let t = this.tile.sub(bl,bt,dx,dy);
				let color = this.curColor;
				this.content.add(unscaledBl + rw * unscaledInnerTileWidth,unscaledBt + rh * unscaledInnerTileHeight,color.x,color.y,color.z,color.w,t);
			}
		}
	}
	sync(ctx) {
		this.checkUpdate();
		super.sync(ctx);
	}
}
$hxClasses["h2d.ScaleGrid"] = h2d_ScaleGrid;
h2d_ScaleGrid.__name__ = "h2d.ScaleGrid";
h2d_ScaleGrid.__super__ = h2d_TileGroup;
Object.assign(h2d_ScaleGrid.prototype, {
	__class__: h2d_ScaleGrid
	,borderLeft: null
	,borderRight: null
	,borderTop: null
	,borderBottom: null
	,width: null
	,height: null
	,tileBorders: null
	,tileCenter: null
	,ignoreScale: null
	,borderScale: null
	,contentTile: null
	,currentScaleX: null
	,currentScaleY: null
});
var h2d_ScaleModeAlign = $hxEnums["h2d.ScaleModeAlign"] = { __ename__:true,__constructs__:null
	,Left: {_hx_name:"Left",_hx_index:0,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:1,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Center: {_hx_name:"Center",_hx_index:2,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Top: {_hx_name:"Top",_hx_index:3,__enum__:"h2d.ScaleModeAlign",toString:$estr}
	,Bottom: {_hx_name:"Bottom",_hx_index:4,__enum__:"h2d.ScaleModeAlign",toString:$estr}
};
h2d_ScaleModeAlign.__constructs__ = [h2d_ScaleModeAlign.Left,h2d_ScaleModeAlign.Right,h2d_ScaleModeAlign.Center,h2d_ScaleModeAlign.Top,h2d_ScaleModeAlign.Bottom];
h2d_ScaleModeAlign.__empty_constructs__ = [h2d_ScaleModeAlign.Left,h2d_ScaleModeAlign.Right,h2d_ScaleModeAlign.Center,h2d_ScaleModeAlign.Top,h2d_ScaleModeAlign.Bottom];
var h2d_ScaleMode = $hxEnums["h2d.ScaleMode"] = { __ename__:true,__constructs__:null
	,Resize: {_hx_name:"Resize",_hx_index:0,__enum__:"h2d.ScaleMode",toString:$estr}
	,Stretch: ($_=function(width,height) { return {_hx_index:1,width:width,height:height,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="Stretch",$_.__params__ = ["width","height"],$_)
	,LetterBox: ($_=function(width,height,integerScale,horizontalAlign,verticalAlign) { return {_hx_index:2,width:width,height:height,integerScale:integerScale,horizontalAlign:horizontalAlign,verticalAlign:verticalAlign,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="LetterBox",$_.__params__ = ["width","height","integerScale","horizontalAlign","verticalAlign"],$_)
	,Fixed: ($_=function(width,height,zoom,horizontalAlign,verticalAlign) { return {_hx_index:3,width:width,height:height,zoom:zoom,horizontalAlign:horizontalAlign,verticalAlign:verticalAlign,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="Fixed",$_.__params__ = ["width","height","zoom","horizontalAlign","verticalAlign"],$_)
	,Zoom: ($_=function(level) { return {_hx_index:4,level:level,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="Zoom",$_.__params__ = ["level"],$_)
	,AutoZoom: ($_=function(minWidth,minHeight,integerScaling) { return {_hx_index:5,minWidth:minWidth,minHeight:minHeight,integerScaling:integerScaling,__enum__:"h2d.ScaleMode",toString:$estr}; },$_._hx_name="AutoZoom",$_.__params__ = ["minWidth","minHeight","integerScaling"],$_)
};
h2d_ScaleMode.__constructs__ = [h2d_ScaleMode.Resize,h2d_ScaleMode.Stretch,h2d_ScaleMode.LetterBox,h2d_ScaleMode.Fixed,h2d_ScaleMode.Zoom,h2d_ScaleMode.AutoZoom];
h2d_ScaleMode.__empty_constructs__ = [h2d_ScaleMode.Resize];
class hxd_InteractiveScene {
}
$hxClasses["hxd.InteractiveScene"] = hxd_InteractiveScene;
hxd_InteractiveScene.__name__ = "hxd.InteractiveScene";
hxd_InteractiveScene.__isInterface__ = true;
Object.assign(hxd_InteractiveScene.prototype, {
	__class__: hxd_InteractiveScene
	,setEvents: null
	,handleEvent: null
	,dispatchEvent: null
	,dispatchListeners: null
	,isInteractiveVisible: null
});
class h2d_Scene extends h2d_Layers {
	constructor() {
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.scaleMode = h2d_ScaleMode.Resize;
		super._hx_constructor(null);
		let e = h3d_Engine.CURRENT;
		this.ctx = new h2d_RenderContext(this);
		this._cameras = [];
		new h2d_Camera(this);
		this.set_interactiveCamera(this._cameras[0]);
		this.width = e.width;
		this.height = e.height;
		this.viewportA = 2 / e.width;
		this.viewportD = 2 / e.height;
		this.viewportX = -1;
		this.viewportY = -1;
		this.viewportScaleX = 1;
		this.viewportScaleY = 1;
		this.offsetX = 0;
		this.offsetY = 0;
		this.interactive = [];
		this.eventListeners = [];
		this.shapePoint = new h2d_col_Point();
		this.window = hxd_Window.getInstance();
		this.posChanged = true;
	}
	setEvents(events) {
		this.events = events;
	}
	set_scaleMode(v) {
		this.scaleMode = v;
		this.checkResize();
		return v;
	}
	set_interactiveCamera(cam) {
		if(cam == null) {
			throw haxe_Exception.thrown("Interactive cammera cannot be null!");
		}
		if(cam.scene != this) {
			this.addCamera(cam);
		}
		return this.interactiveCamera = cam;
	}
	addCamera(cam,pos) {
		if(cam.scene != null) {
			cam.scene.removeCamera(cam);
		}
		cam.scene = this;
		cam.posChanged = true;
		if(pos != null) {
			this._cameras.splice(pos,0,cam);
		} else {
			this._cameras.push(cam);
		}
	}
	removeCamera(cam) {
		if(cam == this.interactiveCamera) {
			throw haxe_Exception.thrown("Current interactive Camera cannot be removed from camera list!");
		}
		cam.scene = null;
		HxOverrides.remove(this._cameras,cam);
	}
	checkResize() {
		let engine = h3d_Engine.CURRENT;
		if(engine == null) {
			return;
		}
		let _g = this.scaleMode;
		switch(_g._hx_index) {
		case 0:
			let w = engine.width;
			let h = engine.height;
			if(w != this.width || h != this.height) {
				this.width = w;
				this.height = h;
				this.posChanged = true;
			}
			this.viewportScaleX = 1;
			this.viewportScaleY = 1;
			this.viewportA = 2 / this.width;
			this.viewportD = 2 / this.height;
			this.viewportX = -1;
			this.viewportY = -1;
			break;
		case 1:
			let _g1 = _g.width;
			let _g2 = _g.height;
			if(_g1 != this.width || _g2 != this.height) {
				this.width = _g1;
				this.height = _g2;
				this.posChanged = true;
			}
			this.viewportScaleX = engine.width / _g1;
			this.viewportScaleY = engine.height / _g2;
			this.viewportA = 2 / this.width;
			this.viewportD = 2 / this.height;
			this.viewportX = -1;
			this.viewportY = -1;
			break;
		case 2:
			let _g3 = _g.width;
			let _g4 = _g.height;
			let _g5 = _g.horizontalAlign;
			let _g6 = _g.verticalAlign;
			if(_g3 != this.width || _g4 != this.height) {
				this.width = _g3;
				this.height = _g4;
				this.posChanged = true;
			}
			let a = engine.width / _g3;
			let b = engine.height / _g4;
			let zoom = a > b ? b : a;
			if(_g.integerScale) {
				zoom = zoom | 0;
				if(zoom == 0) {
					zoom = 1;
				}
			}
			let horizontal = _g5;
			let vertical = _g6;
			this.viewportA = zoom * 2 / engine.width;
			this.viewportD = zoom * 2 / engine.height;
			this.viewportScaleX = zoom;
			this.viewportScaleY = zoom;
			if(_g5 == null) {
				horizontal = h2d_ScaleModeAlign.Center;
			}
			switch(horizontal._hx_index) {
			case 0:
				this.viewportX = -1;
				this.offsetX = 0;
				break;
			case 1:
				this.viewportX = 1 - this.width * this.viewportA;
				this.offsetX = engine.width - this.width * zoom;
				break;
			default:
				this.viewportX = Math.floor((engine.width - this.width * zoom) / (zoom * 2)) * this.viewportA - 1.;
				this.offsetX = Math.floor((engine.width - this.width * zoom) / 2);
			}
			if(_g6 == null) {
				vertical = h2d_ScaleModeAlign.Center;
			}
			switch(vertical._hx_index) {
			case 3:
				this.viewportY = -1;
				this.offsetY = 0;
				break;
			case 4:
				this.viewportY = 1 - this.height * this.viewportD;
				this.offsetY = engine.height - this.height * zoom;
				break;
			default:
				this.viewportY = Math.floor((engine.height - this.height * zoom) / (zoom * 2)) * this.viewportD - 1.;
				this.offsetY = Math.floor((engine.height - this.height * zoom) / 2);
			}
			break;
		case 3:
			let _g7 = _g.width;
			let _g8 = _g.height;
			let _g9 = _g.zoom;
			let _g10 = _g.horizontalAlign;
			let _g11 = _g.verticalAlign;
			if(_g7 != this.width || _g8 != this.height) {
				this.width = _g7;
				this.height = _g8;
				this.posChanged = true;
			}
			let horizontal1 = _g10;
			let vertical1 = _g11;
			this.viewportA = _g9 * 2 / engine.width;
			this.viewportD = _g9 * 2 / engine.height;
			this.viewportScaleX = _g9;
			this.viewportScaleY = _g9;
			if(_g10 == null) {
				horizontal1 = h2d_ScaleModeAlign.Center;
			}
			switch(horizontal1._hx_index) {
			case 0:
				this.viewportX = -1;
				this.offsetX = 0;
				break;
			case 1:
				this.viewportX = 1 - this.width * this.viewportA;
				this.offsetX = engine.width - this.width * _g9;
				break;
			default:
				this.viewportX = Math.floor((engine.width - this.width * _g9) / (_g9 * 2)) * this.viewportA - 1.;
				this.offsetX = Math.floor((engine.width - this.width * _g9) / 2);
			}
			if(_g11 == null) {
				vertical1 = h2d_ScaleModeAlign.Center;
			}
			switch(vertical1._hx_index) {
			case 3:
				this.viewportY = -1;
				this.offsetY = 0;
				break;
			case 4:
				this.viewportY = 1 - this.height * this.viewportD;
				this.offsetY = engine.height - this.height * _g9;
				break;
			default:
				this.viewportY = Math.floor((engine.height - this.height * _g9) / (_g9 * 2)) * this.viewportD - 1.;
				this.offsetY = Math.floor((engine.height - this.height * _g9) / 2);
			}
			break;
		case 4:
			let _g12 = _g.level;
			let w1 = Math.ceil(engine.width / _g12);
			let h1 = Math.ceil(engine.height / _g12);
			if(w1 != this.width || h1 != this.height) {
				this.width = w1;
				this.height = h1;
				this.posChanged = true;
			}
			this.viewportScaleX = _g12;
			this.viewportScaleY = _g12;
			this.viewportA = 2 / this.width;
			this.viewportD = 2 / this.height;
			this.viewportX = -1;
			this.viewportY = -1;
			break;
		case 5:
			let a1 = engine.width / _g.minWidth;
			let b1 = engine.height / _g.minHeight;
			let zoom1 = a1 > b1 ? b1 : a1;
			if(_g.integerScaling) {
				zoom1 = zoom1 | 0;
				if(zoom1 == 0) {
					zoom1 = 1;
				}
			}
			let w2 = Math.ceil(engine.width / zoom1);
			let h2 = Math.ceil(engine.height / zoom1);
			if(w2 != this.width || h2 != this.height) {
				this.width = w2;
				this.height = h2;
				this.posChanged = true;
			}
			this.viewportScaleX = zoom1;
			this.viewportScaleY = zoom1;
			this.viewportA = 2 / this.width;
			this.viewportD = 2 / this.height;
			this.viewportX = -1;
			this.viewportY = -1;
			break;
		}
	}
	get_mouseX() {
		this.syncPos();
		this.window.get_mouseX();
		let _this = this.interactiveCamera;
		let mx = this.window.get_mouseX();
		let my = this.window.get_mouseY();
		let dx = (((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matD - ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matC) * _this.invDet - this.absX;
		if(this.matC == 0) {
			return dx / this.matA;
		}
		this.window.get_mouseY();
		let _this1 = this.interactiveCamera;
		let mx1 = this.window.get_mouseX();
		let my1 = this.window.get_mouseY();
		let dy = (-((mx1 - _this1.scene.offsetX) / _this1.scene.viewportScaleX - _this1.absX) * _this1.matB + ((my1 - _this1.scene.offsetY) / _this1.scene.viewportScaleY - _this1.absY) * _this1.matA) * _this1.invDet - this.absY;
		return (dx * this.matD - dy * this.matC) / (this.matA * this.matD - this.matB * this.matC);
	}
	get_mouseY() {
		this.syncPos();
		this.window.get_mouseY();
		let _this = this.interactiveCamera;
		let mx = this.window.get_mouseX();
		let my = this.window.get_mouseY();
		let dy = (-((mx - _this.scene.offsetX) / _this.scene.viewportScaleX - _this.absX) * _this.matB + ((my - _this.scene.offsetY) / _this.scene.viewportScaleY - _this.absY) * _this.matA) * _this.invDet - this.absY;
		if(this.matB == 0) {
			return dy / this.matD;
		}
		this.window.get_mouseX();
		let _this1 = this.interactiveCamera;
		let mx1 = this.window.get_mouseX();
		let my1 = this.window.get_mouseY();
		let dx = (((mx1 - _this1.scene.offsetX) / _this1.scene.viewportScaleX - _this1.absX) * _this1.matD - ((my1 - _this1.scene.offsetY) / _this1.scene.viewportScaleY - _this1.absY) * _this1.matC) * _this1.invDet - this.absX;
		return (dy * this.matA - dx * this.matB) / (this.matA * this.matD - this.matB * this.matC);
	}
	dispatchListeners(event) {
		this.screenToViewport(event);
		let _g = 0;
		let _g1 = this.eventListeners;
		while(_g < _g1.length) {
			let l = _g1[_g];
			++_g;
			l(event);
			if(!event.propagate) {
				break;
			}
		}
	}
	isInteractiveVisible(i) {
		let s = i;
		while(s != this) {
			if(s == null || !s.visible) {
				return false;
			}
			s = s.parent;
		}
		return true;
	}
	screenToViewport(e) {
		this.interactiveCamera.eventToCamera(e);
	}
	dispatchEvent(event,to) {
		let i = to;
		this.screenToViewport(event);
		let dx = event.relX - i.absX;
		let dy = event.relY - i.absY;
		let rx = (dx * i.matD - dy * i.matC) * i.invDet;
		let ry = (dy * i.matA - dx * i.matB) * i.invDet;
		event.relX = rx;
		event.relY = ry;
		i.handleEvent(event);
	}
	handleEvent(event,last) {
		this.screenToViewport(event);
		let ex = event.relX;
		let ey = event.relY;
		let index = last == null ? 0 : this.interactive.indexOf(last) + 1;
		let pt = this.shapePoint;
		let _g = index;
		let _g1 = this.interactive.length;
		while(_g < _g1) {
			let idx = _g++;
			let i = this.interactive[idx];
			if(i == null) {
				break;
			}
			if(i.invDet == 0) {
				continue;
			}
			let dx = ex - i.absX;
			let dy = ey - i.absY;
			let rx = (dx * i.matD - dy * i.matC) * i.invDet;
			let ry = (dy * i.matA - dx * i.matB) * i.invDet;
			if(i.shape != null) {
				let x = rx + i.shapeX;
				let y = ry + i.shapeY;
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				pt.x = x;
				pt.y = y;
				if(!i.shape.contains(pt)) {
					continue;
				}
			} else if(ry < 0 || rx < 0 || rx >= i.width || ry >= i.height) {
				continue;
			}
			let visible = true;
			let p = i;
			while(p != null) {
				if(!p.visible) {
					visible = false;
					break;
				}
				p = p.parent;
			}
			if(!visible) {
				continue;
			}
			event.relX = rx;
			event.relY = ry;
			i.handleEvent(event);
			if(event.cancel) {
				event.cancel = false;
				event.propagate = false;
				continue;
			}
			return i;
		}
		return null;
	}
	addEventListener(f) {
		this.eventListeners.push(f);
	}
	startCapture(onEvent,onCancel,touchId) {
		let _gthis = this;
		this.events.startCapture(function(e) {
			_gthis.screenToViewport(e);
			onEvent(e);
		},onCancel,touchId);
	}
	stopCapture() {
		this.events.stopCapture();
	}
	addEventTarget(i) {
		let i1 = i;
		let lv = 0;
		while(i1 != null) {
			i1 = i1.parent;
			++lv;
		}
		let level = lv;
		let _g = 0;
		let _g1 = this.interactive.length;
		while(_g < _g1) {
			let index = _g++;
			let i1 = i;
			let i2 = this.interactive[index];
			let lv1 = level;
			let i3 = i2;
			let lv = 0;
			while(i3 != null) {
				i3 = i3.parent;
				++lv;
			}
			let lv2 = lv;
			let p1 = i1;
			let p2 = i2;
			while(lv1 > lv2) {
				i1 = p1;
				p1 = p1.parent;
				--lv1;
			}
			while(lv2 > lv1) {
				i2 = p2;
				p2 = p2.parent;
				--lv2;
			}
			while(p1 != p2) {
				i1 = p1;
				p1 = p1.parent;
				i2 = p2;
				p2 = p2.parent;
			}
			let id = -1;
			let _g1 = 0;
			let _g2 = p1.children.length;
			while(_g1 < _g2) {
				let k = _g1++;
				if(p1.children[k] == i1) {
					id = k;
					break;
				}
			}
			let tmp = id;
			let id1 = -1;
			let _g3 = 0;
			let _g4 = p2.children.length;
			while(_g3 < _g4) {
				let k = _g3++;
				if(p2.children[k] == i2) {
					id1 = k;
					break;
				}
			}
			if(tmp > id1) {
				this.interactive.splice(index,0,i);
				return;
			}
		}
		this.interactive.push(i);
	}
	removeEventTarget(i,notify) {
		if(notify == null) {
			notify = false;
		}
		HxOverrides.remove(this.interactive,i);
		if(notify && this.events != null) {
			this.events.onRemove(i);
		}
	}
	setElapsedTime(v) {
		this.ctx.elapsedTime = v;
	}
	render(engine) {
		this.ctx.engine = engine;
		this.ctx.frame++;
		this.ctx.time += this.ctx.elapsedTime;
		this.ctx.globalAlpha = this.alpha;
		this.sync(this.ctx);
		if(this.children.length == 0) {
			return;
		}
		this.ctx.begin();
		this.ctx.drawScene();
		this.ctx.end();
	}
	sync(ctx) {
		let forceCamSync = this.posChanged;
		if(!this.allocated) {
			this.onAdd();
		}
		super.sync(ctx);
		let _g = 0;
		let _g1 = this._cameras;
		while(_g < _g1.length) {
			let cam = _g1[_g];
			++_g;
			cam.sync(ctx,forceCamSync);
		}
	}
	clipBounds(ctx,bounds,scaleX,scaleY) {
		if(scaleY == null) {
			scaleY = 1.;
		}
		if(scaleX == null) {
			scaleX = 1.;
		}
		let matA;
		let matB;
		let matC;
		let matD;
		let absX;
		let absY;
		if(ctx.inFilter != null) {
			let f1 = ctx.baseShader.filterMatrixA__;
			let f2 = ctx.baseShader.filterMatrixB__;
			let tmpA = this.matA * f1.x + this.matB * f1.y;
			let tmpB = this.matA * f2.x + this.matB * f2.y;
			let tmpC = this.matC * f1.x + this.matD * f1.y;
			let tmpD = this.matC * f2.x + this.matD * f2.y;
			let tmpX = this.absX * f1.x + this.absY * f1.y + f1.z;
			let tmpY = this.absX * f2.x + this.absY * f2.y + f2.z;
			matA = (tmpA * ctx.viewA + tmpB * ctx.viewC) / scaleX;
			matB = (tmpA * ctx.viewB + tmpB * ctx.viewD) / scaleY;
			matC = (tmpC * ctx.viewA + tmpD * ctx.viewC) / scaleX;
			matD = (tmpC * ctx.viewB + tmpD * ctx.viewD) / scaleY;
			absX = tmpX * ctx.viewA + tmpY * ctx.viewC + ctx.viewX;
			absY = tmpX * ctx.viewB + tmpY * ctx.viewD + ctx.viewY;
		} else {
			matA = (this.matA * ctx.viewA + this.matB * ctx.viewC) / scaleX;
			matB = (this.matA * ctx.viewB + this.matB * ctx.viewD) / scaleY;
			matC = (this.matC * ctx.viewA + this.matD * ctx.viewC) / scaleX;
			matD = (this.matC * ctx.viewB + this.matD * ctx.viewD) / scaleY;
			absX = this.absX * ctx.viewA + this.absY * ctx.viewC + ctx.viewX;
			absY = this.absX * ctx.viewB + this.absY * ctx.viewD + ctx.viewY;
		}
		let invDet = 1 / (matA * matD - matB * matC);
		bounds.xMin = ((-1 - absX) * matD + (absY + 1) * matC) * invDet;
		bounds.yMin = ((absX + 1) * matB + (-1 - absY) * matA) * invDet;
		bounds.xMax = ((1 - absX) * matD + (absY - 1) * matC) * invDet;
		bounds.yMax = ((absX - 1) * matB + (1 - absY) * matA) * invDet;
	}
	drawContent(ctx) {
		if(ctx.front2back) {
			let _g = 0;
			let _g1 = this._cameras;
			while(_g < _g1.length) {
				let cam = _g1[_g];
				++_g;
				if(!cam.visible) {
					continue;
				}
				let i = this.children.length;
				let l = this.layerCount;
				cam.enter(ctx);
				while(l-- > 0) {
					let top = l == 0 ? 0 : this.layersIndexes[l - 1];
					if(cam.layerVisible(l)) {
						while(i >= top) this.children[i--].drawRec(ctx);
					} else {
						i = top - 1;
					}
				}
				cam.exit(ctx);
			}
			this.draw(ctx);
		} else {
			this.draw(ctx);
			let _g = 0;
			let _g1 = this._cameras;
			while(_g < _g1.length) {
				let cam = _g1[_g];
				++_g;
				if(!cam.visible) {
					continue;
				}
				let i = 0;
				let l = 0;
				cam.enter(ctx);
				while(l < this.layerCount) {
					let top = this.layersIndexes[l++];
					if(cam.layerVisible(l - 1)) {
						while(i < top) this.children[i++].drawRec(ctx);
					} else {
						i = top;
					}
				}
				cam.exit(ctx);
			}
		}
	}
	onAdd() {
		this.checkResize();
		super.onAdd();
		this.window.addResizeEvent($bind(this,this.checkResize));
	}
	onRemove() {
		super.onRemove();
		this.window.removeResizeEvent($bind(this,this.checkResize));
	}
}
$hxClasses["h2d.Scene"] = h2d_Scene;
h2d_Scene.__name__ = "h2d.Scene";
h2d_Scene.__interfaces__ = [hxd_InteractiveScene,h3d_IDrawable];
h2d_Scene.__super__ = h2d_Layers;
Object.assign(h2d_Scene.prototype, {
	__class__: h2d_Scene
	,width: null
	,height: null
	,viewportA: null
	,viewportD: null
	,viewportX: null
	,viewportY: null
	,offsetX: null
	,offsetY: null
	,viewportScaleX: null
	,viewportScaleY: null
	,mouseX: null
	,mouseY: null
	,scaleMode: null
	,_cameras: null
	,interactiveCamera: null
	,interactive: null
	,eventListeners: null
	,ctx: null
	,window: null
	,events: null
	,shapePoint: null
});
var h2d_Align = $hxEnums["h2d.Align"] = { __ename__:true,__constructs__:null
	,Left: {_hx_name:"Left",_hx_index:0,__enum__:"h2d.Align",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:1,__enum__:"h2d.Align",toString:$estr}
	,Center: {_hx_name:"Center",_hx_index:2,__enum__:"h2d.Align",toString:$estr}
	,MultilineRight: {_hx_name:"MultilineRight",_hx_index:3,__enum__:"h2d.Align",toString:$estr}
	,MultilineCenter: {_hx_name:"MultilineCenter",_hx_index:4,__enum__:"h2d.Align",toString:$estr}
};
h2d_Align.__constructs__ = [h2d_Align.Left,h2d_Align.Right,h2d_Align.Center,h2d_Align.MultilineRight,h2d_Align.MultilineCenter];
h2d_Align.__empty_constructs__ = [h2d_Align.Left,h2d_Align.Right,h2d_Align.Center,h2d_Align.MultilineRight,h2d_Align.MultilineCenter];
class h2d_TextInput extends h2d_Text {
	constructor(font,parent) {
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor(font,parent);
	}
	_hx_constructor(font,parent) {
		this.maxHistorySize = 100;
		this.lastClick = 0.;
		this.lastChange = 0.;
		this.redo = [];
		this.undo = [];
		this.scrollX = 0.;
		this.cursorBlink = 0.;
		this.canEdit = true;
		this.cursorBlinkTime = 0.5;
		this.cursorIndex = -1;
		super._hx_constructor(font,parent);
		this.interactive = new h2d_Interactive(0,0);
		this.interactive.set_cursor(hxd_Cursor.TextInput);
		let _gthis = this;
		this.interactive.onPush = function(e) {
			_gthis.onPush(e);
			if(!e.cancel && e.button == 0) {
				if(!_gthis.interactive.hasFocus()) {
					e.kind = hxd_EventKind.EFocus;
					_gthis.onFocus(e);
					e.kind = hxd_EventKind.EPush;
					if(e.cancel) {
						return;
					}
					_gthis.interactive.focus();
				}
				_gthis.cursorBlink = 0;
				let startIndex = _gthis.textPos(e.relX,e.relY);
				_gthis.cursorIndex = startIndex;
				_gthis.selectionRange = null;
				_gthis.needsRebuild = true;
				let pt = new h2d_col_Point();
				let scene = _gthis.getScene();
				if(scene == null) {
					return;
				}
				scene.startCapture(function(e) {
					pt.x = e.relX;
					pt.y = e.relY;
					_gthis.globalToLocal(pt);
					let index = _gthis.textPos(pt.x,pt.y);
					if(index == startIndex) {
						_gthis.selectionRange = null;
					} else if(index < startIndex) {
						_gthis.selectionRange = { start : index, length : startIndex - index};
					} else {
						_gthis.selectionRange = { start : startIndex, length : index - startIndex};
					}
					_gthis.needsRebuild = true;
					_gthis.selectionSize = 0;
					_gthis.cursorIndex = index;
					if(e.kind == hxd_EventKind.ERelease || _gthis.getScene() != scene) {
						scene.stopCapture();
					}
				});
			}
		};
		this.interactive.onKeyDown = function(e) {
			_gthis.onKeyDown(e);
			_gthis.handleKey(e);
		};
		this.interactive.onTextInput = function(e) {
			_gthis.onTextInput(e);
			_gthis.handleKey(e);
		};
		this.interactive.onFocusLost = function(e) {
			_gthis.cursorIndex = -1;
			_gthis.selectionRange = null;
			_gthis.needsRebuild = true;
			_gthis.onFocusLost(e);
		};
		this.interactive.onClick = function(e) {
			_gthis.onClick(e);
			if(e.cancel) {
				return;
			}
			let t = HxOverrides.now() / 1000;
			if(t - _gthis.lastClick < 0.3 && _gthis.text.length != 0) {
				_gthis.selectionRange = { start : 0, length : _gthis.text.length};
				_gthis.needsRebuild = true;
				_gthis.selectionSize = 0;
				_gthis.cursorIndex = _gthis.text.length;
			}
			_gthis.lastClick = t;
		};
		this.interactive.onKeyUp = function(e) {
			_gthis.onKeyUp(e);
		};
		this.interactive.onRelease = function(e) {
			_gthis.onRelease(e);
		};
		this.interactive.onFocus = function(e) {
			_gthis.onFocus(e);
		};
		this.interactive.onKeyUp = function(e) {
			_gthis.onKeyUp(e);
		};
		this.interactive.onMove = function(e) {
			_gthis.onMove(e);
		};
		this.interactive.onOver = function(e) {
			_gthis.onOver(e);
		};
		this.interactive.onOut = function(e) {
			_gthis.onOut(e);
		};
		this.interactive.set_cursor(hxd_Cursor.TextInput);
		this.addChildAt(this.interactive,0);
	}
	constraintSize(width,height) {
	}
	handleKey(e) {
		if(e.cancel || this.cursorIndex < 0) {
			return;
		}
		let oldIndex = this.cursorIndex;
		let oldText = this.text;
		switch(e.keyCode) {
		case 8:
			if(this.selectionRange != null) {
				if(!this.canEdit) {
					return;
				}
				this.beforeChange();
				this.cutSelection();
				this.onChange();
			} else if(this.cursorIndex > 0 && this.canEdit) {
				this.beforeChange();
				let end = this.cursorIndex;
				this.cursorIndex = hxd_Key.isDown(17) ? this.getWordStart() : this.cursorIndex - 1;
				this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + HxOverrides.substr(this.text,end,null));
				this.onChange();
			}
			break;
		case 35:
			this.cursorIndex = this.text.length;
			break;
		case 36:
			this.cursorIndex = 0;
			break;
		case 37:
			if(hxd_Key.isDown(h2d_TextInput.modifierKey)) {
				this.cursorIndex = this.getWordStart();
			} else if(this.cursorIndex > 0) {
				this.cursorIndex--;
			}
			break;
		case 39:
			if(hxd_Key.isDown(h2d_TextInput.modifierKey)) {
				this.cursorIndex = this.getWordEnd();
			} else if(this.cursorIndex < this.text.length) {
				this.cursorIndex++;
			}
			break;
		case 46:
			if(this.selectionRange != null) {
				if(!this.canEdit) {
					return;
				}
				this.beforeChange();
				this.cutSelection();
				this.onChange();
			} else if(this.cursorIndex < this.text.length && this.canEdit) {
				this.beforeChange();
				let end = hxd_Key.isDown(17) ? this.getWordEnd() : this.cursorIndex + 1;
				this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + HxOverrides.substr(this.text,end,null));
				this.onChange();
			}
			break;
		case 65:
			if(hxd_Key.isDown(h2d_TextInput.modifierKey)) {
				if(this.text != "") {
					this.cursorIndex = this.text.length;
					this.selectionRange = { start : 0, length : this.text.length};
					this.needsRebuild = true;
					this.selectionSize = 0;
				}
				return;
			} else {
				if(e.kind == hxd_EventKind.EKeyDown) {
					return;
				}
				if(e.charCode != 0 && this.canEdit) {
					if(!this.font.hasChar(e.charCode)) {
						return;
					}
					this.beforeChange();
					if(this.selectionRange != null) {
						this.cutSelection();
					}
					if(e.inputChar != "" && e.inputChar != null) {
						this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + e.inputChar + HxOverrides.substr(this.text,this.cursorIndex,null));
						this.cursorIndex += e.inputChar.length;
					} else {
						let code = e.charCode;
						this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + String.fromCodePoint(code) + HxOverrides.substr(this.text,this.cursorIndex,null));
						this.cursorIndex++;
					}
					this.onChange();
				}
			}
			break;
		case 67:
			if(!hxd_Key.isDown(h2d_TextInput.modifierKey)) {
				if(e.kind == hxd_EventKind.EKeyDown) {
					return;
				}
				if(e.charCode != 0 && this.canEdit) {
					if(!this.font.hasChar(e.charCode)) {
						return;
					}
					this.beforeChange();
					if(this.selectionRange != null) {
						this.cutSelection();
					}
					if(e.inputChar != "" && e.inputChar != null) {
						this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + e.inputChar + HxOverrides.substr(this.text,this.cursorIndex,null));
						this.cursorIndex += e.inputChar.length;
					} else {
						let code = e.charCode;
						this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + String.fromCodePoint(code) + HxOverrides.substr(this.text,this.cursorIndex,null));
						this.cursorIndex++;
					}
					this.onChange();
				}
			}
			break;
		case 86:
			if(hxd_Key.isDown(h2d_TextInput.modifierKey)) {
				if(!this.canEdit) {
					return;
				}
				let t = hxd_System.getClipboardText();
				if(t != null && t.length > 0) {
					this.beforeChange();
					if(this.selectionRange != null) {
						this.cutSelection();
					}
					this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + t + HxOverrides.substr(this.text,this.cursorIndex,null));
					this.cursorIndex += t.length;
					this.onChange();
				}
			} else {
				if(e.kind == hxd_EventKind.EKeyDown) {
					return;
				}
				if(e.charCode != 0 && this.canEdit) {
					if(!this.font.hasChar(e.charCode)) {
						return;
					}
					this.beforeChange();
					if(this.selectionRange != null) {
						this.cutSelection();
					}
					if(e.inputChar != "" && e.inputChar != null) {
						this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + e.inputChar + HxOverrides.substr(this.text,this.cursorIndex,null));
						this.cursorIndex += e.inputChar.length;
					} else {
						let code = e.charCode;
						this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + String.fromCodePoint(code) + HxOverrides.substr(this.text,this.cursorIndex,null));
						this.cursorIndex++;
					}
					this.onChange();
				}
			}
			break;
		case 88:
			if(hxd_Key.isDown(h2d_TextInput.modifierKey)) {
				if(this.text != "" && this.selectionRange != null) {
					if(hxd_System.setClipboardText(HxOverrides.substr(this.text,this.selectionRange.start,this.selectionRange.length))) {
						if(!this.canEdit) {
							return;
						}
						this.beforeChange();
						this.cutSelection();
						this.onChange();
					}
				}
			} else {
				if(e.kind == hxd_EventKind.EKeyDown) {
					return;
				}
				if(e.charCode != 0 && this.canEdit) {
					if(!this.font.hasChar(e.charCode)) {
						return;
					}
					this.beforeChange();
					if(this.selectionRange != null) {
						this.cutSelection();
					}
					if(e.inputChar != "" && e.inputChar != null) {
						this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + e.inputChar + HxOverrides.substr(this.text,this.cursorIndex,null));
						this.cursorIndex += e.inputChar.length;
					} else {
						let code = e.charCode;
						this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + String.fromCodePoint(code) + HxOverrides.substr(this.text,this.cursorIndex,null));
						this.cursorIndex++;
					}
					this.onChange();
				}
			}
			break;
		case 89:
			if(hxd_Key.isDown(h2d_TextInput.modifierKey)) {
				if(this.redo.length > 0 && this.canEdit) {
					this.undo.push(this.curHistoryState());
					this.setState(this.redo.pop());
					this.onChange();
				}
				return;
			} else {
				if(e.kind == hxd_EventKind.EKeyDown) {
					return;
				}
				if(e.charCode != 0 && this.canEdit) {
					if(!this.font.hasChar(e.charCode)) {
						return;
					}
					this.beforeChange();
					if(this.selectionRange != null) {
						this.cutSelection();
					}
					if(e.inputChar != "" && e.inputChar != null) {
						this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + e.inputChar + HxOverrides.substr(this.text,this.cursorIndex,null));
						this.cursorIndex += e.inputChar.length;
					} else {
						let code = e.charCode;
						this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + String.fromCodePoint(code) + HxOverrides.substr(this.text,this.cursorIndex,null));
						this.cursorIndex++;
					}
					this.onChange();
				}
			}
			break;
		case 90:
			if(hxd_Key.isDown(h2d_TextInput.modifierKey)) {
				if(this.undo.length > 0 && this.canEdit) {
					this.redo.push(this.curHistoryState());
					this.setState(this.undo.pop());
					this.onChange();
				}
				return;
			} else {
				if(e.kind == hxd_EventKind.EKeyDown) {
					return;
				}
				if(e.charCode != 0 && this.canEdit) {
					if(!this.font.hasChar(e.charCode)) {
						return;
					}
					this.beforeChange();
					if(this.selectionRange != null) {
						this.cutSelection();
					}
					if(e.inputChar != "" && e.inputChar != null) {
						this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + e.inputChar + HxOverrides.substr(this.text,this.cursorIndex,null));
						this.cursorIndex += e.inputChar.length;
					} else {
						let code = e.charCode;
						this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + String.fromCodePoint(code) + HxOverrides.substr(this.text,this.cursorIndex,null));
						this.cursorIndex++;
					}
					this.onChange();
				}
			}
			break;
		case 13:case 27:case 108:
			this.cursorIndex = -1;
			this.interactive.blur();
			return;
		default:
			if(e.kind == hxd_EventKind.EKeyDown) {
				return;
			}
			if(e.charCode != 0 && this.canEdit) {
				if(!this.font.hasChar(e.charCode)) {
					return;
				}
				this.beforeChange();
				if(this.selectionRange != null) {
					this.cutSelection();
				}
				if(e.inputChar != "" && e.inputChar != null) {
					this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + e.inputChar + HxOverrides.substr(this.text,this.cursorIndex,null));
					this.cursorIndex += e.inputChar.length;
				} else {
					let code = e.charCode;
					this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + String.fromCodePoint(code) + HxOverrides.substr(this.text,this.cursorIndex,null));
					this.cursorIndex++;
				}
				this.onChange();
			}
		}
		this.cursorBlink = 0.;
		if(hxd_Key.isDown(16) && this.text == oldText) {
			if(this.cursorIndex == oldIndex) {
				return;
			}
			if(this.selectionRange == null) {
				this.selectionRange = oldIndex < this.cursorIndex ? { start : oldIndex, length : this.cursorIndex - oldIndex} : { start : this.cursorIndex, length : oldIndex - this.cursorIndex};
			} else if(oldIndex == this.selectionRange.start) {
				this.selectionRange.length += oldIndex - this.cursorIndex;
				this.selectionRange.start = this.cursorIndex;
			} else {
				this.selectionRange.length += this.cursorIndex - oldIndex;
			}
			if(this.selectionRange.length == 0) {
				this.selectionRange = null;
				this.needsRebuild = true;
			} else if(this.selectionRange.length < 0) {
				this.selectionRange.start += this.selectionRange.length;
				this.selectionRange.length = -this.selectionRange.length;
			}
			this.selectionSize = 0;
		} else {
			this.selectionRange = null;
			this.needsRebuild = true;
		}
	}
	cutSelection() {
		if(this.selectionRange == null) {
			return false;
		}
		this.cursorIndex = this.selectionRange.start;
		let end = this.cursorIndex + this.selectionRange.length;
		this.set_text(HxOverrides.substr(this.text,0,this.cursorIndex) + HxOverrides.substr(this.text,end,null));
		this.selectionRange = null;
		this.needsRebuild = true;
		return true;
	}
	getWordEnd() {
		let len = this.text.length;
		if(this.cursorIndex >= len) {
			return this.cursorIndex;
		}
		let charset = hxd_Charset.getDefault();
		let ret = this.cursorIndex;
		while(ret < len && charset.isSpace(this.text.charCodeAt(ret))) ++ret;
		while(ret < len && !charset.isSpace(this.text.charCodeAt(ret))) ++ret;
		return ret;
	}
	getWordStart() {
		if(this.cursorIndex <= 0) {
			return this.cursorIndex;
		}
		let charset = hxd_Charset.getDefault();
		let ret = this.cursorIndex;
		while(ret > 0 && charset.isSpace(this.text.charCodeAt(ret - 1))) --ret;
		while(ret > 0 && !charset.isSpace(this.text.charCodeAt(ret - 1))) --ret;
		return ret;
	}
	setState(h) {
		this.set_text(h.t);
		this.cursorIndex = h.c;
		this.selectionRange = h.sel;
		this.needsRebuild = true;
		if(this.selectionRange != null) {
			this.cursorIndex = this.selectionRange.start + this.selectionRange.length;
		}
	}
	curHistoryState() {
		return { t : this.text, c : this.cursorIndex, sel : this.selectionRange == null ? null : { start : this.selectionRange.start, length : this.selectionRange.length}};
	}
	beforeChange() {
		let t = HxOverrides.now() / 1000;
		if(t - this.lastChange < 1) {
			this.lastChange = t;
			return;
		}
		this.lastChange = t;
		this.undo.push(this.curHistoryState());
		this.redo = [];
		while(this.undo.length > this.maxHistorySize) this.undo.shift();
	}
	set_text(t) {
		super.set_text(t);
		if(this.cursorIndex > t.length) {
			this.cursorIndex = t.length;
		}
		return t;
	}
	set_font(f) {
		super.set_font(f);
		this.cursorTile = h2d_Tile.fromColor(0,1 / hxd_Window.getInstance().get_windowToPixelRatio() | 0,this.font.size);
		let tmp = hxd_Window.getInstance().get_windowToPixelRatio();
		this.cursorTile.dy = 2 / tmp;
		this.selectionTile = h2d_Tile.fromColor(3381759,0,Math.ceil(this.font.lineHeight));
		return f;
	}
	initGlyphs(text,rebuild) {
		if(rebuild == null) {
			rebuild = true;
		}
		super.initGlyphs(text,rebuild);
		if(rebuild) {
			this.calcWidth += this.cursorTile.width;
			if(this.inputWidth != null && this.calcWidth > this.inputWidth) {
				this.calcWidth = this.inputWidth;
			}
		}
	}
	textPos(x,y) {
		x += this.scrollX;
		let pos = 0;
		while(pos < this.text.length) {
			if(this.calcTextWidth(HxOverrides.substr(this.text,0,pos + 1)) > x) {
				break;
			}
			++pos;
		}
		return pos;
	}
	sync(ctx) {
		let tmp = this.inputWidth != null ? this.inputWidth : this.maxWidth != null ? Math.ceil(this.maxWidth) : this.get_textWidth();
		this.interactive.width = tmp;
		this.interactive.height = this.font.lineHeight;
		super.sync(ctx);
	}
	draw(ctx) {
		if(this.inputWidth != null) {
			let h = this.localToGlobal(new h2d_col_Point(this.inputWidth,this.font.lineHeight));
			ctx.clipRenderZone(this.absX,this.absY,h.x - this.absX,h.y - this.absY);
		}
		if(this.cursorIndex >= 0 && (this.text != this.cursorText || this.cursorIndex != this.cursorXIndex)) {
			if(this.cursorIndex > this.text.length) {
				this.cursorIndex = this.text.length;
			}
			this.cursorText = this.text;
			this.cursorXIndex = this.cursorIndex;
			this.cursorX = this.calcTextWidth(HxOverrides.substr(this.text,0,this.cursorIndex));
			if(this.inputWidth != null && this.cursorX - this.scrollX >= this.inputWidth) {
				this.scrollX = this.cursorX - this.inputWidth + 1;
			} else if(this.cursorX < this.scrollX && this.cursorIndex > 0) {
				let a = this.inputWidth;
				let b = this.cursorX | 0;
				this.scrollX = this.cursorX - (a > b ? b : a);
			} else if(this.cursorX < this.scrollX) {
				this.scrollX = this.cursorX;
			}
		}
		this.absX -= this.scrollX * this.matA;
		this.absY -= this.scrollX * this.matC;
		if(this.selectionRange != null) {
			if(this.selectionSize == 0) {
				this.selectionPos = this.calcTextWidth(HxOverrides.substr(this.text,0,this.selectionRange.start));
				this.selectionSize = this.calcTextWidth(HxOverrides.substr(this.text,this.selectionRange.start,this.selectionRange.length));
				if(this.selectionRange.start + this.selectionRange.length == this.text.length) {
					this.selectionSize += this.cursorTile.width;
				}
			}
			this.selectionTile.dx += this.selectionPos;
			this.selectionTile.width += this.selectionSize;
			let hasSdf = this.removeShader(this.sdfShader);
			let _this = this.color;
			let x = _this.x;
			let y = _this.y;
			let z = _this.z;
			let w = _this.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let prevColor_x = x;
			let prevColor_y = y;
			let prevColor_z = z;
			let prevColor_w = w;
			let _this1 = this.color;
			_this1.x = 1;
			_this1.y = 1;
			_this1.z = 1;
			_this1.w = 1;
			this.emitTile(ctx,this.selectionTile);
			if(hasSdf) {
				this.addShader(this.sdfShader);
			}
			let _this2 = this.color;
			_this2.x = prevColor_x;
			_this2.y = prevColor_y;
			_this2.z = prevColor_z;
			_this2.w = prevColor_w;
			this.selectionTile.dx -= this.selectionPos;
			this.selectionTile.width -= this.selectionSize;
		}
		super.draw(ctx);
		this.absX += this.scrollX * this.matA;
		this.absY += this.scrollX * this.matC;
		if(this.cursorIndex >= 0) {
			if((this.cursorBlink += ctx.elapsedTime) % (this.cursorBlinkTime * 2) < this.cursorBlinkTime) {
				this.cursorTile.dx += this.cursorX - this.scrollX;
				let hasSdf = this.removeShader(this.sdfShader);
				let _this = this.color;
				let x = _this.x;
				let y = _this.y;
				let z = _this.z;
				let w = _this.w;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let prevColor_x = x;
				let prevColor_y = y;
				let prevColor_z = z;
				let prevColor_w = w;
				let _this1 = this.color;
				_this1.x = 1;
				_this1.y = 1;
				_this1.z = 1;
				_this1.w = 1;
				this.emitTile(ctx,this.cursorTile);
				if(hasSdf) {
					this.addShader(this.sdfShader);
				}
				let _this2 = this.color;
				_this2.x = prevColor_x;
				_this2.y = prevColor_y;
				_this2.z = prevColor_z;
				_this2.w = prevColor_w;
				this.cursorTile.dx -= this.cursorX - this.scrollX;
			}
		}
		if(this.inputWidth != null) {
			ctx.popRenderZone();
		}
	}
	focus() {
		this.interactive.getBounds();
		this.interactive.focus();
		if(this.cursorIndex < 0) {
			this.cursorIndex = 0;
			if(this.text != "") {
				this.selectionRange = { start : 0, length : this.text.length};
				this.needsRebuild = true;
			}
		}
	}
	onOut(e) {
	}
	onOver(e) {
	}
	onMove(e) {
	}
	onClick(e) {
	}
	onPush(e) {
	}
	onRelease(e) {
	}
	onKeyDown(e) {
	}
	onKeyUp(e) {
	}
	onTextInput(e) {
	}
	onFocus(e) {
	}
	onFocusLost(e) {
	}
	onChange() {
	}
	drawRec(ctx) {
		let old = this.interactive.visible;
		this.interactive.set_visible(false);
		this.interactive.draw(ctx);
		super.drawRec(ctx);
		this.interactive.set_visible(old);
	}
	set_backgroundColor(v) {
		return this.interactive.backgroundColor = v;
	}
}
$hxClasses["h2d.TextInput"] = h2d_TextInput;
h2d_TextInput.__name__ = "h2d.TextInput";
h2d_TextInput.__super__ = h2d_Text;
Object.assign(h2d_TextInput.prototype, {
	__class__: h2d_TextInput
	,cursorIndex: null
	,cursorTile: null
	,selectionTile: null
	,cursorBlinkTime: null
	,inputWidth: null
	,canEdit: null
	,interactive: null
	,cursorText: null
	,cursorX: null
	,cursorXIndex: null
	,cursorBlink: null
	,scrollX: null
	,selectionPos: null
	,selectionSize: null
	,undo: null
	,redo: null
	,lastChange: null
	,lastClick: null
	,maxHistorySize: null
});
class h2d_Tile {
	constructor(tex,x,y,w,h,dx,dy) {
		if(dy == null) {
			dy = 0;
		}
		if(dx == null) {
			dx = 0;
		}
		this.innerTex = tex;
		this.x = x;
		this.y = y;
		this.width = w;
		this.height = h;
		this.dx = dx;
		this.dy = dy;
		if(tex != null) {
			this.setTexture(tex);
		}
	}
	setTexture(tex) {
		this.innerTex = tex;
		if(tex != null) {
			this.u = this.x / tex.width;
			this.v = this.y / tex.height;
			this.u2 = (this.x + this.width) / tex.width;
			this.v2 = (this.y + this.height) / tex.height;
		}
	}
	sub(x,y,w,h,dx,dy) {
		if(dy == null) {
			dy = 0.;
		}
		if(dx == null) {
			dx = 0.;
		}
		return new h2d_Tile(this.innerTex,this.x + x,this.y + y,w,h,dx,dy);
	}
	setSize(w,h) {
		this.width = w;
		this.height = h;
		let tex = this.innerTex;
		if(tex != null) {
			this.u2 = (this.x + w) / tex.width;
			this.v2 = (this.y + h) / tex.height;
		}
	}
	scaleToSize(w,h) {
		this.width = w;
		this.height = h;
	}
	clone() {
		let t = new h2d_Tile(null,this.x,this.y,this.width,this.height,this.dx,this.dy);
		t.innerTex = this.innerTex;
		t.u = this.u;
		t.u2 = this.u2;
		t.v = this.v;
		t.v2 = this.v2;
		return t;
	}
	static fromColor(color,width,height,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		if(height == null) {
			height = 1;
		}
		if(width == null) {
			width = 1;
		}
		let t = new h2d_Tile(h3d_mat_Texture.fromColor(color,alpha),0,0,1,1);
		t.width = width;
		t.height = height;
		return t;
	}
	static fromTexture(t) {
		return new h2d_Tile(t,0,0,t.width,t.height);
	}
}
$hxClasses["h2d.Tile"] = h2d_Tile;
h2d_Tile.__name__ = "h2d.Tile";
Object.assign(h2d_Tile.prototype, {
	__class__: h2d_Tile
	,innerTex: null
	,u: null
	,v: null
	,u2: null
	,v2: null
	,dx: null
	,dy: null
	,x: null
	,y: null
	,width: null
	,height: null
});
class h2d_TileLayerContent extends h3d_prim_Primitive {
	constructor() {
		h3d_prim_Primitive._hx_skip_constructor = true;
		super();
		h3d_prim_Primitive._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.useAllocatorLimit = 1024;
		super._hx_constructor();
		this.state = new h2d_impl_BatchDrawState();
		this.clear();
	}
	clear() {
		this.tmp = hxd__$FloatBuffer_Float32Expand._new(0);
		if(this.buffer != null) {
			if(this.buffer.vertices * 8 < this.useAllocatorLimit) {
				hxd_impl_Allocator.get().disposeBuffer(this.buffer);
			} else {
				this.buffer.dispose();
			}
		}
		this.buffer = null;
		this.xMin = Infinity;
		this.yMin = Infinity;
		this.xMax = -Infinity;
		this.yMax = -Infinity;
		this.state.clear();
	}
	isEmpty() {
		return this.triCount() == 0;
	}
	triCount() {
		if(this.buffer == null) {
			return this.tmp.pos >> 4;
		} else {
			return this.buffer.totalVertices() >> 1;
		}
	}
	add(x,y,r,g,b,a,t) {
		let sx = x + t.dx;
		let sy = y + t.dy;
		let this1 = this.tmp;
		if(this1.pos == this1.array.length) {
			let newSize = this1.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this1.array);
			this1.array = newArray;
		}
		this1.array[this1.pos++] = sx;
		let this2 = this.tmp;
		if(this2.pos == this2.array.length) {
			let newSize = this2.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this2.array);
			this2.array = newArray;
		}
		this2.array[this2.pos++] = sy;
		let this3 = this.tmp;
		let v = t.u;
		if(this3.pos == this3.array.length) {
			let newSize = this3.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this3.array);
			this3.array = newArray;
		}
		this3.array[this3.pos++] = v;
		let this4 = this.tmp;
		let v1 = t.v;
		if(this4.pos == this4.array.length) {
			let newSize = this4.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this4.array);
			this4.array = newArray;
		}
		this4.array[this4.pos++] = v1;
		let this5 = this.tmp;
		if(this5.pos == this5.array.length) {
			let newSize = this5.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this5.array);
			this5.array = newArray;
		}
		this5.array[this5.pos++] = r;
		let this6 = this.tmp;
		if(this6.pos == this6.array.length) {
			let newSize = this6.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this6.array);
			this6.array = newArray;
		}
		this6.array[this6.pos++] = g;
		let this7 = this.tmp;
		if(this7.pos == this7.array.length) {
			let newSize = this7.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this7.array);
			this7.array = newArray;
		}
		this7.array[this7.pos++] = b;
		let this8 = this.tmp;
		if(this8.pos == this8.array.length) {
			let newSize = this8.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this8.array);
			this8.array = newArray;
		}
		this8.array[this8.pos++] = a;
		let this9 = this.tmp;
		let v2 = sx + t.width;
		if(this9.pos == this9.array.length) {
			let newSize = this9.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this9.array);
			this9.array = newArray;
		}
		this9.array[this9.pos++] = v2;
		let this10 = this.tmp;
		if(this10.pos == this10.array.length) {
			let newSize = this10.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this10.array);
			this10.array = newArray;
		}
		this10.array[this10.pos++] = sy;
		let this11 = this.tmp;
		let v3 = t.u2;
		if(this11.pos == this11.array.length) {
			let newSize = this11.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this11.array);
			this11.array = newArray;
		}
		this11.array[this11.pos++] = v3;
		let this12 = this.tmp;
		let v4 = t.v;
		if(this12.pos == this12.array.length) {
			let newSize = this12.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this12.array);
			this12.array = newArray;
		}
		this12.array[this12.pos++] = v4;
		let this13 = this.tmp;
		if(this13.pos == this13.array.length) {
			let newSize = this13.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this13.array);
			this13.array = newArray;
		}
		this13.array[this13.pos++] = r;
		let this14 = this.tmp;
		if(this14.pos == this14.array.length) {
			let newSize = this14.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this14.array);
			this14.array = newArray;
		}
		this14.array[this14.pos++] = g;
		let this15 = this.tmp;
		if(this15.pos == this15.array.length) {
			let newSize = this15.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this15.array);
			this15.array = newArray;
		}
		this15.array[this15.pos++] = b;
		let this16 = this.tmp;
		if(this16.pos == this16.array.length) {
			let newSize = this16.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this16.array);
			this16.array = newArray;
		}
		this16.array[this16.pos++] = a;
		let this17 = this.tmp;
		if(this17.pos == this17.array.length) {
			let newSize = this17.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this17.array);
			this17.array = newArray;
		}
		this17.array[this17.pos++] = sx;
		let this18 = this.tmp;
		let v5 = sy + t.height;
		if(this18.pos == this18.array.length) {
			let newSize = this18.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this18.array);
			this18.array = newArray;
		}
		this18.array[this18.pos++] = v5;
		let this19 = this.tmp;
		let v6 = t.u;
		if(this19.pos == this19.array.length) {
			let newSize = this19.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this19.array);
			this19.array = newArray;
		}
		this19.array[this19.pos++] = v6;
		let this20 = this.tmp;
		let v7 = t.v2;
		if(this20.pos == this20.array.length) {
			let newSize = this20.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this20.array);
			this20.array = newArray;
		}
		this20.array[this20.pos++] = v7;
		let this21 = this.tmp;
		if(this21.pos == this21.array.length) {
			let newSize = this21.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this21.array);
			this21.array = newArray;
		}
		this21.array[this21.pos++] = r;
		let this22 = this.tmp;
		if(this22.pos == this22.array.length) {
			let newSize = this22.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this22.array);
			this22.array = newArray;
		}
		this22.array[this22.pos++] = g;
		let this23 = this.tmp;
		if(this23.pos == this23.array.length) {
			let newSize = this23.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this23.array);
			this23.array = newArray;
		}
		this23.array[this23.pos++] = b;
		let this24 = this.tmp;
		if(this24.pos == this24.array.length) {
			let newSize = this24.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this24.array);
			this24.array = newArray;
		}
		this24.array[this24.pos++] = a;
		let this25 = this.tmp;
		let v8 = sx + t.width;
		if(this25.pos == this25.array.length) {
			let newSize = this25.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this25.array);
			this25.array = newArray;
		}
		this25.array[this25.pos++] = v8;
		let this26 = this.tmp;
		let v9 = sy + t.height;
		if(this26.pos == this26.array.length) {
			let newSize = this26.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this26.array);
			this26.array = newArray;
		}
		this26.array[this26.pos++] = v9;
		let this27 = this.tmp;
		let v10 = t.u2;
		if(this27.pos == this27.array.length) {
			let newSize = this27.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this27.array);
			this27.array = newArray;
		}
		this27.array[this27.pos++] = v10;
		let this28 = this.tmp;
		let v11 = t.v2;
		if(this28.pos == this28.array.length) {
			let newSize = this28.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this28.array);
			this28.array = newArray;
		}
		this28.array[this28.pos++] = v11;
		let this29 = this.tmp;
		if(this29.pos == this29.array.length) {
			let newSize = this29.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this29.array);
			this29.array = newArray;
		}
		this29.array[this29.pos++] = r;
		let this30 = this.tmp;
		if(this30.pos == this30.array.length) {
			let newSize = this30.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this30.array);
			this30.array = newArray;
		}
		this30.array[this30.pos++] = g;
		let this31 = this.tmp;
		if(this31.pos == this31.array.length) {
			let newSize = this31.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this31.array);
			this31.array = newArray;
		}
		this31.array[this31.pos++] = b;
		let this32 = this.tmp;
		if(this32.pos == this32.array.length) {
			let newSize = this32.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(this32.array);
			this32.array = newArray;
		}
		this32.array[this32.pos++] = a;
		let x1 = x + t.dx;
		let y1 = y + t.dy;
		if(x1 < this.xMin) {
			this.xMin = x1;
		}
		if(y1 < this.yMin) {
			this.yMin = y1;
		}
		x1 += t.width;
		y1 += t.height;
		if(x1 > this.xMax) {
			this.xMax = x1;
		}
		if(y1 > this.yMax) {
			this.yMax = y1;
		}
		if(t != null) {
			this.state.setTexture(t.innerTex);
		}
		let _this = this.state;
		_this.tail.count += 4;
		_this.totalCount += 4;
	}
	alloc(engine) {
		if(this.tmp == null) {
			this.clear();
		}
		if(this.tmp.pos > 0) {
			this.buffer = this.tmp.pos < this.useAllocatorLimit ? hxd_impl_Allocator.get().ofFloats(this.tmp,8,3) : h3d_Buffer.ofFloats(this.tmp,8,[h3d_BufferFlag.Quads,h3d_BufferFlag.RawFormat]);
		}
	}
	dispose() {
		if(this.buffer != null) {
			if(this.buffer.vertices * 8 < this.useAllocatorLimit) {
				hxd_impl_Allocator.get().disposeBuffer(this.buffer);
			} else {
				this.buffer.dispose();
			}
			this.buffer = null;
		}
		super.dispose();
	}
}
$hxClasses["h2d.TileLayerContent"] = h2d_TileLayerContent;
h2d_TileLayerContent.__name__ = "h2d.TileLayerContent";
h2d_TileLayerContent.__super__ = h3d_prim_Primitive;
Object.assign(h2d_TileLayerContent.prototype, {
	__class__: h2d_TileLayerContent
	,tmp: null
	,xMin: null
	,yMin: null
	,xMax: null
	,yMax: null
	,useAllocatorLimit: null
	,state: null
});
class h2d_col_Collider {
}
$hxClasses["h2d.col.Collider"] = h2d_col_Collider;
h2d_col_Collider.__name__ = "h2d.col.Collider";
Object.assign(h2d_col_Collider.prototype, {
	__class__: h2d_col_Collider
});
class h2d_col_Bounds extends h2d_col_Collider {
	constructor() {
		super();
		this.xMin = 1e20;
		this.yMin = 1e20;
		this.xMax = -1e20;
		this.yMax = -1e20;
	}
	contains(p) {
		if(p.x >= this.xMin && p.x < this.xMax && p.y >= this.yMin) {
			return p.y < this.yMax;
		} else {
			return false;
		}
	}
	intersection(b) {
		let i = new h2d_col_Bounds();
		let a = this.xMin;
		let b1 = b.xMin;
		i.xMin = a < b1 ? b1 : a;
		let a1 = this.yMin;
		let b2 = b.yMin;
		i.yMin = a1 < b2 ? b2 : a1;
		let a2 = this.xMax;
		let b3 = b.xMax;
		i.xMax = a2 > b3 ? b3 : a2;
		let a3 = this.yMax;
		let b4 = b.yMax;
		i.yMax = a3 > b4 ? b4 : a3;
		if(i.xMax < i.xMin) {
			i.xMax = i.xMin;
		}
		if(i.yMax < i.yMin) {
			i.yMax = i.yMin;
		}
		return i;
	}
}
$hxClasses["h2d.col.Bounds"] = h2d_col_Bounds;
h2d_col_Bounds.__name__ = "h2d.col.Bounds";
h2d_col_Bounds.__super__ = h2d_col_Collider;
Object.assign(h2d_col_Bounds.prototype, {
	__class__: h2d_col_Bounds
	,xMin: null
	,yMin: null
	,xMax: null
	,yMax: null
});
class h2d_col_Circle extends h2d_col_Collider {
	constructor(x,y,ray) {
		super();
		this.x = x;
		this.y = y;
		this.ray = ray;
	}
	contains(p) {
		let dx = p.x - this.x;
		let dy = p.y - this.y;
		let d = dx * dx + dy * dy - this.ray * this.ray;
		return (d < 0 ? 0 : d) == 0;
	}
}
$hxClasses["h2d.col.Circle"] = h2d_col_Circle;
h2d_col_Circle.__name__ = "h2d.col.Circle";
h2d_col_Circle.__super__ = h2d_col_Collider;
Object.assign(h2d_col_Circle.prototype, {
	__class__: h2d_col_Circle
	,x: null
	,y: null
	,ray: null
});
class h2d_col_IBounds {
	constructor() {
		this.xMin = 2147483647;
		this.yMin = 2147483647;
		this.xMax = -2147483648;
		this.yMax = -2147483648;
	}
}
$hxClasses["h2d.col.IBounds"] = h2d_col_IBounds;
h2d_col_IBounds.__name__ = "h2d.col.IBounds";
Object.assign(h2d_col_IBounds.prototype, {
	__class__: h2d_col_IBounds
	,xMin: null
	,yMin: null
	,xMax: null
	,yMax: null
});
class h2d_col_Matrix {
	constructor() {
		this.a = 1;
		this.b = 0;
		this.c = 0;
		this.d = 1;
		this.x = 0;
		this.y = 0;
	}
}
$hxClasses["h2d.col.Matrix"] = h2d_col_Matrix;
h2d_col_Matrix.__name__ = "h2d.col.Matrix";
Object.assign(h2d_col_Matrix.prototype, {
	__class__: h2d_col_Matrix
	,a: null
	,b: null
	,c: null
	,d: null
	,x: null
	,y: null
});
class h2d_filter_Filter {
	constructor() {
		if(h2d_filter_Filter._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
		this.useScreenResolution = h2d_filter_Filter.defaultUseScreenResolution;
		this.resolutionScale = 1;
		this.enable = true;
		this.smooth = false;
		this.boundsExtend = 0.;
		this.autoBounds = true;
	}
	get_enable() {
		return this.enable;
	}
	set_enable(v) {
		return this.enable = v;
	}
	sync(ctx,s) {
	}
	bind(s) {
	}
	unbind(s) {
	}
	getBounds(s,bounds,scale) {
		s.getBounds(s,bounds);
		bounds.xMin = bounds.xMin * scale.x - this.boundsExtend;
		bounds.xMax = bounds.xMax * scale.x + this.boundsExtend;
		bounds.yMin = bounds.yMin * scale.y - this.boundsExtend;
		bounds.yMax = bounds.yMax * scale.y + this.boundsExtend;
	}
	draw(ctx,input) {
		return input;
	}
}
$hxClasses["h2d.filter.Filter"] = h2d_filter_Filter;
h2d_filter_Filter.__name__ = "h2d.filter.Filter";
Object.assign(h2d_filter_Filter.prototype, {
	__class__: h2d_filter_Filter
	,autoBounds: null
	,boundsExtend: null
	,smooth: null
	,enable: null
	,resolutionScale: null
	,useScreenResolution: null
});
class h2d_filter_Blur extends h2d_filter_Filter {
	constructor(radius,gain,quality,linear) {
		if(h2d_filter_Filter._hx_skip_constructor) {
			super();
			return;
		}
		h2d_filter_Filter._hx_skip_constructor = true;
		super();
		h2d_filter_Filter._hx_skip_constructor = false;
		this._hx_constructor(radius,gain,quality,linear);
	}
	_hx_constructor(radius,gain,quality,linear) {
		if(linear == null) {
			linear = 0.;
		}
		if(quality == null) {
			quality = 1.;
		}
		if(gain == null) {
			gain = 1.;
		}
		if(radius == null) {
			radius = 1.;
		}
		super._hx_constructor();
		this.smooth = true;
		this.pass = new h3d_pass_Blur(radius,gain,linear,quality);
	}
	sync(ctx,s) {
		this.boundsExtend = this.pass.radius * 2;
	}
	draw(ctx,t) {
		let out = t.innerTex;
		let old = out.filter;
		out.set_filter(h3d_mat_Filter.Linear);
		this.pass.apply(ctx,out);
		out.set_filter(old);
		return t;
	}
}
$hxClasses["h2d.filter.Blur"] = h2d_filter_Blur;
h2d_filter_Blur.__name__ = "h2d.filter.Blur";
h2d_filter_Blur.__super__ = h2d_filter_Filter;
Object.assign(h2d_filter_Blur.prototype, {
	__class__: h2d_filter_Blur
	,pass: null
});
class h2d_filter_ColorMatrix extends h2d_filter_Filter {
	constructor(m) {
		super();
		this.pass = new h3d_pass_ColorMatrix(m);
		let _this = this.pass.shader;
		_this.constModified = true;
		_this.useAlpha__ = true;
	}
	draw(ctx,t) {
		let tout = ctx.textures.allocTileTarget("colorMatrixOut",t);
		this.pass.apply(t.innerTex,tout);
		return h2d_Tile.fromTexture(tout);
	}
}
$hxClasses["h2d.filter.ColorMatrix"] = h2d_filter_ColorMatrix;
h2d_filter_ColorMatrix.__name__ = "h2d.filter.ColorMatrix";
h2d_filter_ColorMatrix.__super__ = h2d_filter_Filter;
Object.assign(h2d_filter_ColorMatrix.prototype, {
	__class__: h2d_filter_ColorMatrix
	,pass: null
});
class h2d_filter_Glow extends h2d_filter_Blur {
	constructor(color,alpha,radius,gain,quality,smoothColor) {
		if(h2d_filter_Filter._hx_skip_constructor) {
			super();
			return;
		}
		h2d_filter_Filter._hx_skip_constructor = true;
		super();
		h2d_filter_Filter._hx_skip_constructor = false;
		this._hx_constructor(color,alpha,radius,gain,quality,smoothColor);
	}
	_hx_constructor(color,alpha,radius,gain,quality,smoothColor) {
		if(smoothColor == null) {
			smoothColor = false;
		}
		if(quality == null) {
			quality = 1.;
		}
		if(gain == null) {
			gain = 1.;
		}
		if(radius == null) {
			radius = 1.;
		}
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 16777215;
		}
		super._hx_constructor(radius,gain,quality);
		this.color = color;
		this.alpha = alpha;
		this.smoothColor = smoothColor;
		let _this = this.pass.shader;
		_this.constModified = true;
		_this.hasFixedColor__ = true;
	}
	setParams() {
		let _this = this.pass.shader.fixedColor__;
		let c = this.color;
		_this.x = (c >> 16 & 255) / 255;
		_this.y = (c >> 8 & 255) / 255;
		_this.z = (c & 255) / 255;
		_this.w = (c >>> 24) / 255;
		this.pass.shader.fixedColor__.w = this.smoothColor ? this.alpha * 1.5 : this.alpha;
		let _this1 = this.pass.shader;
		_this1.constModified = true;
		_this1.smoothFixedColor__ = this.smoothColor;
	}
	draw(ctx,t) {
		this.setParams();
		let tex = t.innerTex;
		let old = tex.filter;
		let save = ctx.textures.allocTileTarget("glowSave",t);
		h3d_pass_Copy.run(tex,save,h2d_BlendMode.None);
		tex.set_filter(h3d_mat_Filter.Linear);
		this.pass.apply(ctx,tex);
		tex.set_filter(old);
		if(this.knockout) {
			h3d_pass_Copy.run(save,tex,h2d_BlendMode.Erase);
		} else {
			h3d_pass_Copy.run(save,tex,h2d_BlendMode.Alpha);
		}
		return t;
	}
}
$hxClasses["h2d.filter.Glow"] = h2d_filter_Glow;
h2d_filter_Glow.__name__ = "h2d.filter.Glow";
h2d_filter_Glow.__super__ = h2d_filter_Blur;
Object.assign(h2d_filter_Glow.prototype, {
	__class__: h2d_filter_Glow
	,color: null
	,alpha: null
	,knockout: null
	,smoothColor: null
});
class h2d_filter_DropShadow extends h2d_filter_Glow {
	constructor(distance,angle,color,alpha,radius,gain,quality,smoothColor) {
		h2d_filter_Filter._hx_skip_constructor = true;
		super();
		h2d_filter_Filter._hx_skip_constructor = false;
		this._hx_constructor(distance,angle,color,alpha,radius,gain,quality,smoothColor);
	}
	_hx_constructor(distance,angle,color,alpha,radius,gain,quality,smoothColor) {
		if(smoothColor == null) {
			smoothColor = false;
		}
		if(quality == null) {
			quality = 1.;
		}
		if(gain == null) {
			gain = 1;
		}
		if(radius == null) {
			radius = 1.;
		}
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 0;
		}
		if(angle == null) {
			angle = 0.785;
		}
		if(distance == null) {
			distance = 4.;
		}
		this.alphaPass = new h3d_mat_Pass("");
		super._hx_constructor(color,alpha,radius,gain,quality,smoothColor);
		this.distance = distance;
		this.angle = angle;
		this.alphaPass.addShader(new h3d_shader_UVDelta());
	}
	sync(ctx,s) {
		super.sync(ctx,s);
		let f = Math.cos(this.angle) * this.distance;
		let a = f < 0 ? -f : f;
		let f1 = Math.sin(this.angle) * this.distance;
		let b = f1 < 0 ? -f1 : f1;
		this.boundsExtend += a < b ? b : a;
	}
	draw(ctx,t) {
		this.setParams();
		let save = ctx.textures.allocTileTarget("glowSave",t);
		h3d_pass_Copy.run(t.innerTex,save,h2d_BlendMode.None);
		this.pass.apply(ctx,save);
		let dx = Math.round(Math.cos(this.angle) * this.distance);
		let dy = Math.round(Math.sin(this.angle) * this.distance);
		let _this = this.alphaPass.getShader(h3d_shader_UVDelta).uvDelta__;
		let x = dx / t.width;
		let y = dy / t.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
		h3d_pass_Copy.run(t.innerTex,save,h2d_BlendMode.Alpha,this.alphaPass);
		let ret = h2d_Tile.fromTexture(save);
		ret.dx = dx;
		ret.dy = dy;
		return ret;
	}
}
$hxClasses["h2d.filter.DropShadow"] = h2d_filter_DropShadow;
h2d_filter_DropShadow.__name__ = "h2d.filter.DropShadow";
h2d_filter_DropShadow.__super__ = h2d_filter_Glow;
Object.assign(h2d_filter_DropShadow.prototype, {
	__class__: h2d_filter_DropShadow
	,distance: null
	,angle: null
	,alphaPass: null
});
class hxsl_Shader {
	constructor() {
		if(hxsl_Shader._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
		this.priority = 0;
		this.initialize();
	}
	initialize() {
		this.constModified = true;
		if(this.shader != null) {
			return;
		}
		let cl = js_Boot.getClass(this);
		this.shader = cl._SHADER;
		if(this.shader == null) {
			let curClass = cl;
			while(curClass != null && curClass.SRC == null) curClass = curClass.__super__;
			if(curClass == null) {
				throw haxe_Exception.thrown(cl.__name__ + " has no shader source");
			}
			this.shader = curClass._SHADER;
			if(this.shader == null) {
				this.shader = new hxsl_SharedShader(curClass.SRC);
				curClass._SHADER = this.shader;
			}
		}
	}
	setPriority(v) {
		this.priority = v;
	}
	getParamValue(index) {
		throw haxe_Exception.thrown("assert");
	}
	getParamFloatValue(index) {
		throw haxe_Exception.thrown("assert");
	}
	updateConstants(globals) {
		throw haxe_Exception.thrown("assert");
	}
	updateConstantsFinal(globals) {
		let c = this.shader.consts;
		while(c != null) {
			if(c.globalId == 0) {
				c = c.next;
				continue;
			}
			let v = globals.map.h[c.globalId];
			let _g = c.v.type;
			switch(_g._hx_index) {
			case 1:
				let v1 = v;
				if(v1 >>> c.bits != 0) {
					throw haxe_Exception.thrown("Constant " + c.v.name + " is outside range (" + v1 + " > " + ((1 << c.bits) - 1) + ")");
				}
				this.constBits |= v1 << c.pos;
				break;
			case 2:
				let v2 = v;
				if(v2) {
					this.constBits |= 1 << c.pos;
				}
				break;
			case 17:
				if(v == null) {
					c = c.next;
					continue;
				}
				let v3 = v;
				let sel = v3.channel;
				if(v3.texture == null) {
					sel = hxsl_Channel.Unknown;
				} else if(sel == null || sel == hxsl_Channel.Unknown) {
					switch(_g.size) {
					case 1:
						if(v3.texture.format == h3d_mat_Texture.nativeFormat) {
							sel = hxsl_Channel.PackedFloat;
						} else {
							throw haxe_Exception.thrown("Constant " + c.v.name + " does not define channel select value");
						}
						break;
					case 3:
						if(v3.texture.format == h3d_mat_Texture.nativeFormat) {
							sel = hxsl_Channel.PackedNormal;
						} else {
							throw haxe_Exception.thrown("Constant " + c.v.name + " does not define channel select value");
						}
						break;
					default:
						throw haxe_Exception.thrown("Constant " + c.v.name + " does not define channel select value");
					}
				}
				this.constBits |= (globals.allocChannelID(v3.texture) << 3 | sel._hx_index) << c.pos;
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			c = c.next;
		}
		let _this = this.shader;
		let constBits = this.constBits;
		let i = _this.instanceCache.h[constBits];
		this.instance = i == null ? _this.makeInstance(constBits) : i;
	}
	clone() {
		return this;
	}
	toString() {
		let c = js_Boot.getClass(this);
		return c.__name__;
	}
}
$hxClasses["hxsl.Shader"] = hxsl_Shader;
hxsl_Shader.__name__ = "hxsl.Shader";
Object.assign(hxsl_Shader.prototype, {
	__class__: hxsl_Shader
	,priority: null
	,shader: null
	,instance: null
	,constBits: null
	,constModified: null
});
class h3d_shader_ScreenShader extends hxsl_Shader {
	constructor() {
		if(hxsl_Shader._hx_skip_constructor) {
			super();
			return;
		}
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.flipY__ = 0;
		super._hx_constructor();
	}
	get_flipY() {
		return this.flipY__;
	}
	set_flipY(_v) {
		return this.flipY__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_ScreenShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		return s;
	}
}
$hxClasses["h3d.shader.ScreenShader"] = h3d_shader_ScreenShader;
h3d_shader_ScreenShader.__name__ = "h3d.shader.ScreenShader";
h3d_shader_ScreenShader.__super__ = hxsl_Shader;
Object.assign(h3d_shader_ScreenShader.prototype, {
	__class__: h3d_shader_ScreenShader
	,flipY__: null
});
class h2d_filter__$Mask_MaskShader extends h3d_shader_ScreenShader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.maskMatB__ = new h3d_Vector();
		this.maskMatA__ = new h3d_Vector();
		super._hx_constructor();
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	get_mask() {
		return this.mask__;
	}
	set_mask(_v) {
		return this.mask__ = _v;
	}
	get_maskMatA() {
		return this.maskMatA__;
	}
	set_maskMatA(_v) {
		return this.maskMatA__ = _v;
	}
	get_maskMatB() {
		return this.maskMatB__;
	}
	set_maskMatB(_v) {
		return this.maskMatB__ = _v;
	}
	get_smoothAlpha() {
		return this.smoothAlpha__;
	}
	set_smoothAlpha(_v) {
		this.constModified = true;
		return this.smoothAlpha__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.smoothAlpha__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.mask__;
		case 3:
			return this.maskMatA__;
		case 4:
			return this.maskMatB__;
		case 5:
			return this.smoothAlpha__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h2d_filter__$Mask_MaskShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		s.mask__ = this.mask__;
		s.maskMatA__ = this.maskMatA__;
		s.maskMatB__ = this.maskMatB__;
		s.smoothAlpha__ = this.smoothAlpha__;
		return s;
	}
}
$hxClasses["h2d.filter._Mask.MaskShader"] = h2d_filter__$Mask_MaskShader;
h2d_filter__$Mask_MaskShader.__name__ = "h2d.filter._Mask.MaskShader";
h2d_filter__$Mask_MaskShader.__super__ = h3d_shader_ScreenShader;
Object.assign(h2d_filter__$Mask_MaskShader.prototype, {
	__class__: h2d_filter__$Mask_MaskShader
	,texture__: null
	,mask__: null
	,maskMatA__: null
	,maskMatB__: null
	,smoothAlpha__: null
});
class h2d_impl_BatchDrawState {
	constructor() {
		this.head = this.tail = new h2d_impl__$BatchDrawState_StateEntry(null);
		this.totalCount = 0;
	}
	setTexture(texture) {
		if(texture != null) {
			if(this.tail.texture == null) {
				this.tail.texture = texture;
			} else if(this.tail.texture != texture) {
				let cur = this.tail;
				if(cur.count == 0) {
					cur.set(texture);
				} else if(cur.next == null) {
					cur.next = this.tail = new h2d_impl__$BatchDrawState_StateEntry(texture);
				} else {
					this.tail = cur.next.set(texture);
				}
			}
		}
	}
	clear() {
		let state = this.head;
		do {
			state.texture = null;
			state = state.next;
		} while(state != null);
		this.tail = this.head;
		this.tail.count = 0;
		this.totalCount = 0;
	}
	drawQuads(ctx,buffer,offset,length) {
		if(length == null) {
			length = -1;
		}
		if(offset == null) {
			offset = 0;
		}
		let state = this.head;
		let last = this.tail.next;
		let engine = ctx.engine;
		let stateLen;
		if(offset == 0 && length == -1) {
			do {
				ctx.texture = state.texture;
				ctx.beforeDraw();
				stateLen = state.count >> 1;
				let start = offset;
				let max = stateLen;
				if(max == null) {
					max = -1;
				}
				if(start == null) {
					start = 0;
				}
				engine.renderBuffer(buffer,engine.mem.quadIndexes,2,start,max);
				offset += stateLen;
				state = state.next;
			} while(state != last);
		} else {
			if(length == -1) {
				length = (this.totalCount >> 1) - offset;
			}
			let caret = 0;
			do {
				stateLen = state.count >> 1;
				if(caret + stateLen >= offset) {
					let stateMin = offset >= caret ? offset : caret;
					let stateLen1 = length > stateLen ? stateLen : length;
					ctx.texture = state.texture;
					ctx.beforeDraw();
					let start = stateMin;
					let max = stateLen1;
					if(max == null) {
						max = -1;
					}
					if(start == null) {
						start = 0;
					}
					engine.renderBuffer(buffer,engine.mem.quadIndexes,2,start,max);
					length -= stateLen1;
					if(length == 0) {
						break;
					}
				}
				caret += stateLen;
				state = state.next;
			} while(state != last);
		}
	}
	drawIndexed(ctx,buffer,indices,offset,length) {
		if(length == null) {
			length = -1;
		}
		if(offset == null) {
			offset = 0;
		}
		let state = this.head;
		let last = this.tail.next;
		let engine = ctx.engine;
		let stateLen;
		if(offset == 0 && length == -1) {
			do {
				ctx.texture = state.texture;
				ctx.beforeDraw();
				stateLen = state.count / 3 | 0;
				engine.renderIndexed(buffer,indices,offset,stateLen);
				offset += stateLen;
				state = state.next;
			} while(state != last);
		} else {
			if(length == -1) {
				length = this.totalCount / 3 | 0;
			}
			let caret = 0;
			do {
				stateLen = state.count / 3 | 0;
				if(caret + stateLen >= offset) {
					let stateMin = offset >= caret ? offset : caret;
					let stateLen1 = length > stateLen ? stateLen : length;
					ctx.texture = state.texture;
					ctx.beforeDraw();
					engine.renderIndexed(buffer,indices,stateMin,stateLen1);
					length -= stateLen1;
					if(length == 0) {
						break;
					}
				}
				caret += stateLen;
				state = state.next;
			} while(state != last);
		}
	}
}
$hxClasses["h2d.impl.BatchDrawState"] = h2d_impl_BatchDrawState;
h2d_impl_BatchDrawState.__name__ = "h2d.impl.BatchDrawState";
Object.assign(h2d_impl_BatchDrawState.prototype, {
	__class__: h2d_impl_BatchDrawState
	,totalCount: null
	,head: null
	,tail: null
});
class h2d_impl__$BatchDrawState_StateEntry {
	constructor(texture) {
		this.texture = texture;
		this.count = 0;
	}
	set(texture) {
		this.texture = texture;
		this.count = 0;
		return this;
	}
}
$hxClasses["h2d.impl._BatchDrawState.StateEntry"] = h2d_impl__$BatchDrawState_StateEntry;
h2d_impl__$BatchDrawState_StateEntry.__name__ = "h2d.impl._BatchDrawState.StateEntry";
Object.assign(h2d_impl__$BatchDrawState_StateEntry.prototype, {
	__class__: h2d_impl__$BatchDrawState_StateEntry
	,texture: null
	,count: null
	,next: null
});
var h3d_BufferFlag = $hxEnums["h3d.BufferFlag"] = { __ename__:true,__constructs__:null
	,Dynamic: {_hx_name:"Dynamic",_hx_index:0,__enum__:"h3d.BufferFlag",toString:$estr}
	,Triangles: {_hx_name:"Triangles",_hx_index:1,__enum__:"h3d.BufferFlag",toString:$estr}
	,Quads: {_hx_name:"Quads",_hx_index:2,__enum__:"h3d.BufferFlag",toString:$estr}
	,Managed: {_hx_name:"Managed",_hx_index:3,__enum__:"h3d.BufferFlag",toString:$estr}
	,RawFormat: {_hx_name:"RawFormat",_hx_index:4,__enum__:"h3d.BufferFlag",toString:$estr}
	,NoAlloc: {_hx_name:"NoAlloc",_hx_index:5,__enum__:"h3d.BufferFlag",toString:$estr}
	,UniformBuffer: {_hx_name:"UniformBuffer",_hx_index:6,__enum__:"h3d.BufferFlag",toString:$estr}
	,LargeBuffer: {_hx_name:"LargeBuffer",_hx_index:7,__enum__:"h3d.BufferFlag",toString:$estr}
};
h3d_BufferFlag.__constructs__ = [h3d_BufferFlag.Dynamic,h3d_BufferFlag.Triangles,h3d_BufferFlag.Quads,h3d_BufferFlag.Managed,h3d_BufferFlag.RawFormat,h3d_BufferFlag.NoAlloc,h3d_BufferFlag.UniformBuffer,h3d_BufferFlag.LargeBuffer];
h3d_BufferFlag.__empty_constructs__ = [h3d_BufferFlag.Dynamic,h3d_BufferFlag.Triangles,h3d_BufferFlag.Quads,h3d_BufferFlag.Managed,h3d_BufferFlag.RawFormat,h3d_BufferFlag.NoAlloc,h3d_BufferFlag.UniformBuffer,h3d_BufferFlag.LargeBuffer];
class h3d_Buffer {
	constructor(vertices,stride,flags) {
		this.id = h3d_Buffer.GUID++;
		this.vertices = vertices;
		this.flags = 0;
		if(flags != null) {
			let _g = 0;
			while(_g < flags.length) {
				let f = flags[_g];
				++_g;
				this.flags |= 1 << f._hx_index;
			}
		}
		if((this.flags & 32) == 0) {
			h3d_Engine.CURRENT.mem.allocBuffer(this,stride);
		}
	}
	dispose() {
		if(this.buffer != null) {
			this.buffer.freeBuffer(this);
			this.buffer = null;
			if(this.next != null) {
				this.next.dispose();
			}
		}
	}
	totalVertices() {
		let count = 0;
		let b = this;
		while(b != null) {
			count += b.vertices;
			b = b.next;
		}
		return count;
	}
	uploadVector(buf,bufPos,vertices,startVertice) {
		if(startVertice == null) {
			startVertice = 0;
		}
		let cur = this;
		while(cur != null && startVertice >= cur.vertices) {
			startVertice -= cur.vertices;
			cur = cur.next;
		}
		while(vertices > 0) {
			if(cur == null) {
				throw haxe_Exception.thrown("Too many vertices");
			}
			let count = vertices + startVertice > cur.vertices ? cur.vertices - startVertice : vertices;
			cur.buffer.uploadVertexBuffer(cur.position + startVertice,count,buf,bufPos);
			startVertice = 0;
			bufPos += count * this.buffer.stride;
			vertices -= count;
			cur = cur.next;
		}
	}
	uploadBytes(data,dataPos,vertices) {
		let cur = this;
		while(vertices > 0) {
			if(cur == null) {
				throw haxe_Exception.thrown("Too many vertices");
			}
			let count = vertices > cur.vertices ? cur.vertices : vertices;
			cur.buffer.uploadVertexBytes(cur.position,count,data,dataPos);
			dataPos += count * this.buffer.stride * 4;
			vertices -= count;
			cur = cur.next;
		}
	}
	static ofFloats(v,stride,flags) {
		let nvert = v.pos / stride | 0;
		let b = new h3d_Buffer(nvert,stride,flags);
		b.uploadVector(v,0,nvert);
		return b;
	}
	static ofSubFloats(v,stride,vertices,flags) {
		let b = new h3d_Buffer(vertices,stride,flags);
		b.uploadVector(v,0,vertices);
		return b;
	}
}
$hxClasses["h3d.Buffer"] = h3d_Buffer;
h3d_Buffer.__name__ = "h3d.Buffer";
Object.assign(h3d_Buffer.prototype, {
	__class__: h3d_Buffer
	,id: null
	,buffer: null
	,position: null
	,vertices: null
	,next: null
	,flags: null
});
class h3d_BufferOffset {
	constructor(buffer,offset) {
		this.buffer = buffer;
		this.offset = offset;
	}
	dispose() {
		if(this.buffer != null) {
			this.buffer.dispose();
			this.buffer = null;
		}
		this.next = null;
	}
}
$hxClasses["h3d.BufferOffset"] = h3d_BufferOffset;
h3d_BufferOffset.__name__ = "h3d.BufferOffset";
Object.assign(h3d_BufferOffset.prototype, {
	__class__: h3d_BufferOffset
	,buffer: null
	,offset: null
	,next: null
});
class h3d_Camera {
	constructor(fovY,zoom,screenRatio,zNear,zFar,rightHanded) {
		if(rightHanded == null) {
			rightHanded = false;
		}
		if(zFar == null) {
			zFar = 4000.;
		}
		if(zNear == null) {
			zNear = 0.02;
		}
		if(screenRatio == null) {
			screenRatio = 1.333333;
		}
		if(zoom == null) {
			zoom = 1.;
		}
		if(fovY == null) {
			fovY = 25.;
		}
		this.viewY = 0.;
		this.viewX = 0.;
		this.fovY = fovY;
		this.zoom = zoom;
		this.screenRatio = screenRatio;
		this.zNear = zNear;
		this.zFar = zFar;
		this.rightHanded = rightHanded;
		this.pos = new h3d_Vector(2,3,4);
		this.up = new h3d_Vector(0,0,1);
		this.target = new h3d_Vector(0,0,0);
		this.m = new h3d_Matrix();
		this.mcam = new h3d_Matrix();
		this.mproj = new h3d_Matrix();
		this.frustum = new h3d_col_Frustum();
		this.update();
	}
	setFovX(fovX,withRatio) {
		let degToRad = Math.PI / 180;
		this.fovY = 2 * Math.atan(Math.tan(fovX * 0.5 * degToRad) / withRatio) / degToRad;
	}
	getFovX() {
		let degToRad = Math.PI / 180;
		let halfFovX = Math.atan(Math.tan(this.fovY * 0.5 * degToRad) * this.screenRatio);
		let fovX = halfFovX * 2 / degToRad;
		return fovX;
	}
	getInverseViewProj() {
		if(this.minv == null) {
			this.minv = new h3d_Matrix();
		}
		if(this.needInv) {
			this.minv.initInverse(this.m);
			this.needInv = false;
		}
		return this.minv;
	}
	getInverseView() {
		if(this.mcamInv == null) {
			this.mcamInv = new h3d_Matrix();
			this.mcamInv._44 = 0;
		}
		if(this.mcamInv._44 == 0) {
			this.mcamInv.initInverse(this.mcam);
		}
		return this.mcamInv;
	}
	setCubeMap(face,position) {
		let dx = 0;
		let dy = 0;
		let dz = 0;
		switch(face) {
		case 0:
			dx = 1;
			let _this = this.up;
			_this.x = 0;
			_this.y = 1;
			_this.z = 0;
			_this.w = 1.;
			break;
		case 1:
			dx = -1;
			let _this1 = this.up;
			_this1.x = 0;
			_this1.y = 1;
			_this1.z = 0;
			_this1.w = 1.;
			break;
		case 2:
			dy = 1;
			let _this2 = this.up;
			_this2.x = 0;
			_this2.y = 0;
			_this2.z = -1;
			_this2.w = 1.;
			break;
		case 3:
			dy = -1;
			let _this3 = this.up;
			_this3.x = 0;
			_this3.y = 0;
			_this3.z = 1;
			_this3.w = 1.;
			break;
		case 4:
			dz = 1;
			let _this4 = this.up;
			_this4.x = 0;
			_this4.y = 1;
			_this4.z = 0;
			_this4.w = 1.;
			break;
		case 5:
			dz = -1;
			let _this5 = this.up;
			_this5.x = 0;
			_this5.y = 1;
			_this5.z = 0;
			_this5.w = 1.;
			break;
		}
		if(position != null) {
			let _this = this.pos;
			_this.x = position.x;
			_this.y = position.y;
			_this.z = position.z;
			_this.w = position.w;
		}
		let _this6 = this.target;
		let x = this.pos.x + dx;
		let y = this.pos.y + dy;
		let z = this.pos.z + dz;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this6.x = x;
		_this6.y = y;
		_this6.z = z;
		_this6.w = 1.;
	}
	unproject(screenX,screenY,camZ) {
		let p = new h3d_Vector(screenX,screenY,camZ);
		let m = this.getInverseViewProj();
		let px = p.x * m._11 + p.y * m._21 + p.z * m._31 + p.w * m._41;
		let py = p.x * m._12 + p.y * m._22 + p.z * m._32 + p.w * m._42;
		let pz = p.x * m._13 + p.y * m._23 + p.z * m._33 + p.w * m._43;
		let iw = 1 / (p.x * m._14 + p.y * m._24 + p.z * m._34 + p.w * m._44);
		p.x = px * iw;
		p.y = py * iw;
		p.z = pz * iw;
		p.w = 1;
		return p;
	}
	update() {
		if(this.follow != null) {
			let fpos = this.follow.pos.localToGlobal();
			let ftarget = this.follow.target.localToGlobal();
			let _this = this.pos;
			let x = fpos.x;
			let y = fpos.y;
			let z = fpos.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = 1.;
			let _this1 = this.target;
			let x1 = ftarget.x;
			let y1 = ftarget.y;
			let z1 = ftarget.z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			_this1.x = x1;
			_this1.y = y1;
			_this1.z = z1;
			_this1.w = 1.;
			if(this.follow.pos.name != null) {
				let p = this.follow.pos;
				while(p != null) {
					if(p.currentAnimation != null) {
						let v = p.currentAnimation.getPropValue(this.follow.pos.name,"FOVY");
						if(v != null) {
							this.fovY = v;
							break;
						}
					}
					p = p.parent;
				}
			}
		}
		this.makeCameraMatrix(this.mcam);
		this.makeFrustumMatrix(this.mproj);
		this.m.multiply(this.mcam,this.mproj);
		this.needInv = true;
		if(this.mcamInv != null) {
			this.mcamInv._44 = 0;
		}
		if(this.mprojInv != null) {
			this.mprojInv._44 = 0;
		}
		this.frustum.loadMatrix(this.m);
	}
	makeCameraMatrix(m) {
		let _this = this.target;
		let v = this.pos;
		let x = _this.x - v.x;
		let y = _this.y - v.y;
		let z = _this.z - v.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let az_x = x;
		let az_y = y;
		let az_z = z;
		if(this.rightHanded) {
			az_x *= -1;
			az_y *= -1;
			az_z *= -1;
		}
		let k = az_x * az_x + az_y * az_y + az_z * az_z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		az_x *= k;
		az_y *= k;
		az_z *= k;
		let _this1 = this.up;
		let x1 = _this1.y * az_z - _this1.z * az_y;
		let y1 = _this1.z * az_x - _this1.x * az_z;
		let z1 = _this1.x * az_y - _this1.y * az_x;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let ax_x = x1;
		let ax_y = y1;
		let ax_z = z1;
		let k1 = ax_x * ax_x + ax_y * ax_y + ax_z * ax_z;
		if(k1 < 1e-10) {
			k1 = 0;
		} else {
			k1 = 1. / Math.sqrt(k1);
		}
		ax_x *= k1;
		ax_y *= k1;
		ax_z *= k1;
		if(Math.sqrt(ax_x * ax_x + ax_y * ax_y + ax_z * ax_z) == 0) {
			ax_x = az_y;
			ax_y = az_z;
			ax_z = az_x;
		}
		let x2 = az_y * ax_z - az_z * ax_y;
		let y2 = az_z * ax_x - az_x * ax_z;
		let z2 = az_x * ax_y - az_y * ax_x;
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let ay_x = x2;
		let ay_y = y2;
		let ay_z = z2;
		m._11 = ax_x;
		m._12 = ay_x;
		m._13 = az_x;
		m._14 = 0;
		m._21 = ax_y;
		m._22 = ay_y;
		m._23 = az_y;
		m._24 = 0;
		m._31 = ax_z;
		m._32 = ay_z;
		m._33 = az_z;
		m._34 = 0;
		let v1 = this.pos;
		m._41 = -(ax_x * v1.x + ax_y * v1.y + ax_z * v1.z);
		let v2 = this.pos;
		m._42 = -(ay_x * v2.x + ay_y * v2.y + ay_z * v2.z);
		let v3 = this.pos;
		m._43 = -(az_x * v3.x + az_y * v3.y + az_z * v3.z);
		m._44 = 1;
	}
	makeFrustumMatrix(m) {
		m.zero();
		let bounds = this.orthoBounds;
		if(bounds != null) {
			let w = 1 / (bounds.xMax - bounds.xMin);
			let h = 1 / (bounds.yMax - bounds.yMin);
			let d = 1 / (bounds.zMax - bounds.zMin);
			m._11 = 2 * w;
			m._22 = 2 * h;
			m._33 = d;
			m._41 = -(bounds.xMin + bounds.xMax) * w;
			m._42 = -(bounds.yMin + bounds.yMax) * h;
			m._43 = -bounds.zMin * d;
			m._44 = 1;
		} else {
			let degToRad = Math.PI / 180;
			let halfFovX = Math.atan(Math.tan(this.fovY * 0.5 * degToRad) * this.screenRatio);
			let scale = this.zoom / Math.tan(halfFovX);
			m._11 = scale;
			m._22 = scale * this.screenRatio;
			m._33 = this.zFar / (this.zFar - this.zNear);
			m._34 = 1;
			m._43 = -(this.zNear * this.zFar) / (this.zFar - this.zNear);
		}
		m._11 += this.viewX * m._14;
		m._21 += this.viewX * m._24;
		m._31 += this.viewX * m._34;
		m._41 += this.viewX * m._44;
		m._12 += this.viewY * m._14;
		m._22 += this.viewY * m._24;
		m._32 += this.viewY * m._34;
		m._42 += this.viewY * m._44;
		if(this.rightHanded) {
			m._33 *= -1;
			m._34 *= -1;
		}
	}
	project(x,y,z,screenWidth,screenHeight,snapToPixel,p) {
		if(snapToPixel == null) {
			snapToPixel = true;
		}
		if(p == null) {
			p = new h3d_Vector();
		}
		let x1 = x;
		let y1 = y;
		let z1 = z;
		if(z == null) {
			z1 = 0.;
		}
		if(y == null) {
			y1 = 0.;
		}
		if(x == null) {
			x1 = 0.;
		}
		p.x = x1;
		p.y = y1;
		p.z = z1;
		p.w = 1.;
		let m = this.m;
		let px = p.x * m._11 + p.y * m._21 + p.z * m._31 + p.w * m._41;
		let py = p.x * m._12 + p.y * m._22 + p.z * m._32 + p.w * m._42;
		let pz = p.x * m._13 + p.y * m._23 + p.z * m._33 + p.w * m._43;
		let iw = 1 / (p.x * m._14 + p.y * m._24 + p.z * m._34 + p.w * m._44);
		p.x = px * iw;
		p.y = py * iw;
		p.z = pz * iw;
		p.w = 1;
		p.x = (p.x + 1) * 0.5 * screenWidth;
		p.y = (-p.y + 1) * 0.5 * screenHeight;
		if(snapToPixel) {
			p.x = Math.round(p.x);
			p.y = Math.round(p.y);
		}
		return p;
	}
	distanceToDepth(dist) {
		let min = this.zNear;
		let max = this.zFar;
		if(max == null) {
			max = 1.;
		}
		if(min == null) {
			min = 0.;
		}
		return ((this.zFar + this.zNear - 2.0 * this.zNear * this.zFar / (dist < min ? min : dist > max ? max : dist)) / (this.zFar - this.zNear) + 1.0) / 2.0;
	}
}
$hxClasses["h3d.Camera"] = h3d_Camera;
h3d_Camera.__name__ = "h3d.Camera";
Object.assign(h3d_Camera.prototype, {
	__class__: h3d_Camera
	,zoom: null
	,screenRatio: null
	,fovY: null
	,zNear: null
	,zFar: null
	,orthoBounds: null
	,rightHanded: null
	,mproj: null
	,mcam: null
	,m: null
	,pos: null
	,up: null
	,target: null
	,viewX: null
	,viewY: null
	,follow: null
	,frustum: null
	,minv: null
	,mcamInv: null
	,mprojInv: null
	,needInv: null
});
class h3d__$Engine_TargetTmp {
	constructor(t,n,l,m) {
		this.t = t;
		this.next = n;
		this.layer = l;
		this.mipLevel = m;
	}
}
$hxClasses["h3d._Engine.TargetTmp"] = h3d__$Engine_TargetTmp;
h3d__$Engine_TargetTmp.__name__ = "h3d._Engine.TargetTmp";
Object.assign(h3d__$Engine_TargetTmp.prototype, {
	__class__: h3d__$Engine_TargetTmp
	,t: null
	,textures: null
	,next: null
	,layer: null
	,mipLevel: null
});
class h3d_Engine {
	constructor() {
		this.resCache = new haxe_ds_ObjectMap();
		this.ready = false;
		this.inRender = false;
		this.textureColorCache = new haxe_ds_IntMap();
		this.tmpVector = new h3d_Vector();
		this.backgroundColor = -16777216;
		this.hardware = !h3d_Engine.SOFTWARE_DRIVER;
		this.antiAlias = h3d_Engine.ANTIALIASING;
		this.autoResize = true;
		this.set_fullScreen(!hxd_System.getValue(hxd_SystemValue.IsWindowed));
		this.window = hxd_Window.getInstance();
		this.realFps = hxd_System.getDefaultFrameRate();
		this.lastTime = HxOverrides.now() / 1000;
		this.window.addResizeEvent($bind(this,this.onWindowResize));
		this.driver = js_Browser.get_supported() ? new h3d_impl_GlDriver(this.antiAlias) : new h3d_impl_NullDriver();
		h3d_Engine.CURRENT = this;
	}
	init() {
		this.driver.init($bind(this,this.onCreate),!this.hardware);
	}
	selectShader(shader) {
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		if(this.driver.selectShader(shader)) {
			this.shaderSwitches++;
		}
	}
	selectMaterial(pass) {
		this.driver.selectMaterial(pass);
	}
	uploadShaderBuffers(buffers,which) {
		this.driver.uploadShaderBuffers(buffers,which);
	}
	selectBuffer(buf) {
		if(buf.buffer == null || buf.buffer.vbuf == null) {
			return false;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.selectBuffer(buf);
		return true;
	}
	renderBuffer(b,indexes,vertPerTri,startTri,drawTri) {
		if(drawTri == null) {
			drawTri = -1;
		}
		if(startTri == null) {
			startTri = 0;
		}
		if(indexes.isDisposed()) {
			return;
		}
		while(true) {
			let ntri = b.vertices / vertPerTri | 0;
			let pos = b.position / vertPerTri | 0;
			if(startTri > 0) {
				if(startTri >= ntri) {
					startTri -= ntri;
					b = b.next;
					if(!(b != null)) {
						break;
					} else {
						continue;
					}
				}
				pos += startTri;
				ntri -= startTri;
				startTri = 0;
			}
			if(drawTri >= 0) {
				if(drawTri == 0) {
					return;
				}
				drawTri -= ntri;
				if(drawTri < 0) {
					ntri += drawTri;
					drawTri = 0;
				}
			}
			if(ntri > 0 && this.selectBuffer(b)) {
				this.driver.draw(indexes.ibuf,pos * 3,ntri);
				this.drawTriangles += ntri;
				this.drawCalls++;
			}
			b = b.next;
			if(!(b != null)) {
				break;
			}
		}
	}
	renderIndexed(b,indexes,startTri,drawTri) {
		if(drawTri == null) {
			drawTri = -1;
		}
		if(startTri == null) {
			startTri = 0;
		}
		if(b.next != null) {
			throw haxe_Exception.thrown("Buffer is split");
		}
		if(indexes.isDisposed()) {
			return;
		}
		let maxTri = indexes.count / 3 | 0;
		if(drawTri < 0) {
			drawTri = maxTri - startTri;
		}
		if(drawTri > 0 && this.selectBuffer(b)) {
			this.driver.draw(indexes.ibuf,startTri * 3,drawTri);
			this.drawTriangles += drawTri;
			this.drawCalls++;
		}
	}
	renderMultiBuffers(buffers,indexes,startTri,drawTri) {
		if(drawTri == null) {
			drawTri = -1;
		}
		if(startTri == null) {
			startTri = 0;
		}
		let maxTri = indexes.count / 3 | 0;
		if(maxTri <= 0) {
			return;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.selectMultiBuffers(buffers);
		if(indexes.isDisposed()) {
			return;
		}
		if(drawTri < 0) {
			drawTri = maxTri - startTri;
		}
		if(drawTri > 0) {
			this.driver.draw(indexes.ibuf,startTri * 3,drawTri);
			this.drawTriangles += drawTri;
			this.drawCalls++;
		}
	}
	renderInstanced(buffers,indexes,commands) {
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.selectMultiBuffers(buffers);
		if(indexes.isDisposed()) {
			return;
		}
		if(commands.commandCount > 0) {
			this.driver.drawInstanced(indexes.ibuf,commands);
			this.drawTriangles += commands.triCount;
			this.drawCalls++;
		}
	}
	set_debug(d) {
		this.debug = d;
		this.driver.setDebug(this.debug);
		return d;
	}
	onCreate(disposed) {
		h3d_Engine.CURRENT = this;
		if(this.autoResize) {
			this.width = this.window.get_width();
			this.height = this.window.get_height();
		}
		if(disposed) {
			hxd_impl_Allocator.get().onContextLost();
			this.mem.onContextLost();
		} else {
			this.mem = new h3d_impl_MemoryManager(this.driver);
			this.mem.init();
			this.nullTexture = new h3d_mat_Texture(0,0,[h3d_mat_TextureFlags.NoAlloc]);
		}
		this.hardware = this.driver.hasFeature(h3d_impl_Feature.HardwareAccelerated);
		this.set_debug(this.debug);
		this.set_fullScreen(this.fullScreen);
		this.resize(this.width,this.height);
		if(disposed) {
			this.onContextLost();
		} else {
			this.onReady();
		}
		this.ready = true;
	}
	onContextLost() {
	}
	onReady() {
	}
	onWindowResize() {
		if(this.autoResize && !this.driver.isDisposed()) {
			let w = this.window.get_width();
			let h = this.window.get_height();
			if(w != this.width || h != this.height) {
				this.resize(w,h);
			}
			this.onResized();
		}
	}
	set_fullScreen(v) {
		this.fullScreen = v;
		if(this.mem != null && hxd_System.getValue(hxd_SystemValue.IsWindowed)) {
			this.window.set_displayMode(v ? hxd_DisplayMode.Borderless : hxd_DisplayMode.Windowed);
		}
		return v;
	}
	onResized() {
	}
	resize(width,height) {
		if(width < 32) {
			width = 32;
		}
		if(height < 32) {
			height = 32;
		}
		this.width = width;
		this.height = height;
		let r = this.window.get_windowToPixelRatio();
		let pw = width / r | 0;
		let ph = height / r | 0;
		if(!this.driver.isDisposed()) {
			this.driver.resize(pw,ph);
		}
	}
	begin() {
		if(this.driver.isDisposed()) {
			return false;
		}
		this.inRender = true;
		this.drawTriangles = 0;
		this.shaderSwitches = 0;
		this.drawCalls = 0;
		this.targetStack = null;
		this.needFlushTarget = this.currentTargetTex != null;
		this.driver.begin(hxd_Timer.frameCount);
		if(this.backgroundColor != null) {
			this.clear(this.backgroundColor,1,0);
		}
		return true;
	}
	end() {
		this.inRender = false;
		this.driver.end();
	}
	getCurrentTarget() {
		if(this.targetStack == null) {
			return null;
		} else if(this.targetStack.t == this.nullTexture) {
			return this.targetStack.textures[0];
		} else {
			return this.targetStack.t;
		}
	}
	pushTarget(tex,layer,mipLevel) {
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(layer == null) {
			layer = 0;
		}
		let c = this.targetTmp;
		if(c == null) {
			c = new h3d__$Engine_TargetTmp(tex,this.targetStack,layer,mipLevel);
		} else {
			this.targetTmp = c.next;
			c.t = tex;
			c.next = this.targetStack;
			c.mipLevel = mipLevel;
			c.layer = layer;
		}
		this.targetStack = c;
		this.updateNeedFlush();
	}
	updateNeedFlush() {
		let t = this.targetStack;
		if(t == null) {
			this.needFlushTarget = this.currentTargetTex != null;
		} else {
			this.needFlushTarget = this.currentTargetTex != t.t || this.currentTargetLayer != t.layer || this.currentTargetMip != t.mipLevel || t.textures != null;
		}
	}
	popTarget() {
		let c = this.targetStack;
		if(c == null) {
			throw haxe_Exception.thrown("popTarget() with no matching pushTarget()");
		}
		this.targetStack = c.next;
		this.updateNeedFlush();
		c.t = null;
		c.textures = null;
		c.next = this.targetTmp;
		this.targetTmp = c;
	}
	doFlushTarget() {
		let t = this.targetStack;
		if(t == null) {
			this.driver.setRenderTarget(null);
			this.currentTargetTex = null;
		} else {
			if(t.textures != null) {
				this.driver.setRenderTargets(t.textures);
			} else {
				this.driver.setRenderTarget(t.t,t.layer,t.mipLevel);
			}
			this.currentTargetTex = t.t;
			this.currentTargetLayer = t.layer;
			this.currentTargetMip = t.mipLevel;
		}
		this.needFlushTarget = false;
	}
	clear(color,depth,stencil) {
		if(color != null) {
			let _this = this.tmpVector;
			_this.x = (color >> 16 & 255) / 255;
			_this.y = (color >> 8 & 255) / 255;
			_this.z = (color & 255) / 255;
			_this.w = (color >>> 24) / 255;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.clear(color == null ? null : this.tmpVector,depth,stencil);
	}
	setRenderZone(x,y,width,height) {
		if(height == null) {
			height = -1;
		}
		if(width == null) {
			width = -1;
		}
		if(y == null) {
			y = 0;
		}
		if(x == null) {
			x = 0;
		}
		if(this.needFlushTarget) {
			this.doFlushTarget();
		}
		this.driver.setRenderZone(x,y,width,height);
	}
	render(obj) {
		if(!this.begin()) {
			return false;
		}
		obj.render(this);
		this.end();
		let delta = HxOverrides.now() / 1000 - this.lastTime;
		this.lastTime += delta;
		if(delta > 0) {
			let curFps = 1. / delta;
			if(curFps > this.realFps * 2) {
				curFps = this.realFps * 2;
			} else if(curFps < this.realFps * 0.5) {
				curFps = this.realFps * 0.5;
			}
			let f = delta / .5;
			if(f > 0.3) {
				f = 0.3;
			}
			this.realFps = this.realFps * (1 - f) + curFps * f;
		}
		return true;
	}
	get_fps() {
		return Math.ceil(this.realFps * 100) / 100;
	}
}
$hxClasses["h3d.Engine"] = h3d_Engine;
h3d_Engine.__name__ = "h3d.Engine";
Object.assign(h3d_Engine.prototype, {
	__class__: h3d_Engine
	,driver: null
	,mem: null
	,hardware: null
	,width: null
	,height: null
	,debug: null
	,drawTriangles: null
	,drawCalls: null
	,shaderSwitches: null
	,backgroundColor: null
	,autoResize: null
	,fullScreen: null
	,realFps: null
	,lastTime: null
	,antiAlias: null
	,tmpVector: null
	,window: null
	,targetTmp: null
	,targetStack: null
	,currentTargetTex: null
	,currentTargetLayer: null
	,currentTargetMip: null
	,needFlushTarget: null
	,nullTexture: null
	,textureColorCache: null
	,inRender: null
	,ready: null
	,resCache: null
});
class h3d_Indexes {
	constructor(count,is32) {
		if(is32 == null) {
			is32 = false;
		}
		this.mem = h3d_Engine.CURRENT.mem;
		this.count = count;
		this.is32 = is32;
		this.mem.allocIndexes(this);
	}
	isDisposed() {
		return this.ibuf == null;
	}
	upload(indexes,pos,count,bufferPos) {
		if(bufferPos == null) {
			bufferPos = 0;
		}
		this.mem.driver.uploadIndexBuffer(this.ibuf,pos,count,indexes,bufferPos);
	}
	dispose() {
		if(this.ibuf != null) {
			this.mem.deleteIndexes(this);
		}
	}
	static alloc(i,startPos,length) {
		if(length == null) {
			length = -1;
		}
		if(startPos == null) {
			startPos = 0;
		}
		if(length < 0) {
			length = i.length;
		}
		let idx = new h3d_Indexes(length);
		idx.upload(i,0,length);
		return idx;
	}
}
$hxClasses["h3d.Indexes"] = h3d_Indexes;
h3d_Indexes.__name__ = "h3d.Indexes";
Object.assign(h3d_Indexes.prototype, {
	__class__: h3d_Indexes
	,mem: null
	,ibuf: null
	,is32: null
	,count: null
});
class h3d_Matrix {
	constructor() {
	}
	equal(other) {
		if(this._11 == other._11 && this._12 == other._12 && this._13 == other._13 && this._14 == other._14 && this._21 == other._21 && this._22 == other._22 && this._23 == other._23 && this._24 == other._24 && this._31 == other._31 && this._32 == other._32 && this._33 == other._33 && this._34 == other._34 && this._41 == other._41 && this._42 == other._42 && this._43 == other._43) {
			return this._44 == other._44;
		} else {
			return false;
		}
	}
	zero() {
		this._11 = 0.0;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = 0.0;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = 0.0;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 0.0;
	}
	identity() {
		this._11 = 1.0;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = 1.0;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = 1.0;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 1.0;
	}
	initTranslation(x,y,z) {
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this._11 = 1.0;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = 1.0;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = 1.0;
		this._34 = 0.0;
		this._41 = x;
		this._42 = y;
		this._43 = z;
		this._44 = 1.0;
	}
	initScale(x,y,z) {
		if(z == null) {
			z = 1.;
		}
		if(y == null) {
			y = 1.;
		}
		if(x == null) {
			x = 1.;
		}
		this._11 = x;
		this._12 = 0.0;
		this._13 = 0.0;
		this._14 = 0.0;
		this._21 = 0.0;
		this._22 = y;
		this._23 = 0.0;
		this._24 = 0.0;
		this._31 = 0.0;
		this._32 = 0.0;
		this._33 = z;
		this._34 = 0.0;
		this._41 = 0.0;
		this._42 = 0.0;
		this._43 = 0.0;
		this._44 = 1.0;
	}
	initRotationAxis(axis,angle) {
		let cos = Math.cos(angle);
		let sin = Math.sin(angle);
		let cos1 = 1 - cos;
		let x = -axis.x;
		let y = -axis.y;
		let z = -axis.z;
		let xx = x * x;
		let yy = y * y;
		let zz = z * z;
		let len = 1. / Math.sqrt(xx + yy + zz);
		x *= len;
		y *= len;
		z *= len;
		let xcos1 = x * cos1;
		let zcos1 = z * cos1;
		this._11 = cos + x * xcos1;
		this._12 = y * xcos1 - z * sin;
		this._13 = x * zcos1 + y * sin;
		this._14 = 0.;
		this._21 = y * xcos1 + z * sin;
		this._22 = cos + y * y * cos1;
		this._23 = y * zcos1 - x * sin;
		this._24 = 0.;
		this._31 = x * zcos1 - y * sin;
		this._32 = y * zcos1 + x * sin;
		this._33 = cos + z * zcos1;
		this._34 = 0.;
		this._41 = 0.;
		this._42 = 0.;
		this._43 = 0.;
		this._44 = 1.;
	}
	initRotation(x,y,z) {
		let cx = Math.cos(x);
		let sx = Math.sin(x);
		let cy = Math.cos(y);
		let sy = Math.sin(y);
		let cz = Math.cos(z);
		let sz = Math.sin(z);
		let cxsy = cx * sy;
		let sxsy = sx * sy;
		this._11 = cy * cz;
		this._12 = cy * sz;
		this._13 = -sy;
		this._14 = 0;
		this._21 = sxsy * cz - cx * sz;
		this._22 = sxsy * sz + cx * cz;
		this._23 = sx * cy;
		this._24 = 0;
		this._31 = cxsy * cz + sx * sz;
		this._32 = cxsy * sz - sx * cz;
		this._33 = cx * cy;
		this._34 = 0;
		this._41 = 0;
		this._42 = 0;
		this._43 = 0;
		this._44 = 1;
	}
	scale(x,y,z) {
		if(z == null) {
			z = 1.;
		}
		if(y == null) {
			y = 1.;
		}
		if(x == null) {
			x = 1.;
		}
		this._11 *= x;
		this._21 *= x;
		this._31 *= x;
		this._41 *= x;
		this._12 *= y;
		this._22 *= y;
		this._32 *= y;
		this._42 *= y;
		this._13 *= z;
		this._23 *= z;
		this._33 *= z;
		this._43 *= z;
	}
	prependRotation(x,y,z) {
		let tmp = h3d_Matrix.tmp;
		tmp.initRotation(x,y,z);
		this.multiply(tmp,this);
	}
	prependScale(sx,sy,sz) {
		if(sz == null) {
			sz = 1.;
		}
		if(sy == null) {
			sy = 1.;
		}
		if(sx == null) {
			sx = 1.;
		}
		let tmp = h3d_Matrix.tmp;
		tmp.initScale(sx,sy,sz);
		this.multiply(tmp,this);
	}
	multiply3x4(a,b) {
		let m11 = a._11;
		let m12 = a._12;
		let m13 = a._13;
		let m21 = a._21;
		let m22 = a._22;
		let m23 = a._23;
		let a31 = a._31;
		let a32 = a._32;
		let a33 = a._33;
		let a41 = a._41;
		let a42 = a._42;
		let a43 = a._43;
		let b11 = b._11;
		let b12 = b._12;
		let b13 = b._13;
		let b21 = b._21;
		let b22 = b._22;
		let b23 = b._23;
		let b31 = b._31;
		let b32 = b._32;
		let b33 = b._33;
		let b41 = b._41;
		let b42 = b._42;
		let b43 = b._43;
		this._11 = m11 * b11 + m12 * b21 + m13 * b31;
		this._12 = m11 * b12 + m12 * b22 + m13 * b32;
		this._13 = m11 * b13 + m12 * b23 + m13 * b33;
		this._14 = 0;
		this._21 = m21 * b11 + m22 * b21 + m23 * b31;
		this._22 = m21 * b12 + m22 * b22 + m23 * b32;
		this._23 = m21 * b13 + m22 * b23 + m23 * b33;
		this._24 = 0;
		this._31 = a31 * b11 + a32 * b21 + a33 * b31;
		this._32 = a31 * b12 + a32 * b22 + a33 * b32;
		this._33 = a31 * b13 + a32 * b23 + a33 * b33;
		this._34 = 0;
		this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
		this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
		this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
		this._44 = 1;
	}
	multiply(a,b) {
		let a11 = a._11;
		let a12 = a._12;
		let a13 = a._13;
		let a14 = a._14;
		let a21 = a._21;
		let a22 = a._22;
		let a23 = a._23;
		let a24 = a._24;
		let a31 = a._31;
		let a32 = a._32;
		let a33 = a._33;
		let a34 = a._34;
		let a41 = a._41;
		let a42 = a._42;
		let a43 = a._43;
		let a44 = a._44;
		let b11 = b._11;
		let b12 = b._12;
		let b13 = b._13;
		let b14 = b._14;
		let b21 = b._21;
		let b22 = b._22;
		let b23 = b._23;
		let b24 = b._24;
		let b31 = b._31;
		let b32 = b._32;
		let b33 = b._33;
		let b34 = b._34;
		let b41 = b._41;
		let b42 = b._42;
		let b43 = b._43;
		let b44 = b._44;
		this._11 = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		this._12 = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		this._13 = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		this._14 = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
		this._21 = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		this._22 = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		this._23 = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		this._24 = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
		this._31 = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		this._32 = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		this._33 = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		this._34 = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
		this._41 = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		this._42 = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		this._43 = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		this._44 = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	}
	getInverse(m) {
		if(m == null) {
			m = new h3d_Matrix();
		}
		m.initInverse(this);
		return m;
	}
	inverse3x4(m) {
		let m11 = m._11;
		let m12 = m._12;
		let m13 = m._13;
		let m21 = m._21;
		let m22 = m._22;
		let m23 = m._23;
		let m31 = m._31;
		let m32 = m._32;
		let m33 = m._33;
		let m41 = m._41;
		let m42 = m._42;
		let m43 = m._43;
		this._11 = m22 * m33 - m23 * m32;
		this._12 = m13 * m32 - m12 * m33;
		this._13 = m12 * m23 - m13 * m22;
		this._14 = 0;
		this._21 = m23 * m31 - m21 * m33;
		this._22 = m11 * m33 - m13 * m31;
		this._23 = m13 * m21 - m11 * m23;
		this._24 = 0;
		this._31 = m21 * m32 - m22 * m31;
		this._32 = m12 * m31 - m11 * m32;
		this._33 = m11 * m22 - m12 * m21;
		this._34 = 0;
		this._41 = -m21 * m32 * m43 + m21 * m33 * m42 + m31 * m22 * m43 - m31 * m23 * m42 - m41 * m22 * m33 + m41 * m23 * m32;
		this._42 = m11 * m32 * m43 - m11 * m33 * m42 - m31 * m12 * m43 + m31 * m13 * m42 + m41 * m12 * m33 - m41 * m13 * m32;
		this._43 = -m11 * m22 * m43 + m11 * m23 * m42 + m21 * m12 * m43 - m21 * m13 * m42 - m41 * m12 * m23 + m41 * m13 * m22;
		this._44 = m11 * m22 * m33 - m11 * m23 * m32 - m21 * m12 * m33 + m21 * m13 * m32 + m31 * m12 * m23 - m31 * m13 * m22;
		this._44 = 1;
		let det = m11 * this._11 + m12 * this._21 + m13 * this._31;
		if((det < 0 ? -det : det) < 1e-10) {
			this.zero();
			return;
		}
		let invDet = 1.0 / det;
		this._11 *= invDet;
		this._12 *= invDet;
		this._13 *= invDet;
		this._21 *= invDet;
		this._22 *= invDet;
		this._23 *= invDet;
		this._31 *= invDet;
		this._32 *= invDet;
		this._33 *= invDet;
		this._41 *= invDet;
		this._42 *= invDet;
		this._43 *= invDet;
	}
	initInverse(m) {
		let m11 = m._11;
		let m12 = m._12;
		let m13 = m._13;
		let m14 = m._14;
		let m21 = m._21;
		let m22 = m._22;
		let m23 = m._23;
		let m24 = m._24;
		let m31 = m._31;
		let m32 = m._32;
		let m33 = m._33;
		let m34 = m._34;
		let m41 = m._41;
		let m42 = m._42;
		let m43 = m._43;
		let m44 = m._44;
		this._11 = m22 * m33 * m44 - m22 * m34 * m43 - m32 * m23 * m44 + m32 * m24 * m43 + m42 * m23 * m34 - m42 * m24 * m33;
		this._12 = -m12 * m33 * m44 + m12 * m34 * m43 + m32 * m13 * m44 - m32 * m14 * m43 - m42 * m13 * m34 + m42 * m14 * m33;
		this._13 = m12 * m23 * m44 - m12 * m24 * m43 - m22 * m13 * m44 + m22 * m14 * m43 + m42 * m13 * m24 - m42 * m14 * m23;
		this._14 = -m12 * m23 * m34 + m12 * m24 * m33 + m22 * m13 * m34 - m22 * m14 * m33 - m32 * m13 * m24 + m32 * m14 * m23;
		this._21 = -m21 * m33 * m44 + m21 * m34 * m43 + m31 * m23 * m44 - m31 * m24 * m43 - m41 * m23 * m34 + m41 * m24 * m33;
		this._22 = m11 * m33 * m44 - m11 * m34 * m43 - m31 * m13 * m44 + m31 * m14 * m43 + m41 * m13 * m34 - m41 * m14 * m33;
		this._23 = -m11 * m23 * m44 + m11 * m24 * m43 + m21 * m13 * m44 - m21 * m14 * m43 - m41 * m13 * m24 + m41 * m14 * m23;
		this._24 = m11 * m23 * m34 - m11 * m24 * m33 - m21 * m13 * m34 + m21 * m14 * m33 + m31 * m13 * m24 - m31 * m14 * m23;
		this._31 = m21 * m32 * m44 - m21 * m34 * m42 - m31 * m22 * m44 + m31 * m24 * m42 + m41 * m22 * m34 - m41 * m24 * m32;
		this._32 = -m11 * m32 * m44 + m11 * m34 * m42 + m31 * m12 * m44 - m31 * m14 * m42 - m41 * m12 * m34 + m41 * m14 * m32;
		this._33 = m11 * m22 * m44 - m11 * m24 * m42 - m21 * m12 * m44 + m21 * m14 * m42 + m41 * m12 * m24 - m41 * m14 * m22;
		this._34 = -m11 * m22 * m34 + m11 * m24 * m32 + m21 * m12 * m34 - m21 * m14 * m32 - m31 * m12 * m24 + m31 * m14 * m22;
		this._41 = -m21 * m32 * m43 + m21 * m33 * m42 + m31 * m22 * m43 - m31 * m23 * m42 - m41 * m22 * m33 + m41 * m23 * m32;
		this._42 = m11 * m32 * m43 - m11 * m33 * m42 - m31 * m12 * m43 + m31 * m13 * m42 + m41 * m12 * m33 - m41 * m13 * m32;
		this._43 = -m11 * m22 * m43 + m11 * m23 * m42 + m21 * m12 * m43 - m21 * m13 * m42 - m41 * m12 * m23 + m41 * m13 * m22;
		this._44 = m11 * m22 * m33 - m11 * m23 * m32 - m21 * m12 * m33 + m21 * m13 * m32 + m31 * m12 * m23 - m31 * m13 * m22;
		let det = m11 * this._11 + m12 * this._21 + m13 * this._31 + m14 * this._41;
		if((det < 0 ? -det : det) < 1e-10) {
			this.zero();
			return;
		}
		det = 1.0 / det;
		this._11 *= det;
		this._12 *= det;
		this._13 *= det;
		this._14 *= det;
		this._21 *= det;
		this._22 *= det;
		this._23 *= det;
		this._24 *= det;
		this._31 *= det;
		this._32 *= det;
		this._33 *= det;
		this._34 *= det;
		this._41 *= det;
		this._42 *= det;
		this._43 *= det;
		this._44 *= det;
	}
	transpose() {
		let tmp = this._12;
		this._12 = this._21;
		this._21 = tmp;
		tmp = this._13;
		this._13 = this._31;
		this._31 = tmp;
		tmp = this._14;
		this._14 = this._41;
		this._41 = tmp;
		tmp = this._23;
		this._23 = this._32;
		this._32 = tmp;
		tmp = this._24;
		this._24 = this._42;
		this._42 = tmp;
		tmp = this._34;
		this._34 = this._43;
		this._43 = tmp;
	}
	clone() {
		let m = new h3d_Matrix();
		m._11 = this._11;
		m._12 = this._12;
		m._13 = this._13;
		m._14 = this._14;
		m._21 = this._21;
		m._22 = this._22;
		m._23 = this._23;
		m._24 = this._24;
		m._31 = this._31;
		m._32 = this._32;
		m._33 = this._33;
		m._34 = this._34;
		m._41 = this._41;
		m._42 = this._42;
		m._43 = this._43;
		m._44 = this._44;
		return m;
	}
	load(m) {
		this._11 = m._11;
		this._12 = m._12;
		this._13 = m._13;
		this._14 = m._14;
		this._21 = m._21;
		this._22 = m._22;
		this._23 = m._23;
		this._24 = m._24;
		this._31 = m._31;
		this._32 = m._32;
		this._33 = m._33;
		this._34 = m._34;
		this._41 = m._41;
		this._42 = m._42;
		this._43 = m._43;
		this._44 = m._44;
	}
	loadValues(a) {
		this._11 = a[0];
		this._12 = a[1];
		this._13 = a[2];
		this._14 = a[3];
		this._21 = a[4];
		this._22 = a[5];
		this._23 = a[6];
		this._24 = a[7];
		this._31 = a[8];
		this._32 = a[9];
		this._33 = a[10];
		this._34 = a[11];
		this._41 = a[12];
		this._42 = a[13];
		this._43 = a[14];
		this._44 = a[15];
	}
	getEulerAngles() {
		let m = this.clone();
		let s_x = 0.;
		let s_y = 0.;
		let s_z = 0.;
		s_x = Math.sqrt(this._11 * this._11 + this._12 * this._12 + this._13 * this._13);
		s_y = Math.sqrt(this._21 * this._21 + this._22 * this._22 + this._23 * this._23);
		s_z = Math.sqrt(this._31 * this._31 + this._32 * this._32 + this._33 * this._33);
		if(this._11 * (this._22 * this._33 - this._23 * this._32) + this._12 * (this._23 * this._31 - this._21 * this._33) + this._13 * (this._21 * this._32 - this._22 * this._31) < 0) {
			s_x *= -1;
			s_y *= -1;
			s_z *= -1;
		}
		m.prependScale(1.0 / s_x,1.0 / s_y,1.0 / s_z);
		let cy = Math.sqrt(m._11 * m._11 + m._12 * m._12);
		if(cy > 0.01) {
			let v1 = new h3d_Vector(Math.atan2(m._23,m._33),Math.atan2(-m._13,cy),Math.atan2(m._12,m._11));
			let v2 = new h3d_Vector(Math.atan2(-m._23,-m._33),Math.atan2(-m._13,-cy),Math.atan2(-m._12,-m._11));
			if(v1.x * v1.x + v1.y * v1.y + v1.z * v1.z < v2.x * v2.x + v2.y * v2.y + v2.z * v2.z) {
				return v1;
			} else {
				return v2;
			}
		} else {
			return new h3d_Vector(Math.atan2(-m._32,m._22),Math.atan2(-m._13,cy),0.0);
		}
	}
	colorHue(hue) {
		if(hue == 0.) {
			return;
		}
		let cosA = Math.cos(-hue);
		let sinA = Math.sin(-hue);
		let ch = (1 - cosA) / 3;
		let tmp = h3d_Matrix.tmp;
		tmp._11 = cosA + ch;
		tmp._12 = ch - 0.57735026918962576450914878050196 * sinA;
		tmp._13 = ch + 0.57735026918962576450914878050196 * sinA;
		tmp._21 = ch + 0.57735026918962576450914878050196 * sinA;
		tmp._22 = cosA + ch;
		tmp._23 = ch - 0.57735026918962576450914878050196 * sinA;
		tmp._31 = ch - 0.57735026918962576450914878050196 * sinA;
		tmp._32 = ch + 0.57735026918962576450914878050196 * sinA;
		tmp._33 = cosA + ch;
		tmp._34 = 0;
		tmp._41 = 0;
		tmp._42 = 0;
		tmp._43 = 0;
		this.multiply3x4(this,tmp);
	}
	colorGain(color,alpha) {
		let tmp = h3d_Matrix.tmp;
		tmp._11 = 1 - alpha;
		tmp._12 = 0;
		tmp._13 = 0;
		tmp._21 = 0;
		tmp._22 = 1 - alpha;
		tmp._23 = 0;
		tmp._31 = 0;
		tmp._32 = 0;
		tmp._33 = 1 - alpha;
		tmp._41 = (color >> 16 & 255) / 255 * alpha;
		tmp._42 = (color >> 8 & 255) / 255 * alpha;
		tmp._43 = (color & 255) / 255 * alpha;
		this.multiply3x4(this,tmp);
	}
	static I() {
		let m = new h3d_Matrix();
		m.identity();
		return m;
	}
	static L(a) {
		let m = new h3d_Matrix();
		m.loadValues(a);
		return m;
	}
	static T(x,y,z) {
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let m = new h3d_Matrix();
		m.initTranslation(x,y,z);
		return m;
	}
	static R(x,y,z) {
		let m = new h3d_Matrix();
		m.initRotation(x,y,z);
		return m;
	}
	static S(x,y,z) {
		if(z == null) {
			z = 1.0;
		}
		if(y == null) {
			y = 1.;
		}
		if(x == null) {
			x = 1.;
		}
		let m = new h3d_Matrix();
		m.initScale(x,y,z);
		return m;
	}
}
$hxClasses["h3d.Matrix"] = h3d_Matrix;
h3d_Matrix.__name__ = "h3d.Matrix";
Object.assign(h3d_Matrix.prototype, {
	__class__: h3d_Matrix
	,_11: null
	,_12: null
	,_13: null
	,_14: null
	,_21: null
	,_22: null
	,_23: null
	,_24: null
	,_31: null
	,_32: null
	,_33: null
	,_34: null
	,_41: null
	,_42: null
	,_43: null
	,_44: null
});
class h3d_Quat {
	constructor(x,y,z,w) {
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}
}
$hxClasses["h3d.Quat"] = h3d_Quat;
h3d_Quat.__name__ = "h3d.Quat";
Object.assign(h3d_Quat.prototype, {
	__class__: h3d_Quat
	,x: null
	,y: null
	,z: null
	,w: null
});
class h3d_Vector {
	constructor(x,y,z,w) {
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;
	}
	clone() {
		return new h3d_Vector(this.x,this.y,this.z,this.w);
	}
}
$hxClasses["h3d.Vector"] = h3d_Vector;
h3d_Vector.__name__ = "h3d.Vector";
Object.assign(h3d_Vector.prototype, {
	__class__: h3d_Vector
	,x: null
	,y: null
	,z: null
	,w: null
});
class h3d_anim_AnimatedObject {
}
$hxClasses["h3d.anim.AnimatedObject"] = h3d_anim_AnimatedObject;
h3d_anim_AnimatedObject.__name__ = "h3d.anim.AnimatedObject";
class h3d_anim_Animation {
	constructor(name,frameCount,sampling) {
		this.name = name;
		this.frameCount = frameCount;
		this.sampling = sampling;
		this.objects = [];
		this.lastEvent = -1;
		this.frame = 0.;
		this.speed = 1.;
		this.loop = true;
		this.pause = false;
	}
	getPropValue(objectName,propName) {
		return null;
	}
	sync(decompose) {
		if(decompose == null) {
			decompose = false;
		}
		throw haxe_Exception.thrown("assert");
	}
	isPlaying() {
		if(!this.pause) {
			return (this.speed < 0 ? -this.speed : this.speed) > 0.000001;
		} else {
			return false;
		}
	}
	endFrame() {
		return this.frameCount;
	}
	update(dt) {
		if(!this.isInstance) {
			throw haxe_Exception.thrown("You must instantiate this animation first");
		}
		if(!this.isPlaying()) {
			return 0;
		}
		if(this.events != null && this.onEvent != null) {
			let f0 = this.frame | 0;
			let f1 = this.frame + dt * this.speed * this.sampling | 0;
			if(f1 >= this.frameCount) {
				f1 = this.frameCount - 1;
			}
			let _g = f0;
			let _g1 = f1 + 1;
			while(_g < _g1) {
				let f = _g++;
				if(f == this.lastEvent) {
					continue;
				}
				this.lastEvent = f;
				if(this.events[f] != null) {
					let oldF = this.frame;
					let oldDT = dt;
					dt -= (f - this.frame) / (this.speed * this.sampling);
					this.frame = f;
					let _g = 0;
					let _g1 = this.events[f];
					while(_g < _g1.length) {
						let e = _g1[_g];
						++_g;
						this.onEvent(e);
					}
					if(this.frame == f && f == this.frameCount - 1) {
						this.frame = oldF;
						dt = oldDT;
						break;
					} else {
						return dt;
					}
				}
			}
		}
		if(this.onAnimEnd != null) {
			let end = this.endFrame();
			let et = this.speed == 0 ? 0 : (end - this.frame) / (this.speed * this.sampling);
			if(et <= dt && et > 0) {
				this.frame = end;
				dt -= et;
				this.onAnimEnd();
				if(this.frame == end && this.isPlaying()) {
					if(this.loop) {
						this.frame = 0;
					} else {
						dt = 0;
					}
				}
				return dt;
			}
		}
		this.frame += dt * this.speed * this.sampling;
		if(this.frame >= this.frameCount) {
			if(this.loop) {
				this.frame %= this.frameCount;
			} else {
				this.frame = this.frameCount;
			}
		}
		return 0;
	}
}
$hxClasses["h3d.anim.Animation"] = h3d_anim_Animation;
h3d_anim_Animation.__name__ = "h3d.anim.Animation";
Object.assign(h3d_anim_Animation.prototype, {
	__class__: h3d_anim_Animation
	,name: null
	,frameCount: null
	,sampling: null
	,frame: null
	,speed: null
	,onAnimEnd: null
	,onEvent: null
	,pause: null
	,loop: null
	,events: null
	,isInstance: null
	,objects: null
	,lastEvent: null
});
class h3d_col_Collider {
}
$hxClasses["h3d.col.Collider"] = h3d_col_Collider;
h3d_col_Collider.__name__ = "h3d.col.Collider";
Object.assign(h3d_col_Collider.prototype, {
	__class__: h3d_col_Collider
});
class h3d_col_Bounds extends h3d_col_Collider {
	constructor() {
		super();
		this.xMin = 1e20;
		this.xMax = -1e20;
		this.yMin = 1e20;
		this.yMax = -1e20;
		this.zMin = 1e20;
		this.zMax = -1e20;
	}
	inFrustum(f,m) {
		if(m != null) {
			throw haxe_Exception.thrown("Not implemented");
		}
		return f.hasBounds(this);
	}
	rayIntersection(r,bestMatch) {
		let minTx = (this.xMin - r.px) / r.lx;
		let minTy = (this.yMin - r.py) / r.ly;
		let minTz = (this.zMin - r.pz) / r.lz;
		let maxTx = (this.xMax - r.px) / r.lx;
		let maxTy = (this.yMax - r.py) / r.ly;
		let maxTz = (this.zMax - r.pz) / r.lz;
		let realMinTx = minTx > maxTx ? maxTx : minTx;
		let realMinTy = minTy > maxTy ? maxTy : minTy;
		let realMinTz = minTz > maxTz ? maxTz : minTz;
		let realMaxTx = minTx < maxTx ? maxTx : minTx;
		let realMaxTy = minTy < maxTy ? maxTy : minTy;
		let realMaxTz = minTz < maxTz ? maxTz : minTz;
		let a = realMaxTx > realMaxTy ? realMaxTy : realMaxTx;
		let minmax = a > realMaxTz ? realMaxTz : a;
		let a1 = realMinTx < realMinTy ? realMinTy : realMinTx;
		let maxmin = a1 < realMinTz ? realMinTz : a1;
		if(minmax < maxmin) {
			return -1;
		}
		return maxmin;
	}
	transform(m) {
		let xMin = this.xMin;
		let yMin = this.yMin;
		let zMin = this.zMin;
		let xMax = this.xMax;
		let yMax = this.yMax;
		let zMax = this.zMax;
		this.xMin = 1e20;
		this.xMax = -1e20;
		this.yMin = 1e20;
		this.yMax = -1e20;
		this.zMin = 1e20;
		this.zMax = -1e20;
		if(xMax < xMin && yMax < yMin && zMax < zMin) {
			return;
		}
		let v_x = 0.;
		let v_y = 0.;
		let v_z = 0.;
		let x = xMin;
		let y = yMin;
		let z = zMin;
		if(zMin == null) {
			z = 0.;
		}
		if(yMin == null) {
			y = 0.;
		}
		if(xMin == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		let px = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		let py = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		let pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px;
		v_y = py;
		v_z = pz;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		let x1 = xMin;
		let y1 = yMin;
		let z1 = zMax;
		if(zMax == null) {
			z1 = 0.;
		}
		if(yMin == null) {
			y1 = 0.;
		}
		if(xMin == null) {
			x1 = 0.;
		}
		v_x = x1;
		v_y = y1;
		v_z = z1;
		let px1 = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		let py1 = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		let pz1 = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px1;
		v_y = py1;
		v_z = pz1;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		let x2 = xMin;
		let y2 = yMax;
		let z2 = zMin;
		if(zMin == null) {
			z2 = 0.;
		}
		if(yMax == null) {
			y2 = 0.;
		}
		if(xMin == null) {
			x2 = 0.;
		}
		v_x = x2;
		v_y = y2;
		v_z = z2;
		let px2 = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		let py2 = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		let pz2 = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px2;
		v_y = py2;
		v_z = pz2;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		let x3 = xMin;
		let y3 = yMax;
		let z3 = zMax;
		if(zMax == null) {
			z3 = 0.;
		}
		if(yMax == null) {
			y3 = 0.;
		}
		if(xMin == null) {
			x3 = 0.;
		}
		v_x = x3;
		v_y = y3;
		v_z = z3;
		let px3 = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		let py3 = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		let pz3 = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px3;
		v_y = py3;
		v_z = pz3;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		let x4 = xMax;
		let y4 = yMin;
		let z4 = zMin;
		if(zMin == null) {
			z4 = 0.;
		}
		if(yMin == null) {
			y4 = 0.;
		}
		if(xMax == null) {
			x4 = 0.;
		}
		v_x = x4;
		v_y = y4;
		v_z = z4;
		let px4 = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		let py4 = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		let pz4 = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px4;
		v_y = py4;
		v_z = pz4;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		let x5 = xMax;
		let y5 = yMin;
		let z5 = zMax;
		if(zMax == null) {
			z5 = 0.;
		}
		if(yMin == null) {
			y5 = 0.;
		}
		if(xMax == null) {
			x5 = 0.;
		}
		v_x = x5;
		v_y = y5;
		v_z = z5;
		let px5 = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		let py5 = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		let pz5 = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px5;
		v_y = py5;
		v_z = pz5;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		let x6 = xMax;
		let y6 = yMax;
		let z6 = zMin;
		if(zMin == null) {
			z6 = 0.;
		}
		if(yMax == null) {
			y6 = 0.;
		}
		if(xMax == null) {
			x6 = 0.;
		}
		v_x = x6;
		v_y = y6;
		v_z = z6;
		let px6 = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		let py6 = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		let pz6 = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px6;
		v_y = py6;
		v_z = pz6;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
		let x7 = xMax;
		let y7 = yMax;
		let z7 = zMax;
		if(zMax == null) {
			z7 = 0.;
		}
		if(yMax == null) {
			y7 = 0.;
		}
		if(xMax == null) {
			x7 = 0.;
		}
		v_x = x7;
		v_y = y7;
		v_z = z7;
		let px7 = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		let py7 = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		let pz7 = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px7;
		v_y = py7;
		v_z = pz7;
		if(v_x < this.xMin) {
			this.xMin = v_x;
		}
		if(v_x > this.xMax) {
			this.xMax = v_x;
		}
		if(v_y < this.yMin) {
			this.yMin = v_y;
		}
		if(v_y > this.yMax) {
			this.yMax = v_y;
		}
		if(v_z < this.zMin) {
			this.zMin = v_z;
		}
		if(v_z > this.zMax) {
			this.zMax = v_z;
		}
	}
	intersection(a,b) {
		let a1 = a.xMin;
		let b1 = b.xMin;
		let xMin = a1 < b1 ? b1 : a1;
		let a2 = a.yMin;
		let b2 = b.yMin;
		let yMin = a2 < b2 ? b2 : a2;
		let a3 = a.zMin;
		let b3 = b.zMin;
		let zMin = a3 < b3 ? b3 : a3;
		let a4 = a.xMax;
		let b4 = b.xMax;
		let xMax = a4 > b4 ? b4 : a4;
		let a5 = a.yMax;
		let b5 = b.yMax;
		let yMax = a5 > b5 ? b5 : a5;
		let a6 = a.zMax;
		let b6 = b.zMax;
		let zMax = a6 > b6 ? b6 : a6;
		this.xMin = xMin;
		this.xMax = xMax;
		this.yMin = yMin;
		this.yMax = yMax;
		this.zMin = zMin;
		this.zMax = zMax;
	}
	load(b) {
		this.xMin = b.xMin;
		this.xMax = b.xMax;
		this.yMin = b.yMin;
		this.yMax = b.yMax;
		this.zMin = b.zMin;
		this.zMax = b.zMax;
	}
	scaleCenter(v) {
		let dx = (this.xMax - this.xMin) * 0.5 * v;
		let dy = (this.yMax - this.yMin) * 0.5 * v;
		let dz = (this.zMax - this.zMin) * 0.5 * v;
		let mx = (this.xMax + this.xMin) * 0.5;
		let my = (this.yMax + this.yMin) * 0.5;
		let mz = (this.zMax + this.zMin) * 0.5;
		this.xMin = mx - dx;
		this.yMin = my - dy;
		this.zMin = mz - dz;
		this.xMax = mx + dx;
		this.yMax = my + dy;
		this.zMax = mz + dz;
	}
	makeDebugObj() {
		let prim = new h3d_prim_Cube(this.xMax - this.xMin,this.yMax - this.yMin,this.zMax - this.zMin);
		prim.translate(this.xMin,this.yMin,this.zMin);
		prim.addNormals();
		return new h3d_scene_Mesh(prim);
	}
}
$hxClasses["h3d.col.Bounds"] = h3d_col_Bounds;
h3d_col_Bounds.__name__ = "h3d.col.Bounds";
h3d_col_Bounds.__super__ = h3d_col_Collider;
Object.assign(h3d_col_Bounds.prototype, {
	__class__: h3d_col_Bounds
	,xMin: null
	,xMax: null
	,yMin: null
	,yMax: null
	,zMin: null
	,zMax: null
});
class h3d_col_Frustum {
	constructor(mvp) {
		this.checkNearFar = true;
		this.pleft = new h3d_col_Plane(1,0,0,0.0);
		this.pright = new h3d_col_Plane(1,0,0,0.0);
		this.ptop = new h3d_col_Plane(1,0,0,0.0);
		this.pbottom = new h3d_col_Plane(1,0,0,0.0);
		this.pnear = new h3d_col_Plane(1,0,0,0.0);
		this.pfar = new h3d_col_Plane(1,0,0,0.0);
		if(mvp != null) {
			this.loadMatrix(mvp);
		}
	}
	clone() {
		let f = new h3d_col_Frustum();
		let _this = f.pleft;
		let p = this.pleft;
		_this.nx = p.nx;
		_this.ny = p.ny;
		_this.nz = p.nz;
		_this.d = p.d;
		let _this1 = f.pright;
		let p1 = this.pright;
		_this1.nx = p1.nx;
		_this1.ny = p1.ny;
		_this1.nz = p1.nz;
		_this1.d = p1.d;
		let _this2 = f.ptop;
		let p2 = this.ptop;
		_this2.nx = p2.nx;
		_this2.ny = p2.ny;
		_this2.nz = p2.nz;
		_this2.d = p2.d;
		let _this3 = f.pbottom;
		let p3 = this.pbottom;
		_this3.nx = p3.nx;
		_this3.ny = p3.ny;
		_this3.nz = p3.nz;
		_this3.d = p3.d;
		let _this4 = f.pnear;
		let p4 = this.pnear;
		_this4.nx = p4.nx;
		_this4.ny = p4.ny;
		_this4.nz = p4.nz;
		_this4.d = p4.d;
		let _this5 = f.pfar;
		let p5 = this.pfar;
		_this5.nx = p5.nx;
		_this5.ny = p5.ny;
		_this5.nz = p5.nz;
		_this5.d = p5.d;
		f.checkNearFar = this.checkNearFar;
		return f;
	}
	loadMatrix(mvp) {
		let _this = this.pleft;
		_this.nx = mvp._14 + mvp._11;
		_this.ny = mvp._24 + mvp._21;
		_this.nz = mvp._34 + mvp._31;
		_this.d = -(mvp._44 + mvp._41);
		let _this1 = this.pright;
		_this1.nx = mvp._14 - mvp._11;
		_this1.ny = mvp._24 - mvp._21;
		_this1.nz = mvp._34 - mvp._31;
		_this1.d = mvp._41 - mvp._44;
		let _this2 = this.ptop;
		_this2.nx = mvp._14 - mvp._12;
		_this2.ny = mvp._24 - mvp._22;
		_this2.nz = mvp._34 - mvp._32;
		_this2.d = mvp._42 - mvp._44;
		let _this3 = this.pbottom;
		_this3.nx = mvp._14 + mvp._12;
		_this3.ny = mvp._24 + mvp._22;
		_this3.nz = mvp._34 + mvp._32;
		_this3.d = -(mvp._44 + mvp._42);
		let _this4 = this.pnear;
		_this4.nx = mvp._13;
		_this4.ny = mvp._23;
		_this4.nz = mvp._33;
		_this4.d = -mvp._43;
		let _this5 = this.pfar;
		_this5.nx = mvp._14 - mvp._13;
		_this5.ny = mvp._24 - mvp._23;
		_this5.nz = mvp._34 - mvp._33;
		_this5.d = mvp._43 - mvp._44;
		let _this6 = this.pleft;
		let len = 1. / Math.sqrt(_this6.nx * _this6.nx + _this6.ny * _this6.ny + _this6.nz * _this6.nz);
		_this6.nx *= len;
		_this6.ny *= len;
		_this6.nz *= len;
		_this6.d *= len;
		let _this7 = this.pright;
		let len1 = 1. / Math.sqrt(_this7.nx * _this7.nx + _this7.ny * _this7.ny + _this7.nz * _this7.nz);
		_this7.nx *= len1;
		_this7.ny *= len1;
		_this7.nz *= len1;
		_this7.d *= len1;
		let _this8 = this.ptop;
		let len2 = 1. / Math.sqrt(_this8.nx * _this8.nx + _this8.ny * _this8.ny + _this8.nz * _this8.nz);
		_this8.nx *= len2;
		_this8.ny *= len2;
		_this8.nz *= len2;
		_this8.d *= len2;
		let _this9 = this.pbottom;
		let len3 = 1. / Math.sqrt(_this9.nx * _this9.nx + _this9.ny * _this9.ny + _this9.nz * _this9.nz);
		_this9.nx *= len3;
		_this9.ny *= len3;
		_this9.nz *= len3;
		_this9.d *= len3;
		let _this10 = this.pnear;
		let len4 = 1. / Math.sqrt(_this10.nx * _this10.nx + _this10.ny * _this10.ny + _this10.nz * _this10.nz);
		_this10.nx *= len4;
		_this10.ny *= len4;
		_this10.nz *= len4;
		_this10.d *= len4;
		let _this11 = this.pfar;
		let len5 = 1. / Math.sqrt(_this11.nx * _this11.nx + _this11.ny * _this11.ny + _this11.nz * _this11.nz);
		_this11.nx *= len5;
		_this11.ny *= len5;
		_this11.nz *= len5;
		_this11.d *= len5;
	}
	hasSphere(s) {
		let x = s.x;
		let y = s.y;
		let z = s.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let p_x = x;
		let p_y = y;
		let p_z = z;
		let _this = this.pleft;
		if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
			return false;
		}
		let _this1 = this.pright;
		if(_this1.nx * p_x + _this1.ny * p_y + _this1.nz * p_z - _this1.d < -s.r) {
			return false;
		}
		let _this2 = this.ptop;
		if(_this2.nx * p_x + _this2.ny * p_y + _this2.nz * p_z - _this2.d < -s.r) {
			return false;
		}
		let _this3 = this.pbottom;
		if(_this3.nx * p_x + _this3.ny * p_y + _this3.nz * p_z - _this3.d < -s.r) {
			return false;
		}
		if(this.checkNearFar) {
			let _this = this.pnear;
			if(_this.nx * p_x + _this.ny * p_y + _this.nz * p_z - _this.d < -s.r) {
				return false;
			}
			let _this1 = this.pfar;
			if(_this1.nx * p_x + _this1.ny * p_y + _this1.nz * p_z - _this1.d < -s.r) {
				return false;
			}
		}
		return true;
	}
	hasBounds(b) {
		let p = this.pleft;
		let a = p.nx;
		let b1 = p.ny;
		let c = p.nz;
		let dd = a * (b.xMax + b.xMin) + b1 * (b.yMax + b.yMin) + c * (b.zMax + b.zMin);
		if(a < 0) {
			a = -a;
		}
		if(b1 < 0) {
			b1 = -b1;
		}
		if(c < 0) {
			c = -c;
		}
		let rr = a * (b.xMax - b.xMin) + b1 * (b.yMax - b.yMin) + c * (b.zMax - b.zMin);
		if(dd + rr - p.d * 2 < 0) {
			return false;
		}
		let p1 = this.pright;
		let a1 = p1.nx;
		let b2 = p1.ny;
		let c1 = p1.nz;
		let dd1 = a1 * (b.xMax + b.xMin) + b2 * (b.yMax + b.yMin) + c1 * (b.zMax + b.zMin);
		if(a1 < 0) {
			a1 = -a1;
		}
		if(b2 < 0) {
			b2 = -b2;
		}
		if(c1 < 0) {
			c1 = -c1;
		}
		let rr1 = a1 * (b.xMax - b.xMin) + b2 * (b.yMax - b.yMin) + c1 * (b.zMax - b.zMin);
		if(dd1 + rr1 - p1.d * 2 < 0) {
			return false;
		}
		let p2 = this.ptop;
		let a2 = p2.nx;
		let b3 = p2.ny;
		let c2 = p2.nz;
		let dd2 = a2 * (b.xMax + b.xMin) + b3 * (b.yMax + b.yMin) + c2 * (b.zMax + b.zMin);
		if(a2 < 0) {
			a2 = -a2;
		}
		if(b3 < 0) {
			b3 = -b3;
		}
		if(c2 < 0) {
			c2 = -c2;
		}
		let rr2 = a2 * (b.xMax - b.xMin) + b3 * (b.yMax - b.yMin) + c2 * (b.zMax - b.zMin);
		if(dd2 + rr2 - p2.d * 2 < 0) {
			return false;
		}
		let p3 = this.pbottom;
		let a3 = p3.nx;
		let b4 = p3.ny;
		let c3 = p3.nz;
		let dd3 = a3 * (b.xMax + b.xMin) + b4 * (b.yMax + b.yMin) + c3 * (b.zMax + b.zMin);
		if(a3 < 0) {
			a3 = -a3;
		}
		if(b4 < 0) {
			b4 = -b4;
		}
		if(c3 < 0) {
			c3 = -c3;
		}
		let rr3 = a3 * (b.xMax - b.xMin) + b4 * (b.yMax - b.yMin) + c3 * (b.zMax - b.zMin);
		if(dd3 + rr3 - p3.d * 2 < 0) {
			return false;
		}
		let p4 = this.pnear;
		let a4 = p4.nx;
		let b5 = p4.ny;
		let c4 = p4.nz;
		let dd4 = a4 * (b.xMax + b.xMin) + b5 * (b.yMax + b.yMin) + c4 * (b.zMax + b.zMin);
		if(a4 < 0) {
			a4 = -a4;
		}
		if(b5 < 0) {
			b5 = -b5;
		}
		if(c4 < 0) {
			c4 = -c4;
		}
		let rr4 = a4 * (b.xMax - b.xMin) + b5 * (b.yMax - b.yMin) + c4 * (b.zMax - b.zMin);
		if(dd4 + rr4 - p4.d * 2 < 0) {
			return false;
		}
		let p5 = this.pfar;
		let a5 = p5.nx;
		let b6 = p5.ny;
		let c5 = p5.nz;
		let dd5 = a5 * (b.xMax + b.xMin) + b6 * (b.yMax + b.yMin) + c5 * (b.zMax + b.zMin);
		if(a5 < 0) {
			a5 = -a5;
		}
		if(b6 < 0) {
			b6 = -b6;
		}
		if(c5 < 0) {
			c5 = -c5;
		}
		let rr5 = a5 * (b.xMax - b.xMin) + b6 * (b.yMax - b.yMin) + c5 * (b.zMax - b.zMin);
		if(dd5 + rr5 - p5.d * 2 < 0) {
			return false;
		}
		return true;
	}
}
$hxClasses["h3d.col.Frustum"] = h3d_col_Frustum;
h3d_col_Frustum.__name__ = "h3d.col.Frustum";
Object.assign(h3d_col_Frustum.prototype, {
	__class__: h3d_col_Frustum
	,pleft: null
	,pright: null
	,ptop: null
	,pbottom: null
	,pnear: null
	,pfar: null
	,checkNearFar: null
});
class h3d_col_Ray {
	constructor() {
	}
	normalize() {
		let l = this.lx * this.lx + this.ly * this.ly + this.lz * this.lz;
		if(l == 1.) {
			return;
		}
		if(l < 1e-10) {
			l = 0;
		} else {
			l = 1. / Math.sqrt(l);
		}
		this.lx *= l;
		this.ly *= l;
		this.lz *= l;
	}
}
$hxClasses["h3d.col.Ray"] = h3d_col_Ray;
h3d_col_Ray.__name__ = "h3d.col.Ray";
Object.assign(h3d_col_Ray.prototype, {
	__class__: h3d_col_Ray
	,px: null
	,py: null
	,pz: null
	,lx: null
	,ly: null
	,lz: null
});
class h3d_col_Plane {
	constructor(nx,ny,nz,d) {
		this.nx = nx;
		this.ny = ny;
		this.nz = nz;
		this.d = d;
	}
}
$hxClasses["h3d.col.Plane"] = h3d_col_Plane;
h3d_col_Plane.__name__ = "h3d.col.Plane";
Object.assign(h3d_col_Plane.prototype, {
	__class__: h3d_col_Plane
	,nx: null
	,ny: null
	,nz: null
	,d: null
});
class h3d_col_Point {
	constructor(x,y,z) {
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.x = x;
		this.y = y;
		this.z = z;
	}
}
$hxClasses["h3d.col.Point"] = h3d_col_Point;
h3d_col_Point.__name__ = "h3d.col.Point";
Object.assign(h3d_col_Point.prototype, {
	__class__: h3d_col_Point
	,x: null
	,y: null
	,z: null
});
class h3d_scene_Object {
	constructor(parent) {
		if(h3d_scene_Object._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(parent);
	}
	_hx_constructor(parent) {
		this.flags = 32768;
		this.absPos = new h3d_Matrix();
		this.absPos.identity();
		this.x = 0;
		this.flags |= 1;
		this.y = 0;
		this.flags |= 1;
		this.z = 0;
		this.flags |= 1;
		this.scaleX = 1;
		this.flags |= 1;
		this.scaleY = 1;
		this.flags |= 1;
		this.scaleZ = 1;
		this.flags |= 1;
		this.qRot = new h3d_Quat();
		let b = this.follow != null;
		if(b) {
			this.flags |= 1;
		} else {
			this.flags &= -2;
		}
		this.flags |= 2;
		this.children = [];
		if(parent != null) {
			parent.addChild(this);
		}
	}
	set_cullingCollider(c) {
		this.cullingCollider = c;
		this.flags &= -4097;
		return c;
	}
	getMaterials(a,recursive) {
		if(recursive == null) {
			recursive = true;
		}
		if(a == null) {
			a = [];
		}
		if(recursive) {
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let o = _g1[_g];
				++_g;
				o.getMaterials(a);
			}
		}
		return a;
	}
	localToGlobal(pt) {
		this.syncPos();
		if(pt == null) {
			pt = new h3d_col_Point();
		}
		let m = this.absPos;
		let px = pt.x * m._11 + pt.y * m._21 + pt.z * m._31 + m._41;
		let py = pt.x * m._12 + pt.y * m._22 + pt.z * m._32 + m._42;
		let pz = pt.x * m._13 + pt.y * m._23 + pt.z * m._33 + m._43;
		pt.x = px;
		pt.y = py;
		pt.z = pz;
		return pt;
	}
	getInvPos() {
		this.syncPos();
		if(this.invPos == null) {
			this.invPos = new h3d_Matrix();
			this.invPos._44 = 0;
		}
		if(this.invPos._44 == 0) {
			this.invPos.inverse3x4(this.absPos);
		}
		return this.invPos;
	}
	getBounds(b,relativeTo) {
		if(b == null) {
			b = new h3d_col_Bounds();
		}
		if(this.parent != null && this.parent != relativeTo) {
			this.parent.syncPos();
		}
		this.addBoundsRec(b,relativeTo == null ? null : relativeTo.getInvPos());
		return b;
	}
	addBoundsRec(b,relativeTo) {
		if((this.flags & 1) != 0) {
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				c.flags |= 1;
			}
			let b = this.follow != null;
			if(b) {
				this.flags |= 1;
			} else {
				this.flags &= -2;
			}
			this.calcAbsPos();
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.addBoundsRec(b,relativeTo);
		}
	}
	getMeshes(out) {
		if(out == null) {
			out = [];
		}
		let m = ((this) instanceof h3d_scene_Mesh) ? this : null;
		if(m != null) {
			out.push(m);
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.getMeshes(out);
		}
		return out;
	}
	addChild(o) {
		this.addChildAt(o,this.children.length);
	}
	addChildAt(o,pos) {
		if(pos < 0) {
			pos = 0;
		}
		if(pos > this.children.length) {
			pos = this.children.length;
		}
		let p = this;
		while(p != null) {
			if(p == o) {
				throw haxe_Exception.thrown("Recursive addChild");
			}
			p = p.parent;
		}
		if(o.parent != null) {
			let old = (o.flags & 32) != 0;
			o.flags &= -33;
			o.parent.removeChild(o);
			if(old) {
				o.flags |= 32;
			} else {
				o.flags &= -33;
			}
		}
		this.children.splice(pos,0,o);
		if((this.flags & 32) == 0 && (o.flags & 32) != 0) {
			o.onRemove();
		}
		o.parent = this;
		o.flags |= 1;
		if((this.flags & 32) != 0) {
			if((o.flags & 32) == 0) {
				o.onAdd();
			} else {
				o.onParentChanged();
			}
		}
	}
	iterVisibleMeshes(callb) {
		if((this.flags & 2) == 0 || (this.flags & 4) != 0 && (this.flags & 128) != 0) {
			return;
		}
		if((this.flags & 4) == 0) {
			let m = ((this) instanceof h3d_scene_Mesh) ? this : null;
			if(m != null) {
				callb(m);
			}
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let o = _g1[_g];
			++_g;
			o.iterVisibleMeshes(callb);
		}
	}
	onParentChanged() {
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.onParentChanged();
		}
	}
	onAdd() {
		this.flags |= 32;
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.onAdd();
		}
	}
	onRemove() {
		this.flags &= -33;
		let i = this.children.length - 1;
		while(i >= 0) this.children[i--].onRemove();
	}
	removeChild(o) {
		if(HxOverrides.remove(this.children,o)) {
			if((o.flags & 32) != 0) {
				o.onRemove();
			}
			o.parent = null;
			o.flags |= 1;
		}
	}
	removeChildren() {
		while(this.children.length > 0) this.removeChild(this.children[0]);
	}
	getScene() {
		let p = this;
		while(p.parent != null) p = p.parent;
		if(((p) instanceof h3d_scene_Scene)) {
			return p;
		} else {
			return null;
		}
	}
	getAbsPos() {
		this.syncPos();
		return this.absPos;
	}
	getRelPos(obj) {
		if(obj == null) {
			return this.getAbsPos();
		}
		this.syncPos();
		let m = new h3d_Matrix();
		m.multiply(this.absPos,obj.getInvPos());
		return m;
	}
	draw(ctx) {
	}
	set_follow(v) {
		this.flags |= 1;
		return this.follow = v;
	}
	calcAbsPos() {
		let _this = this.qRot;
		let m = this.absPos;
		if(m == null) {
			m = new h3d_Matrix();
		}
		let xx = _this.x * _this.x;
		let xy = _this.x * _this.y;
		let xz = _this.x * _this.z;
		let xw = _this.x * _this.w;
		let yy = _this.y * _this.y;
		let yz = _this.y * _this.z;
		let yw = _this.y * _this.w;
		let zz = _this.z * _this.z;
		let zw = _this.z * _this.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		this.absPos._11 *= this.scaleX;
		this.absPos._12 *= this.scaleX;
		this.absPos._13 *= this.scaleX;
		this.absPos._21 *= this.scaleY;
		this.absPos._22 *= this.scaleY;
		this.absPos._23 *= this.scaleY;
		this.absPos._31 *= this.scaleZ;
		this.absPos._32 *= this.scaleZ;
		this.absPos._33 *= this.scaleZ;
		this.absPos._41 = this.x;
		this.absPos._42 = this.y;
		this.absPos._43 = this.z;
		if(this.follow != null) {
			this.follow.syncPos();
			if((this.flags & 8) != 0) {
				let _this = this.absPos;
				let a = this.absPos;
				let b = this.parent.absPos;
				let m11 = a._11;
				let m12 = a._12;
				let m13 = a._13;
				let m21 = a._21;
				let m22 = a._22;
				let m23 = a._23;
				let a31 = a._31;
				let a32 = a._32;
				let a33 = a._33;
				let a41 = a._41;
				let a42 = a._42;
				let a43 = a._43;
				let b11 = b._11;
				let b12 = b._12;
				let b13 = b._13;
				let b21 = b._21;
				let b22 = b._22;
				let b23 = b._23;
				let b31 = b._31;
				let b32 = b._32;
				let b33 = b._33;
				let b41 = b._41;
				let b42 = b._42;
				let b43 = b._43;
				_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
				_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
				_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
				_this._14 = 0;
				_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
				_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
				_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
				_this._24 = 0;
				_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
				_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
				_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
				_this._34 = 0;
				_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
				_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
				_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
				_this._44 = 1;
				this.absPos._41 = this.x + this.follow.absPos._41;
				this.absPos._42 = this.y + this.follow.absPos._42;
				this.absPos._43 = this.z + this.follow.absPos._43;
			} else {
				this.absPos.multiply3x4(this.absPos,this.follow.absPos);
			}
		} else if(this.parent != null && (this.flags & 2048) == 0) {
			let _this = this.absPos;
			let a = this.absPos;
			let b = this.parent.absPos;
			let m11 = a._11;
			let m12 = a._12;
			let m13 = a._13;
			let m21 = a._21;
			let m22 = a._22;
			let m23 = a._23;
			let a31 = a._31;
			let a32 = a._32;
			let a33 = a._33;
			let a41 = a._41;
			let a42 = a._42;
			let a43 = a._43;
			let b11 = b._11;
			let b12 = b._12;
			let b13 = b._13;
			let b21 = b._21;
			let b22 = b._22;
			let b23 = b._23;
			let b31 = b._31;
			let b32 = b._32;
			let b33 = b._33;
			let b41 = b._41;
			let b42 = b._42;
			let b43 = b._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		}
		if(this.defaultTransform != null) {
			let _this = this.absPos;
			let a = this.defaultTransform;
			let b = this.absPos;
			let m11 = a._11;
			let m12 = a._12;
			let m13 = a._13;
			let m21 = a._21;
			let m22 = a._22;
			let m23 = a._23;
			let a31 = a._31;
			let a32 = a._32;
			let a33 = a._33;
			let a41 = a._41;
			let a42 = a._42;
			let a43 = a._43;
			let b11 = b._11;
			let b12 = b._12;
			let b13 = b._13;
			let b21 = b._21;
			let b22 = b._22;
			let b23 = b._23;
			let b31 = b._31;
			let b32 = b._32;
			let b33 = b._33;
			let b41 = b._41;
			let b42 = b._42;
			let b43 = b._43;
			_this._11 = m11 * b11 + m12 * b21 + m13 * b31;
			_this._12 = m11 * b12 + m12 * b22 + m13 * b32;
			_this._13 = m11 * b13 + m12 * b23 + m13 * b33;
			_this._14 = 0;
			_this._21 = m21 * b11 + m22 * b21 + m23 * b31;
			_this._22 = m21 * b12 + m22 * b22 + m23 * b32;
			_this._23 = m21 * b13 + m22 * b23 + m23 * b33;
			_this._24 = 0;
			_this._31 = a31 * b11 + a32 * b21 + a33 * b31;
			_this._32 = a31 * b12 + a32 * b22 + a33 * b32;
			_this._33 = a31 * b13 + a32 * b23 + a33 * b33;
			_this._34 = 0;
			_this._41 = a41 * b11 + a42 * b21 + a43 * b31 + b41;
			_this._42 = a41 * b12 + a42 * b22 + a43 * b32 + b42;
			_this._43 = a41 * b13 + a42 * b23 + a43 * b33 + b43;
			_this._44 = 1;
		}
		if(this.invPos != null) {
			this.invPos._44 = 0;
		}
	}
	sync(ctx) {
	}
	syncRec(ctx) {
		if(this.currentAnimation != null) {
			let old = this.parent;
			let dt = ctx.elapsedTime;
			while(dt > 0 && this.currentAnimation != null) dt = this.currentAnimation.update(dt);
			if(this.currentAnimation != null && (ctx.visibleFlag && (this.flags & 2) != 0 && (this.flags & 4) == 0 || (this.flags & 64) != 0)) {
				this.currentAnimation.sync();
			}
			if(this.parent == null && old != null) {
				return;
			}
		}
		if((this.flags & 32768) == 0 && ((this.flags & 4) != 0 || (this.flags & 2) == 0 || !ctx.visibleFlag)) {
			return;
		}
		let old = ctx.visibleFlag;
		if((this.flags & 2) == 0 || (this.flags & 4) != 0 && (this.flags & 128) != 0) {
			ctx.visibleFlag = false;
		}
		if(ctx.cullingCollider != null && (this.cullingCollider == null || (this.flags & 4096) != 0)) {
			this.set_cullingCollider(ctx.cullingCollider);
			this.flags |= 4096;
		} else if((this.flags & 4096) != 0) {
			this.set_cullingCollider(null);
		}
		let prevCollider = ctx.cullingCollider;
		if((this.flags & 128) != 0) {
			ctx.cullingCollider = this.cullingCollider;
		}
		let changed = (this.flags & 1) != 0;
		if(changed) {
			this.calcAbsPos();
		}
		if((this.flags & 8192) != 0) {
			if((this.flags & 16384) != 0 && !changed && !ctx.wasContextLost) {
				ctx.visibleFlag = old;
				ctx.cullingCollider = prevCollider;
				return;
			}
			this.flags |= 16384;
		}
		this.sync(ctx);
		let b = this.follow != null;
		if(b) {
			this.flags |= 1;
		} else {
			this.flags &= -2;
		}
		this.lastFrame = ctx.frame;
		let p = 0;
		let len = this.children.length;
		while(p < len) {
			let c = this.children[p];
			if(c == null) {
				break;
			}
			if(c.lastFrame != ctx.frame) {
				if(changed) {
					c.flags |= 1;
				}
				c.syncRec(ctx);
			}
			if(this.children[p] != c) {
				p = 0;
				len = this.children.length;
			} else {
				++p;
			}
		}
		ctx.visibleFlag = old;
		ctx.cullingCollider = prevCollider;
	}
	syncPos() {
		if(this.parent != null) {
			this.parent.syncPos();
		}
		if((this.flags & 1) != 0) {
			let b = this.follow != null;
			if(b) {
				this.flags |= 1;
			} else {
				this.flags &= -2;
			}
			this.calcAbsPos();
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				c.flags |= 1;
			}
		}
	}
	emit(ctx) {
	}
	emitRec(ctx) {
		if((this.flags & 2) == 0 || (this.flags & 4) != 0 && (this.flags & 128) != 0 && !ctx.computingStatic) {
			return;
		}
		if((this.flags & 1) != 0) {
			if(this.currentAnimation != null) {
				this.currentAnimation.sync();
			}
			let b = this.follow != null;
			if(b) {
				this.flags |= 1;
			} else {
				this.flags &= -2;
			}
			this.calcAbsPos();
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				c.flags |= 1;
			}
		}
		if((this.flags & 4) == 0 || ctx.computingStatic) {
			this.emit(ctx);
		}
		let _g = 0;
		let _g1 = this.children;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.emitRec(ctx);
		}
	}
	setTransform(mat) {
		let s_x = 0.;
		let s_y = 0.;
		let s_z = 0.;
		s_x = Math.sqrt(mat._11 * mat._11 + mat._12 * mat._12 + mat._13 * mat._13);
		s_y = Math.sqrt(mat._21 * mat._21 + mat._22 * mat._22 + mat._23 * mat._23);
		s_z = Math.sqrt(mat._31 * mat._31 + mat._32 * mat._32 + mat._33 * mat._33);
		if(mat._11 * (mat._22 * mat._33 - mat._23 * mat._32) + mat._12 * (mat._23 * mat._31 - mat._21 * mat._33) + mat._13 * (mat._21 * mat._32 - mat._22 * mat._31) < 0) {
			s_x *= -1;
			s_y *= -1;
			s_z *= -1;
		}
		let v = mat._41;
		this.x = v;
		this.flags |= 1;
		let v1 = mat._42;
		this.y = v1;
		this.flags |= 1;
		let v2 = mat._43;
		this.z = v2;
		this.flags |= 1;
		let v3 = s_x;
		this.scaleX = v3;
		this.flags |= 1;
		let v4 = s_y;
		this.scaleY = v4;
		this.flags |= 1;
		let v5 = s_z;
		this.scaleZ = v5;
		this.flags |= 1;
		h3d_scene_Object.tmpMat.load(mat);
		h3d_scene_Object.tmpMat.prependScale(1.0 / s_x,1.0 / s_y,1.0 / s_z);
		let _this = this.qRot;
		let m = h3d_scene_Object.tmpMat;
		let tr = m._11 + m._22 + m._33;
		if(tr > 0) {
			let s = Math.sqrt(tr + 1.0) * 2;
			let ins = 1 / s;
			_this.x = (m._23 - m._32) * ins;
			_this.y = (m._31 - m._13) * ins;
			_this.z = (m._12 - m._21) * ins;
			_this.w = 0.25 * s;
		} else if(m._11 > m._22 && m._11 > m._33) {
			let s = Math.sqrt(1.0 + m._11 - m._22 - m._33) * 2;
			let ins = 1 / s;
			_this.x = 0.25 * s;
			_this.y = (m._21 + m._12) * ins;
			_this.z = (m._31 + m._13) * ins;
			_this.w = (m._23 - m._32) * ins;
		} else if(m._22 > m._33) {
			let s = Math.sqrt(1.0 + m._22 - m._11 - m._33) * 2;
			let ins = 1 / s;
			_this.x = (m._21 + m._12) * ins;
			_this.y = 0.25 * s;
			_this.z = (m._32 + m._23) * ins;
			_this.w = (m._31 - m._13) * ins;
		} else {
			let s = Math.sqrt(1.0 + m._33 - m._11 - m._22) * 2;
			let ins = 1 / s;
			_this.x = (m._31 + m._13) * ins;
			_this.y = (m._32 + m._23) * ins;
			_this.z = 0.25 * s;
			_this.w = (m._12 - m._21) * ins;
		}
		this.flags |= 1;
	}
	getTransform(mat) {
		if(mat == null) {
			mat = new h3d_Matrix();
		}
		mat.initScale(this.scaleX,this.scaleY,this.scaleZ);
		let _this = this.qRot;
		let m = h3d_scene_Object.tmpMat;
		if(m == null) {
			m = new h3d_Matrix();
		}
		let xx = _this.x * _this.x;
		let xy = _this.x * _this.y;
		let xz = _this.x * _this.z;
		let xw = _this.x * _this.w;
		let yy = _this.y * _this.y;
		let yz = _this.y * _this.z;
		let yw = _this.y * _this.w;
		let zz = _this.z * _this.z;
		let zw = _this.z * _this.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		mat.multiply3x4(mat,h3d_scene_Object.tmpMat);
		mat._41 = this.x;
		mat._42 = this.y;
		mat._43 = this.z;
		return mat;
	}
	setDirection(v) {
		let _this = this.qRot;
		let x = v.x;
		let y = v.y;
		let z = v.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let _this_x = x;
		let _this_y = y;
		let _this_z = z;
		let k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		let x1 = _this_x * k;
		let y1 = _this_y * k;
		let z1 = _this_z * k;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let ax_x = x1;
		let ax_y = y1;
		let ax_z = z1;
		let x2 = -ax_y;
		let y2 = ax_x;
		if(ax_x == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let ay_x = x2;
		let ay_y = y2;
		let ay_z = 0;
		let k1 = ay_x * ay_x + ay_y * ay_y + ay_z * ay_z;
		if(k1 < 1e-10) {
			k1 = 0;
		} else {
			k1 = 1. / Math.sqrt(k1);
		}
		ay_x *= k1;
		ay_y *= k1;
		ay_z *= k1;
		if(ay_x * ay_x + ay_y * ay_y + ay_z * ay_z < 1e-10) {
			ay_x = ax_y;
			ay_y = ax_z;
			ay_z = ax_x;
		}
		let x3 = ax_y * ay_z - ax_z * ay_y;
		let y3 = ax_z * ay_x - ax_x * ay_z;
		let z2 = ax_x * ay_y - ax_y * ay_x;
		if(z2 == null) {
			z2 = 0.;
		}
		if(y3 == null) {
			y3 = 0.;
		}
		if(x3 == null) {
			x3 = 0.;
		}
		let az_x = x3;
		let az_y = y3;
		let az_z = z2;
		let tr = ax_x + ay_y + az_z;
		if(tr > 0) {
			let s = Math.sqrt(tr + 1.0) * 2;
			let ins = 1 / s;
			_this.x = (ay_z - az_y) * ins;
			_this.y = (az_x - ax_z) * ins;
			_this.z = (ax_y - ay_x) * ins;
			_this.w = 0.25 * s;
		} else if(ax_x > ay_y && ax_x > az_z) {
			let s = Math.sqrt(1.0 + ax_x - ay_y - az_z) * 2;
			let ins = 1 / s;
			_this.x = 0.25 * s;
			_this.y = (ay_x + ax_y) * ins;
			_this.z = (az_x + ax_z) * ins;
			_this.w = (ay_z - az_y) * ins;
		} else if(ay_y > az_z) {
			let s = Math.sqrt(1.0 + ay_y - ax_x - az_z) * 2;
			let ins = 1 / s;
			_this.x = (ay_x + ax_y) * ins;
			_this.y = 0.25 * s;
			_this.z = (az_y + ay_z) * ins;
			_this.w = (az_x - ax_z) * ins;
		} else {
			let s = Math.sqrt(1.0 + az_z - ax_x - ay_y) * 2;
			let ins = 1 / s;
			_this.x = (az_x + ax_z) * ins;
			_this.y = (az_y + ay_z) * ins;
			_this.z = 0.25 * s;
			_this.w = (ax_y - ay_x) * ins;
		}
		this.flags |= 1;
	}
	getRotationQuat() {
		return this.qRot;
	}
	setRotationQuat(q) {
		this.qRot = q;
		this.flags |= 1;
	}
}
$hxClasses["h3d.scene.Object"] = h3d_scene_Object;
h3d_scene_Object.__name__ = "h3d.scene.Object";
Object.assign(h3d_scene_Object.prototype, {
	__class__: h3d_scene_Object
	,flags: null
	,lastFrame: null
	,children: null
	,parent: null
	,name: null
	,x: null
	,y: null
	,z: null
	,scaleX: null
	,scaleY: null
	,scaleZ: null
	,follow: null
	,defaultTransform: null
	,currentAnimation: null
	,cullingCollider: null
	,absPos: null
	,invPos: null
	,qRot: null
});
class h3d_col_Sphere extends h3d_col_Collider {
	constructor(x,y,z,r) {
		if(r == null) {
			r = 0.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		super();
		let sx = x;
		let sy = y;
		let sz = z;
		let sr = r;
		if(r == null) {
			sr = 0.;
		}
		if(z == null) {
			sz = 0.;
		}
		if(y == null) {
			sy = 0.;
		}
		if(x == null) {
			sx = 0.;
		}
		this.x = sx;
		this.y = sy;
		this.z = sz;
		this.r = sr;
	}
	rayIntersection(r,bestMatch) {
		let r2 = this.r * this.r;
		let px = r.px + r.lx;
		let py = r.py + r.ly;
		let pz = r.pz + r.lz;
		let a = r.lx * r.lx + r.ly * r.ly + r.lz * r.lz;
		let b = 2 * r.lx * (this.x - px) + 2 * r.ly * (this.y - py) + 2 * r.lz * (this.z - pz);
		let c = this.x * this.x + this.y * this.y + this.z * this.z + (px * px + py * py + pz * pz) - 2 * (this.x * px + this.y * py + this.z * pz) - r2;
		let d = b * b - 4 * a * c;
		if(d < 0) {
			return -1;
		}
		d = Math.sqrt(d);
		let t = (-b + d) / (2 * a);
		return 1 - t;
	}
	inFrustum(f,m) {
		if(m != null) {
			return this.inFrustumMatrix(f,m);
		}
		return f.hasSphere(this);
	}
	inFrustumMatrix(f,m) {
		let oldX = this.x;
		let oldY = this.y;
		let oldZ = this.z;
		let oldR = this.r;
		let x = this.x;
		let y = this.y;
		let z = this.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let v_x = x;
		let v_y = y;
		let v_z = z;
		let px = v_x * m._11 + v_y * m._21 + v_z * m._31 + m._41;
		let py = v_x * m._12 + v_y * m._22 + v_z * m._32 + m._42;
		let pz = v_x * m._13 + v_y * m._23 + v_z * m._33 + m._43;
		v_x = px;
		v_y = py;
		v_z = pz;
		this.x = v_x;
		this.y = v_y;
		this.z = v_z;
		let scale_x = 0.;
		let scale_y = 0.;
		let scale_z = 0.;
		scale_x = Math.sqrt(m._11 * m._11 + m._12 * m._12 + m._13 * m._13);
		scale_y = Math.sqrt(m._21 * m._21 + m._22 * m._22 + m._23 * m._23);
		scale_z = Math.sqrt(m._31 * m._31 + m._32 * m._32 + m._33 * m._33);
		if(m._11 * (m._22 * m._33 - m._23 * m._32) + m._12 * (m._23 * m._31 - m._21 * m._33) + m._13 * (m._21 * m._32 - m._22 * m._31) < 0) {
			scale_x *= -1;
			scale_y *= -1;
			scale_z *= -1;
		}
		this.r *= Math.max(Math.max(scale_x,scale_y),scale_z);
		let res = f.hasSphere(this);
		this.x = oldX;
		this.y = oldY;
		this.z = oldZ;
		this.r = oldR;
		return res;
	}
}
$hxClasses["h3d.col.Sphere"] = h3d_col_Sphere;
h3d_col_Sphere.__name__ = "h3d.col.Sphere";
h3d_col_Sphere.__super__ = h3d_col_Collider;
Object.assign(h3d_col_Sphere.prototype, {
	__class__: h3d_col_Sphere
	,x: null
	,y: null
	,z: null
	,r: null
});
class h3d_impl__$Benchmark_QueryObject {
	constructor() {
		this.driver = h3d_Engine.CURRENT.driver;
		this.q = this.driver.allocQuery(h3d_impl_QueryKind.TimeStamp);
	}
	sync() {
		this.value = this.driver.queryResult(this.q);
	}
	isAvailable() {
		return this.driver.queryResultAvailable(this.q);
	}
	dispose() {
		this.driver.deleteQuery(this.q);
		this.q = null;
	}
}
$hxClasses["h3d.impl._Benchmark.QueryObject"] = h3d_impl__$Benchmark_QueryObject;
h3d_impl__$Benchmark_QueryObject.__name__ = "h3d.impl._Benchmark.QueryObject";
Object.assign(h3d_impl__$Benchmark_QueryObject.prototype, {
	__class__: h3d_impl__$Benchmark_QueryObject
	,driver: null
	,q: null
	,value: null
	,name: null
	,drawCalls: null
	,next: null
});
class h3d_impl__$Benchmark_StatsObject {
	constructor() {
	}
}
$hxClasses["h3d.impl._Benchmark.StatsObject"] = h3d_impl__$Benchmark_StatsObject;
h3d_impl__$Benchmark_StatsObject.__name__ = "h3d.impl._Benchmark.StatsObject";
Object.assign(h3d_impl__$Benchmark_StatsObject.prototype, {
	__class__: h3d_impl__$Benchmark_StatsObject
	,name: null
	,time: null
	,drawCalls: null
	,next: null
	,xPos: null
	,xSize: null
});
class h3d_impl_Benchmark extends h2d_Graphics {
	constructor(parent) {
		h2d_Object._hx_skip_constructor = true;
		super();
		h2d_Object._hx_skip_constructor = false;
		this._hx_constructor(parent);
	}
	_hx_constructor(parent) {
		this.measureCpu = false;
		this.smoothTime = 0.95;
		this.recalTime = 1e9;
		this.colors = [];
		this.textColor = 0;
		this.height = 16;
		this.estimateWait = false;
		super._hx_constructor(parent);
		this.waitFrames = [];
		this.labels = [];
		this.engine = h3d_Engine.CURRENT;
		this.interact = new h2d_Interactive(0,0,this);
		this.interact.onMove = $bind(this,this.onMove);
		this.interact.set_cursor(hxd_Cursor.Default);
		let _gthis = this;
		this.interact.onOut = function(_) {
			if(_gthis.tip == null) {
				return;
			}
			let _this = _gthis.tip.parent;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			_gthis.tip = null;
			_gthis.tipCurrent = null;
		};
		this.set_enable(this.engine.driver.hasFeature(h3d_impl_Feature.Queries));
	}
	set_enable(e) {
		if(!e) {
			this.cleanup();
		}
		return this.enable = e;
	}
	cleanup() {
		while(this.waitFrames.length > 0) {
			let w = this.waitFrames.pop();
			while(w != null) {
				w.dispose();
				w = w.next;
			}
		}
		while(this.cachedQueries != null) {
			this.cachedQueries.dispose();
			this.cachedQueries = this.cachedQueries.next;
		}
		while(this.currentFrame != null) {
			this.currentFrame.dispose();
			this.currentFrame = this.currentFrame.next;
		}
	}
	clear() {
		super.clear();
		if(this.labels != null) {
			let _g = 0;
			let _g1 = this.labels;
			while(_g < _g1.length) {
				let t = _g1[_g];
				++_g;
				if(t != null && t.parent != null) {
					t.parent.removeChild(t);
				}
			}
			this.labels = [];
		}
		if(this.interact != null) {
			this.interact.width = this.interact.height = 0;
		}
	}
	onRemove() {
		super.onRemove();
		this.cleanup();
	}
	onMove(e) {
		let s = this.currentStats;
		while(s != null) {
			if(e.relX >= s.xPos && e.relX <= s.xPos + s.xSize) {
				break;
			}
			s = s.next;
		}
		if(this.tip == null) {
			let fl = new h2d_Flow(this);
			fl.posChanged = true;
			fl.y = -23;
			fl.set_backgroundTile(h2d_Tile.fromColor(0,1,1,0.8));
			fl.set_padding(5);
			this.tip = new h2d_Text(this.font,fl);
			this.tip.dropShadow = { dx : 0, dy : 1, color : 0, alpha : 1};
		}
		this.tipCurrent = s;
		this.tipCurName = s == null ? null : s.name;
		this.syncTip(s);
	}
	syncTip(s) {
		if(s == null) {
			this.tip.set_text("total " + this.engine.drawCalls + " draws " + hxd_Math.fmt(this.engine.drawTriangles / 1000000) + " Mtri");
		} else {
			this.tip.set_text(s.name + "( " + (s.time / 1e6 | 0) + "." + StringTools.lpad("" + (s.time / 1e4 | 0) % 100,"0",2) + " ms " + s.drawCalls + " draws )");
		}
		let tw = this.tip.get_textWidth() + 10;
		let tx = s == null ? this.curWidth : s.xPos + (s.xSize - tw) * .5;
		if(tx + tw > this.curWidth) {
			tx = this.curWidth - tw;
		}
		if(tx < 0) {
			tx = 0;
		}
		let f = this.tip.parent.x - tx;
		if((f < 0 ? -f : f) > 5) {
			let _this = this.tip.parent;
			_this.posChanged = true;
			_this.x = tx | 0;
		}
	}
	begin() {
		if(!this.enable) {
			return;
		}
		let t0 = HxOverrides.now() / 1000;
		let ft = (t0 - this.prevFrame) * 1e9;
		let f = ft - this.frameTime;
		if((f < 0 ? -f : f) > this.recalTime) {
			this.frameTime = ft;
		} else {
			this.frameTime = this.frameTime * this.smoothTime + ft * (1 - this.smoothTime);
		}
		this.prevFrame = t0;
		if(this.currentFrame != null) {
			this.end();
		}
		while(this.waitFrames.length > 0) {
			let q = this.waitFrames[0];
			if(!q.isAvailable()) {
				break;
			}
			this.waitFrames.shift();
			let st = this.currentStats;
			while(st != null) {
				let n = st.next;
				st.next = this.cachedStats;
				this.cachedStats = st;
				st = n;
			}
			this.currentStats = null;
			let prev = null;
			let totalTime = 0.;
			while(q != null) {
				if(!this.measureCpu) {
					q.sync();
				}
				if(prev != null) {
					let dt = prev.value - q.value;
					let s = this.allocStat(q.name,dt);
					totalTime += dt;
					s.drawCalls = prev.drawCalls - q.drawCalls;
					if(s.drawCalls < 0) {
						s.drawCalls = 0;
					}
				}
				let n = q.next;
				q.next = this.cachedQueries;
				this.cachedQueries = q;
				prev = q;
				q = n;
			}
			if(this.estimateWait) {
				let waitT = this.frameTime - totalTime;
				if(waitT > 0) {
					if(hxd_Window.getInstance().get_vsync()) {
						let vst = 1e9 / hxd_System.getDefaultFrameRate() - totalTime;
						if(vst > waitT) {
							vst = waitT;
						}
						if(vst > 0) {
							let s = this.allocStat("vsync",vst);
							s.drawCalls = 0;
							waitT -= vst;
						}
					}
					if(waitT > 0.5e6) {
						let s = this.allocStat(this.measureCpu ? "gpuwait" : "cpuwait",waitT);
						s.drawCalls = 0;
					}
				}
			}
		}
		if(this.allocated && this.visible) {
			this.syncVisual();
		}
		this.measure("begin");
	}
	syncVisual() {
		let s2d = this.getScene();
		let old = this.labels;
		this.labels = null;
		this.clear();
		this.labels = old;
		let width = this.width == null ? s2d.width : this.width;
		this.curWidth = width;
		this.beginFill(0,0.5);
		this.drawRect(0,0,width,this.height);
		this.interact.width = width;
		this.interact.height = this.height;
		let totalTime = 0.;
		let s = this.currentStats;
		while(s != null) {
			totalTime += s.time;
			s = s.next;
		}
		width -= 52;
		let count = 0;
		let xPos = 0;
		let curTime = 0.;
		let s1 = this.currentStats;
		while(s1 != null) {
			if(this.colors.length <= count) {
				let color_x = 0.;
				let color_y = 0.;
				let color_z = 0.;
				let color_w = 1.;
				let m = new h3d_Matrix();
				m.identity();
				m.colorHue(count);
				color_x = 0.2;
				color_y = 0.6;
				color_z = 1.;
				color_w = 0.;
				let px = 0.2 * m._11 + 0.6 * m._21 + m._31 + 0. * m._41;
				let py = 0.2 * m._12 + 0.6 * m._22 + m._32 + 0. * m._42;
				let pz = 0.2 * m._13 + 0.6 * m._23 + m._33 + 0. * m._43;
				let pw = 0.2 * m._14 + 0.6 * m._24 + m._34 + 0. * m._44;
				color_x = px;
				color_y = py;
				color_z = pz;
				color_w = pw;
				let f = color_w;
				let f1 = color_x;
				let f2 = color_y;
				let f3 = color_z;
				this.colors.push(((f < 0. ? 0. : f > 1. ? 1. : f) * 255 + 0.499 | 0) << 24 | ((f1 < 0. ? 0. : f1 > 1. ? 1. : f1) * 255 + 0.499 | 0) << 16 | ((f2 < 0. ? 0. : f2 > 1. ? 1. : f2) * 255 + 0.499 | 0) << 8 | ((f3 < 0. ? 0. : f3 > 1. ? 1. : f3) * 255 + 0.499 | 0));
			}
			curTime += s1.time;
			let xEnd = Math.ceil(width * (curTime / totalTime));
			let xSize = xEnd - xPos;
			this.beginFill(this.colors[count]);
			this.drawRect(xPos,0,xSize,this.height);
			let l = this.allocLabel(count);
			if(xSize < s1.name.length * 6) {
				l.set_visible(false);
			} else {
				l.set_visible(true);
				l.set_textColor(this.textColor);
				l.set_text(s1.name);
				let v = xPos + ((xSize - l.get_textWidth()) * .5 | 0);
				l.posChanged = true;
				l.x = v;
			}
			s1.xPos = xPos;
			s1.xSize = xSize;
			if(this.tipCurrent == s1 && this.tipCurName == s1.name) {
				this.syncTip(s1);
			}
			xPos = xEnd;
			++count;
			s1 = s1.next;
		}
		if(this.tip != null && this.tipCurrent == null) {
			this.syncTip(null);
		}
		let time = this.allocLabel(count++);
		time.posChanged = true;
		time.x = xPos + 3;
		time.posChanged = true;
		time.y = -1;
		time.set_visible(true);
		time.set_textColor(16777215);
		let timeMs = totalTime / 1e6;
		time.set_text((timeMs | 0) + "." + (timeMs * 10 % 10 | 0) + (this.measureCpu ? " cpu" : " gpu"));
		while(this.labels.length > count) {
			let _this = this.labels.pop();
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
		}
	}
	allocLabel(index) {
		let l = this.labels[index];
		if(l != null) {
			return l;
		}
		if(this.font == null) {
			this.font = hxd_res_DefaultFont.get();
		}
		l = new h2d_Text(this.font,this);
		this.labels[index] = l;
		return l;
	}
	end() {
		if(!this.enable) {
			return;
		}
		this.measure("end");
		this.waitFrames.push(this.currentFrame);
		this.currentFrame = null;
	}
	allocStat(name,time) {
		let s = this.cachedStats;
		if(s != null) {
			this.cachedStats = s.next;
		} else {
			s = new h3d_impl__$Benchmark_StatsObject();
		}
		if(name == s.name) {
			let f = time - s.time;
			let et = f < 0 ? -f : f;
			if(et > this.recalTime) {
				s.time = time;
			} else {
				s.time = s.time * this.smoothTime + time * (1 - this.smoothTime);
			}
		} else {
			s.name = name;
			s.time = time;
		}
		s.next = this.currentStats;
		this.currentStats = s;
		return s;
	}
	allocQuery() {
		let q = this.cachedQueries;
		if(q != null) {
			this.cachedQueries = q.next;
		} else {
			q = new h3d_impl__$Benchmark_QueryObject();
		}
		return q;
	}
	measure(name) {
		if(!this.enable) {
			return;
		}
		if(this.currentFrame != null && this.currentFrame.name == name) {
			return;
		}
		let q = this.allocQuery();
		q.name = name;
		q.drawCalls = this.engine.drawCalls;
		q.next = this.currentFrame;
		this.currentFrame = q;
		this.engine.driver.endQuery(q.q);
		if(this.measureCpu) {
			q.value = HxOverrides.now() / 1000 * 1e9;
		}
	}
}
$hxClasses["h3d.impl.Benchmark"] = h3d_impl_Benchmark;
h3d_impl_Benchmark.__name__ = "h3d.impl.Benchmark";
h3d_impl_Benchmark.__super__ = h2d_Graphics;
Object.assign(h3d_impl_Benchmark.prototype, {
	__class__: h3d_impl_Benchmark
	,cachedStats: null
	,currentStats: null
	,cachedQueries: null
	,currentFrame: null
	,waitFrames: null
	,engine: null
	,labels: null
	,interact: null
	,estimateWait: null
	,enable: null
	,width: null
	,height: null
	,textColor: null
	,colors: null
	,font: null
	,recalTime: null
	,smoothTime: null
	,measureCpu: null
	,tip: null
	,tipCurrent: null
	,tipCurName: null
	,curWidth: null
	,prevFrame: null
	,frameTime: null
});
var h3d_impl_Feature = $hxEnums["h3d.impl.Feature"] = { __ename__:true,__constructs__:null
	,StandardDerivatives: {_hx_name:"StandardDerivatives",_hx_index:0,__enum__:"h3d.impl.Feature",toString:$estr}
	,FloatTextures: {_hx_name:"FloatTextures",_hx_index:1,__enum__:"h3d.impl.Feature",toString:$estr}
	,AllocDepthBuffer: {_hx_name:"AllocDepthBuffer",_hx_index:2,__enum__:"h3d.impl.Feature",toString:$estr}
	,HardwareAccelerated: {_hx_name:"HardwareAccelerated",_hx_index:3,__enum__:"h3d.impl.Feature",toString:$estr}
	,MultipleRenderTargets: {_hx_name:"MultipleRenderTargets",_hx_index:4,__enum__:"h3d.impl.Feature",toString:$estr}
	,Queries: {_hx_name:"Queries",_hx_index:5,__enum__:"h3d.impl.Feature",toString:$estr}
	,SRGBTextures: {_hx_name:"SRGBTextures",_hx_index:6,__enum__:"h3d.impl.Feature",toString:$estr}
	,ShaderModel3: {_hx_name:"ShaderModel3",_hx_index:7,__enum__:"h3d.impl.Feature",toString:$estr}
	,BottomLeftCoords: {_hx_name:"BottomLeftCoords",_hx_index:8,__enum__:"h3d.impl.Feature",toString:$estr}
	,Wireframe: {_hx_name:"Wireframe",_hx_index:9,__enum__:"h3d.impl.Feature",toString:$estr}
	,InstancedRendering: {_hx_name:"InstancedRendering",_hx_index:10,__enum__:"h3d.impl.Feature",toString:$estr}
};
h3d_impl_Feature.__constructs__ = [h3d_impl_Feature.StandardDerivatives,h3d_impl_Feature.FloatTextures,h3d_impl_Feature.AllocDepthBuffer,h3d_impl_Feature.HardwareAccelerated,h3d_impl_Feature.MultipleRenderTargets,h3d_impl_Feature.Queries,h3d_impl_Feature.SRGBTextures,h3d_impl_Feature.ShaderModel3,h3d_impl_Feature.BottomLeftCoords,h3d_impl_Feature.Wireframe,h3d_impl_Feature.InstancedRendering];
h3d_impl_Feature.__empty_constructs__ = [h3d_impl_Feature.StandardDerivatives,h3d_impl_Feature.FloatTextures,h3d_impl_Feature.AllocDepthBuffer,h3d_impl_Feature.HardwareAccelerated,h3d_impl_Feature.MultipleRenderTargets,h3d_impl_Feature.Queries,h3d_impl_Feature.SRGBTextures,h3d_impl_Feature.ShaderModel3,h3d_impl_Feature.BottomLeftCoords,h3d_impl_Feature.Wireframe,h3d_impl_Feature.InstancedRendering];
var h3d_impl_QueryKind = $hxEnums["h3d.impl.QueryKind"] = { __ename__:true,__constructs__:null
	,TimeStamp: {_hx_name:"TimeStamp",_hx_index:0,__enum__:"h3d.impl.QueryKind",toString:$estr}
	,Samples: {_hx_name:"Samples",_hx_index:1,__enum__:"h3d.impl.QueryKind",toString:$estr}
};
h3d_impl_QueryKind.__constructs__ = [h3d_impl_QueryKind.TimeStamp,h3d_impl_QueryKind.Samples];
h3d_impl_QueryKind.__empty_constructs__ = [h3d_impl_QueryKind.TimeStamp,h3d_impl_QueryKind.Samples];
var h3d_impl_RenderFlag = $hxEnums["h3d.impl.RenderFlag"] = { __ename__:true,__constructs__:null
	,CameraHandness: {_hx_name:"CameraHandness",_hx_index:0,__enum__:"h3d.impl.RenderFlag",toString:$estr}
};
h3d_impl_RenderFlag.__constructs__ = [h3d_impl_RenderFlag.CameraHandness];
h3d_impl_RenderFlag.__empty_constructs__ = [h3d_impl_RenderFlag.CameraHandness];
class h3d_impl_InputNames {
	constructor(names) {
		this.id = h3d_impl_InputNames.UID++;
		this.names = names;
	}
	static get(names) {
		let key = names.join("|");
		let i = h3d_impl_InputNames.CACHE.h[key];
		if(i == null) {
			i = new h3d_impl_InputNames(names.slice());
			h3d_impl_InputNames.CACHE.h[key] = i;
		}
		return i;
	}
}
$hxClasses["h3d.impl.InputNames"] = h3d_impl_InputNames;
h3d_impl_InputNames.__name__ = "h3d.impl.InputNames";
Object.assign(h3d_impl_InputNames.prototype, {
	__class__: h3d_impl_InputNames
	,id: null
	,names: null
});
class h3d_impl_Driver {
	hasFeature(f) {
		return false;
	}
	setRenderFlag(r,value) {
	}
	isSupportedFormat(fmt) {
		return false;
	}
	isDisposed() {
		return true;
	}
	begin(frame) {
	}
	generateMipMaps(texture) {
		throw haxe_Exception.thrown("Mipmaps auto generation is not supported on this platform");
	}
	clear(color,depth,stencil) {
	}
	capturePixels(tex,layer,mipLevel,region) {
		throw haxe_Exception.thrown("Can't capture pixels on this platform");
	}
	init(onCreate,forceSoftware) {
		if(forceSoftware == null) {
			forceSoftware = false;
		}
	}
	resize(width,height) {
	}
	selectShader(shader) {
		return false;
	}
	selectMaterial(pass) {
	}
	uploadShaderBuffers(buffers,which) {
	}
	getShaderInputNames() {
		return null;
	}
	selectBuffer(buffer) {
	}
	selectMultiBuffers(buffers) {
	}
	draw(ibuf,startIndex,ntriangles) {
	}
	drawInstanced(ibuf,commands) {
	}
	setRenderZone(x,y,width,height) {
	}
	setRenderTarget(tex,layer,mipLevel) {
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(layer == null) {
			layer = 0;
		}
	}
	setRenderTargets(textures) {
	}
	allocDepthBuffer(b) {
		return null;
	}
	disposeDepthBuffer(b) {
	}
	getDefaultDepthBuffer() {
		return null;
	}
	end() {
	}
	setDebug(b) {
	}
	allocTexture(t) {
		return null;
	}
	allocIndexes(count,is32) {
		return null;
	}
	allocVertexes(m) {
		return null;
	}
	allocInstanceBuffer(b,bytes) {
	}
	disposeTexture(t) {
	}
	disposeIndexes(i) {
	}
	disposeVertexes(v) {
	}
	disposeInstanceBuffer(b) {
	}
	uploadIndexBuffer(i,startIndice,indiceCount,buf,bufPos) {
	}
	uploadVertexBuffer(v,startVertex,vertexCount,buf,bufPos) {
	}
	uploadVertexBytes(v,startVertex,vertexCount,buf,bufPos) {
	}
	uploadTextureBitmap(t,bmp,mipLevel,side) {
	}
	uploadTexturePixels(t,pixels,mipLevel,side) {
	}
	copyTexture(from,to) {
		return false;
	}
	allocQuery(queryKind) {
		return null;
	}
	deleteQuery(q) {
	}
	endQuery(q) {
	}
	queryResultAvailable(q) {
		return true;
	}
	queryResult(q) {
		return 0.;
	}
}
$hxClasses["h3d.impl.Driver"] = h3d_impl_Driver;
h3d_impl_Driver.__name__ = "h3d.impl.Driver";
Object.assign(h3d_impl_Driver.prototype, {
	__class__: h3d_impl_Driver
});
class h3d_impl__$GlDriver_CompiledShader {
	constructor(s,vertex,shader) {
		this.s = s;
		this.vertex = vertex;
		this.shader = shader;
	}
}
$hxClasses["h3d.impl._GlDriver.CompiledShader"] = h3d_impl__$GlDriver_CompiledShader;
h3d_impl__$GlDriver_CompiledShader.__name__ = "h3d.impl._GlDriver.CompiledShader";
Object.assign(h3d_impl__$GlDriver_CompiledShader.prototype, {
	__class__: h3d_impl__$GlDriver_CompiledShader
	,s: null
	,vertex: null
	,globals: null
	,params: null
	,textures: null
	,buffers: null
	,shader: null
});
class h3d_impl__$GlDriver_CompiledAttribute {
	constructor() {
	}
}
$hxClasses["h3d.impl._GlDriver.CompiledAttribute"] = h3d_impl__$GlDriver_CompiledAttribute;
h3d_impl__$GlDriver_CompiledAttribute.__name__ = "h3d.impl._GlDriver.CompiledAttribute";
Object.assign(h3d_impl__$GlDriver_CompiledAttribute.prototype, {
	__class__: h3d_impl__$GlDriver_CompiledAttribute
	,index: null
	,type: null
	,size: null
	,offset: null
	,divisor: null
});
class h3d_impl__$GlDriver_CompiledProgram {
	constructor() {
	}
}
$hxClasses["h3d.impl._GlDriver.CompiledProgram"] = h3d_impl__$GlDriver_CompiledProgram;
h3d_impl__$GlDriver_CompiledProgram.__name__ = "h3d.impl._GlDriver.CompiledProgram";
Object.assign(h3d_impl__$GlDriver_CompiledProgram.prototype, {
	__class__: h3d_impl__$GlDriver_CompiledProgram
	,p: null
	,vertex: null
	,fragment: null
	,stride: null
	,inputs: null
	,attribs: null
	,hasAttribIndex: null
});
class h3d_impl_GlDriver extends h3d_impl_Driver {
	constructor(antiAlias) {
		if(antiAlias == null) {
			antiAlias = 0;
		}
		super();
		this.features = new haxe_ds_EnumValueMap();
		this.maxCompressedTexturesSupport = 0;
		this.rightHanded = false;
		this.firstShader = true;
		this.boundTextures = [];
		this.curTargets = [];
		let _g = [];
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		_g.push(0);
		this.currentDivisor = _g;
		this.curColorMask = -1;
		this.lastActiveIndex = 0;
		this.curStEnabled = false;
		this.curStMaskBits = -1;
		this.curStOpBits = -1;
		this.curMatBits = -1;
		this.maxIdxCurAttribs = 0;
		this.curAttribs = [];
		this.canvas = hxd_Window.getInstance().canvas;
		let options = { alpha : false, stencil : true, antialias : antiAlias > 0};
		if(h3d_impl_GlDriver.ALLOW_WEBGL2) {
			this.gl = this.canvas.getContext("webgl2",options);
		}
		if(this.gl == null) {
			this.gl = js_html__$CanvasElement_CanvasUtil.getContextWebGL(this.canvas,options);
		}
		if(this.gl == null) {
			throw haxe_Exception.thrown("Could not acquire GL context");
		}
		if(typeof(WebGLDebugUtils) != "undefined") {
			this.gl = WebGLDebugUtils.makeDebugContext(this.gl);
			this.glDebug = true;
		}
		this.commonFB = this.gl.createFramebuffer();
		this.programs = new haxe_ds_IntMap();
		this.defStencil = new h3d_mat_Stencil();
		this.frame = hxd_Timer.frameCount;
		let v = this.gl.getParameter(7938);
		let reg = new EReg("ES ([0-9]+\\.[0-9]+)","");
		if(reg.match(v)) {
			this.glES = parseFloat(reg.matched(1));
		}
		let reg1 = new EReg("[0-9]+\\.[0-9]+","");
		let v1 = this.gl.getParameter(35724);
		if(reg1.match(v1)) {
			this.glES = parseFloat(reg1.matched(0));
			this.shaderVersion = Math.round(parseFloat(reg1.matched(0)) * 100);
		}
		this.drawMode = 4;
		this.makeFeatures();
		if(this.hasFeature(h3d_impl_Feature.InstancedRendering) && this.glES < 3) {
			let extension = this.gl.getExtension("ANGLE_instanced_arrays");
			this.gl["vertexAttribDivisor"] = $bind(extension,extension.vertexAttribDivisorANGLE);
			this.gl["drawElementsInstanced"] = $bind(extension,extension.drawElementsInstancedANGLE);
		}
		hxsl_SharedShader.UNROLL_LOOPS = !this.hasFeature(h3d_impl_Feature.ShaderModel3);
		this.gl.pixelStorei(3333,1);
		this.gl.pixelStorei(3317,1);
	}
	setRenderFlag(r,value) {
		this.rightHanded = value > 0;
	}
	setDebug(d) {
		this.debug = d;
	}
	begin(frame) {
		this.frame = frame;
		this.resetStream();
		this.gl.useProgram(null);
		this.curShader = null;
		this.curBuffer = null;
	}
	getShaderInputNames() {
		return this.curShader.inputs;
	}
	makeCompiler() {
		let glout = new hxsl_GlslOut();
		glout.glES = this.glES;
		glout.version = this.shaderVersion;
		glout.intelDriverFix = this.isIntelGpu;
		return glout;
	}
	getDriverName(details) {
		let render = this.gl.getParameter(7937);
		if(details) {
			render += " GLv" + Std.string(this.gl.getParameter(7938));
		} else {
			render = render.split("/").shift();
		}
		render = render.split("WebGL ").join("");
		return "OpenGL " + render;
	}
	compileShader(glout,shader) {
		let type = shader.vertex ? 35633 : 35632;
		let s = this.gl.createShader(type);
		if(shader.code == null) {
			shader.code = glout.run(shader.data);
			shader.data.funs = null;
		}
		this.gl.shaderSource(s,shader.code);
		this.gl.compileShader(s);
		this.gl.getShaderInfoLog(s);
		if(this.gl.getShaderParameter(s,35713) != 1) {
			let log = this.gl.getShaderInfoLog(s);
			let lid = Std.parseInt(HxOverrides.substr(log,9,null));
			let line = lid == null ? null : shader.code.split("\n")[lid - 1];
			if(line == null) {
				line = "";
			} else {
				line = "(" + StringTools.trim(line) + ")";
			}
			let codeLines = shader.code.split("\n");
			let _g = 0;
			let _g1 = codeLines.length;
			while(_g < _g1) {
				let i = _g++;
				codeLines[i] = i + 1 + "\t" + codeLines[i];
			}
			throw haxe_Exception.thrown("An error occurred compiling the shaders: " + log + line + "\n\n" + codeLines.join("\n"));
		}
		return new h3d_impl__$GlDriver_CompiledShader(s,shader.vertex,shader);
	}
	initShader(p,s,shader,rt) {
		let prefix = s.vertex ? "vertex" : "fragment";
		s.globals = this.gl.getUniformLocation(p.p,prefix + "Globals");
		s.params = this.gl.getUniformLocation(p.p,prefix + "Params");
		s.textures = [];
		let index = 0;
		let curT = null;
		let mode = 0;
		let name = "";
		let t = shader.textures;
		while(t != null) {
			let tt = t.type;
			let count = 1;
			switch(tt._hx_index) {
			case 15:
				let _g = tt.size;
				if(_g._hx_index == 0) {
					tt = tt.t;
					count = _g.v;
				}
				break;
			case 17:
				tt = hxsl_Type.TSampler2D;
				break;
			default:
			}
			if(tt != curT) {
				curT = tt;
				switch(tt._hx_index) {
				case 10:
					mode = 3553;
					name = "Textures";
					break;
				case 11:
					mode = 35866;
					name = "TexturesArray";
					break;
				case 12:
					mode = 34067;
					name = "TexturesCube";
					break;
				default:
					throw haxe_Exception.thrown("Unsupported texture type " + Std.string(tt));
				}
				index = 0;
			}
			let _g1 = 0;
			let _g2 = count;
			while(_g1 < _g2) {
				++_g1;
				let loc = this.gl.getUniformLocation(p.p,prefix + name + "[" + index + "]");
				if(loc == null) {
					throw haxe_Exception.thrown("Texture " + rt.spec.instances[t.instance].shader.data.name + "." + t.name + " is missing from generated shader");
				}
				s.textures.push({ u : loc, t : curT, mode : mode});
				++index;
			}
			t = t.next;
		}
		if(shader.bufferCount > 0) {
			let _g = [];
			let _g1 = 0;
			let _g2 = shader.bufferCount;
			while(_g1 < _g2) {
				let i = _g1++;
				_g.push(this.gl.getUniformBlockIndex(p.p,(shader.vertex ? "vertex_" : "") + "uniform_buffer" + i));
			}
			s.buffers = _g;
			let start = 0;
			if(!s.vertex) {
				start = rt.vertex.bufferCount;
			}
			let _g3 = 0;
			let _g4 = shader.bufferCount;
			while(_g3 < _g4) {
				let i = _g3++;
				this.gl.uniformBlockBinding(p.p,s.buffers[i],i + start);
			}
		}
	}
	selectShader(shader) {
		let p = this.programs.h[shader.id];
		if(p == null) {
			p = new h3d_impl__$GlDriver_CompiledProgram();
			let glout = this.makeCompiler();
			p.vertex = this.compileShader(glout,shader.vertex);
			p.fragment = this.compileShader(glout,shader.fragment);
			p.p = this.gl.createProgram();
			this.gl.attachShader(p.p,p.vertex.s);
			this.gl.attachShader(p.p,p.fragment.s);
			let log = null;
			try {
				this.gl.linkProgram(p.p);
				if(this.gl.getProgramParameter(p.p,35714) != 1) {
					log = this.gl.getProgramInfoLog(p.p);
				}
			} catch( _g ) {
				throw haxe_Exception.thrown("Shader linkage error: " + Std.string(haxe_Exception.caught(_g).unwrap()) + " (" + this.getDriverName(false) + ")");
			}
			this.gl.deleteShader(p.vertex.s);
			this.gl.deleteShader(p.fragment.s);
			if(log != null) {
				this.gl.deleteProgram(p.p);
				throw haxe_Exception.thrown("Program linkage failure: " + log + "\nVertex=\n" + shader.vertex.code + "\n\nFragment=\n" + shader.fragment.code);
			}
			this.firstShader = false;
			this.initShader(p,p.vertex,shader.vertex,shader);
			this.initShader(p,p.fragment,shader.fragment,shader);
			let attribNames = [];
			p.attribs = [];
			p.hasAttribIndex = [];
			p.stride = 0;
			let _g = 0;
			let _g1 = shader.vertex.data.vars;
			while(_g < _g1.length) {
				let v = _g1[_g];
				++_g;
				if(v.kind._hx_index == 1) {
					let t = 5126;
					let size;
					let _g = v.type;
					switch(_g._hx_index) {
					case 3:
						size = 1;
						break;
					case 5:
						size = _g.size;
						break;
					case 9:
						t = 5120;
						size = _g.size;
						break;
					default:
						throw haxe_Exception.thrown("assert " + Std.string(v.type));
					}
					let index = this.gl.getAttribLocation(p.p,glout.varNames.h.hasOwnProperty(v.id) ? glout.varNames.h[v.id] : v.name);
					if(index < 0) {
						p.stride += size;
						continue;
					}
					let a = new h3d_impl__$GlDriver_CompiledAttribute();
					a.type = t;
					a.size = size;
					a.index = index;
					a.offset = p.stride;
					a.divisor = 0;
					if(v.qualifiers != null) {
						let _g = 0;
						let _g1 = v.qualifiers;
						while(_g < _g1.length) {
							let q = _g1[_g];
							++_g;
							if(q._hx_index == 9) {
								a.divisor = q.v;
							}
						}
					}
					p.attribs.push(a);
					p.hasAttribIndex[a.index] = true;
					attribNames.push(v.name);
					p.stride += size;
				}
			}
			p.inputs = h3d_impl_InputNames.get(attribNames);
			this.programs.h[shader.id] = p;
		}
		if(this.curShader == p) {
			return false;
		}
		this.setProgram(p);
		return true;
	}
	setProgram(p) {
		this.gl.useProgram(p.p);
		let _g = 0;
		let _g1 = p.attribs;
		while(_g < _g1.length) {
			let a = _g1[_g];
			++_g;
			if(!this.curAttribs[a.index]) {
				this.gl.enableVertexAttribArray(a.index);
				this.curAttribs[a.index] = true;
				if(this.maxIdxCurAttribs < a.index) {
					this.maxIdxCurAttribs = a.index;
				}
			}
		}
		let lastIdxCurAttribTrue = 0;
		let _g2 = 0;
		let _g3 = this.maxIdxCurAttribs + 1;
		while(_g2 < _g3) {
			let i = _g2++;
			if(this.curAttribs[i] && !p.hasAttribIndex[i]) {
				this.gl.disableVertexAttribArray(i);
				this.curAttribs[i] = false;
			} else if(this.curAttribs[i]) {
				lastIdxCurAttribTrue = i;
			}
		}
		this.maxIdxCurAttribs = lastIdxCurAttribTrue;
		this.curShader = p;
		this.curBuffer = null;
		let _g4 = 0;
		let _g5 = this.boundTextures.length;
		while(_g4 < _g5) {
			let i = _g4++;
			this.boundTextures[i] = null;
		}
	}
	uploadShaderBuffers(buf,which) {
		this.uploadBuffer(buf,this.curShader.vertex,buf.vertex,which);
		this.uploadBuffer(buf,this.curShader.fragment,buf.fragment,which);
	}
	uploadBuffer(buffer,s,buf,which) {
		switch(which) {
		case 0:
			if(s.globals != null) {
				let a = buf.globals.subarray(0,s.shader.globalsSize * 4);
				this.gl.uniform4fv(s.globals,a);
			}
			break;
		case 1:
			if(s.params != null) {
				let a = buf.params.subarray(0,s.shader.paramsSize * 4);
				this.gl.uniform4fv(s.params,a);
			}
			break;
		case 2:
			let _g = 0;
			let _g1 = s.textures.length;
			while(_g < _g1) {
				let i = _g++;
				let t = buf.tex[i];
				let pt = s.textures[i];
				if(t == null || t.t == null && t.realloc == null) {
					switch(pt.t._hx_index) {
					case 10:
						let color = h3d_mat_Defaults.loadingTextureColor;
						t = h3d_mat_Texture.fromColor(color,(color >>> 24) / 255);
						break;
					case 12:
						t = h3d_mat_Texture.defaultCubeTexture();
						break;
					default:
						throw haxe_Exception.thrown("Missing texture");
					}
				}
				if(t != null && t.t == null && t.realloc != null) {
					let s = this.curShader;
					t.alloc();
					t.realloc();
					if(this.curShader != s) {
						this.setProgram(s);
						this.uploadShaderBuffers(buffer,0);
						this.uploadShaderBuffers(buffer,1);
						this.uploadShaderBuffers(buffer,2);
						return;
					}
				}
				t.set_lastFrame(this.frame);
				if(pt.u == null) {
					continue;
				}
				let idx = s.vertex ? i : this.curShader.vertex.textures.length + i;
				if(this.boundTextures[idx] != t.t) {
					this.boundTextures[idx] = t.t;
					let mode = this.getBindType(t);
					if(mode != pt.mode) {
						throw haxe_Exception.thrown("Texture format mismatch: " + Std.string(t) + " should be " + Std.string(pt.t));
					}
					this.gl.activeTexture(33984 + idx);
					this.gl.uniform1i(pt.u,idx);
					this.gl.bindTexture(mode,t.t.t);
					this.lastActiveIndex = idx;
				}
				let mip = t.mipMap._hx_index;
				let filter = t.filter._hx_index;
				let wrap = t.wrap._hx_index;
				let bits = mip | filter << 3 | wrap << 6;
				if(bits != t.t.bits) {
					t.t.bits = bits;
					let flags = h3d_impl_GlDriver.TFILTERS[mip][filter];
					let mode = pt.mode;
					this.gl.texParameteri(mode,10240,flags[0]);
					this.gl.texParameteri(mode,10241,flags[1]);
					let w = h3d_impl_GlDriver.TWRAP[wrap];
					this.gl.texParameteri(mode,10242,w);
					this.gl.texParameteri(mode,10243,w);
				}
			}
			break;
		case 3:
			if(s.buffers != null) {
				let start = 0;
				if(!s.vertex && this.curShader.vertex.buffers != null) {
					start = this.curShader.vertex.buffers.length;
				}
				let _g = 0;
				let _g1 = s.buffers.length;
				while(_g < _g1) {
					let i = _g++;
					this.gl.bindBufferBase(35345,i + start,buf.buffers[i].buffer.vbuf.b);
				}
			}
			break;
		}
	}
	selectMaterial(pass) {
		let bits = pass.bits;
		if(this.curTarget == null == this.rightHanded) {
			switch(pass.culling._hx_index) {
			case 1:
				bits = bits & -4 | 2;
				break;
			case 2:
				bits = bits & -4 | 1;
				break;
			default:
			}
		}
		this.selectMaterialBits(bits);
		if(this.curColorMask != pass.colorMask) {
			let m = pass.colorMask;
			this.gl.colorMask((m & 1) != 0,(m & 2) != 0,(m & 4) != 0,(m & 8) != 0);
			this.curColorMask = m;
		}
		let s = this.defStencil;
		if(pass.stencil == null) {
			if(this.curStEnabled) {
				this.gl.disable(2960);
				this.curStEnabled = false;
			}
		} else {
			s = pass.stencil;
			if(!this.curStEnabled) {
				this.gl.enable(2960);
				this.curStEnabled = true;
			}
		}
		this.selectStencilBits(s.opBits,s.maskBits);
	}
	selectMaterialBits(bits) {
		let diff = bits ^ this.curMatBits;
		if(this.curMatBits < 0) {
			diff = -1;
		}
		if(diff == 0) {
			return;
		}
		let wireframe = (bits & 268435456) != 0;
		this.drawMode = wireframe ? 3 : 4;
		if((diff & 3) != 0) {
			let cull = bits & 3;
			if(cull == 0) {
				this.gl.disable(2884);
			} else {
				if(this.curMatBits < 0 || (this.curMatBits & 3) == 0) {
					this.gl.enable(2884);
				}
				this.gl.cullFace(h3d_impl_GlDriver.FACES[cull]);
			}
		}
		if((diff & 4194240) != 0) {
			let csrc = bits >> 6 & 15;
			let cdst = bits >> 10 & 15;
			let asrc = bits >> 14 & 15;
			let adst = bits >> 18 & 15;
			if(csrc == asrc && cdst == adst) {
				if(csrc == 0 && cdst == 1) {
					this.gl.disable(3042);
				} else {
					if(this.curMatBits < 0 || (this.curMatBits >> 6 & 15) == 0 && (this.curMatBits >> 10 & 15) == 1) {
						this.gl.enable(3042);
					}
					this.gl.blendFunc(h3d_impl_GlDriver.BLEND[csrc],h3d_impl_GlDriver.BLEND[cdst]);
				}
			} else {
				if(this.curMatBits < 0 || (this.curMatBits >> 6 & 15) == 0 && (this.curMatBits >> 10 & 15) == 1) {
					this.gl.enable(3042);
				}
				this.gl.blendFuncSeparate(h3d_impl_GlDriver.BLEND[csrc],h3d_impl_GlDriver.BLEND[cdst],h3d_impl_GlDriver.BLEND[asrc],h3d_impl_GlDriver.BLEND[adst]);
			}
		}
		if((diff & 264241152) != 0) {
			let cop = bits >> 22 & 7;
			let aop = bits >> 25 & 7;
			if(cop == aop) {
				this.gl.blendEquation(h3d_impl_GlDriver.OP[cop]);
			} else {
				this.gl.blendEquationSeparate(h3d_impl_GlDriver.OP[cop],h3d_impl_GlDriver.OP[aop]);
			}
		}
		if((diff & 4) != 0) {
			this.gl.depthMask((bits >> 2 & 1) != 0);
		}
		if((diff & 56) != 0) {
			let cmp = bits >> 3 & 7;
			if(cmp == 0) {
				this.gl.disable(2929);
			} else {
				if(this.curMatBits < 0 || (this.curMatBits >> 3 & 7) == 0) {
					this.gl.enable(2929);
				}
				this.gl.depthFunc(h3d_impl_GlDriver.COMPARE[cmp]);
			}
		}
		this.curMatBits = bits;
	}
	selectStencilBits(opBits,maskBits) {
		let diffOp = opBits ^ this.curStOpBits;
		let diffMask = maskBits ^ this.curStMaskBits;
		if((diffOp | diffMask) == 0) {
			return;
		}
		if((diffOp & 4088) != 0) {
			this.gl.stencilOpSeparate(h3d_impl_GlDriver.FACES[2],h3d_impl_GlDriver.STENCIL_OP[opBits >> 6 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 9 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 3 & 7]);
		}
		if((diffOp & 16744448) != 0) {
			this.gl.stencilOpSeparate(h3d_impl_GlDriver.FACES[1],h3d_impl_GlDriver.STENCIL_OP[opBits >> 18 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 21 & 7],h3d_impl_GlDriver.STENCIL_OP[opBits >> 15 & 7]);
		}
		if((diffOp & 7 | diffMask & 16711935) != 0) {
			this.gl.stencilFuncSeparate(h3d_impl_GlDriver.FACES[2],h3d_impl_GlDriver.COMPARE[opBits & 7],maskBits >> 16 & 255,maskBits & 255);
		}
		if((diffOp & 28672 | diffMask & 16711935) != 0) {
			this.gl.stencilFuncSeparate(h3d_impl_GlDriver.FACES[1],h3d_impl_GlDriver.COMPARE[opBits >> 12 & 7],maskBits >> 16 & 255,maskBits & 255);
		}
		if((diffMask & 65280) != 0) {
			let w = maskBits >> 8 & 255;
			this.gl.stencilMaskSeparate(h3d_impl_GlDriver.FACES[2],w);
			this.gl.stencilMaskSeparate(h3d_impl_GlDriver.FACES[1],w);
		}
		this.curStOpBits = opBits;
		this.curStMaskBits = maskBits;
	}
	clear(color,depth,stencil) {
		let bits = 0;
		if(color != null) {
			this.gl.colorMask(true,true,true,true);
			this.curColorMask = 15;
			this.gl.clearColor(color.x,color.y,color.z,color.w);
			bits = 16384;
		}
		if(depth != null) {
			this.gl.depthMask(true);
			if(this.curMatBits >= 0) {
				this.curMatBits |= 4;
			}
			this.gl.clearDepth(depth);
			bits |= 256;
		}
		if(stencil != null) {
			this.selectStencilBits(this.defStencil.opBits,this.defStencil.maskBits);
			this.gl.clearStencil(stencil);
			bits |= 1024;
		}
		if(bits != 0) {
			this.gl.clear(bits);
		}
		if(this.curTarget != null) {
			this.curTarget.flags |= 256;
		}
	}
	resize(width,height) {
		if(this.canvas.style.width == "") {
			let tmp = width / window.devicePixelRatio | 0;
			this.canvas.style.width = tmp + "px";
			let tmp1 = height / window.devicePixelRatio | 0;
			this.canvas.style.height = tmp1 + "px";
		}
		this.canvas.width = width;
		this.canvas.height = height;
		this.bufferWidth = width;
		this.bufferHeight = height;
		this.gl.viewport(0,0,width,height);
		if(this.defaultDepth != null) {
			this.disposeDepthBuffer(this.defaultDepth);
			this.defaultDepth.width = this.bufferWidth;
			this.defaultDepth.height = this.bufferHeight;
			this.defaultDepth.b = this.allocDepthBuffer(this.defaultDepth);
		}
	}
	getChannels(t) {
		switch(t.internalFmt) {
		case 6407:
			return 6407;
		case 6408:
			return 6408;
		case 32857:
			return 6408;
		case 6403:case 33321:case 33325:case 33326:
			return 6403;
		case 33319:case 33323:case 33327:case 33328:
			return 33319;
		case 33777:case 33778:case 33779:
			return 6408;
		case 34837:case 34843:
			return 6407;
		case 34836:case 34842:
			return 6408;
		case 35898:
			return 6407;
		case 35904:case 35905:
			return 6407;
		default:
			throw haxe_Exception.thrown("Invalid format " + t.internalFmt);
		}
	}
	isSupportedFormat(fmt) {
		switch(fmt._hx_index) {
		case 2:
			return true;
		case 3:case 4:
			return this.hasFeature(h3d_impl_Feature.FloatTextures);
		case 14:case 15:
			return this.hasFeature(h3d_impl_Feature.SRGBTextures);
		case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 16:case 17:
			return this.glES >= 3;
		case 21:
			return fmt.v <= this.maxCompressedTexturesSupport;
		default:
			return false;
		}
	}
	getBindType(t) {
		let isCube = (t.flags & 2) != 0;
		let isArray = (t.flags & 2048) != 0;
		if(isCube) {
			return 34067;
		} else if(isArray) {
			return 35866;
		} else {
			return 3553;
		}
	}
	allocTexture(t) {
		if(h3d_impl_GlDriver.outOfMemoryCheck) {
			this.gl.getError();
		}
		let tt = this.gl.createTexture();
		let bind = this.getBindType(t);
		let tt1 = { t : tt, width : t.width, height : t.height, internalFmt : 6408, pixelFmt : 5121, bits : -1, bind : bind, bias : 0};
		let _g = t.format;
		switch(_g._hx_index) {
		case 1:
			tt1.internalFmt = 32856;
			break;
		case 2:
			break;
		case 3:
			if(this.hasFeature(h3d_impl_Feature.FloatTextures)) {
				tt1.pixelFmt = 5131;
				tt1.internalFmt = 34842;
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
			}
			break;
		case 4:
			if(this.hasFeature(h3d_impl_Feature.FloatTextures)) {
				tt1.internalFmt = 34836;
				tt1.pixelFmt = 5126;
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
			}
			break;
		case 5:
			tt1.internalFmt = 33321;
			break;
		case 6:
			tt1.internalFmt = 33325;
			tt1.pixelFmt = 5131;
			break;
		case 7:
			tt1.internalFmt = 33326;
			tt1.pixelFmt = 5126;
			break;
		case 8:
			tt1.internalFmt = 33323;
			break;
		case 9:
			tt1.internalFmt = 33327;
			tt1.pixelFmt = 5131;
			break;
		case 10:
			tt1.internalFmt = 33328;
			tt1.pixelFmt = 5126;
			break;
		case 11:
			tt1.internalFmt = 6407;
			break;
		case 12:
			tt1.internalFmt = 34843;
			tt1.pixelFmt = 5131;
			break;
		case 13:
			tt1.internalFmt = 34837;
			tt1.pixelFmt = 5126;
			break;
		case 14:
			tt1.internalFmt = 35905;
			break;
		case 16:
			tt1.internalFmt = 32857;
			tt1.pixelFmt = 33640;
			break;
		case 17:
			tt1.internalFmt = 35898;
			tt1.pixelFmt = 35899;
			break;
		case 21:
			let _g1 = _g.v;
			if(_g1 <= this.maxCompressedTexturesSupport) {
				if((t.width & 3) != 0 || (t.height & 3) != 0) {
					throw haxe_Exception.thrown("Compressed texture " + Std.string(t) + " has size " + t.width + "x" + t.height + " - must be a multiple of 4");
				}
				switch(_g1) {
				case 1:
					tt1.internalFmt = 33777;
					break;
				case 2:
					tt1.internalFmt = 33778;
					break;
				case 3:
					tt1.internalFmt = 33779;
					break;
				default:
					throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
				}
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
			}
			break;
		default:
			throw haxe_Exception.thrown("Unsupported texture format " + Std.string(t.format));
		}
		t.set_lastFrame(this.frame);
		t.flags &= -257;
		this.gl.bindTexture(bind,tt1.t);
		let outOfMem = false;
		let _g2 = 0;
		let _g3 = t.get_mipLevels();
		while(_g2 < _g3) {
			let mip = _g2++;
			let b = tt1.width >> mip;
			let w = 1 < b ? b : 1;
			let b1 = tt1.height >> mip;
			let h = 1 < b1 ? b1 : 1;
			if((t.flags & 2) != 0) {
				let _g = 0;
				while(_g < 6) {
					let i = _g++;
					this.gl.texImage2D(h3d_impl_GlDriver.CUBE_FACES[i],mip,tt1.internalFmt,w,h,0,this.getChannels(tt1),tt1.pixelFmt,null);
					let tmp;
					if(!h3d_impl_GlDriver.outOfMemoryCheck) {
						tmp = false;
					} else {
						let err = this.gl.getError();
						if(err == 1285) {
							outOfMem = true;
							tmp = true;
						} else {
							if(err != 0) {
								throw haxe_Exception.thrown("Failed to alloc texture " + Std.string(t.format) + "(error " + err + ")");
							}
							tmp = false;
						}
					}
					if(tmp) {
						break;
					}
				}
			} else if((t.flags & 2048) != 0) {
				this.gl.texImage3D(bind,mip,tt1.internalFmt,w,h,t.get_layerCount(),0,this.getChannels(tt1),tt1.pixelFmt,null);
				if(h3d_impl_GlDriver.outOfMemoryCheck) {
					let err = this.gl.getError();
					if(err == 1285) {
						outOfMem = true;
					} else if(err != 0) {
						throw haxe_Exception.thrown("Failed to alloc texture " + Std.string(t.format) + "(error " + err + ")");
					}
				}
			} else {
				if(t.format._hx_index != 21) {
					this.gl.texImage2D(bind,mip,tt1.internalFmt,w,h,0,this.getChannels(tt1),tt1.pixelFmt,null);
				}
				if(h3d_impl_GlDriver.outOfMemoryCheck) {
					let err = this.gl.getError();
					if(err == 1285) {
						outOfMem = true;
					} else if(err != 0) {
						throw haxe_Exception.thrown("Failed to alloc texture " + Std.string(t.format) + "(error " + err + ")");
					}
				}
			}
		}
		this.restoreBind();
		if(outOfMem) {
			this.gl.deleteTexture(tt1.t);
			return null;
		}
		return tt1;
	}
	restoreBind() {
		let t = this.boundTextures[this.lastActiveIndex];
		if(t == null) {
			this.gl.bindTexture(3553,null);
		} else {
			this.gl.bindTexture(t.bind,t.t);
		}
	}
	allocDepthBuffer(b) {
		let r = this.gl.createRenderbuffer();
		if(b.format == null) {
			b.format = this.glES >= 3 ? h3d_mat_DepthFormat.Depth24Stencil8 : h3d_mat_DepthFormat.Depth16;
		}
		let format;
		switch(b.format._hx_index) {
		case 0:
			format = 33189;
			break;
		case 1:
			if(this.glES >= 3) {
				format = 33190;
			} else {
				throw haxe_Exception.thrown("Unsupported depth format " + Std.string(b.format));
			}
			break;
		case 2:
			format = 35056;
			break;
		default:
			throw haxe_Exception.thrown("Unsupported depth format " + Std.string(b.format));
		}
		this.gl.bindRenderbuffer(36161,r);
		this.gl.renderbufferStorage(36161,format,b.width,b.height);
		this.gl.bindRenderbuffer(36161,null);
		return { r : r};
	}
	disposeDepthBuffer(b) {
		if(b.b != null && b.b.r != null) {
			this.gl.deleteRenderbuffer(b.b.r);
			b.b = null;
		}
	}
	getDefaultDepthBuffer() {
		if(this.defaultDepth != null) {
			return this.defaultDepth;
		}
		this.defaultDepth = new h3d_mat_DepthBuffer(0,0);
		this.defaultDepth.width = this.bufferWidth;
		this.defaultDepth.height = this.bufferHeight;
		this.defaultDepth.b = this.allocDepthBuffer(this.defaultDepth);
		return this.defaultDepth;
	}
	allocVertexes(m) {
		if(h3d_impl_GlDriver.outOfMemoryCheck) {
			this.gl.getError();
		}
		let b = this.gl.createBuffer();
		this.gl.bindBuffer(34962,b);
		if(m.size * m.stride == 0) {
			throw haxe_Exception.thrown("assert");
		}
		this.gl.bufferData(34962,m.size * m.stride * 4,(m.flags & 1) != 0 ? 35048 : 35044);
		let outOfMem = h3d_impl_GlDriver.outOfMemoryCheck && this.gl.getError() == 1285;
		this.gl.bindBuffer(34962,null);
		if(outOfMem) {
			this.gl.deleteBuffer(b);
			return null;
		}
		return { b : b, stride : m.stride};
	}
	allocIndexes(count,is32) {
		if(h3d_impl_GlDriver.outOfMemoryCheck) {
			this.gl.getError();
		}
		let b = this.gl.createBuffer();
		let size = is32 ? 4 : 2;
		this.gl.bindBuffer(34963,b);
		this.gl.bufferData(34963,count * size,35044);
		let outOfMem = h3d_impl_GlDriver.outOfMemoryCheck && this.gl.getError() == 1285;
		this.gl.bindBuffer(34963,null);
		this.curIndexBuffer = null;
		if(outOfMem) {
			this.gl.deleteBuffer(b);
			return null;
		}
		return { b : b, is32 : is32};
	}
	disposeTexture(t) {
		let tt = t.t;
		if(tt == null) {
			return;
		}
		t.t = null;
		let _g = 0;
		let _g1 = this.boundTextures.length;
		while(_g < _g1) {
			let i = _g++;
			if(this.boundTextures[i] == tt) {
				this.boundTextures[i] = null;
			}
		}
		this.gl.deleteTexture(tt.t);
	}
	disposeIndexes(i) {
		this.gl.deleteBuffer(i.b);
	}
	disposeVertexes(v) {
		this.gl.deleteBuffer(v.b);
	}
	generateMipMaps(t) {
		let bind = this.getBindType(t);
		this.gl.bindTexture(bind,t.t.t);
		this.gl.generateMipmap(bind);
		this.restoreBind();
	}
	uploadTextureBitmap(t,bmp,mipLevel,side) {
		if(t.format != hxd_PixelFormat.RGBA || t.get_layerCount() != 1) {
			let pixels = bmp.getPixels();
			this.uploadTexturePixels(t,pixels,mipLevel,side);
			pixels.dispose();
		} else {
			let img = bmp.ctx;
			this.gl.bindTexture(3553,t.t.t);
			this.gl.texImage2D(3553,mipLevel,t.t.internalFmt,this.getChannels(t.t),t.t.pixelFmt,img.getImageData(0,0,bmp.ctx.canvas.width,bmp.ctx.canvas.height));
			this.restoreBind();
		}
	}
	resetStream() {
	}
	uploadTexturePixels(t,pixels,mipLevel,side) {
		let cubic = (t.flags & 2) != 0;
		let face = cubic ? h3d_impl_GlDriver.CUBE_FACES[side] : (t.flags & 2048) != 0 ? 35866 : 3553;
		let bind = this.getBindType(t);
		this.gl.bindTexture(bind,t.t.t);
		pixels.convert(t.format);
		pixels.setFlip(false);
		let dataLen = pixels.dataSize;
		let buffer;
		switch(t.format._hx_index) {
		case 3:case 6:case 9:case 12:
			buffer = new Uint16Array(pixels.bytes.b.buffer,pixels.offset,dataLen >> 1);
			break;
		case 4:case 7:case 10:case 13:
			buffer = new Float32Array(pixels.bytes.b.buffer,pixels.offset,dataLen >> 2);
			break;
		case 16:case 17:
			buffer = new Uint32Array(pixels.bytes.b.buffer,pixels.offset,dataLen >> 2);
			break;
		default:
			buffer = new Uint8Array(pixels.bytes.b.buffer,pixels.offset,dataLen);
		}
		if(t.format._hx_index == 21) {
			if((t.flags & 2048) != 0) {
				this.gl.compressedTexSubImage3D(face,mipLevel,0,0,side,pixels.width,pixels.height,1,t.t.internalFmt,buffer);
			} else {
				this.gl.compressedTexImage2D(face,mipLevel,t.t.internalFmt,pixels.width,pixels.height,0,buffer);
			}
		} else if((t.flags & 2048) != 0) {
			this.gl.texSubImage3D(face,mipLevel,0,0,side,pixels.width,pixels.height,1,this.getChannels(t.t),t.t.pixelFmt,buffer);
		} else {
			this.gl.texImage2D(face,mipLevel,t.t.internalFmt,pixels.width,pixels.height,0,this.getChannels(t.t),t.t.pixelFmt,buffer);
		}
		t.flags |= 256;
		this.restoreBind();
	}
	uploadVertexBuffer(v,startVertex,vertexCount,buf,bufPos) {
		let stride = v.stride;
		this.gl.bindBuffer(34962,v.b);
		let buf1 = buf.array;
		let sub = new Float32Array(buf1.buffer,bufPos * 4,vertexCount * stride);
		this.gl.bufferSubData(34962,startVertex * stride * 4,sub);
		this.gl.bindBuffer(34962,null);
	}
	uploadVertexBytes(v,startVertex,vertexCount,buf,bufPos) {
		let stride = v.stride;
		this.gl.bindBuffer(34962,v.b);
		let sub = new Uint8Array(buf.b.bufferValue,bufPos * 4,vertexCount * stride * 4);
		this.gl.bufferSubData(34962,startVertex * stride * 4,sub);
		this.gl.bindBuffer(34962,null);
	}
	uploadIndexBuffer(i,startIndice,indiceCount,buf,bufPos) {
		let bits = i.is32 ? 2 : 1;
		this.gl.bindBuffer(34963,i.b);
		let buf1 = new Uint16Array(buf);
		let sub = new Uint16Array(buf1.buffer,bufPos << bits,indiceCount);
		this.gl.bufferSubData(34963,startIndice << bits,sub);
		this.gl.bindBuffer(34963,null);
		this.curIndexBuffer = null;
	}
	selectBuffer(v) {
		if(v == this.curBuffer) {
			return;
		}
		if(this.curBuffer != null && v.buffer == this.curBuffer.buffer && (v.buffer.flags & 16) != 0 == ((this.curBuffer.flags & 16) != 0)) {
			this.curBuffer = v;
			return;
		}
		if(this.curShader == null) {
			throw haxe_Exception.thrown("No shader selected");
		}
		this.curBuffer = v;
		let m = v.buffer.vbuf;
		if(m.stride < this.curShader.stride) {
			throw haxe_Exception.thrown("Buffer stride (" + m.stride + ") and shader stride (" + this.curShader.stride + ") mismatch");
		}
		this.gl.bindBuffer(34962,m.b);
		if((v.flags & 16) != 0) {
			let _g = 0;
			let _g1 = this.curShader.attribs;
			while(_g < _g1.length) {
				let a = _g1[_g];
				++_g;
				let pos = a.offset;
				this.gl.vertexAttribPointer(a.index,a.size,a.type,false,m.stride * 4,pos * 4);
				if(this.currentDivisor[a.index] != a.divisor) {
					this.currentDivisor[a.index] = a.divisor;
					this.gl.vertexAttribDivisor(a.index,a.divisor);
				}
			}
		} else {
			let offset = 8;
			let _g = 0;
			let _g1 = this.curShader.attribs.length;
			while(_g < _g1) {
				let i = _g++;
				let a = this.curShader.attribs[i];
				let pos;
				let _g1 = this.curShader.inputs.names[i];
				switch(_g1) {
				case "normal":
					if(m.stride < 6) {
						throw haxe_Exception.thrown("Buffer is missing NORMAL data, set it to RAW format ?");
					}
					pos = 3;
					break;
				case "position":
					pos = 0;
					break;
				case "uv":
					if(m.stride < 8) {
						throw haxe_Exception.thrown("Buffer is missing UV data, set it to RAW format ?");
					}
					pos = 6;
					break;
				default:
					pos = offset;
					offset += a.size;
					if(offset > m.stride) {
						throw haxe_Exception.thrown("Buffer is missing '" + _g1 + "' data, set it to RAW format ?");
					}
				}
				this.gl.vertexAttribPointer(a.index,a.size,a.type,false,m.stride * 4,pos * 4);
				if(this.currentDivisor[a.index] != a.divisor) {
					this.currentDivisor[a.index] = a.divisor;
					this.gl.vertexAttribDivisor(a.index,a.divisor);
				}
			}
		}
	}
	selectMultiBuffers(buffers) {
		let _g = 0;
		let _g1 = this.curShader.attribs;
		while(_g < _g1.length) {
			let a = _g1[_g];
			++_g;
			this.gl.bindBuffer(34962,buffers.buffer.buffer.vbuf.b);
			this.gl.vertexAttribPointer(a.index,a.size,a.type,false,buffers.buffer.buffer.stride * 4,buffers.offset * 4);
			if(this.currentDivisor[a.index] != a.divisor) {
				this.currentDivisor[a.index] = a.divisor;
				this.gl.vertexAttribDivisor(a.index,a.divisor);
			}
			buffers = buffers.next;
		}
		this.curBuffer = null;
	}
	draw(ibuf,startIndex,ntriangles) {
		if(ibuf != this.curIndexBuffer) {
			this.curIndexBuffer = ibuf;
			this.gl.bindBuffer(34963,ibuf.b);
		}
		if(ibuf.is32) {
			this.gl.drawElements(this.drawMode,ntriangles * 3,5125,startIndex * 4);
		} else {
			this.gl.drawElements(this.drawMode,ntriangles * 3,5123,startIndex * 2);
		}
	}
	allocInstanceBuffer(b,bytes) {
		let data = [];
		let _g = 0;
		let _g1 = b.commandCount;
		while(_g < _g1) {
			let i = _g++;
			let p = i * 5 * 4;
			let indexCount = bytes.getInt32(p);
			let instanceCount = bytes.getInt32(p + 4);
			let offIndex = bytes.getInt32(p + 8);
			let offVertex = bytes.getInt32(p + 12);
			let offInstance = bytes.getInt32(p + 16);
			if(offVertex != 0 || offInstance != 0) {
				throw haxe_Exception.thrown("baseVertex and baseInstance must be zero on this platform");
			}
			data.push(indexCount);
			data.push(offIndex);
			data.push(instanceCount);
		}
		b.data = data;
	}
	disposeInstanceBuffer(b) {
		b.data = null;
	}
	drawInstanced(ibuf,commands) {
		if(ibuf != this.curIndexBuffer) {
			this.curIndexBuffer = ibuf;
			this.gl.bindBuffer(34963,ibuf.b);
		}
		let kind;
		let size;
		if(ibuf.is32) {
			kind = 5125;
			size = 4;
		} else {
			kind = 5123;
			size = 2;
		}
		let args = commands.data;
		if(args != null) {
			let p = 0;
			let _g = 0;
			let _g1 = args.length / 3 | 0;
			while(_g < _g1) {
				++_g;
				this.gl.drawElementsInstanced(this.drawMode,args[p++],kind,args[p++] * size,args[p++]);
			}
		} else {
			this.gl.drawElementsInstanced(this.drawMode,commands.indexCount,kind,commands.startIndex * size,commands.commandCount);
		}
	}
	end() {
	}
	isDisposed() {
		return this.gl.isContextLost();
	}
	setRenderZone(x,y,width,height) {
		if(x == 0 && y == 0 && width < 0 && height < 0) {
			this.gl.disable(3089);
		} else {
			this.gl.enable(3089);
			if(this.curTarget == null) {
				y = this.bufferHeight - (y + height);
			}
			this.gl.scissor(x,y,width,height);
		}
	}
	setDrawBuffers(k) {
		if(this.glES >= 3) {
			this.gl.drawBuffers(h3d_impl_GlDriver.CBUFFERS[k]);
		} else if(this.mrtExt != null) {
			this.mrtExt.drawBuffersWEBGL(h3d_impl_GlDriver.CBUFFERS[k]);
		}
	}
	unbindTargets() {
		if(this.curTarget != null && this.numTargets > 1) {
			while(this.numTargets > 1) {
				this.gl.framebufferTexture2D(36160,36064 + --this.numTargets,3553,null,0);
				this.curTargets[this.numTargets] = null;
			}
			this.setDrawBuffers(1);
		}
	}
	capturePixels(tex,layer,mipLevel,region) {
		let x;
		let y;
		let w;
		let h;
		if(region != null) {
			if(region.xMax > tex.width) {
				region.xMax = tex.width;
			}
			if(region.yMax > tex.height) {
				region.yMax = tex.height;
			}
			if(region.xMin < 0) {
				region.xMin = 0;
			}
			if(region.yMin < 0) {
				region.yMin = 0;
			}
			w = region.xMax - region.xMin;
			h = region.yMax - region.yMin;
			x = region.xMin;
			y = region.yMin;
		} else {
			w = tex.width;
			h = tex.height;
			x = 0;
			y = 0;
		}
		w >>= mipLevel;
		h >>= mipLevel;
		if(w == 0) {
			w = 1;
		}
		if(h == 0) {
			h = 1;
		}
		let pixels = hxd_Pixels.alloc(w,h,tex.format);
		let old = this.curTarget;
		let oldCount = this.numTargets;
		let oldLayer = this.curTargetLayer;
		let oldMip = this.curTargetMip;
		if(oldCount > 1) {
			this.numTargets = 1;
			let _g = 1;
			while(_g < oldCount) {
				let i = _g++;
				if(this.curTargets[i] == tex) {
					this.gl.framebufferTexture2D(36160,36064 + i,3553,null,0);
				}
			}
		}
		this.setRenderTarget(tex,layer,mipLevel);
		this.captureSubRenderBuffer(pixels,x,y);
		this.setRenderTarget(old,oldLayer,oldMip);
		if(oldCount > 1) {
			let _g = 1;
			while(_g < oldCount) {
				let i = _g++;
				if(this.curTargets[i] == tex) {
					this.gl.framebufferTexture2D(36160,36064 + i,3553,tex.t.t,0);
				}
			}
			this.setDrawBuffers(oldCount);
			this.numTargets = oldCount;
		}
		return pixels;
	}
	setRenderTarget(tex,layer,mipLevel) {
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(layer == null) {
			layer = 0;
		}
		this.unbindTargets();
		this.curTarget = tex;
		if(tex == null) {
			this.gl.bindFramebuffer(36160,null);
			this.gl.viewport(0,0,this.bufferWidth,this.bufferHeight);
			return;
		}
		if(tex.depthBuffer != null && (tex.depthBuffer.width != tex.width || tex.depthBuffer.height != tex.height)) {
			throw haxe_Exception.thrown("Invalid depth buffer size : does not match render target size");
		}
		if(mipLevel > 0 && this.glES == 1) {
			throw haxe_Exception.thrown("Cannot render to mipLevel in WebGL1, use upload() instead");
		}
		if(tex.t == null) {
			tex.alloc();
		}
		if((tex.flags & 4) != 0 && (tex.flags & 256) == 0) {
			let bind = this.getBindType(tex);
			this.gl.bindTexture(bind,tex.t.t);
			this.gl.generateMipmap(bind);
			this.restoreBind();
		}
		tex.set_lastFrame(this.frame);
		this.curTargetLayer = layer;
		this.curTargetMip = mipLevel;
		this.gl.bindFramebuffer(36160,this.commonFB);
		if((tex.flags & 2048) != 0) {
			this.gl.framebufferTextureLayer(36160,36064,tex.t.t,mipLevel,layer);
		} else {
			this.gl.framebufferTexture2D(36160,36064,(tex.flags & 2) != 0 ? h3d_impl_GlDriver.CUBE_FACES[layer] : 3553,tex.t.t,mipLevel);
		}
		if(tex.depthBuffer != null) {
			if(tex.depthBuffer.hasStencil() && tex.depthBuffer.format == h3d_mat_DepthFormat.Depth24Stencil8) {
				this.gl.framebufferRenderbuffer(36160,33306,36161,tex.depthBuffer.b.r);
			} else {
				this.gl.framebufferRenderbuffer(36160,33306,36161,null);
				this.gl.framebufferRenderbuffer(36160,36096,36161,tex.depthBuffer.b.r);
				this.gl.framebufferRenderbuffer(36160,36128,36161,tex.depthBuffer.hasStencil() ? tex.depthBuffer.b.r : null);
			}
		} else {
			this.gl.framebufferRenderbuffer(36160,33306,36161,null);
			this.gl.framebufferRenderbuffer(36160,36096,36161,null);
			this.gl.framebufferRenderbuffer(36160,36128,36161,null);
		}
		let w = tex.width >> mipLevel;
		if(w == 0) {
			w = 1;
		}
		let h = tex.height >> mipLevel;
		if(h == 0) {
			h = 1;
		}
		this.gl.viewport(0,0,w,h);
		let _g = 0;
		let _g1 = this.boundTextures.length;
		while(_g < _g1) {
			let i = _g++;
			this.boundTextures[i] = null;
		}
		if((tex.flags & 256) == 0) {
			tex.flags |= 256;
			this.clear(h3d_impl_GlDriver.BLACK);
		}
		if(this.glDebug) {
			let code = this.gl.checkFramebufferStatus(36160);
			if(code != 36053) {
				throw haxe_Exception.thrown("Invalid frame buffer: " + code);
			}
		}
	}
	setRenderTargets(textures) {
		this.unbindTargets();
		this.setRenderTarget(textures[0]);
		if(textures.length < 2) {
			return;
		}
		this.numTargets = textures.length;
		let needClear = false;
		let _g = 1;
		let _g1 = textures.length;
		while(_g < _g1) {
			let i = _g++;
			let tex = textures[i];
			if(tex.t == null) {
				tex.alloc();
			}
			this.gl.framebufferTexture2D(36160,36064 + i,3553,tex.t.t,0);
			this.curTargets[i] = tex;
			tex.set_lastFrame(this.frame);
			if((tex.flags & 256) == 0) {
				tex.flags |= 256;
				needClear = true;
			}
		}
		this.setDrawBuffers(textures.length);
		if(needClear) {
			this.clear(h3d_impl_GlDriver.BLACK);
		}
	}
	init(onCreate,forceSoftware) {
		if(forceSoftware == null) {
			forceSoftware = false;
		}
		if(window.document.readyState == "complete") {
			let _g = onCreate;
			let a1 = false;
			haxe_Timer.delay(function() {
				_g(a1);
			},1);
		} else {
			let onLoad = null;
			onLoad = function() {
				window.removeEventListener("load",onLoad);
				onCreate(false);
			};
			window.addEventListener("load",onLoad);
		}
	}
	hasFeature(f) {
		return this.features.get(f);
	}
	makeFeatures() {
		let _g = 0;
		let _g1 = h3d_impl_Feature.__empty_constructs__.slice();
		while(_g < _g1.length) {
			let f = _g1[_g];
			++_g;
			this.features.set(f,this.checkFeature(f));
		}
		if(this.gl.getExtension("WEBGL_compressed_texture_s3tc") != null) {
			this.maxCompressedTexturesSupport = 3;
		}
	}
	checkFeature(f) {
		switch(f._hx_index) {
		case 0:
			if(this.glES >= 3) {
				return true;
			} else {
				return this.gl.getExtension("OES_standard_derivatives") != null;
			}
			break;
		case 1:
			if(this.glES >= 3) {
				if(this.gl.getExtension("EXT_color_buffer_float") != null) {
					return this.gl.getExtension("OES_texture_float_linear") != null;
				} else {
					return false;
				}
			} else if(this.gl.getExtension("OES_texture_float") != null && this.gl.getExtension("OES_texture_float_linear") != null && this.gl.getExtension("OES_texture_half_float") != null) {
				return this.gl.getExtension("OES_texture_half_float_linear") != null;
			} else {
				return false;
			}
			break;
		case 4:
			if(this.glES >= 3) {
				return true;
			} else if(this.mrtExt == null) {
				return (this.mrtExt = this.gl.getExtension("WEBGL_draw_buffers")) != null;
			} else {
				return true;
			}
			break;
		case 6:
			if(this.glES >= 3) {
				return true;
			} else {
				return this.gl.getExtension("EXT_sRGB") != null;
			}
			break;
		case 7:
			if(this.glES >= 3) {
				return true;
			} else {
				return false;
			}
			break;
		case 2:case 3:case 8:case 9:
			return true;
		case 10:
			if(this.glES >= 3) {
				return true;
			} else {
				return this.gl.getExtension("ANGLE_instanced_arrays") != null;
			}
			break;
		default:
			return false;
		}
	}
	captureSubRenderBuffer(pixels,x,y) {
		if(this.curTarget == null) {
			throw haxe_Exception.thrown("Can't capture main render buffer in GL");
		}
		this.gl.getError();
		let buffer = pixels.bytes.b;
		switch(this.curTarget.format._hx_index) {
		case 3:case 6:case 9:case 12:
			buffer = new Uint16Array(buffer.buffer);
			break;
		case 4:case 7:case 10:case 13:
			buffer = new Float32Array(buffer.buffer);
			break;
		case 16:case 17:
			buffer = new Uint32Array(buffer.buffer);
			break;
		default:
		}
		this.gl.readPixels(x,y,pixels.width,pixels.height,this.getChannels(this.curTarget.t),this.curTarget.t.pixelFmt,buffer);
		let error = this.gl.getError();
		if(error != 0) {
			throw haxe_Exception.thrown("Failed to capture pixels (error " + error + ")");
		}
		pixels.set_innerFormat(this.curTarget.format);
	}
}
$hxClasses["h3d.impl.GlDriver"] = h3d_impl_GlDriver;
h3d_impl_GlDriver.__name__ = "h3d.impl.GlDriver";
h3d_impl_GlDriver.__super__ = h3d_impl_Driver;
Object.assign(h3d_impl_GlDriver.prototype, {
	__class__: h3d_impl_GlDriver
	,canvas: null
	,mrtExt: null
	,gl: null
	,commonFB: null
	,curAttribs: null
	,maxIdxCurAttribs: null
	,curShader: null
	,curBuffer: null
	,curIndexBuffer: null
	,curMatBits: null
	,curStOpBits: null
	,curStMaskBits: null
	,curStEnabled: null
	,defStencil: null
	,programs: null
	,frame: null
	,lastActiveIndex: null
	,curColorMask: null
	,currentDivisor: null
	,bufferWidth: null
	,bufferHeight: null
	,curTarget: null
	,curTargets: null
	,numTargets: null
	,curTargetLayer: null
	,curTargetMip: null
	,debug: null
	,glDebug: null
	,boundTextures: null
	,glES: null
	,shaderVersion: null
	,firstShader: null
	,rightHanded: null
	,maxCompressedTexturesSupport: null
	,drawMode: null
	,isIntelGpu: null
	,defaultDepth: null
	,features: null
});
class h3d_impl_InstanceBuffer {
	constructor() {
		this.triCount = 0;
	}
	setCommand(commandCount,indexCount,startIndex) {
		if(startIndex == null) {
			startIndex = 0;
		}
		this.commandCount = commandCount;
		this.indexCount = indexCount;
		this.triCount = commandCount * indexCount / 3 | 0;
		this.startIndex = startIndex;
	}
	setBuffer(commandCount,bytes) {
		this.dispose();
		let _g = 0;
		while(_g < commandCount) {
			let i = _g++;
			let idxCount = bytes.getInt32(i * 20);
			let instCount = bytes.getInt32(i * 20 + 4);
			let tri = idxCount * instCount / 3 | 0;
			this.triCount += tri;
		}
		this.commandCount = commandCount;
		this.indexCount = 0;
		this.driver = h3d_Engine.CURRENT.driver;
		this.driver.allocInstanceBuffer(this,bytes);
	}
	dispose() {
		if(this.data != null) {
			this.driver.disposeInstanceBuffer(this);
		}
	}
}
$hxClasses["h3d.impl.InstanceBuffer"] = h3d_impl_InstanceBuffer;
h3d_impl_InstanceBuffer.__name__ = "h3d.impl.InstanceBuffer";
Object.assign(h3d_impl_InstanceBuffer.prototype, {
	__class__: h3d_impl_InstanceBuffer
	,data: null
	,driver: null
	,indexCount: null
	,startIndex: null
	,triCount: null
	,commandCount: null
});
class h3d_impl__$ManagedBuffer_FreeCell {
	constructor(pos,count,next) {
		this.pos = pos;
		this.count = count;
		this.next = next;
	}
}
$hxClasses["h3d.impl._ManagedBuffer.FreeCell"] = h3d_impl__$ManagedBuffer_FreeCell;
h3d_impl__$ManagedBuffer_FreeCell.__name__ = "h3d.impl._ManagedBuffer.FreeCell";
Object.assign(h3d_impl__$ManagedBuffer_FreeCell.prototype, {
	__class__: h3d_impl__$ManagedBuffer_FreeCell
	,pos: null
	,count: null
	,next: null
});
class h3d_impl_ManagedBuffer {
	constructor(stride,size,flags) {
		this.flags = 0;
		if(flags != null) {
			let _g = 0;
			while(_g < flags.length) {
				let f = flags[_g];
				++_g;
				this.flags |= 1 << f._hx_index;
			}
		}
		this.size = size;
		this.stride = stride;
		this.freeList = new h3d_impl__$ManagedBuffer_FreeCell(0,size,null);
		this.mem = h3d_Engine.CURRENT.mem;
		this.mem.allocManaged(this);
	}
	uploadVertexBuffer(start,vertices,buf,bufPos) {
		if(bufPos == null) {
			bufPos = 0;
		}
		this.mem.driver.uploadVertexBuffer(this.vbuf,start,vertices,buf,bufPos);
	}
	uploadVertexBytes(start,vertices,data,dataPos) {
		if(dataPos == null) {
			dataPos = 0;
		}
		this.mem.driver.uploadVertexBytes(this.vbuf,start,vertices,data,dataPos);
	}
	allocPosition(nvert,align) {
		let free = this.freeList;
		while(free != null) {
			if(free.count >= nvert) {
				let d = (align - free.pos % align) % align;
				if(d == 0) {
					break;
				}
				if(free.count >= nvert + d) {
					free.next = new h3d_impl__$ManagedBuffer_FreeCell(free.pos + d,free.count - d,free.next);
					free.count = d;
					free = free.next;
					break;
				}
			}
			free = free.next;
		}
		if(free == null) {
			return -1;
		}
		let pos = free.pos;
		free.pos += nvert;
		free.count -= nvert;
		return pos;
	}
	allocBuffer(b) {
		let align = (b.flags & 4) != 0 ? 4 : (b.flags & 2) != 0 ? 3 : 1;
		let p = this.allocPosition(b.vertices,align);
		if(p < 0) {
			return false;
		}
		b.position = p;
		b.buffer = this;
		return true;
	}
	freeBuffer(b) {
		let prev = null;
		let f = this.freeList;
		let nvert = b.vertices;
		let end = b.position + nvert;
		while(f != null) {
			if(f.pos == end) {
				f.pos -= nvert;
				f.count += nvert;
				if(prev != null && prev.pos + prev.count == f.pos) {
					prev.count += f.count;
					prev.next = f.next;
				}
				nvert = 0;
				break;
			}
			if(f.pos > end) {
				if(prev != null && prev.pos + prev.count == b.position) {
					prev.count += nvert;
				} else {
					let n = new h3d_impl__$ManagedBuffer_FreeCell(b.position,nvert,f);
					if(prev == null) {
						this.freeList = n;
					} else {
						prev.next = n;
					}
				}
				nvert = 0;
				break;
			}
			prev = f;
			f = f.next;
		}
		if(nvert != 0) {
			throw haxe_Exception.thrown("assert");
		}
		if(this.freeList.count == this.size && (this.flags & 8) == 0) {
			this.dispose();
		}
	}
	dispose() {
		this.mem.freeManaged(this);
	}
}
$hxClasses["h3d.impl.ManagedBuffer"] = h3d_impl_ManagedBuffer;
h3d_impl_ManagedBuffer.__name__ = "h3d.impl.ManagedBuffer";
Object.assign(h3d_impl_ManagedBuffer.prototype, {
	__class__: h3d_impl_ManagedBuffer
	,mem: null
	,stride: null
	,size: null
	,flags: null
	,vbuf: null
	,freeList: null
	,next: null
});
class h3d_impl_MemoryManager {
	constructor(driver) {
		this.bufferCount = 0;
		this.texMemory = 0;
		this.usedMemory = 0;
		this.driver = driver;
	}
	init() {
		this.indexes = [];
		this.textures = [];
		this.buffers = [];
		this.depths = [];
		this.initIndexes();
	}
	initIndexes() {
		let indices = new Array(0);
		let _g = 0;
		while(_g < 65533) {
			let i = _g++;
			indices.push(i);
		}
		this.triIndexes = h3d_Indexes.alloc(indices);
		let indices1 = new Array(0);
		let _g1 = 0;
		while(_g1 < 16383) {
			let i = _g1++;
			let k = i << 2;
			indices1.push(k);
			indices1.push(k + 1);
			indices1.push(k + 2);
			indices1.push(k + 2);
			indices1.push(k + 1);
			indices1.push(k + 3);
		}
		indices1.push(65533);
		this.quadIndexes = h3d_Indexes.alloc(indices1);
	}
	garbage() {
	}
	cleanManagedBuffers() {
		let _g = 1;
		let _g1 = this.buffers.length;
		while(_g < _g1) {
			let i = _g++;
			let b = this.buffers[i];
			let prev = null;
			while(b != null) {
				if(b.freeList.count == b.size) {
					b.dispose();
					if(prev == null) {
						this.buffers[i] = b.next;
					} else {
						prev.next = b.next;
					}
				} else {
					prev = b;
				}
				b = b.next;
			}
		}
	}
	allocManaged(m) {
		if(m.vbuf != null) {
			return;
		}
		let mem = m.size * m.stride * 4;
		if(mem == 0) {
			return;
		}
		while(this.usedMemory + mem > 4294967296. || this.bufferCount >= 65536 || (m.vbuf = this.driver.allocVertexes(m)) == null) {
			if(this.driver.isDisposed()) {
				return;
			}
			let size = this.usedMemory - this.freeMemorySize();
			this.garbage();
			this.cleanManagedBuffers();
			if(this.usedMemory - this.freeMemorySize() == size) {
				if(this.bufferCount >= 65536) {
					throw haxe_Exception.thrown("Too many buffers");
				}
				throw haxe_Exception.thrown("Memory full (" + Math.ceil(size / 1024) + " KB," + this.bufferCount + " buffers)");
			}
		}
		this.usedMemory += mem;
		this.bufferCount++;
	}
	freeManaged(m) {
		if(m.vbuf == null) {
			return;
		}
		this.driver.disposeVertexes(m.vbuf);
		m.vbuf = null;
		this.usedMemory -= m.size * m.stride * 4;
		this.bufferCount--;
		if((m.flags & 8) == 0) {
			let c = this.buffers[0];
			let prev = null;
			while(c != null) {
				if(c == m) {
					if(prev == null) {
						this.buffers[0] = m.next;
					} else {
						prev.next = m.next;
					}
					break;
				}
				prev = c;
				c = c.next;
			}
		}
	}
	allocBuffer(b,stride) {
		let max = (b.flags & 4) != 0 ? 65532 : (b.flags & 2) != 0 ? 65533 : 65534;
		if(b.vertices > max && (b.flags & 64) == 0 && (b.flags & 128) == 0) {
			if(max == 65534) {
				throw haxe_Exception.thrown("Cannot split buffer with " + b.vertices + " vertices if it's not Quads/Triangles");
			}
			let rem = b.vertices - max;
			b.vertices = max;
			this.allocBuffer(b,stride);
			let n = b;
			while(n.next != null) n = n.next;
			let flags = [];
			let _g = 0;
			let _g1 = h3d_impl_MemoryManager.ALL_FLAGS;
			while(_g < _g1.length) {
				let f = _g1[_g];
				++_g;
				if((b.flags & 1 << f._hx_index) != 0) {
					flags.push(f);
				}
			}
			n.next = new h3d_Buffer(rem,stride,flags);
			return;
		}
		if((b.flags & 8) == 0) {
			let flags = null;
			if((b.flags & 1) != 0) {
				flags = [];
				flags.push(h3d_BufferFlag.Dynamic);
			}
			if((b.flags & 64) != 0) {
				if(flags == null) {
					flags = [];
				}
				flags.push(h3d_BufferFlag.UniformBuffer);
			}
			let m = new h3d_impl_ManagedBuffer(stride,b.vertices,flags);
			m.next = this.buffers[0];
			this.buffers[0] = m;
			if(!m.allocBuffer(b)) {
				throw haxe_Exception.thrown("assert");
			}
			return;
		}
		let m = this.buffers[stride];
		let prev = null;
		while(m != null) {
			if(m.allocBuffer(b)) {
				return;
			}
			prev = m;
			m = m.next;
		}
		let align = (b.flags & 2) != 0 ? 3 : (b.flags & 4) != 0 ? 4 : 0;
		if(m == null && align > 0) {
			let total = b.vertices;
			let size = total;
			while(size > 2048) {
				m = this.buffers[stride];
				size >>= 1;
				size -= size % align;
				b.vertices = size;
				while(m != null) {
					if(m.allocBuffer(b)) {
						let flags = [];
						let _g = 0;
						let _g1 = h3d_impl_MemoryManager.ALL_FLAGS;
						while(_g < _g1.length) {
							let f = _g1[_g];
							++_g;
							if((b.flags & 1 << f._hx_index) != 0) {
								flags.push(f);
							}
						}
						b.next = new h3d_Buffer(total - size,stride,flags);
						return;
					}
					m = m.next;
				}
			}
			b.vertices = total;
		}
		m = new h3d_impl_ManagedBuffer(stride,65533,[h3d_BufferFlag.Managed]);
		if(prev == null) {
			this.buffers[stride] = m;
		} else {
			prev.next = m;
		}
		if(!m.allocBuffer(b)) {
			throw haxe_Exception.thrown("assert");
		}
	}
	deleteIndexes(i) {
		HxOverrides.remove(this.indexes,i);
		this.driver.disposeIndexes(i.ibuf);
		i.ibuf = null;
		this.usedMemory -= i.count * (i.is32 ? 4 : 2);
	}
	allocIndexes(i) {
		i.ibuf = this.driver.allocIndexes(i.count,i.is32);
		this.indexes.push(i);
		this.usedMemory += i.count * (i.is32 ? 4 : 2);
	}
	memSize(t) {
		if((t.flags & 4096) != 0 && (t.flags & 512) != 0) {
			return 4;
		}
		let size = hxd_Pixels.calcDataSize(t.width,t.height,t.format);
		if(t.get_mipLevels() > 0) {
			let _g = 1;
			let _g1 = t.get_mipLevels();
			while(_g < _g1) {
				let i = _g++;
				let w = t.width >> i;
				if(w == 0) {
					w = 1;
				}
				let h = t.height >> i;
				if(h == 0) {
					h = 1;
				}
				size += hxd_Pixels.calcDataSize(w,h,t.format);
			}
		}
		return size * t.get_layerCount();
	}
	cleanTextures(force) {
		if(force == null) {
			force = true;
		}
		this.textures.sort($bind(this,this.sortByLRU));
		let _g = 0;
		let _g1 = this.textures;
		while(_g < _g1.length) {
			let t = _g1[_g];
			++_g;
			if(t.realloc == null || t.t == null && t.realloc == null) {
				continue;
			}
			if((force || t.get_lastFrame() < hxd_Timer.frameCount - 3600) && t.get_lastFrame() != h3d_mat_Texture.PREVENT_AUTO_DISPOSE) {
				t.dispose();
				return true;
			}
		}
		return false;
	}
	sortByLRU(t1,t2) {
		return t1.get_lastFrame() - t2.get_lastFrame();
	}
	deleteTexture(t) {
		if(!HxOverrides.remove(this.textures,t)) {
			return;
		}
		this.driver.disposeTexture(t);
		this.texMemory -= this.memSize(t);
	}
	allocTexture(t) {
		while(true) {
			let free = this.cleanTextures(false);
			t.t = this.driver.allocTexture(t);
			if(t.t != null) {
				break;
			}
			if(this.driver.isDisposed()) {
				return;
			}
			while(this.cleanTextures(false)) {
			}
			if(!free && !this.cleanTextures(true)) {
				throw haxe_Exception.thrown("Maximum texture memory reached");
			}
		}
		this.textures.push(t);
		this.texMemory += this.memSize(t);
	}
	allocDepth(b) {
		while(true) {
			let free = this.cleanTextures(false);
			b.b = this.driver.allocDepthBuffer(b);
			if(b.b != null) {
				break;
			}
			if(this.driver.isDisposed()) {
				return;
			}
			while(this.cleanTextures(false)) {
			}
			if(!free && !this.cleanTextures(true)) {
				throw haxe_Exception.thrown("Maximum texture memory reached");
			}
		}
		this.depths.push(b);
		this.texMemory += b.width * b.height * 4;
	}
	deleteDepth(b) {
		if(!HxOverrides.remove(this.depths,b)) {
			return;
		}
		this.driver.disposeDepthBuffer(b);
		this.texMemory -= b.width * b.height * 4;
	}
	onContextLost() {
		this.dispose();
		this.initIndexes();
	}
	dispose() {
		if(this.triIndexes != null) {
			this.triIndexes.dispose();
		}
		if(this.quadIndexes != null) {
			this.quadIndexes.dispose();
		}
		this.triIndexes = null;
		this.quadIndexes = null;
		let _g = 0;
		let _g1 = this.textures.slice();
		while(_g < _g1.length) {
			let t = _g1[_g];
			++_g;
			t.dispose();
		}
		let _g2 = 0;
		let _g3 = this.depths.slice();
		while(_g2 < _g3.length) {
			let b = _g3[_g2];
			++_g2;
			b.dispose();
		}
		let _g4 = 0;
		let _g5 = this.buffers.slice();
		while(_g4 < _g5.length) {
			let b = _g5[_g4];
			++_g4;
			let b1 = b;
			while(b1 != null) {
				b1.dispose();
				b1 = b1.next;
			}
		}
		let _g6 = 0;
		let _g7 = this.indexes.slice();
		while(_g6 < _g7.length) {
			let i = _g7[_g6];
			++_g6;
			i.dispose();
		}
		this.buffers = [];
		this.indexes = [];
		this.textures = [];
		this.bufferCount = 0;
		this.usedMemory = 0;
		this.texMemory = 0;
	}
	freeMemorySize() {
		let size = 0;
		let _g = 0;
		let _g1 = this.buffers;
		while(_g < _g1.length) {
			let b = _g1[_g];
			++_g;
			let b1 = b;
			while(b1 != null) {
				let free = b1.freeList;
				while(free != null) {
					size += free.count * b1.stride * 4;
					free = free.next;
				}
				b1 = b1.next;
			}
		}
		return size;
	}
}
$hxClasses["h3d.impl.MemoryManager"] = h3d_impl_MemoryManager;
h3d_impl_MemoryManager.__name__ = "h3d.impl.MemoryManager";
Object.assign(h3d_impl_MemoryManager.prototype, {
	__class__: h3d_impl_MemoryManager
	,driver: null
	,buffers: null
	,indexes: null
	,textures: null
	,depths: null
	,triIndexes: null
	,quadIndexes: null
	,usedMemory: null
	,texMemory: null
	,bufferCount: null
});
class h3d_impl_NullDriver extends h3d_impl_Driver {
	constructor() {
		super();
	}
	hasFeature(f) {
		return true;
	}
	isSupportedFormat(fmt) {
		return true;
	}
	isDisposed() {
		return false;
	}
	init(onCreate,forceSoftware) {
		if(forceSoftware == null) {
			forceSoftware = false;
		}
		onCreate(false);
	}
	selectShader(shader) {
		if(this.cur == shader) {
			return false;
		}
		this.cur = shader;
		return true;
	}
	getShaderInputNames() {
		let names = [];
		let _g = 0;
		let _g1 = this.cur.vertex.data.vars;
		while(_g < _g1.length) {
			let v = _g1[_g];
			++_g;
			if(v.kind == hxsl_VarKind.Input) {
				names.push(v.name);
			}
		}
		return h3d_impl_InputNames.get(names);
	}
	allocTexture(t) {
		return { };
	}
	allocIndexes(count,is32) {
		return { };
	}
	allocVertexes(m) {
		return { };
	}
}
$hxClasses["h3d.impl.NullDriver"] = h3d_impl_NullDriver;
h3d_impl_NullDriver.__name__ = "h3d.impl.NullDriver";
h3d_impl_NullDriver.__super__ = h3d_impl_Driver;
Object.assign(h3d_impl_NullDriver.prototype, {
	__class__: h3d_impl_NullDriver
	,cur: null
});
class h3d_impl_TextureCache {
	constructor(ctx) {
		this.position = 0;
		this.ctx = ctx;
		this.cache = [];
		this.defaultFormat = h3d_mat_Texture.nativeFormat;
		this.defaultDepthBuffer = h3d_mat_DepthBuffer.getDefault();
	}
	begin() {
		while(this.cache.length > this.position) {
			let t = this.cache.pop();
			if(t != null) {
				t.dispose();
			}
		}
		this.position = 0;
	}
	lookupTarget(name,width,height,format,isCube) {
		let t = this.cache[this.position];
		let _g = this.position + 1;
		let _g1 = this.cache.length;
		while(_g < _g1) {
			let i = _g++;
			let t2 = this.cache[i];
			if(t2 != null && !(t2.t == null && t2.realloc == null) && t2.width == width && t2.height == height && t2.format == format && isCube == ((t2.flags & 2) != 0)) {
				this.cache[this.position] = t2;
				this.cache[i] = t;
				return t2;
			}
		}
		if(t != null && t.name == name) {
			t.dispose();
			t = null;
		}
		let flags = [h3d_mat_TextureFlags.Target];
		if(isCube) {
			flags.push(h3d_mat_TextureFlags.Cube);
		}
		let newt = new h3d_mat_Texture(width,height,flags,format);
		newt.realloc = function() {
		};
		if(t != null) {
			this.cache.splice(this.position,0,newt);
		} else {
			this.cache[this.position] = newt;
		}
		return newt;
	}
	allocTarget(name,width,height,defaultDepth,format,isCube) {
		if(isCube == null) {
			isCube = false;
		}
		if(defaultDepth == null) {
			defaultDepth = true;
		}
		let t = this.cache[this.position];
		if(format == null) {
			format = this.defaultFormat;
		}
		if(t == null || t.t == null && t.realloc == null || t.width != width || t.height != height || t.format != format || isCube != ((t.flags & 2) != 0)) {
			t = this.lookupTarget(name,width,height,format,isCube);
		}
		t.depthBuffer = defaultDepth ? this.defaultDepthBuffer : null;
		t.setName(name);
		this.position++;
		return t;
	}
	allocTileTarget(name,tile,defaultDepth,format) {
		if(defaultDepth == null) {
			defaultDepth = false;
		}
		return this.allocTarget(name,Math.ceil(tile.width + tile.x) - Math.floor(tile.x),Math.ceil(tile.height + tile.y) - Math.floor(tile.y),defaultDepth,format);
	}
}
$hxClasses["h3d.impl.TextureCache"] = h3d_impl_TextureCache;
h3d_impl_TextureCache.__name__ = "h3d.impl.TextureCache";
Object.assign(h3d_impl_TextureCache.prototype, {
	__class__: h3d_impl_TextureCache
	,cache: null
	,position: null
	,defaultDepthBuffer: null
	,ctx: null
	,defaultFormat: null
});
class hxd_impl_AnyProps {
	set_props(p) {
		this.props = p;
		this.refreshProps();
		return p;
	}
	setDefaultProps(kind) {
		this.set_props(this.getDefaultProps(kind));
	}
	getDefaultProps(kind) {
		return { };
	}
	refreshProps() {
	}
}
$hxClasses["hxd.impl.AnyProps"] = hxd_impl_AnyProps;
hxd_impl_AnyProps.__name__ = "hxd.impl.AnyProps";
Object.assign(hxd_impl_AnyProps.prototype, {
	__class__: hxd_impl_AnyProps
	,props: null
});
class h3d_mat_BaseMaterial extends hxd_impl_AnyProps {
	constructor(shader) {
		super();
		if(h3d_mat_BaseMaterial._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(shader);
	}
	_hx_constructor(shader) {
		if(shader != null) {
			this.addPass(new h3d_mat_Pass("default",null)).addShader(shader);
		}
	}
	addPass(p) {
		let prev = null;
		let cur = this.passes;
		while(cur != null) {
			prev = cur;
			cur = cur.nextPass;
		}
		if(prev == null) {
			this.passes = p;
		} else {
			prev.nextPass = p;
		}
		p.nextPass = null;
		return p;
	}
	removePass(p) {
		let prev = null;
		let cur = this.passes;
		while(cur != null) {
			if(cur == p) {
				if(prev == null) {
					this.passes = p.nextPass;
				} else {
					prev.nextPass = p.nextPass;
				}
				p.nextPass = null;
				return true;
			}
			prev = cur;
			cur = cur.nextPass;
		}
		return false;
	}
	getPasses() {
		let p = this.passes;
		let out = [];
		while(p != null) {
			out.push(p);
			p = p.nextPass;
		}
		return out;
	}
	getPass(name) {
		let p = this.passes;
		while(p != null) {
			if(p.name == name) {
				return p;
			}
			p = p.nextPass;
		}
		return null;
	}
	clone(m) {
		if(m == null) {
			m = new h3d_mat_BaseMaterial();
		}
		m.passes.load(this.passes);
		m.name = this.name;
		m.set_props(this.props);
		return m;
	}
}
$hxClasses["h3d.mat.BaseMaterial"] = h3d_mat_BaseMaterial;
h3d_mat_BaseMaterial.__name__ = "h3d.mat.BaseMaterial";
h3d_mat_BaseMaterial.__super__ = hxd_impl_AnyProps;
Object.assign(h3d_mat_BaseMaterial.prototype, {
	__class__: h3d_mat_BaseMaterial
	,passes: null
	,name: null
});
var h3d_mat_Face = $hxEnums["h3d.mat.Face"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.mat.Face",toString:$estr}
	,Back: {_hx_name:"Back",_hx_index:1,__enum__:"h3d.mat.Face",toString:$estr}
	,Front: {_hx_name:"Front",_hx_index:2,__enum__:"h3d.mat.Face",toString:$estr}
	,Both: {_hx_name:"Both",_hx_index:3,__enum__:"h3d.mat.Face",toString:$estr}
};
h3d_mat_Face.__constructs__ = [h3d_mat_Face.None,h3d_mat_Face.Back,h3d_mat_Face.Front,h3d_mat_Face.Both];
h3d_mat_Face.__empty_constructs__ = [h3d_mat_Face.None,h3d_mat_Face.Back,h3d_mat_Face.Front,h3d_mat_Face.Both];
var h3d_mat_Blend = $hxEnums["h3d.mat.Blend"] = { __ename__:true,__constructs__:null
	,One: {_hx_name:"One",_hx_index:0,__enum__:"h3d.mat.Blend",toString:$estr}
	,Zero: {_hx_name:"Zero",_hx_index:1,__enum__:"h3d.mat.Blend",toString:$estr}
	,SrcAlpha: {_hx_name:"SrcAlpha",_hx_index:2,__enum__:"h3d.mat.Blend",toString:$estr}
	,SrcColor: {_hx_name:"SrcColor",_hx_index:3,__enum__:"h3d.mat.Blend",toString:$estr}
	,DstAlpha: {_hx_name:"DstAlpha",_hx_index:4,__enum__:"h3d.mat.Blend",toString:$estr}
	,DstColor: {_hx_name:"DstColor",_hx_index:5,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusSrcAlpha: {_hx_name:"OneMinusSrcAlpha",_hx_index:6,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusSrcColor: {_hx_name:"OneMinusSrcColor",_hx_index:7,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusDstAlpha: {_hx_name:"OneMinusDstAlpha",_hx_index:8,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusDstColor: {_hx_name:"OneMinusDstColor",_hx_index:9,__enum__:"h3d.mat.Blend",toString:$estr}
	,ConstantColor: {_hx_name:"ConstantColor",_hx_index:10,__enum__:"h3d.mat.Blend",toString:$estr}
	,ConstantAlpha: {_hx_name:"ConstantAlpha",_hx_index:11,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusConstantColor: {_hx_name:"OneMinusConstantColor",_hx_index:12,__enum__:"h3d.mat.Blend",toString:$estr}
	,OneMinusConstantAlpha: {_hx_name:"OneMinusConstantAlpha",_hx_index:13,__enum__:"h3d.mat.Blend",toString:$estr}
	,SrcAlphaSaturate: {_hx_name:"SrcAlphaSaturate",_hx_index:14,__enum__:"h3d.mat.Blend",toString:$estr}
};
h3d_mat_Blend.__constructs__ = [h3d_mat_Blend.One,h3d_mat_Blend.Zero,h3d_mat_Blend.SrcAlpha,h3d_mat_Blend.SrcColor,h3d_mat_Blend.DstAlpha,h3d_mat_Blend.DstColor,h3d_mat_Blend.OneMinusSrcAlpha,h3d_mat_Blend.OneMinusSrcColor,h3d_mat_Blend.OneMinusDstAlpha,h3d_mat_Blend.OneMinusDstColor,h3d_mat_Blend.ConstantColor,h3d_mat_Blend.ConstantAlpha,h3d_mat_Blend.OneMinusConstantColor,h3d_mat_Blend.OneMinusConstantAlpha,h3d_mat_Blend.SrcAlphaSaturate];
h3d_mat_Blend.__empty_constructs__ = [h3d_mat_Blend.One,h3d_mat_Blend.Zero,h3d_mat_Blend.SrcAlpha,h3d_mat_Blend.SrcColor,h3d_mat_Blend.DstAlpha,h3d_mat_Blend.DstColor,h3d_mat_Blend.OneMinusSrcAlpha,h3d_mat_Blend.OneMinusSrcColor,h3d_mat_Blend.OneMinusDstAlpha,h3d_mat_Blend.OneMinusDstColor,h3d_mat_Blend.ConstantColor,h3d_mat_Blend.ConstantAlpha,h3d_mat_Blend.OneMinusConstantColor,h3d_mat_Blend.OneMinusConstantAlpha,h3d_mat_Blend.SrcAlphaSaturate];
var h3d_mat_Compare = $hxEnums["h3d.mat.Compare"] = { __ename__:true,__constructs__:null
	,Always: {_hx_name:"Always",_hx_index:0,__enum__:"h3d.mat.Compare",toString:$estr}
	,Never: {_hx_name:"Never",_hx_index:1,__enum__:"h3d.mat.Compare",toString:$estr}
	,Equal: {_hx_name:"Equal",_hx_index:2,__enum__:"h3d.mat.Compare",toString:$estr}
	,NotEqual: {_hx_name:"NotEqual",_hx_index:3,__enum__:"h3d.mat.Compare",toString:$estr}
	,Greater: {_hx_name:"Greater",_hx_index:4,__enum__:"h3d.mat.Compare",toString:$estr}
	,GreaterEqual: {_hx_name:"GreaterEqual",_hx_index:5,__enum__:"h3d.mat.Compare",toString:$estr}
	,Less: {_hx_name:"Less",_hx_index:6,__enum__:"h3d.mat.Compare",toString:$estr}
	,LessEqual: {_hx_name:"LessEqual",_hx_index:7,__enum__:"h3d.mat.Compare",toString:$estr}
};
h3d_mat_Compare.__constructs__ = [h3d_mat_Compare.Always,h3d_mat_Compare.Never,h3d_mat_Compare.Equal,h3d_mat_Compare.NotEqual,h3d_mat_Compare.Greater,h3d_mat_Compare.GreaterEqual,h3d_mat_Compare.Less,h3d_mat_Compare.LessEqual];
h3d_mat_Compare.__empty_constructs__ = [h3d_mat_Compare.Always,h3d_mat_Compare.Never,h3d_mat_Compare.Equal,h3d_mat_Compare.NotEqual,h3d_mat_Compare.Greater,h3d_mat_Compare.GreaterEqual,h3d_mat_Compare.Less,h3d_mat_Compare.LessEqual];
var h3d_mat_StencilOp = $hxEnums["h3d.mat.StencilOp"] = { __ename__:true,__constructs__:null
	,Keep: {_hx_name:"Keep",_hx_index:0,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Zero: {_hx_name:"Zero",_hx_index:1,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Replace: {_hx_name:"Replace",_hx_index:2,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Increment: {_hx_name:"Increment",_hx_index:3,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,IncrementWrap: {_hx_name:"IncrementWrap",_hx_index:4,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Decrement: {_hx_name:"Decrement",_hx_index:5,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,DecrementWrap: {_hx_name:"DecrementWrap",_hx_index:6,__enum__:"h3d.mat.StencilOp",toString:$estr}
	,Invert: {_hx_name:"Invert",_hx_index:7,__enum__:"h3d.mat.StencilOp",toString:$estr}
};
h3d_mat_StencilOp.__constructs__ = [h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Zero,h3d_mat_StencilOp.Replace,h3d_mat_StencilOp.Increment,h3d_mat_StencilOp.IncrementWrap,h3d_mat_StencilOp.Decrement,h3d_mat_StencilOp.DecrementWrap,h3d_mat_StencilOp.Invert];
h3d_mat_StencilOp.__empty_constructs__ = [h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Zero,h3d_mat_StencilOp.Replace,h3d_mat_StencilOp.Increment,h3d_mat_StencilOp.IncrementWrap,h3d_mat_StencilOp.Decrement,h3d_mat_StencilOp.DecrementWrap,h3d_mat_StencilOp.Invert];
var h3d_mat_MipMap = $hxEnums["h3d.mat.MipMap"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.mat.MipMap",toString:$estr}
	,Nearest: {_hx_name:"Nearest",_hx_index:1,__enum__:"h3d.mat.MipMap",toString:$estr}
	,Linear: {_hx_name:"Linear",_hx_index:2,__enum__:"h3d.mat.MipMap",toString:$estr}
};
h3d_mat_MipMap.__constructs__ = [h3d_mat_MipMap.None,h3d_mat_MipMap.Nearest,h3d_mat_MipMap.Linear];
h3d_mat_MipMap.__empty_constructs__ = [h3d_mat_MipMap.None,h3d_mat_MipMap.Nearest,h3d_mat_MipMap.Linear];
var h3d_mat_Filter = $hxEnums["h3d.mat.Filter"] = { __ename__:true,__constructs__:null
	,Nearest: {_hx_name:"Nearest",_hx_index:0,__enum__:"h3d.mat.Filter",toString:$estr}
	,Linear: {_hx_name:"Linear",_hx_index:1,__enum__:"h3d.mat.Filter",toString:$estr}
};
h3d_mat_Filter.__constructs__ = [h3d_mat_Filter.Nearest,h3d_mat_Filter.Linear];
h3d_mat_Filter.__empty_constructs__ = [h3d_mat_Filter.Nearest,h3d_mat_Filter.Linear];
var h3d_mat_Wrap = $hxEnums["h3d.mat.Wrap"] = { __ename__:true,__constructs__:null
	,Clamp: {_hx_name:"Clamp",_hx_index:0,__enum__:"h3d.mat.Wrap",toString:$estr}
	,Repeat: {_hx_name:"Repeat",_hx_index:1,__enum__:"h3d.mat.Wrap",toString:$estr}
};
h3d_mat_Wrap.__constructs__ = [h3d_mat_Wrap.Clamp,h3d_mat_Wrap.Repeat];
h3d_mat_Wrap.__empty_constructs__ = [h3d_mat_Wrap.Clamp,h3d_mat_Wrap.Repeat];
var h3d_mat_Operation = $hxEnums["h3d.mat.Operation"] = { __ename__:true,__constructs__:null
	,Add: {_hx_name:"Add",_hx_index:0,__enum__:"h3d.mat.Operation",toString:$estr}
	,Sub: {_hx_name:"Sub",_hx_index:1,__enum__:"h3d.mat.Operation",toString:$estr}
	,ReverseSub: {_hx_name:"ReverseSub",_hx_index:2,__enum__:"h3d.mat.Operation",toString:$estr}
	,Min: {_hx_name:"Min",_hx_index:3,__enum__:"h3d.mat.Operation",toString:$estr}
	,Max: {_hx_name:"Max",_hx_index:4,__enum__:"h3d.mat.Operation",toString:$estr}
};
h3d_mat_Operation.__constructs__ = [h3d_mat_Operation.Add,h3d_mat_Operation.Sub,h3d_mat_Operation.ReverseSub,h3d_mat_Operation.Min,h3d_mat_Operation.Max];
h3d_mat_Operation.__empty_constructs__ = [h3d_mat_Operation.Add,h3d_mat_Operation.Sub,h3d_mat_Operation.ReverseSub,h3d_mat_Operation.Min,h3d_mat_Operation.Max];
var h3d_mat_TextureFlags = $hxEnums["h3d.mat.TextureFlags"] = { __ename__:true,__constructs__:null
	,Target: {_hx_name:"Target",_hx_index:0,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Cube: {_hx_name:"Cube",_hx_index:1,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,MipMapped: {_hx_name:"MipMapped",_hx_index:2,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,ManualMipMapGen: {_hx_name:"ManualMipMapGen",_hx_index:3,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,IsNPOT: {_hx_name:"IsNPOT",_hx_index:4,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,NoAlloc: {_hx_name:"NoAlloc",_hx_index:5,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Dynamic: {_hx_name:"Dynamic",_hx_index:6,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,AlphaPremultiplied: {_hx_name:"AlphaPremultiplied",_hx_index:7,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,WasCleared: {_hx_name:"WasCleared",_hx_index:8,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Loading: {_hx_name:"Loading",_hx_index:9,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,Serialize: {_hx_name:"Serialize",_hx_index:10,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,IsArray: {_hx_name:"IsArray",_hx_index:11,__enum__:"h3d.mat.TextureFlags",toString:$estr}
	,AsyncLoading: {_hx_name:"AsyncLoading",_hx_index:12,__enum__:"h3d.mat.TextureFlags",toString:$estr}
};
h3d_mat_TextureFlags.__constructs__ = [h3d_mat_TextureFlags.Target,h3d_mat_TextureFlags.Cube,h3d_mat_TextureFlags.MipMapped,h3d_mat_TextureFlags.ManualMipMapGen,h3d_mat_TextureFlags.IsNPOT,h3d_mat_TextureFlags.NoAlloc,h3d_mat_TextureFlags.Dynamic,h3d_mat_TextureFlags.AlphaPremultiplied,h3d_mat_TextureFlags.WasCleared,h3d_mat_TextureFlags.Loading,h3d_mat_TextureFlags.Serialize,h3d_mat_TextureFlags.IsArray,h3d_mat_TextureFlags.AsyncLoading];
h3d_mat_TextureFlags.__empty_constructs__ = [h3d_mat_TextureFlags.Target,h3d_mat_TextureFlags.Cube,h3d_mat_TextureFlags.MipMapped,h3d_mat_TextureFlags.ManualMipMapGen,h3d_mat_TextureFlags.IsNPOT,h3d_mat_TextureFlags.NoAlloc,h3d_mat_TextureFlags.Dynamic,h3d_mat_TextureFlags.AlphaPremultiplied,h3d_mat_TextureFlags.WasCleared,h3d_mat_TextureFlags.Loading,h3d_mat_TextureFlags.Serialize,h3d_mat_TextureFlags.IsArray,h3d_mat_TextureFlags.AsyncLoading];
class h3d_mat_Defaults {
	static get_shadowShader() {
		let s = h3d_mat_Defaults.shadowShader;
		if(s == null) {
			s = new h3d_shader_Shadow();
			h3d_mat_Defaults.set_shadowShader(s);
			h3d_mat_Defaults.shadowShader.setPriority(-1);
		}
		return s;
	}
	static set_shadowShader(s) {
		return h3d_mat_Defaults.shadowShader = s;
	}
}
$hxClasses["h3d.mat.Defaults"] = h3d_mat_Defaults;
h3d_mat_Defaults.__name__ = "h3d.mat.Defaults";
var h3d_mat_DepthFormat = $hxEnums["h3d.mat.DepthFormat"] = { __ename__:true,__constructs__:null
	,Depth16: {_hx_name:"Depth16",_hx_index:0,__enum__:"h3d.mat.DepthFormat",toString:$estr}
	,Depth24: {_hx_name:"Depth24",_hx_index:1,__enum__:"h3d.mat.DepthFormat",toString:$estr}
	,Depth24Stencil8: {_hx_name:"Depth24Stencil8",_hx_index:2,__enum__:"h3d.mat.DepthFormat",toString:$estr}
};
h3d_mat_DepthFormat.__constructs__ = [h3d_mat_DepthFormat.Depth16,h3d_mat_DepthFormat.Depth24,h3d_mat_DepthFormat.Depth24Stencil8];
h3d_mat_DepthFormat.__empty_constructs__ = [h3d_mat_DepthFormat.Depth16,h3d_mat_DepthFormat.Depth24,h3d_mat_DepthFormat.Depth24Stencil8];
class h3d_mat_DepthBuffer {
	constructor(width,height,format) {
		this.width = width;
		this.height = height;
		this.format = format;
		if(width > 0) {
			this.alloc();
		}
	}
	hasStencil() {
		switch(this.format._hx_index) {
		case 0:case 1:
			return false;
		case 2:
			return true;
		}
	}
	alloc() {
		h3d_Engine.CURRENT.mem.allocDepth(this);
	}
	dispose() {
		if(this.b != null) {
			h3d_Engine.CURRENT.mem.deleteDepth(this);
			this.b = null;
		}
	}
	isDisposed() {
		return this.b == null;
	}
	static getDefault() {
		return h3d_Engine.CURRENT.driver.getDefaultDepthBuffer();
	}
}
$hxClasses["h3d.mat.DepthBuffer"] = h3d_mat_DepthBuffer;
h3d_mat_DepthBuffer.__name__ = "h3d.mat.DepthBuffer";
Object.assign(h3d_mat_DepthBuffer.prototype, {
	__class__: h3d_mat_DepthBuffer
	,b: null
	,width: null
	,height: null
	,format: null
});
class h3d_mat_Material extends h3d_mat_BaseMaterial {
	constructor(texture) {
		h3d_mat_BaseMaterial._hx_skip_constructor = true;
		super();
		h3d_mat_BaseMaterial._hx_skip_constructor = false;
		this._hx_constructor(texture);
	}
	_hx_constructor(texture) {
		this.mshader = new h3d_shader_BaseMesh();
		this.set_blendMode(h2d_BlendMode.None);
		super._hx_constructor(this.mshader);
		this.set_texture(texture);
	}
	set_castShadows(v) {
		if(this.castShadows == v) {
			return v;
		}
		if(this.passes != null) {
			if(v) {
				this.addPass(new h3d_mat_Pass("shadow",null,this.passes)).set_isStatic(this.staticShadows);
			} else {
				this.removePass(this.getPass("shadow"));
			}
		}
		return this.castShadows = v;
	}
	set_receiveShadows(v) {
		if(v == this.receiveShadows) {
			return v;
		}
		if(this.passes != null) {
			let shadows = h3d_mat_Defaults.get_shadowShader();
			if(v) {
				this.passes.addShader(shadows);
			} else {
				this.passes.removeShader(shadows);
			}
		}
		return this.receiveShadows = v;
	}
	clone(m) {
		let m1 = m == null ? new h3d_mat_Material() : m;
		super.clone(m1);
		m1.set_castShadows(this.castShadows);
		m1.set_receiveShadows(this.receiveShadows);
		m1.set_texture(this.get_texture());
		m1.set_specularTexture(this.get_specularTexture());
		m1.set_normalMap(this.get_normalMap());
		if(this.textureShader != null) {
			let _this = m1.textureShader;
			_this.constModified = true;
			_this.additive__ = this.textureShader.additive__;
			let _this1 = m1.textureShader;
			_this1.constModified = true;
			_this1.killAlpha__ = this.textureShader.killAlpha__;
			m1.textureShader.killAlphaThreshold__ = this.textureShader.killAlphaThreshold__;
		}
		m1.mshader.color__ = this.mshader.color__;
		m1.set_blendMode(this.blendMode);
		return m1;
	}
	set_blendMode(v) {
		if(this.passes != null) {
			this.passes.setBlendMode(v);
			switch(v._hx_index) {
			case 0:
				this.passes.set_depthWrite(true);
				this.passes.setPassName("default");
				break;
			case 1:
				this.passes.set_depthWrite(true);
				this.passes.setPassName("alpha");
				break;
			case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:
				this.passes.set_depthWrite(false);
				this.passes.setPassName("additive");
				break;
			}
		}
		return this.blendMode = v;
	}
	get_specularTexture() {
		if(this.specularShader == null) {
			return null;
		} else {
			return this.specularShader.texture__;
		}
	}
	get_texture() {
		if(this.textureShader == null) {
			return null;
		} else {
			return this.textureShader.texture__;
		}
	}
	set_texture(t) {
		if(t == null) {
			if(this.textureShader != null) {
				this.passes.removeShader(this.textureShader);
				this.textureShader = null;
			}
		} else {
			if(this.textureShader == null) {
				this.textureShader = new h3d_shader_Texture();
				this.passes.addShader(this.textureShader);
			}
			this.textureShader.texture__ = t;
		}
		return t;
	}
	get_normalMap() {
		if(this.normalShader == null) {
			return null;
		} else {
			return this.normalShader.texture__;
		}
	}
	set_normalMap(t) {
		if(t == null) {
			if(this.normalShader != null) {
				this.passes.removeShader(this.normalShader);
				this.normalShader = null;
			}
		} else {
			if(this.normalShader == null) {
				this.normalShader = new h3d_shader_NormalMap();
				if(this.textureShader != null) {
					this.passes.addShaderAtIndex(this.normalShader,this.passes.getShaderIndex(this.textureShader) + 1);
				} else {
					this.passes.addShader(this.normalShader);
				}
			}
			this.normalShader.texture__ = t;
		}
		return t;
	}
	set_specularTexture(t) {
		if(t == null) {
			if(this.specularShader != null) {
				this.passes.removeShader(this.specularShader);
				this.specularShader = null;
			}
		} else {
			if(this.specularShader == null) {
				this.specularShader = new h3d_shader_SpecularTexture();
				this.passes.addShader(this.specularShader);
			}
			this.specularShader.texture__ = t;
		}
		return t;
	}
	getDefaultProps(type) {
		let props;
		if(type == null) {
			props = { kind : "Opaque", shadows : true, culling : true, light : true};
		} else {
			switch(type) {
			case "particles3D":case "trail3D":
				props = { kind : "Alpha", shadows : false, culling : false, light : true};
				break;
			case "ui":
				props = { kind : "Alpha", shadows : false, culling : false, light : false};
				break;
			default:
				props = { kind : "Opaque", shadows : true, culling : true, light : true};
			}
		}
		return props;
	}
	refreshProps() {
		if(this.props == null || this.passes == null) {
			return;
		}
		let props = this.props;
		switch(props.kind) {
		case "Add":
			this.set_blendMode(h2d_BlendMode.Add);
			break;
		case "Alpha":
			this.set_blendMode(h2d_BlendMode.Alpha);
			break;
		case "AlphaKill":case "Hidden":case "Opaque":
			this.set_blendMode(h2d_BlendMode.None);
			break;
		case "SoftAdd":
			this.set_blendMode(h2d_BlendMode.SoftAdd);
			break;
		}
		let tshader = this.textureShader;
		if(tshader != null) {
			tshader.constModified = true;
			tshader.killAlpha__ = props.kind == "AlphaKill";
			tshader.killAlphaThreshold__ = 0.5;
		}
		this.passes.set_culling(props.kind == "Hidden" ? h3d_mat_Face.Both : props.culling ? h3d_mat_Face.Back : h3d_mat_Face.None);
		this.passes.set_enableLights(props.light);
		let v = props.shadows;
		this.set_castShadows(v);
		this.set_receiveShadows(v);
		if(this.castShadows && this.receiveShadows) {
			this.getPass("shadow").set_culling(this.passes.culling);
		}
	}
	static create(tex) {
		let mat = h3d_mat_MaterialSetup.current.createMaterial();
		mat.set_texture(tex);
		mat.set_props(mat.getDefaultProps());
		return mat;
	}
}
$hxClasses["h3d.mat.Material"] = h3d_mat_Material;
h3d_mat_Material.__name__ = "h3d.mat.Material";
h3d_mat_Material.__super__ = h3d_mat_BaseMaterial;
Object.assign(h3d_mat_Material.prototype, {
	__class__: h3d_mat_Material
	,mshader: null
	,normalShader: null
	,castShadows: null
	,receiveShadows: null
	,staticShadows: null
	,textureShader: null
	,specularShader: null
	,blendMode: null
});
class h3d_mat_MaterialDatabase {
	constructor() {
	}
}
$hxClasses["h3d.mat.MaterialDatabase"] = h3d_mat_MaterialDatabase;
h3d_mat_MaterialDatabase.__name__ = "h3d.mat.MaterialDatabase";
Object.assign(h3d_mat_MaterialDatabase.prototype, {
	__class__: h3d_mat_MaterialDatabase
});
class h3d_mat_MaterialSetup {
	constructor(name) {
		if(this.database == null) {
			this.database = new h3d_mat_MaterialDatabase();
		}
		this.name = name;
	}
	createRenderer() {
		return new h3d_scene_fwd_Renderer();
	}
	createLightSystem() {
		return new h3d_scene_fwd_LightSystem();
	}
	createMaterial() {
		return new h3d_mat_Material();
	}
}
$hxClasses["h3d.mat.MaterialSetup"] = h3d_mat_MaterialSetup;
h3d_mat_MaterialSetup.__name__ = "h3d.mat.MaterialSetup";
Object.assign(h3d_mat_MaterialSetup.prototype, {
	__class__: h3d_mat_MaterialSetup
	,name: null
	,database: null
});
class h3d_mat_Pass {
	constructor(name,shaders,parent) {
		this.layer = 0;
		this.culled = false;
		this.bits = 0;
		this.parentPass = parent;
		this.shaders = shaders;
		this.setPassName(name);
		this.set_culling(h3d_mat_Face.Back);
		let src = h3d_mat_Blend.One;
		let dst = h3d_mat_Blend.Zero;
		this.set_blendSrc(src);
		this.set_blendAlphaSrc(src);
		this.set_blendDst(dst);
		this.set_blendAlphaDst(dst);
		this.depth(true,h3d_mat_Compare.Less);
		this.set_blendOp(this.set_blendAlphaOp(h3d_mat_Operation.Add));
		this.colorMask = 15;
	}
	load(p) {
		this.name = p.name;
		this.passId = p.passId;
		this.bits = p.bits;
		this.set_enableLights(p.enableLights);
		this.set_dynamicParameters(p.dynamicParameters);
		this.set_culling(p.culling);
		this.set_depthWrite(p.depthWrite);
		this.set_depthTest(p.depthTest);
		this.set_blendSrc(p.blendSrc);
		this.set_blendDst(p.blendDst);
		this.set_blendOp(p.blendOp);
		this.set_blendAlphaSrc(p.blendAlphaSrc);
		this.set_blendAlphaDst(p.blendAlphaDst);
		this.set_blendAlphaOp(p.blendAlphaOp);
		this.colorMask = p.colorMask;
		if(p.stencil != null) {
			if(this.stencil == null) {
				this.stencil = new h3d_mat_Stencil();
			}
			this.stencil.load(p.stencil);
		}
	}
	setPassName(name) {
		this.name = name;
		this.passId = hxsl_Globals.allocID(name);
	}
	setBlendMode(b) {
		this.set_blendOp(h3d_mat_Operation.Add);
		this.set_blendAlphaOp(h3d_mat_Operation.Add);
		switch(b._hx_index) {
		case 0:
			let src = h3d_mat_Blend.One;
			let dst = h3d_mat_Blend.Zero;
			this.set_blendSrc(src);
			this.set_blendAlphaSrc(src);
			this.set_blendDst(dst);
			this.set_blendAlphaDst(dst);
			break;
		case 1:
			let src1 = h3d_mat_Blend.SrcAlpha;
			let dst1 = h3d_mat_Blend.OneMinusSrcAlpha;
			this.set_blendSrc(src1);
			this.set_blendAlphaSrc(src1);
			this.set_blendDst(dst1);
			this.set_blendAlphaDst(dst1);
			this.set_blendAlphaSrc(h3d_mat_Blend.One);
			break;
		case 2:
			let src2 = h3d_mat_Blend.SrcAlpha;
			let dst2 = h3d_mat_Blend.One;
			this.set_blendSrc(src2);
			this.set_blendAlphaSrc(src2);
			this.set_blendDst(dst2);
			this.set_blendAlphaDst(dst2);
			this.set_blendAlphaSrc(h3d_mat_Blend.One);
			break;
		case 3:
			let src3 = h3d_mat_Blend.One;
			let dst3 = h3d_mat_Blend.OneMinusSrcAlpha;
			this.set_blendSrc(src3);
			this.set_blendAlphaSrc(src3);
			this.set_blendDst(dst3);
			this.set_blendAlphaDst(dst3);
			break;
		case 4:
			let src4 = h3d_mat_Blend.OneMinusDstColor;
			let dst4 = h3d_mat_Blend.One;
			this.set_blendSrc(src4);
			this.set_blendAlphaSrc(src4);
			this.set_blendDst(dst4);
			this.set_blendAlphaDst(dst4);
			this.set_blendAlphaSrc(h3d_mat_Blend.One);
			break;
		case 5:
			let src5 = h3d_mat_Blend.DstColor;
			let dst5 = h3d_mat_Blend.Zero;
			this.set_blendSrc(src5);
			this.set_blendAlphaSrc(src5);
			this.set_blendDst(dst5);
			this.set_blendAlphaDst(dst5);
			this.set_blendAlphaSrc(h3d_mat_Blend.One);
			break;
		case 6:
			let src6 = h3d_mat_Blend.DstColor;
			let dst6 = h3d_mat_Blend.OneMinusSrcAlpha;
			this.set_blendSrc(src6);
			this.set_blendAlphaSrc(src6);
			this.set_blendDst(dst6);
			this.set_blendAlphaDst(dst6);
			break;
		case 7:
			let src7 = h3d_mat_Blend.Zero;
			let dst7 = h3d_mat_Blend.OneMinusSrcColor;
			this.set_blendSrc(src7);
			this.set_blendAlphaSrc(src7);
			this.set_blendDst(dst7);
			this.set_blendAlphaDst(dst7);
			break;
		case 8:
			let src8 = h3d_mat_Blend.One;
			let dst8 = h3d_mat_Blend.OneMinusSrcColor;
			this.set_blendSrc(src8);
			this.set_blendAlphaSrc(src8);
			this.set_blendDst(dst8);
			this.set_blendAlphaDst(dst8);
			break;
		case 9:
			let src9 = h3d_mat_Blend.SrcAlpha;
			let dst9 = h3d_mat_Blend.One;
			this.set_blendSrc(src9);
			this.set_blendAlphaSrc(src9);
			this.set_blendDst(dst9);
			this.set_blendAlphaDst(dst9);
			this.set_blendOp(h3d_mat_Operation.ReverseSub);
			this.set_blendAlphaOp(h3d_mat_Operation.ReverseSub);
			break;
		case 10:
			let src10 = h3d_mat_Blend.One;
			let dst10 = h3d_mat_Blend.One;
			this.set_blendSrc(src10);
			this.set_blendAlphaSrc(src10);
			this.set_blendDst(dst10);
			this.set_blendAlphaDst(dst10);
			this.set_blendAlphaOp(h3d_mat_Operation.Max);
			this.set_blendOp(h3d_mat_Operation.Max);
			break;
		case 11:
			let src11 = h3d_mat_Blend.One;
			let dst11 = h3d_mat_Blend.One;
			this.set_blendSrc(src11);
			this.set_blendAlphaSrc(src11);
			this.set_blendDst(dst11);
			this.set_blendAlphaDst(dst11);
			this.set_blendAlphaOp(h3d_mat_Operation.Min);
			this.set_blendOp(h3d_mat_Operation.Min);
			break;
		}
	}
	depth(write,test) {
		this.set_depthWrite(write);
		this.set_depthTest(test);
	}
	setColorMask(r,g,b,a) {
		this.colorMask = (r ? 1 : 0) | (g ? 2 : 0) | (b ? 4 : 0) | (a ? 8 : 0);
	}
	addShader(s) {
		if(s == null) {
			return null;
		}
		this.shaders = hxsl_ShaderList.addSort(s,this.shaders);
		return s;
	}
	addSelfShader(s) {
		if(s == null) {
			return null;
		}
		this.selfShadersChanged = true;
		this.selfShaders = hxsl_ShaderList.addSort(s,this.selfShaders);
		return s;
	}
	addShaderAtIndex(s,index) {
		let prev = null;
		let cur = this.shaders;
		while(index > 0 && cur != this.parentShaders) {
			prev = cur;
			cur = cur.next;
			--index;
		}
		if(prev == null) {
			this.shaders = new hxsl_ShaderList(s,cur);
		} else {
			prev.next = new hxsl_ShaderList(s,cur);
		}
		return s;
	}
	getShaderIndex(s) {
		let index = 0;
		let cur = this.shaders;
		while(cur != this.parentShaders) {
			if(cur.s == s) {
				return index;
			}
			cur = cur.next;
			++index;
		}
		return -1;
	}
	removeShader(s) {
		let sl = this.shaders;
		let prev = null;
		while(sl != null) {
			if(sl.s == s) {
				if(prev == null) {
					this.shaders = sl.next;
				} else {
					prev.next = sl.next;
				}
				return true;
			}
			prev = sl;
			sl = sl.next;
		}
		sl = this.selfShaders;
		prev = null;
		while(sl != null) {
			if(sl.s == s) {
				if(prev == null) {
					this.selfShaders = sl.next;
				} else {
					prev.next = sl.next;
				}
				return true;
			}
			prev = sl;
			sl = sl.next;
		}
		return false;
	}
	getShader(t) {
		let s = this._getShader(t,this.shaders);
		if(s != null) {
			return s;
		} else {
			return this._getShader(t,this.selfShaders);
		}
	}
	_getShader(t,s) {
		while(s != null && s != this.parentShaders) {
			let value = s.s;
			let sh = js_Boot.__downcastCheck(value,t) ? value : null;
			if(sh != null) {
				return sh;
			}
			s = s.next;
		}
		return null;
	}
	selfShadersRec(rebuild) {
		if(this.selfShaders == null) {
			return this.shaders;
		}
		if(!this.selfShadersChanged && !rebuild && this.shaders == this.selfShadersCache) {
			return this.selfShaders;
		}
		let sl = this.selfShaders;
		let prev = null;
		while(sl != null && sl != this.selfShadersCache) {
			prev = sl;
			sl = sl.next;
		}
		this.selfShadersCache = this.shaders;
		if(prev != null) {
			prev.next = this.selfShadersCache;
		} else {
			this.selfShaders = this.shaders;
		}
		return this.selfShaders;
	}
	getShadersRec() {
		if(this.parentPass == null || this.parentShaders == this.parentPass.shaders) {
			return this.selfShadersRec(false);
		}
		let s = this.shaders;
		let prev = null;
		while(s != null && s != this.parentShaders) {
			prev = s;
			s = s.next;
		}
		this.parentShaders = this.parentPass.shaders;
		if(prev == null) {
			this.shaders = this.parentShaders;
		} else {
			prev.next = this.parentShaders;
		}
		return this.selfShadersRec(true);
	}
	clone() {
		let p = new h3d_mat_Pass(this.name,this.shaders.clone());
		p.selfShaders = this.selfShaders;
		p.bits = this.bits;
		p.set_enableLights(this.enableLights);
		if(this.stencil != null) {
			p.stencil = this.stencil.clone();
		}
		return p;
	}
	set_enableLights(v) {
		this.flags = this.flags & -2 | (v ? 1 : 0);
		return this.enableLights = v;
	}
	set_dynamicParameters(v) {
		this.flags = this.flags & -3 | (v ? 1 : 0) << 1;
		return this.dynamicParameters = v;
	}
	set_isStatic(v) {
		this.flags = this.flags & -5 | (v ? 1 : 0) << 2;
		return this.isStatic = v;
	}
	set_batchMode(v) {
		this.flags = this.flags & -9 | (v ? 1 : 0) << 3;
		return this.batchMode = v;
	}
	set_culling(v) {
		this.bits = this.bits & -4 | v._hx_index;
		return this.culling = v;
	}
	set_depthWrite(v) {
		this.bits = this.bits & -5 | (v ? 1 : 0) << 2;
		return this.depthWrite = v;
	}
	set_depthTest(v) {
		this.bits = this.bits & -57 | v._hx_index << 3;
		return this.depthTest = v;
	}
	set_blendSrc(v) {
		this.bits = this.bits & -961 | v._hx_index << 6;
		return this.blendSrc = v;
	}
	set_blendDst(v) {
		this.bits = this.bits & -15361 | v._hx_index << 10;
		return this.blendDst = v;
	}
	set_blendAlphaSrc(v) {
		this.bits = this.bits & -245761 | v._hx_index << 14;
		return this.blendAlphaSrc = v;
	}
	set_blendAlphaDst(v) {
		this.bits = this.bits & -3932161 | v._hx_index << 18;
		return this.blendAlphaDst = v;
	}
	set_blendOp(v) {
		this.bits = this.bits & -29360129 | v._hx_index << 22;
		return this.blendOp = v;
	}
	set_blendAlphaOp(v) {
		this.bits = this.bits & -234881025 | v._hx_index << 25;
		return this.blendAlphaOp = v;
	}
	set_wireframe(v) {
		this.bits = this.bits & -268435457 | (v ? 1 : 0) << 28;
		return this.wireframe = v;
	}
}
$hxClasses["h3d.mat.Pass"] = h3d_mat_Pass;
h3d_mat_Pass.__name__ = "h3d.mat.Pass";
Object.assign(h3d_mat_Pass.prototype, {
	__class__: h3d_mat_Pass
	,name: null
	,flags: null
	,passId: null
	,bits: null
	,parentPass: null
	,parentShaders: null
	,selfShaders: null
	,selfShadersChanged: null
	,selfShadersCache: null
	,shaders: null
	,nextPass: null
	,culled: null
	,enableLights: null
	,dynamicParameters: null
	,isStatic: null
	,batchMode: null
	,culling: null
	,depthWrite: null
	,depthTest: null
	,blendSrc: null
	,blendDst: null
	,blendAlphaSrc: null
	,blendAlphaDst: null
	,blendOp: null
	,blendAlphaOp: null
	,wireframe: null
	,colorMask: null
	,layer: null
	,stencil: null
});
class h3d_mat_Stencil {
	constructor() {
		this.opBits = 0;
		this.maskBits = 0;
		this.setOp(h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep);
		this.setFunc(h3d_mat_Compare.Always);
	}
	setFront(stfail,dpfail,pass) {
		this.set_frontSTfail(stfail);
		this.set_frontDPfail(dpfail);
		this.set_frontPass(pass);
	}
	setBack(stfail,dpfail,pass) {
		this.set_backSTfail(stfail);
		this.set_backDPfail(dpfail);
		this.set_backPass(pass);
	}
	setOp(stfail,dpfail,pass) {
		this.setFront(stfail,dpfail,pass);
		this.setBack(stfail,dpfail,pass);
	}
	setFunc(f,reference,readMask,writeMask) {
		if(writeMask == null) {
			writeMask = 255;
		}
		if(readMask == null) {
			readMask = 255;
		}
		if(reference == null) {
			reference = 0;
		}
		this.set_frontTest(this.set_backTest(f));
		this.set_reference(reference);
		this.set_readMask(readMask);
		this.set_writeMask(writeMask);
	}
	clone() {
		let s = new h3d_mat_Stencil();
		s.opBits = this.opBits;
		s.maskBits = this.maskBits;
		return s;
	}
	load(s) {
		this.opBits = s.opBits;
		this.maskBits = s.maskBits;
	}
	set_readMask(v) {
		this.maskBits = this.maskBits & -256 | v & 255;
		return this.readMask = v;
	}
	set_writeMask(v) {
		this.maskBits = this.maskBits & -65281 | (v & 255) << 8;
		return this.writeMask = v;
	}
	set_reference(v) {
		this.maskBits = this.maskBits & -16711681 | (v & 255) << 16;
		return this.reference = v;
	}
	set_frontTest(v) {
		this.opBits = this.opBits & -8 | v._hx_index;
		return this.frontTest = v;
	}
	set_frontPass(v) {
		this.opBits = this.opBits & -57 | v._hx_index << 3;
		return this.frontPass = v;
	}
	set_frontSTfail(v) {
		this.opBits = this.opBits & -449 | v._hx_index << 6;
		return this.frontSTfail = v;
	}
	set_frontDPfail(v) {
		this.opBits = this.opBits & -3585 | v._hx_index << 9;
		return this.frontDPfail = v;
	}
	set_backTest(v) {
		this.opBits = this.opBits & -28673 | v._hx_index << 12;
		return this.backTest = v;
	}
	set_backPass(v) {
		this.opBits = this.opBits & -229377 | v._hx_index << 15;
		return this.backPass = v;
	}
	set_backSTfail(v) {
		this.opBits = this.opBits & -1835009 | v._hx_index << 18;
		return this.backSTfail = v;
	}
	set_backDPfail(v) {
		this.opBits = this.opBits & -14680065 | v._hx_index << 21;
		return this.backDPfail = v;
	}
}
$hxClasses["h3d.mat.Stencil"] = h3d_mat_Stencil;
h3d_mat_Stencil.__name__ = "h3d.mat.Stencil";
Object.assign(h3d_mat_Stencil.prototype, {
	__class__: h3d_mat_Stencil
	,maskBits: null
	,opBits: null
	,readMask: null
	,writeMask: null
	,reference: null
	,frontTest: null
	,frontPass: null
	,frontSTfail: null
	,frontDPfail: null
	,backTest: null
	,backPass: null
	,backSTfail: null
	,backDPfail: null
});
var hxd_PixelFormat = $hxEnums["hxd.PixelFormat"] = { __ename__:true,__constructs__:null
	,ARGB: {_hx_name:"ARGB",_hx_index:0,__enum__:"hxd.PixelFormat",toString:$estr}
	,BGRA: {_hx_name:"BGRA",_hx_index:1,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA: {_hx_name:"RGBA",_hx_index:2,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA16F: {_hx_name:"RGBA16F",_hx_index:3,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA32F: {_hx_name:"RGBA32F",_hx_index:4,__enum__:"hxd.PixelFormat",toString:$estr}
	,R8: {_hx_name:"R8",_hx_index:5,__enum__:"hxd.PixelFormat",toString:$estr}
	,R16F: {_hx_name:"R16F",_hx_index:6,__enum__:"hxd.PixelFormat",toString:$estr}
	,R32F: {_hx_name:"R32F",_hx_index:7,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG8: {_hx_name:"RG8",_hx_index:8,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG16F: {_hx_name:"RG16F",_hx_index:9,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG32F: {_hx_name:"RG32F",_hx_index:10,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB8: {_hx_name:"RGB8",_hx_index:11,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB16F: {_hx_name:"RGB16F",_hx_index:12,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB32F: {_hx_name:"RGB32F",_hx_index:13,__enum__:"hxd.PixelFormat",toString:$estr}
	,SRGB: {_hx_name:"SRGB",_hx_index:14,__enum__:"hxd.PixelFormat",toString:$estr}
	,SRGB_ALPHA: {_hx_name:"SRGB_ALPHA",_hx_index:15,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB10A2: {_hx_name:"RGB10A2",_hx_index:16,__enum__:"hxd.PixelFormat",toString:$estr}
	,RG11B10UF: {_hx_name:"RG11B10UF",_hx_index:17,__enum__:"hxd.PixelFormat",toString:$estr}
	,R16U: {_hx_name:"R16U",_hx_index:18,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGB16U: {_hx_name:"RGB16U",_hx_index:19,__enum__:"hxd.PixelFormat",toString:$estr}
	,RGBA16U: {_hx_name:"RGBA16U",_hx_index:20,__enum__:"hxd.PixelFormat",toString:$estr}
	,S3TC: ($_=function(v) { return {_hx_index:21,v:v,__enum__:"hxd.PixelFormat",toString:$estr}; },$_._hx_name="S3TC",$_.__params__ = ["v"],$_)
};
hxd_PixelFormat.__constructs__ = [hxd_PixelFormat.ARGB,hxd_PixelFormat.BGRA,hxd_PixelFormat.RGBA,hxd_PixelFormat.RGBA16F,hxd_PixelFormat.RGBA32F,hxd_PixelFormat.R8,hxd_PixelFormat.R16F,hxd_PixelFormat.R32F,hxd_PixelFormat.RG8,hxd_PixelFormat.RG16F,hxd_PixelFormat.RG32F,hxd_PixelFormat.RGB8,hxd_PixelFormat.RGB16F,hxd_PixelFormat.RGB32F,hxd_PixelFormat.SRGB,hxd_PixelFormat.SRGB_ALPHA,hxd_PixelFormat.RGB10A2,hxd_PixelFormat.RG11B10UF,hxd_PixelFormat.R16U,hxd_PixelFormat.RGB16U,hxd_PixelFormat.RGBA16U,hxd_PixelFormat.S3TC];
hxd_PixelFormat.__empty_constructs__ = [hxd_PixelFormat.ARGB,hxd_PixelFormat.BGRA,hxd_PixelFormat.RGBA,hxd_PixelFormat.RGBA16F,hxd_PixelFormat.RGBA32F,hxd_PixelFormat.R8,hxd_PixelFormat.R16F,hxd_PixelFormat.R32F,hxd_PixelFormat.RG8,hxd_PixelFormat.RG16F,hxd_PixelFormat.RG32F,hxd_PixelFormat.RGB8,hxd_PixelFormat.RGB16F,hxd_PixelFormat.RGB32F,hxd_PixelFormat.SRGB,hxd_PixelFormat.SRGB_ALPHA,hxd_PixelFormat.RGB10A2,hxd_PixelFormat.RG11B10UF,hxd_PixelFormat.R16U,hxd_PixelFormat.RGB16U,hxd_PixelFormat.RGBA16U];
class h3d_mat_Texture {
	constructor(w,h,flags,format) {
		if(h3d_mat_Texture._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(w,h,flags,format);
	}
	_hx_constructor(w,h,flags,format) {
		let engine = h3d_Engine.CURRENT;
		this.mem = engine.mem;
		if(format == null) {
			format = h3d_mat_Texture.nativeFormat;
		}
		this.id = ++h3d_mat_Texture.UID;
		this.format = format;
		this.flags = 0;
		if(flags != null) {
			let _g = 0;
			while(_g < flags.length) {
				let f = flags[_g];
				++_g;
				this.flags |= 1 << f._hx_index;
			}
		}
		let tw = 1;
		let th = 1;
		while(tw < w) tw <<= 1;
		while(th < h) th <<= 1;
		if(tw != w || th != h) {
			this.flags |= 16;
		}
		this.width = w;
		this.height = h;
		if((this.flags & 4) != 0) {
			this.set_mipMap(h3d_mat_Texture.TRILINEAR_FILTERING_ENABLED ? h3d_mat_MipMap.Linear : h3d_mat_MipMap.Nearest);
		} else {
			this.set_mipMap(h3d_mat_MipMap.None);
		}
		this.set_filter(h3d_mat_Filter.Linear);
		this.set_wrap(h3d_mat_Texture.DEFAULT_WRAP);
		this.bits &= 32767;
		if((this.flags & 32) == 0) {
			this.alloc();
		}
	}
	set_lastFrame(lf) {
		if(this._lastFrame != h3d_mat_Texture.PREVENT_AUTO_DISPOSE) {
			this._lastFrame = lf;
		}
		return this._lastFrame;
	}
	get_lastFrame() {
		return this._lastFrame;
	}
	get_mipLevels() {
		if((this.flags & 4) == 0) {
			return 1;
		}
		if(this.customMipLevels > 0) {
			return this.customMipLevels;
		}
		let lv = 1;
		let w = this.width;
		let h = this.height;
		while(w >> lv >= 1 || h >> lv >= 1) ++lv;
		return lv;
	}
	get_layerCount() {
		if((this.flags & 2) != 0) {
			return 6;
		} else {
			return 1;
		}
	}
	alloc() {
		if(this.t == null) {
			this.mem.allocTexture(this);
		}
	}
	preventAutoDispose() {
		this.set_lastFrame(h3d_mat_Texture.PREVENT_AUTO_DISPOSE);
	}
	toString() {
		let str = this.name;
		if(this.name == null) {
			str = "Texture_" + this.id;
		}
		return str + "(" + this.width + "x" + this.height + ")";
	}
	setName(n) {
		this.name = n;
	}
	set_mipMap(m) {
		this.bits = this.bits & -4 | m._hx_index;
		return this.mipMap = m;
	}
	set_filter(f) {
		this.bits = this.bits & -25 | f._hx_index << 3;
		return this.filter = f;
	}
	set_wrap(w) {
		this.bits = this.bits & -193 | w._hx_index << 6;
		return this.wrap = w;
	}
	resize(width,height) {
		this.dispose();
		let tw = 1;
		let th = 1;
		while(tw < width) tw <<= 1;
		while(th < height) th <<= 1;
		if(tw != width || th != height) {
			this.flags |= 16;
		} else {
			this.flags &= -17;
		}
		this.width = width;
		this.height = height;
		if((this.flags & 32) == 0) {
			this.alloc();
		}
	}
	clear(color,alpha,layer) {
		if(layer == null) {
			layer = -1;
		}
		if(alpha == null) {
			alpha = 1.;
		}
		this.alloc();
		if(this.width == 0 || this.height == 0) {
			return;
		}
		if(this.width != 1 || this.height != 1) {
			let engine = h3d_Engine.CURRENT;
			color |= ((alpha < 0. ? 0. : alpha > 1. ? 1. : alpha) * 255 | 0) << 24;
			if(layer < 0) {
				let _g = 0;
				let _g1 = this.get_layerCount();
				while(_g < _g1) {
					let i = _g++;
					engine.pushTarget(this,i);
					engine.clear(color);
					engine.popTarget();
				}
			} else {
				engine.pushTarget(this,layer);
				engine.clear(color);
				engine.popTarget();
			}
		} else {
			let p = hxd_Pixels.alloc(this.width,this.height,h3d_mat_Texture.nativeFormat);
			let k = 0;
			let b = color & 255;
			let g = color >> 8 & 255;
			let r = color >> 16 & 255;
			let a = alpha * 255 | 0;
			if(a < 0) {
				a = 0;
			} else if(a > 255) {
				a = 255;
			}
			switch(h3d_mat_Texture.nativeFormat._hx_index) {
			case 1:
				let tmp = r;
				r = b;
				b = tmp;
				break;
			case 2:
				break;
			default:
				throw haxe_Exception.thrown("TODO");
			}
			let _g = 0;
			let _g1 = this.width * this.height;
			while(_g < _g1) {
				++_g;
				p.bytes.b[k++] = r;
				p.bytes.b[k++] = g;
				p.bytes.b[k++] = b;
				p.bytes.b[k++] = a;
			}
			if(layer < 0) {
				let _g = 0;
				let _g1 = this.get_layerCount();
				while(_g < _g1) {
					let i = _g++;
					this.uploadPixels(p,0,i);
				}
			} else {
				this.uploadPixels(p,0,layer);
			}
			p.dispose();
		}
	}
	checkSize(width,height,mip) {
		let mw = this.width >> mip;
		if(mw == 0) {
			mw = 1;
		}
		let mh = this.height >> mip;
		if(mh == 0) {
			mh = 1;
		}
		if(width != mw || height != mh) {
			throw haxe_Exception.thrown("Invalid upload size : " + width + "x" + height + " should be " + mw + "x" + mh);
		}
	}
	checkMipMapGen(mipLevel,layer) {
		if(mipLevel == 0 && (this.flags & 4) != 0 && (this.flags & 8) == 0 && layer == this.get_layerCount() - 1) {
			this.mem.driver.generateMipMaps(this);
		}
	}
	uploadBitmap(bmp,mipLevel,layer) {
		if(layer == null) {
			layer = 0;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		this.alloc();
		this.checkSize(bmp.ctx.canvas.width,bmp.ctx.canvas.height,mipLevel);
		this.mem.driver.uploadTextureBitmap(this,bmp,mipLevel,layer);
		this.flags |= 256;
		this.checkMipMapGen(mipLevel,layer);
	}
	uploadPixels(pixels,mipLevel,layer) {
		if(layer == null) {
			layer = 0;
		}
		if(mipLevel == null) {
			mipLevel = 0;
		}
		this.alloc();
		this.checkSize(pixels.width,pixels.height,mipLevel);
		this.mem.driver.uploadTexturePixels(this,pixels,mipLevel,layer);
		this.flags |= 256;
		this.checkMipMapGen(mipLevel,layer);
	}
	dispose() {
		if(this.t != null) {
			this.mem.deleteTexture(this);
		}
	}
	capturePixels(face,mipLevel,region) {
		if(mipLevel == null) {
			mipLevel = 0;
		}
		if(face == null) {
			face = 0;
		}
		let old = this.get_lastFrame();
		this.preventAutoDispose();
		let pix = this.mem.driver.capturePixels(this,face,mipLevel,region);
		this.set_lastFrame(old);
		return pix;
	}
	static fromPixels(pixels,format) {
		let t = new h3d_mat_Texture(pixels.width,pixels.height,null,format != null ? format : pixels.innerFormat);
		t.uploadPixels(pixels);
		return t;
	}
	static fromColor(color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		let engine = h3d_Engine.CURRENT;
		let aval = alpha * 255 | 0;
		if(aval < 0) {
			aval = 0;
		} else if(aval > 255) {
			aval = 255;
		}
		let key = color & 16777215 | aval << 24;
		let t = engine.textureColorCache.h[key];
		if(t != null) {
			return t;
		}
		let t1 = new h3d_mat_Texture(1,1,null);
		t1.clear(color,alpha);
		t1.realloc = function() {
			t1.clear(color,alpha);
		};
		engine.textureColorCache.h[key] = t1;
		return t1;
	}
	static defaultCubeTexture() {
		let engine = h3d_Engine.CURRENT;
		let t = engine.resCache.h[h3d_mat_Texture.__id__];
		if(t != null) {
			return t;
		}
		t = new h3d_mat_Texture(1,1,[h3d_mat_TextureFlags.Cube]);
		t.clear(2105376);
		t.realloc = function() {
			t.clear(2105376);
		};
		engine.resCache.set(h3d_mat_Texture,t);
		return t;
	}
}
$hxClasses["h3d.mat.Texture"] = h3d_mat_Texture;
h3d_mat_Texture.__name__ = "h3d.mat.Texture";
Object.assign(h3d_mat_Texture.prototype, {
	__class__: h3d_mat_Texture
	,t: null
	,mem: null
	,id: null
	,name: null
	,width: null
	,height: null
	,flags: null
	,format: null
	,bits: null
	,waitLoads: null
	,mipMap: null
	,filter: null
	,wrap: null
	,customMipLevels: null
	,realloc: null
	,depthBuffer: null
	,_lastFrame: null
});
class h3d_mat_TextureArray extends h3d_mat_Texture {
	constructor(w,h,layers,flags,format) {
		h3d_mat_Texture._hx_skip_constructor = true;
		super();
		h3d_mat_Texture._hx_skip_constructor = false;
		this._hx_constructor(w,h,layers,flags,format);
	}
	_hx_constructor(w,h,layers,flags,format) {
		this.layers = layers;
		if(flags == null) {
			flags = [];
		}
		flags.push(h3d_mat_TextureFlags.IsArray);
		super._hx_constructor(w,h,flags,format);
	}
	get_layerCount() {
		return this.layers;
	}
	toString() {
		return super.toString() + "[" + this.layers + "]";
	}
}
$hxClasses["h3d.mat.TextureArray"] = h3d_mat_TextureArray;
h3d_mat_TextureArray.__name__ = "h3d.mat.TextureArray";
h3d_mat_TextureArray.__super__ = h3d_mat_Texture;
Object.assign(h3d_mat_TextureArray.prototype, {
	__class__: h3d_mat_TextureArray
	,layers: null
});
class h3d_pass_Base {
	constructor(name) {
		if(h3d_pass_Base._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(name);
	}
	_hx_constructor(name) {
		this.name = name;
	}
	setContext(ctx) {
		this.ctx = ctx;
	}
	draw(passes,sort) {
	}
}
$hxClasses["h3d.pass.Base"] = h3d_pass_Base;
h3d_pass_Base.__name__ = "h3d.pass.Base";
Object.assign(h3d_pass_Base.prototype, {
	__class__: h3d_pass_Base
	,ctx: null
	,name: null
});
class h3d_pass_ScreenFx {
	constructor(shader,output) {
		if(h3d_pass_ScreenFx._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(shader,output);
	}
	_hx_constructor(shader,output) {
		this.shader = shader;
		this.manager = new h3d_pass_ShaderManager(output);
		this.pass = new h3d_mat_Pass("screenfx",new hxsl_ShaderList(shader));
		this.pass.set_culling(h3d_mat_Face.None);
		this.pass.depth(false,h3d_mat_Compare.Always);
	}
	get_engine() {
		if(this._engine == null) {
			this._engine = h3d_Engine.CURRENT;
		}
		return this._engine;
	}
	render() {
		if(this.primitive == null) {
			this.primitive = h3d_prim_Plane2D.get();
		}
		this.shader.flipY__ = this.get_engine().driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) && this.get_engine().getCurrentTarget() != null ? -1 : 1;
		let shaders = this.pass.shaders;
		let rts = this.manager.compileShaders(shaders);
		this.get_engine().selectMaterial(this.pass);
		this.get_engine().selectShader(rts);
		if(this.buffers == null) {
			this.buffers = new h3d_shader_Buffers(rts);
		} else {
			let _this = this.buffers;
			_this.vertex.grow(rts.vertex);
			_this.fragment.grow(rts.fragment);
		}
		this.manager.fillGlobals(this.buffers,rts);
		this.manager.fillParams(this.buffers,rts,shaders);
		this.get_engine().uploadShaderBuffers(this.buffers,0);
		this.get_engine().uploadShaderBuffers(this.buffers,1);
		this.get_engine().uploadShaderBuffers(this.buffers,2);
		this.primitive.render(this.get_engine());
	}
	dispose() {
	}
}
$hxClasses["h3d.pass.ScreenFx"] = h3d_pass_ScreenFx;
h3d_pass_ScreenFx.__name__ = "h3d.pass.ScreenFx";
Object.assign(h3d_pass_ScreenFx.prototype, {
	__class__: h3d_pass_ScreenFx
	,shader: null
	,pass: null
	,primitive: null
	,manager: null
	,_engine: null
	,buffers: null
});
class h3d_pass_Blur extends h3d_pass_ScreenFx {
	constructor(radius,gain,linear,quality) {
		h3d_pass_ScreenFx._hx_skip_constructor = true;
		super();
		h3d_pass_ScreenFx._hx_skip_constructor = false;
		this._hx_constructor(radius,gain,linear,quality);
	}
	_hx_constructor(radius,gain,linear,quality) {
		if(quality == null) {
			quality = 1.;
		}
		if(linear == null) {
			linear = 0.;
		}
		if(gain == null) {
			gain = 1.;
		}
		if(radius == null) {
			radius = 1.;
		}
		this.cubeDir = [h3d_Matrix.L([0,0,-1,0,0,-1,0,0,1,0,0,0]),h3d_Matrix.L([0,0,1,0,0,-1,0,0,-1,0,0,0]),h3d_Matrix.L([1,0,0,0,0,0,1,0,0,1,0,0]),h3d_Matrix.L([1,0,0,0,0,0,-1,0,0,-1,0,0]),h3d_Matrix.L([1,0,0,0,0,-1,0,0,0,1,0,0]),h3d_Matrix.L([-1,0,0,0,0,-1,0,0,0,0,-1,0])];
		super._hx_constructor(new h3d_shader_Blur());
		this.set_radius(radius);
		this.set_quality(quality);
		this.set_gain(gain);
		this.set_linear(linear);
	}
	set_radius(r) {
		if(this.radius == r) {
			return r;
		}
		this.values = null;
		return this.radius = r;
	}
	set_quality(q) {
		if(this.quality == q) {
			return q;
		}
		this.values = null;
		return this.quality = q;
	}
	set_gain(s) {
		if(this.gain == s) {
			return s;
		}
		this.values = null;
		return this.gain = s;
	}
	set_linear(b) {
		if(this.linear == b) {
			return b;
		}
		this.values = null;
		return this.linear = b;
	}
	gauss(x,s) {
		if(s <= 0) {
			if(x == 0) {
				return 1;
			} else {
				return 0;
			}
		}
		let sq = s * s;
		let p = Math.pow(2.718281828459,-(x * x) / (2 * sq));
		return p / Math.sqrt(2 * Math.PI * sq);
	}
	calcValues() {
		this.values = [];
		this.offsets = [];
		let tot = 0.;
		let f = this.quality;
		let qadj = (f < 0. ? 0. : f > 1. ? 1. : f) * 0.7 + 0.3;
		let width;
		if(this.radius > 0) {
			let a = this.radius - 1;
			width = Math.ceil((a < 1 ? 1 : a) * qadj / 2);
		} else {
			width = 0;
		}
		let sigma = Math.sqrt(this.radius);
		let _g = 0;
		let _g1 = width + 1;
		while(_g < _g1) {
			let i = _g++;
			let i1 = i * 2;
			let i2 = i == 0 ? 0 : i * 2 - 1;
			let g1 = this.gauss(i1,sigma);
			let g2 = this.gauss(i2,sigma);
			let g = g1 + g2;
			this.values[i] = g;
			this.offsets[i] = i == 0 ? 0 : (g1 * i1 + g2 * i2) / (g * i * Math.sqrt(qadj));
			tot += g;
			if(i > 0) {
				tot += g;
			}
		}
		let minVal = this.values[0] * (0.01 / qadj);
		while(this.values.length > 2) {
			let last = this.values[this.values.length - 1];
			if(last > minVal) {
				break;
			}
			tot -= last * 2;
			this.values.pop();
		}
		tot /= this.gain;
		let _g2 = 0;
		let _g3 = this.values.length;
		while(_g2 < _g3) {
			let i = _g2++;
			this.values[i] /= tot;
		}
		if(this.linear > 0) {
			let m = this.gain / (this.values.length * 2 - 1);
			let _g = 0;
			let _g1 = this.values.length;
			while(_g < _g1) {
				let i = _g++;
				let a = this.values[i];
				this.values[i] = a + this.linear * (m - a);
				let a1 = this.offsets[i];
				this.offsets[i] = a1 + this.linear * ((i == 0 ? 0 : (i * 2 - 0.5) / (i * qadj)) - a1);
			}
		}
	}
	apply(ctx,src,output) {
		if(this.radius <= 0 && this.shader.fixedColor__ == null) {
			if(output != null) {
				h3d_pass_Copy.run(src,output);
			}
			return;
		}
		if(output == null) {
			output = src;
		}
		if(this.values == null) {
			this.calcValues();
		}
		let isCube = (src.flags & 2) != 0;
		let faceCount = isCube ? 6 : 1;
		let tmp = ctx.textures.allocTarget(src.name + "BlurTmp",src.width,src.height,false,src.format,isCube);
		let _this = this.shader;
		_this.constModified = true;
		_this.Quality__ = this.values.length;
		this.shader.values__ = this.values;
		this.shader.offsets__ = this.offsets;
		if(isCube) {
			this.shader.cubeTexture__ = src;
			let _this = this.shader;
			_this.constModified = true;
			_this.isCube__ = true;
		} else {
			this.shader.texture__ = src;
			let _this = this.shader;
			_this.constModified = true;
			_this.isCube__ = false;
		}
		let _this1 = this.shader.pixel__;
		let x = 1 / src.width;
		if(x == null) {
			x = 0.;
		}
		_this1.x = x;
		_this1.y = 0;
		_this1.z = 0.;
		_this1.w = 1.;
		let _g = 0;
		let _g1 = faceCount;
		while(_g < _g1) {
			let i = _g++;
			this.get_engine().pushTarget(tmp,i);
			if(isCube) {
				this.shader.cubeDir__ = this.cubeDir[i];
			}
			this.render();
			this.get_engine().popTarget();
		}
		if(isCube) {
			this.shader.cubeTexture__ = tmp;
		} else {
			this.shader.texture__ = tmp;
		}
		let _this2 = this.shader.pixel__;
		let y = 1 / src.height;
		if(y == null) {
			y = 0.;
		}
		_this2.x = 0;
		_this2.y = y;
		_this2.z = 0.;
		_this2.w = 1.;
		let outDepth = output.depthBuffer;
		output.depthBuffer = null;
		let _g2 = 0;
		let _g3 = faceCount;
		while(_g2 < _g3) {
			let i = _g2++;
			this.get_engine().pushTarget(output,i);
			if(isCube) {
				this.shader.cubeDir__ = this.cubeDir[i];
			}
			this.render();
			this.get_engine().popTarget();
		}
		output.depthBuffer = outDepth;
	}
}
$hxClasses["h3d.pass.Blur"] = h3d_pass_Blur;
h3d_pass_Blur.__name__ = "h3d.pass.Blur";
h3d_pass_Blur.__super__ = h3d_pass_ScreenFx;
Object.assign(h3d_pass_Blur.prototype, {
	__class__: h3d_pass_Blur
	,cubeDir: null
	,radius: null
	,gain: null
	,linear: null
	,quality: null
	,values: null
	,offsets: null
});
class h3d_pass__$Border_BorderShader extends h3d_shader_ScreenShader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.color__ = new h3d_Vector();
		super._hx_constructor();
	}
	get_color() {
		return this.color__;
	}
	set_color(_v) {
		return this.color__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.color__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_pass__$Border_BorderShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.color__ = this.color__;
		return s;
	}
}
$hxClasses["h3d.pass._Border.BorderShader"] = h3d_pass__$Border_BorderShader;
h3d_pass__$Border_BorderShader.__name__ = "h3d.pass._Border.BorderShader";
h3d_pass__$Border_BorderShader.__super__ = h3d_shader_ScreenShader;
Object.assign(h3d_pass__$Border_BorderShader.prototype, {
	__class__: h3d_pass__$Border_BorderShader
	,color__: null
});
class h3d_pass_Border extends h3d_pass_ScreenFx {
	constructor(width,height,size) {
		if(size == null) {
			size = 1;
		}
		super(new h3d_pass__$Border_BorderShader());
		let bbuf = hxd__$FloatBuffer_Float32Expand._new(0);
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = width / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - size / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = width / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - size / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = size / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - height / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = size / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - height / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - (height - size) / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = width / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - (height - size) / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 0 / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - height / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = width / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - height / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = (width - size) / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = width / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - 0 / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = (width - size) / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - height / height * 2;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = width / width * 2 - 1;
		if(bbuf.pos == bbuf.array.length) {
			let newSize = bbuf.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(bbuf.array);
			bbuf.array = newArray;
		}
		bbuf.array[bbuf.pos++] = 1 - height / height * 2;
		this.primitive = new h3d_prim_RawPrimitive({ vbuf : bbuf, stride : 2, quads : true},true);
		let _this = this.shader.color__;
		_this.x = 1;
		_this.y = 1;
		_this.z = 1;
		_this.w = 1;
	}
	dispose() {
		super.dispose();
		this.primitive.dispose();
	}
}
$hxClasses["h3d.pass.Border"] = h3d_pass_Border;
h3d_pass_Border.__name__ = "h3d.pass.Border";
h3d_pass_Border.__super__ = h3d_pass_ScreenFx;
Object.assign(h3d_pass_Border.prototype, {
	__class__: h3d_pass_Border
});
class h3d_pass_ColorMatrixShader extends h3d_shader_ScreenShader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.maskChannel__ = new h3d_Vector();
		this.maskPower__ = 0;
		this.maskMatB__ = new h3d_Vector();
		this.maskMatA__ = new h3d_Vector();
		this.matrix2__ = new h3d_Matrix();
		this.matrix__ = new h3d_Matrix();
		super._hx_constructor();
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	get_matrix() {
		return this.matrix__;
	}
	set_matrix(_v) {
		return this.matrix__ = _v;
	}
	get_useAlpha() {
		return this.useAlpha__;
	}
	set_useAlpha(_v) {
		this.constModified = true;
		return this.useAlpha__ = _v;
	}
	get_useMask() {
		return this.useMask__;
	}
	set_useMask(_v) {
		this.constModified = true;
		return this.useMask__ = _v;
	}
	get_maskInvert() {
		return this.maskInvert__;
	}
	set_maskInvert(_v) {
		this.constModified = true;
		return this.maskInvert__ = _v;
	}
	get_hasSecondMatrix() {
		return this.hasSecondMatrix__;
	}
	set_hasSecondMatrix(_v) {
		this.constModified = true;
		return this.hasSecondMatrix__ = _v;
	}
	get_matrix2() {
		return this.matrix2__;
	}
	set_matrix2(_v) {
		return this.matrix2__ = _v;
	}
	get_mask() {
		return this.mask__;
	}
	set_mask(_v) {
		return this.mask__ = _v;
	}
	get_maskMatA() {
		return this.maskMatA__;
	}
	set_maskMatA(_v) {
		return this.maskMatA__ = _v;
	}
	get_maskMatB() {
		return this.maskMatB__;
	}
	set_maskMatB(_v) {
		return this.maskMatB__ = _v;
	}
	get_maskPower() {
		return this.maskPower__;
	}
	set_maskPower(_v) {
		return this.maskPower__ = _v;
	}
	get_maskChannel() {
		return this.maskChannel__;
	}
	set_maskChannel(_v) {
		return this.maskChannel__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.useAlpha__) {
			this.constBits |= 1;
		}
		if(this.useMask__) {
			this.constBits |= 2;
		}
		if(this.maskInvert__) {
			this.constBits |= 4;
		}
		if(this.hasSecondMatrix__) {
			this.constBits |= 8;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.matrix__;
		case 3:
			return this.useAlpha__;
		case 4:
			return this.useMask__;
		case 5:
			return this.maskInvert__;
		case 6:
			return this.hasSecondMatrix__;
		case 7:
			return this.matrix2__;
		case 8:
			return this.mask__;
		case 9:
			return this.maskMatA__;
		case 10:
			return this.maskMatB__;
		case 11:
			return this.maskPower__;
		case 12:
			return this.maskChannel__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 11:
			return this.maskPower__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_pass_ColorMatrixShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		s.matrix__ = this.matrix__;
		s.useAlpha__ = this.useAlpha__;
		s.useMask__ = this.useMask__;
		s.maskInvert__ = this.maskInvert__;
		s.hasSecondMatrix__ = this.hasSecondMatrix__;
		s.matrix2__ = this.matrix2__;
		s.mask__ = this.mask__;
		s.maskMatA__ = this.maskMatA__;
		s.maskMatB__ = this.maskMatB__;
		s.maskPower__ = this.maskPower__;
		s.maskChannel__ = this.maskChannel__;
		return s;
	}
}
$hxClasses["h3d.pass.ColorMatrixShader"] = h3d_pass_ColorMatrixShader;
h3d_pass_ColorMatrixShader.__name__ = "h3d.pass.ColorMatrixShader";
h3d_pass_ColorMatrixShader.__super__ = h3d_shader_ScreenShader;
Object.assign(h3d_pass_ColorMatrixShader.prototype, {
	__class__: h3d_pass_ColorMatrixShader
	,texture__: null
	,matrix__: null
	,useAlpha__: null
	,useMask__: null
	,maskInvert__: null
	,hasSecondMatrix__: null
	,matrix2__: null
	,mask__: null
	,maskMatA__: null
	,maskMatB__: null
	,maskPower__: null
	,maskChannel__: null
});
class h3d_pass_ColorMatrix extends h3d_pass_ScreenFx {
	constructor(m) {
		super(new h3d_pass_ColorMatrixShader());
		if(m != null) {
			this.shader.matrix__ = m;
		} else {
			this.shader.matrix__.identity();
		}
		this.shader.maskPower__ = 1;
		let _this = this.shader.maskChannel__;
		_this.x = 1;
		_this.y = 0;
		_this.z = 0;
		_this.w = 0;
	}
	apply(src,out,mask,maskMatrix) {
		this.get_engine().pushTarget(out);
		this.shader.texture__ = src;
		let _this = this.shader;
		_this.constModified = true;
		_this.useMask__ = mask != null;
		if(mask != null) {
			this.shader.mask__ = mask;
			if(maskMatrix == null) {
				let _this = this.shader.maskMatA__;
				_this.x = 1;
				_this.y = 0;
				_this.z = 0;
				_this.w = 1.;
				let _this1 = this.shader.maskMatB__;
				_this1.x = 0;
				_this1.y = 1;
				_this1.z = 0;
				_this1.w = 1.;
			} else {
				let _this = this.shader.maskMatA__;
				let x = maskMatrix.a;
				let y = maskMatrix.c;
				let z = maskMatrix.x;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				_this.x = x;
				_this.y = y;
				_this.z = z;
				_this.w = 1.;
				let _this1 = this.shader.maskMatB__;
				let x1 = maskMatrix.b;
				let y1 = maskMatrix.d;
				let z1 = maskMatrix.y;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				_this1.x = x1;
				_this1.y = y1;
				_this1.z = z1;
				_this1.w = 1.;
			}
		}
		this.render();
		this.get_engine().popTarget();
	}
}
$hxClasses["h3d.pass.ColorMatrix"] = h3d_pass_ColorMatrix;
h3d_pass_ColorMatrix.__name__ = "h3d.pass.ColorMatrix";
h3d_pass_ColorMatrix.__super__ = h3d_pass_ScreenFx;
Object.assign(h3d_pass_ColorMatrix.prototype, {
	__class__: h3d_pass_ColorMatrix
});
class h3d_pass__$Copy_ArrayCopyShader extends h3d_shader_ScreenShader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.layer__ = 0;
		super._hx_constructor();
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	get_layer() {
		return this.layer__;
	}
	set_layer(_v) {
		return this.layer__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.layer__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_pass__$Copy_ArrayCopyShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		s.layer__ = this.layer__;
		return s;
	}
}
$hxClasses["h3d.pass._Copy.ArrayCopyShader"] = h3d_pass__$Copy_ArrayCopyShader;
h3d_pass__$Copy_ArrayCopyShader.__name__ = "h3d.pass._Copy.ArrayCopyShader";
h3d_pass__$Copy_ArrayCopyShader.__super__ = h3d_shader_ScreenShader;
Object.assign(h3d_pass__$Copy_ArrayCopyShader.prototype, {
	__class__: h3d_pass__$Copy_ArrayCopyShader
	,texture__: null
	,layer__: null
});
class h3d_pass__$Copy_CopyShader extends h3d_shader_ScreenShader {
	constructor() {
		super();
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_pass__$Copy_CopyShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		return s;
	}
}
$hxClasses["h3d.pass._Copy.CopyShader"] = h3d_pass__$Copy_CopyShader;
h3d_pass__$Copy_CopyShader.__name__ = "h3d.pass._Copy.CopyShader";
h3d_pass__$Copy_CopyShader.__super__ = h3d_shader_ScreenShader;
Object.assign(h3d_pass__$Copy_CopyShader.prototype, {
	__class__: h3d_pass__$Copy_CopyShader
	,texture__: null
});
class h3d_pass_Copy extends h3d_pass_ScreenFx {
	constructor() {
		super(new h3d_pass__$Copy_CopyShader());
	}
	apply(from,to,blend,customPass,layer) {
		if(to != null) {
			this.get_engine().pushTarget(to,layer != null ? layer : 0);
		}
		this.shader.texture__ = from;
		if(customPass != null) {
			if(blend != null) {
				customPass.setBlendMode(blend);
			}
			let h = customPass.shaders;
			while(h.next != null) h = h.next;
			h.next = this.pass.shaders;
			let old = this.pass;
			this.pass = customPass;
			this.render();
			this.pass = old;
			h.next = null;
		} else {
			this.pass.setBlendMode(blend == null ? h2d_BlendMode.None : blend);
			this.render();
		}
		this.shader.texture__ = null;
		if(to != null) {
			this.get_engine().popTarget();
		}
	}
	static run(from,to,blend,pass,layer) {
		let engine = h3d_Engine.CURRENT;
		if(to != null && from != null && (blend == null || blend == h2d_BlendMode.None) && pass == null && layer == null && engine.driver.copyTexture(from,to)) {
			return;
		}
		let inst = engine.resCache.h[h3d_pass_Copy.__id__];
		if(inst == null) {
			inst = new h3d_pass_Copy();
			engine.resCache.set(h3d_pass_Copy,inst);
		}
		inst.apply(from,to,blend,pass,layer);
	}
}
$hxClasses["h3d.pass.Copy"] = h3d_pass_Copy;
h3d_pass_Copy.__name__ = "h3d.pass.Copy";
h3d_pass_Copy.__super__ = h3d_pass_ScreenFx;
Object.assign(h3d_pass_Copy.prototype, {
	__class__: h3d_pass_Copy
});
class h3d_pass__$CubeCopy_CubeCopyShader extends h3d_shader_ScreenShader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.mat__ = new h3d_Matrix();
		super._hx_constructor();
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	get_mat() {
		return this.mat__;
	}
	set_mat(_v) {
		return this.mat__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.mat__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_pass__$CubeCopy_CubeCopyShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		s.mat__ = this.mat__;
		return s;
	}
}
$hxClasses["h3d.pass._CubeCopy.CubeCopyShader"] = h3d_pass__$CubeCopy_CubeCopyShader;
h3d_pass__$CubeCopy_CubeCopyShader.__name__ = "h3d.pass._CubeCopy.CubeCopyShader";
h3d_pass__$CubeCopy_CubeCopyShader.__super__ = h3d_shader_ScreenShader;
Object.assign(h3d_pass__$CubeCopy_CubeCopyShader.prototype, {
	__class__: h3d_pass__$CubeCopy_CubeCopyShader
	,texture__: null
	,mat__: null
});
class h3d_pass_Default extends h3d_pass_Base {
	constructor(name) {
		if(h3d_pass_Base._hx_skip_constructor) {
			super();
			return;
		}
		h3d_pass_Base._hx_skip_constructor = true;
		super();
		h3d_pass_Base._hx_skip_constructor = false;
		this._hx_constructor(name);
	}
	_hx_constructor(name) {
		this.defaultSort = ($_=new h3d_pass_SortByMaterial(),$bind($_,$_.sort));
		super._hx_constructor(name);
		this.manager = new h3d_pass_ShaderManager(this.getOutputs());
		this.initGlobals();
	}
	getCurrentPixelSize() {
		let t = this.ctx.engine.getCurrentTarget();
		return new h3d_Vector(2 / (t == null ? this.ctx.engine.width : t.width),2 / (t == null ? this.ctx.engine.height : t.height));
	}
	getOutputs() {
		return [hxsl_Output.Value("output.color")];
	}
	processShaders(p,shaders) {
		let p1 = this.ctx.extraShaders;
		while(p1 != null) {
			shaders = this.ctx.allocShaderList(p1.s,shaders);
			p1 = p1.next;
		}
		return shaders;
	}
	setupShaders(passes) {
		let lightInit = false;
		let _g_o = passes.current;
		while(_g_o != null) {
			let tmp = _g_o;
			_g_o = _g_o.next;
			let shaders = tmp.pass.getShadersRec();
			shaders = this.processShaders(tmp,shaders);
			if(tmp.pass.enableLights && this.ctx.lightSystem != null) {
				if(!lightInit) {
					this.ctx.lightSystem.initGlobals(this.manager.globals);
					lightInit = true;
				}
				shaders = this.ctx.lightSystem.computeLight(tmp.obj,shaders);
			}
			tmp.shader = this.manager.compileShaders(shaders,tmp.pass.batchMode);
			tmp.shaders = shaders;
			let t = tmp.shader.fragment.textures;
			if(t == null || t.type._hx_index == 15) {
				tmp.texture = 0;
			} else {
				let _this = this.manager;
				let t1;
				if(t.perObjectGlobal != null) {
					let v = _this.globals.map.h[t.perObjectGlobal.gid];
					if(v == null) {
						throw haxe_Exception.thrown("Missing global value " + t.perObjectGlobal.path + " for shader " + _this.shaderInfo(shaders,t.perObjectGlobal.path));
					}
					t1 = t.type._hx_index == 17 ? v.texture : v;
				} else {
					let si = shaders;
					let n = t.instance;
					while(--n > 0) si = si.next;
					let v = si.s.getParamValue(t.index);
					t1 = v;
				}
				tmp.texture = t1 == null ? 0 : t1.id;
			}
		}
	}
	drawObject(p) {
		this.ctx.drawPass = p;
		this.ctx.engine.selectMaterial(p.pass);
		p.obj.draw(this.ctx);
	}
	draw(passes,sort) {
		if(passes.current == null) {
			return;
		}
		let _g = 0;
		let _g1 = this.ctx.sharedGlobals;
		while(_g < _g1.length) {
			let g = _g1[_g];
			++_g;
			this.manager.globals.map.h[g.gid] = g.value;
		}
		this.setGlobals();
		this.setupShaders(passes);
		if(sort == null) {
			this.defaultSort(passes);
		} else {
			sort(passes);
		}
		this.ctx.currentManager = this.manager;
		let buf = this.ctx.shaderBuffers;
		let prevShader = null;
		let _g_o = passes.current;
		while(_g_o != null) {
			let tmp = _g_o;
			_g_o = _g_o.next;
			let v = tmp.obj.absPos;
			this.manager.globals.map.h[this.globalModelView_id] = v;
			if(tmp.shader.globals.h.hasOwnProperty(this.globalModelViewInverse_id)) {
				let v = tmp.obj.getInvPos();
				this.manager.globals.map.h[this.globalModelViewInverse_id] = v;
			}
			if(prevShader != tmp.shader) {
				prevShader = tmp.shader;
				try {
					this.ctx.engine.selectShader(tmp.shader);
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g).unwrap();
					h3d_pass_Default.onShaderError(_g1,tmp);
					continue;
				}
				if(buf == null) {
					buf = this.ctx.shaderBuffers = new h3d_shader_Buffers(tmp.shader);
				} else {
					let s = tmp.shader;
					buf.vertex.grow(s.vertex);
					buf.fragment.grow(s.fragment);
				}
				this.manager.fillGlobals(buf,tmp.shader);
				this.ctx.engine.uploadShaderBuffers(buf,0);
			}
			if(!tmp.pass.dynamicParameters) {
				this.manager.fillParams(buf,tmp.shader,tmp.shaders);
				this.ctx.engine.uploadShaderBuffers(buf,1);
				this.ctx.engine.uploadShaderBuffers(buf,2);
				this.ctx.engine.uploadShaderBuffers(buf,3);
			}
			this.drawObject(tmp);
		}
		let _this = this.ctx;
		_this.cachedPos = 0;
		_this.drawPass = null;
	}
	initGlobals() {
		this.cameraView_id = hxsl_Globals.allocID("camera.view");
		this.cameraNear_id = hxsl_Globals.allocID("camera.zNear");
		this.cameraFar_id = hxsl_Globals.allocID("camera.zFar");
		this.cameraProj_id = hxsl_Globals.allocID("camera.proj");
		this.cameraPos_id = hxsl_Globals.allocID("camera.position");
		this.cameraProjDiag_id = hxsl_Globals.allocID("camera.projDiag");
		this.cameraProjFlip_id = hxsl_Globals.allocID("camera.projFlip");
		this.cameraViewProj_id = hxsl_Globals.allocID("camera.viewProj");
		this.cameraInverseViewProj_id = hxsl_Globals.allocID("camera.inverseViewProj");
		this.globalTime_id = hxsl_Globals.allocID("global.time");
		this.pixelSize_id = hxsl_Globals.allocID("global.pixelSize");
		this.globalModelView_id = hxsl_Globals.allocID("global.modelView");
		this.globalModelViewInverse_id = hxsl_Globals.allocID("global.modelViewInverse");
	}
	setGlobals() {
		let v = this.ctx.camera.mcam;
		this.manager.globals.map.h[this.cameraView_id] = v;
		let v1 = this.ctx.camera.zNear;
		this.manager.globals.map.h[this.cameraNear_id] = v1;
		let v2 = this.ctx.camera.zFar;
		this.manager.globals.map.h[this.cameraFar_id] = v2;
		let v3 = this.ctx.camera.mproj;
		this.manager.globals.map.h[this.cameraProj_id] = v3;
		let v4 = this.ctx.camera.pos;
		this.manager.globals.map.h[this.cameraPos_id] = v4;
		let v5 = new h3d_Vector(this.ctx.camera.mproj._11,this.ctx.camera.mproj._22,this.ctx.camera.mproj._33,this.ctx.camera.mproj._44);
		this.manager.globals.map.h[this.cameraProjDiag_id] = v5;
		let v6 = this.ctx.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) && this.ctx.engine.getCurrentTarget() != null ? -1 : 1;
		this.manager.globals.map.h[this.cameraProjFlip_id] = v6;
		let v7 = this.ctx.camera.m;
		this.manager.globals.map.h[this.cameraViewProj_id] = v7;
		let v8 = this.ctx.camera.getInverseViewProj();
		this.manager.globals.map.h[this.cameraInverseViewProj_id] = v8;
		let v9 = this.ctx.time;
		this.manager.globals.map.h[this.globalTime_id] = v9;
		let v10 = this.getCurrentPixelSize();
		this.manager.globals.map.h[this.pixelSize_id] = v10;
	}
	static onShaderError(e,p) {
		throw haxe_Exception.thrown(e);
	}
}
$hxClasses["h3d.pass.Default"] = h3d_pass_Default;
h3d_pass_Default.__name__ = "h3d.pass.Default";
h3d_pass_Default.__super__ = h3d_pass_Base;
Object.assign(h3d_pass_Default.prototype, {
	__class__: h3d_pass_Default
	,manager: null
	,defaultSort: null
	,cameraView_id: null
	,cameraNear_id: null
	,cameraFar_id: null
	,cameraProj_id: null
	,cameraPos_id: null
	,cameraProjDiag_id: null
	,cameraProjFlip_id: null
	,cameraViewProj_id: null
	,cameraInverseViewProj_id: null
	,globalTime_id: null
	,pixelSize_id: null
	,globalModelView_id: null
	,globalModelViewInverse_id: null
});
class h3d_pass_Shadows extends h3d_pass_Default {
	constructor(light) {
		if(h3d_pass_Base._hx_skip_constructor) {
			super();
			return;
		}
		h3d_pass_Base._hx_skip_constructor = true;
		super();
		h3d_pass_Base._hx_skip_constructor = false;
		this._hx_constructor(light);
	}
	_hx_constructor(light) {
		this.pcfScale = 1.0;
		this.pcfQuality = 1;
		this.bias = 0.01;
		this.power = 30.0;
		this.samplingKind = h3d_pass_ShadowSamplingKind.None;
		this.size = 1024;
		this.mode = h3d_pass_RenderMode.None;
		this.enabled = true;
		if(this.format == null) {
			this.format = hxd_PixelFormat.R16F;
		}
		if(!h3d_Engine.CURRENT.driver.isSupportedFormat(this.format)) {
			this.format = h3d_mat_Texture.nativeFormat;
		}
		super._hx_constructor("shadow");
		this.light = light;
		this.blur = new h3d_pass_Blur(5);
		this.blur.set_quality(0.5);
		let _this = this.blur.shader;
		_this.constModified = true;
		_this.isDepth__ = this.format == h3d_mat_Texture.nativeFormat;
	}
	set_size(s) {
		if(s != this.size && this.staticTexture != null) {
			this.staticTexture.dispose();
			this.staticTexture = null;
		}
		return this.size = s;
	}
	getShadowProj() {
		return this.lightCamera.m;
	}
	isUsingWorldDist() {
		return false;
	}
	getOutputs() {
		if(this.isUsingWorldDist()) {
			return [hxsl_Output.Swiz(hxsl_Output.Value("output.worldDist",1),[hxsl_Component.X,hxsl_Component.X,hxsl_Component.X,hxsl_Component.X])];
		}
		if(this.format == h3d_mat_Texture.nativeFormat) {
			return [hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))];
		}
		return [hxsl_Output.Swiz(hxsl_Output.Value("output.depth",1),[hxsl_Component.X,hxsl_Component.X,hxsl_Component.X,hxsl_Component.X])];
	}
	createDefaultShadowMap() {
		let tex = h3d_mat_Texture.fromColor(16777215);
		tex.name = "defaultShadowMap";
		return tex;
	}
	syncShader(texture) {
	}
	filterPasses(passes) {
		if(!this.ctx.computingStatic) {
			switch(this.mode._hx_index) {
			case 0:
				return false;
			case 1:
				let tmp;
				if(this.staticTexture != null) {
					let _this = this.staticTexture;
					tmp = _this.t == null && _this.realloc == null;
				} else {
					tmp = true;
				}
				if(tmp) {
					this.staticTexture = this.createDefaultShadowMap();
				}
				this.syncShader(this.staticTexture);
				return false;
			case 2:
				return true;
			case 3:
				let tmp1;
				if(this.staticTexture != null) {
					let _this = this.staticTexture;
					tmp1 = _this.t == null && _this.realloc == null;
				} else {
					tmp1 = true;
				}
				if(tmp1) {
					this.staticTexture = this.createDefaultShadowMap();
				}
				let head = null;
				let prev = null;
				let disc = passes.discarded;
				let discQueue = passes.lastDisc;
				let cur = passes.current;
				while(cur != null) {
					if(cur.pass.isStatic == false) {
						if(head == null) {
							prev = cur;
							head = prev;
						} else {
							prev.next = cur;
							prev = cur;
						}
					} else if(disc == null) {
						discQueue = cur;
						disc = discQueue;
					} else {
						discQueue.next = cur;
						discQueue = cur;
					}
					cur = cur.next;
				}
				if(prev != null) {
					prev.next = null;
				}
				if(discQueue != null) {
					discQueue.next = null;
				}
				passes.current = head;
				passes.discarded = disc;
				passes.lastDisc = discQueue;
				return true;
			}
		} else {
			switch(this.mode._hx_index) {
			case 0:
				return false;
			case 1:
				let head1 = null;
				let prev1 = null;
				let disc1 = passes.discarded;
				let discQueue1 = passes.lastDisc;
				let cur1 = passes.current;
				while(cur1 != null) {
					if(cur1.pass.isStatic == true) {
						if(head1 == null) {
							prev1 = cur1;
							head1 = prev1;
						} else {
							prev1.next = cur1;
							prev1 = cur1;
						}
					} else if(disc1 == null) {
						discQueue1 = cur1;
						disc1 = discQueue1;
					} else {
						discQueue1.next = cur1;
						discQueue1 = cur1;
					}
					cur1 = cur1.next;
				}
				if(prev1 != null) {
					prev1.next = null;
				}
				if(discQueue1 != null) {
					discQueue1.next = null;
				}
				passes.current = head1;
				passes.discarded = disc1;
				passes.lastDisc = discQueue1;
				return true;
			case 2:
				return false;
			case 3:
				let head2 = null;
				let prev2 = null;
				let disc2 = passes.discarded;
				let discQueue2 = passes.lastDisc;
				let cur2 = passes.current;
				while(cur2 != null) {
					if(cur2.pass.isStatic == true) {
						if(head2 == null) {
							prev2 = cur2;
							head2 = prev2;
						} else {
							prev2.next = cur2;
							prev2 = cur2;
						}
					} else if(disc2 == null) {
						discQueue2 = cur2;
						disc2 = discQueue2;
					} else {
						discQueue2.next = cur2;
						discQueue2 = cur2;
					}
					cur2 = cur2.next;
				}
				if(prev2 != null) {
					prev2.next = null;
				}
				if(discQueue2 != null) {
					discQueue2.next = null;
				}
				passes.current = head2;
				passes.discarded = disc2;
				passes.lastDisc = discQueue2;
				return true;
			}
		}
	}
}
$hxClasses["h3d.pass.Shadows"] = h3d_pass_Shadows;
h3d_pass_Shadows.__name__ = "h3d.pass.Shadows";
h3d_pass_Shadows.__super__ = h3d_pass_Default;
Object.assign(h3d_pass_Shadows.prototype, {
	__class__: h3d_pass_Shadows
	,lightCamera: null
	,format: null
	,staticTexture: null
	,light: null
	,enabled: null
	,mode: null
	,size: null
	,shader: null
	,blur: null
	,samplingKind: null
	,power: null
	,bias: null
	,pcfQuality: null
	,pcfScale: null
});
class h3d_pass_DirShadowMap extends h3d_pass_Shadows {
	constructor(light) {
		if(h3d_pass_Base._hx_skip_constructor) {
			super();
			return;
		}
		h3d_pass_Base._hx_skip_constructor = true;
		super();
		h3d_pass_Base._hx_skip_constructor = false;
		this._hx_constructor(light);
	}
	_hx_constructor(light) {
		this.minDist = -1.0;
		this.maxDist = -1.0;
		this.autoZPlanes = false;
		this.autoShrink = true;
		this.mergePass = new h3d_pass_ScreenFx(new h3d_shader_MinMaxShader());
		super._hx_constructor(light);
		this.lightCamera = new h3d_Camera();
		this.lightCamera.orthoBounds = new h3d_col_Bounds();
		this.shader = this.dshader = new h3d_shader_DirShadow();
		this.border = new h3d_pass_Border(this.size,this.size);
		this.customDepth = h3d_Engine.CURRENT.driver.hasFeature(h3d_impl_Feature.AllocDepthBuffer);
		if(!this.customDepth) {
			this.depth = h3d_mat_DepthBuffer.getDefault();
		}
	}
	set_mode(m) {
		let _this = this.dshader;
		_this.constModified = true;
		_this.enable__ = m != h3d_pass_RenderMode.None;
		return this.mode = m;
	}
	set_size(s) {
		if(this.border != null && this.size != s) {
			this.border.dispose();
			this.border = new h3d_pass_Border(s,s);
		}
		return super.set_size(s);
	}
	calcShadowBounds(camera) {
		let bounds = camera.orthoBounds;
		let zMax = -1e9;
		let zMin = 1e9;
		let _gthis = this;
		if(this.autoShrink) {
			let mtmp = new h3d_Matrix();
			let identity = h3d_Matrix.I();
			let btmp = this.autoZPlanes ? new h3d_col_Bounds() : null;
			let obj = this.boundingObject != null ? this.boundingObject : this.ctx.scene;
			obj.iterVisibleMeshes(function(m) {
				if(m.primitive == null || !m.material.castShadows) {
					return;
				}
				let b = m.primitive.getBounds();
				if(b.xMin > b.xMax) {
					return;
				}
				let absPos = ((m.primitive) instanceof h3d_prim_Instanced) ? identity : m.getAbsPos();
				if(_gthis.autoZPlanes) {
					btmp.load(b);
					btmp.transform(absPos);
					if(btmp.zMax > zMax) {
						zMax = btmp.zMax;
					}
					if(btmp.zMin < zMin) {
						zMin = btmp.zMin;
					}
				}
				mtmp.multiply3x4(absPos,camera.mcam);
				let x = b.xMin;
				let y = b.yMin;
				let z = b.zMin;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let p_x = x;
				let p_y = y;
				let p_z = z;
				let px = p_x * mtmp._11 + p_y * mtmp._21 + p_z * mtmp._31 + mtmp._41;
				let py = p_x * mtmp._12 + p_y * mtmp._22 + p_z * mtmp._32 + mtmp._42;
				let pz = p_x * mtmp._13 + p_y * mtmp._23 + p_z * mtmp._33 + mtmp._43;
				p_x = px;
				p_y = py;
				p_z = pz;
				if(p_x < bounds.xMin) {
					bounds.xMin = p_x;
				}
				if(p_x > bounds.xMax) {
					bounds.xMax = p_x;
				}
				if(p_y < bounds.yMin) {
					bounds.yMin = p_y;
				}
				if(p_y > bounds.yMax) {
					bounds.yMax = p_y;
				}
				if(p_z < bounds.zMin) {
					bounds.zMin = p_z;
				}
				if(p_z > bounds.zMax) {
					bounds.zMax = p_z;
				}
				let x1 = b.xMin;
				let y1 = b.yMin;
				let z1 = b.zMax;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let p_x1 = x1;
				let p_y1 = y1;
				let p_z1 = z1;
				let px1 = p_x1 * mtmp._11 + p_y1 * mtmp._21 + p_z1 * mtmp._31 + mtmp._41;
				let py1 = p_x1 * mtmp._12 + p_y1 * mtmp._22 + p_z1 * mtmp._32 + mtmp._42;
				let pz1 = p_x1 * mtmp._13 + p_y1 * mtmp._23 + p_z1 * mtmp._33 + mtmp._43;
				p_x1 = px1;
				p_y1 = py1;
				p_z1 = pz1;
				if(p_x1 < bounds.xMin) {
					bounds.xMin = p_x1;
				}
				if(p_x1 > bounds.xMax) {
					bounds.xMax = p_x1;
				}
				if(p_y1 < bounds.yMin) {
					bounds.yMin = p_y1;
				}
				if(p_y1 > bounds.yMax) {
					bounds.yMax = p_y1;
				}
				if(p_z1 < bounds.zMin) {
					bounds.zMin = p_z1;
				}
				if(p_z1 > bounds.zMax) {
					bounds.zMax = p_z1;
				}
				let x2 = b.xMin;
				let y2 = b.yMax;
				let z2 = b.zMin;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let p_x2 = x2;
				let p_y2 = y2;
				let p_z2 = z2;
				let px2 = p_x2 * mtmp._11 + p_y2 * mtmp._21 + p_z2 * mtmp._31 + mtmp._41;
				let py2 = p_x2 * mtmp._12 + p_y2 * mtmp._22 + p_z2 * mtmp._32 + mtmp._42;
				let pz2 = p_x2 * mtmp._13 + p_y2 * mtmp._23 + p_z2 * mtmp._33 + mtmp._43;
				p_x2 = px2;
				p_y2 = py2;
				p_z2 = pz2;
				if(p_x2 < bounds.xMin) {
					bounds.xMin = p_x2;
				}
				if(p_x2 > bounds.xMax) {
					bounds.xMax = p_x2;
				}
				if(p_y2 < bounds.yMin) {
					bounds.yMin = p_y2;
				}
				if(p_y2 > bounds.yMax) {
					bounds.yMax = p_y2;
				}
				if(p_z2 < bounds.zMin) {
					bounds.zMin = p_z2;
				}
				if(p_z2 > bounds.zMax) {
					bounds.zMax = p_z2;
				}
				let x3 = b.xMin;
				let y3 = b.yMax;
				let z3 = b.zMax;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				let p_x3 = x3;
				let p_y3 = y3;
				let p_z3 = z3;
				let px3 = p_x3 * mtmp._11 + p_y3 * mtmp._21 + p_z3 * mtmp._31 + mtmp._41;
				let py3 = p_x3 * mtmp._12 + p_y3 * mtmp._22 + p_z3 * mtmp._32 + mtmp._42;
				let pz3 = p_x3 * mtmp._13 + p_y3 * mtmp._23 + p_z3 * mtmp._33 + mtmp._43;
				p_x3 = px3;
				p_y3 = py3;
				p_z3 = pz3;
				if(p_x3 < bounds.xMin) {
					bounds.xMin = p_x3;
				}
				if(p_x3 > bounds.xMax) {
					bounds.xMax = p_x3;
				}
				if(p_y3 < bounds.yMin) {
					bounds.yMin = p_y3;
				}
				if(p_y3 > bounds.yMax) {
					bounds.yMax = p_y3;
				}
				if(p_z3 < bounds.zMin) {
					bounds.zMin = p_z3;
				}
				if(p_z3 > bounds.zMax) {
					bounds.zMax = p_z3;
				}
				let x4 = b.xMax;
				let y4 = b.yMin;
				let z4 = b.zMin;
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				let p_x4 = x4;
				let p_y4 = y4;
				let p_z4 = z4;
				let px4 = p_x4 * mtmp._11 + p_y4 * mtmp._21 + p_z4 * mtmp._31 + mtmp._41;
				let py4 = p_x4 * mtmp._12 + p_y4 * mtmp._22 + p_z4 * mtmp._32 + mtmp._42;
				let pz4 = p_x4 * mtmp._13 + p_y4 * mtmp._23 + p_z4 * mtmp._33 + mtmp._43;
				p_x4 = px4;
				p_y4 = py4;
				p_z4 = pz4;
				if(p_x4 < bounds.xMin) {
					bounds.xMin = p_x4;
				}
				if(p_x4 > bounds.xMax) {
					bounds.xMax = p_x4;
				}
				if(p_y4 < bounds.yMin) {
					bounds.yMin = p_y4;
				}
				if(p_y4 > bounds.yMax) {
					bounds.yMax = p_y4;
				}
				if(p_z4 < bounds.zMin) {
					bounds.zMin = p_z4;
				}
				if(p_z4 > bounds.zMax) {
					bounds.zMax = p_z4;
				}
				let x5 = b.xMax;
				let y5 = b.yMin;
				let z5 = b.zMax;
				if(z5 == null) {
					z5 = 0.;
				}
				if(y5 == null) {
					y5 = 0.;
				}
				if(x5 == null) {
					x5 = 0.;
				}
				let p_x5 = x5;
				let p_y5 = y5;
				let p_z5 = z5;
				let px5 = p_x5 * mtmp._11 + p_y5 * mtmp._21 + p_z5 * mtmp._31 + mtmp._41;
				let py5 = p_x5 * mtmp._12 + p_y5 * mtmp._22 + p_z5 * mtmp._32 + mtmp._42;
				let pz5 = p_x5 * mtmp._13 + p_y5 * mtmp._23 + p_z5 * mtmp._33 + mtmp._43;
				p_x5 = px5;
				p_y5 = py5;
				p_z5 = pz5;
				if(p_x5 < bounds.xMin) {
					bounds.xMin = p_x5;
				}
				if(p_x5 > bounds.xMax) {
					bounds.xMax = p_x5;
				}
				if(p_y5 < bounds.yMin) {
					bounds.yMin = p_y5;
				}
				if(p_y5 > bounds.yMax) {
					bounds.yMax = p_y5;
				}
				if(p_z5 < bounds.zMin) {
					bounds.zMin = p_z5;
				}
				if(p_z5 > bounds.zMax) {
					bounds.zMax = p_z5;
				}
				let x6 = b.xMax;
				let y6 = b.yMax;
				let z6 = b.zMin;
				if(z6 == null) {
					z6 = 0.;
				}
				if(y6 == null) {
					y6 = 0.;
				}
				if(x6 == null) {
					x6 = 0.;
				}
				let p_x6 = x6;
				let p_y6 = y6;
				let p_z6 = z6;
				let px6 = p_x6 * mtmp._11 + p_y6 * mtmp._21 + p_z6 * mtmp._31 + mtmp._41;
				let py6 = p_x6 * mtmp._12 + p_y6 * mtmp._22 + p_z6 * mtmp._32 + mtmp._42;
				let pz6 = p_x6 * mtmp._13 + p_y6 * mtmp._23 + p_z6 * mtmp._33 + mtmp._43;
				p_x6 = px6;
				p_y6 = py6;
				p_z6 = pz6;
				if(p_x6 < bounds.xMin) {
					bounds.xMin = p_x6;
				}
				if(p_x6 > bounds.xMax) {
					bounds.xMax = p_x6;
				}
				if(p_y6 < bounds.yMin) {
					bounds.yMin = p_y6;
				}
				if(p_y6 > bounds.yMax) {
					bounds.yMax = p_y6;
				}
				if(p_z6 < bounds.zMin) {
					bounds.zMin = p_z6;
				}
				if(p_z6 > bounds.zMax) {
					bounds.zMax = p_z6;
				}
				let x7 = b.xMax;
				let y7 = b.yMax;
				let z7 = b.zMax;
				if(z7 == null) {
					z7 = 0.;
				}
				if(y7 == null) {
					y7 = 0.;
				}
				if(x7 == null) {
					x7 = 0.;
				}
				let p_x7 = x7;
				let p_y7 = y7;
				let p_z7 = z7;
				let px7 = p_x7 * mtmp._11 + p_y7 * mtmp._21 + p_z7 * mtmp._31 + mtmp._41;
				let py7 = p_x7 * mtmp._12 + p_y7 * mtmp._22 + p_z7 * mtmp._32 + mtmp._42;
				let pz7 = p_x7 * mtmp._13 + p_y7 * mtmp._23 + p_z7 * mtmp._33 + mtmp._43;
				p_x7 = px7;
				p_y7 = py7;
				p_z7 = pz7;
				if(p_x7 < bounds.xMin) {
					bounds.xMin = p_x7;
				}
				if(p_x7 > bounds.xMax) {
					bounds.xMax = p_x7;
				}
				if(p_y7 < bounds.yMin) {
					bounds.yMin = p_y7;
				}
				if(p_y7 > bounds.yMax) {
					bounds.yMax = p_y7;
				}
				if(p_z7 < bounds.zMin) {
					bounds.zMin = p_z7;
				}
				if(p_z7 > bounds.zMax) {
					bounds.zMax = p_z7;
				}
			});
		} else if(this.mode == h3d_pass_RenderMode.Dynamic) {
			bounds.xMin = -1e20;
			bounds.xMax = 1e20;
			bounds.yMin = -1e20;
			bounds.yMax = 1e20;
			bounds.zMin = -1e20;
			bounds.zMax = 1e20;
		}
		if(this.mode == h3d_pass_RenderMode.Dynamic) {
			let cameraBounds = new h3d_col_Bounds();
			let minDist = this.minDist < 0 ? this.ctx.camera.zNear : this.minDist;
			let maxDist = this.maxDist < 0 ? this.ctx.camera.zFar : this.maxDist;
			let dist = minDist;
			let _this = _gthis.ctx.camera.unproject(-1,-1,_gthis.ctx.camera.distanceToDepth(dist));
			let x = _this.x;
			let y = _this.y;
			let z = _this.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let pt_x = x;
			let pt_y = y;
			let pt_z = z;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				let _this = _gthis.ctx.camera.pos;
				let x = _this.x;
				let y = _this.y;
				let z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let p1_x = x;
				let p1_y = y;
				let p1_z = z;
				let r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x - p1_x;
				r.ly = pt_y - p1_y;
				r.lz = pt_z - p1_z;
				r.normalize();
				let v = zMax;
				if(v == null) {
					v = 0.0;
				}
				let p_nx = 0;
				let p_ny = 0;
				let p_nz = 1;
				let p_d = v;
				let d = r.lx * p_nx + r.ly * p_ny + r.lz * p_nz;
				let nd = p_d - (r.px * p_nx + r.py * p_ny + r.pz * p_nz);
				let d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				if(d2 > 0 && d2 > dist) {
					let x = r.px + d2 * r.lx;
					let y = r.py + d2 * r.ly;
					let z = r.pz + d2 * r.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let p_x = x;
					let p_y = y;
					let p_z = z;
					pt_x = p_x;
					pt_y = p_y;
					pt_z = p_z;
				}
			}
			let m = camera.mcam;
			let px = pt_x * m._11 + pt_y * m._21 + pt_z * m._31 + m._41;
			let py = pt_x * m._12 + pt_y * m._22 + pt_z * m._32 + m._42;
			let pz = pt_x * m._13 + pt_y * m._23 + pt_z * m._33 + m._43;
			pt_x = px;
			pt_y = py;
			pt_z = pz;
			let x1 = pt_x;
			let y1 = pt_y;
			let z1 = pt_z;
			if(x1 < cameraBounds.xMin) {
				cameraBounds.xMin = x1;
			}
			if(x1 > cameraBounds.xMax) {
				cameraBounds.xMax = x1;
			}
			if(y1 < cameraBounds.yMin) {
				cameraBounds.yMin = y1;
			}
			if(y1 > cameraBounds.yMax) {
				cameraBounds.yMax = y1;
			}
			if(z1 < cameraBounds.zMin) {
				cameraBounds.zMin = z1;
			}
			if(z1 > cameraBounds.zMax) {
				cameraBounds.zMax = z1;
			}
			let dist1 = minDist;
			let _this1 = _gthis.ctx.camera.unproject(-1,1,_gthis.ctx.camera.distanceToDepth(dist1));
			let x2 = _this1.x;
			let y2 = _this1.y;
			let z2 = _this1.z;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let pt_x1 = x2;
			let pt_y1 = y2;
			let pt_z1 = z2;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				let _this = _gthis.ctx.camera.pos;
				let x = _this.x;
				let y = _this.y;
				let z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let p1_x = x;
				let p1_y = y;
				let p1_z = z;
				let r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x1 - p1_x;
				r.ly = pt_y1 - p1_y;
				r.lz = pt_z1 - p1_z;
				r.normalize();
				let v = zMax;
				if(v == null) {
					v = 0.0;
				}
				let p_nx = 0;
				let p_ny = 0;
				let p_nz = 1;
				let p_d = v;
				let d = r.lx * p_nx + r.ly * p_ny + r.lz * p_nz;
				let nd = p_d - (r.px * p_nx + r.py * p_ny + r.pz * p_nz);
				let d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				if(d2 > 0 && d2 > dist1) {
					let x = r.px + d2 * r.lx;
					let y = r.py + d2 * r.ly;
					let z = r.pz + d2 * r.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let p_x = x;
					let p_y = y;
					let p_z = z;
					pt_x1 = p_x;
					pt_y1 = p_y;
					pt_z1 = p_z;
				}
			}
			let m1 = camera.mcam;
			let px1 = pt_x1 * m1._11 + pt_y1 * m1._21 + pt_z1 * m1._31 + m1._41;
			let py1 = pt_x1 * m1._12 + pt_y1 * m1._22 + pt_z1 * m1._32 + m1._42;
			let pz1 = pt_x1 * m1._13 + pt_y1 * m1._23 + pt_z1 * m1._33 + m1._43;
			pt_x1 = px1;
			pt_y1 = py1;
			pt_z1 = pz1;
			let x3 = pt_x1;
			let y3 = pt_y1;
			let z3 = pt_z1;
			if(x3 < cameraBounds.xMin) {
				cameraBounds.xMin = x3;
			}
			if(x3 > cameraBounds.xMax) {
				cameraBounds.xMax = x3;
			}
			if(y3 < cameraBounds.yMin) {
				cameraBounds.yMin = y3;
			}
			if(y3 > cameraBounds.yMax) {
				cameraBounds.yMax = y3;
			}
			if(z3 < cameraBounds.zMin) {
				cameraBounds.zMin = z3;
			}
			if(z3 > cameraBounds.zMax) {
				cameraBounds.zMax = z3;
			}
			let dist2 = minDist;
			let _this2 = _gthis.ctx.camera.unproject(1,-1,_gthis.ctx.camera.distanceToDepth(dist2));
			let x4 = _this2.x;
			let y4 = _this2.y;
			let z4 = _this2.z;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			let pt_x2 = x4;
			let pt_y2 = y4;
			let pt_z2 = z4;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				let _this = _gthis.ctx.camera.pos;
				let x = _this.x;
				let y = _this.y;
				let z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let p1_x = x;
				let p1_y = y;
				let p1_z = z;
				let r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x2 - p1_x;
				r.ly = pt_y2 - p1_y;
				r.lz = pt_z2 - p1_z;
				r.normalize();
				let v = zMax;
				if(v == null) {
					v = 0.0;
				}
				let p_nx = 0;
				let p_ny = 0;
				let p_nz = 1;
				let p_d = v;
				let d = r.lx * p_nx + r.ly * p_ny + r.lz * p_nz;
				let nd = p_d - (r.px * p_nx + r.py * p_ny + r.pz * p_nz);
				let d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				if(d2 > 0 && d2 > dist2) {
					let x = r.px + d2 * r.lx;
					let y = r.py + d2 * r.ly;
					let z = r.pz + d2 * r.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let p_x = x;
					let p_y = y;
					let p_z = z;
					pt_x2 = p_x;
					pt_y2 = p_y;
					pt_z2 = p_z;
				}
			}
			let m2 = camera.mcam;
			let px2 = pt_x2 * m2._11 + pt_y2 * m2._21 + pt_z2 * m2._31 + m2._41;
			let py2 = pt_x2 * m2._12 + pt_y2 * m2._22 + pt_z2 * m2._32 + m2._42;
			let pz2 = pt_x2 * m2._13 + pt_y2 * m2._23 + pt_z2 * m2._33 + m2._43;
			pt_x2 = px2;
			pt_y2 = py2;
			pt_z2 = pz2;
			let x5 = pt_x2;
			let y5 = pt_y2;
			let z5 = pt_z2;
			if(x5 < cameraBounds.xMin) {
				cameraBounds.xMin = x5;
			}
			if(x5 > cameraBounds.xMax) {
				cameraBounds.xMax = x5;
			}
			if(y5 < cameraBounds.yMin) {
				cameraBounds.yMin = y5;
			}
			if(y5 > cameraBounds.yMax) {
				cameraBounds.yMax = y5;
			}
			if(z5 < cameraBounds.zMin) {
				cameraBounds.zMin = z5;
			}
			if(z5 > cameraBounds.zMax) {
				cameraBounds.zMax = z5;
			}
			let dist3 = minDist;
			let _this3 = _gthis.ctx.camera.unproject(1,1,_gthis.ctx.camera.distanceToDepth(dist3));
			let x6 = _this3.x;
			let y6 = _this3.y;
			let z6 = _this3.z;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			let pt_x3 = x6;
			let pt_y3 = y6;
			let pt_z3 = z6;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				let _this = _gthis.ctx.camera.pos;
				let x = _this.x;
				let y = _this.y;
				let z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let p1_x = x;
				let p1_y = y;
				let p1_z = z;
				let r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x3 - p1_x;
				r.ly = pt_y3 - p1_y;
				r.lz = pt_z3 - p1_z;
				r.normalize();
				let v = zMax;
				if(v == null) {
					v = 0.0;
				}
				let p_nx = 0;
				let p_ny = 0;
				let p_nz = 1;
				let p_d = v;
				let d = r.lx * p_nx + r.ly * p_ny + r.lz * p_nz;
				let nd = p_d - (r.px * p_nx + r.py * p_ny + r.pz * p_nz);
				let d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				if(d2 > 0 && d2 > dist3) {
					let x = r.px + d2 * r.lx;
					let y = r.py + d2 * r.ly;
					let z = r.pz + d2 * r.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let p_x = x;
					let p_y = y;
					let p_z = z;
					pt_x3 = p_x;
					pt_y3 = p_y;
					pt_z3 = p_z;
				}
			}
			let m3 = camera.mcam;
			let px3 = pt_x3 * m3._11 + pt_y3 * m3._21 + pt_z3 * m3._31 + m3._41;
			let py3 = pt_x3 * m3._12 + pt_y3 * m3._22 + pt_z3 * m3._32 + m3._42;
			let pz3 = pt_x3 * m3._13 + pt_y3 * m3._23 + pt_z3 * m3._33 + m3._43;
			pt_x3 = px3;
			pt_y3 = py3;
			pt_z3 = pz3;
			let x7 = pt_x3;
			let y7 = pt_y3;
			let z7 = pt_z3;
			if(x7 < cameraBounds.xMin) {
				cameraBounds.xMin = x7;
			}
			if(x7 > cameraBounds.xMax) {
				cameraBounds.xMax = x7;
			}
			if(y7 < cameraBounds.yMin) {
				cameraBounds.yMin = y7;
			}
			if(y7 > cameraBounds.yMax) {
				cameraBounds.yMax = y7;
			}
			if(z7 < cameraBounds.zMin) {
				cameraBounds.zMin = z7;
			}
			if(z7 > cameraBounds.zMax) {
				cameraBounds.zMax = z7;
			}
			let dist4 = maxDist;
			let _this4 = _gthis.ctx.camera.unproject(-1,-1,_gthis.ctx.camera.distanceToDepth(dist4));
			let x8 = _this4.x;
			let y8 = _this4.y;
			let z8 = _this4.z;
			if(z8 == null) {
				z8 = 0.;
			}
			if(y8 == null) {
				y8 = 0.;
			}
			if(x8 == null) {
				x8 = 0.;
			}
			let pt_x4 = x8;
			let pt_y4 = y8;
			let pt_z4 = z8;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				let _this = _gthis.ctx.camera.pos;
				let x = _this.x;
				let y = _this.y;
				let z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let p1_x = x;
				let p1_y = y;
				let p1_z = z;
				let r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x4 - p1_x;
				r.ly = pt_y4 - p1_y;
				r.lz = pt_z4 - p1_z;
				r.normalize();
				let v = zMin;
				if(v == null) {
					v = 0.0;
				}
				let p_nx = 0;
				let p_ny = 0;
				let p_nz = 1;
				let p_d = v;
				let d = r.lx * p_nx + r.ly * p_ny + r.lz * p_nz;
				let nd = p_d - (r.px * p_nx + r.py * p_ny + r.pz * p_nz);
				let d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				if(d2 > 0 && d2 * -1 > dist4 * -1) {
					let x = r.px + d2 * r.lx;
					let y = r.py + d2 * r.ly;
					let z = r.pz + d2 * r.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let p_x = x;
					let p_y = y;
					let p_z = z;
					pt_x4 = p_x;
					pt_y4 = p_y;
					pt_z4 = p_z;
				}
			}
			let m4 = camera.mcam;
			let px4 = pt_x4 * m4._11 + pt_y4 * m4._21 + pt_z4 * m4._31 + m4._41;
			let py4 = pt_x4 * m4._12 + pt_y4 * m4._22 + pt_z4 * m4._32 + m4._42;
			let pz4 = pt_x4 * m4._13 + pt_y4 * m4._23 + pt_z4 * m4._33 + m4._43;
			pt_x4 = px4;
			pt_y4 = py4;
			pt_z4 = pz4;
			let x9 = pt_x4;
			let y9 = pt_y4;
			let z9 = pt_z4;
			if(x9 < cameraBounds.xMin) {
				cameraBounds.xMin = x9;
			}
			if(x9 > cameraBounds.xMax) {
				cameraBounds.xMax = x9;
			}
			if(y9 < cameraBounds.yMin) {
				cameraBounds.yMin = y9;
			}
			if(y9 > cameraBounds.yMax) {
				cameraBounds.yMax = y9;
			}
			if(z9 < cameraBounds.zMin) {
				cameraBounds.zMin = z9;
			}
			if(z9 > cameraBounds.zMax) {
				cameraBounds.zMax = z9;
			}
			let dist5 = maxDist;
			let _this5 = _gthis.ctx.camera.unproject(-1,1,_gthis.ctx.camera.distanceToDepth(dist5));
			let x10 = _this5.x;
			let y10 = _this5.y;
			let z10 = _this5.z;
			if(z10 == null) {
				z10 = 0.;
			}
			if(y10 == null) {
				y10 = 0.;
			}
			if(x10 == null) {
				x10 = 0.;
			}
			let pt_x5 = x10;
			let pt_y5 = y10;
			let pt_z5 = z10;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				let _this = _gthis.ctx.camera.pos;
				let x = _this.x;
				let y = _this.y;
				let z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let p1_x = x;
				let p1_y = y;
				let p1_z = z;
				let r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x5 - p1_x;
				r.ly = pt_y5 - p1_y;
				r.lz = pt_z5 - p1_z;
				r.normalize();
				let v = zMin;
				if(v == null) {
					v = 0.0;
				}
				let p_nx = 0;
				let p_ny = 0;
				let p_nz = 1;
				let p_d = v;
				let d = r.lx * p_nx + r.ly * p_ny + r.lz * p_nz;
				let nd = p_d - (r.px * p_nx + r.py * p_ny + r.pz * p_nz);
				let d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				if(d2 > 0 && d2 * -1 > dist5 * -1) {
					let x = r.px + d2 * r.lx;
					let y = r.py + d2 * r.ly;
					let z = r.pz + d2 * r.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let p_x = x;
					let p_y = y;
					let p_z = z;
					pt_x5 = p_x;
					pt_y5 = p_y;
					pt_z5 = p_z;
				}
			}
			let m5 = camera.mcam;
			let px5 = pt_x5 * m5._11 + pt_y5 * m5._21 + pt_z5 * m5._31 + m5._41;
			let py5 = pt_x5 * m5._12 + pt_y5 * m5._22 + pt_z5 * m5._32 + m5._42;
			let pz5 = pt_x5 * m5._13 + pt_y5 * m5._23 + pt_z5 * m5._33 + m5._43;
			pt_x5 = px5;
			pt_y5 = py5;
			pt_z5 = pz5;
			let x11 = pt_x5;
			let y11 = pt_y5;
			let z11 = pt_z5;
			if(x11 < cameraBounds.xMin) {
				cameraBounds.xMin = x11;
			}
			if(x11 > cameraBounds.xMax) {
				cameraBounds.xMax = x11;
			}
			if(y11 < cameraBounds.yMin) {
				cameraBounds.yMin = y11;
			}
			if(y11 > cameraBounds.yMax) {
				cameraBounds.yMax = y11;
			}
			if(z11 < cameraBounds.zMin) {
				cameraBounds.zMin = z11;
			}
			if(z11 > cameraBounds.zMax) {
				cameraBounds.zMax = z11;
			}
			let dist6 = maxDist;
			let _this6 = _gthis.ctx.camera.unproject(1,-1,_gthis.ctx.camera.distanceToDepth(dist6));
			let x12 = _this6.x;
			let y12 = _this6.y;
			let z12 = _this6.z;
			if(z12 == null) {
				z12 = 0.;
			}
			if(y12 == null) {
				y12 = 0.;
			}
			if(x12 == null) {
				x12 = 0.;
			}
			let pt_x6 = x12;
			let pt_y6 = y12;
			let pt_z6 = z12;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				let _this = _gthis.ctx.camera.pos;
				let x = _this.x;
				let y = _this.y;
				let z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let p1_x = x;
				let p1_y = y;
				let p1_z = z;
				let r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x6 - p1_x;
				r.ly = pt_y6 - p1_y;
				r.lz = pt_z6 - p1_z;
				r.normalize();
				let v = zMin;
				if(v == null) {
					v = 0.0;
				}
				let p_nx = 0;
				let p_ny = 0;
				let p_nz = 1;
				let p_d = v;
				let d = r.lx * p_nx + r.ly * p_ny + r.lz * p_nz;
				let nd = p_d - (r.px * p_nx + r.py * p_ny + r.pz * p_nz);
				let d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				if(d2 > 0 && d2 * -1 > dist6 * -1) {
					let x = r.px + d2 * r.lx;
					let y = r.py + d2 * r.ly;
					let z = r.pz + d2 * r.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let p_x = x;
					let p_y = y;
					let p_z = z;
					pt_x6 = p_x;
					pt_y6 = p_y;
					pt_z6 = p_z;
				}
			}
			let m6 = camera.mcam;
			let px6 = pt_x6 * m6._11 + pt_y6 * m6._21 + pt_z6 * m6._31 + m6._41;
			let py6 = pt_x6 * m6._12 + pt_y6 * m6._22 + pt_z6 * m6._32 + m6._42;
			let pz6 = pt_x6 * m6._13 + pt_y6 * m6._23 + pt_z6 * m6._33 + m6._43;
			pt_x6 = px6;
			pt_y6 = py6;
			pt_z6 = pz6;
			let x13 = pt_x6;
			let y13 = pt_y6;
			let z13 = pt_z6;
			if(x13 < cameraBounds.xMin) {
				cameraBounds.xMin = x13;
			}
			if(x13 > cameraBounds.xMax) {
				cameraBounds.xMax = x13;
			}
			if(y13 < cameraBounds.yMin) {
				cameraBounds.yMin = y13;
			}
			if(y13 > cameraBounds.yMax) {
				cameraBounds.yMax = y13;
			}
			if(z13 < cameraBounds.zMin) {
				cameraBounds.zMin = z13;
			}
			if(z13 > cameraBounds.zMax) {
				cameraBounds.zMax = z13;
			}
			let dist7 = maxDist;
			let _this7 = _gthis.ctx.camera.unproject(1,1,_gthis.ctx.camera.distanceToDepth(dist7));
			let x14 = _this7.x;
			let y14 = _this7.y;
			let z14 = _this7.z;
			if(z14 == null) {
				z14 = 0.;
			}
			if(y14 == null) {
				y14 = 0.;
			}
			if(x14 == null) {
				x14 = 0.;
			}
			let pt_x7 = x14;
			let pt_y7 = y14;
			let pt_z7 = z14;
			if(_gthis.autoShrink && _gthis.autoZPlanes) {
				let _this = _gthis.ctx.camera.pos;
				let x = _this.x;
				let y = _this.y;
				let z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let p1_x = x;
				let p1_y = y;
				let p1_z = z;
				let r = new h3d_col_Ray();
				r.px = p1_x;
				r.py = p1_y;
				r.pz = p1_z;
				r.lx = pt_x7 - p1_x;
				r.ly = pt_y7 - p1_y;
				r.lz = pt_z7 - p1_z;
				r.normalize();
				let v = zMin;
				if(v == null) {
					v = 0.0;
				}
				let p_nx = 0;
				let p_ny = 0;
				let p_nz = 1;
				let p_d = v;
				let d = r.lx * p_nx + r.ly * p_ny + r.lz * p_nz;
				let nd = p_d - (r.px * p_nx + r.py * p_ny + r.pz * p_nz);
				let d2 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
				if(d2 > 0 && d2 * -1 > dist7 * -1) {
					let x = r.px + d2 * r.lx;
					let y = r.py + d2 * r.ly;
					let z = r.pz + d2 * r.lz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let p_x = x;
					let p_y = y;
					let p_z = z;
					pt_x7 = p_x;
					pt_y7 = p_y;
					pt_z7 = p_z;
				}
			}
			let m7 = camera.mcam;
			let px7 = pt_x7 * m7._11 + pt_y7 * m7._21 + pt_z7 * m7._31 + m7._41;
			let py7 = pt_x7 * m7._12 + pt_y7 * m7._22 + pt_z7 * m7._32 + m7._42;
			let pz7 = pt_x7 * m7._13 + pt_y7 * m7._23 + pt_z7 * m7._33 + m7._43;
			pt_x7 = px7;
			pt_y7 = py7;
			pt_z7 = pz7;
			let x15 = pt_x7;
			let y15 = pt_y7;
			let z15 = pt_z7;
			if(x15 < cameraBounds.xMin) {
				cameraBounds.xMin = x15;
			}
			if(x15 > cameraBounds.xMax) {
				cameraBounds.xMax = x15;
			}
			if(y15 < cameraBounds.yMin) {
				cameraBounds.yMin = y15;
			}
			if(y15 > cameraBounds.yMax) {
				cameraBounds.yMax = y15;
			}
			if(z15 < cameraBounds.zMin) {
				cameraBounds.zMin = z15;
			}
			if(z15 > cameraBounds.zMax) {
				cameraBounds.zMax = z15;
			}
			if(this.autoShrink) {
				cameraBounds.zMin = bounds.zMin;
				bounds.intersection(bounds,cameraBounds);
				if(this.autoZPlanes) {
					let _this = camera.target;
					let v = camera.pos;
					let x = _this.x - v.x;
					let y = _this.y - v.y;
					let z = _this.z - v.z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let _this_x = x;
					let _this_y = y;
					let _this_z = z;
					let k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
					if(k < 1e-10) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					let x1 = _this_x * k;
					let y1 = _this_y * k;
					let z1 = _this_z * k;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let v_x = x1;
					let v_y = y1;
					let v_z = z1;
					let dMin = 1e9;
					let px = bounds.xMin;
					let py = bounds.yMin;
					let x2 = px;
					let y2 = py;
					let z2 = bounds.zMin;
					if(z2 == null) {
						z2 = 0.;
					}
					if(py == null) {
						y2 = 0.;
					}
					if(px == null) {
						x2 = 0.;
					}
					let _this_x1 = x2;
					let _this_y1 = y2;
					let _this_z1 = z2;
					let m = camera.getInverseView();
					let px1 = _this_x1 * m._11 + _this_y1 * m._21 + _this_z1 * m._31 + m._41;
					let py1 = _this_x1 * m._12 + _this_y1 * m._22 + _this_z1 * m._32 + m._42;
					let pz = _this_x1 * m._13 + _this_y1 * m._23 + _this_z1 * m._33 + m._43;
					let x3 = px1;
					let y3 = py1;
					let z3 = pz;
					if(pz == null) {
						z3 = 0.;
					}
					if(py1 == null) {
						y3 = 0.;
					}
					if(px1 == null) {
						x3 = 0.;
					}
					let r0_x = x3;
					let r0_y = y3;
					let r0_z = z3;
					let r = new h3d_col_Ray();
					r.px = r0_x;
					r.py = r0_y;
					r.pz = r0_z;
					r.lx = v_x;
					r.ly = v_y;
					r.lz = v_z;
					r.normalize();
					let v1 = zMax;
					if(v1 == null) {
						v1 = 0.0;
					}
					let p_nx = 0;
					let p_ny = 0;
					let p_nz = 1;
					let p_d = v1;
					let d = r.lx * p_nx + r.ly * p_ny + r.lz * p_nz;
					let nd = p_d - (r.px * p_nx + r.py * p_ny + r.pz * p_nz);
					let d1 = (d < 0 ? -d : d) < 1e-10 ? (nd < 0 ? -nd : nd) < 1e-10 ? 0. : -1 : nd / d;
					if(d1 < 1e9) {
						dMin = d1;
					}
					let px2 = bounds.xMin;
					let py2 = bounds.yMax;
					let x4 = px2;
					let y4 = py2;
					let z4 = bounds.zMin;
					if(z4 == null) {
						z4 = 0.;
					}
					if(py2 == null) {
						y4 = 0.;
					}
					if(px2 == null) {
						x4 = 0.;
					}
					let _this_x2 = x4;
					let _this_y2 = y4;
					let _this_z2 = z4;
					let m1 = camera.getInverseView();
					let px3 = _this_x2 * m1._11 + _this_y2 * m1._21 + _this_z2 * m1._31 + m1._41;
					let py3 = _this_x2 * m1._12 + _this_y2 * m1._22 + _this_z2 * m1._32 + m1._42;
					let pz1 = _this_x2 * m1._13 + _this_y2 * m1._23 + _this_z2 * m1._33 + m1._43;
					let x5 = px3;
					let y5 = py3;
					let z5 = pz1;
					if(pz1 == null) {
						z5 = 0.;
					}
					if(py3 == null) {
						y5 = 0.;
					}
					if(px3 == null) {
						x5 = 0.;
					}
					let r0_x1 = x5;
					let r0_y1 = y5;
					let r0_z1 = z5;
					let r1 = new h3d_col_Ray();
					r1.px = r0_x1;
					r1.py = r0_y1;
					r1.pz = r0_z1;
					r1.lx = v_x;
					r1.ly = v_y;
					r1.lz = v_z;
					r1.normalize();
					let v2 = zMax;
					if(v2 == null) {
						v2 = 0.0;
					}
					let p_nx1 = 0;
					let p_ny1 = 0;
					let p_nz1 = 1;
					let p_d1 = v2;
					let d2 = r1.lx * p_nx1 + r1.ly * p_ny1 + r1.lz * p_nz1;
					let nd1 = p_d1 - (r1.px * p_nx1 + r1.py * p_ny1 + r1.pz * p_nz1);
					let d3 = (d2 < 0 ? -d2 : d2) < 1e-10 ? (nd1 < 0 ? -nd1 : nd1) < 1e-10 ? 0. : -1 : nd1 / d2;
					if(d3 < dMin) {
						dMin = d3;
					}
					let px4 = bounds.xMax;
					let py4 = bounds.yMin;
					let x6 = px4;
					let y6 = py4;
					let z6 = bounds.zMin;
					if(z6 == null) {
						z6 = 0.;
					}
					if(py4 == null) {
						y6 = 0.;
					}
					if(px4 == null) {
						x6 = 0.;
					}
					let _this_x3 = x6;
					let _this_y3 = y6;
					let _this_z3 = z6;
					let m2 = camera.getInverseView();
					let px5 = _this_x3 * m2._11 + _this_y3 * m2._21 + _this_z3 * m2._31 + m2._41;
					let py5 = _this_x3 * m2._12 + _this_y3 * m2._22 + _this_z3 * m2._32 + m2._42;
					let pz2 = _this_x3 * m2._13 + _this_y3 * m2._23 + _this_z3 * m2._33 + m2._43;
					let x7 = px5;
					let y7 = py5;
					let z7 = pz2;
					if(pz2 == null) {
						z7 = 0.;
					}
					if(py5 == null) {
						y7 = 0.;
					}
					if(px5 == null) {
						x7 = 0.;
					}
					let r0_x2 = x7;
					let r0_y2 = y7;
					let r0_z2 = z7;
					let r2 = new h3d_col_Ray();
					r2.px = r0_x2;
					r2.py = r0_y2;
					r2.pz = r0_z2;
					r2.lx = v_x;
					r2.ly = v_y;
					r2.lz = v_z;
					r2.normalize();
					let v3 = zMax;
					if(v3 == null) {
						v3 = 0.0;
					}
					let p_nx2 = 0;
					let p_ny2 = 0;
					let p_nz2 = 1;
					let p_d2 = v3;
					let d4 = r2.lx * p_nx2 + r2.ly * p_ny2 + r2.lz * p_nz2;
					let nd2 = p_d2 - (r2.px * p_nx2 + r2.py * p_ny2 + r2.pz * p_nz2);
					let d5 = (d4 < 0 ? -d4 : d4) < 1e-10 ? (nd2 < 0 ? -nd2 : nd2) < 1e-10 ? 0. : -1 : nd2 / d4;
					if(d5 < dMin) {
						dMin = d5;
					}
					let px6 = bounds.xMax;
					let py6 = bounds.yMax;
					let x8 = px6;
					let y8 = py6;
					let z8 = bounds.zMin;
					if(z8 == null) {
						z8 = 0.;
					}
					if(py6 == null) {
						y8 = 0.;
					}
					if(px6 == null) {
						x8 = 0.;
					}
					let _this_x4 = x8;
					let _this_y4 = y8;
					let _this_z4 = z8;
					let m3 = camera.getInverseView();
					let px7 = _this_x4 * m3._11 + _this_y4 * m3._21 + _this_z4 * m3._31 + m3._41;
					let py7 = _this_x4 * m3._12 + _this_y4 * m3._22 + _this_z4 * m3._32 + m3._42;
					let pz3 = _this_x4 * m3._13 + _this_y4 * m3._23 + _this_z4 * m3._33 + m3._43;
					let x9 = px7;
					let y9 = py7;
					let z9 = pz3;
					if(pz3 == null) {
						z9 = 0.;
					}
					if(py7 == null) {
						y9 = 0.;
					}
					if(px7 == null) {
						x9 = 0.;
					}
					let r0_x3 = x9;
					let r0_y3 = y9;
					let r0_z3 = z9;
					let r3 = new h3d_col_Ray();
					r3.px = r0_x3;
					r3.py = r0_y3;
					r3.pz = r0_z3;
					r3.lx = v_x;
					r3.ly = v_y;
					r3.lz = v_z;
					r3.normalize();
					let v4 = zMax;
					if(v4 == null) {
						v4 = 0.0;
					}
					let p_nx3 = 0;
					let p_ny3 = 0;
					let p_nz3 = 1;
					let p_d3 = v4;
					let d6 = r3.lx * p_nx3 + r3.ly * p_ny3 + r3.lz * p_nz3;
					let nd3 = p_d3 - (r3.px * p_nx3 + r3.py * p_ny3 + r3.pz * p_nz3);
					let d7 = (d6 < 0 ? -d6 : d6) < 1e-10 ? (nd3 < 0 ? -nd3 : nd3) < 1e-10 ? 0. : -1 : nd3 / d6;
					if(d7 < dMin) {
						dMin = d7;
					}
					bounds.zMin += dMin;
				}
			} else {
				bounds.load(cameraBounds);
			}
		}
		bounds.scaleCenter(1.01);
	}
	setGlobals() {
		super.setGlobals();
		if(this.mode != h3d_pass_RenderMode.Mixed || this.ctx.computingStatic) {
			let _this = this.lightCamera.orthoBounds;
			_this.xMin = 1e20;
			_this.xMax = -1e20;
			_this.yMin = 1e20;
			_this.yMax = -1e20;
			_this.zMin = 1e20;
			_this.zMax = -1e20;
			this.calcShadowBounds(this.lightCamera);
			this.lightCamera.update();
		}
		let v = this.getShadowProj();
		this.manager.globals.map.h[this.cameraViewProj_id] = v;
	}
	syncShader(texture) {
		let _this = this.dshader;
		_this.constModified = true;
		_this.shadowMap__ = texture;
		let _this1 = this.dshader;
		_this1.constModified = true;
		_this1.shadowMapChannel__ = this.format == h3d_mat_Texture.nativeFormat ? hxsl_Channel.PackedFloat : hxsl_Channel.R;
		this.dshader.shadowBias__ = this.bias;
		this.dshader.shadowPower__ = this.power;
		this.dshader.shadowProj__ = this.getShadowProj();
		let _this2 = this.dshader;
		_this2.constModified = true;
		_this2.USE_ESM__ = this.samplingKind == h3d_pass_ShadowSamplingKind.ESM;
		this.dshader.shadowPower__ = this.power;
		let _this3 = this.dshader;
		_this3.constModified = true;
		_this3.USE_PCF__ = this.samplingKind == h3d_pass_ShadowSamplingKind.PCF;
		let _this4 = this.dshader.shadowRes__;
		let x = texture.width;
		let y = texture.height;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this4.x = x;
		_this4.y = y;
		_this4.z = 0.;
		_this4.w = 1.;
		this.dshader.pcfScale__ = this.pcfScale;
		this.dshader.set_pcfQuality(this.pcfQuality);
	}
	processShadowMap(passes,tex,sort) {
		this.ctx.engine.pushTarget(tex);
		this.ctx.engine.clear(16777215,1);
		super.draw(passes,sort);
		let doBlur = this.blur.radius > 0 && (this.mode != h3d_pass_RenderMode.Mixed || !this.ctx.computingStatic);
		if(this.border != null && !doBlur) {
			this.border.render();
		}
		this.ctx.engine.popTarget();
		if(this.mode == h3d_pass_RenderMode.Mixed && !this.ctx.computingStatic) {
			let merge = this.ctx.textures.allocTarget("mergedDirShadowMap",this.size,this.size,false,this.format);
			this.mergePass.shader.texA__ = tex;
			this.mergePass.shader.texB__ = this.staticTexture;
			this.ctx.engine.pushTarget(merge);
			this.mergePass.render();
			this.ctx.engine.popTarget();
			tex = merge;
		}
		if(doBlur) {
			this.blur.apply(this.ctx,tex);
			if(this.border != null) {
				this.ctx.engine.pushTarget(tex);
				this.border.render();
				this.ctx.engine.popTarget();
			}
		}
	}
	draw(passes,sort) {
		if(!this.enabled) {
			return;
		}
		if(!this.filterPasses(passes)) {
			return;
		}
		let _gthis = this;
		let f = function(col) {
			return col.inFrustum(_gthis.lightCamera.frustum);
		};
		let prevCollider = null;
		let prevResult = true;
		let head = null;
		let prev = null;
		let disc = passes.discarded;
		let discQueue = passes.lastDisc;
		let cur = passes.current;
		while(cur != null) {
			let col = cur.obj.cullingCollider;
			let tmp;
			if(col == null) {
				tmp = true;
			} else {
				if(col != prevCollider) {
					prevCollider = col;
					prevResult = f(col);
				}
				tmp = prevResult;
			}
			if(tmp) {
				if(head == null) {
					prev = cur;
					head = prev;
				} else {
					prev.next = cur;
					prev = cur;
				}
			} else if(disc == null) {
				discQueue = cur;
				disc = discQueue;
			} else {
				discQueue.next = cur;
				discQueue = cur;
			}
			cur = cur.next;
		}
		if(prev != null) {
			prev.next = null;
		}
		if(discQueue != null) {
			discQueue.next = null;
		}
		passes.current = head;
		passes.discarded = disc;
		passes.lastDisc = discQueue;
		let texture = this.ctx.textures.allocTarget("dirShadowMap",this.size,this.size,false,this.format);
		if(this.customDepth && (this.depth == null || this.depth.width != this.size || this.depth.height != this.size || this.depth.isDisposed())) {
			if(this.depth != null) {
				this.depth.dispose();
			}
			this.depth = new h3d_mat_DepthBuffer(this.size,this.size);
		}
		texture.depthBuffer = this.depth;
		if(this.mode != h3d_pass_RenderMode.Mixed || this.ctx.computingStatic) {
			let ct = this.ctx.camera.target;
			let slight = this.light == null ? this.ctx.lightSystem.shadowLight : this.light;
			let ldir = slight == null ? null : slight.getShadowDirection();
			if(ldir == null) {
				let _this = this.lightCamera.target;
				_this.x = 0;
				_this.y = 0;
				_this.z = -1;
				_this.w = 1.;
			} else {
				let _this = this.lightCamera.target;
				let x = ldir.x;
				let y = ldir.y;
				let z = ldir.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				_this.x = x;
				_this.y = y;
				_this.z = z;
				_this.w = 1.;
				let _this1 = this.lightCamera.target;
				let k = _this1.x * _this1.x + _this1.y * _this1.y + _this1.z * _this1.z;
				if(k < 1e-10) {
					k = 0;
				} else {
					k = 1. / Math.sqrt(k);
				}
				_this1.x *= k;
				_this1.y *= k;
				_this1.z *= k;
			}
			this.lightCamera.target.x += ct.x;
			this.lightCamera.target.y += ct.y;
			this.lightCamera.target.z += ct.z;
			let _this = this.lightCamera.pos;
			_this.x = ct.x;
			_this.y = ct.y;
			_this.z = ct.z;
			_this.w = ct.w;
			this.lightCamera.update();
			let _this1 = this.lightCamera.orthoBounds;
			_this1.xMin = 1e20;
			_this1.xMax = -1e20;
			_this1.yMin = 1e20;
			_this1.yMax = -1e20;
			_this1.zMin = 1e20;
			_this1.zMax = -1e20;
			if(passes.current != null) {
				this.calcShadowBounds(this.lightCamera);
			}
			this.lightCamera.update();
		}
		let f1 = function(col) {
			return col.inFrustum(_gthis.lightCamera.frustum);
		};
		let prevCollider1 = null;
		let prevResult1 = true;
		let head1 = null;
		let prev1 = null;
		let disc1 = passes.discarded;
		let discQueue1 = passes.lastDisc;
		let cur1 = passes.current;
		while(cur1 != null) {
			let col = cur1.obj.cullingCollider;
			let tmp;
			if(col == null) {
				tmp = true;
			} else {
				if(col != prevCollider1) {
					prevCollider1 = col;
					prevResult1 = f1(col);
				}
				tmp = prevResult1;
			}
			if(tmp) {
				if(head1 == null) {
					prev1 = cur1;
					head1 = prev1;
				} else {
					prev1.next = cur1;
					prev1 = cur1;
				}
			} else if(disc1 == null) {
				discQueue1 = cur1;
				disc1 = discQueue1;
			} else {
				discQueue1.next = cur1;
				discQueue1 = cur1;
			}
			cur1 = cur1.next;
		}
		if(prev1 != null) {
			prev1.next = null;
		}
		if(discQueue1 != null) {
			discQueue1.next = null;
		}
		passes.current = head1;
		passes.discarded = disc1;
		passes.lastDisc = discQueue1;
		let texture1 = this.ctx.textures.allocTarget("dirShadowMap",this.size,this.size,false,this.format);
		if(this.customDepth && (this.depth == null || this.depth.width != this.size || this.depth.height != this.size || this.depth.isDisposed())) {
			if(this.depth != null) {
				this.depth.dispose();
			}
			this.depth = new h3d_mat_DepthBuffer(this.size,this.size);
		}
		texture1.depthBuffer = this.depth;
		this.processShadowMap(passes,texture1,sort);
		this.syncShader(texture1);
	}
}
$hxClasses["h3d.pass.DirShadowMap"] = h3d_pass_DirShadowMap;
h3d_pass_DirShadowMap.__name__ = "h3d.pass.DirShadowMap";
h3d_pass_DirShadowMap.__super__ = h3d_pass_Shadows;
Object.assign(h3d_pass_DirShadowMap.prototype, {
	__class__: h3d_pass_DirShadowMap
	,customDepth: null
	,depth: null
	,dshader: null
	,border: null
	,mergePass: null
	,boundingObject: null
	,autoShrink: null
	,autoZPlanes: null
	,maxDist: null
	,minDist: null
});
class h3d_pass_DefaultShadowMap extends h3d_pass_DirShadowMap {
	constructor(size,format) {
		h3d_pass_Base._hx_skip_constructor = true;
		super();
		h3d_pass_Base._hx_skip_constructor = false;
		this._hx_constructor(size,format);
	}
	_hx_constructor(size,format) {
		if(size == null) {
			size = 1024;
		}
		if(format != null) {
			this.format = format;
		}
		super._hx_constructor(null);
		this.set_size(size);
		this.color = new h3d_Vector();
		this.set_mode(h3d_pass_RenderMode.Dynamic);
		this.shadowMapId = hxsl_Globals.allocID("shadow.map");
		this.shadowProjId = hxsl_Globals.allocID("shadow.proj");
		this.shadowColorId = hxsl_Globals.allocID("shadow.color");
		this.shadowPowerId = hxsl_Globals.allocID("shadow.power");
		this.shadowBiasId = hxsl_Globals.allocID("shadow.bias");
	}
	draw(passes,sort) {
		super.draw(passes,sort);
		this.ctx.setGlobalID(this.shadowMapId,{ texture : this.dshader.shadowMap__, channel : this.format == h3d_mat_Texture.nativeFormat ? hxsl_Channel.PackedFloat : hxsl_Channel.R});
		this.ctx.setGlobalID(this.shadowProjId,this.getShadowProj());
		this.ctx.setGlobalID(this.shadowColorId,this.color);
		this.ctx.setGlobalID(this.shadowPowerId,this.power);
		this.ctx.setGlobalID(this.shadowBiasId,this.bias);
	}
}
$hxClasses["h3d.pass.DefaultShadowMap"] = h3d_pass_DefaultShadowMap;
h3d_pass_DefaultShadowMap.__name__ = "h3d.pass.DefaultShadowMap";
h3d_pass_DefaultShadowMap.__super__ = h3d_pass_DirShadowMap;
Object.assign(h3d_pass_DefaultShadowMap.prototype, {
	__class__: h3d_pass_DefaultShadowMap
	,shadowMapId: null
	,shadowProjId: null
	,shadowColorId: null
	,shadowPowerId: null
	,shadowBiasId: null
	,color: null
});
class h3d_pass__$HardwarePick_FixedColor extends hxsl_Shader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.viewport__ = new h3d_Vector();
		this.colorID__ = new h3d_Vector();
		super._hx_constructor();
	}
	get_colorID() {
		return this.colorID__;
	}
	set_colorID(_v) {
		return this.colorID__ = _v;
	}
	get_viewport() {
		return this.viewport__;
	}
	set_viewport(_v) {
		return this.viewport__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.colorID__;
		case 1:
			return this.viewport__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_pass__$HardwarePick_FixedColor.prototype);
		s.shader = this.shader;
		s.colorID__ = this.colorID__;
		s.viewport__ = this.viewport__;
		return s;
	}
}
$hxClasses["h3d.pass._HardwarePick.FixedColor"] = h3d_pass__$HardwarePick_FixedColor;
h3d_pass__$HardwarePick_FixedColor.__name__ = "h3d.pass._HardwarePick.FixedColor";
h3d_pass__$HardwarePick_FixedColor.__super__ = hxsl_Shader;
Object.assign(h3d_pass__$HardwarePick_FixedColor.prototype, {
	__class__: h3d_pass__$HardwarePick_FixedColor
	,colorID__: null
	,viewport__: null
});
class h3d_pass_PassList {
	constructor(current) {
		this.current = current;
		this.discarded = this.lastDisc = null;
	}
}
$hxClasses["h3d.pass.PassList"] = h3d_pass_PassList;
h3d_pass_PassList.__name__ = "h3d.pass.PassList";
Object.assign(h3d_pass_PassList.prototype, {
	__class__: h3d_pass_PassList
	,current: null
	,discarded: null
	,lastDisc: null
});
class h3d_pass_PassObject {
	constructor() {
		this.texture = 0;
	}
}
$hxClasses["h3d.pass.PassObject"] = h3d_pass_PassObject;
h3d_pass_PassObject.__name__ = "h3d.pass.PassObject";
Object.assign(h3d_pass_PassObject.prototype, {
	__class__: h3d_pass_PassObject
	,next: null
	,nextAlloc: null
	,pass: null
	,obj: null
	,index: null
	,shaders: null
	,shader: null
	,depth: null
	,texture: null
});
class h3d_pass_ShaderManager {
	constructor(output) {
		this.shaderCache = hxsl_Cache.get();
		this.globals = new hxsl_Globals();
		this.currentOutput = new hxsl_ShaderList(null);
		this.setOutput(output);
	}
	setOutput(output) {
		if(output == null) {
			output = [hxsl_Output.Value("output.color")];
		}
		this.currentOutput.s = this.shaderCache.getLinkShader(output);
	}
	fillRec(v,type,out,pos) {
		switch(type._hx_index) {
		case 1:
			out[pos] = v;
			return 1;
		case 3:
			out[pos] = v;
			return 1;
		case 5:
			let _g = type.size;
			let v1 = v;
			out[pos++] = v1.x;
			out[pos++] = v1.y;
			switch(_g) {
			case 3:
				out[pos++] = v1.z;
				break;
			case 4:
				out[pos++] = v1.z;
				out[pos++] = v1.w;
				break;
			}
			return _g;
		case 6:
			let m = v;
			out[pos++] = m._11;
			out[pos++] = m._21;
			out[pos++] = m._31;
			out[pos++] = 0;
			out[pos++] = m._12;
			out[pos++] = m._22;
			out[pos++] = m._32;
			out[pos++] = 0;
			out[pos++] = m._13;
			out[pos++] = m._23;
			out[pos++] = m._33;
			out[pos++] = 0;
			return 12;
		case 7:
			let m1 = v;
			out[pos++] = m1._11;
			out[pos++] = m1._21;
			out[pos++] = m1._31;
			out[pos++] = m1._41;
			out[pos++] = m1._12;
			out[pos++] = m1._22;
			out[pos++] = m1._32;
			out[pos++] = m1._42;
			out[pos++] = m1._13;
			out[pos++] = m1._23;
			out[pos++] = m1._33;
			out[pos++] = m1._43;
			out[pos++] = m1._14;
			out[pos++] = m1._24;
			out[pos++] = m1._34;
			out[pos++] = m1._44;
			return 16;
		case 8:
			let m2 = v;
			out[pos++] = m2._11;
			out[pos++] = m2._21;
			out[pos++] = m2._31;
			out[pos++] = m2._41;
			out[pos++] = m2._12;
			out[pos++] = m2._22;
			out[pos++] = m2._32;
			out[pos++] = m2._42;
			out[pos++] = m2._13;
			out[pos++] = m2._23;
			out[pos++] = m2._33;
			out[pos++] = m2._43;
			return 12;
		case 13:
			let _g1 = type.vl;
			let tot = 0;
			let _g2 = 0;
			while(_g2 < _g1.length) {
				let vv = _g1[_g2];
				++_g2;
				tot += this.fillRec(Reflect.field(v,vv.name),vv.type,out,pos + tot);
			}
			return tot;
		case 15:
			let _g3 = type.t;
			let _g4 = type.size;
			switch(_g3._hx_index) {
			case 3:
				if(_g4._hx_index == 0) {
					let _g = _g4.v;
					let v1 = v;
					let count = v1.length < _g ? v1.length : _g;
					let _g1 = 0;
					let _g2 = count;
					while(_g1 < _g2) {
						let i = _g1++;
						out[pos++] = v1[i];
					}
					return _g;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
				break;
			case 5:
				if(_g3.size == 4) {
					if(_g3.t._hx_index == 1) {
						if(_g4._hx_index == 0) {
							let _g = _g4.v;
							let v1 = v;
							let _g1 = 0;
							while(_g1 < _g) {
								let i = _g1++;
								let n = v1[i];
								if(n == null) {
									break;
								}
								out[pos++] = n.x;
								out[pos++] = n.y;
								out[pos++] = n.z;
								out[pos++] = n.w;
							}
							return _g * 4;
						} else {
							throw haxe_Exception.thrown("assert " + Std.string(type));
						}
					} else if(_g4._hx_index == 0) {
						let _g = _g4.v;
						let v1 = v;
						let size = 0;
						let _g1 = 0;
						while(_g1 < _g) {
							let i = _g1++;
							let n = v1[i];
							if(n == null) {
								break;
							}
							size = this.fillRec(n,_g3,out,pos);
							pos += size;
						}
						return _g * size;
					} else {
						throw haxe_Exception.thrown("assert " + Std.string(type));
					}
				} else if(_g4._hx_index == 0) {
					let _g = _g4.v;
					let v1 = v;
					let size = 0;
					let _g1 = 0;
					while(_g1 < _g) {
						let i = _g1++;
						let n = v1[i];
						if(n == null) {
							break;
						}
						size = this.fillRec(n,_g3,out,pos);
						pos += size;
					}
					return _g * size;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
				break;
			case 8:
				if(_g4._hx_index == 0) {
					let _g = _g4.v;
					let v1 = v;
					let _g1 = 0;
					while(_g1 < _g) {
						let i = _g1++;
						let m = v1[i];
						if(m == null) {
							break;
						}
						out[pos++] = m._11;
						out[pos++] = m._21;
						out[pos++] = m._31;
						out[pos++] = m._41;
						out[pos++] = m._12;
						out[pos++] = m._22;
						out[pos++] = m._32;
						out[pos++] = m._42;
						out[pos++] = m._13;
						out[pos++] = m._23;
						out[pos++] = m._33;
						out[pos++] = m._43;
					}
					return _g * 12;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
				break;
			default:
				if(_g4._hx_index == 0) {
					let _g = _g4.v;
					let v1 = v;
					let size = 0;
					let _g1 = 0;
					while(_g1 < _g) {
						let i = _g1++;
						let n = v1[i];
						if(n == null) {
							break;
						}
						size = this.fillRec(n,_g3,out,pos);
						pos += size;
					}
					return _g * size;
				} else {
					throw haxe_Exception.thrown("assert " + Std.string(type));
				}
			}
			break;
		default:
			throw haxe_Exception.thrown("assert " + Std.string(type));
		}
	}
	shaderInfo(shaders,path) {
		let name = path.split(".").pop();
		while(shaders != null) {
			let inst = shaders.s.instance;
			let _g = 0;
			let _g1 = inst.shader.vars;
			while(_g < _g1.length) {
				let v = _g1[_g];
				++_g;
				if(v.name == name) {
					return shaders.s.toString();
				}
			}
			shaders = shaders.next;
		}
		return "(not found)";
	}
	fillGlobals(buf,s) {
		let s1 = s.vertex;
		let g = s1.globals;
		let ptr = buf.vertex.globals;
		while(g != null) {
			let v = this.globals.map.h[g.gid];
			if(v == null) {
				if(g.path == "__consts__") {
					this.fillRec(s1.consts,g.type,ptr,g.pos);
					g = g.next;
					continue;
				}
				throw haxe_Exception.thrown("Missing global value " + g.path);
			}
			this.fillRec(v,g.type,ptr,g.pos);
			g = g.next;
		}
		let s2 = s.fragment;
		let g1 = s2.globals;
		let ptr1 = buf.fragment.globals;
		while(g1 != null) {
			let v = this.globals.map.h[g1.gid];
			if(v == null) {
				if(g1.path == "__consts__") {
					this.fillRec(s2.consts,g1.type,ptr1,g1.pos);
					g1 = g1.next;
					continue;
				}
				throw haxe_Exception.thrown("Missing global value " + g1.path);
			}
			this.fillRec(v,g1.type,ptr1,g1.pos);
			g1 = g1.next;
		}
	}
	fillParams(buf,s,shaders) {
		let curInstance = -1;
		let curInstanceValue = null;
		let buf1 = buf.vertex;
		let s1 = s.vertex;
		let p = s1.params;
		let ptr = buf1.params;
		while(p != null) {
			let v;
			if(p.perObjectGlobal == null) {
				if(p.type == hxsl_Type.TFloat) {
					let index = p.instance;
					let i;
					if(curInstance == index) {
						i = curInstanceValue;
					} else {
						let si = shaders;
						curInstance = index;
						while(--index > 0) si = si.next;
						curInstanceValue = si.s;
						i = curInstanceValue;
					}
					ptr[p.pos] = i.getParamFloatValue(p.index);
					p = p.next;
					continue;
				}
				let index = p.instance;
				let v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					let si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				v = v1.getParamValue(p.index);
				if(v == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(curInstanceValue) + "." + p.name);
				}
			} else if(p.perObjectGlobal != null) {
				let v1 = this.globals.map.h[p.perObjectGlobal.gid];
				if(v1 == null) {
					throw haxe_Exception.thrown("Missing global value " + p.perObjectGlobal.path + " for shader " + this.shaderInfo(shaders,p.perObjectGlobal.path));
				}
				v = p.type._hx_index == 17 ? v1.texture : v1;
			} else {
				let index = p.instance;
				let v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					let si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				let v2 = v1.getParamValue(p.index);
				if(v2 == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p.name);
				}
				v = v2;
			}
			this.fillRec(v,p.type,ptr,p.pos);
			p = p.next;
		}
		let tid = 0;
		let p1 = s1.textures;
		while(p1 != null) {
			let opt = !h3d_pass_ShaderManager.STRICT;
			if(opt == null) {
				opt = false;
			}
			let t;
			if(p1.perObjectGlobal != null) {
				let v = this.globals.map.h[p1.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p1.perObjectGlobal.path + " for shader " + this.shaderInfo(shaders,p1.perObjectGlobal.path));
				}
				t = p1.type._hx_index == 17 ? v.texture : v;
			} else {
				let index = p1.instance;
				let v;
				if(curInstance == index) {
					v = curInstanceValue;
				} else {
					let si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v = curInstanceValue;
				}
				let v1 = v.getParamValue(p1.index);
				if(v1 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p1.name);
				}
				t = v1;
			}
			if(p1.pos < 0) {
				let arr = t;
				let _g = 0;
				let _g1 = -p1.pos;
				while(_g < _g1) {
					let i = _g++;
					buf1.tex[tid++] = arr[i];
				}
			} else {
				buf1.tex[tid++] = t;
			}
			p1 = p1.next;
		}
		let p2 = s1.buffers;
		let bid = 0;
		while(p2 != null) {
			let opt = !h3d_pass_ShaderManager.STRICT;
			if(opt == null) {
				opt = false;
			}
			let b;
			if(p2.perObjectGlobal != null) {
				let v = this.globals.map.h[p2.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p2.perObjectGlobal.path + " for shader " + this.shaderInfo(shaders,p2.perObjectGlobal.path));
				}
				b = p2.type._hx_index == 17 ? v.texture : v;
			} else {
				let index = p2.instance;
				let v;
				if(curInstance == index) {
					v = curInstanceValue;
				} else {
					let si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v = curInstanceValue;
				}
				let v1 = v.getParamValue(p2.index);
				if(v1 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p2.name);
				}
				b = v1;
			}
			buf1.buffers[bid++] = b;
			p2 = p2.next;
		}
		let buf2 = buf.fragment;
		let s2 = s.fragment;
		let p3 = s2.params;
		let ptr1 = buf2.params;
		while(p3 != null) {
			let v;
			if(p3.perObjectGlobal == null) {
				if(p3.type == hxsl_Type.TFloat) {
					let index = p3.instance;
					let i;
					if(curInstance == index) {
						i = curInstanceValue;
					} else {
						let si = shaders;
						curInstance = index;
						while(--index > 0) si = si.next;
						curInstanceValue = si.s;
						i = curInstanceValue;
					}
					ptr1[p3.pos] = i.getParamFloatValue(p3.index);
					p3 = p3.next;
					continue;
				}
				let index = p3.instance;
				let v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					let si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				v = v1.getParamValue(p3.index);
				if(v == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(curInstanceValue) + "." + p3.name);
				}
			} else if(p3.perObjectGlobal != null) {
				let v1 = this.globals.map.h[p3.perObjectGlobal.gid];
				if(v1 == null) {
					throw haxe_Exception.thrown("Missing global value " + p3.perObjectGlobal.path + " for shader " + this.shaderInfo(shaders,p3.perObjectGlobal.path));
				}
				v = p3.type._hx_index == 17 ? v1.texture : v1;
			} else {
				let index = p3.instance;
				let v1;
				if(curInstance == index) {
					v1 = curInstanceValue;
				} else {
					let si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v1 = curInstanceValue;
				}
				let v2 = v1.getParamValue(p3.index);
				if(v2 == null) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p3.name);
				}
				v = v2;
			}
			this.fillRec(v,p3.type,ptr1,p3.pos);
			p3 = p3.next;
		}
		let tid1 = 0;
		let p4 = s2.textures;
		while(p4 != null) {
			let opt = !h3d_pass_ShaderManager.STRICT;
			if(opt == null) {
				opt = false;
			}
			let t;
			if(p4.perObjectGlobal != null) {
				let v = this.globals.map.h[p4.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p4.perObjectGlobal.path + " for shader " + this.shaderInfo(shaders,p4.perObjectGlobal.path));
				}
				t = p4.type._hx_index == 17 ? v.texture : v;
			} else {
				let index = p4.instance;
				let v;
				if(curInstance == index) {
					v = curInstanceValue;
				} else {
					let si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v = curInstanceValue;
				}
				let v1 = v.getParamValue(p4.index);
				if(v1 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p4.name);
				}
				t = v1;
			}
			if(p4.pos < 0) {
				let arr = t;
				let _g = 0;
				let _g1 = -p4.pos;
				while(_g < _g1) {
					let i = _g++;
					buf2.tex[tid1++] = arr[i];
				}
			} else {
				buf2.tex[tid1++] = t;
			}
			p4 = p4.next;
		}
		let p5 = s2.buffers;
		let bid1 = 0;
		while(p5 != null) {
			let opt = !h3d_pass_ShaderManager.STRICT;
			if(opt == null) {
				opt = false;
			}
			let b;
			if(p5.perObjectGlobal != null) {
				let v = this.globals.map.h[p5.perObjectGlobal.gid];
				if(v == null) {
					throw haxe_Exception.thrown("Missing global value " + p5.perObjectGlobal.path + " for shader " + this.shaderInfo(shaders,p5.perObjectGlobal.path));
				}
				b = p5.type._hx_index == 17 ? v.texture : v;
			} else {
				let index = p5.instance;
				let v;
				if(curInstance == index) {
					v = curInstanceValue;
				} else {
					let si = shaders;
					curInstance = index;
					while(--index > 0) si = si.next;
					curInstanceValue = si.s;
					v = curInstanceValue;
				}
				let v1 = v.getParamValue(p5.index);
				if(v1 == null && !opt) {
					throw haxe_Exception.thrown("Missing param value " + Std.string(shaders.s) + "." + p5.name);
				}
				b = v1;
			}
			buf2.buffers[bid1++] = b;
			p5 = p5.next;
		}
	}
	compileShaders(shaders,batchMode) {
		if(batchMode == null) {
			batchMode = false;
		}
		this.globals.maxChannels = 0;
		let last = null;
		let _g_l = shaders;
		while(_g_l != last) {
			let s = _g_l.s;
			_g_l = _g_l.next;
			s.updateConstants(this.globals);
		}
		this.currentOutput.next = shaders;
		let s = this.shaderCache.link(this.currentOutput,batchMode);
		this.currentOutput.next = null;
		return s;
	}
}
$hxClasses["h3d.pass.ShaderManager"] = h3d_pass_ShaderManager;
h3d_pass_ShaderManager.__name__ = "h3d.pass.ShaderManager";
Object.assign(h3d_pass_ShaderManager.prototype, {
	__class__: h3d_pass_ShaderManager
	,globals: null
	,shaderCache: null
	,currentOutput: null
});
var h3d_pass_RenderMode = $hxEnums["h3d.pass.RenderMode"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.pass.RenderMode",toString:$estr}
	,Static: {_hx_name:"Static",_hx_index:1,__enum__:"h3d.pass.RenderMode",toString:$estr}
	,Dynamic: {_hx_name:"Dynamic",_hx_index:2,__enum__:"h3d.pass.RenderMode",toString:$estr}
	,Mixed: {_hx_name:"Mixed",_hx_index:3,__enum__:"h3d.pass.RenderMode",toString:$estr}
};
h3d_pass_RenderMode.__constructs__ = [h3d_pass_RenderMode.None,h3d_pass_RenderMode.Static,h3d_pass_RenderMode.Dynamic,h3d_pass_RenderMode.Mixed];
h3d_pass_RenderMode.__empty_constructs__ = [h3d_pass_RenderMode.None,h3d_pass_RenderMode.Static,h3d_pass_RenderMode.Dynamic,h3d_pass_RenderMode.Mixed];
var h3d_pass_ShadowSamplingKind = $hxEnums["h3d.pass.ShadowSamplingKind"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"h3d.pass.ShadowSamplingKind",toString:$estr}
	,PCF: {_hx_name:"PCF",_hx_index:1,__enum__:"h3d.pass.ShadowSamplingKind",toString:$estr}
	,ESM: {_hx_name:"ESM",_hx_index:2,__enum__:"h3d.pass.ShadowSamplingKind",toString:$estr}
};
h3d_pass_ShadowSamplingKind.__constructs__ = [h3d_pass_ShadowSamplingKind.None,h3d_pass_ShadowSamplingKind.PCF,h3d_pass_ShadowSamplingKind.ESM];
h3d_pass_ShadowSamplingKind.__empty_constructs__ = [h3d_pass_ShadowSamplingKind.None,h3d_pass_ShadowSamplingKind.PCF,h3d_pass_ShadowSamplingKind.ESM];
class h3d_pass_SortByMaterial {
	constructor() {
		this.textureCount = 1;
		this.shaderCount = 1;
		this.shaderIdMap = [];
		this.textureIdMap = [];
	}
	sort(passes) {
		let shaderStart = this.shaderCount;
		let textureStart = this.textureCount;
		let _g_o = passes.current;
		while(_g_o != null) {
			let tmp = _g_o;
			_g_o = _g_o.next;
			if(this.shaderIdMap[tmp.shader.id] < shaderStart || this.shaderIdMap[tmp.shader.id] == null) {
				this.shaderIdMap[tmp.shader.id] = this.shaderCount++;
			}
			if(this.textureIdMap[tmp.texture] < textureStart || this.textureIdMap[tmp.shader.id] == null) {
				this.textureIdMap[tmp.texture] = this.textureCount++;
			}
		}
		let list = passes.current;
		let tmp;
		if(list == null) {
			tmp = null;
		} else {
			let insize = 1;
			let nmerges;
			let psize = 0;
			let qsize = 0;
			let p;
			let q;
			let e;
			let tail;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					let _g = 0;
					let _g1 = insize;
					while(_g < _g1) {
						++_g;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else {
							let tmp;
							if(!(qsize == 0 || q == null)) {
								let tmp1;
								if(p.pass.layer != q.pass.layer) {
									tmp1 = p.pass.layer - q.pass.layer;
								} else {
									let d = this.shaderIdMap[p.shader.id] - this.shaderIdMap[q.shader.id];
									tmp1 = d != 0 ? d : this.textureIdMap[p.texture] - this.textureIdMap[q.texture];
								}
								tmp = tmp1 <= 0;
							} else {
								tmp = true;
							}
							if(tmp) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			tmp = list;
		}
		passes.current = tmp;
	}
}
$hxClasses["h3d.pass.SortByMaterial"] = h3d_pass_SortByMaterial;
h3d_pass_SortByMaterial.__name__ = "h3d.pass.SortByMaterial";
Object.assign(h3d_pass_SortByMaterial.prototype, {
	__class__: h3d_pass_SortByMaterial
	,shaderCount: null
	,textureCount: null
	,shaderIdMap: null
	,textureIdMap: null
});
class h3d_prim_MeshPrimitive extends h3d_prim_Primitive {
	_hx_constructor() {
		super._hx_constructor();
	}
	allocBuffer(engine,name) {
		return null;
	}
	getBuffer(name) {
		if(this.bufferCache == null) {
			return null;
		}
		let this1 = this.bufferCache;
		let key = hxsl_Globals.allocID(name);
		let b = this1.h[key];
		if(b == null) {
			return null;
		} else {
			return b.buffer;
		}
	}
	addBuffer(name,buf,offset) {
		if(offset == null) {
			offset = 0;
		}
		if(this.bufferCache == null) {
			this.bufferCache = new haxe_ds_IntMap();
		}
		let id = hxsl_Globals.allocID(name);
		let old = this.bufferCache.h[id];
		if(old != null) {
			old.dispose();
		}
		this.bufferCache.h[id] = new h3d_BufferOffset(buf,offset);
		this.layouts = null;
	}
	dispose() {
		super.dispose();
		if(this.bufferCache != null) {
			let b = this.bufferCache.iterator();
			while(b.hasNext()) {
				let b1 = b.next();
				b1.dispose();
			}
		}
		this.bufferCache = null;
		this.layouts = null;
	}
	getBuffers(engine) {
		if(this.bufferCache == null) {
			this.bufferCache = new haxe_ds_IntMap();
		}
		if(this.layouts == null) {
			this.layouts = new haxe_ds_IntMap();
		}
		let inputs = engine.driver.getShaderInputNames();
		let buffers = this.layouts.h[inputs.id];
		if(buffers != null) {
			return buffers;
		}
		let prev = null;
		let _g = 0;
		let _g1 = inputs.names;
		while(_g < _g1.length) {
			let name = _g1[_g];
			++_g;
			let id = hxsl_Globals.allocID(name);
			let b = this.bufferCache.h[id];
			if(b == null) {
				b = this.allocBuffer(engine,name);
				if(b == null) {
					throw haxe_Exception.thrown("Buffer " + name + " is not available");
				}
				this.bufferCache.h[id] = b;
			}
			let b1 = new h3d_BufferOffset(b.buffer,b.offset);
			if(prev == null) {
				prev = b1;
				buffers = prev;
			} else {
				prev.next = b1;
				prev = b1;
			}
		}
		this.layouts.h[inputs.id] = buffers;
		return buffers;
	}
	render(engine) {
		if(this.indexes == null || this.indexes.isDisposed()) {
			this.alloc(engine);
		}
		engine.renderMultiBuffers(this.getBuffers(engine),this.indexes);
	}
}
$hxClasses["h3d.prim.MeshPrimitive"] = h3d_prim_MeshPrimitive;
h3d_prim_MeshPrimitive.__name__ = "h3d.prim.MeshPrimitive";
h3d_prim_MeshPrimitive.__super__ = h3d_prim_Primitive;
Object.assign(h3d_prim_MeshPrimitive.prototype, {
	__class__: h3d_prim_MeshPrimitive
	,bufferCache: null
	,layouts: null
});
class h3d_prim_Polygon extends h3d_prim_MeshPrimitive {
	constructor(points,idx) {
		if(h3d_prim_Primitive._hx_skip_constructor) {
			super();
			return;
		}
		h3d_prim_Primitive._hx_skip_constructor = true;
		super();
		h3d_prim_Primitive._hx_skip_constructor = false;
		this._hx_constructor(points,idx);
	}
	_hx_constructor(points,idx) {
		this.translatedZ = 0.;
		this.translatedY = 0.;
		this.translatedX = 0.;
		super._hx_constructor();
		this.points = points;
		this.idx = idx;
	}
	getBounds() {
		let b = new h3d_col_Bounds();
		let _g = 0;
		let _g1 = this.points;
		while(_g < _g1.length) {
			let p = _g1[_g];
			++_g;
			if(p.x < b.xMin) {
				b.xMin = p.x;
			}
			if(p.x > b.xMax) {
				b.xMax = p.x;
			}
			if(p.y < b.yMin) {
				b.yMin = p.y;
			}
			if(p.y > b.yMax) {
				b.yMax = p.y;
			}
			if(p.z < b.zMin) {
				b.zMin = p.z;
			}
			if(p.z > b.zMax) {
				b.zMax = p.z;
			}
		}
		return b;
	}
	alloc(engine) {
		this.dispose();
		let size = 3;
		let names = ["position"];
		let positions = [0];
		if(this.normals != null) {
			names.push("normal");
			positions.push(3);
			size = 6;
		}
		if(this.tangents != null) {
			names.push("tangent");
			positions.push(size);
			size += 3;
		}
		if(this.uvs != null) {
			names.push("uv");
			positions.push(size);
			size += 2;
		}
		if(this.colors != null) {
			names.push("color");
			positions.push(size);
			size += 3;
		}
		let buf = hxd__$FloatBuffer_Float32Expand._new(0);
		let _g = 0;
		let _g1 = this.points.length;
		while(_g < _g1) {
			let k = _g++;
			let p = this.points[k];
			let v = p.x;
			if(buf.pos == buf.array.length) {
				let newSize = buf.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(buf.array);
				buf.array = newArray;
			}
			buf.array[buf.pos++] = v;
			let v1 = p.y;
			if(buf.pos == buf.array.length) {
				let newSize = buf.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(buf.array);
				buf.array = newArray;
			}
			buf.array[buf.pos++] = v1;
			let v2 = p.z;
			if(buf.pos == buf.array.length) {
				let newSize = buf.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(buf.array);
				buf.array = newArray;
			}
			buf.array[buf.pos++] = v2;
			if(this.normals != null) {
				let n = this.normals[k];
				let v = n.x;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v;
				let v1 = n.y;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v1;
				let v2 = n.z;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v2;
			}
			if(this.tangents != null) {
				let t = this.tangents[k];
				let v = t.x;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v;
				let v1 = t.y;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v1;
				let v2 = t.z;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v2;
			}
			if(this.uvs != null) {
				let t = this.uvs[k];
				let v = t.u;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v;
				let v1 = t.v;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v1;
			}
			if(this.colors != null) {
				let c = this.colors[k];
				let v = c.x;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v;
				let v1 = c.y;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v1;
				let v2 = c.z;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v2;
			}
		}
		let flags = [];
		if(this.idx == null) {
			flags.push(h3d_BufferFlag.Triangles);
		}
		if(this.normals == null || this.tangents != null) {
			flags.push(h3d_BufferFlag.RawFormat);
		}
		this.buffer = h3d_Buffer.ofFloats(buf,size,flags);
		let _g2 = 0;
		let _g3 = names.length;
		while(_g2 < _g3) {
			let i = _g2++;
			this.addBuffer(names[i],this.buffer,positions[i]);
		}
		if(this.idx != null) {
			this.indexes = h3d_Indexes.alloc(this.idx);
		}
	}
	unindex() {
		if(this.idx != null && this.points.length != this.idx.length) {
			let p = [];
			let _g = 0;
			let _g1 = this.idx.length;
			while(_g < _g1) {
				let i = _g++;
				let _this = this.points[this.idx[i]];
				p.push(new h3d_col_Point(_this.x,_this.y,_this.z));
			}
			if(this.normals != null) {
				let n = [];
				let _g = 0;
				let _g1 = this.idx.length;
				while(_g < _g1) {
					let i = _g++;
					let _this = this.normals[this.idx[i]];
					n.push(new h3d_col_Point(_this.x,_this.y,_this.z));
				}
				this.normals = n;
			}
			if(this.tangents != null) {
				let t = [];
				let _g = 0;
				let _g1 = this.idx.length;
				while(_g < _g1) {
					let i = _g++;
					let _this = this.tangents[this.idx[i]];
					t.push(new h3d_col_Point(_this.x,_this.y,_this.z));
				}
				this.tangents = t;
			}
			if(this.colors != null) {
				let n = [];
				let _g = 0;
				let _g1 = this.idx.length;
				while(_g < _g1) {
					let i = _g++;
					let _this = this.colors[this.idx[i]];
					n.push(new h3d_col_Point(_this.x,_this.y,_this.z));
				}
				this.colors = n;
			}
			if(this.uvs != null) {
				let t = [];
				let _g = 0;
				let _g1 = this.idx.length;
				while(_g < _g1) {
					let i = _g++;
					t.push(this.uvs[this.idx[i]].clone());
				}
				this.uvs = t;
			}
			this.points = p;
			this.idx = null;
		}
	}
	translate(dx,dy,dz) {
		this.translatedX += dx;
		this.translatedY += dy;
		this.translatedZ += dz;
		let _g = 0;
		let _g1 = this.points;
		while(_g < _g1.length) {
			let p = _g1[_g];
			++_g;
			p.x += dx;
			p.y += dy;
			p.z += dz;
		}
	}
	addNormals() {
		this.normals = [];
		let _g = 0;
		let _g1 = this.points.length;
		while(_g < _g1) {
			let i = _g++;
			this.normals[i] = new h3d_col_Point();
		}
		let pos = 0;
		let _g2 = 0;
		let _g3 = this.triCount();
		while(_g2 < _g3) {
			++_g2;
			let i0;
			let i1;
			let i2;
			if(this.idx == null) {
				++pos;
				i0 = pos - 1;
				++pos;
				i1 = pos - 1;
				++pos;
				i2 = pos - 1;
			} else {
				i0 = this.idx[pos++];
				i1 = this.idx[pos++];
				i2 = this.idx[pos++];
			}
			let p0 = this.points[i0];
			let p1 = this.points[i1];
			let p2 = this.points[i2];
			let x = p1.x - p0.x;
			let y = p1.y - p0.y;
			let z = p1.z - p0.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let _this_x = x;
			let _this_y = y;
			let _this_z = z;
			let x1 = p2.x - p0.x;
			let y1 = p2.y - p0.y;
			let z1 = p2.z - p0.z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let p_x = x1;
			let p_y = y1;
			let p_z = z1;
			let x2 = _this_y * p_z - _this_z * p_y;
			let y2 = _this_z * p_x - _this_x * p_z;
			let z2 = _this_x * p_y - _this_y * p_x;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let n_x = x2;
			let n_y = y2;
			let n_z = z2;
			this.normals[i0].x += n_x;
			this.normals[i0].y += n_y;
			this.normals[i0].z += n_z;
			this.normals[i1].x += n_x;
			this.normals[i1].y += n_y;
			this.normals[i1].z += n_z;
			this.normals[i2].x += n_x;
			this.normals[i2].y += n_y;
			this.normals[i2].z += n_z;
		}
		let _g4 = 0;
		let _g5 = this.normals;
		while(_g4 < _g5.length) {
			let n = _g5[_g4];
			++_g4;
			let k = n.x * n.x + n.y * n.y + n.z * n.z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			n.x *= k;
			n.y *= k;
			n.z *= k;
		}
	}
	addTangents() {
		if(this.normals == null) {
			this.addNormals();
		}
		if(this.uvs == null) {
			this.addUVs();
		}
		this.tangents = [];
		let _g = 0;
		let _g1 = this.points.length;
		while(_g < _g1) {
			let i = _g++;
			this.tangents[i] = new h3d_col_Point();
		}
		let pos = 0;
		let _g2 = 0;
		let _g3 = this.triCount();
		while(_g2 < _g3) {
			++_g2;
			let i0;
			let i1;
			let i2;
			if(this.idx == null) {
				++pos;
				i0 = pos - 1;
				++pos;
				i1 = pos - 1;
				++pos;
				i2 = pos - 1;
			} else {
				i0 = this.idx[pos++];
				i1 = this.idx[pos++];
				i2 = this.idx[pos++];
			}
			let p0 = this.points[i0];
			let p1 = this.points[i1];
			let p2 = this.points[i2];
			let uv0 = this.uvs[i0];
			let uv1 = this.uvs[i1];
			let uv2 = this.uvs[i2];
			let n = this.normals[i0];
			let x = p1.x - p0.x;
			let y = p1.y - p0.y;
			let z = p1.z - p0.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let k0_x = x;
			let k0_y = y;
			let k0_z = z;
			let x1 = p2.x - p0.x;
			let y1 = p2.y - p0.y;
			let z1 = p2.z - p0.z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let k1_x = x1;
			let k1_y = y1;
			let k1_z = z1;
			let v = uv2.v - uv0.v;
			k0_x *= v;
			k0_y *= v;
			k0_z *= v;
			let v1 = uv1.v - uv0.v;
			k1_x *= v1;
			k1_y *= v1;
			k1_z *= v1;
			let t = new h3d_col_Point(k0_x - k1_x,k0_y - k1_y,k0_z - k1_z);
			let x2 = n.y * t.z - n.z * t.y;
			let y2 = n.z * t.x - n.x * t.z;
			let z2 = n.x * t.y - n.y * t.x;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let b_x = x2;
			let b_y = y2;
			let b_z = z2;
			let k = b_x * b_x + b_y * b_y + b_z * b_z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			b_x *= k;
			b_y *= k;
			b_z *= k;
			t = new h3d_col_Point(b_y * n.z - b_z * n.y,b_z * n.x - b_x * n.z,b_x * n.y - b_y * n.x);
			let k1 = t.x * t.x + t.y * t.y + t.z * t.z;
			if(k1 < 1e-10) {
				k1 = 0;
			} else {
				k1 = 1. / Math.sqrt(k1);
			}
			t.x *= k1;
			t.y *= k1;
			t.z *= k1;
			this.tangents[i0].x += t.x;
			this.tangents[i0].y += t.y;
			this.tangents[i0].z += t.z;
			this.tangents[i1].x += t.x;
			this.tangents[i1].y += t.y;
			this.tangents[i1].z += t.z;
			this.tangents[i2].x += t.x;
			this.tangents[i2].y += t.y;
			this.tangents[i2].z += t.z;
		}
		let _g4 = 0;
		let _g5 = this.tangents;
		while(_g4 < _g5.length) {
			let t = _g5[_g4];
			++_g4;
			let k = t.x * t.x + t.y * t.y + t.z * t.z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			t.x *= k;
			t.y *= k;
			t.z *= k;
		}
	}
	addUVs() {
		this.uvs = [];
		let _g = 0;
		let _g1 = this.points.length;
		while(_g < _g1) {
			let i = _g++;
			this.uvs[i] = new h3d_prim_UV(this.points[i].x,this.points[i].y);
		}
	}
	triCount() {
		let n = super.triCount();
		if(n != 0) {
			return n;
		}
		return (this.idx == null ? this.points.length : this.idx.length) / 3 | 0;
	}
	render(engine) {
		let tmp;
		if(this.buffer != null) {
			let _this = this.buffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.alloc(engine);
		}
		let bufs = this.getBuffers(engine);
		if(this.indexes != null) {
			engine.renderMultiBuffers(bufs,this.indexes);
		} else if((this.buffer.flags & 4) != 0) {
			engine.renderMultiBuffers(bufs,engine.mem.quadIndexes,0,this.triCount());
		} else {
			engine.renderMultiBuffers(bufs,engine.mem.triIndexes,0,this.triCount());
		}
	}
}
$hxClasses["h3d.prim.Polygon"] = h3d_prim_Polygon;
h3d_prim_Polygon.__name__ = "h3d.prim.Polygon";
h3d_prim_Polygon.__super__ = h3d_prim_MeshPrimitive;
Object.assign(h3d_prim_Polygon.prototype, {
	__class__: h3d_prim_Polygon
	,points: null
	,normals: null
	,tangents: null
	,uvs: null
	,idx: null
	,colors: null
	,translatedX: null
	,translatedY: null
	,translatedZ: null
});
class h3d_prim_Cube extends h3d_prim_Polygon {
	constructor(x,y,z,centered) {
		h3d_prim_Primitive._hx_skip_constructor = true;
		super();
		h3d_prim_Primitive._hx_skip_constructor = false;
		this._hx_constructor(x,y,z,centered);
	}
	_hx_constructor(x,y,z,centered) {
		if(centered == null) {
			centered = false;
		}
		if(z == null) {
			z = 1.;
		}
		if(y == null) {
			y = 1.;
		}
		if(x == null) {
			x = 1.;
		}
		this.sizeX = x;
		this.sizeY = y;
		this.sizeZ = z;
		let p = [new h3d_col_Point(0,0,0),new h3d_col_Point(x,0,0),new h3d_col_Point(0,y,0),new h3d_col_Point(0,0,z),new h3d_col_Point(x,y,0),new h3d_col_Point(x,0,z),new h3d_col_Point(0,y,z),new h3d_col_Point(x,y,z)];
		let idx = new Array(0);
		idx.push(0);
		idx.push(1);
		idx.push(5);
		idx.push(0);
		idx.push(5);
		idx.push(3);
		idx.push(1);
		idx.push(4);
		idx.push(7);
		idx.push(1);
		idx.push(7);
		idx.push(5);
		idx.push(3);
		idx.push(5);
		idx.push(7);
		idx.push(3);
		idx.push(7);
		idx.push(6);
		idx.push(0);
		idx.push(6);
		idx.push(2);
		idx.push(0);
		idx.push(3);
		idx.push(6);
		idx.push(2);
		idx.push(7);
		idx.push(4);
		idx.push(2);
		idx.push(6);
		idx.push(7);
		idx.push(0);
		idx.push(4);
		idx.push(1);
		idx.push(0);
		idx.push(2);
		idx.push(4);
		super._hx_constructor(p,idx);
		if(centered) {
			this.translate(-x * 0.5,-y * 0.5,-z * 0.5);
		}
	}
	addUVs() {
		this.unindex();
		let z = new h3d_prim_UV(0,1);
		let x = new h3d_prim_UV(1,1);
		let y = new h3d_prim_UV(0,0);
		let o = new h3d_prim_UV(1,0);
		this.uvs = [x,z,y,x,y,o,x,z,y,x,y,o,x,z,y,x,y,o,z,o,x,z,y,o,z,o,x,z,y,o,z,o,x,z,y,o];
	}
}
$hxClasses["h3d.prim.Cube"] = h3d_prim_Cube;
h3d_prim_Cube.__name__ = "h3d.prim.Cube";
h3d_prim_Cube.__super__ = h3d_prim_Polygon;
Object.assign(h3d_prim_Cube.prototype, {
	__class__: h3d_prim_Cube
	,sizeX: null
	,sizeY: null
	,sizeZ: null
});
class h3d_prim_Instanced extends h3d_prim_MeshPrimitive {
	constructor() {
		super();
		this.bounds = new h3d_col_Bounds();
		let _this = this.bounds;
		if(0 < _this.xMin) {
			_this.xMin = 0;
		}
		if(0 > _this.xMax) {
			_this.xMax = 0;
		}
		if(0 < _this.yMin) {
			_this.yMin = 0;
		}
		if(0 > _this.yMax) {
			_this.yMax = 0;
		}
		if(0 < _this.zMin) {
			_this.zMin = 0;
		}
		if(0 > _this.zMax) {
			_this.zMax = 0;
		}
		this.tmpBounds = new h3d_col_Bounds();
	}
	setMesh(m) {
		if(this.refCount > 0) {
			if(this.primitive != null) {
				this.primitive.decref();
			}
			m.incref();
		}
		this.primitive = m;
		let engine = h3d_Engine.CURRENT;
		let tmp;
		if(m.buffer != null) {
			let _this = m.buffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			m.alloc(engine);
		}
		this.buffer = m.buffer;
		this.indexes = m.indexes;
		this.baseBounds = m.getBounds();
		if(this.indexes == null) {
			this.indexes = engine.mem.triIndexes;
		}
		let bid = m.bufferCache.keys();
		while(bid.hasNext()) {
			let bid1 = bid.next();
			let b = m.bufferCache.h[bid1];
			this.addBuffer(hxsl_Globals.getIDName(bid1),b.buffer,b.offset);
		}
	}
	initBounds() {
		let _this = this.bounds;
		_this.xMin = 1e20;
		_this.xMax = -1e20;
		_this.yMin = 1e20;
		_this.yMax = -1e20;
		_this.zMin = 1e20;
		_this.zMax = -1e20;
	}
	dispose() {
	}
	incref() {
		if(this.refCount == 0 && this.primitive != null) {
			this.primitive.incref();
		}
		super.incref();
	}
	decref() {
		super.decref();
		if(this.refCount == 0 && this.primitive != null) {
			this.primitive.decref();
		}
	}
	getBounds() {
		return this.bounds;
	}
	addBuffer(name,buffer,offset) {
		if(offset == null) {
			offset = 0;
		}
		super.addBuffer(name,buffer,offset);
	}
	render(engine) {
		let _this = this.buffer;
		if(_this.buffer == null || _this.buffer.vbuf == null) {
			this.setMesh(this.primitive);
		}
		engine.renderInstanced(this.getBuffers(engine),this.indexes,this.commands);
	}
}
$hxClasses["h3d.prim.Instanced"] = h3d_prim_Instanced;
h3d_prim_Instanced.__name__ = "h3d.prim.Instanced";
h3d_prim_Instanced.__super__ = h3d_prim_MeshPrimitive;
Object.assign(h3d_prim_Instanced.prototype, {
	__class__: h3d_prim_Instanced
	,commands: null
	,bounds: null
	,baseBounds: null
	,tmpBounds: null
	,primitive: null
});
class h3d_prim_Plane2D extends h3d_prim_Primitive {
	constructor() {
		super();
	}
	triCount() {
		return 2;
	}
	alloc(engine) {
		let v = hxd__$FloatBuffer_Float32Expand._new(0);
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = -1;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 1;
		if(v.pos == v.array.length) {
			let newSize = v.array.length << 1;
			if(newSize < 128) {
				newSize = 128;
			}
			let newArray = new Float32Array(newSize);
			newArray.set(v.array);
			v.array = newArray;
		}
		v.array[v.pos++] = 0;
		this.buffer = h3d_Buffer.ofFloats(v,4,[h3d_BufferFlag.Quads,h3d_BufferFlag.RawFormat]);
	}
	render(engine) {
		let tmp;
		if(this.buffer != null) {
			let _this = this.buffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.alloc(engine);
		}
		engine.renderBuffer(this.buffer,engine.mem.quadIndexes,2,0,-1);
	}
	static get() {
		let engine = h3d_Engine.CURRENT;
		let inst = engine.resCache.h[h3d_prim_Plane2D.__id__];
		if(inst == null) {
			inst = new h3d_prim_Plane2D();
			engine.resCache.set(h3d_prim_Plane2D,inst);
		}
		return inst;
	}
}
$hxClasses["h3d.prim.Plane2D"] = h3d_prim_Plane2D;
h3d_prim_Plane2D.__name__ = "h3d.prim.Plane2D";
h3d_prim_Plane2D.__super__ = h3d_prim_Primitive;
Object.assign(h3d_prim_Plane2D.prototype, {
	__class__: h3d_prim_Plane2D
});
class h3d_prim_RawPrimitive extends h3d_prim_Primitive {
	constructor(inf,persist) {
		if(persist == null) {
			persist = false;
		}
		super();
		this.onContextLost = function() {
			return inf;
		};
		this.bounds = inf.bounds;
		this.alloc(null);
		if(!persist) {
			this.onContextLost = null;
		}
	}
	alloc(engine) {
		if(this.onContextLost == null) {
			throw haxe_Exception.thrown("Cannot realloc " + Std.string(this));
		}
		let inf = this.onContextLost();
		let flags = [];
		if(inf.ibuf == null) {
			flags.push(inf.quads ? h3d_BufferFlag.Quads : h3d_BufferFlag.Triangles);
		}
		if(inf.stride < 8) {
			flags.push(h3d_BufferFlag.RawFormat);
		}
		this.buffer = h3d_Buffer.ofFloats(inf.vbuf,inf.stride,flags);
		this.vcount = this.buffer.vertices;
		this.tcount = inf.ibuf != null ? inf.ibuf.length / 3 | 0 : inf.quads ? this.vcount >> 1 : this.vcount / 3 | 0;
		if(inf.ibuf != null) {
			this.indexes = h3d_Indexes.alloc(inf.ibuf);
		} else if(this.indexes != null) {
			this.indexes.dispose();
			this.indexes = null;
		}
	}
	getBounds() {
		if(this.bounds == null) {
			throw haxe_Exception.thrown("Bounds not defined for " + Std.string(this));
		}
		return this.bounds;
	}
	triCount() {
		return this.tcount;
	}
}
$hxClasses["h3d.prim.RawPrimitive"] = h3d_prim_RawPrimitive;
h3d_prim_RawPrimitive.__name__ = "h3d.prim.RawPrimitive";
h3d_prim_RawPrimitive.__super__ = h3d_prim_Primitive;
Object.assign(h3d_prim_RawPrimitive.prototype, {
	__class__: h3d_prim_RawPrimitive
	,vcount: null
	,tcount: null
	,bounds: null
	,onContextLost: null
});
class h3d_prim_Sphere extends h3d_prim_Polygon {
	constructor(ray,segsW,segsH,portion) {
		h3d_prim_Primitive._hx_skip_constructor = true;
		super();
		h3d_prim_Primitive._hx_skip_constructor = false;
		this._hx_constructor(ray,segsW,segsH,portion);
	}
	_hx_constructor(ray,segsW,segsH,portion) {
		if(portion == null) {
			portion = 1.;
		}
		if(segsH == null) {
			segsH = 6;
		}
		if(segsW == null) {
			segsW = 8;
		}
		if(ray == null) {
			ray = 1.;
		}
		this.ray = ray;
		this.segsH = segsH;
		this.segsW = segsW;
		this.portion = portion;
		let dp = Math.PI * 2 / segsW;
		let pts = [];
		let idx = new Array(0);
		let _g = 0;
		let _g1 = segsH + 1;
		while(_g < _g1) {
			let y = _g++;
			let t = y / segsH * Math.PI * portion;
			let st = Math.sin(t);
			let pz = Math.cos(t);
			let p = 0.;
			let _g1 = 0;
			let _g2 = segsW + 1;
			while(_g1 < _g2) {
				++_g1;
				let px = st * Math.cos(p);
				let py = st * Math.sin(p);
				pts.push(new h3d_col_Point(px * ray,py * ray,pz * ray));
				p += dp;
			}
		}
		let _g2 = 0;
		while(_g2 < segsH) {
			let y = _g2++;
			let _g = 0;
			while(_g < segsW) {
				let x = _g++;
				let v1 = x + 1 + y * (segsW + 1);
				let v2 = x + y * (segsW + 1);
				let v3 = x + (y + 1) * (segsW + 1);
				let v4 = x + 1 + (y + 1) * (segsW + 1);
				if(y != 0) {
					idx.push(v1);
					idx.push(v2);
					idx.push(v4);
				}
				if(y != segsH - 1 || portion != 1.) {
					idx.push(v2);
					idx.push(v3);
					idx.push(v4);
				}
			}
		}
		super._hx_constructor(pts,idx);
	}
	addNormals() {
		this.normals = this.points;
	}
	addUVs() {
		this.uvs = [];
		let _g = 0;
		let _g1 = this.segsH + 1;
		while(_g < _g1) {
			let y = _g++;
			let _g1 = 0;
			let _g2 = this.segsW + 1;
			while(_g1 < _g2) {
				let x = _g1++;
				this.uvs.push(new h3d_prim_UV(1 - x / this.segsW,y / this.segsH));
			}
		}
	}
}
$hxClasses["h3d.prim.Sphere"] = h3d_prim_Sphere;
h3d_prim_Sphere.__name__ = "h3d.prim.Sphere";
h3d_prim_Sphere.__super__ = h3d_prim_Polygon;
Object.assign(h3d_prim_Sphere.prototype, {
	__class__: h3d_prim_Sphere
	,ray: null
	,segsH: null
	,segsW: null
	,portion: null
});
class h3d_prim_UV {
	constructor(u,v) {
		this.u = u;
		this.v = v;
	}
	clone() {
		return new h3d_prim_UV(this.u,this.v);
	}
}
$hxClasses["h3d.prim.UV"] = h3d_prim_UV;
h3d_prim_UV.__name__ = "h3d.prim.UV";
Object.assign(h3d_prim_UV.prototype, {
	__class__: h3d_prim_UV
	,u: null
	,v: null
});
class h3d_scene_Mesh extends h3d_scene_Object {
	constructor(primitive,material,parent) {
		if(h3d_scene_Object._hx_skip_constructor) {
			super();
			return;
		}
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(primitive,material,parent);
	}
	_hx_constructor(primitive,material,parent) {
		super._hx_constructor(parent);
		this.set_primitive(primitive);
		if(material == null) {
			material = h3d_mat_MaterialSetup.current.createMaterial();
			material.set_props(material.getDefaultProps());
		}
		this.material = material;
	}
	addBoundsRec(b,relativeTo) {
		super.addBoundsRec(b,relativeTo);
		if(this.primitive == null || (this.flags & 512) != 0) {
			return;
		}
		let bounds = this.primitive.getBounds();
		if(relativeTo == null) {
			let b1 = new h3d_col_Bounds();
			b1.xMin = bounds.xMin;
			b1.xMax = bounds.xMax;
			b1.yMin = bounds.yMin;
			b1.yMax = bounds.yMax;
			b1.zMin = bounds.zMin;
			b1.zMax = bounds.zMax;
			b1.transform(this.absPos);
			if(b1.xMin < b.xMin) {
				b.xMin = b1.xMin;
			}
			if(b1.xMax > b.xMax) {
				b.xMax = b1.xMax;
			}
			if(b1.yMin < b.yMin) {
				b.yMin = b1.yMin;
			}
			if(b1.yMax > b.yMax) {
				b.yMax = b1.yMax;
			}
			if(b1.zMin < b.zMin) {
				b.zMin = b1.zMin;
			}
			if(b1.zMax > b.zMax) {
				b.zMax = b1.zMax;
			}
		} else {
			h3d_scene_Mesh.tmpMat.multiply(this.absPos,relativeTo);
			let b1 = new h3d_col_Bounds();
			b1.xMin = bounds.xMin;
			b1.xMax = bounds.xMax;
			b1.yMin = bounds.yMin;
			b1.yMax = bounds.yMax;
			b1.zMin = bounds.zMin;
			b1.zMax = bounds.zMax;
			b1.transform(h3d_scene_Mesh.tmpMat);
			if(b1.xMin < b.xMin) {
				b.xMin = b1.xMin;
			}
			if(b1.xMax > b.xMax) {
				b.xMax = b1.xMax;
			}
			if(b1.yMin < b.yMin) {
				b.yMin = b1.yMin;
			}
			if(b1.yMax > b.yMax) {
				b.yMax = b1.yMax;
			}
			if(b1.zMin < b.zMin) {
				b.zMin = b1.zMin;
			}
			if(b1.zMax > b.zMax) {
				b.zMax = b1.zMax;
			}
		}
	}
	draw(ctx) {
		this.primitive.render(ctx.engine);
	}
	emit(ctx) {
		let p = this.material.passes;
		while(p != null) {
			if(!p.culled) {
				ctx.emitPass(p,this).index = 0;
			}
			p = p.nextPass;
		}
	}
	getMaterials(a,recursive) {
		if(recursive == null) {
			recursive = true;
		}
		if(a == null) {
			a = [];
		}
		if(this.material != null && a.indexOf(this.material) < 0) {
			a.push(this.material);
		}
		return super.getMaterials(a,recursive);
	}
	onAdd() {
		super.onAdd();
		if(this.primitive != null) {
			this.primitive.incref();
		}
	}
	onRemove() {
		if(this.primitive != null) {
			this.primitive.decref();
		}
		super.onRemove();
	}
	set_primitive(prim) {
		if(prim != this.primitive && (this.flags & 32) != 0) {
			if(this.primitive != null) {
				this.primitive.decref();
			}
			if(prim != null) {
				prim.incref();
			}
		}
		return this.primitive = prim;
	}
}
$hxClasses["h3d.scene.Mesh"] = h3d_scene_Mesh;
h3d_scene_Mesh.__name__ = "h3d.scene.Mesh";
h3d_scene_Mesh.__super__ = h3d_scene_Object;
Object.assign(h3d_scene_Mesh.prototype, {
	__class__: h3d_scene_Mesh
	,primitive: null
	,material: null
});
class h3d_scene_Interactive extends h3d_scene_Object {
	constructor(shape,parent) {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(shape,parent);
	}
	_hx_constructor(shape,parent) {
		this.hitPoint = new h3d_Vector();
		this.lastClickFrame = -1;
		this.mouseDownButton = -1;
		this.isAbsoluteShape = false;
		this.allowMultiClick = false;
		this.enableRightButton = false;
		this.propagateEvents = false;
		this.cancelEvents = false;
		super._hx_constructor(parent);
		this.shape = shape;
		this.set_cursor(hxd_Cursor.Button);
	}
	onAdd() {
		this.scene = this.getScene();
		if(this.scene != null) {
			this.scene.addEventTarget(this);
		}
		super.onAdd();
	}
	onRemove() {
		if(this.scene != null) {
			this.scene.removeEventTarget(this);
			this.scene = null;
		}
		super.onRemove();
	}
	getInteractiveScene() {
		return this.scene;
	}
	handleEvent(e) {
		if(this.propagateEvents) {
			e.propagate = true;
		}
		if(this.cancelEvents) {
			e.cancel = true;
		}
		switch(e.kind._hx_index) {
		case 0:
			if(this.enableRightButton || e.button == 0) {
				this.mouseDownButton = e.button;
				this.onPush(e);
				if(e.cancel) {
					this.mouseDownButton = -1;
				}
			}
			break;
		case 1:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				let frame = hxd_Timer.frameCount;
				if(this.mouseDownButton == e.button && (this.lastClickFrame != frame || this.allowMultiClick)) {
					this.onClick(e);
					this.lastClickFrame = frame;
				}
			}
			this.mouseDownButton = -1;
			break;
		case 2:
			this.onMove(e);
			break;
		case 3:
			this.onOver(e);
			break;
		case 4:
			this.onOut(e);
			break;
		case 5:
			this.onWheel(e);
			break;
		case 6:
			this.onFocus(e);
			break;
		case 7:
			this.onFocusLost(e);
			break;
		case 8:
			this.onKeyDown(e);
			break;
		case 9:
			this.onKeyUp(e);
			break;
		case 10:
			if(this.enableRightButton || e.button == 0) {
				this.onRelease(e);
				if(this.mouseDownButton == e.button) {
					this.onReleaseOutside(e);
				}
			}
			this.mouseDownButton = -1;
			break;
		case 11:
			this.onTextInput(e);
			break;
		case 12:
			this.onCheck(e);
			break;
		}
	}
	set_cursor(c) {
		this.cursor = c;
		if(this.scene != null && this.scene.events != null) {
			this.scene.events.updateCursor(this);
		}
		return c;
	}
	onOver(e) {
	}
	onOut(e) {
	}
	onPush(e) {
	}
	onRelease(e) {
	}
	onReleaseOutside(e) {
	}
	onClick(e) {
	}
	onMove(e) {
	}
	onWheel(e) {
	}
	onFocus(e) {
	}
	onFocusLost(e) {
	}
	onKeyUp(e) {
	}
	onKeyDown(e) {
	}
	onCheck(e) {
	}
	onTextInput(e) {
	}
}
$hxClasses["h3d.scene.Interactive"] = h3d_scene_Interactive;
h3d_scene_Interactive.__name__ = "h3d.scene.Interactive";
h3d_scene_Interactive.__interfaces__ = [hxd_Interactive];
h3d_scene_Interactive.__super__ = h3d_scene_Object;
Object.assign(h3d_scene_Interactive.prototype, {
	__class__: h3d_scene_Interactive
	,shape: null
	,preciseShape: null
	,priority: null
	,cursor: null
	,cancelEvents: null
	,propagateEvents: null
	,enableRightButton: null
	,allowMultiClick: null
	,bestMatch: null
	,isAbsoluteShape: null
	,scene: null
	,mouseDownButton: null
	,lastClickFrame: null
	,hitPoint: null
});
class h3d_scene_Light extends h3d_scene_Object {
	constructor(shader,parent) {
		if(h3d_scene_Object._hx_skip_constructor) {
			super();
			return;
		}
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(shader,parent);
	}
	_hx_constructor(shader,parent) {
		super._hx_constructor(parent);
		this.shader = shader;
	}
	emit(ctx) {
		ctx.emitLight(this);
	}
	getShadowDirection() {
		return null;
	}
}
$hxClasses["h3d.scene.Light"] = h3d_scene_Light;
h3d_scene_Light.__name__ = "h3d.scene.Light";
h3d_scene_Light.__super__ = h3d_scene_Object;
Object.assign(h3d_scene_Light.prototype, {
	__class__: h3d_scene_Light
	,shader: null
	,next: null
});
class h3d_scene_LightSystem {
	constructor() {
		if(h3d_scene_LightSystem._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
	}
	initGlobals(globals) {
	}
	initLights(ctx) {
		this.ctx = ctx;
		if(this.shadowLight == null || (this.shadowLight.flags & 32) == 0) {
			let l = ctx.lights;
			while(l != null) {
				let dir = l.getShadowDirection();
				if(dir != null) {
					this.shadowLight = l;
					break;
				}
				l = l.next;
			}
		}
	}
	computeLight(obj,shaders) {
		return shaders;
	}
}
$hxClasses["h3d.scene.LightSystem"] = h3d_scene_LightSystem;
h3d_scene_LightSystem.__name__ = "h3d.scene.LightSystem";
Object.assign(h3d_scene_LightSystem.prototype, {
	__class__: h3d_scene_LightSystem
	,shadowLight: null
	,ctx: null
});
class h3d_scene_MultiMaterial extends h3d_scene_Mesh {
	_hx_constructor(prim,mats,parent) {
		super._hx_constructor(prim,mats == null ? null : mats[0],parent);
		this.materials = mats == null ? [this.material] : mats;
	}
	emit(ctx) {
		let _g = 0;
		let _g1 = this.materials.length;
		while(_g < _g1) {
			let i = _g++;
			let m = this.materials[i];
			if(m != null) {
				let index = i;
				if(i == null) {
					index = 0;
				}
				let p = m.passes;
				while(p != null) {
					if(!p.culled) {
						ctx.emitPass(p,this).index = index;
					}
					p = p.nextPass;
				}
			}
		}
	}
	getMaterials(a,recursive) {
		if(recursive == null) {
			recursive = true;
		}
		if(a == null) {
			a = [];
		}
		let _g = 0;
		let _g1 = this.materials;
		while(_g < _g1.length) {
			let m = _g1[_g];
			++_g;
			if(m != null && a.indexOf(m) < 0) {
				a.push(m);
			}
		}
		if(recursive) {
			let _g = 0;
			let _g1 = this.children;
			while(_g < _g1.length) {
				let o = _g1[_g];
				++_g;
				o.getMaterials(a);
			}
		}
		return a;
	}
	draw(ctx) {
		if(this.materials.length > 1) {
			this.primitive.selectMaterial(ctx.drawPass.index);
		}
		super.draw(ctx);
	}
}
$hxClasses["h3d.scene.MultiMaterial"] = h3d_scene_MultiMaterial;
h3d_scene_MultiMaterial.__name__ = "h3d.scene.MultiMaterial";
h3d_scene_MultiMaterial.__super__ = h3d_scene_Mesh;
Object.assign(h3d_scene_MultiMaterial.prototype, {
	__class__: h3d_scene_MultiMaterial
	,materials: null
});
class hxsl_Globals {
	constructor() {
		this.channels = [];
		this.map = new haxe_ds_IntMap();
	}
	set(path,v) {
		let this1 = this.map;
		let key = hxsl_Globals.allocID(path);
		this1.h[key] = v;
	}
	allocChannelID(t) {
		let _g = 0;
		let _g1 = this.maxChannels;
		while(_g < _g1) {
			let i = _g++;
			if(this.channels[i] == t) {
				return i;
			}
		}
		if(this.maxChannels == 1 << hxsl_Tools.MAX_CHANNELS_BITS) {
			throw haxe_Exception.thrown("Too many unique channels");
		}
		let i = this.maxChannels++;
		this.channels[i] = t;
		return i;
	}
	static allocID(path) {
		if(hxsl_Globals.MAP == null) {
			hxsl_Globals.MAP = new haxe_ds_StringMap();
			hxsl_Globals.ALL = [];
		}
		let id = hxsl_Globals.MAP.h[path];
		if(id == null) {
			id = hxsl_Globals.ALL.length;
			hxsl_Globals.ALL.push(path);
			hxsl_Globals.MAP.h[path] = id;
		}
		return id;
	}
	static getIDName(id) {
		return hxsl_Globals.ALL[id];
	}
}
$hxClasses["hxsl.Globals"] = hxsl_Globals;
hxsl_Globals.__name__ = "hxsl.Globals";
Object.assign(hxsl_Globals.prototype, {
	__class__: hxsl_Globals
	,map: null
	,channels: null
	,maxChannels: null
});
class h3d_scene__$RenderContext_SharedGlobal {
	constructor(gid,value) {
		this.gid = gid;
		this.value = value;
	}
}
$hxClasses["h3d.scene._RenderContext.SharedGlobal"] = h3d_scene__$RenderContext_SharedGlobal;
h3d_scene__$RenderContext_SharedGlobal.__name__ = "h3d.scene._RenderContext.SharedGlobal";
Object.assign(h3d_scene__$RenderContext_SharedGlobal.prototype, {
	__class__: h3d_scene__$RenderContext_SharedGlobal
	,gid: null
	,value: null
});
class h3d_scene_RenderContext extends h3d_impl_RenderContext {
	constructor() {
		super();
		this.cachedShaderList = [];
		this.cachedPassObjects = [];
	}
	start() {
		this.sharedGlobals = [];
		this.lights = null;
		this.drawPass = null;
		this.passes = [];
		this.lights = null;
		this.cachedPos = 0;
		this.visibleFlag = true;
		this.time += this.elapsedTime;
		this.frame++;
	}
	setGlobalID(gid,value) {
		let _g = 0;
		let _g1 = this.sharedGlobals;
		while(_g < _g1.length) {
			let g = _g1[_g];
			++_g;
			if(g.gid == gid) {
				g.value = value;
				return;
			}
		}
		this.sharedGlobals.push(new h3d_scene__$RenderContext_SharedGlobal(gid,value));
	}
	emitPass(pass,obj) {
		let o = this.allocPool;
		if(o == null) {
			o = new h3d_pass_PassObject();
			o.nextAlloc = this.allocFirst;
			this.allocFirst = o;
		} else {
			this.allocPool = o.nextAlloc;
		}
		o.pass = pass;
		o.obj = obj;
		if(this.passes.length <= pass.passId) {
			this.passes.length = pass.passId;
		}
		o.next = this.passes[pass.passId];
		this.passes[pass.passId] = o;
		return o;
	}
	allocShaderList(s,next) {
		let sl = this.cachedShaderList[this.cachedPos++];
		if(sl == null) {
			sl = new hxsl_ShaderList(null);
			this.cachedShaderList[this.cachedPos - 1] = sl;
		}
		sl.s = s;
		sl.next = next;
		return sl;
	}
	emitLight(l) {
		l.next = this.lights;
		this.lights = l;
	}
	uploadParams() {
		this.currentManager.fillParams(this.shaderBuffers,this.drawPass.shader,this.drawPass.shaders);
		this.engine.uploadShaderBuffers(this.shaderBuffers,1);
		this.engine.uploadShaderBuffers(this.shaderBuffers,2);
		this.engine.uploadShaderBuffers(this.shaderBuffers,3);
	}
	done() {
		this.drawPass = null;
		let p = this.allocFirst;
		while(p != null && p != this.allocPool) {
			p.obj = null;
			p.pass = null;
			p.shader = null;
			p.shaders = null;
			p.next = null;
			p.index = 0;
			p.texture = 0;
			p = p.nextAlloc;
		}
		if(this.allocPool != null) {
			this.allocFirst = this.allocFirst.nextAlloc;
		}
		this.allocPool = this.allocFirst;
		let _g = 0;
		let _g1 = this.cachedShaderList;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c.s = null;
			c.next = null;
		}
		this.passes = [];
		this.lights = null;
	}
}
$hxClasses["h3d.scene.RenderContext"] = h3d_scene_RenderContext;
h3d_scene_RenderContext.__name__ = "h3d.scene.RenderContext";
h3d_scene_RenderContext.__super__ = h3d_impl_RenderContext;
Object.assign(h3d_scene_RenderContext.prototype, {
	__class__: h3d_scene_RenderContext
	,camera: null
	,scene: null
	,drawPass: null
	,computingStatic: null
	,sharedGlobals: null
	,lightSystem: null
	,extraShaders: null
	,visibleFlag: null
	,wasContextLost: null
	,shaderBuffers: null
	,cullingCollider: null
	,allocPool: null
	,allocFirst: null
	,cachedShaderList: null
	,cachedPassObjects: null
	,cachedPos: null
	,passes: null
	,lights: null
	,currentManager: null
});
class h3d_scene_PassObjects {
	constructor() {
		this.passes = new h3d_pass_PassList();
	}
}
$hxClasses["h3d.scene.PassObjects"] = h3d_scene_PassObjects;
h3d_scene_PassObjects.__name__ = "h3d.scene.PassObjects";
Object.assign(h3d_scene_PassObjects.prototype, {
	__class__: h3d_scene_PassObjects
	,name: null
	,passes: null
	,rendered: null
});
class h3d_scene_Renderer extends hxd_impl_AnyProps {
	constructor() {
		super();
		if(h3d_scene_Renderer._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
		this.hasSetTarget = false;
		this.emptyPasses = new h3d_pass_PassList();
		this.allPasses = [];
		this.passObjects = new haxe_ds_StringMap();
		this.set_props(this.getDefaultProps());
		let _g = this;
		let frontToBack = true;
		this.frontToBack = function(passes) {
			_g.depthSort(frontToBack,passes);
		};
		let _g1 = this;
		let frontToBack1 = false;
		this.backToFront = function(passes) {
			_g1.depthSort(frontToBack1,passes);
		};
	}
	getPassByName(name) {
		let _g = 0;
		let _g1 = this.allPasses;
		while(_g < _g1.length) {
			let p = _g1[_g];
			++_g;
			if(p.name == name) {
				return p;
			}
		}
		return null;
	}
	depthSort(frontToBack,passes) {
		let cam = this.ctx.camera.m;
		let _g_o = passes.current;
		while(_g_o != null) {
			let tmp = _g_o;
			_g_o = _g_o.next;
			let z = tmp.obj.absPos._41 * cam._13 + tmp.obj.absPos._42 * cam._23 + tmp.obj.absPos._43 * cam._33 + cam._43;
			let w = tmp.obj.absPos._41 * cam._14 + tmp.obj.absPos._42 * cam._24 + tmp.obj.absPos._43 * cam._34 + cam._44;
			tmp.depth = z / w;
		}
		if(frontToBack) {
			let list = passes.current;
			let tmp;
			if(list == null) {
				tmp = null;
			} else {
				let insize = 1;
				let nmerges;
				let psize = 0;
				let qsize = 0;
				let p;
				let q;
				let e;
				let tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						let _g = 0;
						let _g1 = insize;
						while(_g < _g1) {
							++_g;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || (p.pass.layer == q.pass.layer ? p.depth > q.depth ? 1 : -1 : p.pass.layer - q.pass.layer) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			passes.current = tmp;
		} else {
			let list = passes.current;
			let tmp;
			if(list == null) {
				tmp = null;
			} else {
				let insize = 1;
				let nmerges;
				let psize = 0;
				let qsize = 0;
				let p;
				let q;
				let e;
				let tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						let _g = 0;
						let _g1 = insize;
						while(_g < _g1) {
							++_g;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || (p.pass.layer == q.pass.layer ? p.depth > q.depth ? -1 : 1 : p.pass.layer - q.pass.layer) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			passes.current = tmp;
		}
	}
	resetTarget() {
		if(this.hasSetTarget) {
			this.ctx.engine.popTarget();
			this.hasSetTarget = false;
		}
	}
	has(name) {
		return this.passObjects.h[name] != null;
	}
	get(name) {
		let p = this.passObjects.h[name];
		if(p == null) {
			return this.emptyPasses;
		}
		p.rendered = true;
		return p.passes;
	}
	render() {
		throw haxe_Exception.thrown("Not implemented");
	}
	computeStatic() {
		throw haxe_Exception.thrown("Not implemented");
	}
	start() {
	}
	process(passes) {
		this.hasSetTarget = false;
		let _g = 0;
		let _g1 = this.allPasses;
		while(_g < _g1.length) {
			let p = _g1[_g];
			++_g;
			p.setContext(this.ctx);
		}
		let _g2 = 0;
		while(_g2 < passes.length) {
			let p = passes[_g2];
			++_g2;
			this.passObjects.h[p.name] = p;
		}
		this.ctx.textures.begin();
		if(this.ctx.computingStatic) {
			this.computeStatic();
		} else {
			this.render();
		}
		this.resetTarget();
		let _g3 = 0;
		while(_g3 < passes.length) {
			let p = passes[_g3];
			++_g3;
			this.passObjects.h[p.name] = null;
		}
	}
}
$hxClasses["h3d.scene.Renderer"] = h3d_scene_Renderer;
h3d_scene_Renderer.__name__ = "h3d.scene.Renderer";
h3d_scene_Renderer.__super__ = hxd_impl_AnyProps;
Object.assign(h3d_scene_Renderer.prototype, {
	__class__: h3d_scene_Renderer
	,defaultPass: null
	,passObjects: null
	,allPasses: null
	,emptyPasses: null
	,ctx: null
	,hasSetTarget: null
	,frontToBack: null
	,backToFront: null
});
class h3d_scene_Scene extends h3d_scene_Object {
	constructor(createRenderer,createLightSystem) {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(createRenderer,createLightSystem);
	}
	_hx_constructor(createRenderer,createLightSystem) {
		if(createLightSystem == null) {
			createLightSystem = true;
		}
		if(createRenderer == null) {
			createRenderer = true;
		}
		this.checkPasses = true;
		super._hx_constructor(null);
		this.window = hxd_Window.getInstance();
		this.eventListeners = [];
		this.hitInteractives = [];
		this.interactives = [];
		this.camera = new h3d_Camera();
		let engine = h3d_Engine.CURRENT;
		if(engine != null) {
			this.camera.screenRatio = engine.width / engine.height;
		}
		this.ctx = new h3d_scene_RenderContext();
		if(createRenderer) {
			this.set_renderer(h3d_mat_MaterialSetup.current.createRenderer());
		}
		if(createLightSystem) {
			this.lightSystem = h3d_mat_MaterialSetup.current.createLightSystem();
		}
	}
	setEvents(events) {
		this.events = events;
	}
	dispatchListeners(event) {
		let _g = 0;
		let _g1 = this.eventListeners;
		while(_g < _g1.length) {
			let l = _g1[_g];
			++_g;
			l(event);
			if(!event.propagate) {
				break;
			}
		}
	}
	set_renderer(r) {
		this.renderer = r;
		if(r != null) {
			r.ctx = this.ctx;
		}
		return r;
	}
	sortHitPointByCameraDistance(i1,i2) {
		let z1 = i1.hitPoint.w;
		let z2 = i2.hitPoint.w;
		if(z1 > z2) {
			return -1;
		}
		return 1;
	}
	dispatchEvent(event,to) {
		let i = to;
		i.handleEvent(event);
	}
	isInteractiveVisible(i) {
		let o = i;
		while(o != this) {
			if(o == null || (o.flags & 2) == 0) {
				return false;
			}
			o = o.parent;
		}
		return true;
	}
	handleEvent(event,last) {
		if(this.interactives.length == 0) {
			return null;
		}
		if(this.hitInteractives.length == 0) {
			let screenX = (event.relX / this.window.get_width() - 0.5) * 2;
			let screenY = -(event.relY / this.window.get_height() - 0.5) * 2;
			let p0 = this.camera.unproject(screenX,screenY,0);
			let p1 = this.camera.unproject(screenX,screenY,1);
			let x = p0.x;
			let y = p0.y;
			let z = p0.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let p1_x = x;
			let p1_y = y;
			let p1_z = z;
			let x1 = p1.x;
			let y1 = p1.y;
			let z1 = p1.z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let p2_x = x1;
			let p2_y = y1;
			let p2_z = z1;
			let r = new h3d_col_Ray();
			r.px = p1_x;
			r.py = p1_y;
			r.pz = p1_z;
			r.lx = p2_x - p1_x;
			r.ly = p2_y - p1_y;
			r.lz = p2_z - p1_z;
			r.normalize();
			let saveR_px = r.px;
			let saveR_py = r.py;
			let saveR_pz = r.pz;
			let saveR_lx = r.lx;
			let saveR_ly = r.ly;
			let saveR_lz = r.lz;
			let priority = -2147483648;
			let _g = 0;
			let _g1 = this.interactives;
			while(_g < _g1.length) {
				let i = _g1[_g];
				++_g;
				if(i.priority < priority) {
					continue;
				}
				let p = i;
				while(p != null && (p.flags & 2) != 0) p = p.parent;
				if(p != null) {
					continue;
				}
				if(!i.isAbsoluteShape) {
					let minv = i.getInvPos();
					let x = r.px;
					let y = r.py;
					let z = r.pz;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let p_x = x;
					let p_y = y;
					let p_z = z;
					let px = p_x * minv._11 + p_y * minv._21 + p_z * minv._31 + minv._41;
					let py = p_x * minv._12 + p_y * minv._22 + p_z * minv._32 + minv._42;
					let pz = p_x * minv._13 + p_y * minv._23 + p_z * minv._33 + minv._43;
					p_x = px;
					p_y = py;
					p_z = pz;
					r.px = p_x;
					r.py = p_y;
					r.pz = p_z;
					let x1 = r.lx;
					let y1 = r.ly;
					let z1 = r.lz;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let l_x = x1;
					let l_y = y1;
					let l_z = z1;
					let px1 = l_x * minv._11 + l_y * minv._21 + l_z * minv._31;
					let py1 = l_x * minv._12 + l_y * minv._22 + l_z * minv._32;
					let pz1 = l_x * minv._13 + l_y * minv._23 + l_z * minv._33;
					l_x = px1;
					l_y = py1;
					l_z = pz1;
					r.lx = l_x;
					r.ly = l_y;
					r.lz = l_z;
					r.normalize();
				}
				if(r.lx != r.lx) {
					r.px = saveR_px;
					r.py = saveR_py;
					r.pz = saveR_pz;
					r.lx = saveR_lx;
					r.ly = saveR_ly;
					r.lz = saveR_lz;
					continue;
				}
				let hit = i.shape.rayIntersection(r,i.bestMatch);
				if(hit < 0) {
					r.px = saveR_px;
					r.py = saveR_py;
					r.pz = saveR_pz;
					r.lx = saveR_lx;
					r.ly = saveR_ly;
					r.lz = saveR_lz;
					continue;
				}
				let x = r.px + hit * r.lx;
				let y = r.py + hit * r.ly;
				let z = r.pz + hit * r.lz;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let hitPoint_x = x;
				let hitPoint_y = y;
				let hitPoint_z = z;
				r.px = saveR_px;
				r.py = saveR_py;
				r.pz = saveR_pz;
				r.lx = saveR_lx;
				r.ly = saveR_ly;
				r.lz = saveR_lz;
				i.hitPoint.x = hitPoint_x;
				i.hitPoint.y = hitPoint_y;
				i.hitPoint.z = hitPoint_z;
				if(i.priority > priority) {
					while(this.hitInteractives.length > 0) this.hitInteractives.pop();
					priority = i.priority;
				}
				this.hitInteractives.push(i);
			}
			if(this.hitInteractives.length == 0) {
				return null;
			}
			if(this.hitInteractives.length > 1) {
				let _g = 0;
				let _g1 = this.hitInteractives;
				while(_g < _g1.length) {
					let i = _g1[_g];
					++_g;
					let m = i.invPos;
					let wfactor = 0.;
					if(i.preciseShape != null) {
						let x = r.px;
						let y = r.py;
						let z = r.pz;
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let p_x = x;
						let p_y = y;
						let p_z = z;
						let px = p_x * m._11 + p_y * m._21 + p_z * m._31 + m._41;
						let py = p_x * m._12 + p_y * m._22 + p_z * m._32 + m._42;
						let pz = p_x * m._13 + p_y * m._23 + p_z * m._33 + m._43;
						p_x = px;
						p_y = py;
						p_z = pz;
						r.px = p_x;
						r.py = p_y;
						r.pz = p_z;
						let x1 = r.lx;
						let y1 = r.ly;
						let z1 = r.lz;
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let l_x = x1;
						let l_y = y1;
						let l_z = z1;
						let px1 = l_x * m._11 + l_y * m._21 + l_z * m._31;
						let py1 = l_x * m._12 + l_y * m._22 + l_z * m._32;
						let pz1 = l_x * m._13 + l_y * m._23 + l_z * m._33;
						l_x = px1;
						l_y = py1;
						l_z = pz1;
						r.lx = l_x;
						r.ly = l_y;
						r.lz = l_z;
						r.normalize();
						let hit = i.preciseShape.rayIntersection(r,i.bestMatch);
						if(hit > 0) {
							let x = r.px + hit * r.lx;
							let y = r.py + hit * r.ly;
							let z = r.pz + hit * r.lz;
							if(z == null) {
								z = 0.;
							}
							if(y == null) {
								y = 0.;
							}
							if(x == null) {
								x = 0.;
							}
							let hitPoint_x = x;
							let hitPoint_y = y;
							let hitPoint_z = z;
							i.hitPoint.x = hitPoint_x;
							i.hitPoint.y = hitPoint_y;
							i.hitPoint.z = hitPoint_z;
						} else {
							wfactor = 1.;
						}
						r.px = saveR_px;
						r.py = saveR_py;
						r.pz = saveR_pz;
						r.lx = saveR_lx;
						r.ly = saveR_ly;
						r.lz = saveR_lz;
					}
					let _this = i.hitPoint;
					let x = _this.x;
					let y = _this.y;
					let z = _this.z;
					let w = _this.w;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let p_x = x;
					let p_y = y;
					let p_z = z;
					let p_w = w;
					p_w = 1;
					let m1 = i.absPos;
					let px = p_x * m1._11 + p_y * m1._21 + p_z * m1._31 + p_w * m1._41;
					let py = p_x * m1._12 + p_y * m1._22 + p_z * m1._32 + p_w * m1._42;
					let pz = p_x * m1._13 + p_y * m1._23 + p_z * m1._33 + p_w * m1._43;
					p_x = px;
					p_y = py;
					p_z = pz;
					let m2 = this.camera.m;
					let pz1 = p_x * m2._13 + p_y * m2._23 + p_z * m2._33 + p_w * m2._43;
					let iw = 1 / (p_x * m2._14 + p_y * m2._24 + p_z * m2._34 + p_w * m2._44);
					p_z = pz1 * iw;
					i.hitPoint.w = p_z + wfactor;
				}
				this.hitInteractives.sort($bind(this,this.sortHitPointByCameraDistance));
			}
			this.hitInteractives.unshift(null);
		}
		while(this.hitInteractives.length > 0) {
			let i = this.hitInteractives.pop();
			if(i == null) {
				return null;
			}
			event.relX = i.hitPoint.x;
			event.relY = i.hitPoint.y;
			event.relZ = i.hitPoint.z;
			i.handleEvent(event);
			if(event.cancel) {
				event.cancel = false;
				event.propagate = false;
				continue;
			}
			if(!event.propagate) {
				while(this.hitInteractives.length > 0) this.hitInteractives.pop();
			}
			return i;
		}
		return null;
	}
	addEventTarget(i) {
		if(this.interactives.indexOf(i) >= 0) {
			throw haxe_Exception.thrown("assert");
		}
		this.interactives.push(i);
	}
	removeEventTarget(i) {
		if(HxOverrides.remove(this.interactives,i)) {
			if(this.events != null) {
				this.events.onRemove(i);
			}
			HxOverrides.remove(this.hitInteractives,i);
		}
	}
	setElapsedTime(elapsedTime) {
		this.ctx.elapsedTime = elapsedTime;
	}
	onContextLost() {
		this.ctx.wasContextLost = true;
	}
	render(engine) {
		if((this.flags & 32) == 0) {
			this.onAdd();
		}
		let t = engine.getCurrentTarget();
		if(t == null) {
			this.camera.screenRatio = engine.width / engine.height;
		} else {
			this.camera.screenRatio = t.width / t.height;
		}
		this.camera.update();
		if(this.camera.rightHanded) {
			engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,1);
		}
		this.ctx.camera = this.camera;
		this.ctx.engine = engine;
		this.ctx.scene = this;
		this.ctx.start();
		this.renderer.start();
		this.syncRec(this.ctx);
		this.emitRec(this.ctx);
		let passes = [];
		let passIndex = -1;
		let _g = 0;
		let _g1 = this.ctx.passes.length;
		while(_g < _g1) {
			let passId = _g++;
			let curPass = this.ctx.passes[passId];
			if(curPass == null) {
				continue;
			}
			let pobjs = this.ctx.cachedPassObjects[++passIndex];
			if(pobjs == null) {
				pobjs = new h3d_scene_PassObjects();
				this.ctx.cachedPassObjects[passIndex] = pobjs;
			}
			pobjs.name = curPass.pass.name;
			let _this = pobjs.passes;
			_this.current = curPass;
			_this.discarded = _this.lastDisc = null;
			passes.push(pobjs);
		}
		if(this.lightSystem != null) {
			this.ctx.lightSystem = this.lightSystem;
			this.lightSystem.initLights(this.ctx);
		}
		this.renderer.process(passes);
		if(!this.ctx.computingStatic && this.checkPasses) {
			let _g = 0;
			while(_g < passes.length) {
				let p = passes[_g];
				++_g;
				if(!p.rendered) {
					haxe_Log.trace("Pass " + p.name + " has not been rendered : don't know how to handle.",{ fileName : "h3d/scene/Scene.hx", lineNumber : 445, className : "h3d.scene.Scene", methodName : "render"});
				}
			}
		}
		if(this.camera.rightHanded) {
			engine.driver.setRenderFlag(h3d_impl_RenderFlag.CameraHandness,0);
		}
		this.ctx.done();
		this.ctx.wasContextLost = false;
		this.ctx.scene = null;
		this.ctx.camera = null;
		this.ctx.engine = null;
		let _g2 = 0;
		let _g3 = passIndex;
		while(_g2 < _g3) {
			let i = _g2++;
			let p = this.ctx.cachedPassObjects[i];
			p.name = null;
			let _this = p.passes;
			_this.current = null;
			_this.discarded = _this.lastDisc = null;
		}
	}
}
$hxClasses["h3d.scene.Scene"] = h3d_scene_Scene;
h3d_scene_Scene.__name__ = "h3d.scene.Scene";
h3d_scene_Scene.__interfaces__ = [hxd_InteractiveScene,h3d_IDrawable];
h3d_scene_Scene.__super__ = h3d_scene_Object;
Object.assign(h3d_scene_Scene.prototype, {
	__class__: h3d_scene_Scene
	,camera: null
	,lightSystem: null
	,renderer: null
	,ctx: null
	,interactives: null
	,events: null
	,hitInteractives: null
	,eventListeners: null
	,window: null
	,checkPasses: null
});
class h3d_scene_fwd_Light extends h3d_scene_Light {
	constructor(shader,parent) {
		if(h3d_scene_Object._hx_skip_constructor) {
			super();
			return;
		}
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(shader,parent);
	}
	_hx_constructor(shader,parent) {
		this.priority = 0;
		this.cullingDistance = -1;
		super._hx_constructor(shader,parent);
	}
}
$hxClasses["h3d.scene.fwd.Light"] = h3d_scene_fwd_Light;
h3d_scene_fwd_Light.__name__ = "h3d.scene.fwd.Light";
h3d_scene_fwd_Light.__super__ = h3d_scene_Light;
Object.assign(h3d_scene_fwd_Light.prototype, {
	__class__: h3d_scene_fwd_Light
	,objectDistance: null
	,cullingDistance: null
	,priority: null
});
class h3d_scene_fwd_LightSystem extends h3d_scene_LightSystem {
	constructor() {
		h3d_scene_LightSystem._hx_skip_constructor = true;
		super();
		h3d_scene_LightSystem._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.perPixelLighting = true;
		this.maxLightsPerObject = 6;
		super._hx_constructor();
		this.ambientLight = new h3d_Vector(0.5,0.5,0.5);
		this.ambientShader = new h3d_shader_AmbientLight();
		this.set_additiveLighting(true);
	}
	set_additiveLighting(b) {
		let value = this.ambientShader;
		let _this = ((value) instanceof h3d_shader_AmbientLight) ? value : null;
		_this.constModified = true;
		return _this.additive__ = b;
	}
	initLights(ctx) {
		this.lightCount = 0;
		this.ctx = ctx;
		this.cullLights();
		super.initLights(ctx);
		if(this.lightCount <= this.maxLightsPerObject) {
			let list = ctx.lights;
			let cmp = $bind(this,this.sortLight);
			let tmp;
			if(list == null) {
				tmp = null;
			} else {
				let insize = 1;
				let nmerges;
				let psize = 0;
				let qsize = 0;
				let p;
				let q;
				let e;
				let tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						let _g = 0;
						let _g1 = insize;
						while(_g < _g1) {
							++_g;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			ctx.lights = tmp;
		}
	}
	initGlobals(globals) {
		globals.set("global.ambientLight",this.ambientLight);
		globals.set("global.perPixelLighting",this.perPixelLighting);
	}
	cullLights() {
		let ll = this.ctx.lights;
		let prev = null;
		let s = new h3d_col_Sphere();
		while(ll != null) {
			let l = ((ll) instanceof h3d_scene_fwd_Light) ? ll : null;
			if(l != null) {
				s.x = l.absPos._41;
				s.y = l.absPos._42;
				s.z = l.absPos._43;
				s.r = l.cullingDistance;
			}
			if(l == null || l.cullingDistance > 0 && !this.ctx.computingStatic && !this.ctx.camera.frustum.hasSphere(s)) {
				if(prev == null) {
					this.ctx.lights = ll.next;
				} else {
					prev.next = ll.next;
				}
				ll = ll.next;
				continue;
			}
			this.lightCount++;
			l.objectDistance = 0.;
			prev = ll;
			ll = ll.next;
		}
	}
	sortLight(l1,l2) {
		let p = l1.priority - l2.priority;
		if(p != 0) {
			return -p;
		}
		if(l1.objectDistance < l2.objectDistance) {
			return -1;
		} else {
			return 1;
		}
	}
	computeLight(obj,shaders) {
		if(this.lightCount > this.maxLightsPerObject) {
			let ll = this.ctx.lights;
			while(ll != null) {
				let l = ((ll) instanceof h3d_scene_fwd_Light) ? ll : null;
				if((obj.flags & 16) != 0) {
					let dx = l.absPos._41 - this.ctx.camera.target.x;
					let dy = l.absPos._42 - this.ctx.camera.target.y;
					let dz = l.absPos._43 - this.ctx.camera.target.z;
					if(dz == null) {
						dz = 0.;
					}
					l.objectDistance = dx * dx + dy * dy + dz * dz;
				} else {
					let dx = l.absPos._41 - obj.absPos._41;
					let dy = l.absPos._42 - obj.absPos._42;
					let dz = l.absPos._43 - obj.absPos._43;
					if(dz == null) {
						dz = 0.;
					}
					l.objectDistance = dx * dx + dy * dy + dz * dz;
				}
				ll = ll.next;
			}
			let list = this.ctx.lights;
			let cmp = $bind(this,this.sortLight);
			let tmp;
			if(list == null) {
				tmp = null;
			} else {
				let insize = 1;
				let nmerges;
				let psize = 0;
				let qsize = 0;
				let p;
				let q;
				let e;
				let tail;
				while(true) {
					p = list;
					list = null;
					tail = null;
					nmerges = 0;
					while(p != null) {
						++nmerges;
						q = p;
						psize = 0;
						let _g = 0;
						let _g1 = insize;
						while(_g < _g1) {
							++_g;
							++psize;
							q = q.next;
							if(q == null) {
								break;
							}
						}
						qsize = insize;
						while(psize > 0 || qsize > 0 && q != null) {
							if(psize == 0) {
								e = q;
								q = q.next;
								--qsize;
							} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
								e = p;
								p = p.next;
								--psize;
							} else {
								e = q;
								q = q.next;
								--qsize;
							}
							if(tail != null) {
								tail.next = e;
							} else {
								list = e;
							}
							tail = e;
						}
						p = q;
					}
					tail.next = null;
					if(nmerges <= 1) {
						break;
					}
					insize *= 2;
				}
				tmp = list;
			}
			this.ctx.lights = tmp;
		}
		shaders = this.ctx.allocShaderList(this.ambientShader,shaders);
		let l = this.ctx.lights;
		let i = 0;
		while(l != null) {
			if(i++ == this.maxLightsPerObject) {
				break;
			}
			shaders = this.ctx.allocShaderList(l.shader,shaders);
			l = l.next;
		}
		return shaders;
	}
}
$hxClasses["h3d.scene.fwd.LightSystem"] = h3d_scene_fwd_LightSystem;
h3d_scene_fwd_LightSystem.__name__ = "h3d.scene.fwd.LightSystem";
h3d_scene_fwd_LightSystem.__super__ = h3d_scene_LightSystem;
Object.assign(h3d_scene_fwd_LightSystem.prototype, {
	__class__: h3d_scene_fwd_LightSystem
	,maxLightsPerObject: null
	,ambientShader: null
	,lightCount: null
	,perPixelLighting: null
	,ambientLight: null
});
class h3d_scene_fwd_DepthPass extends h3d_pass_Default {
	constructor() {
		h3d_pass_Base._hx_skip_constructor = true;
		super();
		h3d_pass_Base._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.enableSky = false;
		super._hx_constructor("depth");
		this.depthMapId = hxsl_Globals.allocID("depthMap");
	}
	getOutputs() {
		return [hxsl_Output.PackFloat(hxsl_Output.Value("output.depth"))];
	}
	draw(passes,sort) {
		let texture = this.ctx.textures.allocTarget("depthMap",this.ctx.engine.width,this.ctx.engine.height,true);
		this.ctx.engine.pushTarget(texture);
		this.ctx.engine.clear(this.enableSky ? 0 : 16711680,1);
		super.draw(passes,sort);
		this.ctx.engine.popTarget();
		this.ctx.setGlobalID(this.depthMapId,{ texture : texture});
	}
}
$hxClasses["h3d.scene.fwd.DepthPass"] = h3d_scene_fwd_DepthPass;
h3d_scene_fwd_DepthPass.__name__ = "h3d.scene.fwd.DepthPass";
h3d_scene_fwd_DepthPass.__super__ = h3d_pass_Default;
Object.assign(h3d_scene_fwd_DepthPass.prototype, {
	__class__: h3d_scene_fwd_DepthPass
	,depthMapId: null
	,enableSky: null
});
class h3d_scene_fwd_NormalPass extends h3d_pass_Default {
	constructor() {
		super("normal");
		this.normalMapId = hxsl_Globals.allocID("normalMap");
	}
	getOutputs() {
		return [hxsl_Output.PackNormal(hxsl_Output.Value("output.normal"))];
	}
	draw(passes,sort) {
		let texture = this.ctx.textures.allocTarget("normalMap",this.ctx.engine.width,this.ctx.engine.height);
		this.ctx.engine.pushTarget(texture);
		this.ctx.engine.clear(8421504,1);
		super.draw(passes,sort);
		this.ctx.engine.popTarget();
		this.ctx.setGlobalID(this.normalMapId,texture);
	}
}
$hxClasses["h3d.scene.fwd.NormalPass"] = h3d_scene_fwd_NormalPass;
h3d_scene_fwd_NormalPass.__name__ = "h3d.scene.fwd.NormalPass";
h3d_scene_fwd_NormalPass.__super__ = h3d_pass_Default;
Object.assign(h3d_scene_fwd_NormalPass.prototype, {
	__class__: h3d_scene_fwd_NormalPass
	,normalMapId: null
});
class h3d_scene_fwd_Renderer extends h3d_scene_Renderer {
	constructor() {
		h3d_scene_Renderer._hx_skip_constructor = true;
		super();
		h3d_scene_Renderer._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.shadow = new h3d_pass_DefaultShadowMap(1024);
		this.normal = new h3d_scene_fwd_NormalPass();
		this.depth = new h3d_scene_fwd_DepthPass();
		super._hx_constructor();
		this.defaultPass = new h3d_pass_Default("default");
		this.allPasses = [this.defaultPass,this.depth,this.normal,this.shadow];
	}
	renderPass(p,passes,sort) {
		p.draw(passes,sort);
	}
	getPassByName(name) {
		if(name == "alpha" || name == "additive") {
			return this.defaultPass;
		}
		return super.getPassByName(name);
	}
	render() {
		if(this.has("shadow")) {
			this.renderPass(this.shadow,this.get("shadow"));
		}
		if(this.has("depth")) {
			this.renderPass(this.depth,this.get("depth"));
		}
		if(this.has("normal")) {
			this.renderPass(this.normal,this.get("normal"));
		}
		this.renderPass(this.defaultPass,this.get("default"));
		this.renderPass(this.defaultPass,this.get("alpha"),this.backToFront);
		this.renderPass(this.defaultPass,this.get("additive"));
	}
}
$hxClasses["h3d.scene.fwd.Renderer"] = h3d_scene_fwd_Renderer;
h3d_scene_fwd_Renderer.__name__ = "h3d.scene.fwd.Renderer";
h3d_scene_fwd_Renderer.__super__ = h3d_scene_Renderer;
Object.assign(h3d_scene_fwd_Renderer.prototype, {
	__class__: h3d_scene_fwd_Renderer
	,depth: null
	,normal: null
	,shadow: null
});
class h3d_scene_pbr_IrradBase extends h3d_shader_ScreenShader {
	constructor() {
		if(hxsl_Shader._hx_skip_constructor) {
			super();
			return;
		}
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.samplesBits__ = 0;
		super._hx_constructor();
	}
	get_samplesBits() {
		return this.samplesBits__;
	}
	set_samplesBits(_v) {
		this.constModified = true;
		return this.samplesBits__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		let v = this.samplesBits__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("samplesBits" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.samplesBits__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_scene_pbr_IrradBase.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.samplesBits__ = this.samplesBits__;
		return s;
	}
}
$hxClasses["h3d.scene.pbr.IrradBase"] = h3d_scene_pbr_IrradBase;
h3d_scene_pbr_IrradBase.__name__ = "h3d.scene.pbr.IrradBase";
h3d_scene_pbr_IrradBase.__super__ = h3d_shader_ScreenShader;
Object.assign(h3d_scene_pbr_IrradBase.prototype, {
	__class__: h3d_scene_pbr_IrradBase
	,samplesBits__: null
});
class h3d_scene_pbr_IrradShader extends h3d_scene_pbr_IrradBase {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.hdrMax__ = 0;
		this.cubeScaleFactor__ = 0;
		this.cubeSize__ = 0;
		this.roughness__ = 0;
		this.faceMatrix__ = new h3d_Matrix();
		super._hx_constructor();
	}
	get_faceMatrix() {
		return this.faceMatrix__;
	}
	set_faceMatrix(_v) {
		return this.faceMatrix__ = _v;
	}
	get_envMap() {
		return this.envMap__;
	}
	set_envMap(_v) {
		return this.envMap__ = _v;
	}
	get_isSpecular() {
		return this.isSpecular__;
	}
	set_isSpecular(_v) {
		this.constModified = true;
		return this.isSpecular__ = _v;
	}
	get_isSRGB() {
		return this.isSRGB__;
	}
	set_isSRGB(_v) {
		this.constModified = true;
		return this.isSRGB__ = _v;
	}
	get_roughness() {
		return this.roughness__;
	}
	set_roughness(_v) {
		return this.roughness__ = _v;
	}
	get_cubeSize() {
		return this.cubeSize__;
	}
	set_cubeSize(_v) {
		return this.cubeSize__ = _v;
	}
	get_cubeScaleFactor() {
		return this.cubeScaleFactor__;
	}
	set_cubeScaleFactor(_v) {
		return this.cubeScaleFactor__ = _v;
	}
	get_hdrMax() {
		return this.hdrMax__;
	}
	set_hdrMax(_v) {
		return this.hdrMax__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		let v = this.samplesBits__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("samplesBits" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.isSpecular__) {
			this.constBits |= 256;
		}
		if(this.isSRGB__) {
			this.constBits |= 512;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.samplesBits__;
		case 2:
			return this.faceMatrix__;
		case 3:
			return this.envMap__;
		case 4:
			return this.isSpecular__;
		case 5:
			return this.isSRGB__;
		case 6:
			return this.roughness__;
		case 7:
			return this.cubeSize__;
		case 8:
			return this.cubeScaleFactor__;
		case 9:
			return this.hdrMax__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 6:
			return this.roughness__;
		case 7:
			return this.cubeSize__;
		case 8:
			return this.cubeScaleFactor__;
		case 9:
			return this.hdrMax__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_scene_pbr_IrradShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.samplesBits__ = this.samplesBits__;
		s.faceMatrix__ = this.faceMatrix__;
		s.envMap__ = this.envMap__;
		s.isSpecular__ = this.isSpecular__;
		s.isSRGB__ = this.isSRGB__;
		s.roughness__ = this.roughness__;
		s.cubeSize__ = this.cubeSize__;
		s.cubeScaleFactor__ = this.cubeScaleFactor__;
		s.hdrMax__ = this.hdrMax__;
		return s;
	}
}
$hxClasses["h3d.scene.pbr.IrradShader"] = h3d_scene_pbr_IrradShader;
h3d_scene_pbr_IrradShader.__name__ = "h3d.scene.pbr.IrradShader";
h3d_scene_pbr_IrradShader.__super__ = h3d_scene_pbr_IrradBase;
Object.assign(h3d_scene_pbr_IrradShader.prototype, {
	__class__: h3d_scene_pbr_IrradShader
	,faceMatrix__: null
	,envMap__: null
	,isSpecular__: null
	,isSRGB__: null
	,roughness__: null
	,cubeSize__: null
	,cubeScaleFactor__: null
	,hdrMax__: null
});
class h3d_scene_pbr_IrradLut extends h3d_scene_pbr_IrradBase {
	constructor() {
		super();
	}
	updateConstants(globals) {
		this.constBits = 0;
		let v = this.samplesBits__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("samplesBits" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.samplesBits__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_scene_pbr_IrradLut.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.samplesBits__ = this.samplesBits__;
		return s;
	}
}
$hxClasses["h3d.scene.pbr.IrradLut"] = h3d_scene_pbr_IrradLut;
h3d_scene_pbr_IrradLut.__name__ = "h3d.scene.pbr.IrradLut";
h3d_scene_pbr_IrradLut.__super__ = h3d_scene_pbr_IrradBase;
Object.assign(h3d_scene_pbr_IrradLut.prototype, {
	__class__: h3d_scene_pbr_IrradLut
});
class h3d_scene_pbr_PanoramaToCube extends h3d_shader_ScreenShader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.aboveThresholdScale__ = 0;
		this.threshold__ = 0;
		this.faceMatrix__ = new h3d_Matrix();
		super._hx_constructor();
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	get_faceMatrix() {
		return this.faceMatrix__;
	}
	set_faceMatrix(_v) {
		return this.faceMatrix__ = _v;
	}
	get_threshold() {
		return this.threshold__;
	}
	set_threshold(_v) {
		return this.threshold__ = _v;
	}
	get_aboveThresholdScale() {
		return this.aboveThresholdScale__;
	}
	set_aboveThresholdScale(_v) {
		return this.aboveThresholdScale__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.faceMatrix__;
		case 3:
			return this.threshold__;
		case 4:
			return this.aboveThresholdScale__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 3:
			return this.threshold__;
		case 4:
			return this.aboveThresholdScale__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_scene_pbr_PanoramaToCube.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		s.faceMatrix__ = this.faceMatrix__;
		s.threshold__ = this.threshold__;
		s.aboveThresholdScale__ = this.aboveThresholdScale__;
		return s;
	}
}
$hxClasses["h3d.scene.pbr.PanoramaToCube"] = h3d_scene_pbr_PanoramaToCube;
h3d_scene_pbr_PanoramaToCube.__name__ = "h3d.scene.pbr.PanoramaToCube";
h3d_scene_pbr_PanoramaToCube.__super__ = h3d_shader_ScreenShader;
Object.assign(h3d_scene_pbr_PanoramaToCube.prototype, {
	__class__: h3d_scene_pbr_PanoramaToCube
	,texture__: null
	,faceMatrix__: null
	,threshold__: null
	,aboveThresholdScale__: null
});
class h3d_scene_pbr_CubeToPanorama extends h3d_shader_ScreenShader {
	constructor() {
		super();
	}
	get_source() {
		return this.source__;
	}
	set_source(_v) {
		return this.source__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.source__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_scene_pbr_CubeToPanorama.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.source__ = this.source__;
		return s;
	}
}
$hxClasses["h3d.scene.pbr.CubeToPanorama"] = h3d_scene_pbr_CubeToPanorama;
h3d_scene_pbr_CubeToPanorama.__name__ = "h3d.scene.pbr.CubeToPanorama";
h3d_scene_pbr_CubeToPanorama.__super__ = h3d_shader_ScreenShader;
Object.assign(h3d_scene_pbr_CubeToPanorama.prototype, {
	__class__: h3d_scene_pbr_CubeToPanorama
	,source__: null
});
class h3d_shader_AlphaChannel extends hxsl_Shader {
	constructor() {
		super();
	}
	get_showAlpha() {
		return this.showAlpha__;
	}
	set_showAlpha(_v) {
		this.constModified = true;
		return this.showAlpha__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.showAlpha__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.showAlpha__;
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_AlphaChannel.prototype);
		s.shader = this.shader;
		s.showAlpha__ = this.showAlpha__;
		return s;
	}
}
$hxClasses["h3d.shader.AlphaChannel"] = h3d_shader_AlphaChannel;
h3d_shader_AlphaChannel.__name__ = "h3d.shader.AlphaChannel";
h3d_shader_AlphaChannel.__super__ = hxsl_Shader;
Object.assign(h3d_shader_AlphaChannel.prototype, {
	__class__: h3d_shader_AlphaChannel
	,showAlpha__: null
});
class h3d_shader_AlphaMult extends hxsl_Shader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.alpha__ = 0;
		super._hx_constructor();
	}
	get_alpha() {
		return this.alpha__;
	}
	set_alpha(_v) {
		return this.alpha__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.alpha__;
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.alpha__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_AlphaMult.prototype);
		s.shader = this.shader;
		s.alpha__ = this.alpha__;
		return s;
	}
}
$hxClasses["h3d.shader.AlphaMult"] = h3d_shader_AlphaMult;
h3d_shader_AlphaMult.__name__ = "h3d.shader.AlphaMult";
h3d_shader_AlphaMult.__super__ = hxsl_Shader;
Object.assign(h3d_shader_AlphaMult.prototype, {
	__class__: h3d_shader_AlphaMult
	,alpha__: null
});
class h3d_shader_AmbientLight extends hxsl_Shader {
	constructor() {
		super();
	}
	get_additive() {
		return this.additive__;
	}
	set_additive(_v) {
		this.constModified = true;
		return this.additive__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.additive__) {
			this.constBits |= 2;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.additive__;
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_AmbientLight.prototype);
		s.shader = this.shader;
		s.additive__ = this.additive__;
		return s;
	}
}
$hxClasses["h3d.shader.AmbientLight"] = h3d_shader_AmbientLight;
h3d_shader_AmbientLight.__name__ = "h3d.shader.AmbientLight";
h3d_shader_AmbientLight.__super__ = hxsl_Shader;
Object.assign(h3d_shader_AmbientLight.prototype, {
	__class__: h3d_shader_AmbientLight
	,additive__: null
});
class h3d_shader_Base2d extends hxsl_Shader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.viewportB__ = new h3d_Vector();
		this.viewportA__ = new h3d_Vector();
		this.halfPixelInverse__ = new h3d_Vector();
		this.uvPos__ = new h3d_Vector();
		this.filterMatrixB__ = new h3d_Vector();
		this.filterMatrixA__ = new h3d_Vector();
		this.absoluteMatrixB__ = new h3d_Vector();
		this.absoluteMatrixA__ = new h3d_Vector();
		this.color__ = new h3d_Vector();
		this.zValue__ = 0;
		super._hx_constructor();
	}
	get_zValue() {
		return this.zValue__;
	}
	set_zValue(_v) {
		return this.zValue__ = _v;
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	get_isRelative() {
		return this.isRelative__;
	}
	set_isRelative(_v) {
		this.constModified = true;
		return this.isRelative__ = _v;
	}
	get_color() {
		return this.color__;
	}
	set_color(_v) {
		return this.color__ = _v;
	}
	get_absoluteMatrixA() {
		return this.absoluteMatrixA__;
	}
	set_absoluteMatrixA(_v) {
		return this.absoluteMatrixA__ = _v;
	}
	get_absoluteMatrixB() {
		return this.absoluteMatrixB__;
	}
	set_absoluteMatrixB(_v) {
		return this.absoluteMatrixB__ = _v;
	}
	get_filterMatrixA() {
		return this.filterMatrixA__;
	}
	set_filterMatrixA(_v) {
		return this.filterMatrixA__ = _v;
	}
	get_filterMatrixB() {
		return this.filterMatrixB__;
	}
	set_filterMatrixB(_v) {
		return this.filterMatrixB__ = _v;
	}
	get_hasUVPos() {
		return this.hasUVPos__;
	}
	set_hasUVPos(_v) {
		this.constModified = true;
		return this.hasUVPos__ = _v;
	}
	get_uvPos() {
		return this.uvPos__;
	}
	set_uvPos(_v) {
		return this.uvPos__ = _v;
	}
	get_killAlpha() {
		return this.killAlpha__;
	}
	set_killAlpha(_v) {
		this.constModified = true;
		return this.killAlpha__ = _v;
	}
	get_pixelAlign() {
		return this.pixelAlign__;
	}
	set_pixelAlign(_v) {
		this.constModified = true;
		return this.pixelAlign__ = _v;
	}
	get_halfPixelInverse() {
		return this.halfPixelInverse__;
	}
	set_halfPixelInverse(_v) {
		return this.halfPixelInverse__ = _v;
	}
	get_viewportA() {
		return this.viewportA__;
	}
	set_viewportA(_v) {
		return this.viewportA__ = _v;
	}
	get_viewportB() {
		return this.viewportB__;
	}
	set_viewportB(_v) {
		return this.viewportB__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.isRelative__) {
			this.constBits |= 1;
		}
		if(this.hasUVPos__) {
			this.constBits |= 2;
		}
		if(this.killAlpha__) {
			this.constBits |= 4;
		}
		if(this.pixelAlign__) {
			this.constBits |= 8;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.zValue__;
		case 1:
			return this.texture__;
		case 2:
			return this.isRelative__;
		case 3:
			return this.color__;
		case 4:
			return this.absoluteMatrixA__;
		case 5:
			return this.absoluteMatrixB__;
		case 6:
			return this.filterMatrixA__;
		case 7:
			return this.filterMatrixB__;
		case 8:
			return this.hasUVPos__;
		case 9:
			return this.uvPos__;
		case 10:
			return this.killAlpha__;
		case 11:
			return this.pixelAlign__;
		case 12:
			return this.halfPixelInverse__;
		case 13:
			return this.viewportA__;
		case 14:
			return this.viewportB__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.zValue__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_Base2d.prototype);
		s.shader = this.shader;
		s.zValue__ = this.zValue__;
		s.texture__ = this.texture__;
		s.isRelative__ = this.isRelative__;
		s.color__ = this.color__;
		s.absoluteMatrixA__ = this.absoluteMatrixA__;
		s.absoluteMatrixB__ = this.absoluteMatrixB__;
		s.filterMatrixA__ = this.filterMatrixA__;
		s.filterMatrixB__ = this.filterMatrixB__;
		s.hasUVPos__ = this.hasUVPos__;
		s.uvPos__ = this.uvPos__;
		s.killAlpha__ = this.killAlpha__;
		s.pixelAlign__ = this.pixelAlign__;
		s.halfPixelInverse__ = this.halfPixelInverse__;
		s.viewportA__ = this.viewportA__;
		s.viewportB__ = this.viewportB__;
		return s;
	}
}
$hxClasses["h3d.shader.Base2d"] = h3d_shader_Base2d;
h3d_shader_Base2d.__name__ = "h3d.shader.Base2d";
h3d_shader_Base2d.__super__ = hxsl_Shader;
Object.assign(h3d_shader_Base2d.prototype, {
	__class__: h3d_shader_Base2d
	,zValue__: null
	,texture__: null
	,isRelative__: null
	,color__: null
	,absoluteMatrixA__: null
	,absoluteMatrixB__: null
	,filterMatrixA__: null
	,filterMatrixB__: null
	,hasUVPos__: null
	,uvPos__: null
	,killAlpha__: null
	,pixelAlign__: null
	,halfPixelInverse__: null
	,viewportA__: null
	,viewportB__: null
});
class h3d_shader_BaseMesh extends hxsl_Shader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.specularColor__ = new h3d_Vector();
		this.specularAmount__ = 0;
		this.specularPower__ = 0;
		this.color__ = new h3d_Vector();
		super._hx_constructor();
		let _this = this.color__;
		_this.x = 1;
		_this.y = 1;
		_this.z = 1;
		_this.w = 1.;
		let _this1 = this.specularColor__;
		_this1.x = 1;
		_this1.y = 1;
		_this1.z = 1;
		_this1.w = 1.;
		this.specularPower__ = 50;
		this.specularAmount__ = 1;
	}
	get_color() {
		return this.color__;
	}
	set_color(_v) {
		return this.color__ = _v;
	}
	get_specularPower() {
		return this.specularPower__;
	}
	set_specularPower(_v) {
		return this.specularPower__ = _v;
	}
	get_specularAmount() {
		return this.specularAmount__;
	}
	set_specularAmount(_v) {
		return this.specularAmount__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.color__;
		case 1:
			return this.specularPower__;
		case 2:
			return this.specularAmount__;
		case 3:
			return this.specularColor__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 1:
			return this.specularPower__;
		case 2:
			return this.specularAmount__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_BaseMesh.prototype);
		s.shader = this.shader;
		s.color__ = this.color__;
		s.specularPower__ = this.specularPower__;
		s.specularAmount__ = this.specularAmount__;
		s.specularColor__ = this.specularColor__;
		return s;
	}
}
$hxClasses["h3d.shader.BaseMesh"] = h3d_shader_BaseMesh;
h3d_shader_BaseMesh.__name__ = "h3d.shader.BaseMesh";
h3d_shader_BaseMesh.__super__ = hxsl_Shader;
Object.assign(h3d_shader_BaseMesh.prototype, {
	__class__: h3d_shader_BaseMesh
	,color__: null
	,specularPower__: null
	,specularAmount__: null
	,specularColor__: null
});
class h3d_shader_Blur extends h3d_shader_ScreenShader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.cubeDir__ = new h3d_Matrix();
		this.fixedColor__ = new h3d_Vector();
		this.pixel__ = new h3d_Vector();
		this.offsets__ = [];
		this.values__ = [];
		this.Quality__ = 0;
		this.cameraInverseViewProj__ = new h3d_Matrix();
		super._hx_constructor();
	}
	get_cameraInverseViewProj() {
		return this.cameraInverseViewProj__;
	}
	set_cameraInverseViewProj(_v) {
		return this.cameraInverseViewProj__ = _v;
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	get_depthTexture() {
		return this.depthTexture__;
	}
	set_depthTexture(_v) {
		return this.depthTexture__ = _v;
	}
	get_Quality() {
		return this.Quality__;
	}
	set_Quality(_v) {
		this.constModified = true;
		return this.Quality__ = _v;
	}
	get_isDepth() {
		return this.isDepth__;
	}
	set_isDepth(_v) {
		this.constModified = true;
		return this.isDepth__ = _v;
	}
	get_values() {
		return this.values__;
	}
	set_values(_v) {
		return this.values__ = _v;
	}
	get_offsets() {
		return this.offsets__;
	}
	set_offsets(_v) {
		return this.offsets__ = _v;
	}
	get_pixel() {
		return this.pixel__;
	}
	set_pixel(_v) {
		return this.pixel__ = _v;
	}
	get_hasFixedColor() {
		return this.hasFixedColor__;
	}
	set_hasFixedColor(_v) {
		this.constModified = true;
		return this.hasFixedColor__ = _v;
	}
	get_smoothFixedColor() {
		return this.smoothFixedColor__;
	}
	set_smoothFixedColor(_v) {
		this.constModified = true;
		return this.smoothFixedColor__ = _v;
	}
	get_fixedColor() {
		return this.fixedColor__;
	}
	set_fixedColor(_v) {
		return this.fixedColor__ = _v;
	}
	get_isDepthDependant() {
		return this.isDepthDependant__;
	}
	set_isDepthDependant(_v) {
		this.constModified = true;
		return this.isDepthDependant__ = _v;
	}
	get_hasNormal() {
		return this.hasNormal__;
	}
	set_hasNormal(_v) {
		this.constModified = true;
		return this.hasNormal__ = _v;
	}
	get_normalTexture() {
		return this.normalTexture__;
	}
	set_normalTexture(_v) {
		return this.normalTexture__ = _v;
	}
	get_isCube() {
		return this.isCube__;
	}
	set_isCube(_v) {
		this.constModified = true;
		return this.isCube__ = _v;
	}
	get_cubeTexture() {
		return this.cubeTexture__;
	}
	set_cubeTexture(_v) {
		return this.cubeTexture__ = _v;
	}
	get_cubeDir() {
		return this.cubeDir__;
	}
	set_cubeDir(_v) {
		return this.cubeDir__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		let v = this.Quality__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("Quality" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.isDepth__) {
			this.constBits |= 256;
		}
		if(this.hasFixedColor__) {
			this.constBits |= 512;
		}
		if(this.smoothFixedColor__) {
			this.constBits |= 1024;
		}
		if(this.isDepthDependant__) {
			this.constBits |= 2048;
		}
		if(this.hasNormal__) {
			this.constBits |= 4096;
		}
		if(this.isCube__) {
			this.constBits |= 8192;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.cameraInverseViewProj__;
		case 2:
			return this.texture__;
		case 3:
			return this.depthTexture__;
		case 4:
			return this.Quality__;
		case 5:
			return this.isDepth__;
		case 6:
			return this.values__;
		case 7:
			return this.offsets__;
		case 8:
			return this.pixel__;
		case 9:
			return this.hasFixedColor__;
		case 10:
			return this.smoothFixedColor__;
		case 11:
			return this.fixedColor__;
		case 12:
			return this.isDepthDependant__;
		case 13:
			return this.hasNormal__;
		case 14:
			return this.normalTexture__;
		case 15:
			return this.isCube__;
		case 16:
			return this.cubeTexture__;
		case 17:
			return this.cubeDir__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_Blur.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.cameraInverseViewProj__ = this.cameraInverseViewProj__;
		s.texture__ = this.texture__;
		s.depthTexture__ = this.depthTexture__;
		s.Quality__ = this.Quality__;
		s.isDepth__ = this.isDepth__;
		s.values__ = this.values__;
		s.offsets__ = this.offsets__;
		s.pixel__ = this.pixel__;
		s.hasFixedColor__ = this.hasFixedColor__;
		s.smoothFixedColor__ = this.smoothFixedColor__;
		s.fixedColor__ = this.fixedColor__;
		s.isDepthDependant__ = this.isDepthDependant__;
		s.hasNormal__ = this.hasNormal__;
		s.normalTexture__ = this.normalTexture__;
		s.isCube__ = this.isCube__;
		s.cubeTexture__ = this.cubeTexture__;
		s.cubeDir__ = this.cubeDir__;
		return s;
	}
}
$hxClasses["h3d.shader.Blur"] = h3d_shader_Blur;
h3d_shader_Blur.__name__ = "h3d.shader.Blur";
h3d_shader_Blur.__super__ = h3d_shader_ScreenShader;
Object.assign(h3d_shader_Blur.prototype, {
	__class__: h3d_shader_Blur
	,cameraInverseViewProj__: null
	,texture__: null
	,depthTexture__: null
	,Quality__: null
	,isDepth__: null
	,values__: null
	,offsets__: null
	,pixel__: null
	,hasFixedColor__: null
	,smoothFixedColor__: null
	,fixedColor__: null
	,isDepthDependant__: null
	,hasNormal__: null
	,normalTexture__: null
	,isCube__: null
	,cubeTexture__: null
	,cubeDir__: null
});
class h3d_shader_ShaderBuffers {
	constructor(s) {
		this.globals = new Float32Array(s.globalsSize << 2);
		this.params = new Float32Array(s.paramsSize << 2);
		this.tex = new Array(s.texturesCount);
		this.buffers = s.bufferCount > 0 ? new Array(s.bufferCount) : null;
	}
	grow(s) {
		let ng = s.globalsSize << 2;
		let np = s.paramsSize << 2;
		let nt = s.texturesCount;
		let nb = s.bufferCount;
		if(this.globals.length < ng) {
			this.globals = new Float32Array(ng);
		}
		if(this.params.length < np) {
			this.params = new Float32Array(np);
		}
		if(this.tex.length < nt) {
			this.tex = new Array(nt);
		}
		if(nb > 0 && (this.buffers == null || this.buffers.length < nb)) {
			this.buffers = new Array(nb);
		}
	}
}
$hxClasses["h3d.shader.ShaderBuffers"] = h3d_shader_ShaderBuffers;
h3d_shader_ShaderBuffers.__name__ = "h3d.shader.ShaderBuffers";
Object.assign(h3d_shader_ShaderBuffers.prototype, {
	__class__: h3d_shader_ShaderBuffers
	,globals: null
	,params: null
	,tex: null
	,buffers: null
});
class h3d_shader_Buffers {
	constructor(s) {
		this.vertex = new h3d_shader_ShaderBuffers(s.vertex);
		this.fragment = new h3d_shader_ShaderBuffers(s.fragment);
	}
}
$hxClasses["h3d.shader.Buffers"] = h3d_shader_Buffers;
h3d_shader_Buffers.__name__ = "h3d.shader.Buffers";
Object.assign(h3d_shader_Buffers.prototype, {
	__class__: h3d_shader_Buffers
	,vertex: null
	,fragment: null
});
class h3d_shader_ColorAdd extends hxsl_Shader {
	constructor(color) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(color);
	}
	_hx_constructor(color) {
		if(color == null) {
			color = 0;
		}
		this.color__ = new h3d_Vector();
		super._hx_constructor();
		let _this = this.color__;
		_this.x = (color >> 16 & 255) / 255;
		_this.y = (color >> 8 & 255) / 255;
		_this.z = (color & 255) / 255;
		_this.w = (color >>> 24) / 255;
	}
	get_color() {
		return this.color__;
	}
	set_color(_v) {
		return this.color__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.color__;
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_ColorAdd.prototype);
		s.shader = this.shader;
		s.color__ = this.color__;
		return s;
	}
}
$hxClasses["h3d.shader.ColorAdd"] = h3d_shader_ColorAdd;
h3d_shader_ColorAdd.__name__ = "h3d.shader.ColorAdd";
h3d_shader_ColorAdd.__super__ = hxsl_Shader;
Object.assign(h3d_shader_ColorAdd.prototype, {
	__class__: h3d_shader_ColorAdd
	,color__: null
});
class h3d_shader_ColorKey extends hxsl_Shader {
	constructor(v) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(v);
	}
	_hx_constructor(v) {
		if(v == null) {
			v = 0;
		}
		this.colorKey__ = new h3d_Vector();
		super._hx_constructor();
		let _this = this.colorKey__;
		_this.x = (v >> 16 & 255) / 255;
		_this.y = (v >> 8 & 255) / 255;
		_this.z = (v & 255) / 255;
		_this.w = (v >>> 24) / 255;
	}
	get_colorKey() {
		return this.colorKey__;
	}
	set_colorKey(_v) {
		return this.colorKey__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.colorKey__;
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_ColorKey.prototype);
		s.shader = this.shader;
		s.colorKey__ = this.colorKey__;
		return s;
	}
}
$hxClasses["h3d.shader.ColorKey"] = h3d_shader_ColorKey;
h3d_shader_ColorKey.__name__ = "h3d.shader.ColorKey";
h3d_shader_ColorKey.__super__ = hxsl_Shader;
Object.assign(h3d_shader_ColorKey.prototype, {
	__class__: h3d_shader_ColorKey
	,colorKey__: null
});
class h3d_shader_ColorMatrix extends hxsl_Shader {
	constructor(m) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(m);
	}
	_hx_constructor(m) {
		this.enabled__ = true;
		this.matrix__ = new h3d_Matrix();
		super._hx_constructor();
		if(m != null) {
			this.matrix__.loadValues(m);
		} else {
			this.matrix__.identity();
		}
	}
	get_matrix() {
		return this.matrix__;
	}
	set_matrix(_v) {
		return this.matrix__ = _v;
	}
	get_enabled() {
		return this.enabled__;
	}
	set_enabled(_v) {
		this.constModified = true;
		return this.enabled__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.enabled__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.matrix__;
		case 1:
			return this.enabled__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_ColorMatrix.prototype);
		s.shader = this.shader;
		s.matrix__ = this.matrix__;
		s.enabled__ = this.enabled__;
		return s;
	}
}
$hxClasses["h3d.shader.ColorMatrix"] = h3d_shader_ColorMatrix;
h3d_shader_ColorMatrix.__name__ = "h3d.shader.ColorMatrix";
h3d_shader_ColorMatrix.__super__ = hxsl_Shader;
Object.assign(h3d_shader_ColorMatrix.prototype, {
	__class__: h3d_shader_ColorMatrix
	,matrix__: null
	,enabled__: null
});
class h3d_shader_CubeMap extends hxsl_Shader {
	constructor(texture,reflection) {
		if(reflection == null) {
			reflection = false;
		}
		super();
		this.texture__ = texture;
		this.constModified = true;
		this.reflection__ = reflection;
	}
	get_reflection() {
		return this.reflection__;
	}
	set_reflection(_v) {
		this.constModified = true;
		return this.reflection__ = _v;
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.reflection__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.reflection__;
		case 1:
			return this.texture__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_CubeMap.prototype);
		s.shader = this.shader;
		s.reflection__ = this.reflection__;
		s.texture__ = this.texture__;
		return s;
	}
}
$hxClasses["h3d.shader.CubeMap"] = h3d_shader_CubeMap;
h3d_shader_CubeMap.__name__ = "h3d.shader.CubeMap";
h3d_shader_CubeMap.__super__ = hxsl_Shader;
Object.assign(h3d_shader_CubeMap.prototype, {
	__class__: h3d_shader_CubeMap
	,reflection__: null
	,texture__: null
});
class h3d_shader_DirShadow extends hxsl_Shader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.poissonDisk__ = [];
		this.shadowBias__ = 0;
		this.shadowProj__ = new h3d_Matrix();
		this.shadowMapChannel__ = hxsl_Channel.Unknown;
		this.shadowRes__ = new h3d_Vector();
		this.pcfScale__ = 0;
		this.PCF_SAMPLES__ = 0;
		this.shadowPower__ = 0;
		super._hx_constructor();
		this.set_pcfQuality(1);
	}
	set_pcfQuality(q) {
		let _v;
		switch(q) {
		case 2:
			_v = [new h3d_Vector(-0.326,-0.406),new h3d_Vector(-0.840,-0.074),new h3d_Vector(-0.696,0.457),new h3d_Vector(-0.203,0.621),new h3d_Vector(0.962,-0.195),new h3d_Vector(0.473,-0.480),new h3d_Vector(0.519,0.767),new h3d_Vector(0.185,-0.893),new h3d_Vector(0.507,0.064),new h3d_Vector(0.896,0.412),new h3d_Vector(-0.322,-0.933),new h3d_Vector(-0.792,-0.598)];
			break;
		case 3:
			_v = [new h3d_Vector(-0.613392,0.617481),new h3d_Vector(0.170019,-0.040254),new h3d_Vector(-0.299417,0.791925),new h3d_Vector(0.645680,0.493210),new h3d_Vector(-0.651784,0.717887),new h3d_Vector(0.421003,0.027070),new h3d_Vector(-0.817194,-0.271096),new h3d_Vector(-0.705374,-0.668203),new h3d_Vector(0.977050,-0.108615),new h3d_Vector(0.063326,0.142369),new h3d_Vector(0.203528,0.214331),new h3d_Vector(-0.667531,0.326090),new h3d_Vector(-0.098422,-0.295755),new h3d_Vector(-0.885922,0.215369),new h3d_Vector(0.566637,0.605213),new h3d_Vector(0.039766,-0.396100),new h3d_Vector(0.751946,0.453352),new h3d_Vector(0.078707,-0.715323),new h3d_Vector(-0.075838,-0.529344),new h3d_Vector(0.724479,-0.580798),new h3d_Vector(0.222999,-0.215125),new h3d_Vector(-0.467574,-0.405438),new h3d_Vector(-0.248268,-0.814753),new h3d_Vector(0.354411,-0.887570),new h3d_Vector(0.175817,0.382366),new h3d_Vector(0.487472,-0.063082),new h3d_Vector(-0.084078,0.898312),new h3d_Vector(0.488876,-0.783441),new h3d_Vector(0.470016,0.217933),new h3d_Vector(-0.696890,-0.549791),new h3d_Vector(-0.149693,0.605762),new h3d_Vector(0.034211,0.979980),new h3d_Vector(0.503098,-0.308878),new h3d_Vector(-0.016205,-0.872921),new h3d_Vector(0.385784,-0.393902),new h3d_Vector(-0.146886,-0.859249),new h3d_Vector(0.643361,0.164098),new h3d_Vector(0.634388,-0.049471),new h3d_Vector(-0.688894,0.007843),new h3d_Vector(0.464034,-0.188818),new h3d_Vector(-0.440840,0.137486),new h3d_Vector(0.364483,0.511704),new h3d_Vector(0.034028,0.325968),new h3d_Vector(0.099094,-0.308023),new h3d_Vector(0.693960,-0.366253),new h3d_Vector(0.678884,-0.204688),new h3d_Vector(0.001801,0.780328),new h3d_Vector(0.145177,-0.898984),new h3d_Vector(0.062655,-0.611866),new h3d_Vector(0.315226,-0.604297),new h3d_Vector(-0.780145,0.486251),new h3d_Vector(-0.371868,0.882138),new h3d_Vector(0.200476,0.494430),new h3d_Vector(-0.494552,-0.711051),new h3d_Vector(0.612476,0.705252),new h3d_Vector(-0.578845,-0.768792),new h3d_Vector(-0.772454,-0.090976),new h3d_Vector(0.504440,0.372295),new h3d_Vector(0.155736,0.065157),new h3d_Vector(0.391522,0.849605),new h3d_Vector(-0.620106,-0.328104),new h3d_Vector(0.789239,-0.419965),new h3d_Vector(-0.545396,0.538133),new h3d_Vector(-0.178564,-0.596057)];
			break;
		default:
			_v = [new h3d_Vector(-0.942,-0.399),new h3d_Vector(0.945,-0.768),new h3d_Vector(-0.094,-0.929),new h3d_Vector(0.344,0.293)];
		}
		this.poissonDisk__ = _v;
		this.constModified = true;
		this.PCF_SAMPLES__ = this.poissonDisk__.length;
		return q;
	}
	get_enable() {
		return this.enable__;
	}
	set_enable(_v) {
		this.constModified = true;
		return this.enable__ = _v;
	}
	get_USE_ESM() {
		return this.USE_ESM__;
	}
	set_USE_ESM(_v) {
		this.constModified = true;
		return this.USE_ESM__ = _v;
	}
	get_shadowPower() {
		return this.shadowPower__;
	}
	set_shadowPower(_v) {
		return this.shadowPower__ = _v;
	}
	get_USE_PCF() {
		return this.USE_PCF__;
	}
	set_USE_PCF(_v) {
		this.constModified = true;
		return this.USE_PCF__ = _v;
	}
	get_PCF_SAMPLES() {
		return this.PCF_SAMPLES__;
	}
	set_PCF_SAMPLES(_v) {
		this.constModified = true;
		return this.PCF_SAMPLES__ = _v;
	}
	get_pcfScale() {
		return this.pcfScale__;
	}
	set_pcfScale(_v) {
		return this.pcfScale__ = _v;
	}
	get_shadowRes() {
		return this.shadowRes__;
	}
	set_shadowRes(_v) {
		return this.shadowRes__ = _v;
	}
	get_shadowMap() {
		return this.shadowMap__;
	}
	set_shadowMap(_v) {
		this.constModified = true;
		return this.shadowMap__ = _v;
	}
	get_shadowProj() {
		return this.shadowProj__;
	}
	set_shadowProj(_v) {
		return this.shadowProj__ = _v;
	}
	get_shadowBias() {
		return this.shadowBias__;
	}
	set_shadowBias(_v) {
		return this.shadowBias__ = _v;
	}
	get_poissonDisk() {
		return this.poissonDisk__;
	}
	set_poissonDisk(_v) {
		return this.poissonDisk__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.enable__) {
			this.constBits |= 1;
		}
		if(this.USE_ESM__) {
			this.constBits |= 2;
		}
		if(this.USE_PCF__) {
			this.constBits |= 4;
		}
		let v = this.PCF_SAMPLES__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("PCF_SAMPLES" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v << 3;
		if(this.shadowMap__ == null) {
			this.shadowMapChannel__ = hxsl_Channel.Unknown;
		} else if(this.shadowMapChannel__ == hxsl_Channel.Unknown) {
			if(this.shadowMap__.format == h3d_mat_Texture.nativeFormat) {
				this.shadowMapChannel__ = hxsl_Channel.PackedFloat;
			} else {
				throw haxe_Exception.thrown("shadowMap" + "Channel is not set");
			}
		}
		this.constBits |= (globals.allocChannelID(this.shadowMap__) << 3 | this.shadowMapChannel__._hx_index) << 11;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.enable__;
		case 1:
			return this.USE_ESM__;
		case 2:
			return this.shadowPower__;
		case 3:
			return this.USE_PCF__;
		case 4:
			return this.PCF_SAMPLES__;
		case 5:
			return this.pcfScale__;
		case 6:
			return this.shadowRes__;
		case 7:
			return this.shadowMap__;
		case 8:
			return this.shadowProj__;
		case 9:
			return this.shadowBias__;
		case 10:
			return this.poissonDisk__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 2:
			return this.shadowPower__;
		case 5:
			return this.pcfScale__;
		case 9:
			return this.shadowBias__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_DirShadow.prototype);
		s.shader = this.shader;
		s.enable__ = this.enable__;
		s.USE_ESM__ = this.USE_ESM__;
		s.shadowPower__ = this.shadowPower__;
		s.USE_PCF__ = this.USE_PCF__;
		s.PCF_SAMPLES__ = this.PCF_SAMPLES__;
		s.pcfScale__ = this.pcfScale__;
		s.shadowRes__ = this.shadowRes__;
		s.shadowMap__ = this.shadowMap__;
		s.shadowProj__ = this.shadowProj__;
		s.shadowBias__ = this.shadowBias__;
		s.poissonDisk__ = this.poissonDisk__;
		return s;
	}
}
$hxClasses["h3d.shader.DirShadow"] = h3d_shader_DirShadow;
h3d_shader_DirShadow.__name__ = "h3d.shader.DirShadow";
h3d_shader_DirShadow.__super__ = hxsl_Shader;
Object.assign(h3d_shader_DirShadow.prototype, {
	__class__: h3d_shader_DirShadow
	,enable__: null
	,USE_ESM__: null
	,shadowPower__: null
	,USE_PCF__: null
	,PCF_SAMPLES__: null
	,pcfScale__: null
	,shadowRes__: null
	,shadowMap__: null
	,shadowMapChannel__: null
	,shadowProj__: null
	,shadowBias__: null
	,poissonDisk__: null
});
class h3d_shader_FixedColor extends hxsl_Shader {
	constructor(color,alpha) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(color,alpha);
	}
	_hx_constructor(color,alpha) {
		if(alpha == null) {
			alpha = 1.;
		}
		if(color == null) {
			color = 0;
		}
		this.color__ = new h3d_Vector();
		super._hx_constructor();
		let _this = this.color__;
		_this.x = (color >> 16 & 255) / 255;
		_this.y = (color >> 8 & 255) / 255;
		_this.z = (color & 255) / 255;
		_this.w = (color >>> 24) / 255;
		this.color__.w = alpha;
		this.constModified = true;
		this.USE_ALPHA__ = true;
	}
	get_color() {
		return this.color__;
	}
	set_color(_v) {
		return this.color__ = _v;
	}
	get_USE_ALPHA() {
		return this.USE_ALPHA__;
	}
	set_USE_ALPHA(_v) {
		this.constModified = true;
		return this.USE_ALPHA__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.USE_ALPHA__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.color__;
		case 1:
			return this.USE_ALPHA__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_FixedColor.prototype);
		s.shader = this.shader;
		s.color__ = this.color__;
		s.USE_ALPHA__ = this.USE_ALPHA__;
		return s;
	}
}
$hxClasses["h3d.shader.FixedColor"] = h3d_shader_FixedColor;
h3d_shader_FixedColor.__name__ = "h3d.shader.FixedColor";
h3d_shader_FixedColor.__super__ = hxsl_Shader;
Object.assign(h3d_shader_FixedColor.prototype, {
	__class__: h3d_shader_FixedColor
	,color__: null
	,USE_ALPHA__: null
});
class h3d_shader_GenTexture extends h3d_shader_ScreenShader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.color__ = new h3d_Vector();
		this.mode__ = 0;
		super._hx_constructor();
	}
	get_mode() {
		return this.mode__;
	}
	set_mode(_v) {
		this.constModified = true;
		return this.mode__ = _v;
	}
	get_color() {
		return this.color__;
	}
	set_color(_v) {
		return this.color__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		let v = this.mode__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("mode" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.mode__;
		case 2:
			return this.color__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_GenTexture.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.mode__ = this.mode__;
		s.color__ = this.color__;
		return s;
	}
}
$hxClasses["h3d.shader.GenTexture"] = h3d_shader_GenTexture;
h3d_shader_GenTexture.__name__ = "h3d.shader.GenTexture";
h3d_shader_GenTexture.__super__ = h3d_shader_ScreenShader;
Object.assign(h3d_shader_GenTexture.prototype, {
	__class__: h3d_shader_GenTexture
	,mode__: null
	,color__: null
});
class h3d_shader_LineShader extends hxsl_Shader {
	constructor(width,lengthScale) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(width,lengthScale);
	}
	_hx_constructor(width,lengthScale) {
		if(lengthScale == null) {
			lengthScale = 1.;
		}
		if(width == null) {
			width = 1.5;
		}
		this.width__ = 0;
		this.lengthScale__ = 0;
		super._hx_constructor();
		this.width__ = width;
		this.lengthScale__ = lengthScale;
	}
	get_lengthScale() {
		return this.lengthScale__;
	}
	set_lengthScale(_v) {
		return this.lengthScale__ = _v;
	}
	get_width() {
		return this.width__;
	}
	set_width(_v) {
		return this.width__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.lengthScale__;
		case 1:
			return this.width__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 0:
			return this.lengthScale__;
		case 1:
			return this.width__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_LineShader.prototype);
		s.shader = this.shader;
		s.lengthScale__ = this.lengthScale__;
		s.width__ = this.width__;
		return s;
	}
}
$hxClasses["h3d.shader.LineShader"] = h3d_shader_LineShader;
h3d_shader_LineShader.__name__ = "h3d.shader.LineShader";
h3d_shader_LineShader.__super__ = hxsl_Shader;
Object.assign(h3d_shader_LineShader.prototype, {
	__class__: h3d_shader_LineShader
	,lengthScale__: null
	,width__: null
});
class h3d_shader_MinMaxShader extends h3d_shader_ScreenShader {
	constructor() {
		super();
	}
	get_texA() {
		return this.texA__;
	}
	set_texA(_v) {
		return this.texA__ = _v;
	}
	get_texB() {
		return this.texB__;
	}
	set_texB(_v) {
		return this.texB__ = _v;
	}
	get_isMax() {
		return this.isMax__;
	}
	set_isMax(_v) {
		this.constModified = true;
		return this.isMax__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.isMax__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texA__;
		case 2:
			return this.texB__;
		case 3:
			return this.isMax__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_MinMaxShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texA__ = this.texA__;
		s.texB__ = this.texB__;
		s.isMax__ = this.isMax__;
		return s;
	}
}
$hxClasses["h3d.shader.MinMaxShader"] = h3d_shader_MinMaxShader;
h3d_shader_MinMaxShader.__name__ = "h3d.shader.MinMaxShader";
h3d_shader_MinMaxShader.__super__ = h3d_shader_ScreenShader;
Object.assign(h3d_shader_MinMaxShader.prototype, {
	__class__: h3d_shader_MinMaxShader
	,texA__: null
	,texB__: null
	,isMax__: null
});
class h3d_shader_CubeMinMaxShader extends h3d_shader_ScreenShader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.mat__ = new h3d_Matrix();
		super._hx_constructor();
	}
	get_texA() {
		return this.texA__;
	}
	set_texA(_v) {
		return this.texA__ = _v;
	}
	get_texB() {
		return this.texB__;
	}
	set_texB(_v) {
		return this.texB__ = _v;
	}
	get_isMax() {
		return this.isMax__;
	}
	set_isMax(_v) {
		this.constModified = true;
		return this.isMax__ = _v;
	}
	get_mat() {
		return this.mat__;
	}
	set_mat(_v) {
		return this.mat__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.isMax__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texA__;
		case 2:
			return this.texB__;
		case 3:
			return this.isMax__;
		case 4:
			return this.mat__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 0) {
			return this.flipY__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_CubeMinMaxShader.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texA__ = this.texA__;
		s.texB__ = this.texB__;
		s.isMax__ = this.isMax__;
		s.mat__ = this.mat__;
		return s;
	}
}
$hxClasses["h3d.shader.CubeMinMaxShader"] = h3d_shader_CubeMinMaxShader;
h3d_shader_CubeMinMaxShader.__name__ = "h3d.shader.CubeMinMaxShader";
h3d_shader_CubeMinMaxShader.__super__ = h3d_shader_ScreenShader;
Object.assign(h3d_shader_CubeMinMaxShader.prototype, {
	__class__: h3d_shader_CubeMinMaxShader
	,texA__: null
	,texB__: null
	,isMax__: null
	,mat__: null
});
class h3d_shader_NormalMap extends hxsl_Shader {
	constructor(texture) {
		super();
		this.texture__ = texture;
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.texture__;
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_NormalMap.prototype);
		s.shader = this.shader;
		s.texture__ = this.texture__;
		return s;
	}
}
$hxClasses["h3d.shader.NormalMap"] = h3d_shader_NormalMap;
h3d_shader_NormalMap.__name__ = "h3d.shader.NormalMap";
h3d_shader_NormalMap.__super__ = hxsl_Shader;
Object.assign(h3d_shader_NormalMap.prototype, {
	__class__: h3d_shader_NormalMap
	,texture__: null
});
class h3d_shader_ParticleShader extends hxsl_Shader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.size__ = new h3d_Vector();
		this.rotationAxis__ = new h3d_Matrix();
		super._hx_constructor();
		this.rotationAxis__.initRotationAxis(new h3d_Vector(1,0,0),Math.PI / 2);
	}
	get_rotationAxis() {
		return this.rotationAxis__;
	}
	set_rotationAxis(_v) {
		return this.rotationAxis__ = _v;
	}
	get_size() {
		return this.size__;
	}
	set_size(_v) {
		return this.size__ = _v;
	}
	get_is3D() {
		return this.is3D__;
	}
	set_is3D(_v) {
		this.constModified = true;
		return this.is3D__ = _v;
	}
	get_isAbsolute() {
		return this.isAbsolute__;
	}
	set_isAbsolute(_v) {
		this.constModified = true;
		return this.isAbsolute__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.is3D__) {
			this.constBits |= 1;
		}
		if(this.isAbsolute__) {
			this.constBits |= 2;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.rotationAxis__;
		case 1:
			return this.size__;
		case 2:
			return this.is3D__;
		case 3:
			return this.isAbsolute__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_ParticleShader.prototype);
		s.shader = this.shader;
		s.rotationAxis__ = this.rotationAxis__;
		s.size__ = this.size__;
		s.is3D__ = this.is3D__;
		s.isAbsolute__ = this.isAbsolute__;
		return s;
	}
}
$hxClasses["h3d.shader.ParticleShader"] = h3d_shader_ParticleShader;
h3d_shader_ParticleShader.__name__ = "h3d.shader.ParticleShader";
h3d_shader_ParticleShader.__super__ = hxsl_Shader;
Object.assign(h3d_shader_ParticleShader.prototype, {
	__class__: h3d_shader_ParticleShader
	,rotationAxis__: null
	,size__: null
	,is3D__: null
	,isAbsolute__: null
});
class h3d_shader_Shadow extends hxsl_Shader {
	constructor() {
		super();
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
}
$hxClasses["h3d.shader.Shadow"] = h3d_shader_Shadow;
h3d_shader_Shadow.__name__ = "h3d.shader.Shadow";
h3d_shader_Shadow.__super__ = hxsl_Shader;
Object.assign(h3d_shader_Shadow.prototype, {
	__class__: h3d_shader_Shadow
});
class h3d_shader_SignedDistanceField extends hxsl_Shader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.smoothing__ = 0.041666666666666664;
		this.alphaCutoff__ = 0.5;
		this.autoSmoothing__ = false;
		this.channel__ = 0;
		super._hx_constructor();
	}
	get_channel() {
		return this.channel__;
	}
	set_channel(_v) {
		this.constModified = true;
		return this.channel__ = _v;
	}
	get_autoSmoothing() {
		return this.autoSmoothing__;
	}
	set_autoSmoothing(_v) {
		this.constModified = true;
		return this.autoSmoothing__ = _v;
	}
	get_alphaCutoff() {
		return this.alphaCutoff__;
	}
	set_alphaCutoff(_v) {
		return this.alphaCutoff__ = _v;
	}
	get_smoothing() {
		return this.smoothing__;
	}
	set_smoothing(_v) {
		return this.smoothing__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		let v = this.channel__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("channel" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.autoSmoothing__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.channel__;
		case 1:
			return this.autoSmoothing__;
		case 2:
			return this.alphaCutoff__;
		case 3:
			return this.smoothing__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 2:
			return this.alphaCutoff__;
		case 3:
			return this.smoothing__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_SignedDistanceField.prototype);
		s.shader = this.shader;
		s.channel__ = this.channel__;
		s.autoSmoothing__ = this.autoSmoothing__;
		s.alphaCutoff__ = this.alphaCutoff__;
		s.smoothing__ = this.smoothing__;
		return s;
	}
}
$hxClasses["h3d.shader.SignedDistanceField"] = h3d_shader_SignedDistanceField;
h3d_shader_SignedDistanceField.__name__ = "h3d.shader.SignedDistanceField";
h3d_shader_SignedDistanceField.__super__ = hxsl_Shader;
Object.assign(h3d_shader_SignedDistanceField.prototype, {
	__class__: h3d_shader_SignedDistanceField
	,channel__: null
	,autoSmoothing__: null
	,alphaCutoff__: null
	,smoothing__: null
});
class h3d_shader_SkinBase extends hxsl_Shader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.bonesMatrixes__ = [];
		this.fourBonesByVertex__ = false;
		this.MaxBones__ = 0;
		super._hx_constructor();
		this.constModified = true;
		this.MaxBones__ = 34;
	}
	get_MaxBones() {
		return this.MaxBones__;
	}
	set_MaxBones(_v) {
		this.constModified = true;
		return this.MaxBones__ = _v;
	}
	get_fourBonesByVertex() {
		return this.fourBonesByVertex__;
	}
	set_fourBonesByVertex(_v) {
		this.constModified = true;
		return this.fourBonesByVertex__ = _v;
	}
	get_bonesMatrixes() {
		return this.bonesMatrixes__;
	}
	set_bonesMatrixes(_v) {
		return this.bonesMatrixes__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		let v = this.MaxBones__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("MaxBones" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.fourBonesByVertex__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.MaxBones__;
		case 1:
			return this.fourBonesByVertex__;
		case 2:
			return this.bonesMatrixes__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_SkinBase.prototype);
		s.shader = this.shader;
		s.MaxBones__ = this.MaxBones__;
		s.fourBonesByVertex__ = this.fourBonesByVertex__;
		s.bonesMatrixes__ = this.bonesMatrixes__;
		return s;
	}
}
$hxClasses["h3d.shader.SkinBase"] = h3d_shader_SkinBase;
h3d_shader_SkinBase.__name__ = "h3d.shader.SkinBase";
h3d_shader_SkinBase.__super__ = hxsl_Shader;
Object.assign(h3d_shader_SkinBase.prototype, {
	__class__: h3d_shader_SkinBase
	,MaxBones__: null
	,fourBonesByVertex__: null
	,bonesMatrixes__: null
});
class h3d_shader_Skin extends h3d_shader_SkinBase {
	constructor() {
		super();
	}
	updateConstants(globals) {
		this.constBits = 0;
		let v = this.MaxBones__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("MaxBones" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.fourBonesByVertex__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.MaxBones__;
		case 1:
			return this.fourBonesByVertex__;
		case 2:
			return this.bonesMatrixes__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_Skin.prototype);
		s.shader = this.shader;
		s.MaxBones__ = this.MaxBones__;
		s.fourBonesByVertex__ = this.fourBonesByVertex__;
		s.bonesMatrixes__ = this.bonesMatrixes__;
		return s;
	}
}
$hxClasses["h3d.shader.Skin"] = h3d_shader_Skin;
h3d_shader_Skin.__name__ = "h3d.shader.Skin";
h3d_shader_Skin.__super__ = h3d_shader_SkinBase;
Object.assign(h3d_shader_Skin.prototype, {
	__class__: h3d_shader_Skin
});
class h3d_shader_SkinTangent extends h3d_shader_SkinBase {
	constructor() {
		super();
	}
	updateConstants(globals) {
		this.constBits = 0;
		let v = this.MaxBones__;
		if(v >>> 8 != 0) {
			throw haxe_Exception.thrown("MaxBones" + " is out of range " + v + ">" + 255);
		}
		this.constBits |= v;
		if(this.fourBonesByVertex__) {
			this.constBits |= 256;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.MaxBones__;
		case 1:
			return this.fourBonesByVertex__;
		case 2:
			return this.bonesMatrixes__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_SkinTangent.prototype);
		s.shader = this.shader;
		s.MaxBones__ = this.MaxBones__;
		s.fourBonesByVertex__ = this.fourBonesByVertex__;
		s.bonesMatrixes__ = this.bonesMatrixes__;
		return s;
	}
}
$hxClasses["h3d.shader.SkinTangent"] = h3d_shader_SkinTangent;
h3d_shader_SkinTangent.__name__ = "h3d.shader.SkinTangent";
h3d_shader_SkinTangent.__super__ = h3d_shader_SkinBase;
Object.assign(h3d_shader_SkinTangent.prototype, {
	__class__: h3d_shader_SkinTangent
});
class h3d_shader_SpecularTexture extends hxsl_Shader {
	constructor(tex) {
		super();
		this.texture__ = tex;
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.texture__;
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_SpecularTexture.prototype);
		s.shader = this.shader;
		s.texture__ = this.texture__;
		return s;
	}
}
$hxClasses["h3d.shader.SpecularTexture"] = h3d_shader_SpecularTexture;
h3d_shader_SpecularTexture.__name__ = "h3d.shader.SpecularTexture";
h3d_shader_SpecularTexture.__super__ = hxsl_Shader;
Object.assign(h3d_shader_SpecularTexture.prototype, {
	__class__: h3d_shader_SpecularTexture
	,texture__: null
});
class h3d_shader_Texture extends hxsl_Shader {
	constructor(tex) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(tex);
	}
	_hx_constructor(tex) {
		this.killAlphaThreshold__ = 0;
		super._hx_constructor();
		this.texture__ = tex;
		this.killAlphaThreshold__ = h3d_mat_Defaults.defaultKillAlphaThreshold;
	}
	get_additive() {
		return this.additive__;
	}
	set_additive(_v) {
		this.constModified = true;
		return this.additive__ = _v;
	}
	get_killAlpha() {
		return this.killAlpha__;
	}
	set_killAlpha(_v) {
		this.constModified = true;
		return this.killAlpha__ = _v;
	}
	get_specularAlpha() {
		return this.specularAlpha__;
	}
	set_specularAlpha(_v) {
		this.constModified = true;
		return this.specularAlpha__ = _v;
	}
	get_killAlphaThreshold() {
		return this.killAlphaThreshold__;
	}
	set_killAlphaThreshold(_v) {
		return this.killAlphaThreshold__ = _v;
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.additive__) {
			this.constBits |= 1;
		}
		if(this.killAlpha__) {
			this.constBits |= 2;
		}
		if(this.specularAlpha__) {
			this.constBits |= 4;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.additive__;
		case 1:
			return this.killAlpha__;
		case 2:
			return this.specularAlpha__;
		case 3:
			return this.killAlphaThreshold__;
		case 4:
			return this.texture__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 3) {
			return this.killAlphaThreshold__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_Texture.prototype);
		s.shader = this.shader;
		s.additive__ = this.additive__;
		s.killAlpha__ = this.killAlpha__;
		s.specularAlpha__ = this.specularAlpha__;
		s.killAlphaThreshold__ = this.killAlphaThreshold__;
		s.texture__ = this.texture__;
		return s;
	}
}
$hxClasses["h3d.shader.Texture"] = h3d_shader_Texture;
h3d_shader_Texture.__name__ = "h3d.shader.Texture";
h3d_shader_Texture.__super__ = hxsl_Shader;
Object.assign(h3d_shader_Texture.prototype, {
	__class__: h3d_shader_Texture
	,additive__: null
	,killAlpha__: null
	,specularAlpha__: null
	,killAlphaThreshold__: null
	,texture__: null
});
class h3d_shader_UVAnim extends hxsl_Shader {
	constructor(frameDivision,totalFrames,speed) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(frameDivision,totalFrames,speed);
	}
	_hx_constructor(frameDivision,totalFrames,speed) {
		if(speed == null) {
			speed = 1.;
		}
		if(totalFrames == null) {
			totalFrames = -1;
		}
		this.startTime__ = 0;
		this.totalFrames__ = 0;
		this.frameDivision__ = 0;
		this.speed__ = 0;
		super._hx_constructor();
		if(totalFrames < 0) {
			totalFrames = frameDivision;
		}
		this.frameDivision__ = frameDivision;
		this.totalFrames__ = totalFrames;
		this.speed__ = speed;
		this.constModified = true;
		this.loop__ = true;
	}
	get_speed() {
		return this.speed__;
	}
	set_speed(_v) {
		return this.speed__ = _v;
	}
	get_frameDivision() {
		return this.frameDivision__;
	}
	set_frameDivision(_v) {
		return this.frameDivision__ = _v;
	}
	get_totalFrames() {
		return this.totalFrames__;
	}
	set_totalFrames(_v) {
		return this.totalFrames__ = _v;
	}
	get_startTime() {
		return this.startTime__;
	}
	set_startTime(_v) {
		return this.startTime__ = _v;
	}
	get_loop() {
		return this.loop__;
	}
	set_loop(_v) {
		this.constModified = true;
		return this.loop__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.loop__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.speed__;
		case 1:
			return this.frameDivision__;
		case 2:
			return this.totalFrames__;
		case 3:
			return this.startTime__;
		case 4:
			return this.loop__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 0:
			return this.speed__;
		case 1:
			return this.frameDivision__;
		case 2:
			return this.totalFrames__;
		case 3:
			return this.startTime__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_UVAnim.prototype);
		s.shader = this.shader;
		s.speed__ = this.speed__;
		s.frameDivision__ = this.frameDivision__;
		s.totalFrames__ = this.totalFrames__;
		s.startTime__ = this.startTime__;
		s.loop__ = this.loop__;
		return s;
	}
}
$hxClasses["h3d.shader.UVAnim"] = h3d_shader_UVAnim;
h3d_shader_UVAnim.__name__ = "h3d.shader.UVAnim";
h3d_shader_UVAnim.__super__ = hxsl_Shader;
Object.assign(h3d_shader_UVAnim.prototype, {
	__class__: h3d_shader_UVAnim
	,speed__: null
	,frameDivision__: null
	,totalFrames__: null
	,startTime__: null
	,loop__: null
});
class h3d_shader_UVDelta extends hxsl_Shader {
	constructor(dx,dy,sx,sy) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(dx,dy,sx,sy);
	}
	_hx_constructor(dx,dy,sx,sy) {
		if(sy == null) {
			sy = 1.;
		}
		if(sx == null) {
			sx = 1.;
		}
		if(dy == null) {
			dy = 0.;
		}
		if(dx == null) {
			dx = 0.;
		}
		this.uvScale__ = new h3d_Vector();
		this.uvDelta__ = new h3d_Vector();
		super._hx_constructor();
		let _this = this.uvDelta__;
		let x = dx;
		let y = dy;
		if(dy == null) {
			y = 0.;
		}
		if(dx == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
		let _this1 = this.uvScale__;
		let x1 = sx;
		let y1 = sy;
		if(sy == null) {
			y1 = 0.;
		}
		if(sx == null) {
			x1 = 0.;
		}
		_this1.x = x1;
		_this1.y = y1;
		_this1.z = 0.;
		_this1.w = 1.;
	}
	get_uvDelta() {
		return this.uvDelta__;
	}
	set_uvDelta(_v) {
		return this.uvDelta__ = _v;
	}
	get_uvScale() {
		return this.uvScale__;
	}
	set_uvScale(_v) {
		return this.uvScale__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.uvDelta__;
		case 1:
			return this.uvScale__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_UVDelta.prototype);
		s.shader = this.shader;
		s.uvDelta__ = this.uvDelta__;
		s.uvScale__ = this.uvScale__;
		return s;
	}
}
$hxClasses["h3d.shader.UVDelta"] = h3d_shader_UVDelta;
h3d_shader_UVDelta.__name__ = "h3d.shader.UVDelta";
h3d_shader_UVDelta.__super__ = hxsl_Shader;
Object.assign(h3d_shader_UVDelta.prototype, {
	__class__: h3d_shader_UVDelta
	,uvDelta__: null
	,uvScale__: null
});
class h3d_shader_UVScroll extends hxsl_Shader {
	constructor(vx,vy) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(vx,vy);
	}
	_hx_constructor(vx,vy) {
		if(vy == null) {
			vy = 0.;
		}
		if(vx == null) {
			vx = 0.;
		}
		this.uvSpeed__ = new h3d_Vector();
		super._hx_constructor();
		let _this = this.uvSpeed__;
		let x = vx;
		let y = vy;
		if(vy == null) {
			y = 0.;
		}
		if(vx == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
	}
	get_uvSpeed() {
		return this.uvSpeed__;
	}
	set_uvSpeed(_v) {
		return this.uvSpeed__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.uvSpeed__;
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_UVScroll.prototype);
		s.shader = this.shader;
		s.uvSpeed__ = this.uvSpeed__;
		return s;
	}
}
$hxClasses["h3d.shader.UVScroll"] = h3d_shader_UVScroll;
h3d_shader_UVScroll.__name__ = "h3d.shader.UVScroll";
h3d_shader_UVScroll.__super__ = hxsl_Shader;
Object.assign(h3d_shader_UVScroll.prototype, {
	__class__: h3d_shader_UVScroll
	,uvSpeed__: null
});
class h3d_shader_VertexColorAlpha extends hxsl_Shader {
	constructor() {
		super();
	}
	get_additive() {
		return this.additive__;
	}
	set_additive(_v) {
		this.constModified = true;
		return this.additive__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.additive__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.additive__;
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_VertexColorAlpha.prototype);
		s.shader = this.shader;
		s.additive__ = this.additive__;
		return s;
	}
}
$hxClasses["h3d.shader.VertexColorAlpha"] = h3d_shader_VertexColorAlpha;
h3d_shader_VertexColorAlpha.__name__ = "h3d.shader.VertexColorAlpha";
h3d_shader_VertexColorAlpha.__super__ = hxsl_Shader;
Object.assign(h3d_shader_VertexColorAlpha.prototype, {
	__class__: h3d_shader_VertexColorAlpha
	,additive__: null
});
class h3d_shader_VolumeDecal extends hxsl_Shader {
	constructor(objectWidth,objectHeight) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(objectWidth,objectHeight);
	}
	_hx_constructor(objectWidth,objectHeight) {
		this.isCentered__ = true;
		this.tangent__ = new h3d_Vector();
		this.normal__ = new h3d_Vector();
		this.scale__ = new h3d_Vector();
		super._hx_constructor();
		let _this = this.normal__;
		_this.x = 0;
		_this.y = 0;
		_this.z = 1;
		_this.w = 1.;
		let _this1 = this.tangent__;
		_this1.x = 1;
		_this1.y = 0;
		_this1.z = 0;
		_this1.w = 1.;
		let _this2 = this.scale__;
		let x = 1 / objectWidth;
		let y = 1 / objectHeight;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this2.x = x;
		_this2.y = y;
		_this2.z = 0.;
		_this2.w = 1.;
	}
	get_scale() {
		return this.scale__;
	}
	set_scale(_v) {
		return this.scale__ = _v;
	}
	get_normal() {
		return this.normal__;
	}
	set_normal(_v) {
		return this.normal__ = _v;
	}
	get_tangent() {
		return this.tangent__;
	}
	set_tangent(_v) {
		return this.tangent__ = _v;
	}
	get_isCentered() {
		return this.isCentered__;
	}
	set_isCentered(_v) {
		this.constModified = true;
		return this.isCentered__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.isCentered__) {
			this.constBits |= 64;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.scale__;
		case 1:
			return this.normal__;
		case 2:
			return this.tangent__;
		case 3:
			return this.isCentered__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_VolumeDecal.prototype);
		s.shader = this.shader;
		s.scale__ = this.scale__;
		s.normal__ = this.normal__;
		s.tangent__ = this.tangent__;
		s.isCentered__ = this.isCentered__;
		return s;
	}
}
$hxClasses["h3d.shader.VolumeDecal"] = h3d_shader_VolumeDecal;
h3d_shader_VolumeDecal.__name__ = "h3d.shader.VolumeDecal";
h3d_shader_VolumeDecal.__super__ = hxsl_Shader;
Object.assign(h3d_shader_VolumeDecal.prototype, {
	__class__: h3d_shader_VolumeDecal
	,scale__: null
	,normal__: null
	,tangent__: null
	,isCentered__: null
});
class h3d_shader_pbr_PropsValues extends hxsl_Shader {
	constructor(metalness,roughness,occlusion,emissive,custom1,custom2) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(metalness,roughness,occlusion,emissive,custom1,custom2);
	}
	_hx_constructor(metalness,roughness,occlusion,emissive,custom1,custom2) {
		if(custom2 == null) {
			custom2 = 0.;
		}
		if(custom1 == null) {
			custom1 = 0.;
		}
		if(emissive == null) {
			emissive = 0.;
		}
		if(occlusion == null) {
			occlusion = 1.;
		}
		if(roughness == null) {
			roughness = 1.;
		}
		if(metalness == null) {
			metalness = 0.;
		}
		this.custom2Value__ = 0;
		this.custom1Value__ = 0;
		this.emissiveValue__ = 0;
		this.occlusionValue__ = 0;
		this.roughnessValue__ = 0;
		this.metalnessValue__ = 0;
		super._hx_constructor();
		this.metalnessValue__ = metalness;
		this.roughnessValue__ = roughness;
		this.occlusionValue__ = occlusion;
		this.emissiveValue__ = emissive;
		this.custom1Value__ = custom1;
		this.custom2Value__ = custom2;
	}
	get_metalnessValue() {
		return this.metalnessValue__;
	}
	set_metalnessValue(_v) {
		return this.metalnessValue__ = _v;
	}
	get_roughnessValue() {
		return this.roughnessValue__;
	}
	set_roughnessValue(_v) {
		return this.roughnessValue__ = _v;
	}
	get_occlusionValue() {
		return this.occlusionValue__;
	}
	set_occlusionValue(_v) {
		return this.occlusionValue__ = _v;
	}
	get_emissiveValue() {
		return this.emissiveValue__;
	}
	set_emissiveValue(_v) {
		return this.emissiveValue__ = _v;
	}
	get_custom1Value() {
		return this.custom1Value__;
	}
	set_custom1Value(_v) {
		return this.custom1Value__ = _v;
	}
	get_custom2Value() {
		return this.custom2Value__;
	}
	set_custom2Value(_v) {
		return this.custom2Value__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.metalnessValue__;
		case 1:
			return this.roughnessValue__;
		case 2:
			return this.occlusionValue__;
		case 3:
			return this.emissiveValue__;
		case 4:
			return this.custom1Value__;
		case 5:
			return this.custom2Value__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 0:
			return this.metalnessValue__;
		case 1:
			return this.roughnessValue__;
		case 2:
			return this.occlusionValue__;
		case 3:
			return this.emissiveValue__;
		case 4:
			return this.custom1Value__;
		case 5:
			return this.custom2Value__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(h3d_shader_pbr_PropsValues.prototype);
		s.shader = this.shader;
		s.metalnessValue__ = this.metalnessValue__;
		s.roughnessValue__ = this.roughnessValue__;
		s.occlusionValue__ = this.occlusionValue__;
		s.emissiveValue__ = this.emissiveValue__;
		s.custom1Value__ = this.custom1Value__;
		s.custom2Value__ = this.custom2Value__;
		return s;
	}
}
$hxClasses["h3d.shader.pbr.PropsValues"] = h3d_shader_pbr_PropsValues;
h3d_shader_pbr_PropsValues.__name__ = "h3d.shader.pbr.PropsValues";
h3d_shader_pbr_PropsValues.__super__ = hxsl_Shader;
Object.assign(h3d_shader_pbr_PropsValues.prototype, {
	__class__: h3d_shader_pbr_PropsValues
	,metalnessValue__: null
	,roughnessValue__: null
	,occlusionValue__: null
	,emissiveValue__: null
	,custom1Value__: null
	,custom2Value__: null
});
class haxe_IMap {
}
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = "haxe.IMap";
haxe_IMap.__isInterface__ = true;
Object.assign(haxe_IMap.prototype, {
	__class__: haxe_IMap
	,get: null
	,set: null
	,exists: null
	,remove: null
	,keys: null
	,keyValueIterator: null
});
class haxe_EntryPoint {
	static processEvents() {
		while(true) {
			let f = haxe_EntryPoint.pending.shift();
			if(f == null) {
				break;
			}
			f();
		}
		let time = haxe_MainLoop.tick();
		if(!haxe_MainLoop.hasEvents() && haxe_EntryPoint.threadCount == 0) {
			return -1;
		}
		return time;
	}
	static run() {
		let nextTick = haxe_EntryPoint.processEvents();
		if(typeof(window) != "undefined") {
			let $window = window;
			let rqf = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame;
			if(rqf != null) {
				rqf(haxe_EntryPoint.run);
			} else if(nextTick >= 0) {
				setTimeout(haxe_EntryPoint.run,nextTick * 1000);
			}
		} else if(nextTick >= 0) {
			setTimeout(haxe_EntryPoint.run,nextTick * 1000);
		}
	}
}
$hxClasses["haxe.EntryPoint"] = haxe_EntryPoint;
haxe_EntryPoint.__name__ = "haxe.EntryPoint";
class haxe_Int32 {
	static ucompare(a,b) {
		if(a < 0) {
			if(b < 0) {
				return ~b - ~a | 0;
			} else {
				return 1;
			}
		}
		if(b < 0) {
			return -1;
		} else {
			return a - b | 0;
		}
	}
}
class haxe_Int64 {
	static divMod(dividend,divisor) {
		if(divisor.high == 0) {
			switch(divisor.low) {
			case 0:
				throw haxe_Exception.thrown("divide by zero");
			case 1:
				return { quotient : new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low), modulus : new haxe__$Int64__$_$_$Int64(0,0)};
			}
		}
		let divSign = dividend.high < 0 != divisor.high < 0;
		let modulus;
		if(dividend.high < 0) {
			let high = ~dividend.high;
			let low = ~dividend.low + 1 | 0;
			if(low == 0) {
				++high;
				high = high | 0;
			}
			modulus = new haxe__$Int64__$_$_$Int64(high,low);
		} else {
			modulus = new haxe__$Int64__$_$_$Int64(dividend.high,dividend.low);
		}
		if(divisor.high < 0) {
			let high = ~divisor.high;
			let low = ~divisor.low + 1 | 0;
			if(low == 0) {
				++high;
				high = high | 0;
			}
			divisor = new haxe__$Int64__$_$_$Int64(high,low);
		}
		let quotient = new haxe__$Int64__$_$_$Int64(0,0);
		let mask = new haxe__$Int64__$_$_$Int64(0,1);
		while(!(divisor.high < 0)) {
			let v = haxe_Int32.ucompare(divisor.high,modulus.high);
			let cmp = v != 0 ? v : haxe_Int32.ucompare(divisor.low,modulus.low);
			divisor = new haxe__$Int64__$_$_$Int64(divisor.high << 1 | divisor.low >>> 31,divisor.low << 1);
			mask = new haxe__$Int64__$_$_$Int64(mask.high << 1 | mask.low >>> 31,mask.low << 1);
			if(cmp >= 0) {
				break;
			}
		}
		while(true) {
			let b_high = 0;
			let b_low = 0;
			if(!(mask.high != b_high || mask.low != b_low)) {
				break;
			}
			let v = haxe_Int32.ucompare(modulus.high,divisor.high);
			if((v != 0 ? v : haxe_Int32.ucompare(modulus.low,divisor.low)) >= 0) {
				quotient = new haxe__$Int64__$_$_$Int64(quotient.high | mask.high,quotient.low | mask.low);
				let high = modulus.high - divisor.high | 0;
				let low = modulus.low - divisor.low | 0;
				if(haxe_Int32.ucompare(modulus.low,divisor.low) < 0) {
					--high;
					high = high | 0;
				}
				modulus = new haxe__$Int64__$_$_$Int64(high,low);
			}
			mask = new haxe__$Int64__$_$_$Int64(mask.high >>> 1,mask.high << 31 | mask.low >>> 1);
			divisor = new haxe__$Int64__$_$_$Int64(divisor.high >>> 1,divisor.high << 31 | divisor.low >>> 1);
		}
		if(divSign) {
			let high = ~quotient.high;
			let low = ~quotient.low + 1 | 0;
			if(low == 0) {
				++high;
				high = high | 0;
			}
			quotient = new haxe__$Int64__$_$_$Int64(high,low);
		}
		if(dividend.high < 0) {
			let high = ~modulus.high;
			let low = ~modulus.low + 1 | 0;
			if(low == 0) {
				++high;
				high = high | 0;
			}
			modulus = new haxe__$Int64__$_$_$Int64(high,low);
		}
		return { quotient : quotient, modulus : modulus};
	}
}
class haxe__$Int64__$_$_$Int64 {
	constructor(high,low) {
		this.high = high;
		this.low = low;
	}
}
$hxClasses["haxe._Int64.___Int64"] = haxe__$Int64__$_$_$Int64;
haxe__$Int64__$_$_$Int64.__name__ = "haxe._Int64.___Int64";
Object.assign(haxe__$Int64__$_$_$Int64.prototype, {
	__class__: haxe__$Int64__$_$_$Int64
	,high: null
	,low: null
});
class haxe_Int64Helper {
	static fromFloat(f) {
		if(isNaN(f) || !isFinite(f)) {
			throw haxe_Exception.thrown("Number is NaN or Infinite");
		}
		let noFractions = f - f % 1;
		if(noFractions > 9007199254740991) {
			throw haxe_Exception.thrown("Conversion overflow");
		}
		if(noFractions < -9007199254740991) {
			throw haxe_Exception.thrown("Conversion underflow");
		}
		let result = new haxe__$Int64__$_$_$Int64(0,0);
		let neg = noFractions < 0;
		let rest = neg ? -noFractions : noFractions;
		let i = 0;
		while(rest >= 1) {
			let curr = rest % 2;
			rest /= 2;
			if(curr >= 1) {
				let a_high = 0;
				let a_low = 1;
				let b = i;
				b &= 63;
				let b1 = b == 0 ? new haxe__$Int64__$_$_$Int64(a_high,a_low) : b < 32 ? new haxe__$Int64__$_$_$Int64(a_high << b | a_low >>> 32 - b,a_low << b) : new haxe__$Int64__$_$_$Int64(a_low << b - 32,0);
				let high = result.high + b1.high | 0;
				let low = result.low + b1.low | 0;
				if(haxe_Int32.ucompare(low,result.low) < 0) {
					++high;
					high = high | 0;
				}
				result = new haxe__$Int64__$_$_$Int64(high,low);
			}
			++i;
		}
		if(neg) {
			let high = ~result.high;
			let low = ~result.low + 1 | 0;
			if(low == 0) {
				++high;
				high = high | 0;
			}
			result = new haxe__$Int64__$_$_$Int64(high,low);
		}
		return result;
	}
}
$hxClasses["haxe.Int64Helper"] = haxe_Int64Helper;
haxe_Int64Helper.__name__ = "haxe.Int64Helper";
class haxe_Log {
	static formatOutput(v,infos) {
		let str = Std.string(v);
		if(infos == null) {
			return str;
		}
		let pstr = infos.fileName + ":" + infos.lineNumber;
		if(infos.customParams != null) {
			let _g = 0;
			let _g1 = infos.customParams;
			while(_g < _g1.length) {
				let v = _g1[_g];
				++_g;
				str += ", " + Std.string(v);
			}
		}
		return pstr + ": " + str;
	}
	static trace(v,infos) {
		let str = haxe_Log.formatOutput(v,infos);
		if(typeof(console) != "undefined" && console.log != null) {
			console.log(str);
		}
	}
}
$hxClasses["haxe.Log"] = haxe_Log;
haxe_Log.__name__ = "haxe.Log";
class haxe_MainEvent {
	constructor(f,p) {
		this.isBlocking = true;
		this.f = f;
		this.priority = p;
		this.nextRun = -Infinity;
	}
}
$hxClasses["haxe.MainEvent"] = haxe_MainEvent;
haxe_MainEvent.__name__ = "haxe.MainEvent";
Object.assign(haxe_MainEvent.prototype, {
	__class__: haxe_MainEvent
	,f: null
	,prev: null
	,next: null
	,isBlocking: null
	,nextRun: null
	,priority: null
});
class haxe_MainLoop {
	static hasEvents() {
		let p = haxe_MainLoop.pending;
		while(p != null) {
			if(p.isBlocking) {
				return true;
			}
			p = p.next;
		}
		return false;
	}
	static add(f,priority) {
		if(priority == null) {
			priority = 0;
		}
		if(f == null) {
			throw haxe_Exception.thrown("Event function is null");
		}
		let e = new haxe_MainEvent(f,priority);
		let head = haxe_MainLoop.pending;
		if(head != null) {
			head.prev = e;
		}
		e.next = head;
		haxe_MainLoop.pending = e;
		return e;
	}
	static sortEvents() {
		let list = haxe_MainLoop.pending;
		if(list == null) {
			return;
		}
		let insize = 1;
		let nmerges;
		let psize = 0;
		let qsize = 0;
		let p;
		let q;
		let e;
		let tail;
		while(true) {
			p = list;
			list = null;
			tail = null;
			nmerges = 0;
			while(p != null) {
				++nmerges;
				q = p;
				psize = 0;
				let _g = 0;
				let _g1 = insize;
				while(_g < _g1) {
					++_g;
					++psize;
					q = q.next;
					if(q == null) {
						break;
					}
				}
				qsize = insize;
				while(psize > 0 || qsize > 0 && q != null) {
					if(psize == 0) {
						e = q;
						q = q.next;
						--qsize;
					} else if(qsize == 0 || q == null || (p.priority > q.priority || p.priority == q.priority && p.nextRun <= q.nextRun)) {
						e = p;
						p = p.next;
						--psize;
					} else {
						e = q;
						q = q.next;
						--qsize;
					}
					if(tail != null) {
						tail.next = e;
					} else {
						list = e;
					}
					e.prev = tail;
					tail = e;
				}
				p = q;
			}
			tail.next = null;
			if(nmerges <= 1) {
				break;
			}
			insize *= 2;
		}
		list.prev = null;
		haxe_MainLoop.pending = list;
	}
	static tick() {
		haxe_MainLoop.sortEvents();
		let e = haxe_MainLoop.pending;
		let now = HxOverrides.now() / 1000;
		let wait = 1e9;
		while(e != null) {
			let next = e.next;
			let wt = e.nextRun - now;
			if(wt <= 0) {
				wait = 0;
				if(e.f != null) {
					e.f();
				}
			} else if(wait > wt) {
				wait = wt;
			}
			e = next;
		}
		return wait;
	}
}
$hxClasses["haxe.MainLoop"] = haxe_MainLoop;
haxe_MainLoop.__name__ = "haxe.MainLoop";
class haxe_Timer {
	constructor(time_ms) {
		let me = this;
		this.id = setInterval(function() {
			me.run();
		},time_ms);
	}
	stop() {
		if(this.id == null) {
			return;
		}
		clearInterval(this.id);
		this.id = null;
	}
	run() {
	}
	static delay(f,time_ms) {
		let t = new haxe_Timer(time_ms);
		t.run = function() {
			t.stop();
			f();
		};
		return t;
	}
}
$hxClasses["haxe.Timer"] = haxe_Timer;
haxe_Timer.__name__ = "haxe.Timer";
Object.assign(haxe_Timer.prototype, {
	__class__: haxe_Timer
	,id: null
});
class haxe__$Unserializer_DefaultResolver {
	constructor() {
	}
	resolveClass(name) {
		return $hxClasses[name];
	}
	resolveEnum(name) {
		return $hxEnums[name];
	}
}
$hxClasses["haxe._Unserializer.DefaultResolver"] = haxe__$Unserializer_DefaultResolver;
haxe__$Unserializer_DefaultResolver.__name__ = "haxe._Unserializer.DefaultResolver";
Object.assign(haxe__$Unserializer_DefaultResolver.prototype, {
	__class__: haxe__$Unserializer_DefaultResolver
});
class haxe_Unserializer {
	constructor(buf) {
		this.buf = buf;
		this.length = this.buf.length;
		this.pos = 0;
		this.scache = [];
		this.cache = [];
		let r = haxe_Unserializer.DEFAULT_RESOLVER;
		if(r == null) {
			r = new haxe__$Unserializer_DefaultResolver();
			haxe_Unserializer.DEFAULT_RESOLVER = r;
		}
		this.resolver = r;
	}
	readDigits() {
		let k = 0;
		let s = false;
		let fpos = this.pos;
		while(true) {
			let c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c == 45) {
				if(this.pos != fpos) {
					break;
				}
				s = true;
				this.pos++;
				continue;
			}
			if(c < 48 || c > 57) {
				break;
			}
			k = k * 10 + (c - 48);
			this.pos++;
		}
		if(s) {
			k *= -1;
		}
		return k;
	}
	readFloat() {
		let p1 = this.pos;
		while(true) {
			let c = this.buf.charCodeAt(this.pos);
			if(c != c) {
				break;
			}
			if(c >= 43 && c < 58 || c == 101 || c == 69) {
				this.pos++;
			} else {
				break;
			}
		}
		return parseFloat(HxOverrides.substr(this.buf,p1,this.pos - p1));
	}
	unserializeObject(o) {
		while(true) {
			if(this.pos >= this.length) {
				throw haxe_Exception.thrown("Invalid object");
			}
			if(this.buf.charCodeAt(this.pos) == 103) {
				break;
			}
			let k = this.unserialize();
			if(typeof(k) != "string") {
				throw haxe_Exception.thrown("Invalid object key");
			}
			let v = this.unserialize();
			o[k] = v;
		}
		this.pos++;
	}
	unserializeEnum(edecl,tag) {
		if(this.buf.charCodeAt(this.pos++) != 58) {
			throw haxe_Exception.thrown("Invalid enum format");
		}
		let nargs = this.readDigits();
		if(nargs == 0) {
			return Type.createEnum(edecl,tag);
		}
		let args = [];
		while(nargs-- > 0) args.push(this.unserialize());
		return Type.createEnum(edecl,tag,args);
	}
	unserialize() {
		switch(this.buf.charCodeAt(this.pos++)) {
		case 65:
			let name = this.unserialize();
			let cl = this.resolver.resolveClass(name);
			if(cl == null) {
				throw haxe_Exception.thrown("Class not found " + name);
			}
			return cl;
		case 66:
			let name1 = this.unserialize();
			let e = this.resolver.resolveEnum(name1);
			if(e == null) {
				throw haxe_Exception.thrown("Enum not found " + name1);
			}
			return e;
		case 67:
			let name2 = this.unserialize();
			let cl1 = this.resolver.resolveClass(name2);
			if(cl1 == null) {
				throw haxe_Exception.thrown("Class not found " + name2);
			}
			let o = Object.create(cl1.prototype);
			this.cache.push(o);
			o.hxUnserialize(this);
			if(this.buf.charCodeAt(this.pos++) != 103) {
				throw haxe_Exception.thrown("Invalid custom data");
			}
			return o;
		case 77:
			let h = new haxe_ds_ObjectMap();
			this.cache.push(h);
			while(this.buf.charCodeAt(this.pos) != 104) {
				let s = this.unserialize();
				h.set(s,this.unserialize());
			}
			this.pos++;
			return h;
		case 82:
			let n = this.readDigits();
			if(n < 0 || n >= this.scache.length) {
				throw haxe_Exception.thrown("Invalid string reference");
			}
			return this.scache[n];
		case 97:
			let a = [];
			this.cache.push(a);
			while(true) {
				let c = this.buf.charCodeAt(this.pos);
				if(c == 104) {
					this.pos++;
					break;
				}
				if(c == 117) {
					this.pos++;
					let n = this.readDigits();
					a[a.length + n - 1] = null;
				} else {
					a.push(this.unserialize());
				}
			}
			return a;
		case 98:
			let h1 = new haxe_ds_StringMap();
			this.cache.push(h1);
			while(this.buf.charCodeAt(this.pos) != 104) {
				let s = this.unserialize();
				let value = this.unserialize();
				h1.h[s] = value;
			}
			this.pos++;
			return h1;
		case 99:
			let name3 = this.unserialize();
			let cl2 = this.resolver.resolveClass(name3);
			if(cl2 == null) {
				throw haxe_Exception.thrown("Class not found " + name3);
			}
			let o1 = Object.create(cl2.prototype);
			this.cache.push(o1);
			this.unserializeObject(o1);
			return o1;
		case 100:
			return this.readFloat();
		case 102:
			return false;
		case 105:
			return this.readDigits();
		case 106:
			let name4 = this.unserialize();
			let edecl = this.resolver.resolveEnum(name4);
			if(edecl == null) {
				throw haxe_Exception.thrown("Enum not found " + name4);
			}
			this.pos++;
			let index = this.readDigits();
			let _this = edecl.__constructs__;
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _this[i]._hx_name;
			}
			let tag = result[index];
			if(tag == null) {
				throw haxe_Exception.thrown("Unknown enum index " + name4 + "@" + index);
			}
			let e1 = this.unserializeEnum(edecl,tag);
			this.cache.push(e1);
			return e1;
		case 107:
			return NaN;
		case 108:
			let l = new haxe_ds_List();
			this.cache.push(l);
			while(this.buf.charCodeAt(this.pos) != 104) l.add(this.unserialize());
			this.pos++;
			return l;
		case 109:
			return -Infinity;
		case 110:
			return null;
		case 111:
			let o2 = { };
			this.cache.push(o2);
			this.unserializeObject(o2);
			return o2;
		case 112:
			return Infinity;
		case 113:
			let h2 = new haxe_ds_IntMap();
			this.cache.push(h2);
			let c = this.buf.charCodeAt(this.pos++);
			while(c == 58) {
				let i = this.readDigits();
				let value = this.unserialize();
				h2.h[i] = value;
				c = this.buf.charCodeAt(this.pos++);
			}
			if(c != 104) {
				throw haxe_Exception.thrown("Invalid IntMap format");
			}
			return h2;
		case 114:
			let n1 = this.readDigits();
			if(n1 < 0 || n1 >= this.cache.length) {
				throw haxe_Exception.thrown("Invalid reference");
			}
			return this.cache[n1];
		case 115:
			let len = this.readDigits();
			let buf = this.buf;
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len) {
				throw haxe_Exception.thrown("Invalid bytes length");
			}
			let codes = haxe_Unserializer.CODES;
			if(codes == null) {
				codes = haxe_Unserializer.initCodes();
				haxe_Unserializer.CODES = codes;
			}
			let i = this.pos;
			let rest = len & 3;
			let size = (len >> 2) * 3 + (rest >= 2 ? rest - 1 : 0);
			let max = i + (len - rest);
			let bytes = new haxe_io_Bytes(new ArrayBuffer(size));
			let bpos = 0;
			while(i < max) {
				let c1 = codes[buf.charCodeAt(i++)];
				let c2 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				let c3 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				let c4 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c3 << 6 | c4;
			}
			if(rest >= 2) {
				let c1 = codes[buf.charCodeAt(i++)];
				let c2 = codes[buf.charCodeAt(i++)];
				bytes.b[bpos++] = c1 << 2 | c2 >> 4;
				if(rest == 3) {
					let c3 = codes[buf.charCodeAt(i++)];
					bytes.b[bpos++] = c2 << 4 | c3 >> 2;
				}
			}
			this.pos += len;
			this.cache.push(bytes);
			return bytes;
		case 116:
			return true;
		case 118:
			let d;
			if(this.buf.charCodeAt(this.pos) >= 48 && this.buf.charCodeAt(this.pos) <= 57 && this.buf.charCodeAt(this.pos + 1) >= 48 && this.buf.charCodeAt(this.pos + 1) <= 57 && this.buf.charCodeAt(this.pos + 2) >= 48 && this.buf.charCodeAt(this.pos + 2) <= 57 && this.buf.charCodeAt(this.pos + 3) >= 48 && this.buf.charCodeAt(this.pos + 3) <= 57 && this.buf.charCodeAt(this.pos + 4) == 45) {
				d = HxOverrides.strDate(HxOverrides.substr(this.buf,this.pos,19));
				this.pos += 19;
			} else {
				d = new Date(this.readFloat());
			}
			this.cache.push(d);
			return d;
		case 119:
			let name5 = this.unserialize();
			let edecl1 = this.resolver.resolveEnum(name5);
			if(edecl1 == null) {
				throw haxe_Exception.thrown("Enum not found " + name5);
			}
			let e2 = this.unserializeEnum(edecl1,this.unserialize());
			this.cache.push(e2);
			return e2;
		case 120:
			throw haxe_Exception.thrown(this.unserialize());
		case 121:
			let len1 = this.readDigits();
			if(this.buf.charCodeAt(this.pos++) != 58 || this.length - this.pos < len1) {
				throw haxe_Exception.thrown("Invalid string length");
			}
			let s = HxOverrides.substr(this.buf,this.pos,len1);
			this.pos += len1;
			s = decodeURIComponent(s.split("+").join(" "));
			this.scache.push(s);
			return s;
		case 122:
			return 0;
		default:
		}
		this.pos--;
		throw haxe_Exception.thrown("Invalid char " + this.buf.charAt(this.pos) + " at position " + this.pos);
	}
	static initCodes() {
		let codes = [];
		let _g = 0;
		let _g1 = haxe_Unserializer.BASE64.length;
		while(_g < _g1) {
			let i = _g++;
			codes[haxe_Unserializer.BASE64.charCodeAt(i)] = i;
		}
		return codes;
	}
	static run(v) {
		return new haxe_Unserializer(v).unserialize();
	}
}
$hxClasses["haxe.Unserializer"] = haxe_Unserializer;
haxe_Unserializer.__name__ = "haxe.Unserializer";
Object.assign(haxe_Unserializer.prototype, {
	__class__: haxe_Unserializer
	,buf: null
	,pos: null
	,length: null
	,cache: null
	,scache: null
	,resolver: null
});
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
	unwrap() {
		return this.value;
	}
}
$hxClasses["haxe.ValueException"] = haxe_ValueException;
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
Object.assign(haxe_ValueException.prototype, {
	__class__: haxe_ValueException
	,value: null
});
class haxe_crypto_Adler32 {
	constructor() {
		this.a1 = 1;
		this.a2 = 0;
	}
	update(b,pos,len) {
		let a1 = this.a1;
		let a2 = this.a2;
		let _g = pos;
		let _g1 = pos + len;
		while(_g < _g1) {
			let p = _g++;
			let c = b.b[p];
			a1 = (a1 + c) % 65521;
			a2 = (a2 + a1) % 65521;
		}
		this.a1 = a1;
		this.a2 = a2;
	}
	equals(a) {
		if(a.a1 == this.a1) {
			return a.a2 == this.a2;
		} else {
			return false;
		}
	}
	static read(i) {
		let a = new haxe_crypto_Adler32();
		let a2a = i.readByte();
		let a2b = i.readByte();
		let a1a = i.readByte();
		let a1b = i.readByte();
		a.a1 = a1a << 8 | a1b;
		a.a2 = a2a << 8 | a2b;
		return a;
	}
}
$hxClasses["haxe.crypto.Adler32"] = haxe_crypto_Adler32;
haxe_crypto_Adler32.__name__ = "haxe.crypto.Adler32";
Object.assign(haxe_crypto_Adler32.prototype, {
	__class__: haxe_crypto_Adler32
	,a1: null
	,a2: null
});
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
	blit(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	fill(pos,len,value) {
		let _g = 0;
		while(_g < len) {
			++_g;
			this.b[pos++] = value;
		}
	}
	sub(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	getFloat(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat32(pos,true);
	}
	setFloat(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat32(pos,v,true);
	}
	getUInt16(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getUint16(pos,true);
	}
	setUInt16(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setUint16(pos,v,true);
	}
	getInt32(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	setInt32(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
	getString(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		let s = "";
		let b = this.b;
		let i = pos;
		let max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			while(i < max) {
				let c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					let code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					let c2 = b[i++];
					let code = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else {
					let c2 = b[i++];
					let c3 = b[i++];
					let u = (c & 15) << 18 | (c2 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				let c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	toString() {
		return this.getString(0,this.length);
	}
	toHex() {
		let s_b = "";
		let chars = [];
		let str = "0123456789abcdef";
		let _g = 0;
		let _g1 = str.length;
		while(_g < _g1) {
			let i = _g++;
			chars.push(HxOverrides.cca(str,i));
		}
		let _g2 = 0;
		let _g3 = this.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let c = this.b[i];
			s_b += String.fromCodePoint(chars[c >> 4]);
			s_b += String.fromCodePoint(chars[c & 15]);
		}
		return s_b;
	}
	static ofString(s,encoding) {
		if(encoding == haxe_io_Encoding.RawNative) {
			let buf = new Uint8Array(s.length << 1);
			let _g = 0;
			let _g1 = s.length;
			while(_g < _g1) {
				let i = _g++;
				let c = s.charCodeAt(i);
				buf[i << 1] = c & 255;
				buf[i << 1 | 1] = c >> 8;
			}
			return new haxe_io_Bytes(buf.buffer);
		}
		let a = [];
		let i = 0;
		while(i < s.length) {
			let c = s.charCodeAt(i++);
			if(55296 <= c && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
			}
			if(c <= 127) {
				a.push(c);
			} else if(c <= 2047) {
				a.push(192 | c >> 6);
				a.push(128 | c & 63);
			} else if(c <= 65535) {
				a.push(224 | c >> 12);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			} else {
				a.push(240 | c >> 18);
				a.push(128 | c >> 12 & 63);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			}
		}
		return new haxe_io_Bytes(new Uint8Array(a).buffer);
	}
	static ofData(b) {
		let hb = b.hxBytes;
		if(hb != null) {
			return hb;
		}
		return new haxe_io_Bytes(b);
	}
}
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
Object.assign(haxe_io_Bytes.prototype, {
	__class__: haxe_io_Bytes
	,length: null
	,b: null
	,data: null
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
haxe_io_Encoding.__empty_constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
class haxe_crypto_Base64 {
	static encode(bytes,complement) {
		if(complement == null) {
			complement = true;
		}
		let str = new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(bytes).toString();
		if(complement) {
			switch(bytes.length % 3) {
			case 1:
				str += "==";
				break;
			case 2:
				str += "=";
				break;
			default:
			}
		}
		return str;
	}
	static decode(str,complement) {
		if(complement == null) {
			complement = true;
		}
		if(complement) {
			while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
		}
		return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
	}
}
$hxClasses["haxe.crypto.Base64"] = haxe_crypto_Base64;
haxe_crypto_Base64.__name__ = "haxe.crypto.Base64";
class haxe_crypto_BaseCode {
	constructor(base) {
		let len = base.length;
		let nbits = 1;
		while(len > 1 << nbits) ++nbits;
		if(nbits > 8 || len != 1 << nbits) {
			throw haxe_Exception.thrown("BaseCode : base length must be a power of two.");
		}
		this.base = base;
		this.nbits = nbits;
	}
	encodeBytes(b) {
		let nbits = this.nbits;
		let base = this.base;
		let size = b.length * 8 / nbits | 0;
		let out = new haxe_io_Bytes(new ArrayBuffer(size + (b.length * 8 % nbits == 0 ? 0 : 1)));
		let buf = 0;
		let curbits = 0;
		let mask = (1 << nbits) - 1;
		let pin = 0;
		let pout = 0;
		while(pout < size) {
			while(curbits < nbits) {
				curbits += 8;
				buf <<= 8;
				buf |= b.b[pin++];
			}
			curbits -= nbits;
			out.b[pout++] = base.b[buf >> curbits & mask];
		}
		if(curbits > 0) {
			out.b[pout++] = base.b[buf << nbits - curbits & mask];
		}
		return out;
	}
	initTable() {
		let tbl = [];
		let _g = 0;
		while(_g < 256) {
			let i = _g++;
			tbl[i] = -1;
		}
		let _g1 = 0;
		let _g2 = this.base.length;
		while(_g1 < _g2) {
			let i = _g1++;
			tbl[this.base.b[i]] = i;
		}
		this.tbl = tbl;
	}
	decodeBytes(b) {
		let nbits = this.nbits;
		if(this.tbl == null) {
			this.initTable();
		}
		let tbl = this.tbl;
		let size = b.length * nbits >> 3;
		let out = new haxe_io_Bytes(new ArrayBuffer(size));
		let buf = 0;
		let curbits = 0;
		let pin = 0;
		let pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				let i = tbl[b.b[pin++]];
				if(i == -1) {
					throw haxe_Exception.thrown("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255;
		}
		return out;
	}
}
$hxClasses["haxe.crypto.BaseCode"] = haxe_crypto_BaseCode;
haxe_crypto_BaseCode.__name__ = "haxe.crypto.BaseCode";
Object.assign(haxe_crypto_BaseCode.prototype, {
	__class__: haxe_crypto_BaseCode
	,base: null
	,nbits: null
	,tbl: null
});
class haxe_crypto_Md5 {
	constructor() {
	}
	bitOR(a,b) {
		let lsb = a & 1 | b & 1;
		let msb31 = a >>> 1 | b >>> 1;
		return msb31 << 1 | lsb;
	}
	bitXOR(a,b) {
		let lsb = a & 1 ^ b & 1;
		let msb31 = a >>> 1 ^ b >>> 1;
		return msb31 << 1 | lsb;
	}
	bitAND(a,b) {
		let lsb = a & 1 & (b & 1);
		let msb31 = a >>> 1 & b >>> 1;
		return msb31 << 1 | lsb;
	}
	addme(x,y) {
		let lsw = (x & 65535) + (y & 65535);
		let msw = (x >> 16) + (y >> 16) + (lsw >> 16);
		return msw << 16 | lsw & 65535;
	}
	hex(a) {
		let str = "";
		let _g = 0;
		while(_g < a.length) {
			let num = a[_g];
			++_g;
			str += "0123456789abcdef".charAt(num >> 4 & 15) + "0123456789abcdef".charAt(num & 15);
			str += "0123456789abcdef".charAt(num >> 12 & 15) + "0123456789abcdef".charAt(num >> 8 & 15);
			str += "0123456789abcdef".charAt(num >> 20 & 15) + "0123456789abcdef".charAt(num >> 16 & 15);
			str += "0123456789abcdef".charAt(num >> 28 & 15) + "0123456789abcdef".charAt(num >> 24 & 15);
		}
		return str;
	}
	rol(num,cnt) {
		return num << cnt | num >>> 32 - cnt;
	}
	cmn(q,a,b,x,s,t) {
		return this.addme(this.rol(this.addme(this.addme(a,q),this.addme(x,t)),s),b);
	}
	ff(a,b,c,d,x,s,t) {
		return this.cmn(this.bitOR(this.bitAND(b,c),this.bitAND(~b,d)),a,b,x,s,t);
	}
	gg(a,b,c,d,x,s,t) {
		return this.cmn(this.bitOR(this.bitAND(b,d),this.bitAND(c,~d)),a,b,x,s,t);
	}
	hh(a,b,c,d,x,s,t) {
		return this.cmn(this.bitXOR(this.bitXOR(b,c),d),a,b,x,s,t);
	}
	ii(a,b,c,d,x,s,t) {
		return this.cmn(this.bitXOR(c,this.bitOR(b,~d)),a,b,x,s,t);
	}
	doEncode(x) {
		let a = 1732584193;
		let b = -271733879;
		let c = -1732584194;
		let d = 271733878;
		let i = 0;
		while(i < x.length) {
			let olda = a;
			let oldb = b;
			let oldc = c;
			let oldd = d;
			a = this.ff(a,b,c,d,x[i],7,-680876936);
			d = this.ff(d,a,b,c,x[i + 1],12,-389564586);
			c = this.ff(c,d,a,b,x[i + 2],17,606105819);
			b = this.ff(b,c,d,a,x[i + 3],22,-1044525330);
			a = this.ff(a,b,c,d,x[i + 4],7,-176418897);
			d = this.ff(d,a,b,c,x[i + 5],12,1200080426);
			c = this.ff(c,d,a,b,x[i + 6],17,-1473231341);
			b = this.ff(b,c,d,a,x[i + 7],22,-45705983);
			a = this.ff(a,b,c,d,x[i + 8],7,1770035416);
			d = this.ff(d,a,b,c,x[i + 9],12,-1958414417);
			c = this.ff(c,d,a,b,x[i + 10],17,-42063);
			b = this.ff(b,c,d,a,x[i + 11],22,-1990404162);
			a = this.ff(a,b,c,d,x[i + 12],7,1804603682);
			d = this.ff(d,a,b,c,x[i + 13],12,-40341101);
			c = this.ff(c,d,a,b,x[i + 14],17,-1502002290);
			b = this.ff(b,c,d,a,x[i + 15],22,1236535329);
			a = this.gg(a,b,c,d,x[i + 1],5,-165796510);
			d = this.gg(d,a,b,c,x[i + 6],9,-1069501632);
			c = this.gg(c,d,a,b,x[i + 11],14,643717713);
			b = this.gg(b,c,d,a,x[i],20,-373897302);
			a = this.gg(a,b,c,d,x[i + 5],5,-701558691);
			d = this.gg(d,a,b,c,x[i + 10],9,38016083);
			c = this.gg(c,d,a,b,x[i + 15],14,-660478335);
			b = this.gg(b,c,d,a,x[i + 4],20,-405537848);
			a = this.gg(a,b,c,d,x[i + 9],5,568446438);
			d = this.gg(d,a,b,c,x[i + 14],9,-1019803690);
			c = this.gg(c,d,a,b,x[i + 3],14,-187363961);
			b = this.gg(b,c,d,a,x[i + 8],20,1163531501);
			a = this.gg(a,b,c,d,x[i + 13],5,-1444681467);
			d = this.gg(d,a,b,c,x[i + 2],9,-51403784);
			c = this.gg(c,d,a,b,x[i + 7],14,1735328473);
			b = this.gg(b,c,d,a,x[i + 12],20,-1926607734);
			a = this.hh(a,b,c,d,x[i + 5],4,-378558);
			d = this.hh(d,a,b,c,x[i + 8],11,-2022574463);
			c = this.hh(c,d,a,b,x[i + 11],16,1839030562);
			b = this.hh(b,c,d,a,x[i + 14],23,-35309556);
			a = this.hh(a,b,c,d,x[i + 1],4,-1530992060);
			d = this.hh(d,a,b,c,x[i + 4],11,1272893353);
			c = this.hh(c,d,a,b,x[i + 7],16,-155497632);
			b = this.hh(b,c,d,a,x[i + 10],23,-1094730640);
			a = this.hh(a,b,c,d,x[i + 13],4,681279174);
			d = this.hh(d,a,b,c,x[i],11,-358537222);
			c = this.hh(c,d,a,b,x[i + 3],16,-722521979);
			b = this.hh(b,c,d,a,x[i + 6],23,76029189);
			a = this.hh(a,b,c,d,x[i + 9],4,-640364487);
			d = this.hh(d,a,b,c,x[i + 12],11,-421815835);
			c = this.hh(c,d,a,b,x[i + 15],16,530742520);
			b = this.hh(b,c,d,a,x[i + 2],23,-995338651);
			a = this.ii(a,b,c,d,x[i],6,-198630844);
			d = this.ii(d,a,b,c,x[i + 7],10,1126891415);
			c = this.ii(c,d,a,b,x[i + 14],15,-1416354905);
			b = this.ii(b,c,d,a,x[i + 5],21,-57434055);
			a = this.ii(a,b,c,d,x[i + 12],6,1700485571);
			d = this.ii(d,a,b,c,x[i + 3],10,-1894986606);
			c = this.ii(c,d,a,b,x[i + 10],15,-1051523);
			b = this.ii(b,c,d,a,x[i + 1],21,-2054922799);
			a = this.ii(a,b,c,d,x[i + 8],6,1873313359);
			d = this.ii(d,a,b,c,x[i + 15],10,-30611744);
			c = this.ii(c,d,a,b,x[i + 6],15,-1560198380);
			b = this.ii(b,c,d,a,x[i + 13],21,1309151649);
			a = this.ii(a,b,c,d,x[i + 4],6,-145523070);
			d = this.ii(d,a,b,c,x[i + 11],10,-1120210379);
			c = this.ii(c,d,a,b,x[i + 2],15,718787259);
			b = this.ii(b,c,d,a,x[i + 9],21,-343485551);
			a = this.addme(a,olda);
			b = this.addme(b,oldb);
			c = this.addme(c,oldc);
			d = this.addme(d,oldd);
			i += 16;
		}
		return [a,b,c,d];
	}
	static encode(s) {
		let m = new haxe_crypto_Md5();
		let h = m.doEncode(haxe_crypto_Md5.str2blks(s));
		return m.hex(h);
	}
	static str2blks(str) {
		let str1 = haxe_io_Bytes.ofString(str);
		let nblk = (str1.length + 8 >> 6) + 1;
		let blks = [];
		let blksSize = nblk * 16;
		let _g = 0;
		while(_g < blksSize) {
			let i = _g++;
			blks[i] = 0;
		}
		let i = 0;
		let max = str1.length;
		let l = max * 8;
		while(i < max) {
			blks[i >> 2] |= str1.b[i] << (l + i) % 4 * 8;
			++i;
		}
		blks[i >> 2] |= 128 << (l + i) % 4 * 8;
		let k = nblk * 16 - 2;
		blks[k] = l & 255;
		blks[k] = (blks[k] |= (l >>> 8 & 255) << 8) | (l >>> 16 & 255) << 16;
		blks[k] |= (l >>> 24 & 255) << 24;
		return blks;
	}
}
$hxClasses["haxe.crypto.Md5"] = haxe_crypto_Md5;
haxe_crypto_Md5.__name__ = "haxe.crypto.Md5";
Object.assign(haxe_crypto_Md5.prototype, {
	__class__: haxe_crypto_Md5
});
class haxe_ds_ArraySort {
	static sort(a,cmp) {
		haxe_ds_ArraySort.rec(a,cmp,0,a.length);
	}
	static rec(a,cmp,from,to) {
		let middle = from + to >> 1;
		if(to - from < 12) {
			if(to <= from) {
				return;
			}
			let _g = from + 1;
			while(_g < to) {
				let i = _g++;
				let j = i;
				while(j > from) {
					if(cmp(a[j],a[j - 1]) < 0) {
						haxe_ds_ArraySort.swap(a,j - 1,j);
					} else {
						break;
					}
					--j;
				}
			}
			return;
		}
		haxe_ds_ArraySort.rec(a,cmp,from,middle);
		haxe_ds_ArraySort.rec(a,cmp,middle,to);
		haxe_ds_ArraySort.doMerge(a,cmp,from,middle,to,middle - from,to - middle);
	}
	static doMerge(a,cmp,from,pivot,to,len1,len2) {
		while(true) {
			let first_cut;
			let second_cut;
			let len11;
			let len22;
			if(len1 == 0 || len2 == 0) {
				return;
			}
			if(len1 + len2 == 2) {
				if(cmp(a[pivot],a[from]) < 0) {
					haxe_ds_ArraySort.swap(a,pivot,from);
				}
				return;
			}
			if(len1 > len2) {
				len11 = len1 >> 1;
				first_cut = from + len11;
				second_cut = haxe_ds_ArraySort.lower(a,cmp,pivot,to,first_cut);
				len22 = second_cut - pivot;
			} else {
				len22 = len2 >> 1;
				second_cut = pivot + len22;
				first_cut = haxe_ds_ArraySort.upper(a,cmp,from,pivot,second_cut);
				len11 = first_cut - from;
			}
			haxe_ds_ArraySort.rotate(a,cmp,first_cut,pivot,second_cut);
			let new_mid = first_cut + len22;
			haxe_ds_ArraySort.doMerge(a,cmp,from,first_cut,new_mid,len11,len22);
			from = new_mid;
			pivot = second_cut;
			len1 -= len11;
			len2 -= len22;
		}
	}
	static rotate(a,cmp,from,mid,to) {
		if(from == mid || mid == to) {
			return;
		}
		let n = haxe_ds_ArraySort.gcd(to - from,mid - from);
		while(n-- != 0) {
			let val = a[from + n];
			let shift = mid - from;
			let p1 = from + n;
			let p2 = from + n + shift;
			while(p2 != from + n) {
				a[p1] = a[p2];
				p1 = p2;
				if(to - p2 > shift) {
					p2 += shift;
				} else {
					p2 = from + (shift - (to - p2));
				}
			}
			a[p1] = val;
		}
	}
	static gcd(m,n) {
		while(n != 0) {
			let t = m % n;
			m = n;
			n = t;
		}
		return m;
	}
	static upper(a,cmp,from,to,val) {
		let len = to - from;
		let half;
		let mid;
		while(len > 0) {
			half = len >> 1;
			mid = from + half;
			if(cmp(a[val],a[mid]) < 0) {
				len = half;
			} else {
				from = mid + 1;
				len = len - half - 1;
			}
		}
		return from;
	}
	static lower(a,cmp,from,to,val) {
		let len = to - from;
		let half;
		let mid;
		while(len > 0) {
			half = len >> 1;
			mid = from + half;
			if(cmp(a[mid],a[val]) < 0) {
				from = mid + 1;
				len = len - half - 1;
			} else {
				len = half;
			}
		}
		return from;
	}
	static swap(a,i,j) {
		let tmp = a[i];
		a[i] = a[j];
		a[j] = tmp;
	}
}
$hxClasses["haxe.ds.ArraySort"] = haxe_ds_ArraySort;
haxe_ds_ArraySort.__name__ = "haxe.ds.ArraySort";
class haxe_ds_BalancedTree {
	constructor() {
	}
	set(key,value) {
		this.root = this.setLoop(key,value,this.root);
	}
	get(key) {
		let node = this.root;
		while(node != null) {
			let c = this.compare(key,node.key);
			if(c == 0) {
				return node.value;
			}
			if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return null;
	}
	remove(key) {
		try {
			this.root = this.removeLoop(key,this.root);
			return true;
		} catch( _g ) {
			if(typeof(haxe_Exception.caught(_g).unwrap()) == "string") {
				return false;
			} else {
				throw _g;
			}
		}
	}
	exists(key) {
		let node = this.root;
		while(node != null) {
			let c = this.compare(key,node.key);
			if(c == 0) {
				return true;
			} else if(c < 0) {
				node = node.left;
			} else {
				node = node.right;
			}
		}
		return false;
	}
	keyValueIterator() {
		return new haxe_iterators_MapKeyValueIterator(this);
	}
	keys() {
		let ret = [];
		this.keysLoop(this.root,ret);
		return new haxe_iterators_ArrayIterator(ret);
	}
	setLoop(k,v,node) {
		if(node == null) {
			return new haxe_ds_TreeNode(null,k,v,null);
		}
		let c = this.compare(k,node.key);
		if(c == 0) {
			return new haxe_ds_TreeNode(node.left,k,v,node.right,node == null ? 0 : node._height);
		} else if(c < 0) {
			let nl = this.setLoop(k,v,node.left);
			return this.balance(nl,node.key,node.value,node.right);
		} else {
			let nr = this.setLoop(k,v,node.right);
			return this.balance(node.left,node.key,node.value,nr);
		}
	}
	removeLoop(k,node) {
		if(node == null) {
			throw haxe_Exception.thrown("Not_found");
		}
		let c = this.compare(k,node.key);
		if(c == 0) {
			return this.merge(node.left,node.right);
		} else if(c < 0) {
			return this.balance(this.removeLoop(k,node.left),node.key,node.value,node.right);
		} else {
			return this.balance(node.left,node.key,node.value,this.removeLoop(k,node.right));
		}
	}
	keysLoop(node,acc) {
		if(node != null) {
			this.keysLoop(node.left,acc);
			acc.push(node.key);
			this.keysLoop(node.right,acc);
		}
	}
	merge(t1,t2) {
		if(t1 == null) {
			return t2;
		}
		if(t2 == null) {
			return t1;
		}
		let t = this.minBinding(t2);
		return this.balance(t1,t.key,t.value,this.removeMinBinding(t2));
	}
	minBinding(t) {
		if(t == null) {
			throw haxe_Exception.thrown("Not_found");
		} else if(t.left == null) {
			return t;
		} else {
			return this.minBinding(t.left);
		}
	}
	removeMinBinding(t) {
		if(t.left == null) {
			return t.right;
		} else {
			return this.balance(this.removeMinBinding(t.left),t.key,t.value,t.right);
		}
	}
	balance(l,k,v,r) {
		let hl = l == null ? 0 : l._height;
		let hr = r == null ? 0 : r._height;
		if(hl > hr + 2) {
			let _this = l.left;
			let _this1 = l.right;
			if((_this == null ? 0 : _this._height) >= (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(l.left,l.key,l.value,new haxe_ds_TreeNode(l.right,k,v,r));
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,new haxe_ds_TreeNode(l.right.right,k,v,r));
			}
		} else if(hr > hl + 2) {
			let _this = r.right;
			let _this1 = r.left;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right);
			} else {
				return new haxe_ds_TreeNode(new haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,new haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right));
			}
		} else {
			return new haxe_ds_TreeNode(l,k,v,r,(hl > hr ? hl : hr) + 1);
		}
	}
	compare(k1,k2) {
		return Reflect.compare(k1,k2);
	}
}
$hxClasses["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree;
haxe_ds_BalancedTree.__name__ = "haxe.ds.BalancedTree";
haxe_ds_BalancedTree.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_BalancedTree.prototype, {
	__class__: haxe_ds_BalancedTree
	,root: null
});
class haxe_ds_TreeNode {
	constructor(l,k,v,r,h) {
		if(h == null) {
			h = -1;
		}
		this.left = l;
		this.key = k;
		this.value = v;
		this.right = r;
		if(h == -1) {
			let tmp;
			let _this = this.left;
			let _this1 = this.right;
			if((_this == null ? 0 : _this._height) > (_this1 == null ? 0 : _this1._height)) {
				let _this = this.left;
				tmp = _this == null ? 0 : _this._height;
			} else {
				let _this = this.right;
				tmp = _this == null ? 0 : _this._height;
			}
			this._height = tmp + 1;
		} else {
			this._height = h;
		}
	}
}
$hxClasses["haxe.ds.TreeNode"] = haxe_ds_TreeNode;
haxe_ds_TreeNode.__name__ = "haxe.ds.TreeNode";
Object.assign(haxe_ds_TreeNode.prototype, {
	__class__: haxe_ds_TreeNode
	,left: null
	,right: null
	,key: null
	,value: null
	,_height: null
});
class haxe_ds_EnumValueMap extends haxe_ds_BalancedTree {
	constructor() {
		super();
	}
	compare(k1,k2) {
		let d = k1._hx_index - k2._hx_index;
		if(d != 0) {
			return d;
		}
		let p1 = Type.enumParameters(k1);
		let p2 = Type.enumParameters(k2);
		if(p1.length == 0 && p2.length == 0) {
			return 0;
		}
		return this.compareArgs(p1,p2);
	}
	compareArgs(a1,a2) {
		let ld = a1.length - a2.length;
		if(ld != 0) {
			return ld;
		}
		let _g = 0;
		let _g1 = a1.length;
		while(_g < _g1) {
			let i = _g++;
			let d = this.compareArg(a1[i],a2[i]);
			if(d != 0) {
				return d;
			}
		}
		return 0;
	}
	compareArg(v1,v2) {
		if(Reflect.isEnumValue(v1) && Reflect.isEnumValue(v2)) {
			return this.compare(v1,v2);
		} else if(((v1) instanceof Array) && ((v2) instanceof Array)) {
			return this.compareArgs(v1,v2);
		} else {
			return Reflect.compare(v1,v2);
		}
	}
}
$hxClasses["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap;
haxe_ds_EnumValueMap.__name__ = "haxe.ds.EnumValueMap";
haxe_ds_EnumValueMap.__interfaces__ = [haxe_IMap];
haxe_ds_EnumValueMap.__super__ = haxe_ds_BalancedTree;
Object.assign(haxe_ds_EnumValueMap.prototype, {
	__class__: haxe_ds_EnumValueMap
});
class haxe_ds_IntMap {
	constructor() {
		this.h = { };
	}
	set(key,value) {
		this.h[key] = value;
	}
	get(key) {
		return this.h[key];
	}
	exists(key) {
		return this.h.hasOwnProperty(key);
	}
	remove(key) {
		if(!this.h.hasOwnProperty(key)) {
			return false;
		}
		delete(this.h[key]);
		return true;
	}
	keys() {
		let a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(+key);
		return new haxe_iterators_ArrayIterator(a);
	}
	iterator() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			let i = this.it.next();
			return this.ref[i];
		}};
	}
	keyValueIterator() {
		return new haxe_iterators_MapKeyValueIterator(this);
	}
}
$hxClasses["haxe.ds.IntMap"] = haxe_ds_IntMap;
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_IntMap.prototype, {
	__class__: haxe_ds_IntMap
	,h: null
});
class haxe_ds_List {
	constructor() {
		this.length = 0;
	}
	add(item) {
		let x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	push(item) {
		let x = new haxe_ds__$List_ListNode(item,this.h);
		this.h = x;
		if(this.q == null) {
			this.q = x;
		}
		this.length++;
	}
	remove(v) {
		let prev = null;
		let l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
}
$hxClasses["haxe.ds.List"] = haxe_ds_List;
haxe_ds_List.__name__ = "haxe.ds.List";
Object.assign(haxe_ds_List.prototype, {
	__class__: haxe_ds_List
	,h: null
	,q: null
	,length: null
});
class haxe_ds__$List_ListNode {
	constructor(item,next) {
		this.item = item;
		this.next = next;
	}
}
$hxClasses["haxe.ds._List.ListNode"] = haxe_ds__$List_ListNode;
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
Object.assign(haxe_ds__$List_ListNode.prototype, {
	__class__: haxe_ds__$List_ListNode
	,item: null
	,next: null
});
class haxe_ds_ObjectMap {
	constructor() {
		this.h = { __keys__ : { }};
	}
	set(key,value) {
		let id = key.__id__;
		if(id == null) {
			id = (key.__id__ = $global.$haxeUID++);
		}
		this.h[id] = value;
		this.h.__keys__[id] = key;
	}
	get(key) {
		return this.h[key.__id__];
	}
	exists(key) {
		return this.h.__keys__[key.__id__] != null;
	}
	remove(key) {
		let id = key.__id__;
		if(this.h.__keys__[id] == null) {
			return false;
		}
		delete(this.h[id]);
		delete(this.h.__keys__[id]);
		return true;
	}
	keys() {
		let a = [];
		for( var key in this.h.__keys__ ) {
		if(this.h.hasOwnProperty(key)) {
			a.push(this.h.__keys__[key]);
		}
		}
		return new haxe_iterators_ArrayIterator(a);
	}
	iterator() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			let i = this.it.next();
			return this.ref[i.__id__];
		}};
	}
	keyValueIterator() {
		return new haxe_iterators_MapKeyValueIterator(this);
	}
	copy() {
		let copied = new haxe_ds_ObjectMap();
		let key = this.keys();
		while(key.hasNext()) {
			let key1 = key.next();
			copied.set(key1,this.h[key1.__id__]);
		}
		return copied;
	}
}
$hxClasses["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap;
haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap";
haxe_ds_ObjectMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_ObjectMap.prototype, {
	__class__: haxe_ds_ObjectMap
	,h: null
});
var haxe_ds_Option = $hxEnums["haxe.ds.Option"] = { __ename__:true,__constructs__:null
	,Some: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"haxe.ds.Option",toString:$estr}; },$_._hx_name="Some",$_.__params__ = ["v"],$_)
	,None: {_hx_name:"None",_hx_index:1,__enum__:"haxe.ds.Option",toString:$estr}
};
haxe_ds_Option.__constructs__ = [haxe_ds_Option.Some,haxe_ds_Option.None];
haxe_ds_Option.__empty_constructs__ = [haxe_ds_Option.None];
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
	exists(key) {
		return Object.prototype.hasOwnProperty.call(this.h,key);
	}
	get(key) {
		return this.h[key];
	}
	set(key,value) {
		this.h[key] = value;
	}
	remove(key) {
		if(Object.prototype.hasOwnProperty.call(this.h,key)) {
			delete(this.h[key]);
			return true;
		} else {
			return false;
		}
	}
	keys() {
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.h);
	}
	keyValueIterator() {
		return new haxe_ds__$StringMap_StringMapKeyValueIterator(this.h);
	}
}
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
	,h: null
});
class haxe_ds__$StringMap_StringMapKeyIterator {
	constructor(h) {
		this.h = h;
		this.keys = Object.keys(h);
		this.length = this.keys.length;
		this.current = 0;
	}
	hasNext() {
		return this.current < this.length;
	}
	next() {
		return this.keys[this.current++];
	}
}
$hxClasses["haxe.ds._StringMap.StringMapKeyIterator"] = haxe_ds__$StringMap_StringMapKeyIterator;
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
Object.assign(haxe_ds__$StringMap_StringMapKeyIterator.prototype, {
	__class__: haxe_ds__$StringMap_StringMapKeyIterator
	,h: null
	,keys: null
	,length: null
	,current: null
});
class haxe_ds__$StringMap_StringMapKeyValueIterator {
	constructor(h) {
		this.h = h;
		this.keys = Object.keys(h);
		this.length = this.keys.length;
		this.current = 0;
	}
	hasNext() {
		return this.current < this.length;
	}
	next() {
		let key = this.keys[this.current++];
		return { key : key, value : this.h[key]};
	}
}
$hxClasses["haxe.ds._StringMap.StringMapKeyValueIterator"] = haxe_ds__$StringMap_StringMapKeyValueIterator;
haxe_ds__$StringMap_StringMapKeyValueIterator.__name__ = "haxe.ds._StringMap.StringMapKeyValueIterator";
Object.assign(haxe_ds__$StringMap_StringMapKeyValueIterator.prototype, {
	__class__: haxe_ds__$StringMap_StringMapKeyValueIterator
	,h: null
	,keys: null
	,length: null
	,current: null
});
class haxe_exceptions_PosException extends haxe_Exception {
	constructor(message,previous,pos) {
		super(message,previous);
		if(pos == null) {
			this.posInfos = { fileName : "(unknown)", lineNumber : 0, className : "(unknown)", methodName : "(unknown)"};
		} else {
			this.posInfos = pos;
		}
	}
	toString() {
		return "" + super.toString() + " in " + this.posInfos.className + "." + this.posInfos.methodName + " at " + this.posInfos.fileName + ":" + this.posInfos.lineNumber;
	}
}
$hxClasses["haxe.exceptions.PosException"] = haxe_exceptions_PosException;
haxe_exceptions_PosException.__name__ = "haxe.exceptions.PosException";
haxe_exceptions_PosException.__super__ = haxe_Exception;
Object.assign(haxe_exceptions_PosException.prototype, {
	__class__: haxe_exceptions_PosException
	,posInfos: null
});
class haxe_exceptions_NotImplementedException extends haxe_exceptions_PosException {
	constructor(message,previous,pos) {
		if(message == null) {
			message = "Not implemented";
		}
		super(message,previous,pos);
	}
}
$hxClasses["haxe.exceptions.NotImplementedException"] = haxe_exceptions_NotImplementedException;
haxe_exceptions_NotImplementedException.__name__ = "haxe.exceptions.NotImplementedException";
haxe_exceptions_NotImplementedException.__super__ = haxe_exceptions_PosException;
Object.assign(haxe_exceptions_NotImplementedException.prototype, {
	__class__: haxe_exceptions_NotImplementedException
});
class haxe_io_BytesBuffer {
	constructor() {
		this.pos = 0;
		this.size = 0;
	}
	addByte(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	add(src) {
		if(this.pos + src.length > this.size) {
			this.grow(src.length);
		}
		if(this.size == 0) {
			return;
		}
		let sub = new Uint8Array(src.b.buffer,src.b.byteOffset,src.length);
		this.u8.set(sub,this.pos);
		this.pos += src.length;
	}
	addString(v,encoding) {
		this.add(haxe_io_Bytes.ofString(v,encoding));
	}
	addInt32(v) {
		if(this.pos + 4 > this.size) {
			this.grow(4);
		}
		this.view.setInt32(this.pos,v,true);
		this.pos += 4;
	}
	addFloat(v) {
		if(this.pos + 4 > this.size) {
			this.grow(4);
		}
		this.view.setFloat32(this.pos,v,true);
		this.pos += 4;
	}
	addBytes(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		let sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	grow(delta) {
		let req = this.pos + delta;
		let nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		let nbuf = new ArrayBuffer(nsize);
		let nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	getBytes() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		let b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
}
$hxClasses["haxe.io.BytesBuffer"] = haxe_io_BytesBuffer;
haxe_io_BytesBuffer.__name__ = "haxe.io.BytesBuffer";
Object.assign(haxe_io_BytesBuffer.prototype, {
	__class__: haxe_io_BytesBuffer
	,buffer: null
	,view: null
	,u8: null
	,pos: null
	,size: null
});
class haxe_io_Input {
	readByte() {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Input.hx", lineNumber : 53, className : "haxe.io.Input", methodName : "readByte"});
	}
	readBytes(s,pos,len) {
		let k = len;
		let b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( _g ) {
			if(!((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				throw _g;
			}
		}
		return len - k;
	}
	set_bigEndian(b) {
		this.bigEndian = b;
		return b;
	}
	readFullBytes(s,pos,len) {
		while(len > 0) {
			let k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	read(nbytes) {
		let s = new haxe_io_Bytes(new ArrayBuffer(nbytes));
		let p = 0;
		while(nbytes > 0) {
			let k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	}
	readUntil(end) {
		let buf = new haxe_io_BytesBuffer();
		let last;
		while(true) {
			last = this.readByte();
			if(!(last != end)) {
				break;
			}
			buf.addByte(last);
		}
		return buf.getBytes().toString();
	}
	readLine() {
		let buf = new haxe_io_BytesBuffer();
		let last;
		let s;
		try {
			while(true) {
				last = this.readByte();
				if(!(last != 10)) {
					break;
				}
				buf.addByte(last);
			}
			s = buf.getBytes().toString();
			if(HxOverrides.cca(s,s.length - 1) == 13) {
				s = HxOverrides.substr(s,0,-1);
			}
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof haxe_io_Eof)) {
				let e = _g1;
				s = buf.getBytes().toString();
				if(s.length == 0) {
					throw haxe_Exception.thrown(e);
				}
			} else {
				throw _g;
			}
		}
		return s;
	}
	readDouble() {
		let i1 = this.readInt32();
		let i2 = this.readInt32();
		if(this.bigEndian) {
			return haxe_io_FPHelper.i64ToDouble(i2,i1);
		} else {
			return haxe_io_FPHelper.i64ToDouble(i1,i2);
		}
	}
	readInt16() {
		let ch1 = this.readByte();
		let ch2 = this.readByte();
		let n = this.bigEndian ? ch2 | ch1 << 8 : ch1 | ch2 << 8;
		if((n & 32768) != 0) {
			return n - 65536;
		}
		return n;
	}
	readUInt16() {
		let ch1 = this.readByte();
		let ch2 = this.readByte();
		if(this.bigEndian) {
			return ch2 | ch1 << 8;
		} else {
			return ch1 | ch2 << 8;
		}
	}
	readUInt24() {
		let ch1 = this.readByte();
		let ch2 = this.readByte();
		let ch3 = this.readByte();
		if(this.bigEndian) {
			return ch3 | ch2 << 8 | ch1 << 16;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16;
		}
	}
	readInt32() {
		let ch1 = this.readByte();
		let ch2 = this.readByte();
		let ch3 = this.readByte();
		let ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
	readString(len,encoding) {
		let b = new haxe_io_Bytes(new ArrayBuffer(len));
		this.readFullBytes(b,0,len);
		return b.getString(0,len,encoding);
	}
}
$hxClasses["haxe.io.Input"] = haxe_io_Input;
haxe_io_Input.__name__ = "haxe.io.Input";
Object.assign(haxe_io_Input.prototype, {
	__class__: haxe_io_Input
	,bigEndian: null
});
class haxe_io_BytesInput extends haxe_io_Input {
	constructor(b,pos,len) {
		super();
		if(pos == null) {
			pos = 0;
		}
		if(len == null) {
			len = b.length - pos;
		}
		if(pos < 0 || len < 0 || pos + len > b.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		this.b = b.b;
		this.pos = pos;
		this.len = len;
		this.totlen = len;
	}
	set_position(p) {
		if(p < 0) {
			p = 0;
		} else if(p > this.totlen) {
			p = this.totlen;
		}
		this.len = this.totlen - p;
		return this.pos = p;
	}
	readByte() {
		if(this.len == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	readBytes(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		let b1 = this.b;
		let b2 = buf.b;
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
}
$hxClasses["haxe.io.BytesInput"] = haxe_io_BytesInput;
haxe_io_BytesInput.__name__ = "haxe.io.BytesInput";
haxe_io_BytesInput.__super__ = haxe_io_Input;
Object.assign(haxe_io_BytesInput.prototype, {
	__class__: haxe_io_BytesInput
	,b: null
	,pos: null
	,len: null
	,totlen: null
});
class haxe_io_Output {
	writeByte(c) {
		throw new haxe_exceptions_NotImplementedException(null,null,{ fileName : "haxe/io/Output.hx", lineNumber : 47, className : "haxe.io.Output", methodName : "writeByte"});
	}
	writeBytes(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		let b = s.b;
		let k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	flush() {
	}
	close() {
	}
	write(s) {
		let l = s.length;
		let p = 0;
		while(l > 0) {
			let k = this.writeBytes(s,p,l);
			if(k == 0) {
				throw haxe_Exception.thrown(haxe_io_Error.Blocked);
			}
			p += k;
			l -= k;
		}
	}
	writeFloat(x) {
		this.writeInt32(haxe_io_FPHelper.floatToI32(x));
	}
	writeDouble(x) {
		let i64 = haxe_io_FPHelper.doubleToI64(x);
		if(this.bigEndian) {
			this.writeInt32(i64.high);
			this.writeInt32(i64.low);
		} else {
			this.writeInt32(i64.low);
			this.writeInt32(i64.high);
		}
	}
	writeInt16(x) {
		if(x < -32768 || x >= 32768) {
			throw haxe_Exception.thrown(haxe_io_Error.Overflow);
		}
		this.writeUInt16(x & 65535);
	}
	writeUInt16(x) {
		if(x < 0 || x >= 65536) {
			throw haxe_Exception.thrown(haxe_io_Error.Overflow);
		}
		if(this.bigEndian) {
			this.writeByte(x >> 8);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8);
		}
	}
	writeInt32(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
	prepare(nbytes) {
	}
}
$hxClasses["haxe.io.Output"] = haxe_io_Output;
haxe_io_Output.__name__ = "haxe.io.Output";
Object.assign(haxe_io_Output.prototype, {
	__class__: haxe_io_Output
	,bigEndian: null
});
class haxe_io_BytesOutput extends haxe_io_Output {
	constructor() {
		super();
		this.b = new haxe_io_BytesBuffer();
	}
	writeByte(c) {
		this.b.addByte(c);
	}
	writeBytes(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	}
	getBytes() {
		return this.b.getBytes();
	}
}
$hxClasses["haxe.io.BytesOutput"] = haxe_io_BytesOutput;
haxe_io_BytesOutput.__name__ = "haxe.io.BytesOutput";
haxe_io_BytesOutput.__super__ = haxe_io_Output;
Object.assign(haxe_io_BytesOutput.prototype, {
	__class__: haxe_io_BytesOutput
	,b: null
});
class haxe_io_Eof {
	constructor() {
	}
	toString() {
		return "Eof";
	}
}
$hxClasses["haxe.io.Eof"] = haxe_io_Eof;
haxe_io_Eof.__name__ = "haxe.io.Eof";
Object.assign(haxe_io_Eof.prototype, {
	__class__: haxe_io_Eof
});
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
haxe_io_Error.__empty_constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds];
class haxe_io_FPHelper {
	static i32ToFloat(i) {
		haxe_io_FPHelper.helper.setInt32(0,i,true);
		return haxe_io_FPHelper.helper.getFloat32(0,true);
	}
	static floatToI32(f) {
		haxe_io_FPHelper.helper.setFloat32(0,f,true);
		return haxe_io_FPHelper.helper.getInt32(0,true);
	}
	static i64ToDouble(low,high) {
		haxe_io_FPHelper.helper.setInt32(0,low,true);
		haxe_io_FPHelper.helper.setInt32(4,high,true);
		return haxe_io_FPHelper.helper.getFloat64(0,true);
	}
	static doubleToI64(v) {
		let i64 = haxe_io_FPHelper.i64tmp;
		haxe_io_FPHelper.helper.setFloat64(0,v,true);
		i64.low = haxe_io_FPHelper.helper.getInt32(0,true);
		i64.high = haxe_io_FPHelper.helper.getInt32(4,true);
		return i64;
	}
}
$hxClasses["haxe.io.FPHelper"] = haxe_io_FPHelper;
haxe_io_FPHelper.__name__ = "haxe.io.FPHelper";
class haxe_io_Path {
	constructor(path) {
		switch(path) {
		case ".":case "..":
			this.dir = path;
			this.file = "";
			return;
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			this.dir = HxOverrides.substr(path,0,c2);
			path = HxOverrides.substr(path,c2 + 1,null);
			this.backslash = true;
		} else if(c2 < c1) {
			this.dir = HxOverrides.substr(path,0,c1);
			path = HxOverrides.substr(path,c1 + 1,null);
		} else {
			this.dir = null;
		}
		let cp = path.lastIndexOf(".");
		if(cp != -1) {
			this.ext = HxOverrides.substr(path,cp + 1,null);
			this.file = HxOverrides.substr(path,0,cp);
		} else {
			this.ext = null;
			this.file = path;
		}
	}
	toString() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	static withoutExtension(path) {
		let s = new haxe_io_Path(path);
		s.ext = null;
		return s.toString();
	}
	static withoutDirectory(path) {
		let s = new haxe_io_Path(path);
		s.dir = null;
		return s.toString();
	}
	static directory(path) {
		let s = new haxe_io_Path(path);
		if(s.dir == null) {
			return "";
		}
		return s.dir;
	}
	static extension(path) {
		let s = new haxe_io_Path(path);
		if(s.ext == null) {
			return "";
		}
		return s.ext;
	}
	static withExtension(path,ext) {
		let s = new haxe_io_Path(path);
		s.ext = ext;
		return s.toString();
	}
	static join(paths) {
		let _g = [];
		let _g1 = 0;
		while(_g1 < paths.length) {
			let v = paths[_g1];
			++_g1;
			if(v != null && v != "") {
				_g.push(v);
			}
		}
		if(_g.length == 0) {
			return "";
		}
		let path = _g[0];
		let _g2 = 1;
		let _g3 = _g.length;
		while(_g2 < _g3) {
			let i = _g2++;
			path = haxe_io_Path.addTrailingSlash(path);
			path += _g[i];
		}
		return haxe_io_Path.normalize(path);
	}
	static normalize(path) {
		let slash = "/";
		path = path.split("\\").join(slash);
		if(path == slash) {
			return slash;
		}
		let target = [];
		let _g = 0;
		let _g1 = path.split(slash);
		while(_g < _g1.length) {
			let token = _g1[_g];
			++_g;
			if(token == ".." && target.length > 0 && target[target.length - 1] != "..") {
				target.pop();
			} else if(token == "") {
				if(target.length > 0 || HxOverrides.cca(path,0) == 47) {
					target.push(token);
				}
			} else if(token != ".") {
				target.push(token);
			}
		}
		let tmp = target.join(slash);
		let acc_b = "";
		let colon = false;
		let slashes = false;
		let _g_offset = 0;
		let _g_s = tmp;
		while(_g_offset < _g_s.length) {
			let s = _g_s;
			let index = _g_offset++;
			let c = s.charCodeAt(index);
			if(c >= 55296 && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(index + 1) & 1023;
			}
			let c1 = c;
			if(c1 >= 65536) {
				++_g_offset;
			}
			let c2 = c1;
			switch(c2) {
			case 47:
				if(!colon) {
					slashes = true;
				} else {
					let i = c2;
					colon = false;
					if(slashes) {
						acc_b += "/";
						slashes = false;
					}
					acc_b += String.fromCodePoint(i);
				}
				break;
			case 58:
				acc_b += ":";
				colon = true;
				break;
			default:
				let i = c2;
				colon = false;
				if(slashes) {
					acc_b += "/";
					slashes = false;
				}
				acc_b += String.fromCodePoint(i);
			}
		}
		return acc_b;
	}
	static addTrailingSlash(path) {
		if(path.length == 0) {
			return "/";
		}
		let c1 = path.lastIndexOf("/");
		let c2 = path.lastIndexOf("\\");
		if(c1 < c2) {
			if(c2 != path.length - 1) {
				return path + "\\";
			} else {
				return path;
			}
		} else if(c1 != path.length - 1) {
			return path + "/";
		} else {
			return path;
		}
	}
}
$hxClasses["haxe.io.Path"] = haxe_io_Path;
haxe_io_Path.__name__ = "haxe.io.Path";
Object.assign(haxe_io_Path.prototype, {
	__class__: haxe_io_Path
	,dir: null
	,file: null
	,ext: null
	,backslash: null
});
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
$hxClasses["haxe.iterators.ArrayIterator"] = haxe_iterators_ArrayIterator;
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
Object.assign(haxe_iterators_ArrayIterator.prototype, {
	__class__: haxe_iterators_ArrayIterator
	,array: null
	,current: null
});
class haxe_iterators_MapKeyValueIterator {
	constructor(map) {
		this.map = map;
		this.keys = map.keys();
	}
	hasNext() {
		return this.keys.hasNext();
	}
	next() {
		let key = this.keys.next();
		return { value : this.map.get(key), key : key};
	}
}
$hxClasses["haxe.iterators.MapKeyValueIterator"] = haxe_iterators_MapKeyValueIterator;
haxe_iterators_MapKeyValueIterator.__name__ = "haxe.iterators.MapKeyValueIterator";
Object.assign(haxe_iterators_MapKeyValueIterator.prototype, {
	__class__: haxe_iterators_MapKeyValueIterator
	,map: null
	,keys: null
});
var haxe_macro_Binop = $hxEnums["haxe.macro.Binop"] = { __ename__:true,__constructs__:null
	,OpAdd: {_hx_name:"OpAdd",_hx_index:0,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMult: {_hx_name:"OpMult",_hx_index:1,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpDiv: {_hx_name:"OpDiv",_hx_index:2,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpSub: {_hx_name:"OpSub",_hx_index:3,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssign: {_hx_name:"OpAssign",_hx_index:4,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpEq: {_hx_name:"OpEq",_hx_index:5,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNotEq: {_hx_name:"OpNotEq",_hx_index:6,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGt: {_hx_name:"OpGt",_hx_index:7,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpGte: {_hx_name:"OpGte",_hx_index:8,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLt: {_hx_name:"OpLt",_hx_index:9,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpLte: {_hx_name:"OpLte",_hx_index:10,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAnd: {_hx_name:"OpAnd",_hx_index:11,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpOr: {_hx_name:"OpOr",_hx_index:12,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpXor: {_hx_name:"OpXor",_hx_index:13,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolAnd: {_hx_name:"OpBoolAnd",_hx_index:14,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpBoolOr: {_hx_name:"OpBoolOr",_hx_index:15,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShl: {_hx_name:"OpShl",_hx_index:16,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpShr: {_hx_name:"OpShr",_hx_index:17,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpUShr: {_hx_name:"OpUShr",_hx_index:18,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpMod: {_hx_name:"OpMod",_hx_index:19,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpAssignOp: ($_=function(op) { return {_hx_index:20,op:op,__enum__:"haxe.macro.Binop",toString:$estr}; },$_._hx_name="OpAssignOp",$_.__params__ = ["op"],$_)
	,OpInterval: {_hx_name:"OpInterval",_hx_index:21,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpArrow: {_hx_name:"OpArrow",_hx_index:22,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpIn: {_hx_name:"OpIn",_hx_index:23,__enum__:"haxe.macro.Binop",toString:$estr}
	,OpNullCoal: {_hx_name:"OpNullCoal",_hx_index:24,__enum__:"haxe.macro.Binop",toString:$estr}
};
haxe_macro_Binop.__constructs__ = [haxe_macro_Binop.OpAdd,haxe_macro_Binop.OpMult,haxe_macro_Binop.OpDiv,haxe_macro_Binop.OpSub,haxe_macro_Binop.OpAssign,haxe_macro_Binop.OpEq,haxe_macro_Binop.OpNotEq,haxe_macro_Binop.OpGt,haxe_macro_Binop.OpGte,haxe_macro_Binop.OpLt,haxe_macro_Binop.OpLte,haxe_macro_Binop.OpAnd,haxe_macro_Binop.OpOr,haxe_macro_Binop.OpXor,haxe_macro_Binop.OpBoolAnd,haxe_macro_Binop.OpBoolOr,haxe_macro_Binop.OpShl,haxe_macro_Binop.OpShr,haxe_macro_Binop.OpUShr,haxe_macro_Binop.OpMod,haxe_macro_Binop.OpAssignOp,haxe_macro_Binop.OpInterval,haxe_macro_Binop.OpArrow,haxe_macro_Binop.OpIn,haxe_macro_Binop.OpNullCoal];
haxe_macro_Binop.__empty_constructs__ = [haxe_macro_Binop.OpAdd,haxe_macro_Binop.OpMult,haxe_macro_Binop.OpDiv,haxe_macro_Binop.OpSub,haxe_macro_Binop.OpAssign,haxe_macro_Binop.OpEq,haxe_macro_Binop.OpNotEq,haxe_macro_Binop.OpGt,haxe_macro_Binop.OpGte,haxe_macro_Binop.OpLt,haxe_macro_Binop.OpLte,haxe_macro_Binop.OpAnd,haxe_macro_Binop.OpOr,haxe_macro_Binop.OpXor,haxe_macro_Binop.OpBoolAnd,haxe_macro_Binop.OpBoolOr,haxe_macro_Binop.OpShl,haxe_macro_Binop.OpShr,haxe_macro_Binop.OpUShr,haxe_macro_Binop.OpMod,haxe_macro_Binop.OpInterval,haxe_macro_Binop.OpArrow,haxe_macro_Binop.OpIn,haxe_macro_Binop.OpNullCoal];
var haxe_macro_Unop = $hxEnums["haxe.macro.Unop"] = { __ename__:true,__constructs__:null
	,OpIncrement: {_hx_name:"OpIncrement",_hx_index:0,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpDecrement: {_hx_name:"OpDecrement",_hx_index:1,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNot: {_hx_name:"OpNot",_hx_index:2,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNeg: {_hx_name:"OpNeg",_hx_index:3,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpNegBits: {_hx_name:"OpNegBits",_hx_index:4,__enum__:"haxe.macro.Unop",toString:$estr}
	,OpSpread: {_hx_name:"OpSpread",_hx_index:5,__enum__:"haxe.macro.Unop",toString:$estr}
};
haxe_macro_Unop.__constructs__ = [haxe_macro_Unop.OpIncrement,haxe_macro_Unop.OpDecrement,haxe_macro_Unop.OpNot,haxe_macro_Unop.OpNeg,haxe_macro_Unop.OpNegBits,haxe_macro_Unop.OpSpread];
haxe_macro_Unop.__empty_constructs__ = [haxe_macro_Unop.OpIncrement,haxe_macro_Unop.OpDecrement,haxe_macro_Unop.OpNot,haxe_macro_Unop.OpNeg,haxe_macro_Unop.OpNegBits,haxe_macro_Unop.OpSpread];
class haxe_net_WebSocket {
	constructor() {
	}
	sendString(message) {
	}
	close() {
	}
	onopen() {
	}
	onerror(message) {
	}
	onmessageString(message) {
	}
	onmessageBytes(message) {
	}
	onclose(e) {
	}
	static create(url,protocols,origin,debug) {
		if(debug == null) {
			debug = false;
		}
		return new haxe_net_impl_WebSocketJs(url,protocols);
	}
}
$hxClasses["haxe.net.WebSocket"] = haxe_net_WebSocket;
haxe_net_WebSocket.__name__ = "haxe.net.WebSocket";
Object.assign(haxe_net_WebSocket.prototype, {
	__class__: haxe_net_WebSocket
});
class haxe_net_impl_WebSocketJs extends haxe_net_WebSocket {
	constructor(url,protocols) {
		super();
		if(protocols != null) {
			this.impl = new WebSocket(url,protocols);
		} else {
			this.impl = new WebSocket(url);
		}
		let _gthis = this;
		this.impl.onopen = function(e) {
			_gthis.onopen();
		};
		this.impl.onclose = function(e) {
			_gthis.onclose(e);
		};
		this.impl.onerror = function(e) {
			_gthis.onerror("error");
		};
		this.impl.onmessage = function(e) {
			let m = e.data;
			if(typeof(m) == "string") {
				_gthis.onmessageString(m);
			} else if(((m) instanceof ArrayBuffer)) {
				_gthis.onmessageBytes(haxe_io_Bytes.ofData(js_Boot.__cast(m , ArrayBuffer)));
			} else if(((m) instanceof Blob)) {
				let arrayBuffer;
				let fileReader = new FileReader();
				fileReader.onload = function() {
					arrayBuffer = fileReader.result;
					_gthis.onmessageBytes(haxe_io_Bytes.ofData(arrayBuffer));
				};
				fileReader.readAsArrayBuffer(js_Boot.__cast(m , Blob));
			} else {
				haxe_Log.trace("Unhandled websocket onmessage " + m,{ fileName : "haxe/net/impl/WebSocketJs.hx", lineNumber : 56, className : "haxe.net.impl.WebSocketJs", methodName : "new"});
			}
		};
	}
	sendString(message) {
		this.impl.send(message);
	}
	close() {
		this.impl.close();
	}
}
$hxClasses["haxe.net.impl.WebSocketJs"] = haxe_net_impl_WebSocketJs;
haxe_net_impl_WebSocketJs.__name__ = "haxe.net.impl.WebSocketJs";
haxe_net_impl_WebSocketJs.__super__ = haxe_net_WebSocket;
Object.assign(haxe_net_impl_WebSocketJs.prototype, {
	__class__: haxe_net_impl_WebSocketJs
	,impl: null
});
class haxe_xml__$Access_NodeAccess {
	static resolve(this1,name) {
		let x = this1.elementsNamed(name).next();
		if(x == null) {
			let xname;
			if(this1.nodeType == Xml.Document) {
				xname = "Document";
			} else {
				if(this1.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
				}
				xname = this1.nodeName;
			}
			throw haxe_Exception.thrown(xname + " is missing element " + name);
		}
		if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
		}
		return x;
	}
}
class haxe_xml__$Access_AttribAccess {
	static resolve(this1,name) {
		if(this1.nodeType == Xml.Document) {
			throw haxe_Exception.thrown("Cannot access document attribute " + name);
		}
		let v = this1.get(name);
		if(v == null) {
			if(this1.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (this1.nodeType == null ? "null" : XmlType.toString(this1.nodeType)));
			}
			throw haxe_Exception.thrown(this1.nodeName + " is missing attribute " + name);
		}
		return v;
	}
}
class haxe_xml__$Access_HasNodeAccess {
	static resolve(this1,name) {
		return this1.elementsNamed(name).hasNext();
	}
}
class haxe_xml_XmlParserException {
	constructor(message,xml,position) {
		this.xml = xml;
		this.message = message;
		this.position = position;
		this.lineNumber = 1;
		this.positionAtLine = 0;
		let _g = 0;
		while(_g < position) {
			let i = _g++;
			let c = xml.charCodeAt(i);
			if(c == 10) {
				this.lineNumber++;
				this.positionAtLine = 0;
			} else if(c != 13) {
				this.positionAtLine++;
			}
		}
	}
	toString() {
		let c = js_Boot.getClass(this);
		return c.__name__ + ": " + this.message + " at line " + this.lineNumber + " char " + this.positionAtLine;
	}
}
$hxClasses["haxe.xml.XmlParserException"] = haxe_xml_XmlParserException;
haxe_xml_XmlParserException.__name__ = "haxe.xml.XmlParserException";
Object.assign(haxe_xml_XmlParserException.prototype, {
	__class__: haxe_xml_XmlParserException
	,message: null
	,lineNumber: null
	,positionAtLine: null
	,position: null
	,xml: null
});
class haxe_xml_Parser {
	static parse(str,strict) {
		if(strict == null) {
			strict = false;
		}
		let doc = Xml.createDocument();
		haxe_xml_Parser.doParse(str,strict,0,doc);
		return doc;
	}
	static doParse(str,strict,p,parent) {
		if(p == null) {
			p = 0;
		}
		let xml = null;
		let state = 1;
		let next = 1;
		let aname = null;
		let start = 0;
		let nsubs = 0;
		let nbrackets = 0;
		let buf = new StringBuf();
		let escapeNext = 1;
		let attrValQuote = -1;
		while(p < str.length) {
			let c = str.charCodeAt(p);
			switch(state) {
			case 0:
				switch(c) {
				case 9:case 10:case 13:case 32:
					break;
				default:
					state = next;
					continue;
				}
				break;
			case 1:
				if(c == 60) {
					state = 0;
					next = 2;
				} else {
					start = p;
					state = 13;
					continue;
				}
				break;
			case 2:
				switch(c) {
				case 33:
					if(str.charCodeAt(p + 1) == 91) {
						p += 2;
						if(HxOverrides.substr(str,p,6).toUpperCase() != "CDATA[") {
							throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <![CDATA[",str,p));
						}
						p += 5;
						state = 17;
						start = p + 1;
					} else if(str.charCodeAt(p + 1) == 68 || str.charCodeAt(p + 1) == 100) {
						if(HxOverrides.substr(str,p + 2,6).toUpperCase() != "OCTYPE") {
							throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!DOCTYPE",str,p));
						}
						p += 8;
						state = 16;
						start = p + 1;
					} else if(str.charCodeAt(p + 1) != 45 || str.charCodeAt(p + 2) != 45) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected <!--",str,p));
					} else {
						p += 2;
						state = 15;
						start = p + 1;
					}
					break;
				case 47:
					if(parent == null) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
					}
					start = p + 1;
					state = 0;
					next = 10;
					break;
				case 63:
					state = 14;
					start = p;
					break;
				default:
					state = 3;
					start = p;
					continue;
				}
				break;
			case 3:
				if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
					if(p == start) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
					}
					xml = Xml.createElement(HxOverrides.substr(str,start,p - start));
					parent.addChild(xml);
					++nsubs;
					state = 0;
					next = 4;
					continue;
				}
				break;
			case 4:
				switch(c) {
				case 47:
					state = 11;
					break;
				case 62:
					state = 9;
					break;
				default:
					state = 5;
					start = p;
					continue;
				}
				break;
			case 5:
				if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
					if(start == p) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected attribute name",str,p));
					}
					let tmp = HxOverrides.substr(str,start,p - start);
					aname = tmp;
					if(xml.exists(aname)) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Duplicate attribute [" + aname + "]",str,p));
					}
					state = 0;
					next = 6;
					continue;
				}
				break;
			case 6:
				if(c == 61) {
					state = 0;
					next = 7;
				} else {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected =",str,p));
				}
				break;
			case 7:
				switch(c) {
				case 34:case 39:
					buf = new StringBuf();
					state = 8;
					start = p + 1;
					attrValQuote = c;
					break;
				default:
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected \"",str,p));
				}
				break;
			case 8:
				switch(c) {
				case 38:
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					state = 18;
					escapeNext = 8;
					start = p + 1;
					break;
				case 60:case 62:
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid unescaped " + String.fromCodePoint(c) + " in attribute value",str,p));
					} else if(c == attrValQuote) {
						let len = p - start;
						buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
						let val = buf.b;
						buf = new StringBuf();
						xml.set(aname,val);
						state = 0;
						next = 4;
					}
					break;
				default:
					if(c == attrValQuote) {
						let len = p - start;
						buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
						let val = buf.b;
						buf = new StringBuf();
						xml.set(aname,val);
						state = 0;
						next = 4;
					}
				}
				break;
			case 9:
				p = haxe_xml_Parser.doParse(str,strict,p,xml);
				start = p;
				state = 1;
				break;
			case 10:
				if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45)) {
					if(start == p) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected node name",str,p));
					}
					let v = HxOverrides.substr(str,start,p - start);
					if(parent == null || parent.nodeType != 0) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected </" + v + ">, tag is not open",str,p));
					}
					if(parent.nodeType != Xml.Element) {
						throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
					}
					if(v != parent.nodeName) {
						if(parent.nodeType != Xml.Element) {
							throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
						}
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected </" + parent.nodeName + ">",str,p));
					}
					state = 0;
					next = 12;
					continue;
				}
				break;
			case 11:
				if(c == 62) {
					state = 1;
				} else {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
				}
				break;
			case 12:
				if(c == 62) {
					if(nsubs == 0) {
						parent.addChild(Xml.createPCData(""));
					}
					return p;
				} else {
					throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Expected >",str,p));
				}
				break;
			case 13:
				if(c == 60) {
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					let child = Xml.createPCData(buf.b);
					buf = new StringBuf();
					parent.addChild(child);
					++nsubs;
					state = 0;
					next = 2;
				} else if(c == 38) {
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					state = 18;
					escapeNext = 13;
					start = p + 1;
				}
				break;
			case 14:
				if(c == 63 && str.charCodeAt(p + 1) == 62) {
					++p;
					let str1 = HxOverrides.substr(str,start + 1,p - start - 2);
					parent.addChild(Xml.createProcessingInstruction(str1));
					++nsubs;
					state = 1;
				}
				break;
			case 15:
				if(c == 45 && str.charCodeAt(p + 1) == 45 && str.charCodeAt(p + 2) == 62) {
					parent.addChild(Xml.createComment(HxOverrides.substr(str,start,p - start)));
					++nsubs;
					p += 2;
					state = 1;
				}
				break;
			case 16:
				if(c == 91) {
					++nbrackets;
				} else if(c == 93) {
					--nbrackets;
				} else if(c == 62 && nbrackets == 0) {
					parent.addChild(Xml.createDocType(HxOverrides.substr(str,start,p - start)));
					++nsubs;
					state = 1;
				}
				break;
			case 17:
				if(c == 93 && str.charCodeAt(p + 1) == 93 && str.charCodeAt(p + 2) == 62) {
					let child = Xml.createCData(HxOverrides.substr(str,start,p - start));
					parent.addChild(child);
					++nsubs;
					p += 2;
					state = 1;
				}
				break;
			case 18:
				if(c == 59) {
					let s = HxOverrides.substr(str,start,p - start);
					if(s.charCodeAt(0) == 35) {
						let c = s.charCodeAt(1) == 120 ? Std.parseInt("0" + HxOverrides.substr(s,1,s.length - 1)) : Std.parseInt(HxOverrides.substr(s,1,s.length - 1));
						buf.b += String.fromCodePoint(c);
					} else if(!Object.prototype.hasOwnProperty.call(haxe_xml_Parser.escapes.h,s)) {
						if(strict) {
							throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Undefined entity: " + s,str,p));
						}
						buf.b += Std.string("&" + s + ";");
					} else {
						buf.b += Std.string(haxe_xml_Parser.escapes.h[s]);
					}
					start = p + 1;
					state = escapeNext;
				} else if(!(c >= 97 && c <= 122 || c >= 65 && c <= 90 || c >= 48 && c <= 57 || c == 58 || c == 46 || c == 95 || c == 45) && c != 35) {
					if(strict) {
						throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Invalid character in entity: " + String.fromCodePoint(c),str,p));
					}
					buf.b += String.fromCodePoint(38);
					let len = p - start;
					buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
					--p;
					start = p + 1;
					state = escapeNext;
				}
				break;
			}
			++p;
		}
		if(state == 1) {
			start = p;
			state = 13;
		}
		if(state == 13) {
			if(parent.nodeType == 0) {
				if(parent.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (parent.nodeType == null ? "null" : XmlType.toString(parent.nodeType)));
				}
				throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unclosed node <" + parent.nodeName + ">",str,p));
			}
			if(p != start || nsubs == 0) {
				let len = p - start;
				buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
				parent.addChild(Xml.createPCData(buf.b));
				++nsubs;
			}
			return p;
		}
		if(!strict && state == 18 && escapeNext == 13) {
			buf.b += String.fromCodePoint(38);
			let len = p - start;
			buf.b += len == null ? HxOverrides.substr(str,start,null) : HxOverrides.substr(str,start,len);
			parent.addChild(Xml.createPCData(buf.b));
			++nsubs;
			return p;
		}
		throw haxe_Exception.thrown(new haxe_xml_XmlParserException("Unexpected end",str,p));
	}
}
$hxClasses["haxe.xml.Parser"] = haxe_xml_Parser;
haxe_xml_Parser.__name__ = "haxe.xml.Parser";
class haxe_xml_Printer {
	constructor(pretty) {
		this.output = new StringBuf();
		this.pretty = pretty;
	}
	writeNode(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeName);
			let attribute = value.attributes();
			while(attribute.hasNext()) {
				let attribute1 = attribute.next();
				this.output.b += Std.string(" " + attribute1 + "=\"");
				let input = StringTools.htmlEscape(value.get(attribute1),true);
				this.output.b += Std.string(input);
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				let _this = value.children;
				let _g_current = 0;
				while(_g_current < _this.length) {
					let child = _this[_g_current++];
					this.writeNode(child,this.pretty ? tabs + "\t" : tabs);
				}
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, expected Element but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				let input = tabs + StringTools.htmlEscape(nodeValue);
				this.output.b += Std.string(input);
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string(value.nodeValue);
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let commentContent = value.nodeValue;
			let _this_r = new RegExp("[\n\r\t]+","g".split("u").join(""));
			commentContent = commentContent.replace(_this_r,"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null ? "null" : "" + tabs;
			this.output.b += Std.string(StringTools.trim(commentContent));
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, unexpected " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
			}
			let _this = value.children;
			let _g_current = 0;
			while(_g_current < _this.length) {
				let child = _this[_g_current++];
				this.writeNode(child,tabs);
			}
			break;
		}
	}
	hasChildren(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw haxe_Exception.thrown("Bad node type, expected Element or Document but found " + (value.nodeType == null ? "null" : XmlType.toString(value.nodeType)));
		}
		let _this = value.children;
		let _g_current = 0;
		while(_g_current < _this.length) {
			let child = _this[_g_current++];
			switch(child.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child.nodeType == Xml.Document || child.nodeType == Xml.Element) {
					throw haxe_Exception.thrown("Bad node type, unexpected " + (child.nodeType == null ? "null" : XmlType.toString(child.nodeType)));
				}
				if(StringTools.ltrim(child.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	static print(xml,pretty) {
		if(pretty == null) {
			pretty = false;
		}
		let printer = new haxe_xml_Printer(pretty);
		printer.writeNode(xml,"");
		return printer.output.b;
	}
}
$hxClasses["haxe.xml.Printer"] = haxe_xml_Printer;
haxe_xml_Printer.__name__ = "haxe.xml.Printer";
Object.assign(haxe_xml_Printer.prototype, {
	__class__: haxe_xml_Printer
	,output: null
	,pretty: null
});
var haxe_zip_ExtraField = $hxEnums["haxe.zip.ExtraField"] = { __ename__:true,__constructs__:null
	,FUnknown: ($_=function(tag,bytes) { return {_hx_index:0,tag:tag,bytes:bytes,__enum__:"haxe.zip.ExtraField",toString:$estr}; },$_._hx_name="FUnknown",$_.__params__ = ["tag","bytes"],$_)
	,FInfoZipUnicodePath: ($_=function(name,crc) { return {_hx_index:1,name:name,crc:crc,__enum__:"haxe.zip.ExtraField",toString:$estr}; },$_._hx_name="FInfoZipUnicodePath",$_.__params__ = ["name","crc"],$_)
	,FUtf8: {_hx_name:"FUtf8",_hx_index:2,__enum__:"haxe.zip.ExtraField",toString:$estr}
};
haxe_zip_ExtraField.__constructs__ = [haxe_zip_ExtraField.FUnknown,haxe_zip_ExtraField.FInfoZipUnicodePath,haxe_zip_ExtraField.FUtf8];
haxe_zip_ExtraField.__empty_constructs__ = [haxe_zip_ExtraField.FUtf8];
var haxe_zip_Huffman = $hxEnums["haxe.zip.Huffman"] = { __ename__:true,__constructs__:null
	,Found: ($_=function(i) { return {_hx_index:0,i:i,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="Found",$_.__params__ = ["i"],$_)
	,NeedBit: ($_=function(left,right) { return {_hx_index:1,left:left,right:right,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="NeedBit",$_.__params__ = ["left","right"],$_)
	,NeedBits: ($_=function(n,table) { return {_hx_index:2,n:n,table:table,__enum__:"haxe.zip.Huffman",toString:$estr}; },$_._hx_name="NeedBits",$_.__params__ = ["n","table"],$_)
};
haxe_zip_Huffman.__constructs__ = [haxe_zip_Huffman.Found,haxe_zip_Huffman.NeedBit,haxe_zip_Huffman.NeedBits];
haxe_zip_Huffman.__empty_constructs__ = [];
class haxe_zip_HuffTools {
	constructor() {
	}
	treeDepth(t) {
		switch(t._hx_index) {
		case 0:
			return 0;
		case 1:
			let da = this.treeDepth(t.left);
			let db = this.treeDepth(t.right);
			return 1 + (da < db ? da : db);
		case 2:
			throw haxe_Exception.thrown("assert");
		}
	}
	treeCompress(t) {
		let d = this.treeDepth(t);
		if(d == 0) {
			return t;
		}
		if(d == 1) {
			if(t._hx_index == 1) {
				return haxe_zip_Huffman.NeedBit(this.treeCompress(t.left),this.treeCompress(t.right));
			} else {
				throw haxe_Exception.thrown("assert");
			}
		}
		let size = 1 << d;
		let table = [];
		let _g = 0;
		while(_g < size) {
			++_g;
			table.push(haxe_zip_Huffman.Found(-1));
		}
		this.treeWalk(table,0,0,d,t);
		return haxe_zip_Huffman.NeedBits(d,table);
	}
	treeWalk(table,p,cd,d,t) {
		if(t._hx_index == 1) {
			if(d > 0) {
				this.treeWalk(table,p,cd + 1,d - 1,t.left);
				this.treeWalk(table,p | 1 << cd,cd + 1,d - 1,t.right);
			} else {
				table[p] = this.treeCompress(t);
			}
		} else {
			table[p] = this.treeCompress(t);
		}
	}
	treeMake(bits,maxbits,v,len) {
		if(len > maxbits) {
			throw haxe_Exception.thrown("Invalid huffman");
		}
		let idx = v << 5 | len;
		if(bits.h.hasOwnProperty(idx)) {
			return haxe_zip_Huffman.Found(bits.h[idx]);
		}
		v <<= 1;
		++len;
		return haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,v,len),this.treeMake(bits,maxbits,v | 1,len));
	}
	make(lengths,pos,nlengths,maxbits) {
		if(nlengths == 1) {
			return haxe_zip_Huffman.NeedBit(haxe_zip_Huffman.Found(0),haxe_zip_Huffman.Found(0));
		}
		let counts = [];
		let tmp = [];
		if(maxbits > 32) {
			throw haxe_Exception.thrown("Invalid huffman");
		}
		let _g = 0;
		while(_g < maxbits) {
			++_g;
			counts.push(0);
			tmp.push(0);
		}
		let _g1 = 0;
		while(_g1 < nlengths) {
			let i = _g1++;
			let p = lengths[i + pos];
			if(p >= maxbits) {
				throw haxe_Exception.thrown("Invalid huffman");
			}
			counts[p]++;
		}
		let code = 0;
		let _g2 = 1;
		let _g3 = maxbits - 1;
		while(_g2 < _g3) {
			let i = _g2++;
			code = code + counts[i] << 1;
			tmp[i] = code;
		}
		let bits = new haxe_ds_IntMap();
		let _g4 = 0;
		while(_g4 < nlengths) {
			let i = _g4++;
			let l = lengths[i + pos];
			if(l != 0) {
				let n = tmp[l - 1];
				tmp[l - 1] = n + 1;
				bits.h[n << 5 | l] = i;
			}
		}
		return this.treeCompress(haxe_zip_Huffman.NeedBit(this.treeMake(bits,maxbits,0,1),this.treeMake(bits,maxbits,1,1)));
	}
}
$hxClasses["haxe.zip.HuffTools"] = haxe_zip_HuffTools;
haxe_zip_HuffTools.__name__ = "haxe.zip.HuffTools";
Object.assign(haxe_zip_HuffTools.prototype, {
	__class__: haxe_zip_HuffTools
});
class haxe_zip__$InflateImpl_Window {
	constructor(hasCrc) {
		this.buffer = new haxe_io_Bytes(new ArrayBuffer(65536));
		this.pos = 0;
		if(hasCrc) {
			this.crc = new haxe_crypto_Adler32();
		}
	}
	slide() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,32768);
		}
		let b = new haxe_io_Bytes(new ArrayBuffer(65536));
		this.pos -= 32768;
		b.blit(0,this.buffer,32768,this.pos);
		this.buffer = b;
	}
	addBytes(b,p,len) {
		if(this.pos + len > 65536) {
			this.slide();
		}
		this.buffer.blit(this.pos,b,p,len);
		this.pos += len;
	}
	addByte(c) {
		if(this.pos == 65536) {
			this.slide();
		}
		this.buffer.b[this.pos] = c;
		this.pos++;
	}
	getLastChar() {
		return this.buffer.b[this.pos - 1];
	}
	available() {
		return this.pos;
	}
	checksum() {
		if(this.crc != null) {
			this.crc.update(this.buffer,0,this.pos);
		}
		return this.crc;
	}
}
$hxClasses["haxe.zip._InflateImpl.Window"] = haxe_zip__$InflateImpl_Window;
haxe_zip__$InflateImpl_Window.__name__ = "haxe.zip._InflateImpl.Window";
Object.assign(haxe_zip__$InflateImpl_Window.prototype, {
	__class__: haxe_zip__$InflateImpl_Window
	,buffer: null
	,pos: null
	,crc: null
});
var haxe_zip__$InflateImpl_State = $hxEnums["haxe.zip._InflateImpl.State"] = { __ename__:true,__constructs__:null
	,Head: {_hx_name:"Head",_hx_index:0,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Block: {_hx_name:"Block",_hx_index:1,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,CData: {_hx_name:"CData",_hx_index:2,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Flat: {_hx_name:"Flat",_hx_index:3,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Crc: {_hx_name:"Crc",_hx_index:4,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Dist: {_hx_name:"Dist",_hx_index:5,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,DistOne: {_hx_name:"DistOne",_hx_index:6,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
	,Done: {_hx_name:"Done",_hx_index:7,__enum__:"haxe.zip._InflateImpl.State",toString:$estr}
};
haxe_zip__$InflateImpl_State.__constructs__ = [haxe_zip__$InflateImpl_State.Head,haxe_zip__$InflateImpl_State.Block,haxe_zip__$InflateImpl_State.CData,haxe_zip__$InflateImpl_State.Flat,haxe_zip__$InflateImpl_State.Crc,haxe_zip__$InflateImpl_State.Dist,haxe_zip__$InflateImpl_State.DistOne,haxe_zip__$InflateImpl_State.Done];
haxe_zip__$InflateImpl_State.__empty_constructs__ = [haxe_zip__$InflateImpl_State.Head,haxe_zip__$InflateImpl_State.Block,haxe_zip__$InflateImpl_State.CData,haxe_zip__$InflateImpl_State.Flat,haxe_zip__$InflateImpl_State.Crc,haxe_zip__$InflateImpl_State.Dist,haxe_zip__$InflateImpl_State.DistOne,haxe_zip__$InflateImpl_State.Done];
class haxe_zip_InflateImpl {
	constructor(i,header,crc) {
		if(crc == null) {
			crc = true;
		}
		if(header == null) {
			header = true;
		}
		this.isFinal = false;
		this.htools = new haxe_zip_HuffTools();
		this.huffman = this.buildFixedHuffman();
		this.huffdist = null;
		this.len = 0;
		this.dist = 0;
		this.state = header ? haxe_zip__$InflateImpl_State.Head : haxe_zip__$InflateImpl_State.Block;
		this.input = i;
		this.bits = 0;
		this.nbits = 0;
		this.needed = 0;
		this.output = null;
		this.outpos = 0;
		this.lengths = [];
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.lengths.push(-1);
		this.window = new haxe_zip__$InflateImpl_Window(crc);
	}
	buildFixedHuffman() {
		if(haxe_zip_InflateImpl.FIXED_HUFFMAN != null) {
			return haxe_zip_InflateImpl.FIXED_HUFFMAN;
		}
		let a = [];
		let _g = 0;
		while(_g < 288) {
			let n = _g++;
			a.push(n <= 143 ? 8 : n <= 255 ? 9 : n <= 279 ? 7 : 8);
		}
		haxe_zip_InflateImpl.FIXED_HUFFMAN = this.htools.make(a,0,288,10);
		return haxe_zip_InflateImpl.FIXED_HUFFMAN;
	}
	readBytes(b,pos,len) {
		this.needed = len;
		this.outpos = pos;
		this.output = b;
		if(len > 0) {
			while(this.inflateLoop()) {
			}
		}
		return len - this.needed;
	}
	getBits(n) {
		while(this.nbits < n) {
			this.bits |= this.input.readByte() << this.nbits;
			this.nbits += 8;
		}
		let b = this.bits & (1 << n) - 1;
		this.nbits -= n;
		this.bits >>= n;
		return b;
	}
	getBit() {
		if(this.nbits == 0) {
			this.nbits = 8;
			this.bits = this.input.readByte();
		}
		let b = (this.bits & 1) == 1;
		this.nbits--;
		this.bits >>= 1;
		return b;
	}
	getRevBits(n) {
		if(n == 0) {
			return 0;
		} else if(this.getBit()) {
			return 1 << n - 1 | this.getRevBits(n - 1);
		} else {
			return this.getRevBits(n - 1);
		}
	}
	resetBits() {
		this.bits = 0;
		this.nbits = 0;
	}
	addBytes(b,p,len) {
		this.window.addBytes(b,p,len);
		this.output.blit(this.outpos,b,p,len);
		this.needed -= len;
		this.outpos += len;
	}
	addByte(b) {
		this.window.addByte(b);
		this.output.b[this.outpos] = b;
		this.needed--;
		this.outpos++;
	}
	addDistOne(n) {
		let c = this.window.getLastChar();
		let _g = 0;
		while(_g < n) {
			++_g;
			this.addByte(c);
		}
	}
	addDist(d,len) {
		this.addBytes(this.window.buffer,this.window.pos - d,len);
	}
	applyHuffman(h) {
		switch(h._hx_index) {
		case 0:
			return h.i;
		case 1:
			return this.applyHuffman(this.getBit() ? h.right : h.left);
		case 2:
			return this.applyHuffman(h.table[this.getBits(h.n)]);
		}
	}
	inflateLengths(a,max) {
		let i = 0;
		let prev = 0;
		while(i < max) {
			let n = this.applyHuffman(this.huffman);
			switch(n) {
			case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:case 11:case 12:case 13:case 14:case 15:
				prev = n;
				a[i] = n;
				++i;
				break;
			case 16:
				let end = i + 3 + this.getBits(2);
				if(end > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				while(i < end) {
					a[i] = prev;
					++i;
				}
				break;
			case 17:
				i += 3 + this.getBits(3);
				if(i > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				break;
			case 18:
				i += 11 + this.getBits(7);
				if(i > max) {
					throw haxe_Exception.thrown("Invalid data");
				}
				break;
			default:
				throw haxe_Exception.thrown("Invalid data");
			}
		}
	}
	inflateLoop() {
		switch(this.state._hx_index) {
		case 0:
			let cmf = this.input.readByte();
			let cm = cmf & 15;
			if(cm != 8) {
				throw haxe_Exception.thrown("Invalid data");
			}
			let flg = this.input.readByte();
			let fdict = (flg & 32) != 0;
			if(((cmf << 8) + flg) % 31 != 0) {
				throw haxe_Exception.thrown("Invalid data");
			}
			if(fdict) {
				throw haxe_Exception.thrown("Unsupported dictionary");
			}
			this.state = haxe_zip__$InflateImpl_State.Block;
			return true;
		case 1:
			this.isFinal = this.getBit();
			switch(this.getBits(2)) {
			case 0:
				this.len = this.input.readUInt16();
				let nlen = this.input.readUInt16();
				if(nlen != 65535 - this.len) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.state = haxe_zip__$InflateImpl_State.Flat;
				let r = this.inflateLoop();
				this.resetBits();
				return r;
			case 1:
				this.huffman = this.buildFixedHuffman();
				this.huffdist = null;
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			case 2:
				let hlit = this.getBits(5) + 257;
				let hdist = this.getBits(5) + 1;
				let hclen = this.getBits(4) + 4;
				let _g = 0;
				while(_g < hclen) {
					let i = _g++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i]] = this.getBits(3);
				}
				let _g1 = hclen;
				while(_g1 < 19) {
					let i = _g1++;
					this.lengths[haxe_zip_InflateImpl.CODE_LENGTHS_POS[i]] = 0;
				}
				this.huffman = this.htools.make(this.lengths,0,19,8);
				let lengths = [];
				let _g2 = 0;
				let _g3 = hlit + hdist;
				while(_g2 < _g3) {
					++_g2;
					lengths.push(0);
				}
				this.inflateLengths(lengths,hlit + hdist);
				this.huffdist = this.htools.make(lengths,hlit,hdist,16);
				this.huffman = this.htools.make(lengths,0,hlit,16);
				this.state = haxe_zip__$InflateImpl_State.CData;
				return true;
			default:
				throw haxe_Exception.thrown("Invalid data");
			}
			break;
		case 2:
			let n = this.applyHuffman(this.huffman);
			if(n < 256) {
				this.addByte(n);
				return this.needed > 0;
			} else if(n == 256) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
				return true;
			} else {
				n -= 257;
				let extra_bits = haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL[n];
				if(extra_bits == -1) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.len = haxe_zip_InflateImpl.LEN_BASE_VAL_TBL[n] + this.getBits(extra_bits);
				let dist_code = this.huffdist == null ? this.getRevBits(5) : this.applyHuffman(this.huffdist);
				extra_bits = haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL[dist_code];
				if(extra_bits == -1) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.dist = haxe_zip_InflateImpl.DIST_BASE_VAL_TBL[dist_code] + this.getBits(extra_bits);
				if(this.dist > this.window.available()) {
					throw haxe_Exception.thrown("Invalid data");
				}
				this.state = this.dist == 1 ? haxe_zip__$InflateImpl_State.DistOne : haxe_zip__$InflateImpl_State.Dist;
				return true;
			}
			break;
		case 3:
			let rlen = this.len < this.needed ? this.len : this.needed;
			let bytes = this.input.read(rlen);
			this.len -= rlen;
			this.addBytes(bytes,0,rlen);
			if(this.len == 0) {
				this.state = this.isFinal ? haxe_zip__$InflateImpl_State.Crc : haxe_zip__$InflateImpl_State.Block;
			}
			return this.needed > 0;
		case 4:
			let calc = this.window.checksum();
			if(calc == null) {
				this.state = haxe_zip__$InflateImpl_State.Done;
				return true;
			}
			let crc = haxe_crypto_Adler32.read(this.input);
			if(!calc.equals(crc)) {
				throw haxe_Exception.thrown("Invalid CRC");
			}
			this.state = haxe_zip__$InflateImpl_State.Done;
			return true;
		case 5:
			while(this.len > 0 && this.needed > 0) {
				let rdist = this.len < this.dist ? this.len : this.dist;
				let rlen = this.needed < rdist ? this.needed : rdist;
				this.addDist(this.dist,rlen);
				this.len -= rlen;
			}
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 6:
			let rlen1 = this.len < this.needed ? this.len : this.needed;
			this.addDistOne(rlen1);
			this.len -= rlen1;
			if(this.len == 0) {
				this.state = haxe_zip__$InflateImpl_State.CData;
			}
			return this.needed > 0;
		case 7:
			return false;
		}
	}
	static run(i,bufsize) {
		if(bufsize == null) {
			bufsize = 65536;
		}
		let buf = new haxe_io_Bytes(new ArrayBuffer(bufsize));
		let output = new haxe_io_BytesBuffer();
		let inflate = new haxe_zip_InflateImpl(i);
		while(true) {
			let len = inflate.readBytes(buf,0,bufsize);
			output.addBytes(buf,0,len);
			if(len < bufsize) {
				break;
			}
		}
		return output.getBytes();
	}
}
$hxClasses["haxe.zip.InflateImpl"] = haxe_zip_InflateImpl;
haxe_zip_InflateImpl.__name__ = "haxe.zip.InflateImpl";
Object.assign(haxe_zip_InflateImpl.prototype, {
	__class__: haxe_zip_InflateImpl
	,nbits: null
	,bits: null
	,state: null
	,isFinal: null
	,huffman: null
	,huffdist: null
	,htools: null
	,len: null
	,dist: null
	,needed: null
	,output: null
	,outpos: null
	,input: null
	,lengths: null
	,window: null
});
class haxe_zip_Reader {
	constructor(i) {
		this.i = i;
	}
	readZipDate() {
		let t = this.i.readUInt16();
		let hour = t >> 11 & 31;
		let min = t >> 5 & 63;
		let sec = t & 31;
		let d = this.i.readUInt16();
		let year = d >> 9;
		let month = d >> 5 & 15;
		let day = d & 31;
		return new Date(year + 1980,month - 1,day,hour,min,sec << 1);
	}
	readExtraFields(length) {
		let fields = new haxe_ds_List();
		while(length > 0) {
			if(length < 4) {
				throw haxe_Exception.thrown("Invalid extra fields data");
			}
			let tag = this.i.readUInt16();
			let len = this.i.readUInt16();
			if(length < len) {
				throw haxe_Exception.thrown("Invalid extra fields data");
			}
			if(tag == 28789) {
				let version = this.i.readByte();
				if(version != 1) {
					let data = new haxe_io_BytesBuffer();
					data.addByte(version);
					data.add(this.i.read(len - 1));
					fields.add(haxe_zip_ExtraField.FUnknown(tag,data.getBytes()));
				} else {
					let crc = this.i.readInt32();
					let name = this.i.read(len - 5).toString();
					fields.add(haxe_zip_ExtraField.FInfoZipUnicodePath(name,crc));
				}
			} else {
				fields.add(haxe_zip_ExtraField.FUnknown(tag,this.i.read(len)));
			}
			length -= 4 + len;
		}
		return fields;
	}
	readEntryHeader() {
		let i = this.i;
		let h = i.readInt32();
		if(h == 33639248 || h == 101010256) {
			return null;
		}
		if(h != 67324752) {
			throw haxe_Exception.thrown("Invalid Zip Data");
		}
		i.readUInt16();
		let flags = i.readUInt16();
		let utf8 = (flags & 2048) != 0;
		if((flags & 63473) != 0) {
			throw haxe_Exception.thrown("Unsupported flags " + flags);
		}
		let compression = i.readUInt16();
		let compressed = compression != 0;
		if(compressed && compression != 8) {
			throw haxe_Exception.thrown("Unsupported compression " + compression);
		}
		let mtime = this.readZipDate();
		let crc32 = i.readInt32();
		let csize = i.readInt32();
		let usize = i.readInt32();
		let fnamelen = i.readInt16();
		let elen = i.readInt16();
		let fname = i.readString(fnamelen);
		let fields = this.readExtraFields(elen);
		if(utf8) {
			fields.push(haxe_zip_ExtraField.FUtf8);
		}
		let data = null;
		if((flags & 8) != 0) {
			crc32 = null;
		}
		return { fileName : fname, fileSize : usize, fileTime : mtime, compressed : compressed, dataSize : csize, data : data, crc32 : crc32, extraFields : fields};
	}
	read() {
		let l = new haxe_ds_List();
		let tmp = null;
		while(true) {
			let e = this.readEntryHeader();
			if(e == null) {
				break;
			}
			if(e.crc32 == null) {
				if(e.compressed) {
					if(tmp == null) {
						tmp = new haxe_io_Bytes(new ArrayBuffer(65536));
					}
					let out = new haxe_io_BytesBuffer();
					let z = new haxe_zip_InflateImpl(this.i,false,false);
					while(true) {
						let n = z.readBytes(tmp,0,65536);
						out.addBytes(tmp,0,n);
						if(n < 65536) {
							break;
						}
					}
					e.data = out.getBytes();
				} else {
					e.data = this.i.read(e.dataSize);
				}
				e.crc32 = this.i.readInt32();
				if(e.crc32 == 134695760) {
					e.crc32 = this.i.readInt32();
				}
				e.dataSize = this.i.readInt32();
				e.fileSize = this.i.readInt32();
				e.dataSize = e.fileSize;
				e.compressed = false;
			} else {
				e.data = this.i.read(e.dataSize);
			}
			l.add(e);
		}
		return l;
	}
}
$hxClasses["haxe.zip.Reader"] = haxe_zip_Reader;
haxe_zip_Reader.__name__ = "haxe.zip.Reader";
Object.assign(haxe_zip_Reader.prototype, {
	__class__: haxe_zip_Reader
	,i: null
});
class haxe_zip_Uncompress {
	static run(src,bufsize) {
		return haxe_zip_InflateImpl.run(new haxe_io_BytesInput(src),bufsize);
	}
}
$hxClasses["haxe.zip.Uncompress"] = haxe_zip_Uncompress;
haxe_zip_Uncompress.__name__ = "haxe.zip.Uncompress";
class hxd_BitmapData {
	constructor(width,height) {
		if(!(width == -101 && height == -102)) {
			let canvas = window.document.createElement("canvas");
			canvas.width = width;
			canvas.height = height;
			this.ctx = canvas.getContext("2d",null);
		}
	}
	getPixels() {
		let w = this.ctx.canvas.width;
		let h = this.ctx.canvas.height;
		let data = this.ctx.getImageData(0,0,w,h).data;
		let pixels = data.buffer;
		return new hxd_Pixels(w,h,haxe_io_Bytes.ofData(pixels),hxd_PixelFormat.RGBA);
	}
}
$hxClasses["hxd.BitmapData"] = hxd_BitmapData;
hxd_BitmapData.__name__ = "hxd.BitmapData";
Object.assign(hxd_BitmapData.prototype, {
	__class__: hxd_BitmapData
	,ctx: null
	,pixel: null
});
class hxd_Charset {
	constructor() {
		this.map = new haxe_ds_IntMap();
		let _g = 0;
		while(_g < 94) {
			let i = _g++;
			this.map.h[65281 + i] = 33 + i;
		}
		let _g1 = 192;
		while(_g1 < 199) {
			let i = _g1++;
			this.map.h[i] = 65;
		}
		let _g2 = 224;
		while(_g2 < 231) {
			let i = _g2++;
			this.map.h[i] = 97;
		}
		let _g3 = 200;
		while(_g3 < 204) {
			let i = _g3++;
			this.map.h[i] = 69;
		}
		let _g4 = 232;
		while(_g4 < 236) {
			let i = _g4++;
			this.map.h[i] = 101;
		}
		let _g5 = 204;
		while(_g5 < 208) {
			let i = _g5++;
			this.map.h[i] = 73;
		}
		let _g6 = 236;
		while(_g6 < 240) {
			let i = _g6++;
			this.map.h[i] = 105;
		}
		let _g7 = 210;
		while(_g7 < 215) {
			let i = _g7++;
			this.map.h[i] = 79;
		}
		let _g8 = 242;
		while(_g8 < 247) {
			let i = _g8++;
			this.map.h[i] = 111;
		}
		let _g9 = 217;
		while(_g9 < 221) {
			let i = _g9++;
			this.map.h[i] = 85;
		}
		let _g10 = 249;
		while(_g10 < 253) {
			let i = _g10++;
			this.map.h[i] = 117;
		}
		this.map.h[199] = 67;
		this.map.h[231] = 67;
		this.map.h[208] = 68;
		this.map.h[222] = 100;
		this.map.h[209] = 78;
		this.map.h[241] = 110;
		this.map.h[221] = 89;
		this.map.h[253] = 121;
		this.map.h[255] = 121;
		this.map.h[8364] = 69;
		this.map.h[12288] = 32;
		this.map.h[160] = 32;
		this.map.h[171] = 34;
		this.map.h[187] = 34;
		this.map.h[8220] = 34;
		this.map.h[8221] = 34;
		this.map.h[8222] = 34;
		this.map.h[8216] = 39;
		this.map.h[8217] = 39;
		this.map.h[180] = 39;
		this.map.h[8216] = 39;
		this.map.h[8249] = 60;
		this.map.h[8250] = 62;
		this.map.h[8211] = 45;
	}
	resolveChar(code,glyphs) {
		let c = code;
		while(c != null) {
			let g = glyphs.h[c];
			if(g != null) {
				return g;
			}
			c = this.map.h[c];
		}
		return null;
	}
	isCJK(code) {
		if(!(code >= 11904 && code <= 42191 || code >= 63744 && code <= 64255)) {
			if(code >= 131072) {
				return code <= 262141;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	isSpace(code) {
		if(code != 32) {
			return code == 12288;
		} else {
			return true;
		}
	}
	isBreakChar(code) {
		if(!this.isSpace(code)) {
			return this.isCJK(code);
		} else {
			return true;
		}
	}
	isComplementChar(code) {
		return hxd_Charset.complementChars.h.hasOwnProperty(code);
	}
	static getDefault() {
		if(hxd_Charset.inst == null) {
			hxd_Charset.inst = new hxd_Charset();
		}
		return hxd_Charset.inst;
	}
}
$hxClasses["hxd.Charset"] = hxd_Charset;
hxd_Charset.__name__ = "hxd.Charset";
Object.assign(hxd_Charset.prototype, {
	__class__: hxd_Charset
	,map: null
});
var hxd_Cursor = $hxEnums["hxd.Cursor"] = { __ename__:true,__constructs__:null
	,Default: {_hx_name:"Default",_hx_index:0,__enum__:"hxd.Cursor",toString:$estr}
	,Button: {_hx_name:"Button",_hx_index:1,__enum__:"hxd.Cursor",toString:$estr}
	,Move: {_hx_name:"Move",_hx_index:2,__enum__:"hxd.Cursor",toString:$estr}
	,TextInput: {_hx_name:"TextInput",_hx_index:3,__enum__:"hxd.Cursor",toString:$estr}
	,Hide: {_hx_name:"Hide",_hx_index:4,__enum__:"hxd.Cursor",toString:$estr}
	,Custom: ($_=function(custom) { return {_hx_index:5,custom:custom,__enum__:"hxd.Cursor",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["custom"],$_)
	,Callback: ($_=function(f) { return {_hx_index:6,f:f,__enum__:"hxd.Cursor",toString:$estr}; },$_._hx_name="Callback",$_.__params__ = ["f"],$_)
};
hxd_Cursor.__constructs__ = [hxd_Cursor.Default,hxd_Cursor.Button,hxd_Cursor.Move,hxd_Cursor.TextInput,hxd_Cursor.Hide,hxd_Cursor.Custom,hxd_Cursor.Callback];
hxd_Cursor.__empty_constructs__ = [hxd_Cursor.Default,hxd_Cursor.Button,hxd_Cursor.Move,hxd_Cursor.TextInput,hxd_Cursor.Hide];
class hxd_CustomCursor {
	constructor(frames,speed,offsetX,offsetY) {
		this.frames = frames;
		this.speed = speed;
		this.offsetX = offsetX;
		this.offsetY = offsetY;
		this.frameDelay = 1 / speed;
		this.frameTime = 0;
		this.frameIndex = 0;
	}
	reset() {
		this.frameTime = 0;
		this.frameIndex = 0;
	}
	update(dt) {
		let newTime = this.frameTime + dt;
		let delay = this.frameDelay;
		let index = this.frameIndex;
		while(newTime >= delay) {
			newTime -= delay;
			++index;
		}
		this.frameTime = newTime;
		if(index >= this.frames.length) {
			index %= this.frames.length;
		}
		if(index != this.frameIndex) {
			this.frameIndex = index;
			return index;
		}
		return -1;
	}
}
$hxClasses["hxd.CustomCursor"] = hxd_CustomCursor;
hxd_CustomCursor.__name__ = "hxd.CustomCursor";
Object.assign(hxd_CustomCursor.prototype, {
	__class__: hxd_CustomCursor
	,frames: null
	,speed: null
	,offsetX: null
	,offsetY: null
	,alloc: null
	,frameDelay: null
	,frameTime: null
	,frameIndex: null
});
var hxd_EventKind = $hxEnums["hxd.EventKind"] = { __ename__:true,__constructs__:null
	,EPush: {_hx_name:"EPush",_hx_index:0,__enum__:"hxd.EventKind",toString:$estr}
	,ERelease: {_hx_name:"ERelease",_hx_index:1,__enum__:"hxd.EventKind",toString:$estr}
	,EMove: {_hx_name:"EMove",_hx_index:2,__enum__:"hxd.EventKind",toString:$estr}
	,EOver: {_hx_name:"EOver",_hx_index:3,__enum__:"hxd.EventKind",toString:$estr}
	,EOut: {_hx_name:"EOut",_hx_index:4,__enum__:"hxd.EventKind",toString:$estr}
	,EWheel: {_hx_name:"EWheel",_hx_index:5,__enum__:"hxd.EventKind",toString:$estr}
	,EFocus: {_hx_name:"EFocus",_hx_index:6,__enum__:"hxd.EventKind",toString:$estr}
	,EFocusLost: {_hx_name:"EFocusLost",_hx_index:7,__enum__:"hxd.EventKind",toString:$estr}
	,EKeyDown: {_hx_name:"EKeyDown",_hx_index:8,__enum__:"hxd.EventKind",toString:$estr}
	,EKeyUp: {_hx_name:"EKeyUp",_hx_index:9,__enum__:"hxd.EventKind",toString:$estr}
	,EReleaseOutside: {_hx_name:"EReleaseOutside",_hx_index:10,__enum__:"hxd.EventKind",toString:$estr}
	,ETextInput: {_hx_name:"ETextInput",_hx_index:11,__enum__:"hxd.EventKind",toString:$estr}
	,ECheck: {_hx_name:"ECheck",_hx_index:12,__enum__:"hxd.EventKind",toString:$estr}
};
hxd_EventKind.__constructs__ = [hxd_EventKind.EPush,hxd_EventKind.ERelease,hxd_EventKind.EMove,hxd_EventKind.EOver,hxd_EventKind.EOut,hxd_EventKind.EWheel,hxd_EventKind.EFocus,hxd_EventKind.EFocusLost,hxd_EventKind.EKeyDown,hxd_EventKind.EKeyUp,hxd_EventKind.EReleaseOutside,hxd_EventKind.ETextInput,hxd_EventKind.ECheck];
hxd_EventKind.__empty_constructs__ = [hxd_EventKind.EPush,hxd_EventKind.ERelease,hxd_EventKind.EMove,hxd_EventKind.EOver,hxd_EventKind.EOut,hxd_EventKind.EWheel,hxd_EventKind.EFocus,hxd_EventKind.EFocusLost,hxd_EventKind.EKeyDown,hxd_EventKind.EKeyUp,hxd_EventKind.EReleaseOutside,hxd_EventKind.ETextInput,hxd_EventKind.ECheck];
class hxd_Event {
	constructor(k,x,y) {
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		this.button = 0;
		this.kind = k;
		this.relX = x;
		this.relY = y;
	}
}
$hxClasses["hxd.Event"] = hxd_Event;
hxd_Event.__name__ = "hxd.Event";
Object.assign(hxd_Event.prototype, {
	__class__: hxd_Event
	,kind: null
	,relX: null
	,relY: null
	,relZ: null
	,propagate: null
	,cancel: null
	,button: null
	,touchId: null
	,keyCode: null
	,charCode: null
	,inputChar: null
	,wheelDelta: null
});
class hxd_File {
	static browse(onSelect,options) {
		if(options == null) {
			options = { };
		}
		let input = window.document.getElementById("heapsBrowserInput");
		if(input == null) {
			input = window.document.createElement("input");
			input.setAttribute("id","heapsBrowserInput");
			window.document.body.appendChild(input);
		}
		input.setAttribute("type","file");
		input.style.display = "none";
		if(options.fileTypes != null) {
			let extensions = [];
			let _g = 0;
			let _g1 = options.fileTypes;
			while(_g < _g1.length) {
				let ft = _g1[_g];
				++_g;
				let _g2 = 0;
				let _g3 = ft.extensions;
				while(_g2 < _g3.length) {
					let e = _g3[_g2];
					++_g2;
					extensions.push("." + e);
				}
			}
			input.setAttribute("accept",extensions.join(","));
		}
		input.onclick = function(e) {
			input.value = null;
		};
		input.onchange = function(e) {
			let file = e.target.files[0];
			let b = { fileName : file.name, load : function(onReady) {
				let reader = new FileReader();
				reader.readAsDataURL(file);
				reader.onload = function(re) {
					let raw = re.target.result;
					let header = HxOverrides.substr(raw,0,raw.indexOf(","));
					let data = HxOverrides.substr(raw,raw.indexOf(",") + 1,null);
					if(raw.indexOf(";") >= 0) {
						let onReady1 = onReady;
						let b;
						if(header.split(";")[1] == "base64") {
							b = haxe_crypto_Base64.decode(data);
						} else {
							throw haxe_Exception.thrown("Unsupported encoding: " + header.split(";")[1]);
						}
						onReady1(b);
					} else {
						onReady(haxe_io_Bytes.ofString(data));
					}
				};
			}};
			onSelect(b);
			input.remove();
		};
		input.click();
	}
}
$hxClasses["hxd.File"] = hxd_File;
hxd_File.__name__ = "hxd.File";
class hxd__$FloatBuffer_Float32Expand {
	static _new(length) {
		return { pos : length, array : new Float32Array(new ArrayBuffer(length << 2))};
	}
}
class hxd_Key {
	static isDown(code) {
		return hxd_Key.keyPressed[code] > 0;
	}
	static isPressed(code) {
		return hxd_Key.keyPressed[code] == hxd_Timer.frameCount + 2 - 1;
	}
	static isReleased(code) {
		return hxd_Key.keyPressed[code] == -(hxd_Timer.frameCount + 2) + 1;
	}
	static initialize() {
		if(hxd_Key.initDone) {
			hxd_Key.dispose();
		}
		hxd_Key.initDone = true;
		hxd_Key.keyPressed = [];
		hxd_Window.getInstance().addEventTarget(hxd_Key.onEvent);
	}
	static dispose() {
		if(hxd_Key.initDone) {
			hxd_Window.getInstance().removeEventTarget(hxd_Key.onEvent);
			hxd_Key.initDone = false;
			hxd_Key.keyPressed = [];
		}
	}
	static onEvent(e) {
		switch(e.kind._hx_index) {
		case 0:
			if(e.button < 5) {
				hxd_Key.keyPressed[e.button] = hxd_Timer.frameCount + 2;
			}
			break;
		case 1:
			if(e.button < 5) {
				hxd_Key.keyPressed[e.button] = -(hxd_Timer.frameCount + 2);
			}
			break;
		case 5:
			hxd_Key.keyPressed[e.wheelDelta > 0 ? 6 : 5] = hxd_Timer.frameCount + 2;
			break;
		case 8:
			if(!hxd_Key.ALLOW_KEY_REPEAT && hxd_Key.keyPressed[e.keyCode] > 0) {
				return;
			}
			hxd_Key.keyPressed[e.keyCode] = hxd_Timer.frameCount + 2;
			break;
		case 9:
			hxd_Key.keyPressed[e.keyCode] = -(hxd_Timer.frameCount + 2);
			break;
		case 10:
			hxd_Key.keyPressed = [];
			break;
		default:
		}
	}
	static getKeyName(keyCode) {
		let c = keyCode;
		switch(c) {
		case 0:
			return "MouseLeft";
		case 1:
			return "MouseRight";
		case 2:
			return "MouseMiddle";
		case 3:
			return "Mouse3";
		case 4:
			return "Mouse4";
		case 8:
			return "Backspace";
		case 9:
			return "Tab";
		case 13:
			return "Enter";
		case 16:
			return "Shift";
		case 17:
			return "Ctrl";
		case 18:
			return "Alt";
		case 19:
			return "PauseBreak";
		case 20:
			return "CapsLock";
		case 27:
			return "Escape";
		case 32:
			return "Space";
		case 33:
			return "PageUp";
		case 34:
			return "PageDown";
		case 35:
			return "End";
		case 36:
			return "Home";
		case 37:
			return "Left";
		case 38:
			return "Up";
		case 39:
			return "Right";
		case 40:
			return "Down";
		case 45:
			return "Insert";
		case 46:
			return "Delete";
		case 91:
			return "LeftWindowKey";
		case 92:
			return "RightWindowKey";
		case 93:
			return "ContextMenu";
		case 106:
			return "NumPad*";
		case 107:
			return "NumPad+";
		case 108:
			return "NumPadEnter";
		case 109:
			return "NumPad-";
		case 110:
			return "NumPad.";
		case 111:
			return "NumPad/";
		case 144:
			return "NumLock";
		case 145:
			return "ScrollLock";
		case 186:
			return "Semicolon";
		case 187:
			return "Equals";
		case 188:
			return "Comma";
		case 189:
			return "Minus";
		case 190:
			return "Period";
		case 191:
			return "Slash";
		case 192:
			return "Tilde";
		case 219:
			return "BracketLeft";
		case 220:
			return "Backslash";
		case 221:
			return "BacketRight";
		case 222:
			return "Quote";
		case 226:
			return "IntlBackslash";
		case 272:
			return "LShift";
		case 273:
			return "LCtrl";
		case 274:
			return "LAlt";
		case 528:
			return "RShift";
		case 529:
			return "RCtrl";
		case 530:
			return "RAlt";
		default:
			if(c >= 48 && c <= 57) {
				return "" + (c - 48);
			} else if(c >= 96 && c <= 105) {
				return "NumPad" + (c - 96);
			} else if(c >= 65 && c <= 90) {
				return String.fromCodePoint((65 + c - 65));
			} else if(c >= 112 && c <= 135) {
				return "F" + (c - 112 + 1);
			} else {
				return null;
			}
		}
	}
}
$hxClasses["hxd.Key"] = hxd_Key;
hxd_Key.__name__ = "hxd.Key";
class hxd_Math {
	static fmt(v) {
		let neg;
		if(v < 0) {
			neg = -1.0;
			v = -v;
		} else {
			neg = 1.0;
		}
		if(isNaN(v) || !isFinite(v)) {
			return v;
		}
		let digits = 4 - Math.log(v) / Math.log(10) | 0;
		if(digits < 1) {
			digits = 1;
		} else if(digits >= 10) {
			return 0.;
		}
		let exp = Math.pow(10,digits);
		return Math.floor(v * exp + .49999) * neg / exp;
	}
}
$hxClasses["hxd.Math"] = hxd_Math;
hxd_Math.__name__ = "hxd.Math";
class hxd_Pad {
	constructor() {
		this.rawRYAxis = 0.;
		this.rawRXAxis = 0.;
		this.rawYAxis = 0.;
		this.rawXAxis = 0.;
		this.prevButtons = [];
		this.values = [];
		this.buttons = [];
		this.axisDeadZone = 0.1;
		this.config = hxd_Pad.DEFAULT_CONFIG;
		this.index = -1;
		this.connected = true;
	}
	get_xAxis() {
		if(this.rawXAxis * this.rawXAxis + this.rawYAxis * this.rawYAxis < this.axisDeadZone * this.axisDeadZone) {
			return 0.;
		}
		return this.rawXAxis;
	}
	get_yAxis() {
		if(this.rawXAxis * this.rawXAxis + this.rawYAxis * this.rawYAxis < this.axisDeadZone * this.axisDeadZone) {
			return 0.;
		}
		return this.rawYAxis;
	}
	get_rxAxis() {
		if(this.rawRXAxis * this.rawRXAxis + this.rawRYAxis * this.rawRYAxis < this.axisDeadZone * this.axisDeadZone) {
			return 0.;
		}
		return this.rawRXAxis;
	}
	get_ryAxis() {
		if(this.rawRXAxis * this.rawRXAxis + this.rawRYAxis * this.rawRYAxis < this.axisDeadZone * this.axisDeadZone) {
			return 0.;
		}
		return this.rawRYAxis;
	}
	onDisconnect() {
	}
	isDown(button) {
		return this.buttons[button];
	}
	isPressed(button) {
		if(this.buttons[button]) {
			return !this.prevButtons[button];
		} else {
			return false;
		}
	}
	isReleased(button) {
		if(!this.buttons[button]) {
			return this.prevButtons[button];
		} else {
			return false;
		}
	}
	static pickConfig(name) {
		switch(name) {
		case "054c-05c4-Wireless Controller":case "054c-09cc-Wireless Controller":
			return hxd_Pad.CONFIG_JS_DS4_FF;
		case "Wireless Controller (STANDARD GAMEPAD Vendor: 054c Product: 05c4)":case "Wireless Controller (STANDARD GAMEPAD Vendor: 054c Product: 09cc)":
			return hxd_Pad.CONFIG_JS_DS4;
		default:
			return hxd_Pad.CONFIG_JS_STD;
		}
	}
	static createDummy() {
		let p = new hxd_Pad();
		p.connected = false;
		return p;
	}
	static wait(onPad) {
		if(!js_Browser.get_supported()) {
			return;
		}
		hxd_Pad.waitPad = onPad;
		if(!hxd_Pad.initDone) {
			hxd_Pad.initDone = true;
			window.addEventListener("gamepadconnected",function(p) {
				let pad = new hxd_Pad();
				pad.d = p.gamepad;
				pad.config = hxd_Pad.pickConfig(pad.d.id);
				pad.index = pad.d.index;
				hxd_Pad.pads.h[pad.d.index] = pad;
				hxd_Pad.waitPad(pad);
			});
			window.addEventListener("gamepaddisconnected",function(p) {
				let pad = hxd_Pad.pads.h[p.gamepad.index];
				if(pad == null) {
					return;
				}
				hxd_Pad.pads.remove(p.gamepad.index);
				pad.connected = false;
				pad.onDisconnect();
			});
			haxe_MainLoop.add(hxd_Pad.syncPads);
		}
	}
	static syncPads() {
		let freshPads = [];
		try {
			freshPads = $global.navigator.getGamepads();
		} catch( _g ) {
		}
		if(freshPads.length > 0) {
			let _g = 0;
			let _g1 = freshPads.length;
			while(_g < _g1) {
				let i = _g++;
				if(hxd_Pad.pads.h[i] != null) {
					hxd_Pad.pads.h[i].d = freshPads[i];
				}
			}
		}
		let p = hxd_Pad.pads.iterator();
		while(p.hasNext()) {
			let p1 = p.next();
			let _g = 0;
			let _g1 = p1.d.buttons.length;
			while(_g < _g1) {
				let i = _g++;
				p1.prevButtons[i] = p1.buttons[i];
				p1.buttons[i] = p1.d.buttons[i].pressed;
				p1.values[i] = p1.d.buttons[i].value;
			}
			let _g2 = 0;
			let _g3 = p1.d.axes.length >> 1;
			while(_g2 < _g3) {
				let i = _g2++;
				let x = p1.d.axes[i << 1];
				let y = p1.d.axes[(i << 1) + 1];
				p1.values[(i << 1) + p1.d.buttons.length] = x;
				p1.values[(i << 1) + p1.d.buttons.length + 1] = -y;
				if(i == 0) {
					p1.rawXAxis = x;
					p1.rawYAxis = y;
				} else if(i == 1) {
					p1.rawRXAxis = x;
					p1.rawRYAxis = y;
				}
			}
		}
	}
}
$hxClasses["hxd.Pad"] = hxd_Pad;
hxd_Pad.__name__ = "hxd.Pad";
Object.assign(hxd_Pad.prototype, {
	__class__: hxd_Pad
	,connected: null
	,index: null
	,config: null
	,axisDeadZone: null
	,buttons: null
	,values: null
	,prevButtons: null
	,rawXAxis: null
	,rawYAxis: null
	,rawRXAxis: null
	,rawRYAxis: null
	,d: null
});
var hxd_Flags = $hxEnums["hxd.Flags"] = { __ename__:true,__constructs__:null
	,ReadOnly: {_hx_name:"ReadOnly",_hx_index:0,__enum__:"hxd.Flags",toString:$estr}
	,AlphaPremultiplied: {_hx_name:"AlphaPremultiplied",_hx_index:1,__enum__:"hxd.Flags",toString:$estr}
	,FlipY: {_hx_name:"FlipY",_hx_index:2,__enum__:"hxd.Flags",toString:$estr}
};
hxd_Flags.__constructs__ = [hxd_Flags.ReadOnly,hxd_Flags.AlphaPremultiplied,hxd_Flags.FlipY];
hxd_Flags.__empty_constructs__ = [hxd_Flags.ReadOnly,hxd_Flags.AlphaPremultiplied,hxd_Flags.FlipY];
class hxd_PixelsARGB {
	static fromPixels(p) {
		p.convert(hxd_PixelFormat.ARGB);
		p.setFlip(false);
		return p;
	}
}
class hxd_Pixels {
	constructor(width,height,bytes,format,offset) {
		if(offset == null) {
			offset = 0;
		}
		this.width = width;
		this.height = height;
		this.bytes = bytes;
		this.set_innerFormat(format);
		this.offset = offset;
		this.flags = 0;
	}
	set_innerFormat(fmt) {
		this.innerFormat = fmt;
		this.stride = hxd_Pixels.calcStride(this.width,fmt);
		this.dataSize = hxd_Pixels.calcDataSize(this.width,this.height,fmt);
		this.bytesPerPixel = hxd_Pixels.calcStride(1,fmt);
		return fmt;
	}
	invalidFormat() {
		throw haxe_Exception.thrown("Unsupported format for this operation : " + Std.string(this.innerFormat));
	}
	copyInner() {
		let old = this.bytes;
		this.bytes = new haxe_io_Bytes(new ArrayBuffer(this.dataSize));
		this.bytes.blit(0,old,this.offset,this.dataSize);
		this.offset = 0;
		this.flags &= -2;
	}
	setFlip(b) {
		if(b == null) {
			b = false;
		}
		if((this.flags & 4) != 0 == b) {
			return;
		}
		if((this.flags & 1) != 0) {
			this.copyInner();
		}
		if(b) {
			this.flags |= 4;
		} else {
			this.flags &= -5;
		}
		if(this.stride % 4 != 0) {
			this.invalidFormat();
		}
		let _g = 0;
		let _g1 = this.height >> 1;
		while(_g < _g1) {
			let y = _g++;
			let p1 = y * this.stride + this.offset;
			let p2 = (this.height - 1 - y) * this.stride + this.offset;
			let _g1 = 0;
			let _g2 = this.stride >> 2;
			while(_g1 < _g2) {
				++_g1;
				let a = this.bytes.getInt32(p1);
				let b = this.bytes.getInt32(p2);
				this.bytes.setInt32(p1,b);
				this.bytes.setInt32(p2,a);
				p1 += 4;
				p2 += 4;
			}
		}
	}
	convert(target) {
		if(this.innerFormat == target || Type.enumEq(this.innerFormat,target)) {
			return;
		}
		if((this.flags & 1) != 0) {
			this.copyInner();
		}
		let bytes = this.bytes.b;
		let _g = this.innerFormat;
		switch(_g._hx_index) {
		case 0:
			switch(target._hx_index) {
			case 1:
				let _g1 = 0;
				let _g2 = this.width * this.height;
				while(_g1 < _g2) {
					let i = _g1++;
					let p = (i << 2) + this.offset;
					let a = bytes[p];
					let r = bytes[p + 1];
					let g = bytes[p + 2];
					let b = bytes[p + 3];
					bytes[p++] = b;
					bytes[p++] = g;
					bytes[p++] = r;
					bytes[p] = a;
				}
				break;
			case 2:
				let _g3 = 0;
				let _g4 = this.width * this.height;
				while(_g3 < _g4) {
					let i = _g3++;
					let p = (i << 2) + this.offset;
					let a = bytes[p];
					let v = bytes[p + 1];
					bytes[p] = v;
					let v1 = bytes[p + 2];
					bytes[p + 1] = v1;
					let v2 = bytes[p + 3];
					bytes[p + 2] = v2;
					bytes[p + 3] = a;
				}
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 1:
			switch(target._hx_index) {
			case 0:
				let _g5 = 0;
				let _g6 = this.width * this.height;
				while(_g5 < _g6) {
					let i = _g5++;
					let p = (i << 2) + this.offset;
					let a = bytes[p];
					let r = bytes[p + 1];
					let g = bytes[p + 2];
					let b = bytes[p + 3];
					bytes[p++] = b;
					bytes[p++] = g;
					bytes[p++] = r;
					bytes[p] = a;
				}
				break;
			case 2:
				let _g7 = 0;
				let _g8 = this.width * this.height;
				while(_g7 < _g8) {
					let i = _g7++;
					let p = (i << 2) + this.offset;
					let b = bytes[p];
					let r = bytes[p + 2];
					bytes[p] = r;
					bytes[p + 2] = b;
				}
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 2:
			switch(target._hx_index) {
			case 0:
				let _g9 = 0;
				let _g10 = this.width * this.height;
				while(_g9 < _g10) {
					let i = _g9++;
					let p = (i << 2) + this.offset;
					let a = bytes[p + 3];
					let v = bytes[p + 2];
					bytes[p + 3] = v;
					let v1 = bytes[p + 1];
					bytes[p + 2] = v1;
					let v2 = bytes[p];
					bytes[p + 1] = v2;
					bytes[p] = a;
				}
				break;
			case 1:
				let _g11 = 0;
				let _g12 = this.width * this.height;
				while(_g11 < _g12) {
					let i = _g11++;
					let p = (i << 2) + this.offset;
					let b = bytes[p];
					let r = bytes[p + 2];
					bytes[p] = r;
					bytes[p + 2] = b;
				}
				break;
			case 5:
				let nbytes = new haxe_io_Bytes(new ArrayBuffer(this.width * this.height));
				let out = nbytes.b;
				let _g13 = 0;
				let _g14 = this.width * this.height;
				while(_g13 < _g14) {
					let i = _g13++;
					let v = bytes[i << 2];
					out[i] = v;
				}
				this.bytes = nbytes;
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 4:
			if(target._hx_index == 7) {
				let nbytes = new haxe_io_Bytes(new ArrayBuffer(this.height * this.width * 4));
				let _g = 0;
				let _g1 = this.width * this.height;
				while(_g < _g1) {
					let i = _g++;
					nbytes.setFloat(i << 2,this.bytes.getFloat(i << 4));
				}
				this.bytes = nbytes;
			} else {
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 7:
			switch(target._hx_index) {
			case 1:case 2:
				let fbytes = this.bytes;
				let p = 0;
				let _g15 = 0;
				let _g16 = this.width * this.height;
				while(_g15 < _g16) {
					++_g15;
					let v = fbytes.getFloat(p) * 255 | 0;
					if(v < 0) {
						v = 0;
					} else if(v > 255) {
						v = 255;
					}
					bytes[p++] = v;
					bytes[p++] = v;
					bytes[p++] = v;
					bytes[p++] = 255;
				}
				break;
			default:
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 18:
			if(target._hx_index == 7) {
				let nbytes = new haxe_io_Bytes(new ArrayBuffer(this.width * this.height * 4));
				let fbytes = this.bytes;
				let _g = 0;
				let _g1 = this.width * this.height;
				while(_g < _g1) {
					let i = _g++;
					let nv = fbytes.getUInt16(i << 1);
					nbytes.setFloat(i << 2,nv / 65535.0);
				}
				this.bytes = nbytes;
			} else {
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		case 21:
			if(target._hx_index == 21) {
				if(_g.v != target.v) {
					throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
				}
			} else {
				throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
			}
			break;
		default:
			throw haxe_Exception.thrown("Cannot convert from " + Std.string(this.innerFormat) + " to " + Std.string(target));
		}
		this.set_innerFormat(target);
	}
	dispose() {
		this.bytes = null;
	}
	toString() {
		return "Pixels(" + this.width + "x" + this.height + " " + Std.string(this.innerFormat) + ")";
	}
	clone() {
		let p = new hxd_Pixels(this.width,this.height,null,this.innerFormat);
		p.flags = this.flags;
		p.flags &= -2;
		if(this.bytes != null) {
			p.bytes = new haxe_io_Bytes(new ArrayBuffer(this.dataSize));
			p.bytes.blit(0,this.bytes,this.offset,this.dataSize);
		}
		return p;
	}
	static calcDataSize(width,height,format) {
		if(format._hx_index == 21) {
			return (height + 3 >> 2 << 2) * hxd_Pixels.calcStride(width,format);
		} else {
			return height * hxd_Pixels.calcStride(width,format);
		}
	}
	static calcStride(width,format) {
		let tmp;
		switch(format._hx_index) {
		case 3:case 20:
			tmp = 8;
			break;
		case 4:
			tmp = 16;
			break;
		case 5:
			tmp = 1;
			break;
		case 6:case 18:
			tmp = 2;
			break;
		case 7:
			tmp = 4;
			break;
		case 8:
			tmp = 2;
			break;
		case 9:
			tmp = 4;
			break;
		case 10:
			tmp = 8;
			break;
		case 11:
			tmp = 3;
			break;
		case 12:case 19:
			tmp = 6;
			break;
		case 13:
			tmp = 12;
			break;
		case 0:case 1:case 2:case 14:case 15:
			tmp = 4;
			break;
		case 16:
			tmp = 4;
			break;
		case 17:
			tmp = 4;
			break;
		case 21:
			let _g = format.v;
			let blocks = width + 3 >> 2;
			if(_g == 1 || _g == 4) {
				return blocks << 1;
			}
			return blocks << 2;
		}
		return width * tmp;
	}
	static alloc(width,height,format) {
		return new hxd_Pixels(width,height,new haxe_io_Bytes(new ArrayBuffer(hxd_Pixels.calcDataSize(width,height,format))),format);
	}
}
$hxClasses["hxd.Pixels"] = hxd_Pixels;
hxd_Pixels.__name__ = "hxd.Pixels";
Object.assign(hxd_Pixels.prototype, {
	__class__: hxd_Pixels
	,bytes: null
	,width: null
	,height: null
	,dataSize: null
	,offset: null
	,flags: null
	,stride: null
	,bytesPerPixel: null
	,innerFormat: null
});
class hxd_SceneEvents {
	constructor($window) {
		this.defaultCursor = hxd_Cursor.Default;
		this.mouseCheckMove = true;
		this.enablePhysicalMouse = true;
		this.isOut = false;
		this.onOver = new hxd_Event(hxd_EventKind.EOver);
		this.onOut = new hxd_Event(hxd_EventKind.EOut);
		this.checkPos = new hxd_Event(hxd_EventKind.ECheck);
		this.focusLost = new hxd_Event(hxd_EventKind.EFocusLost);
		this.lastTouch = 0;
		this.mouseY = -1.;
		this.mouseX = -1.;
		this.overIndex = -1;
		this.scenes = [];
		this.pendingEvents = [];
		this.pushList = [];
		this.overList = [];
		this.overCandidates = [];
		if($window == null) {
			$window = hxd_Window.getInstance();
		}
		this.window = $window;
		$window.addEventTarget($bind(this,this.onEvent));
	}
	onRemove(i) {
		if(i == this.currentFocus) {
			this.currentFocus = null;
		}
		if(this.overIndex >= 0) {
			let index = this.overList.indexOf(i);
			if(index >= 0) {
				HxOverrides.remove(this.overList,i);
				if(index < this.overIndex) {
					this.overIndex--;
				}
			}
		} else {
			HxOverrides.remove(this.overList,i);
			this.selectCursor();
		}
		HxOverrides.remove(this.pushList,i);
	}
	addScene(s,index) {
		s.setEvents(this);
		if(index == null) {
			this.scenes.push(s);
		} else {
			this.scenes.splice(index,0,s);
		}
	}
	focus(i) {
		if(this.currentFocus == i) {
			return;
		}
		if(i == null) {
			this.blur();
			return;
		}
		if(this.currentFocus != null) {
			this.blur();
			if(this.currentFocus != null) {
				return;
			}
		}
		let e = new hxd_Event(hxd_EventKind.EFocus);
		i.handleEvent(e);
		if(!e.cancel) {
			this.currentFocus = i;
		}
	}
	blur() {
		if(this.currentFocus == null) {
			return;
		}
		this.focusLost.cancel = false;
		this.currentFocus.handleEvent(this.focusLost);
		if(!this.focusLost.cancel) {
			this.currentFocus = null;
		}
	}
	checkFocus() {
		if(this.currentFocus == null) {
			return;
		}
		let s = this.currentFocus.getInteractiveScene();
		if(s == null) {
			this.currentFocus = null;
			return;
		}
		if(!s.isInteractiveVisible(this.currentFocus)) {
			this.blur();
		}
	}
	emitEvent(event) {
		let oldX = event.relX;
		let oldY = event.relY;
		let overCandidateCount = 0;
		let handled = false;
		let checkOver = false;
		let fillOver = false;
		let checkPush = false;
		let cancelFocus = false;
		let updateCursor = false;
		this.overIndex = 0;
		switch(event.kind._hx_index) {
		case 0:
			cancelFocus = true;
			checkPush = true;
			break;
		case 1:
			checkPush = true;
			break;
		case 5:case 8:case 9:case 11:
			if(this.currentFocus != null) {
				event.relX = event.relY = 0;
				this.currentFocus.handleEvent(event);
				event.relX = oldX;
				event.relY = oldY;
				if(!event.propagate) {
					return;
				}
			}
			break;
		case 2:case 12:
			checkOver = true;
			fillOver = true;
			break;
		default:
		}
		let _g = 0;
		let _g1 = this.scenes;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			let last = null;
			while(true) {
				let i = s.handleEvent(event,last);
				if(i == null) {
					event.relX = oldX;
					event.relY = oldY;
					break;
				}
				if(checkOver) {
					if(fillOver) {
						let idx = this.overList.indexOf(i);
						if(idx == -1) {
							if(this.overCandidates.length == overCandidateCount) {
								this.overCandidates[overCandidateCount] = { i : i, s : s, x : event.relX, y : event.relY, z : event.relZ};
							} else {
								let info = this.overCandidates[overCandidateCount];
								info.i = i;
								info.s = s;
								info.x = event.relX;
								info.y = event.relY;
								info.z = event.relZ;
							}
							++overCandidateCount;
							this.overList.splice(this.overIndex++,0,i);
							updateCursor = true;
						} else {
							if(idx < this.overIndex) {
								do {
									this.overList[idx] = this.overList[idx + 1];
									++idx;
								} while(idx < this.overIndex);
								this.overList[this.overIndex] = i;
								updateCursor = true;
							} else if(idx > this.overIndex) {
								do {
									this.overList[idx] = this.overList[idx - 1];
									--idx;
								} while(idx > this.overIndex);
								this.overList[this.overIndex] = i;
								updateCursor = true;
							}
							this.overIndex++;
						}
						fillOver = event.propagate;
					}
				} else {
					if(checkPush) {
						if(event.kind == hxd_EventKind.EPush) {
							this.pushList.push(i);
						} else {
							HxOverrides.remove(this.pushList,i);
						}
					}
					if(cancelFocus && i == this.currentFocus) {
						cancelFocus = false;
					}
				}
				event.relX = oldX;
				event.relY = oldY;
				if(!event.propagate) {
					handled = true;
					break;
				}
				last = i;
				event.propagate = false;
			}
			if(handled) {
				break;
			}
		}
		if(cancelFocus && this.currentFocus != null) {
			this.blur();
		}
		if(checkOver) {
			if(this.overIndex < this.overList.length) {
				while(this.overIndex < this.overList.length) {
					let e = this.overList.pop();
					e.handleEvent(this.onOut);
				}
				updateCursor = true;
			}
			if(overCandidateCount != 0) {
				let i = 0;
				let ev = this.onOver;
				do {
					let info = this.overCandidates[i++];
					ev.relX = info.x;
					ev.relY = info.y;
					ev.relZ = info.z;
					if(info.s.isInteractiveVisible(info.i)) {
						info.i.handleEvent(ev);
					} else {
						HxOverrides.remove(this.overList,info.i);
					}
					info.i = null;
					info.s = null;
				} while(i < overCandidateCount);
			}
		}
		this.overIndex = -1;
		if(updateCursor) {
			this.selectCursor();
		}
		if(!handled && event != this.checkPos) {
			if(event.kind == hxd_EventKind.EPush) {
				this.pushList.push(null);
			} else if(event.kind == hxd_EventKind.ERelease) {
				HxOverrides.remove(this.pushList,null);
			}
			this.dispatchListeners(event);
		}
		if(event.kind == hxd_EventKind.ERelease && this.pushList.length > 0) {
			let _g = 0;
			let _g1 = this.pushList;
			while(_g < _g1.length) {
				let i = _g1[_g];
				++_g;
				if(i == null) {
					event.kind = hxd_EventKind.EReleaseOutside;
					this.dispatchListeners(event);
					event.kind = hxd_EventKind.ERelease;
				} else {
					let s = i.getInteractiveScene();
					if(s == null) {
						continue;
					}
					event.kind = hxd_EventKind.EReleaseOutside;
					s.dispatchEvent(event,i);
					event.kind = hxd_EventKind.ERelease;
					event.relX = oldX;
					event.relY = oldY;
				}
			}
			this.pushList = [];
		}
	}
	checkEvents() {
		let old = this.pendingEvents;
		let checkMoved = !this.mouseCheckMove;
		let checkFocused = this.currentFocus == null;
		if(old.length > 0) {
			this.pendingEvents = [];
			let _g = 0;
			while(_g < old.length) {
				let e = old[_g];
				++_g;
				let ox = e.relX;
				let oy = e.relY;
				switch(e.kind._hx_index) {
				case 0:case 1:
					this.mouseX = e.relX;
					this.mouseY = e.relY;
					this.lastTouch = e.touchId;
					break;
				case 2:
					checkMoved = true;
					this.mouseX = e.relX;
					this.mouseY = e.relY;
					this.lastTouch = e.touchId;
					break;
				case 3:
					this.isOut = false;
					this.selectCursor();
					continue;
				case 4:
					this.isOut = true;
					if(this.overList.length > 0) {
						let i = this.overList.length - 1;
						while(i >= 0) {
							this.onOut.cancel = false;
							this.overList[i].handleEvent(this.onOut);
							HxOverrides.remove(this.overList,this.overList[i]);
							--i;
						}
						this.selectCursor();
					}
					continue;
				case 5:case 8:case 9:case 11:
					if(!checkFocused) {
						checkFocused = true;
						this.checkFocus();
					}
					break;
				default:
				}
				if(this.currentDrag != null && (this.currentDrag.ref == null || this.currentDrag.ref == e.touchId)) {
					e.propagate = true;
					e.cancel = false;
					this.currentDrag.f(e);
					e.relX = ox;
					e.relY = oy;
					if(!e.propagate) {
						continue;
					}
				}
				this.emitEvent(e);
			}
		}
		if(!checkFocused) {
			this.checkFocus();
		}
		if(!checkMoved && !this.isOut && this.currentDrag == null) {
			this.checkPos.relX = this.mouseX;
			this.checkPos.relY = this.mouseY;
			this.checkPos.touchId = this.lastTouch;
			this.checkPos.cancel = false;
			this.checkPos.propagate = false;
			this.emitEvent(this.checkPos);
		}
	}
	startCapture(f,onCancel,touchId) {
		if(this.currentDrag != null && this.currentDrag.onCancel != null) {
			this.currentDrag.onCancel();
		}
		this.currentDrag = { f : f, ref : touchId, onCancel : onCancel};
	}
	stopCapture() {
		if(this.currentDrag != null && this.currentDrag.onCancel != null) {
			this.currentDrag.onCancel();
		}
		this.currentDrag = null;
	}
	updateCursor(i) {
		if(this.overList.indexOf(i) != -1) {
			this.selectCursor();
		}
	}
	selectCursor() {
		let cur = this.defaultCursor;
		let _g = 0;
		let _g1 = this.overList;
		while(_g < _g1.length) {
			let o = _g1[_g];
			++_g;
			if(o.cursor != null) {
				cur = o.cursor;
				break;
			}
		}
		if(cur._hx_index == 6) {
			cur.f();
		} else {
			hxd_System.setCursor(cur);
		}
	}
	onEvent(e) {
		if(!this.enablePhysicalMouse && e.kind == hxd_EventKind.EMove) {
			return;
		}
		this.pendingEvents.push(e);
	}
	dispatchListeners(event) {
		let ox = event.relX;
		let oy = event.relY;
		event.propagate = true;
		let _g = 0;
		let _g1 = this.scenes;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			event.cancel = false;
			s.dispatchListeners(event);
			event.relX = ox;
			event.relY = oy;
			if(!event.propagate) {
				break;
			}
		}
	}
}
$hxClasses["hxd.SceneEvents"] = hxd_SceneEvents;
hxd_SceneEvents.__name__ = "hxd.SceneEvents";
Object.assign(hxd_SceneEvents.prototype, {
	__class__: hxd_SceneEvents
	,window: null
	,scenes: null
	,overList: null
	,overCandidates: null
	,overIndex: null
	,currentFocus: null
	,pendingEvents: null
	,pushList: null
	,currentDrag: null
	,mouseX: null
	,mouseY: null
	,lastTouch: null
	,focusLost: null
	,checkPos: null
	,onOut: null
	,onOver: null
	,isOut: null
	,enablePhysicalMouse: null
	,mouseCheckMove: null
	,defaultCursor: null
});
var hxd_Platform = $hxEnums["hxd.Platform"] = { __ename__:true,__constructs__:null
	,IOS: {_hx_name:"IOS",_hx_index:0,__enum__:"hxd.Platform",toString:$estr}
	,Android: {_hx_name:"Android",_hx_index:1,__enum__:"hxd.Platform",toString:$estr}
	,WebGL: {_hx_name:"WebGL",_hx_index:2,__enum__:"hxd.Platform",toString:$estr}
	,PC: {_hx_name:"PC",_hx_index:3,__enum__:"hxd.Platform",toString:$estr}
	,Console: {_hx_name:"Console",_hx_index:4,__enum__:"hxd.Platform",toString:$estr}
	,FlashPlayer: {_hx_name:"FlashPlayer",_hx_index:5,__enum__:"hxd.Platform",toString:$estr}
};
hxd_Platform.__constructs__ = [hxd_Platform.IOS,hxd_Platform.Android,hxd_Platform.WebGL,hxd_Platform.PC,hxd_Platform.Console,hxd_Platform.FlashPlayer];
hxd_Platform.__empty_constructs__ = [hxd_Platform.IOS,hxd_Platform.Android,hxd_Platform.WebGL,hxd_Platform.PC,hxd_Platform.Console,hxd_Platform.FlashPlayer];
var hxd_SystemValue = $hxEnums["hxd.SystemValue"] = { __ename__:true,__constructs__:null
	,IsTouch: {_hx_name:"IsTouch",_hx_index:0,__enum__:"hxd.SystemValue",toString:$estr}
	,IsWindowed: {_hx_name:"IsWindowed",_hx_index:1,__enum__:"hxd.SystemValue",toString:$estr}
	,IsMobile: {_hx_name:"IsMobile",_hx_index:2,__enum__:"hxd.SystemValue",toString:$estr}
};
hxd_SystemValue.__constructs__ = [hxd_SystemValue.IsTouch,hxd_SystemValue.IsWindowed,hxd_SystemValue.IsMobile];
hxd_SystemValue.__empty_constructs__ = [hxd_SystemValue.IsTouch,hxd_SystemValue.IsWindowed,hxd_SystemValue.IsMobile];
class hxd_Timer {
	static update() {
		hxd_Timer.frameCount++;
		let newTime = HxOverrides.now() / 1000;
		hxd_Timer.elapsedTime = newTime - hxd_Timer.lastTimeStamp;
		hxd_Timer.lastTimeStamp = newTime;
		if(hxd_Timer.elapsedTime < hxd_Timer.maxDeltaTime) {
			let a = hxd_Timer.elapsedTime;
			hxd_Timer.currentDT = a + hxd_Timer.smoothFactor * (hxd_Timer.currentDT - a);
		} else {
			hxd_Timer.elapsedTime = 1 / hxd_Timer.wantedFPS;
		}
		hxd_Timer.dt = hxd_Timer.currentDT;
	}
	static skip() {
		hxd_Timer.lastTimeStamp = HxOverrides.now() / 1000;
	}
}
$hxClasses["hxd.Timer"] = hxd_Timer;
hxd_Timer.__name__ = "hxd.Timer";
class hxd_Window {
	constructor(canvas,globalEvents) {
		this.useScreenPixels = js_Browser.get_supported();
		this._mouseLock = false;
		this.curMouseY = 0.;
		this.curMouseX = 0.;
		let customCanvas = canvas != null;
		this.eventTargets = new haxe_ds_List();
		this.resizeEvents = new haxe_ds_List();
		if(!js_Browser.get_supported()) {
			this.canvasPos = { "width" : 0, "top" : 0, "left" : 0, "height" : 0};
			return;
		}
		if(canvas == null) {
			canvas = window.document.getElementById("webgl");
			if(canvas == null) {
				throw haxe_Exception.thrown("Missing canvas #webgl");
			}
			if(canvas.getAttribute("globalEvents") == "1") {
				globalEvents = true;
			}
		}
		this.canvas = canvas;
		this.propagateKeyEvents = globalEvents;
		let propagate = canvas.getAttribute("propagateKeyEvents");
		if(propagate != null) {
			this.propagateKeyEvents = propagate != "0" && propagate != "false";
		}
		this.focused = globalEvents;
		this.element = globalEvents ? window : canvas;
		this.canvasPos = canvas.getBoundingClientRect();
		if(customCanvas) {
			canvas.addEventListener("mousemove",$bind(this,this.onMouseMove));
		} else {
			window.addEventListener("mousemove",$bind(this,this.onMouseMove));
		}
		this.element.addEventListener("mousedown",$bind(this,this.onMouseDown));
		this.element.addEventListener("mouseup",$bind(this,this.onMouseUp));
		this.element.addEventListener("mouseleave",$bind(this,this.onMouseLeave));
		this.element.addEventListener("wheel",$bind(this,this.onMouseWheel));
		this.element.addEventListener("touchstart",$bind(this,this.onTouchStart));
		this.element.addEventListener("touchmove",$bind(this,this.onTouchMove));
		this.element.addEventListener("touchend",$bind(this,this.onTouchEnd));
		this.element.addEventListener("keydown",$bind(this,this.onKeyDown));
		this.element.addEventListener("keyup",$bind(this,this.onKeyUp));
		this.element.addEventListener("keypress",$bind(this,this.onKeyPress));
		let _g = this;
		let b = false;
		let tmp = function() {
			_g.onFocus(b);
		};
		this.element.addEventListener("blur",tmp);
		let _g1 = this;
		let b1 = true;
		let tmp1 = function() {
			_g1.onFocus(b1);
		};
		this.element.addEventListener("focus",tmp1);
		let _gthis = this;
		if(window.ResizeObserver != null) {
			this.observer = new ResizeObserver(function(e) {
				_gthis.checkResize();
			});
			this.observer.observe(canvas);
		} else {
			window.addEventListener("resize",$bind(this,this.checkResize));
		}
		canvas.addEventListener("contextmenu",function(e) {
			e.stopPropagation();
			if(e.button == 2) {
				e.preventDefault();
			}
			return false;
		});
		this.curW = this.get_width();
		this.curH = this.get_height();
	}
	checkResize() {
		this.canvasPos = this.canvas.getBoundingClientRect();
		let cw = this.canvasPos.width;
		let ch = this.canvasPos.height;
		if(this.curW != cw || this.curH != ch) {
			this.curW = cw;
			this.curH = ch;
			this.onResize(null);
		}
	}
	event(e) {
		let _g_head = this.eventTargets.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			val(e);
		}
	}
	addEventTarget(et) {
		this.eventTargets.add(et);
	}
	removeEventTarget(et) {
		let _g_head = this.eventTargets.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			if(val == et) {
				this.eventTargets.remove(val);
				break;
			}
		}
	}
	addResizeEvent(f) {
		this.resizeEvents.push(f);
	}
	removeResizeEvent(f) {
		let _g_head = this.resizeEvents.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			if(val == f) {
				this.resizeEvents.remove(f);
				break;
			}
		}
	}
	onResize(e) {
		let _g_head = this.resizeEvents.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			val();
		}
	}
	lockPointer(callback) {
		this.lockCallback = callback;
		this.canvas.requestPointerLock();
	}
	unlockPointer() {
		if(window.document.pointerLockElement == this.canvas) {
			this.lockCallback = null;
			window.document.exitPointerLock();
		}
	}
	getPixelRatio() {
		if(this.useScreenPixels) {
			return window.devicePixelRatio;
		} else {
			return 1;
		}
	}
	get_width() {
		return Math.round(this.canvasPos.width * this.getPixelRatio());
	}
	get_height() {
		return Math.round(this.canvasPos.height * this.getPixelRatio());
	}
	get_windowToPixelRatio() {
		return 1.0;
	}
	get_mouseX() {
		if(this.lockCallback == null) {
			return Math.round((this.curMouseX - this.canvasPos.left) * this.getPixelRatio());
		} else {
			return -1;
		}
	}
	get_mouseY() {
		if(this.lockCallback == null) {
			return Math.round((this.curMouseY - this.canvasPos.top) * this.getPixelRatio());
		} else {
			return -1;
		}
	}
	get_mouseLock() {
		return this._mouseLock;
	}
	get_vsync() {
		return true;
	}
	onMouseDown(e) {
		if(this.get_mouseLock()) {
			if(e.movementX != 0 || e.movementY != 0) {
				this.onMouseMove(e);
			}
		} else if(e.clientX != this.curMouseX || e.clientY != this.curMouseY) {
			this.onMouseMove(e);
		}
		if(this.lockCallback != null && window.document.pointerLockElement != this.canvas) {
			this.canvas.requestPointerLock();
		}
		let ev = new hxd_Event(hxd_EventKind.EPush,this.get_mouseX(),this.get_mouseY());
		let _g = e.button;
		let tmp;
		switch(_g) {
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 1;
			break;
		default:
			tmp = _g;
		}
		ev.button = tmp;
		this.event(ev);
	}
	onMouseUp(e) {
		if(this.get_mouseLock()) {
			if(e.movementX != 0 || e.movementY != 0) {
				this.onMouseMove(e);
			}
		} else if(e.clientX != this.curMouseX || e.clientY != this.curMouseY) {
			this.onMouseMove(e);
		}
		let ev = new hxd_Event(hxd_EventKind.ERelease,this.get_mouseX(),this.get_mouseY());
		let _g = e.button;
		let tmp;
		switch(_g) {
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 1;
			break;
		default:
			tmp = _g;
		}
		ev.button = tmp;
		this.event(ev);
	}
	onMouseLeave(e) {
		let ev = new hxd_Event(hxd_EventKind.EReleaseOutside,this.get_mouseX(),this.get_mouseY());
		let _g = e.button;
		let tmp;
		switch(_g) {
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 1;
			break;
		default:
			tmp = _g;
		}
		ev.button = tmp;
		this.event(ev);
	}
	onMouseMove(e) {
		if(this.get_mouseLock()) {
			this.curMouseX += e.movementX;
			this.curMouseY += e.movementY;
		} else {
			this.curMouseX = e.clientX;
			this.curMouseY = e.clientY;
		}
		if(this.lockCallback != null) {
			let ratio = this.getPixelRatio();
			this.lockCallback(e.movementX * ratio,e.movementY * ratio);
		} else {
			this.event(new hxd_Event(hxd_EventKind.EMove,this.get_mouseX(),this.get_mouseY()));
		}
	}
	onMouseWheel(e) {
		let ev = new hxd_Event(hxd_EventKind.EWheel,this.get_mouseX(),this.get_mouseY());
		ev.wheelDelta = e.deltaY / 120;
		this.event(ev);
	}
	onTouchStart(e) {
		e.preventDefault();
		let x;
		let y;
		let ev;
		let _g = 0;
		let _g1 = e.changedTouches;
		while(_g < _g1.length) {
			let touch = _g1[_g];
			++_g;
			x = Math.round((touch.clientX - this.canvasPos.left) * this.getPixelRatio());
			y = Math.round((touch.clientY - this.canvasPos.top) * this.getPixelRatio());
			ev = new hxd_Event(hxd_EventKind.EPush,x,y);
			ev.touchId = touch.identifier;
			this.event(ev);
		}
	}
	onTouchMove(e) {
		e.preventDefault();
		let x;
		let y;
		let ev;
		let _g = 0;
		let _g1 = e.changedTouches;
		while(_g < _g1.length) {
			let touch = _g1[_g];
			++_g;
			x = Math.round((touch.clientX - this.canvasPos.left) * this.getPixelRatio());
			y = Math.round((touch.clientY - this.canvasPos.top) * this.getPixelRatio());
			ev = new hxd_Event(hxd_EventKind.EMove,x,y);
			ev.touchId = touch.identifier;
			this.event(ev);
		}
	}
	onTouchEnd(e) {
		e.preventDefault();
		let x;
		let y;
		let ev;
		let _g = 0;
		let _g1 = e.changedTouches;
		while(_g < _g1.length) {
			let touch = _g1[_g];
			++_g;
			x = Math.round((touch.clientX - this.canvasPos.left) * this.getPixelRatio());
			y = Math.round((touch.clientY - this.canvasPos.top) * this.getPixelRatio());
			ev = new hxd_Event(hxd_EventKind.ERelease,x,y);
			ev.touchId = touch.identifier;
			this.event(ev);
		}
	}
	onKeyUp(e) {
		let ev = new hxd_Event(hxd_EventKind.EKeyUp,this.get_mouseX(),this.get_mouseY());
		ev.keyCode = e.keyCode;
		this.event(ev);
		if(!this.propagateKeyEvents) {
			e.preventDefault();
			e.stopPropagation();
		}
	}
	onKeyDown(e) {
		let ev = new hxd_Event(hxd_EventKind.EKeyDown,this.get_mouseX(),this.get_mouseY());
		ev.keyCode = e.keyCode;
		this.event(ev);
		if(!this.propagateKeyEvents) {
			switch(ev.keyCode) {
			case 8:case 9:case 16:case 17:case 33:case 34:case 35:case 36:case 37:case 38:case 39:case 40:
				e.preventDefault();
				break;
			default:
			}
			e.stopPropagation();
		}
	}
	onKeyPress(e) {
		let ev = new hxd_Event(hxd_EventKind.ETextInput,this.get_mouseX(),this.get_mouseY());
		ev.charCode = e.charCode;
		this.event(ev);
		if(!this.propagateKeyEvents) {
			e.preventDefault();
			e.stopPropagation();
		}
	}
	onFocus(b) {
		this.event(new hxd_Event(b ? hxd_EventKind.EFocus : hxd_EventKind.EFocusLost));
		this.focused = b;
	}
	set_displayMode(m) {
		if(!js_Browser.get_supported()) {
			return m;
		}
		let doc = window.document;
		let elt = doc.documentElement;
		let fullscreen = m != hxd_DisplayMode.Windowed;
		if(doc.fullscreenElement == elt == fullscreen) {
			return hxd_DisplayMode.Windowed;
		}
		if(m != hxd_DisplayMode.Windowed) {
			elt.requestFullscreen();
		} else {
			doc.exitFullscreen();
		}
		return m;
	}
	static getInstance() {
		if(hxd_Window.inst == null) {
			hxd_Window.inst = new hxd_Window();
		}
		return hxd_Window.inst;
	}
}
$hxClasses["hxd.Window"] = hxd_Window;
hxd_Window.__name__ = "hxd.Window";
Object.assign(hxd_Window.prototype, {
	__class__: hxd_Window
	,resizeEvents: null
	,eventTargets: null
	,propagateKeyEvents: null
	,curMouseX: null
	,curMouseY: null
	,_mouseLock: null
	,canvas: null
	,element: null
	,canvasPos: null
	,curW: null
	,curH: null
	,focused: null
	,observer: null
	,lockCallback: null
	,useScreenPixels: null
});
class js_Browser {
	static get_supported() {
		if(typeof(window) != "undefined" && typeof(window.location) != "undefined") {
			return typeof(window.location.protocol) == "string";
		} else {
			return false;
		}
	}
	static getLocalStorage() {
		try {
			let s = window.localStorage;
			s.getItem("");
			if(s.length == 0) {
				let key = "_hx_" + Math.random();
				s.setItem(key,key);
				s.removeItem(key);
			}
			return s;
		} catch( _g ) {
			return null;
		}
	}
}
$hxClasses["js.Browser"] = js_Browser;
js_Browser.__name__ = "js.Browser";
class hxd_System {
	static setLoop(f) {
		if(!hxd_System.loopInit) {
			hxd_System.loopInit = true;
			hxd_System.browserLoop();
		}
		hxd_System.loopFunc = f;
	}
	static browserLoop() {
		if(js_Browser.get_supported()) {
			let $window = window;
			let rqf = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame;
			if(hxd_System.fpsLimit > 0) {
				window.setTimeout(function() {
					return rqf(hxd_System.browserLoop);
				},1000 / hxd_System.fpsLimit);
			} else {
				rqf(hxd_System.browserLoop);
			}
		} else {
			throw haxe_Exception.thrown("Cannot use browserLoop without Browser support nor defining nodejs + hxnodejs");
		}
		if(hxd_System.loopFunc != null) {
			hxd_System.loopFunc();
		}
	}
	static start(callb) {
		callb();
	}
	static setNativeCursor(c) {
		if(hxd_System.currentNativeCursor != null && Type.enumEq(c,hxd_System.currentNativeCursor)) {
			return;
		}
		hxd_System.currentNativeCursor = c;
		hxd_System.currentCustomCursor = null;
		let canvas = hxd_Window.getInstance().canvas;
		if(canvas != null) {
			let tmp;
			switch(c._hx_index) {
			case 0:
				tmp = "default";
				break;
			case 1:
				tmp = "pointer";
				break;
			case 2:
				tmp = "move";
				break;
			case 3:
				tmp = "text";
				break;
			case 4:
				tmp = "none";
				break;
			case 5:
				let _g = c.custom;
				if(_g.alloc == null) {
					_g.alloc = [];
					let _g1 = 0;
					let _g2 = _g.frames;
					while(_g1 < _g2.length) {
						let frame = _g2[_g1];
						++_g1;
						_g.alloc.push("url(\"" + frame.ctx.canvas.toDataURL("image/png") + "\") " + _g.offsetX + " " + _g.offsetY + ", default");
					}
				}
				if(_g.frames.length > 1) {
					hxd_System.currentCustomCursor = _g;
					_g.reset();
				}
				tmp = _g.alloc[_g.frameIndex];
				break;
			case 6:
				throw haxe_Exception.thrown("assert");
			}
			canvas.style.cursor = tmp;
		}
	}
	static getDefaultFrameRate() {
		return 60.;
	}
	static getValue(s) {
		switch(s._hx_index) {
		case 0:
			if(hxd_System.get_platform() != hxd_Platform.Android) {
				return hxd_System.get_platform() == hxd_Platform.IOS;
			} else {
				return true;
			}
			break;
		case 1:
			return true;
		case 2:
			if(hxd_System.get_platform() != hxd_Platform.Android) {
				return hxd_System.get_platform() == hxd_Platform.IOS;
			} else {
				return true;
			}
			break;
		}
	}
	static updateCursor() {
		if(hxd_System.currentCustomCursor != null) {
			let change = hxd_System.currentCustomCursor.update(hxd_Timer.elapsedTime);
			if(change != -1) {
				let canvas = hxd_Window.getInstance().canvas;
				if(canvas != null) {
					canvas.style.cursor = hxd_System.currentCustomCursor.alloc[change];
				}
			}
		}
	}
	static getClipboardText() {
		return null;
	}
	static setClipboardText(text) {
		return false;
	}
	static get_platform() {
		let ua = $global.navigator.userAgent.toLowerCase();
		if(ua.indexOf("android") >= 0) {
			return hxd_Platform.Android;
		} else if(ua.indexOf("ipad") >= 0 || ua.indexOf("iphone") >= 0 || ua.indexOf("ipod") >= 0) {
			return hxd_Platform.IOS;
		} else {
			return hxd_Platform.PC;
		}
	}
}
$hxClasses["hxd.System"] = hxd_System;
hxd_System.__name__ = "hxd.System";
var hxd_DisplayMode = $hxEnums["hxd.DisplayMode"] = { __ename__:true,__constructs__:null
	,Windowed: {_hx_name:"Windowed",_hx_index:0,__enum__:"hxd.DisplayMode",toString:$estr}
	,Borderless: {_hx_name:"Borderless",_hx_index:1,__enum__:"hxd.DisplayMode",toString:$estr}
	,Fullscreen: {_hx_name:"Fullscreen",_hx_index:2,__enum__:"hxd.DisplayMode",toString:$estr}
	,FullscreenResize: {_hx_name:"FullscreenResize",_hx_index:3,__enum__:"hxd.DisplayMode",toString:$estr}
};
hxd_DisplayMode.__constructs__ = [hxd_DisplayMode.Windowed,hxd_DisplayMode.Borderless,hxd_DisplayMode.Fullscreen,hxd_DisplayMode.FullscreenResize];
hxd_DisplayMode.__empty_constructs__ = [hxd_DisplayMode.Windowed,hxd_DisplayMode.Borderless,hxd_DisplayMode.Fullscreen,hxd_DisplayMode.FullscreenResize];
class hxd_earcut_EarNode {
	constructor() {
	}
}
$hxClasses["hxd.earcut.EarNode"] = hxd_earcut_EarNode;
hxd_earcut_EarNode.__name__ = "hxd.earcut.EarNode";
Object.assign(hxd_earcut_EarNode.prototype, {
	__class__: hxd_earcut_EarNode
	,next: null
	,prev: null
	,nextZ: null
	,prevZ: null
	,allocNext: null
	,x: null
	,y: null
	,i: null
	,z: null
	,steiner: null
});
class hxd_earcut_Earcut {
	constructor() {
	}
	triangulate_gui_GPoint(points,holes) {
		let hasHoles = holes != null && holes.length > 0;
		let outerLen = hasHoles ? holes[0] : points.length;
		if(outerLen < 3) {
			return [];
		}
		let root = this.setLinkedList_triangulate_T(points,0,outerLen,true);
		if(holes != null) {
			root = this.eliminateHoles_triangulate_T(points,holes,root);
		}
		return this.triangulateNode(root,points.length > 80);
	}
	triangulate_h2d_GPoint(points,holes) {
		let hasHoles = holes != null && holes.length > 0;
		let outerLen = hasHoles ? holes[0] : points.length;
		if(outerLen < 3) {
			return [];
		}
		let root = this.setLinkedList_triangulate_T(points,0,outerLen,true);
		if(holes != null) {
			root = this.eliminateHoles_triangulate_T(points,holes,root);
		}
		return this.triangulateNode(root,points.length > 80);
	}
	eliminateHoles_triangulate_T(points,holes,root) {
		let queue = [];
		let _g = 0;
		let _g1 = holes.length;
		while(_g < _g1) {
			let i = _g++;
			let s = holes[i];
			let e = i == holes.length - 1 ? points.length : holes[i + 1];
			let node = this.setLinkedList_eliminateHoles_T(points,s,e,false);
			if(node == node.next) {
				node.steiner = true;
			}
			queue.push(this.getLeftmost(node));
		}
		queue.sort($bind(this,this.compareX));
		let _g2 = 0;
		while(_g2 < queue.length) {
			let q = queue[_g2];
			++_g2;
			this.eliminateHole(q,root);
			root = this.filterPoints(root,root.next);
		}
		return root;
	}
	setLinkedList_eliminateHoles_T(points,start,end,clockwise) {
		let sum = 0.;
		let j = end - 1;
		let _g = start;
		while(_g < end) {
			let i = _g++;
			sum += (points[j].x - points[i].x) * (points[i].y + points[j].y);
			j = i;
		}
		let last = null;
		let n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = -1;
		n.z = -1;
		n.x = 0;
		n.y = 0;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		let node = n;
		let first = node;
		if(clockwise == sum > 0) {
			let _g = start;
			while(_g < end) {
				let i = _g++;
				let p = points[i];
				let n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = p.x;
				n.y = p.y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
			}
		} else {
			let i = end - 1;
			while(i >= start) {
				let p = points[i];
				let n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = p.x;
				n.y = p.y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
				--i;
			}
		}
		node.next = first.next;
		node.next.prev = node;
		return node;
	}
	setLinkedList_triangulate_T(points,start,end,clockwise) {
		let sum = 0.;
		let j = end - 1;
		let _g = start;
		while(_g < end) {
			let i = _g++;
			sum += (points[j].x - points[i].x) * (points[i].y + points[j].y);
			j = i;
		}
		let last = null;
		let n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = -1;
		n.z = -1;
		n.x = 0;
		n.y = 0;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		let node = n;
		let first = node;
		if(clockwise == sum > 0) {
			let _g = start;
			while(_g < end) {
				let i = _g++;
				let p = points[i];
				let n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = p.x;
				n.y = p.y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
			}
		} else {
			let i = end - 1;
			while(i >= start) {
				let p = points[i];
				let n = this.cache;
				if(n == null) {
					n = new hxd_earcut_EarNode();
					n.allocNext = this.allocated;
					this.allocated = n;
				} else {
					this.cache = n.next;
				}
				n.i = i;
				n.z = -1;
				n.x = p.x;
				n.y = p.y;
				n.next = null;
				n.prev = node;
				n.steiner = false;
				n.prevZ = null;
				n.nextZ = null;
				if(node != null) {
					node.next = n;
				}
				node = n;
				--i;
			}
		}
		node.next = first.next;
		node.next.prev = node;
		return node;
	}
	triangulateNode(root,useZOrder) {
		this.triangles = [];
		root = this.filterPoints(root);
		if(useZOrder && root != null) {
			let maxX = root.x;
			this.minX = maxX;
			let maxY = root.y;
			this.minY = maxY;
			let p = root.next;
			while(p != root) {
				let x = p.x;
				let y = p.y;
				if(x < this.minX) {
					this.minX = x;
				}
				if(y < this.minY) {
					this.minY = y;
				}
				if(x > maxX) {
					maxX = x;
				}
				if(y > maxY) {
					maxY = y;
				}
				p = p.next;
			}
			let a = maxX - this.minX;
			let b = maxY - this.minY;
			this.size = a < b ? b : a;
			this.hasSize = true;
		} else {
			this.hasSize = false;
		}
		this.earcutLinked(root);
		let result = this.triangles;
		this.triangles = null;
		let n = this.allocated;
		if(this.cache != null) {
			while(n != this.cache) n = n.allocNext;
			n = n.allocNext;
		}
		while(n != null) {
			n.next = this.cache;
			this.cache = n;
			n = n.allocNext;
		}
		return result;
	}
	eliminateHole(hole,root) {
		root = this.findHoleBridge(hole,root);
		if(root != null) {
			let b = this.splitPolygon(root,hole);
			this.filterPoints(b,b.next);
		}
	}
	findHoleBridge(hole,root) {
		let p = root;
		let hx = hole.x;
		let hy = hole.y;
		let qx = -Infinity;
		let m = null;
		do {
			if(hy <= p.y && hy >= p.next.y) {
				let x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
				if(x <= hx && x > qx) {
					qx = x;
					m = p.x < p.next.x ? p : p.next;
				}
			}
			p = p.next;
		} while(p != root);
		if(m == null) {
			return null;
		}
		let stop = m;
		let tanMin = Infinity;
		let tan;
		p = m.next;
		while(p != stop) {
			let tmp;
			if(hx >= p.x && p.x >= m.x) {
				let ax = hy < m.y ? hx : qx;
				let bx = m.x;
				let by = m.y;
				let cx = hy < m.y ? qx : hx;
				let px = p.x;
				let py = p.y;
				tmp = (cx - px) * (hy - py) - (ax - px) * (hy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (hy - py) >= 0 && (bx - px) * (hy - py) - (cx - px) * (by - py) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				let f = hy - p.y;
				tan = (f < 0 ? -f : f) / (hx - p.x);
				let tmp;
				if(tan < tanMin || tan == tanMin && p.x > m.x) {
					let p1 = p.prev;
					let r = p.next;
					if((p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) < 0) {
						let r = p.next;
						if((hole.y - p.y) * (r.x - hole.x) - (hole.x - p.x) * (r.y - hole.y) >= 0) {
							let q = p.prev;
							tmp = (q.y - p.y) * (hole.x - q.x) - (q.x - p.x) * (hole.y - q.y) >= 0;
						} else {
							tmp = false;
						}
					} else {
						let r = p.prev;
						if(!((hole.y - p.y) * (r.x - hole.x) - (hole.x - p.x) * (r.y - hole.y) < 0)) {
							let q = p.next;
							tmp = (q.y - p.y) * (hole.x - q.x) - (q.x - p.x) * (hole.y - q.y) < 0;
						} else {
							tmp = true;
						}
					}
				} else {
					tmp = false;
				}
				if(tmp) {
					m = p;
					tanMin = tan;
				}
			}
			p = p.next;
		}
		return m;
	}
	getLeftmost(node) {
		let p = node;
		let leftmost = node;
		do {
			if(p.x < leftmost.x) {
				leftmost = p;
			}
			p = p.next;
		} while(p != node);
		return leftmost;
	}
	compareX(a,b) {
		if(a.x - b.x > 0) {
			return 1;
		} else {
			return -1;
		}
	}
	filterPoints(start,end) {
		if(start == null) {
			return start;
		}
		if(end == null) {
			end = start;
		}
		let p = start;
		let again;
		do {
			again = false;
			let tmp;
			if(!p.steiner) {
				let p2 = p.next;
				if(!(p.x == p2.x && p.y == p2.y)) {
					let p1 = p.prev;
					let r = p.next;
					tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) == 0;
				} else {
					tmp = true;
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				p.next.prev = p.prev;
				p.prev.next = p.next;
				if(p.prevZ != null) {
					p.prevZ.nextZ = p.nextZ;
				}
				if(p.nextZ != null) {
					p.nextZ.prevZ = p.prevZ;
				}
				end = p.prev;
				p = end;
				if(p == p.next) {
					return null;
				}
				again = true;
			} else {
				p = p.next;
			}
		} while(again || p != end);
		return end;
	}
	earcutLinked(ear,pass) {
		if(pass == null) {
			pass = 0;
		}
		if(ear == null) {
			return;
		}
		if(pass == 0 && this.hasSize) {
			this.indexCurve(ear);
		}
		let stop = ear;
		let prev;
		let next;
		while(ear.prev != ear.next) {
			prev = ear.prev;
			next = ear.next;
			if(this.hasSize ? this.isEarHashed(ear) : this.isEar(ear)) {
				this.triangles.push(prev.i);
				this.triangles.push(ear.i);
				this.triangles.push(next.i);
				ear.next.prev = ear.prev;
				ear.prev.next = ear.next;
				if(ear.prevZ != null) {
					ear.prevZ.nextZ = ear.nextZ;
				}
				if(ear.nextZ != null) {
					ear.nextZ.prevZ = ear.prevZ;
				}
				ear = next.next;
				stop = next.next;
				continue;
			}
			ear = next;
			if(next == stop) {
				switch(pass) {
				case 0:
					this.earcutLinked(this.filterPoints(next),1);
					break;
				case 1:
					ear = this.cureLocalIntersections(next);
					this.earcutLinked(ear,2);
					break;
				case 2:
					this.splitEarcut(next);
					break;
				}
				break;
			}
		}
	}
	isEar(ear) {
		let a = ear.prev;
		let c = ear.next;
		if((ear.y - a.y) * (c.x - ear.x) - (ear.x - a.x) * (c.y - ear.y) >= 0) {
			return false;
		}
		let p = ear.next.next;
		while(p != ear.prev) {
			let tmp;
			let ax = a.x;
			let ay = a.y;
			let bx = ear.x;
			let by = ear.y;
			let cx = c.x;
			let cy = c.y;
			let px = p.x;
			let py = p.y;
			if((cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0) {
				let p1 = p.prev;
				let r = p.next;
				tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			p = p.next;
		}
		return true;
	}
	isEarHashed(ear) {
		let a = ear.prev;
		let c = ear.next;
		if((ear.y - a.y) * (c.x - ear.x) - (ear.x - a.x) * (c.y - ear.y) >= 0) {
			return false;
		}
		let minTX = a.x < ear.x ? a.x < c.x ? a.x : c.x : ear.x < c.x ? ear.x : c.x;
		let minTY = a.y < ear.y ? a.y < c.y ? a.y : c.y : ear.y < c.y ? ear.y : c.y;
		let maxTX = a.x > ear.x ? a.x > c.x ? a.x : c.x : ear.x > c.x ? ear.x : c.x;
		let maxTY = a.y > ear.y ? a.y > c.y ? a.y : c.y : ear.y > c.y ? ear.y : c.y;
		let x = 32767 * (minTX - this.minX) / this.size | 0;
		let y = 32767 * (minTY - this.minY) / this.size | 0;
		x = (x | x << 8) & 16711935;
		x = (x | x << 4) & 252645135;
		x = (x | x << 2) & 858993459;
		x = (x | x << 1) & 1431655765;
		y = (y | y << 8) & 16711935;
		y = (y | y << 4) & 252645135;
		y = (y | y << 2) & 858993459;
		y = (y | y << 1) & 1431655765;
		let minZ = x | y << 1;
		let x1 = 32767 * (maxTX - this.minX) / this.size | 0;
		let y1 = 32767 * (maxTY - this.minY) / this.size | 0;
		x1 = (x1 | x1 << 8) & 16711935;
		x1 = (x1 | x1 << 4) & 252645135;
		x1 = (x1 | x1 << 2) & 858993459;
		x1 = (x1 | x1 << 1) & 1431655765;
		y1 = (y1 | y1 << 8) & 16711935;
		y1 = (y1 | y1 << 4) & 252645135;
		y1 = (y1 | y1 << 2) & 858993459;
		y1 = (y1 | y1 << 1) & 1431655765;
		let maxZ = x1 | y1 << 1;
		let p = ear.nextZ;
		while(p != null && p.z <= maxZ) {
			let tmp;
			let tmp1;
			if(p != ear.prev && p != ear.next) {
				let ax = a.x;
				let ay = a.y;
				let bx = ear.x;
				let by = ear.y;
				let cx = c.x;
				let cy = c.y;
				let px = p.x;
				let py = p.y;
				tmp1 = (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				let p1 = p.prev;
				let r = p.next;
				tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			p = p.nextZ;
		}
		p = ear.prevZ;
		while(p != null && p.z >= minZ) {
			let tmp;
			let tmp1;
			if(p != ear.prev && p != ear.next) {
				let ax = a.x;
				let ay = a.y;
				let bx = ear.x;
				let by = ear.y;
				let cx = c.x;
				let cy = c.y;
				let px = p.x;
				let py = p.y;
				tmp1 = (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				let p1 = p.prev;
				let r = p.next;
				tmp = (p.y - p1.y) * (r.x - p.x) - (p.x - p1.x) * (r.y - p.y) >= 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return false;
			}
			p = p.prevZ;
		}
		return true;
	}
	cureLocalIntersections(start) {
		let p = start;
		do {
			let a = p.prev;
			let b = p.next.next;
			let tmp;
			let tmp1;
			let p2 = p.next;
			if((p.y - a.y) * (p2.x - p.x) - (p.x - a.x) * (p2.y - p.y) > 0 != (p.y - a.y) * (b.x - p.x) - (p.x - a.x) * (b.y - p.y) > 0 && (b.y - p2.y) * (a.x - b.x) - (b.x - p2.x) * (a.y - b.y) > 0 != (b.y - p2.y) * (p.x - b.x) - (b.x - p2.x) * (p.y - b.y) > 0) {
				let p = a.prev;
				let r = a.next;
				if((a.y - p.y) * (r.x - a.x) - (a.x - p.x) * (r.y - a.y) < 0) {
					let r = a.next;
					if((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) >= 0) {
						let q = a.prev;
						tmp1 = (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) >= 0;
					} else {
						tmp1 = false;
					}
				} else {
					let r = a.prev;
					if(!((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) < 0)) {
						let q = a.next;
						tmp1 = (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) < 0;
					} else {
						tmp1 = true;
					}
				}
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				let p = b.prev;
				let r = b.next;
				if((b.y - p.y) * (r.x - b.x) - (b.x - p.x) * (r.y - b.y) < 0) {
					let r = b.next;
					if((a.y - b.y) * (r.x - a.x) - (a.x - b.x) * (r.y - a.y) >= 0) {
						let q = b.prev;
						tmp = (q.y - b.y) * (a.x - q.x) - (q.x - b.x) * (a.y - q.y) >= 0;
					} else {
						tmp = false;
					}
				} else {
					let r = b.prev;
					if(!((a.y - b.y) * (r.x - a.x) - (a.x - b.x) * (r.y - a.y) < 0)) {
						let q = b.next;
						tmp = (q.y - b.y) * (a.x - q.x) - (q.x - b.x) * (a.y - q.y) < 0;
					} else {
						tmp = true;
					}
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				this.triangles.push(a.i);
				this.triangles.push(p.i);
				this.triangles.push(b.i);
				p.next.prev = p.prev;
				p.prev.next = p.next;
				if(p.prevZ != null) {
					p.prevZ.nextZ = p.nextZ;
				}
				if(p.nextZ != null) {
					p.nextZ.prevZ = p.prevZ;
				}
				let p1 = p.next;
				p1.next.prev = p1.prev;
				p1.prev.next = p1.next;
				if(p1.prevZ != null) {
					p1.prevZ.nextZ = p1.nextZ;
				}
				if(p1.nextZ != null) {
					p1.nextZ.prevZ = p1.prevZ;
				}
				start = b;
				p = b;
			}
			p = p.next;
		} while(p != start);
		return p;
	}
	splitEarcut(start) {
		let a = start;
		do {
			let b = a.next.next;
			while(b != a.prev) {
				if(a.i != b.i && this.isValidDiagonal(a,b)) {
					let c = this.splitPolygon(a,b);
					a = this.filterPoints(a,a.next);
					c = this.filterPoints(c,c.next);
					this.earcutLinked(a);
					this.earcutLinked(c);
					return;
				}
				b = b.next;
			}
			a = a.next;
		} while(a != start);
	}
	splitPolygon(a,b) {
		let last = null;
		let n = this.cache;
		if(n == null) {
			n = new hxd_earcut_EarNode();
			n.allocNext = this.allocated;
			this.allocated = n;
		} else {
			this.cache = n.next;
		}
		n.i = a.i;
		n.z = -1;
		n.x = a.x;
		n.y = a.y;
		n.next = null;
		n.prev = last;
		n.steiner = false;
		n.prevZ = null;
		n.nextZ = null;
		let a2 = n;
		let last1 = null;
		let n1 = this.cache;
		if(n1 == null) {
			n1 = new hxd_earcut_EarNode();
			n1.allocNext = this.allocated;
			this.allocated = n1;
		} else {
			this.cache = n1.next;
		}
		n1.i = b.i;
		n1.z = -1;
		n1.x = b.x;
		n1.y = b.y;
		n1.next = null;
		n1.prev = last1;
		n1.steiner = false;
		n1.prevZ = null;
		n1.nextZ = null;
		let b2 = n1;
		let an = a.next;
		let bp = b.prev;
		a.next = b;
		b.prev = a;
		a2.next = an;
		an.prev = a2;
		b2.next = a2;
		a2.prev = b2;
		bp.next = b2;
		b2.prev = bp;
		return b2;
	}
	isValidDiagonal(a,b) {
		if(!(a.x == b.x && a.y == b.y)) {
			let tmp;
			let tmp1;
			if(a.next.i != b.i && a.prev.i != b.i && !this.intersectsPolygon(a,b)) {
				let p = a.prev;
				let r = a.next;
				if((a.y - p.y) * (r.x - a.x) - (a.x - p.x) * (r.y - a.y) < 0) {
					let r = a.next;
					if((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) >= 0) {
						let q = a.prev;
						tmp1 = (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) >= 0;
					} else {
						tmp1 = false;
					}
				} else {
					let r = a.prev;
					if(!((b.y - a.y) * (r.x - b.x) - (b.x - a.x) * (r.y - b.y) < 0)) {
						let q = a.next;
						tmp1 = (q.y - a.y) * (b.x - q.x) - (q.x - a.x) * (b.y - q.y) < 0;
					} else {
						tmp1 = true;
					}
				}
			} else {
				tmp1 = false;
			}
			if(tmp1) {
				let p = b.prev;
				let r = b.next;
				if((b.y - p.y) * (r.x - b.x) - (b.x - p.x) * (r.y - b.y) < 0) {
					let r = b.next;
					if((a.y - b.y) * (r.x - a.x) - (a.x - b.x) * (r.y - a.y) >= 0) {
						let q = b.prev;
						tmp = (q.y - b.y) * (a.x - q.x) - (q.x - b.x) * (a.y - q.y) >= 0;
					} else {
						tmp = false;
					}
				} else {
					let r = b.prev;
					if(!((a.y - b.y) * (r.x - a.x) - (a.x - b.x) * (r.y - a.y) < 0)) {
						let q = b.next;
						tmp = (q.y - b.y) * (a.x - q.x) - (q.x - b.x) * (a.y - q.y) < 0;
					} else {
						tmp = true;
					}
				}
			} else {
				tmp = false;
			}
			if(tmp) {
				return this.middleInside(a,b);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	middleInside(a,b) {
		let p = a;
		let inside = false;
		let px = (a.x + b.x) / 2;
		let py = (a.y + b.y) / 2;
		do {
			if(p.y > py != p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
				inside = !inside;
			}
			p = p.next;
		} while(p != a);
		return inside;
	}
	intersectsPolygon(a,b) {
		let p = a;
		do {
			let tmp;
			if(p.i != a.i && p.next.i != a.i && p.i != b.i && p.next.i != b.i) {
				let q1 = p.next;
				tmp = (q1.y - p.y) * (a.x - q1.x) - (q1.x - p.x) * (a.y - q1.y) > 0 != (q1.y - p.y) * (b.x - q1.x) - (q1.x - p.x) * (b.y - q1.y) > 0 && (b.y - a.y) * (p.x - b.x) - (b.x - a.x) * (p.y - b.y) > 0 != (b.y - a.y) * (q1.x - b.x) - (b.x - a.x) * (q1.y - b.y) > 0;
			} else {
				tmp = false;
			}
			if(tmp) {
				return true;
			}
			p = p.next;
		} while(p != a);
		return false;
	}
	indexCurve(start) {
		let p = start;
		do {
			if(p.z < 0) {
				let x = 32767 * (p.x - this.minX) / this.size | 0;
				let y = 32767 * (p.y - this.minY) / this.size | 0;
				x = (x | x << 8) & 16711935;
				x = (x | x << 4) & 252645135;
				x = (x | x << 2) & 858993459;
				x = (x | x << 1) & 1431655765;
				y = (y | y << 8) & 16711935;
				y = (y | y << 4) & 252645135;
				y = (y | y << 2) & 858993459;
				y = (y | y << 1) & 1431655765;
				p.z = x | y << 1;
			}
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
		} while(p != start);
		p.prevZ.nextZ = null;
		p.prevZ = null;
		this.sortLinked(p);
	}
	sortLinked(list) {
		let p;
		let q;
		let e;
		let tail;
		let numMerges;
		let pSize;
		let qSize;
		let inSize = 1;
		do {
			p = list;
			list = null;
			tail = null;
			numMerges = 0;
			while(p != null) {
				++numMerges;
				q = p;
				pSize = 0;
				let _g = 0;
				let _g1 = inSize;
				while(_g < _g1) {
					++_g;
					++pSize;
					q = q.nextZ;
					if(q == null) {
						break;
					}
				}
				qSize = inSize;
				while(pSize > 0 || qSize > 0 && q != null) {
					if(pSize == 0) {
						e = q;
						q = q.nextZ;
						--qSize;
					} else if(qSize == 0 || q == null) {
						e = p;
						p = p.nextZ;
						--pSize;
					} else if(p.z <= q.z) {
						e = p;
						p = p.nextZ;
						--pSize;
					} else {
						e = q;
						q = q.nextZ;
						--qSize;
					}
					if(tail != null) {
						tail.nextZ = e;
					} else {
						list = e;
					}
					e.prevZ = tail;
					tail = e;
				}
				p = q;
			}
			tail.nextZ = null;
			inSize *= 2;
		} while(numMerges > 1);
		return list;
	}
}
$hxClasses["hxd.earcut.Earcut"] = hxd_earcut_Earcut;
hxd_earcut_Earcut.__name__ = "hxd.earcut.Earcut";
Object.assign(hxd_earcut_Earcut.prototype, {
	__class__: hxd_earcut_Earcut
	,triangles: null
	,cache: null
	,allocated: null
	,minX: null
	,minY: null
	,size: null
	,hasSize: null
});
class hxd_fmt_bfnt_FontParser {
	static parse(bytes,path,resolveTile) {
		let tile = null;
		let font = new h2d_Font(null,0);
		let glyphs = font.glyphs;
		font.baseLine = 0;
		let _g = bytes.getInt32(0);
		switch(_g) {
		case 54938946:
			let bytes1 = new haxe_io_BytesInput(bytes);
			bytes1.set_position(bytes1.pos + 4);
			let pageCount = 0;
			while(bytes1.pos < bytes1.totlen) {
				let id = bytes1.readByte();
				let length = bytes1.readInt32();
				let pos = bytes1.pos;
				switch(id) {
				case 1:
					font.size = font.initSize = bytes1.readInt16();
					bytes1.set_position(bytes1.pos + 12);
					font.name = bytes1.readUntil(0);
					break;
				case 2:
					font.lineHeight = bytes1.readUInt16();
					font.baseLine = bytes1.readUInt16();
					bytes1.set_position(bytes1.pos + 4);
					pageCount = bytes1.readUInt16();
					if(pageCount != 1) {
						haxe_Log.trace("Warning: BMF format only supports one page at the moment.",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 224, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
					}
					break;
				case 3:
					let name = bytes1.readUntil(0);
					try {
						font.tilePath = name;
						tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),name]));
					} catch( _g ) {
						haxe_Log.trace("Warning: Could not find referenced font texture at \"" + name + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 30, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
						font.tilePath = new haxe_io_Path(path).file + ".png";
						tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
					}
					break;
				case 4:
					let count = length / 20 | 0;
					while(count > 0) {
						let cid = bytes1.readInt32();
						let t = tile.sub(bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readUInt16(),bytes1.readInt16(),bytes1.readInt16());
						let fc = new h2d_FontChar(t,bytes1.readInt16());
						glyphs.h[cid] = fc;
						bytes1.set_position(bytes1.pos + 2);
						--count;
					}
					break;
				case 5:
					let count1 = length / 10 | 0;
					while(count1 > 0) {
						let first = bytes1.readInt32();
						let key = bytes1.readInt32();
						let fc = glyphs.h[key];
						if(fc != null) {
							fc.addKerning(first,bytes1.readInt16());
						} else {
							bytes1.set_position(bytes1.pos + 2);
						}
						--count1;
					}
					break;
				}
				bytes1.set_position(pos + length);
			}
			break;
		case 1414415938:
			return new hxd_fmt_bfnt_Reader(new haxe_io_BytesInput(bytes)).read(function(tp) {
				try {
					font.tilePath = tp;
					tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),tp]));
				} catch( _g ) {
					haxe_Log.trace("Warning: Could not find referenced font texture at \"" + tp + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 30, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
					font.tilePath = new haxe_io_Path(path).file + ".png";
					tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
				}
				return tile;
			});
		case 1836597052:case 1852794428:
			let xml = Xml.parse(bytes.toString());
			let x = xml.firstElement();
			if(x.nodeType != Xml.Document && x.nodeType != Xml.Element) {
				throw haxe_Exception.thrown("Invalid nodeType " + (x.nodeType == null ? "null" : XmlType.toString(x.nodeType)));
			}
			let xml1 = x;
			if(haxe_xml__$Access_HasNodeAccess.resolve(xml1,"info")) {
				let tmp = haxe_xml__$Access_NodeAccess.resolve(xml1,"info");
				font.name = haxe_xml__$Access_AttribAccess.resolve(tmp,"face");
				let tmp1 = haxe_xml__$Access_AttribAccess.resolve(haxe_xml__$Access_NodeAccess.resolve(xml1,"info"),"size");
				font.size = font.initSize = Std.parseInt(tmp1);
				let tmp2 = haxe_xml__$Access_AttribAccess.resolve(haxe_xml__$Access_NodeAccess.resolve(xml1,"common"),"lineHeight");
				font.lineHeight = Std.parseInt(tmp2);
				let tmp3 = haxe_xml__$Access_AttribAccess.resolve(haxe_xml__$Access_NodeAccess.resolve(xml1,"common"),"base");
				font.baseLine = Std.parseInt(tmp3);
				let p = haxe_xml__$Access_NodeAccess.resolve(xml1,"pages").elements();
				while(p.hasNext()) {
					let p1 = p.next();
					if(haxe_xml__$Access_AttribAccess.resolve(p1,"id") == "0") {
						let tilePath = haxe_xml__$Access_AttribAccess.resolve(p1,"file");
						try {
							font.tilePath = tilePath;
							tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),tilePath]));
						} catch( _g ) {
							haxe_Log.trace("Warning: Could not find referenced font texture at \"" + tilePath + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 30, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
							font.tilePath = new haxe_io_Path(path).file + ".png";
							tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
						}
					} else {
						haxe_Log.trace("Warning: BMF format only supports one page at the moment.",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 66, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
					}
				}
				let chars = haxe_xml__$Access_NodeAccess.resolve(xml1,"chars").elements();
				while(chars.hasNext()) {
					let c = chars.next();
					let t = tile.sub(Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c,"x")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c,"y")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c,"width")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c,"height")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c,"xoffset")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c,"yoffset")));
					let fc = new h2d_FontChar(t,Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c,"xadvance")));
					let kerns = haxe_xml__$Access_NodeAccess.resolve(xml1,"kernings").elements();
					while(kerns.hasNext()) {
						let k = kerns.next();
						if(haxe_xml__$Access_AttribAccess.resolve(k,"second") == haxe_xml__$Access_AttribAccess.resolve(c,"id")) {
							fc.addKerning(Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(k,"first")),Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(k,"amount")));
						}
					}
					let key = Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c,"id"));
					glyphs.h[key] = fc;
				}
			} else {
				font.tilePath = new haxe_io_Path(path).file + ".png";
				tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
				font.name = haxe_xml__$Access_AttribAccess.resolve(xml1,"family");
				let tmp = haxe_xml__$Access_AttribAccess.resolve(xml1,"size");
				font.size = font.initSize = Std.parseInt(tmp);
				let tmp1 = haxe_xml__$Access_AttribAccess.resolve(xml1,"height");
				font.lineHeight = Std.parseInt(tmp1);
				let kernings = [];
				let c = xml1.elements();
				while(c.hasNext()) {
					let c1 = c.next();
					let r = haxe_xml__$Access_AttribAccess.resolve(c1,"rect").split(" ");
					let o = haxe_xml__$Access_AttribAccess.resolve(c1,"offset").split(" ");
					let t = tile.sub(Std.parseInt(r[0]),Std.parseInt(r[1]),Std.parseInt(r[2]),Std.parseInt(r[3]),Std.parseInt(o[0]),Std.parseInt(o[1]));
					let fc = new h2d_FontChar(t,Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(c1,"width")));
					let code = haxe_xml__$Access_AttribAccess.resolve(c1,"code");
					let code1 = code.startsWith("&#") ? Std.parseInt(HxOverrides.substr(code,2,code.length - 3)) : HxOverrides.cca(code,0);
					let k = c1.elements();
					while(k.hasNext()) {
						let k1 = k.next();
						let code = haxe_xml__$Access_AttribAccess.resolve(k1,"id");
						let next = code.startsWith("&#") ? Std.parseInt(HxOverrides.substr(code,2,code.length - 3)) : HxOverrides.cca(code,0);
						let adv = Std.parseInt(haxe_xml__$Access_AttribAccess.resolve(k1,"advance"));
						if(glyphs.h.hasOwnProperty(next)) {
							glyphs.h[next].addKerning(code1,adv);
						} else {
							kernings.push({ prev : code1, next : next, adv : adv});
						}
					}
					glyphs.h[code1] = fc;
				}
				let _g = 0;
				while(_g < kernings.length) {
					let k = kernings[_g];
					++_g;
					let g = glyphs.h[k.next];
					if(g == null) {
						continue;
					}
					g.addKerning(k.prev,k.adv);
				}
			}
			break;
		case 1868983913:
			let lines = bytes.toString().split("\n");
			let reg = new EReg(" *?([0-9a-zA-Z]+)=(\"[^\"]+\"|.+?)(?:[ \r]|$)","");
			let idx;
			let pageCount1 = 0;
			let _g1 = 0;
			while(_g1 < lines.length) {
				let line = lines[_g1];
				++_g1;
				idx = line.indexOf(" ");
				switch(HxOverrides.substr(line,0,idx)) {
				case "char":
					let id = 0;
					let x = 0;
					let y = 0;
					let width = 0;
					let height = 0;
					let xoffset = 0;
					let yoffset = 0;
					let xadvance = 0;
					while(idx < line.length && reg.matchSub(line,idx)) {
						switch(reg.matched(1)) {
						case "height":
							let v = reg.matched(2);
							height = Std.parseInt(HxOverrides.cca(v,0) == 34 ? v.substring(1,v.length - 1) : v);
							break;
						case "id":
							let v1 = reg.matched(2);
							id = Std.parseInt(HxOverrides.cca(v1,0) == 34 ? v1.substring(1,v1.length - 1) : v1);
							break;
						case "width":
							let v2 = reg.matched(2);
							width = Std.parseInt(HxOverrides.cca(v2,0) == 34 ? v2.substring(1,v2.length - 1) : v2);
							break;
						case "x":
							let v3 = reg.matched(2);
							x = Std.parseInt(HxOverrides.cca(v3,0) == 34 ? v3.substring(1,v3.length - 1) : v3);
							break;
						case "xadvance":
							let v4 = reg.matched(2);
							xadvance = Std.parseInt(HxOverrides.cca(v4,0) == 34 ? v4.substring(1,v4.length - 1) : v4);
							break;
						case "xoffset":
							let v5 = reg.matched(2);
							xoffset = Std.parseInt(HxOverrides.cca(v5,0) == 34 ? v5.substring(1,v5.length - 1) : v5);
							break;
						case "y":
							let v6 = reg.matched(2);
							y = Std.parseInt(HxOverrides.cca(v6,0) == 34 ? v6.substring(1,v6.length - 1) : v6);
							break;
						case "yoffset":
							let v7 = reg.matched(2);
							yoffset = Std.parseInt(HxOverrides.cca(v7,0) == 34 ? v7.substring(1,v7.length - 1) : v7);
							break;
						}
						let pos = reg.matchedPos();
						idx = pos.pos + pos.len;
					}
					let t = tile.sub(x,y,width,height,xoffset,yoffset);
					let fc = new h2d_FontChar(t,xadvance);
					glyphs.h[id] = fc;
					break;
				case "common":
					while(idx < line.length && reg.matchSub(line,idx)) {
						switch(reg.matched(1)) {
						case "base":
							let v = reg.matched(2);
							font.baseLine = Std.parseInt(HxOverrides.cca(v,0) == 34 ? v.substring(1,v.length - 1) : v);
							break;
						case "lineHeight":
							let v1 = reg.matched(2);
							font.lineHeight = Std.parseInt(HxOverrides.cca(v1,0) == 34 ? v1.substring(1,v1.length - 1) : v1);
							break;
						case "pages":
							let v2 = reg.matched(2);
							pageCount1 = Std.parseInt(HxOverrides.cca(v2,0) == 34 ? v2.substring(1,v2.length - 1) : v2);
							if(pageCount1 != 1) {
								haxe_Log.trace("Warning: BMF format only supports one page at the moment.",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 157, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
							}
							break;
						}
						let pos = reg.matchedPos();
						idx = pos.pos + pos.len;
					}
					break;
				case "info":
					while(idx < line.length && reg.matchSub(line,idx)) {
						switch(reg.matched(1)) {
						case "face":
							let v = reg.matched(2);
							font.name = HxOverrides.cca(v,0) == 34 ? v.substring(1,v.length - 1) : v;
							break;
						case "size":
							let v1 = reg.matched(2);
							font.size = font.initSize = Std.parseInt(HxOverrides.cca(v1,0) == 34 ? v1.substring(1,v1.length - 1) : v1);
							break;
						}
						let pos = reg.matchedPos();
						idx = pos.pos + pos.len;
					}
					break;
				case "kerning":
					let first = 0;
					let second = 0;
					let advance = 0;
					while(idx < line.length && reg.matchSub(line,idx)) {
						switch(reg.matched(1)) {
						case "amount":
							let v = reg.matched(2);
							advance = Std.parseInt(HxOverrides.cca(v,0) == 34 ? v.substring(1,v.length - 1) : v);
							break;
						case "first":
							let v1 = reg.matched(2);
							first = Std.parseInt(HxOverrides.cca(v1,0) == 34 ? v1.substring(1,v1.length - 1) : v1);
							break;
						case "second":
							let v2 = reg.matched(2);
							second = Std.parseInt(HxOverrides.cca(v2,0) == 34 ? v2.substring(1,v2.length - 1) : v2);
							break;
						}
						let pos = reg.matchedPos();
						idx = pos.pos + pos.len;
					}
					let fc1 = glyphs.h[second];
					if(fc1 != null) {
						fc1.addKerning(first,advance);
					}
					break;
				case "page":
					while(idx < line.length && reg.matchSub(line,idx)) {
						if(reg.matched(1) == "file") {
							let v = reg.matched(2);
							let tilePath = HxOverrides.cca(v,0) == 34 ? v.substring(1,v.length - 1) : v;
							try {
								font.tilePath = tilePath;
								tile = resolveTile(haxe_io_Path.join([haxe_io_Path.directory(path),tilePath]));
							} catch( _g ) {
								haxe_Log.trace("Warning: Could not find referenced font texture at \"" + tilePath + "\", trying to resolve same name as fnt!",{ fileName : "hxd/fmt/bfnt/FontParser.hx", lineNumber : 30, className : "hxd.fmt.bfnt.FontParser", methodName : "parse"});
								font.tilePath = new haxe_io_Path(path).file + ".png";
								tile = resolveTile(haxe_io_Path.withExtension(path,"png"));
							}
						}
						let pos = reg.matchedPos();
						idx = pos.pos + pos.len;
					}
					break;
				}
			}
			break;
		default:
			throw haxe_Exception.thrown("Unknown font signature " + StringTools.hex(_g,8));
		}
		if(glyphs.h[32] == null) {
			let value = tile.sub(0,0,0,0);
			glyphs.h[32] = new h2d_FontChar(value,font.size >> 1);
		}
		font.tile = tile;
		if(font.baseLine == 0) {
			font.baseLine = font.calcBaseLine();
		}
		let fallback = glyphs.h[65533];
		if(fallback == null) {
			fallback = glyphs.h[9633];
		}
		if(fallback == null) {
			fallback = glyphs.h[63];
		}
		if(fallback != null) {
			font.defaultChar = fallback;
		}
		return font;
	}
}
$hxClasses["hxd.fmt.bfnt.FontParser"] = hxd_fmt_bfnt_FontParser;
hxd_fmt_bfnt_FontParser.__name__ = "hxd.fmt.bfnt.FontParser";
class hxd_fmt_bfnt_Reader {
	constructor(i) {
		this.i = i;
	}
	read(resolveTile) {
		if(this.i.readString(4) != "BFNT" || this.i.readByte() != 0) {
			throw haxe_Exception.thrown("Not a BFNT file!");
		}
		let font = null;
		let _g = this.i.readByte();
		if(_g == 1) {
			font = new h2d_Font(this.i.readString(this.i.readUInt16()),this.i.readInt16());
			font.tilePath = this.i.readString(this.i.readUInt16());
			let tile = font.tile = resolveTile(font.tilePath);
			font.lineHeight = this.i.readInt16();
			font.baseLine = this.i.readInt16();
			let defaultChar = this.i.readInt32();
			let id;
			while(true) {
				id = this.i.readInt32();
				if(!(id != 0)) {
					break;
				}
				let t = tile.sub(this.i.readUInt16(),this.i.readUInt16(),this.i.readUInt16(),this.i.readUInt16(),this.i.readInt16(),this.i.readInt16());
				let glyph = new h2d_FontChar(t,this.i.readInt16());
				font.glyphs.h[id] = glyph;
				if(id == defaultChar) {
					font.defaultChar = glyph;
				}
				let prevChar;
				while(true) {
					prevChar = this.i.readInt32();
					if(!(prevChar != 0)) {
						break;
					}
					glyph.addKerning(prevChar,this.i.readInt16());
				}
			}
		} else {
			throw haxe_Exception.thrown("Unknown BFNT version: " + _g);
		}
		return font;
	}
}
$hxClasses["hxd.fmt.bfnt.Reader"] = hxd_fmt_bfnt_Reader;
hxd_fmt_bfnt_Reader.__name__ = "hxd.fmt.bfnt.Reader";
Object.assign(hxd_fmt_bfnt_Reader.prototype, {
	__class__: hxd_fmt_bfnt_Reader
	,i: null
});
class hxd_fmt_hdr_Reader {
	static decode(bytes,sRGB) {
		let f = new haxe_io_BytesInput(bytes);
		let width = 0;
		let height = 0;
		let keys_h = Object.create(null);
		while(true) {
			let line = f.readLine();
			if(line == "") {
				break;
			}
			if(HxOverrides.cca(line,0) == 35) {
				continue;
			}
			let nameValue = line.split("=");
			if(nameValue.length > 1) {
				keys_h[nameValue.shift()] = nameValue.join("=");
			}
		}
		let parts = f.readLine().split(" ");
		height = Std.parseInt(parts[1]);
		width = Std.parseInt(parts[3]);
		let gamma = keys_h["GAMMA"] == "1";
		let data = new haxe_io_Bytes(new ArrayBuffer(width * height * 4 * 4));
		let exposure = 1.0;
		let exp = keys_h["EXPOSURE"];
		if(exp != null) {
			let exp1 = parseFloat(exp);
			if(exp1 < 1e-12 || exp1 < 1e12) {
				exposure = exp1;
			}
		}
		let gammaCorrect = sRGB ? 1 : 0.45454545454545453;
		let _g = [];
		let _g1 = 0;
		while(_g1 < 256) {
			let e = _g1++;
			_g.push(Math.pow(e,gammaCorrect));
		}
		let _g2 = [];
		let _g3 = 0;
		while(_g3 < 256) {
			let e = _g3++;
			_g2.push(Math.pow(Math.pow(2,e - 128) / (256 * exposure),gammaCorrect));
		}
		let _g4 = keys_h["FORMAT"];
		if(_g4 == null) {
			throw haxe_Exception.thrown("Unsupported HDR format " + _g4);
		} else if(_g4 == "32-bit_rle_rgbe") {
			let dataPos = f.pos;
			let scanLen = width * 4;
			let scanLine = new haxe_io_Bytes(new ArrayBuffer(scanLen));
			let widthBE = width >> 8 | (width & 255) << 8;
			let _g1 = 0;
			let _g3 = height;
			while(_g1 < _g3) {
				let y = _g1++;
				let h = bytes.getInt32(dataPos);
				if((h & 65535) != 514 || h >>> 16 != widthBE) {
					scanLine.blit(0,bytes,dataPos,width * 4);
					dataPos += width * 4;
				} else {
					dataPos += 4;
					let p = 0;
					let end = width * 4;
					while(p < end) {
						let len = bytes.b[dataPos++];
						if(len > 128) {
							len -= 128;
							scanLine.fill(p,len,bytes.b[dataPos++]);
						} else {
							scanLine.blit(p,bytes,dataPos,len);
							dataPos += len;
						}
						p += len;
					}
				}
				let pos = y * width * 16;
				let _g3 = 0;
				let _g4 = width;
				while(_g3 < _g4) {
					let x = _g3++;
					let e = _g2[scanLine.b[x + width * 3]];
					data.setFloat(pos,_g[scanLine.b[x]] * e);
					pos += 4;
					data.setFloat(pos,_g[scanLine.b[x + width]] * e);
					pos += 4;
					data.setFloat(pos,_g[scanLine.b[x + (width << 1)]] * e);
					pos += 4;
					data.setFloat(pos,1.0);
					pos += 4;
				}
			}
		} else {
			throw haxe_Exception.thrown("Unsupported HDR format " + _g4);
		}
		return { width : width, height : height, bytes : data, gamma : gamma};
	}
}
$hxClasses["hxd.fmt.hdr.Reader"] = hxd_fmt_hdr_Reader;
hxd_fmt_hdr_Reader.__name__ = "hxd.fmt.hdr.Reader";
class hxd_fs_BytesFileEntry extends hxd_fs_FileEntry {
	constructor(path,bytes) {
		super();
		this.fullPath = path;
		this.name = path.split("/").pop();
		this.bytes = bytes;
	}
	get_path() {
		return this.fullPath;
	}
	getBytes() {
		return this.bytes;
	}
	readBytes(out,outPos,pos,len) {
		if(pos + len > this.bytes.length) {
			len = this.bytes.length - pos;
		}
		if(len < 0) {
			len = 0;
		}
		out.blit(outPos,this.bytes,pos,len);
		return len;
	}
	load(onReady) {
		haxe_Timer.delay(onReady,1);
	}
	loadBitmap(onLoaded) {
		let mime;
		switch(haxe_io_Path.extension(this.fullPath).toLowerCase()) {
		case "gif":
			mime = "image/gif";
			break;
		case "jpeg":case "jpg":
			mime = "image/jpeg";
			break;
		case "png":
			mime = "image/png";
			break;
		default:
			throw haxe_Exception.thrown("Cannot determine image encoding, try adding an extension to the resource path");
		}
		let img = new Image();
		img.onload = function() {
			onLoaded(img);
		};
		let tmp = haxe_crypto_Base64.encode(this.bytes);
		img.src = "data:" + mime + ";base64," + tmp;
	}
	iterator() {
		return new hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry([]);
	}
	get_size() {
		return this.bytes.length;
	}
}
$hxClasses["hxd.fs.BytesFileEntry"] = hxd_fs_BytesFileEntry;
hxd_fs_BytesFileEntry.__name__ = "hxd.fs.BytesFileEntry";
hxd_fs_BytesFileEntry.__super__ = hxd_fs_FileEntry;
Object.assign(hxd_fs_BytesFileEntry.prototype, {
	__class__: hxd_fs_BytesFileEntry
	,fullPath: null
	,bytes: null
});
class hxd_fs_BytesFileSystem {
	constructor() {
	}
	getBytes(path) {
		throw haxe_Exception.thrown("Not implemented");
	}
	exists(path) {
		return this.getBytes(path) != null;
	}
	get(path) {
		let bytes = this.getBytes(path);
		if(bytes == null) {
			throw haxe_Exception.thrown("Resource not found '" + path + "'");
		}
		return new hxd_fs_BytesFileEntry(path,bytes);
	}
	dir(path) {
		throw haxe_Exception.thrown("Not implemented");
	}
}
$hxClasses["hxd.fs.BytesFileSystem"] = hxd_fs_BytesFileSystem;
hxd_fs_BytesFileSystem.__name__ = "hxd.fs.BytesFileSystem";
hxd_fs_BytesFileSystem.__interfaces__ = [hxd_fs_FileSystem];
Object.assign(hxd_fs_BytesFileSystem.prototype, {
	__class__: hxd_fs_BytesFileSystem
});
class hxd_fs_FileInput extends haxe_io_Input {
	constructor(entry) {
		super();
		this.nextReadPos = 0;
		this.cacheLen = 0;
		this.cachePos = 0;
		this.entry = entry;
	}
	fetch(dataSize) {
		if(dataSize == null) {
			dataSize = 256;
		}
		let prev = this.cache;
		if(this.cache == null || this.cache.length < dataSize) {
			this.cache = hxd_fs_FileInput.PREFETCH_CACHE;
			if(this.cache != null && this.cache.length >= dataSize) {
				hxd_fs_FileInput.PREFETCH_CACHE = null;
			} else {
				this.cache = new haxe_io_Bytes(new ArrayBuffer(dataSize));
			}
		}
		let startPos = 0;
		if(this.cacheLen > 0) {
			startPos = this.cacheLen;
			dataSize -= this.cacheLen;
			this.cache.blit(0,prev,this.cachePos,this.cacheLen);
		}
		let read = this.entry.readBytes(this.cache,startPos,this.nextReadPos,dataSize);
		this.cachePos = 0;
		this.cacheLen = startPos + read;
		this.nextReadPos += read;
		if(this.cacheLen == 0) {
			throw haxe_Exception.thrown(new haxe_io_Eof());
		}
	}
	skip(nbytes) {
		if(this.cacheLen > 0) {
			let a = this.cacheLen;
			let k = a > nbytes ? nbytes : a;
			this.cachePos += k;
			this.cacheLen -= k;
			nbytes -= k;
		}
		this.nextReadPos += nbytes;
	}
	readByte() {
		if(this.cacheLen == 0) {
			this.fetch();
		}
		let b = this.cache.b[this.cachePos++];
		this.cacheLen--;
		return b;
	}
	readBytes(b,pos,len) {
		let tot = 0;
		if(len < 256 && this.cacheLen < len) {
			this.fetch();
		}
		if(this.cacheLen > 0) {
			let b1 = this.cacheLen;
			let k = len > b1 ? b1 : len;
			b.blit(pos,this.cache,this.cachePos,k);
			this.cachePos += k;
			this.cacheLen -= k;
			len -= k;
			if(len == 0) {
				return k;
			}
			pos += k;
			tot = k;
		}
		if(len > 0) {
			let k = this.entry.readBytes(b,pos,this.nextReadPos,len);
			this.nextReadPos += k;
			tot += k;
		}
		return tot;
	}
	close() {
		if(this.cache != null && (hxd_fs_FileInput.PREFETCH_CACHE == null || hxd_fs_FileInput.PREFETCH_CACHE.length < this.cache.length)) {
			hxd_fs_FileInput.PREFETCH_CACHE = this.cache;
		}
		this.cache = null;
		this.cacheLen = 0;
	}
}
$hxClasses["hxd.fs.FileInput"] = hxd_fs_FileInput;
hxd_fs_FileInput.__name__ = "hxd.fs.FileInput";
hxd_fs_FileInput.__super__ = haxe_io_Input;
Object.assign(hxd_fs_FileInput.prototype, {
	__class__: hxd_fs_FileInput
	,entry: null
	,cache: null
	,cachePos: null
	,cacheLen: null
	,nextReadPos: null
});
class hxd_fs_LoadedBitmap {
	static toBitmap(this1) {
		let bmp = new hxd_BitmapData(this1.width,this1.height);
		bmp.ctx.drawImage(this1,0,0);
		return bmp;
	}
}
class hxd_fs_NotFound {
	constructor(path) {
		this.path = path;
	}
	toString() {
		return "Resource file not found '" + this.path + "'";
	}
}
$hxClasses["hxd.fs.NotFound"] = hxd_fs_NotFound;
hxd_fs_NotFound.__name__ = "hxd.fs.NotFound";
Object.assign(hxd_fs_NotFound.prototype, {
	__class__: hxd_fs_NotFound
	,path: null
});
class hxd_impl_Allocator {
	constructor() {
	}
	allocBuffer(vertices,stride,flags) {
		let tmp;
		switch(flags) {
		case 0:
			tmp = [h3d_BufferFlag.Dynamic];
			break;
		case 1:
			tmp = [h3d_BufferFlag.UniformBuffer,h3d_BufferFlag.Dynamic];
			break;
		case 2:
			tmp = [h3d_BufferFlag.RawFormat];
			break;
		case 3:
			tmp = [h3d_BufferFlag.Quads,h3d_BufferFlag.RawFormat];
			break;
		}
		return new h3d_Buffer(vertices,stride,tmp);
	}
	ofFloats(v,stride,flags) {
		let nvert = v.pos / stride | 0;
		return this.ofSubFloats(v,stride,nvert,flags);
	}
	ofSubFloats(v,stride,vertices,flags) {
		let b = this.allocBuffer(vertices,stride,flags);
		b.uploadVector(v,0,vertices);
		return b;
	}
	disposeBuffer(b) {
		b.dispose();
	}
	allocIndexBuffer(count) {
		return new h3d_Indexes(count);
	}
	ofIndexes(ib,length) {
		if(length == null) {
			length = -1;
		}
		if(length < 0 && ib != null) {
			length = ib.length;
		}
		let idx = this.allocIndexBuffer(length);
		idx.upload(ib,0,length);
		return idx;
	}
	disposeIndexBuffer(i) {
		i.dispose();
	}
	onContextLost() {
	}
	allocFloats(count) {
		let length = count;
		if(count == null) {
			length = 0;
		}
		return hxd__$FloatBuffer_Float32Expand._new(length);
	}
	disposeFloats(f) {
	}
	static get() {
		if(hxd_impl_Allocator.inst == null) {
			hxd_impl_Allocator.inst = new hxd_impl_Allocator();
		}
		return hxd_impl_Allocator.inst;
	}
}
$hxClasses["hxd.impl.Allocator"] = hxd_impl_Allocator;
hxd_impl_Allocator.__name__ = "hxd.impl.Allocator";
Object.assign(hxd_impl_Allocator.prototype, {
	__class__: hxd_impl_Allocator
});
class hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry {
	constructor(a) {
		this.i = 0;
		this.a = a;
		this.l = this.a.length;
	}
	hasNext() {
		return this.i < this.l;
	}
	next() {
		return this.a[this.i++];
	}
}
$hxClasses["hxd.impl.ArrayIterator_hxd_fs_FileEntry"] = hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry;
hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry.__name__ = "hxd.impl.ArrayIterator_hxd_fs_FileEntry";
Object.assign(hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry.prototype, {
	__class__: hxd_impl_ArrayIterator_$hxd_$fs_$FileEntry
	,i: null
	,l: null
	,a: null
});
class hxd_impl_ArrayIterator_$hxd_$snd_$Channel {
	constructor(a) {
		this.i = 0;
		this.a = a;
		this.l = this.a.length;
	}
	hasNext() {
		return this.i < this.l;
	}
	next() {
		return this.a[this.i++];
	}
}
$hxClasses["hxd.impl.ArrayIterator_hxd_snd_Channel"] = hxd_impl_ArrayIterator_$hxd_$snd_$Channel;
hxd_impl_ArrayIterator_$hxd_$snd_$Channel.__name__ = "hxd.impl.ArrayIterator_hxd_snd_Channel";
Object.assign(hxd_impl_ArrayIterator_$hxd_$snd_$Channel.prototype, {
	__class__: hxd_impl_ArrayIterator_$hxd_$snd_$Channel
	,i: null
	,l: null
	,a: null
});
class hxd_impl_AsyncLoader {
}
$hxClasses["hxd.impl.AsyncLoader"] = hxd_impl_AsyncLoader;
hxd_impl_AsyncLoader.__name__ = "hxd.impl.AsyncLoader";
hxd_impl_AsyncLoader.__isInterface__ = true;
Object.assign(hxd_impl_AsyncLoader.prototype, {
	__class__: hxd_impl_AsyncLoader
	,load: null
	,isSupported: null
});
class hxd_res__$Any_SingleFileSystem extends hxd_fs_BytesFileSystem {
	constructor(path,bytes) {
		super();
		this.path = path;
		this.bytes = bytes;
	}
	getBytes(p) {
		if(p == this.path) {
			return this.bytes;
		} else {
			return null;
		}
	}
}
$hxClasses["hxd.res._Any.SingleFileSystem"] = hxd_res__$Any_SingleFileSystem;
hxd_res__$Any_SingleFileSystem.__name__ = "hxd.res._Any.SingleFileSystem";
hxd_res__$Any_SingleFileSystem.__super__ = hxd_fs_BytesFileSystem;
Object.assign(hxd_res__$Any_SingleFileSystem.prototype, {
	__class__: hxd_res__$Any_SingleFileSystem
	,path: null
	,bytes: null
});
class hxd_res_Resource {
	constructor(entry) {
		if(hxd_res_Resource._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(entry);
	}
	_hx_constructor(entry) {
		this.entry = entry;
	}
	toString() {
		return this.entry.get_path();
	}
	watch(onChanged) {
		if(hxd_res_Resource.LIVE_UPDATE) {
			this.entry.watch(onChanged);
		}
	}
}
$hxClasses["hxd.res.Resource"] = hxd_res_Resource;
hxd_res_Resource.__name__ = "hxd.res.Resource";
Object.assign(hxd_res_Resource.prototype, {
	__class__: hxd_res_Resource
	,entry: null
});
class hxd_res_Any extends hxd_res_Resource {
	constructor(loader,entry) {
		super(entry);
		this.loader = loader;
	}
	toTexture() {
		return this.toImage().toTexture();
	}
	toTile() {
		return this.toImage().toTile();
	}
	toImage() {
		return this.loader.loadCache(this.entry.get_path(),hxd_res_Image);
	}
	toSound() {
		return this.loader.loadCache(this.entry.get_path(),hxd_res_Sound);
	}
	static fromBytes(path,bytes) {
		let fs = new hxd_res__$Any_SingleFileSystem(path,bytes);
		return new hxd_res_Loader(fs).load(path);
	}
}
$hxClasses["hxd.res.Any"] = hxd_res_Any;
hxd_res_Any.__name__ = "hxd.res.Any";
hxd_res_Any.__super__ = hxd_res_Resource;
Object.assign(hxd_res_Any.prototype, {
	__class__: hxd_res_Any
	,loader: null
});
class hxd_res_BitmapFont extends hxd_res_Resource {
	constructor(entry) {
		super(entry);
		this.loader = hxd_res_Loader.currentInstance;
	}
	toFont() {
		if(this.font == null) {
			this.font = hxd_fmt_bfnt_FontParser.parse(this.entry.getBytes(),this.entry.get_path(),$bind(this,this.resolveTile));
		}
		return this.font;
	}
	toSdfFont(size,channel,alphaCutoff,smoothing) {
		if(smoothing == null) {
			smoothing = -1;
		}
		if(alphaCutoff == null) {
			alphaCutoff = 0.5;
		}
		if(channel == null) {
			channel = 0;
		}
		if(this.sdfFonts == null) {
			this.sdfFonts = [];
		}
		if(size == null) {
			size = this.toFont().size;
		}
		let _g = 0;
		let _g1 = this.sdfFonts;
		while(_g < _g1.length) {
			let font = _g1[_g];
			++_g;
			let _g2 = font.type;
			if(_g2._hx_index == 1) {
				if(font.size == size && _g2.channel == channel && _g2.alphaCutoff == alphaCutoff && _g2.smoothing == smoothing) {
					return font;
				}
			}
		}
		let font = hxd_fmt_bfnt_FontParser.parse(this.entry.getBytes(),this.entry.get_path(),$bind(this,this.resolveSdfTile));
		font.type = h2d_FontType.SignedDistanceField(channel,alphaCutoff,smoothing);
		font.resizeTo(size);
		this.sdfFonts.push(font);
		return font;
	}
	resolveSdfTile(path) {
		let tex = this.loader.load(path).toTexture();
		tex.set_filter(h3d_mat_Filter.Linear);
		return h2d_Tile.fromTexture(tex);
	}
	resolveTile(path) {
		return this.loader.load(path).toTile();
	}
}
$hxClasses["hxd.res.BitmapFont"] = hxd_res_BitmapFont;
hxd_res_BitmapFont.__name__ = "hxd.res.BitmapFont";
hxd_res_BitmapFont.__super__ = hxd_res_Resource;
Object.assign(hxd_res_BitmapFont.prototype, {
	__class__: hxd_res_BitmapFont
	,loader: null
	,font: null
	,sdfFonts: null
});
class hxd_res_DefaultFont {
	static get() {
		let engine = h3d_Engine.CURRENT;
		let fnt = engine.resCache.h[hxd_res_DefaultFont.__id__];
		if(fnt == null) {
			let BYTES = hxd_res_Any.fromBytes("hxd/res/defaultFont.png",haxe_Unserializer.run("s3176:iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAACPBJREFUeJztnelypDoMRp2p%:6v3PNjhrlCLX1aLIPBPlWppI03bCG0QOfn8:m0zbr8KupnS9FDqRKAzUOhAvBRfqO:tfrSZ86H:ET79o6Rhc%JzzNSD7Xn:XyEH9RPtP4X:6GDDj6ttR:Hb62d9pmX8b487StA4:DFlup5z5MSWS%tL:f6eG4BXDppGQdtApJEtPm0zkf427Oo1fAxtfO2hDIruGXCLgnAD:jNyzSsKxa18yBphyqQ1jqwBN1zHmgcU3V3jHui9xaArkS0%XzTohOX%jvGauzvjMrlUJXuqSeV07G0ekgTovWS1t61vr0CQAez7nkj7uFIELJqmdN7RWvzil7hnnXV5qLOzSMAmlcQub9ZRuEsaNoq0w5RZbN0rye1ASzplWyAiGEXQVK3kZOdRcgy9:FLoRogI02WNc7rRQw3jzsZAfWB7skR44%3jdo6Wv2qfr4rFuUCZlftrT1jjpezSih4b75ClQDMvrizz%82uA1wMCqsKvUv3YO045rxma2vjY3mpPUvuV1WKDzbLtqfNu9:AjA6tl69QM3Zn1Wfl1M8G:CUW4s6b%sWIEXWtM:omNeXrnaDRm:OyIsE1UOfQ1gCwMOLdFCqWnj8Grl5nsjVakRjHMj1DgnEcQvw%OV0AE0wGisfqTKrbBYrZ4BiB:T4ldE8dPsMxU2oEWgZZtoAyMCq2GxtLlWCFbEB%PGIYWv1kxECq0%TbDKITjpirVr9SW2zC:skqqKdUp%QwwbILKwlgZk2mkBlmUVgPPOI3IbL0GwASY2PiMdbPrfVF6:vVctIq5SoVqNdxtrvWXt1:EguYHVL:ZV4Q8F781%KVwD25r8UagTyYE4TjkllmfrU4udtI%XZdrRcm5c1T%3cPXjq9RqEYTewIrau1a%ODVSBomgeL4cLudedG%H2pah4KBQx8gSnWMC:8AvDKwS0fXU5n59Uf7gAXA1dfG1TtM1Bm2ZtKi%PCGaVlpXKrf67ngeI%uFXoW1WdvNH0ztuV3vNBvAOrC30wR0LG7kX0:p3MjoCqPYfiQNI3BK%BEhq31vfYtS5UkN5lCD%NGWMSBxAWyyeyKkAJYc2Z6JrfqpvGYF0IzxqNWoDoPrSeNJ8POMgtJg76rtSEyDNErGzUF5F3ZOq9wI2D%VtbuBsaFfkNGwBGMtUmy3BjUAtxs3x3LOk8mi7zWB6Xw7leCNlb%LRXkrk%wEOpESIlezxlvM%uSWuzQXNx1Ofjqd5Aah:qW5PGDfbjpZzRCGlbwZ5T0TqMHMVoLgCP56Nj0fqo7mhLOeMGoDPx4wE0sW64mRmXLSDaCZvxPjSeNnAGKx:hxcw8%a3Zkc7tTqjyWgbs:4d3w8wW:7AC42l3zF:dH9H9SGedwO9rmEEz4nMpCXuznFoSS5tf9x9e24ByFjqodKAQio6EjfP9C8duzLHoZ0r8oD%LzRyAZY1XN2umux8n0L3OkeygcdnDzMYTSvQvc47G7g4q3xL2EqE8jhbAN6H9YDJ6TaxBeCduJNy3AjkrghySay8QXOU84lZSQ8plj:ioYuIG%axvLUrcoRxHHGHXelgKzkTWSxtLK:7whM8UaGLzs3qJ7P5IxNI0axh%hbAgxhWMGJ01M%KVKIASXQcipVR7MEz524XboQNoKVwPZPNhkpRjD5yRdM53B0c0qKDvE4X9PVw78JYWPc7usEo9cm1TAa0%R:hh44n1UXz1sjaB0dbJATdGoB:R1Dv:c4DGktSez33TNqW96MZtVo:R53sPLQxvGseCWu7y2d7Kji70MgQRUIwM5nNb%1bc8HyK%MAHiMtq2q5ypaOS39rdTz9jMaac4kg87eDpSsp4%bx:iS3UZLOqMQPM44Y3jGuSoCVabERyaCsj:90qs7TG1soWePZbICViWharvnSgrfTwYsz0gjckvUApHcDOdwa9waDvIGjCFZ:2vwzfVeGj7W%qs4ns0ettbMASJvG:WfJ%JAGHOVvI6GSxtMEUfNENK%FH%NtNaz1qzif7B79mcC2AdbG8zVxyNqMtrGkTQqZWmHUqvJjDJg%BZ9Rf552I8qtY%a:jUMnEG3j9V1RvWgUryfqFyXql1etX2aP:vGER8JWCCLdxhME4OlMbWTdLQCRhA%qX1WegVrZEbtjCjQjsDnKM200Y8nLjDaAx%WdVgg8:zfQY%1620Q8grcxpRDcfQvwMN2ivYm7s4GSRkGZLuRvV5T3AP1tAe08q8qtY38KJo4Ejgglbxh3awCJQyL35l:AjAKwN:5CKozAqpRm7zibBBUCMDJFi:p5GlMKcJUbGAm4aIkdlPCpttK9xz1RxMhzAdVCkDmnE5H:GURPXLta7ypHcz248%GLWR6Q%cL7ZdHRVOddWHPt1VRWX6O1mERXuNt6HmBmooGXnlB178MX3vIr5nhCejkUbf7VhgyalyWwngcjqsorxxg5xy%oDeDZ:Du0Qub%2aP6M%XVfSFK90D6ihjranoC2pUgUVVe0VdUw2bmeEKyASx1OwvWfQ7dPqi1XlFe1Vd0nbu1C:%HEeEObuSH:LyRKzSW6QZKvjDXDNKxqvIsR19a:624vKKvW9Zy5nTw5swQO2zGbODmDNdmpWwBmJ%hNo7n7WAJ5L703FN4DD:Sr3RcK6uar0XVnHvHUbHeDqadawaLFA3jbTwW6tH2aC%5oqgfLXYRGcOab5SKOVvz8sY75AneZATyQd:qyt1ByFjkGoCrR6u8gXLtc2tn:51qD22s7Pwi5Z5jEryNtS6jy6U5qfS8HZwFTWp0ogWdj3Wu0nmPWJ8K3HO62gvoul:dhKbBPPWmp:fdwBXwXNGa8TY92ruBzVG%GpoqnUXtp9CeCdza4JvZLhDqyqb3hT8RRDtH5VmyavKKREn0XCW1f3WiDKWmpTpf7GTQc:F6OpCdC3guJdp5C8CzkTY9JAg8Ekh:bxaAPxVMf28WgP7XMMrWAovwhO8I2gxkC8DibAFYnC0Ai6OFgjeL4Pmm0M2L0dzAzSJY2cDNy:E8ELJ5MdsLWJwtAIuzBWBxtgAszhaAxdkCsDi:AYnqZwd25SoPAAAAAElFTkSuQmCC"));
			let DESC = hxd_res_Any.fromBytes("hxd/res/defaultFont.fnt",haxe_Unserializer.run("s14030:PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPEZvbnQgc2l6ZT0iMTIiIGZhbWlseT0iUGl4ZWwgT3BlcmF0b3IiIGhlaWdodD0iMTYiIHN0eWxlPSJSZWd1bGFyIj4KIDxDaGFyIHdpZHRoPSI0IiBvZmZzZXQ9IjAgMTMiIHJlY3Q9IjEgMTIgMCAwIiBjb2RlPSIgIi8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjIgMyAxIDkiIGNvZGU9IiEiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNCAzIDMgMyIgY29kZT0iJnF1b3Q7Ii8%CiA8Q2hhciB3aWR0aD0iOCIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjggMyA2IDkiIGNvZGU9IiMiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMiIgcmVjdD0iMTUgMSA1IDEzIiBjb2RlPSIkIi8%CiA8Q2hhciB3aWR0aD0iOSIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjIxIDMgNyA5IiBjb2RlPSIlIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjI5IDMgNSA5IiBjb2RlPSImYW1wOyIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMSA0IiByZWN0PSIzNSAzIDEgMyIgY29kZT0iJyIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMSA0IiByZWN0PSIzNyAzIDMgOSIgY29kZT0iKCIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMSA0IiByZWN0PSI0MSAzIDMgOSIgY29kZT0iKSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI0NSAzIDUgNSIgY29kZT0iKiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSI1MSA1IDUgNSIgY29kZT0iKyIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMCAxMiIgcmVjdD0iNTcgMTEgMiAzIiBjb2RlPSIsIi8%CiA8Q2hhciB3aWR0aD0iNiIgb2Zmc2V0PSIxIDgiIHJlY3Q9IjYwIDcgNCAxIiBjb2RlPSItIi8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDEyIiByZWN0PSI2NSAxMSAxIDEiIGNvZGU9Ii4iLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNjcgMyAzIDkiIGNvZGU9Ii8iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNzEgMyA1IDkiIGNvZGU9IjAiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNzcgMyAzIDkiIGNvZGU9IjEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iODEgMyA1IDkiIGNvZGU9IjIiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iODcgMyA1IDkiIGNvZGU9IjMiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iOTMgMyA1IDkiIGNvZGU9IjQiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iOTkgMyA1IDkiIGNvZGU9IjUiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTA1IDMgNSA5IiBjb2RlPSI2Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjExMSAzIDUgOSIgY29kZT0iNyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIxMTcgMyA1IDkiIGNvZGU9IjgiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMSAxNSA1IDkiIGNvZGU9IjkiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgNiIgcmVjdD0iNyAxNyAxIDciIGNvZGU9IjoiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgNiIgcmVjdD0iOSAxNyAyIDkiIGNvZGU9IjsiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNiIgcmVjdD0iMTIgMTcgMyA1IiBjb2RlPSImbHQ7Ii8%CiA8Q2hhciB3aWR0aD0iNiIgb2Zmc2V0PSIxIDciIHJlY3Q9IjE2IDE4IDQgMyIgY29kZT0iPSIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMSA2IiByZWN0PSIyMSAxNyAzIDUiIGNvZGU9Ij4iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjUgMTUgNSA5IiBjb2RlPSI:Ii8%CiA8Q2hhciB3aWR0aD0iOSIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjMxIDE1IDcgOSIgY29kZT0iQCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIzOSAxNSA1IDkiIGNvZGU9IkEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNDUgMTUgNSA5IiBjb2RlPSJCIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjUxIDE1IDUgOSIgY29kZT0iQyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI1NyAxNSA1IDkiIGNvZGU9IkQiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNjMgMTUgNSA5IiBjb2RlPSJFIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjY5IDE1IDUgOSIgY29kZT0iRiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI3NSAxNSA1IDkiIGNvZGU9IkciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iODEgMTUgNSA5IiBjb2RlPSJIIi8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDQiIHJlY3Q9Ijg3IDE1IDEgOSIgY29kZT0iSSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI4OSAxNSA1IDkiIGNvZGU9IkoiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iOTUgMTUgNSA5IiBjb2RlPSJLIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjEwMSAxNSA1IDkiIGNvZGU9IkwiLz4KIDxDaGFyIHdpZHRoPSI5IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTA3IDE1IDcgOSIgY29kZT0iTSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIxMTUgMTUgNSA5IiBjb2RlPSJOIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjEyMSAxNSA1IDkiIGNvZGU9Ik8iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMSAyNyA1IDkiIGNvZGU9IlAiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNyAyNyA1IDkiIGNvZGU9IlEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTMgMjcgNSA5IiBjb2RlPSJSIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjE5IDI3IDUgOSIgY29kZT0iUyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIyNSAyNyA1IDkiIGNvZGU9IlQiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMzEgMjcgNSA5IiBjb2RlPSJVIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjM3IDI3IDUgOSIgY29kZT0iViIvPgogPENoYXIgd2lkdGg9IjkiIG9mZnNldD0iMSA0IiByZWN0PSI0MyAyNyA3IDkiIGNvZGU9IlciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNTEgMjcgNSA5IiBjb2RlPSJYIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjU3IDI3IDUgOSIgY29kZT0iWSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI2MyAyNyA1IDkiIGNvZGU9IloiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNjkgMjcgMyA5IiBjb2RlPSJbIi8%CiA8Q2hhciB3aWR0aD0iNSIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjczIDI3IDMgOSIgY29kZT0iXCIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMSA0IiByZWN0PSI3NyAyNyAzIDkiIGNvZGU9Il0iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iODEgMjcgNSAzIiBjb2RlPSJeIi8%CiA8Q2hhciB3aWR0aD0iNSIgb2Zmc2V0PSIwIDE0IiByZWN0PSI4NyAzNyA1IDEiIGNvZGU9Il8iLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgNCIgcmVjdD0iOTMgMjcgMiAyIiBjb2RlPSJgIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9Ijk2IDI5IDUgNyIgY29kZT0iYSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIxMDIgMjcgNSA5IiBjb2RlPSJiIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjEwOCAyOSA1IDciIGNvZGU9ImMiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTE0IDI3IDUgOSIgY29kZT0iZCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSIxMjAgMjkgNSA3IiBjb2RlPSJlIi8%CiA8Q2hhciB3aWR0aD0iNiIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjEgMzkgNSA5IiBjb2RlPSJmIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjcgNDEgNSA5IiBjb2RlPSJnIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjEzIDM5IDUgOSIgY29kZT0iaCIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMSA0IiByZWN0PSIxOSAzOSAxIDkiIGNvZGU9ImkiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjEgMzkgNSAxMSIgY29kZT0iaiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIyNyAzOSA1IDkiIGNvZGU9ImsiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgNCIgcmVjdD0iMzMgMzkgMSA5IiBjb2RlPSJsIi8%CiA8Q2hhciB3aWR0aD0iOSIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjM1IDQxIDcgNyIgY29kZT0ibSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSI0MyA0MSA1IDciIGNvZGU9Im4iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iNDkgNDEgNSA3IiBjb2RlPSJvIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjU1IDQxIDUgOSIgY29kZT0icCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSI2MSA0MSA1IDkiIGNvZGU9InEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iNjcgNDEgNSA3IiBjb2RlPSJyIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjczIDQxIDUgNyIgY29kZT0icyIvPgogPENoYXIgd2lkdGg9IjYiIG9mZnNldD0iMSA1IiByZWN0PSI3OSA0MCA1IDgiIGNvZGU9InQiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iODUgNDEgNSA3IiBjb2RlPSJ1Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjkxIDQxIDUgNyIgY29kZT0idiIvPgogPENoYXIgd2lkdGg9IjkiIG9mZnNldD0iMSA2IiByZWN0PSI5NyA0MSA3IDciIGNvZGU9InciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iMTA1IDQxIDUgNyIgY29kZT0ieCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSIxMTEgNDEgNSA5IiBjb2RlPSJ5Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjExNyA0MSA1IDciIGNvZGU9InoiLz4KIDxDaGFyIHdpZHRoPSI2IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMSA1NCA0IDkiIGNvZGU9InsiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgNCIgcmVjdD0iNiA1NCAxIDkiIGNvZGU9InwiLz4KIDxDaGFyIHdpZHRoPSI2IiBvZmZzZXQ9IjEgNCIgcmVjdD0iOCA1NCA0IDkiIGNvZGU9In0iLz4KIDxDaGFyIHdpZHRoPSI4IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTMgNTQgNiAyIiBjb2RlPSJ%Ii8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjIwIDU2IDEgOSIgY29kZT0iwqEiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjIgNTQgNSAxMSIgY29kZT0iwqIiLz4KIDxDaGFyIHdpZHRoPSI4IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjggNTQgNiA5IiBjb2RlPSLCoyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIzNSA1NCA1IDkiIGNvZGU9IsKlIi8%CiA8Q2hhciB3aWR0aD0iMyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjQxIDU0IDEgOSIgY29kZT0iwqYiLz4KIDxDaGFyIHdpZHRoPSI1IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNDMgNTQgMyAxIiBjb2RlPSLCqCIvPgogPENoYXIgd2lkdGg9IjkiIG9mZnNldD0iMSA0IiByZWN0PSI0NyA1NCA3IDkiIGNvZGU9IsKpIi8%CiA8Q2hhciB3aWR0aD0iOCIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjU1IDU2IDYgNSIgY29kZT0iwqsiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgOCIgcmVjdD0iNjIgNTggNSAzIiBjb2RlPSLCrCIvPgogPENoYXIgd2lkdGg9IjYiIG9mZnNldD0iMSA0IiByZWN0PSI2OCA1NCA0IDQiIGNvZGU9IsKwIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjczIDU2IDUgNyIgY29kZT0iwrEiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgNCIgcmVjdD0iNzkgNTQgMiAyIiBjb2RlPSLCtCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSI4MiA1NiA1IDkiIGNvZGU9IsK1Ii8%CiA8Q2hhciB3aWR0aD0iOCIgb2Zmc2V0PSIxIDQiIHJlY3Q9Ijg4IDU0IDcgOSIgY29kZT0iwrYiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgOCIgcmVjdD0iOTYgNTggMSAxIiBjb2RlPSLCtyIvPgogPENoYXIgd2lkdGg9IjUiIG9mZnNldD0iMCAxMyIgcmVjdD0iOTggNjMgMyAyIiBjb2RlPSLCuCIvPgogPENoYXIgd2lkdGg9IjgiIG9mZnNldD0iMSA2IiByZWN0PSIxMDIgNTYgNiA1IiBjb2RlPSLCuyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSIxMDkgNTYgNSA5IiBjb2RlPSLCvyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSIxMTUgNTEgNSAxMiIgY29kZT0iw4AiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMSIgcmVjdD0iMTIxIDUxIDUgMTIiIGNvZGU9IsOBIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjEgNjcgNSAxMiIgY29kZT0iw4IiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMSIgcmVjdD0iNyA2NyA2IDEyIiBjb2RlPSLDgyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAyIiByZWN0PSIxNCA2OCA1IDExIiBjb2RlPSLDhCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAwIiByZWN0PSIyMCA2NiA1IDEzIiBjb2RlPSLDhSIvPgogPENoYXIgd2lkdGg9IjExIiBvZmZzZXQ9IjEgNCIgcmVjdD0iMjYgNzAgOSA5IiBjb2RlPSLDhiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIzNiA3MCA1IDExIiBjb2RlPSLDhyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSI0MiA2NyA1IDEyIiBjb2RlPSLDiCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSI0OCA2NyA1IDEyIiBjb2RlPSLDiSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSI1NCA2NyA1IDEyIiBjb2RlPSLDiiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAyIiByZWN0PSI2MCA2OCA1IDExIiBjb2RlPSLDiyIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMCAxIiByZWN0PSI2NiA2NyAyIDEyIiBjb2RlPSLDjCIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMSAxIiByZWN0PSI2OSA2NyAyIDEyIiBjb2RlPSLDjSIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMCAxIiByZWN0PSI3MiA2NyAzIDEyIiBjb2RlPSLDjiIvPgogPENoYXIgd2lkdGg9IjMiIG9mZnNldD0iMCAyIiByZWN0PSI3NiA2OCAzIDExIiBjb2RlPSLDjyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMCA0IiByZWN0PSI4MCA3MCA2IDkiIGNvZGU9IsOQIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9Ijg3IDY3IDYgMTIiIGNvZGU9IsORIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9Ijk0IDY3IDUgMTIiIGNvZGU9IsOSIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjEwMCA2NyA1IDEyIiBjb2RlPSLDkyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAxIiByZWN0PSIxMDYgNjcgNSAxMiIgY29kZT0iw5QiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMSIgcmVjdD0iMTEyIDY3IDYgMTIiIGNvZGU9IsOVIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDIiIHJlY3Q9IjExOSA2OCA1IDExIiBjb2RlPSLDliIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA2IiByZWN0PSIxIDg3IDUgNSIgY29kZT0iw5ciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjAgNCIgcmVjdD0iNyA4NSA3IDkiIGNvZGU9IsOYIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjE1IDgyIDUgMTIiIGNvZGU9IsOZIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjIxIDgyIDUgMTIiIGNvZGU9IsOaIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjI3IDgyIDUgMTIiIGNvZGU9IsObIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDIiIHJlY3Q9IjMzIDgzIDUgMTEiIGNvZGU9IsOcIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDEiIHJlY3Q9IjM5IDgyIDUgMTIiIGNvZGU9IsOdIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjQ1IDg1IDUgOSIgY29kZT0iw54iLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iNTEgODUgNSA5IiBjb2RlPSLDnyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSI1NyA4NCA1IDEwIiBjb2RlPSLDoCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSI2MyA4NCA1IDEwIiBjb2RlPSLDoSIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSI2OSA4NCA1IDEwIiBjb2RlPSLDoiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSI3NSA4NCA2IDEwIiBjb2RlPSLDoyIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI4MiA4NSA1IDkiIGNvZGU9IsOkIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDIiIHJlY3Q9Ijg4IDgzIDUgMTEiIGNvZGU9IsOlIi8%CiA8Q2hhciB3aWR0aD0iMTEiIG9mZnNldD0iMSA2IiByZWN0PSI5NCA4NyA5IDciIGNvZGU9IsOmIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDYiIHJlY3Q9IjEwNCA4NyA1IDkiIGNvZGU9IsOnIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjExMCA4NCA1IDEwIiBjb2RlPSLDqCIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSAzIiByZWN0PSIxMTYgODQgNSAxMCIgY29kZT0iw6kiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iMSA5NyA1IDEwIiBjb2RlPSLDqiIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSI3IDk4IDUgOSIgY29kZT0iw6siLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgMyIgcmVjdD0iMTMgOTcgMiAxMCIgY29kZT0iw6wiLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjEgMyIgcmVjdD0iMTYgOTcgMiAxMCIgY29kZT0iw60iLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgMyIgcmVjdD0iMTkgOTcgMyAxMCIgY29kZT0iw64iLz4KIDxDaGFyIHdpZHRoPSIzIiBvZmZzZXQ9IjAgNCIgcmVjdD0iMjMgOTggMyA5IiBjb2RlPSLDryIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIyNyA5OCA2IDkiIGNvZGU9IsOwIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjM0IDk3IDYgMTAiIGNvZGU9IsOxIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjQxIDk3IDUgMTAiIGNvZGU9IsOyIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjQ3IDk3IDUgMTAiIGNvZGU9IsOzIi8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjUzIDk3IDUgMTAiIGNvZGU9IsO0Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDMiIHJlY3Q9IjU5IDk3IDYgMTAiIGNvZGU9IsO1Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjY2IDk4IDUgOSIgY29kZT0iw7YiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNiIgcmVjdD0iNzIgMTAwIDUgNSIgY29kZT0iw7ciLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjAgNiIgcmVjdD0iNzggMTAwIDcgNyIgY29kZT0iw7giLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iODYgOTcgNSAxMCIgY29kZT0iw7kiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iOTIgOTcgNSAxMCIgY29kZT0iw7oiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iOTggOTcgNSAxMCIgY29kZT0iw7siLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgNCIgcmVjdD0iMTA0IDk4IDUgOSIgY29kZT0iw7wiLz4KIDxDaGFyIHdpZHRoPSI3IiBvZmZzZXQ9IjEgMyIgcmVjdD0iMTEwIDk3IDUgMTIiIGNvZGU9IsO9Ii8%CiA8Q2hhciB3aWR0aD0iNyIgb2Zmc2V0PSIxIDQiIHJlY3Q9IjExNiA5OCA1IDExIiBjb2RlPSLDviIvPgogPENoYXIgd2lkdGg9IjciIG9mZnNldD0iMSA0IiByZWN0PSIxIDExMCA1IDExIiBjb2RlPSLDvyIvPgo8L0ZvbnQ%Cg"));
			let bmp = new hxd_res_BitmapFont(DESC.entry);
			bmp.loader = BYTES.loader;
			fnt = bmp.toFont();
			engine.resCache.set(hxd_res_DefaultFont,fnt);
		}
		return fnt;
	}
}
$hxClasses["hxd.res.DefaultFont"] = hxd_res_DefaultFont;
hxd_res_DefaultFont.__name__ = "hxd.res.DefaultFont";
class hxd_res_Embed {
}
$hxClasses["hxd.res.Embed"] = hxd_res_Embed;
hxd_res_Embed.__name__ = "hxd.res.Embed";
class hxd_res_ImageFormat {
	static getName(this1) {
		switch(this1) {
		case 0:
			return "JPG";
		case 1:
			return "PNG";
		case 2:
			return "GIF";
		case 3:
			return "TGA";
		case 4:
			return "DDS";
		case 5:
			return "RAW";
		case 6:
			return "HDR";
		}
	}
}
var hxd_res_ImageInfoFlag = $hxEnums["hxd.res.ImageInfoFlag"] = { __ename__:true,__constructs__:null
	,IsCube: {_hx_name:"IsCube",_hx_index:0,__enum__:"hxd.res.ImageInfoFlag",toString:$estr}
	,Dxt10Header: {_hx_name:"Dxt10Header",_hx_index:1,__enum__:"hxd.res.ImageInfoFlag",toString:$estr}
};
hxd_res_ImageInfoFlag.__constructs__ = [hxd_res_ImageInfoFlag.IsCube,hxd_res_ImageInfoFlag.Dxt10Header];
hxd_res_ImageInfoFlag.__empty_constructs__ = [hxd_res_ImageInfoFlag.IsCube,hxd_res_ImageInfoFlag.Dxt10Header];
class hxd_res_ImageInfo {
	constructor() {
		this.layerCount = 1;
		this.mipOffset = 0;
		this.mipLevels = 1;
		this.height = 0;
		this.width = 0;
		this.flags = 0;
	}
}
$hxClasses["hxd.res.ImageInfo"] = hxd_res_ImageInfo;
hxd_res_ImageInfo.__name__ = "hxd.res.ImageInfo";
Object.assign(hxd_res_ImageInfo.prototype, {
	__class__: hxd_res_ImageInfo
	,width: null
	,height: null
	,mipLevels: null
	,mipOffset: null
	,layerCount: null
	,flags: null
	,dataFormat: null
	,pixelFormat: null
});
class hxd_res_Image extends hxd_res_Resource {
	constructor(entry) {
		super(entry);
	}
	getInfo() {
		if(this.inf != null) {
			return this.inf;
		}
		this.inf = new hxd_res_ImageInfo();
		let f = this.entry.open();
		f.fetch(256);
		let head;
		try {
			head = f.readUInt16();
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				head = 0;
			} else {
				throw _g;
			}
		}
		switch(head) {
		case 16163:
			this.inf.dataFormat = 6;
			while(f.readLine() != "") {
			}
			let parts = f.readLine().split(" ");
			this.inf.pixelFormat = hxd_PixelFormat.RGBA32F;
			this.inf.height = Std.parseInt(parts[1]);
			this.inf.width = Std.parseInt(parts[3]);
			break;
		case 17476:
			this.inf.dataFormat = 4;
			f.skip(10);
			this.inf.height = f.readInt32();
			this.inf.width = f.readInt32();
			f.skip(8);
			this.inf.mipLevels = f.readInt32();
			f.skip(48);
			let caps = f.readInt32();
			let fourCC = f.readInt32();
			let bpp = f.readInt32();
			let rMask = f.readInt32();
			let gMask = f.readInt32();
			let bMask = f.readInt32();
			let aMask = f.readInt32();
			f.readInt32();
			let cubes = f.readInt32();
			if((cubes & 65024) == 65024) {
				this.inf.flags |= 1 << hxd_res_ImageInfoFlag.IsCube._hx_index;
			}
			switch(fourCC & 16777215) {
			case 0:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					let dxgi = f.readInt32();
					let tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else if((caps & 64) != 0) {
					if(bpp == 32) {
						switch(rMask) {
						case 255:
							if(gMask == 65280) {
								if(bMask == 16711680) {
									if(aMask == -16777216) {
										this.inf.pixelFormat = hxd_PixelFormat.RGBA;
									} else {
										throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
									}
								} else {
									throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
								}
							} else {
								throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
							}
							break;
						case 16711680:
							if(gMask == 65280) {
								if(bMask == 255) {
									if(aMask == -16777216) {
										this.inf.pixelFormat = hxd_PixelFormat.BGRA;
									} else {
										throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
									}
								} else {
									throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
								}
							} else {
								throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
							}
							break;
						default:
							throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
						}
					} else {
						throw haxe_Exception.thrown("Unsupported RGB DDS " + bpp + "bits " + StringTools.hex(rMask) + "/" + StringTools.hex(gMask) + "/" + StringTools.hex(bMask) + "/" + StringTools.hex(aMask));
					}
				}
				break;
			case 111:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					let dxgi = f.readInt32();
					let tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.R16F;
				}
				break;
			case 112:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					let dxgi = f.readInt32();
					let tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RG16F;
				}
				break;
			case 113:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					let dxgi = f.readInt32();
					let tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RGBA16F;
				}
				break;
			case 114:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					let dxgi = f.readInt32();
					let tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.R32F;
				}
				break;
			case 115:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					let dxgi = f.readInt32();
					let tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RG32F;
				}
				break;
			case 116:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					let dxgi = f.readInt32();
					let tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				} else {
					this.inf.pixelFormat = hxd_PixelFormat.RGBA32F;
				}
				break;
			case 4805697:
				let v = (fourCC >>> 24) - 48;
				let tmp;
				switch(v) {
				case 1:
					tmp = hxd_PixelFormat.S3TC(4);
					break;
				case 2:
					tmp = hxd_PixelFormat.S3TC(5);
					break;
				default:
					tmp = null;
				}
				this.inf.pixelFormat = tmp;
				break;
			case 5527620:
				let dxt = (fourCC >>> 24) - 48;
				let tmp1;
				switch(dxt) {
				case 1:
					tmp1 = hxd_PixelFormat.S3TC(1);
					break;
				case 2:case 3:
					tmp1 = hxd_PixelFormat.S3TC(2);
					break;
				case 4:case 5:
					tmp1 = hxd_PixelFormat.S3TC(3);
					break;
				default:
					tmp1 = null;
				}
				this.inf.pixelFormat = tmp1;
				break;
			default:
				if(fourCC == 808540228) {
					f.skip(12);
					this.inf.flags |= 1 << hxd_res_ImageInfoFlag.Dxt10Header._hx_index;
					let dxgi = f.readInt32();
					let tmp;
					switch(dxgi) {
					case 28:
						tmp = hxd_PixelFormat.RGBA;
						break;
					case 71:
						tmp = hxd_PixelFormat.S3TC(1);
						break;
					case 74:
						tmp = hxd_PixelFormat.S3TC(2);
						break;
					case 77:
						tmp = hxd_PixelFormat.S3TC(3);
						break;
					case 95:
						tmp = hxd_PixelFormat.S3TC(6);
						break;
					case 98:
						tmp = hxd_PixelFormat.S3TC(7);
						break;
					default:
						throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported DXGI format " + dxgi);
					}
					this.inf.pixelFormat = tmp;
					f.readInt32();
					f.skip(4);
					this.inf.layerCount = f.readInt32();
				}
			}
			if(this.inf.pixelFormat == null) {
				let fid = String.fromCodePoint((fourCC & 255)) + String.fromCodePoint((fourCC >> 8 & 255)) + String.fromCodePoint((fourCC >> 16 & 255)) + String.fromCodePoint((fourCC >>> 24));
				if((fourCC & 255) == fourCC) {
					fid = "0x" + fourCC;
				}
				throw haxe_Exception.thrown(this.entry.get_path() + " has unsupported 4CC " + fid);
			}
			break;
		case 18759:
			this.inf.dataFormat = 2;
			this.inf.pixelFormat = hxd_PixelFormat.BGRA;
			f.readInt32();
			this.inf.width = f.readUInt16();
			this.inf.height = f.readUInt16();
			break;
		case 20617:
			this.inf.dataFormat = 1;
			f.set_bigEndian(true);
			f.skip(6);
			while(true) {
				let dataLen = f.readInt32();
				if(f.readInt32() == 1229472850) {
					this.inf.width = f.readInt32();
					this.inf.height = f.readInt32();
					let colbits = f.readByte();
					let tmp;
					switch(colbits) {
					case 8:
						tmp = hxd_PixelFormat.BGRA;
						break;
					case 16:
						tmp = hxd_PixelFormat.R16U;
						break;
					case 48:
						tmp = hxd_PixelFormat.RGB16U;
						break;
					case 64:
						tmp = hxd_PixelFormat.RGBA16U;
						break;
					default:
						throw haxe_Exception.thrown("Unsupported png format " + colbits + "(" + this.entry.get_path() + ")");
					}
					this.inf.pixelFormat = tmp;
					break;
				}
				f.skip(dataLen + 4);
			}
			break;
		case 55551:
			this.inf.dataFormat = 0;
			this.inf.pixelFormat = hxd_PixelFormat.BGRA;
			f.set_bigEndian(true);
			_hx_loop3: while(true) switch(f.readUInt16()) {
			case 65472:case 65473:case 65474:
				f.readUInt16();
				f.readByte();
				this.inf.height = f.readUInt16();
				this.inf.width = f.readUInt16();
				break _hx_loop3;
			default:
				f.skip(f.readUInt16() - 2);
			}
			break;
		default:
			if(this.entry.get_extension() == "tga") {
				this.inf.dataFormat = 3;
				this.inf.pixelFormat = hxd_PixelFormat.ARGB;
				f.skip(10);
				this.inf.width = f.readUInt16();
				this.inf.height = f.readUInt16();
			} else if(this.entry.get_extension() == "raw") {
				this.inf.dataFormat = 5;
				this.inf.pixelFormat = hxd_PixelFormat.R32F;
				let size = Math.sqrt(this.entry.get_size() >> 2) | 0;
				if(this.entry.get_size() != size * size * 4) {
					let size2 = Math.sqrt(this.entry.get_size() >> 1) | 0;
					if(this.entry.get_size() == size2 * size2 * 2) {
						this.inf.pixelFormat = hxd_PixelFormat.R16F;
						size = size2;
					} else {
						throw haxe_Exception.thrown("RAW format does not match 32 bit per components on " + size + "x" + size);
					}
				}
				this.inf.width = this.inf.height = size;
			} else {
				throw haxe_Exception.thrown("Unsupported texture format " + this.entry.get_path());
			}
		}
		f.close();
		if(this.inf.pixelFormat == null) {
			throw haxe_Exception.thrown("Unsupported internal format (" + this.entry.get_path() + ")");
		}
		if(hxd_res_Image.MIPMAP_MAX_SIZE != 0 && this.inf.mipLevels > 1) {
			while(((this.inf.width | this.inf.height) & 7) == 0 && this.inf.width >> 1 >= hxd_res_Image.MIPMAP_MAX_SIZE && this.inf.height >> 1 >= hxd_res_Image.MIPMAP_MAX_SIZE) {
				this.inf.width >>= 1;
				this.inf.height >>= 1;
				this.inf.mipLevels--;
				this.inf.mipOffset++;
			}
		}
		return this.inf;
	}
	getPixels(fmt,flipY,index) {
		let pixels;
		if(index == null) {
			index = 0;
		}
		switch(this.getInfo().dataFormat) {
		case 0:
			let bytes = this.entry.getBytes();
			if(this.inf.pixelFormat != hxd_PixelFormat.BGRA) {
				throw haxe_Exception.thrown("No support to decode " + Std.string(this.inf.pixelFormat) + " on this platform (" + this.entry.get_path() + ")");
			}
			let p;
			try {
				p = hxd_res_NanoJpeg.decode(bytes);
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g).unwrap();
				throw haxe_Exception.thrown("Failed to decode JPG " + this.entry.get_path() + " (" + Std.string(_g1) + ")");
			}
			pixels = new hxd_Pixels(p.width,p.height,p.pixels,hxd_PixelFormat.BGRA);
			break;
		case 1:
			let bytes1 = this.entry.getBytes();
			if(this.inf.pixelFormat != hxd_PixelFormat.BGRA) {
				throw haxe_Exception.thrown("No support to decode " + Std.string(this.inf.pixelFormat) + " on this platform (" + this.entry.get_path() + ")");
			}
			let png = new format_png_Reader(new haxe_io_BytesInput(bytes1));
			png.checkCRC = false;
			pixels = hxd_Pixels.alloc(this.inf.width,this.inf.height,hxd_PixelFormat.BGRA);
			let pdata = png.read();
			format_png_Tools.extract32(pdata,pixels.bytes,flipY);
			if(flipY) {
				pixels.flags |= 4;
			}
			break;
		case 2:
			let bytes2 = this.entry.getBytes();
			let gif = new format_gif_Reader(new haxe_io_BytesInput(bytes2)).read();
			if(fmt == hxd_PixelFormat.RGBA) {
				pixels = new hxd_Pixels(this.inf.width,this.inf.height,format_gif_Tools.extractFullRGBA(gif,0),hxd_PixelFormat.RGBA);
			} else {
				pixels = new hxd_Pixels(this.inf.width,this.inf.height,format_gif_Tools.extractFullBGRA(gif,0),hxd_PixelFormat.BGRA);
			}
			break;
		case 3:
			let bytes3 = this.entry.getBytes();
			let r = new format_tga_Reader(new haxe_io_BytesInput(bytes3)).read();
			if(r.header.imageType != format_tga_ImageType.UncompressedTrueColor || r.header.bitsPerPixel != 32) {
				throw haxe_Exception.thrown("Not supported TGA " + Std.string(r.header.imageType) + "/" + r.header.bitsPerPixel);
			}
			let w = r.header.width;
			let h = r.header.height;
			if(fmt == hxd_PixelFormat.RGBA) {
				pixels = hxd_Pixels.alloc(w,h,hxd_PixelFormat.RGBA);
				let bytes = pixels.bytes;
				let _g = 0;
				let _g1 = w * h;
				while(_g < _g1) {
					let i = _g++;
					let c = r.imageData[i];
					c = c >>> 24 | c << 8;
					bytes.setInt32(i << 2,c);
				}
			} else {
				pixels = hxd_Pixels.alloc(w,h,hxd_PixelFormat.ARGB);
				let access = hxd_PixelsARGB.fromPixels(pixels);
				let p = 0;
				let _g = 0;
				while(_g < h) {
					let y = _g++;
					let _g1 = 0;
					while(_g1 < w) {
						let x = _g1++;
						let c = r.imageData[p++];
						access.bytes.setInt32((x + y * access.width << 2) + access.offset,c >>> 24 | c >> 8 & 65280 | c << 8 & 16711680 | c << 24);
					}
				}
			}
			switch(r.header.imageOrigin._hx_index) {
			case 0:
				pixels.flags |= 4;
				break;
			case 2:
				break;
			default:
				throw haxe_Exception.thrown("Not supported " + Std.string(r.header.imageOrigin));
			}
			break;
		case 4:
			let pos = 128;
			let mipLevel = 0;
			if((this.inf.flags & 2) != 0) {
				pos = 148;
			}
			index += this.inf.mipOffset;
			if(index > 0) {
				let totLevels = this.inf.mipLevels + this.inf.mipOffset;
				let layer = index / totLevels | 0;
				mipLevel = index % totLevels;
				let totSize = 0;
				let _g = 0;
				while(_g < totLevels) {
					let i = _g++;
					let w = this.inf.width << this.inf.mipOffset >> i;
					let h = this.inf.height << this.inf.mipOffset >> i;
					if(w == 0) {
						w = 1;
					}
					if(h == 0) {
						h = 1;
					}
					let size = hxd_Pixels.calcDataSize(w,h,this.inf.pixelFormat);
					totSize += size;
					if(i < mipLevel) {
						pos += size;
					} else if(layer == 0) {
						break;
					}
				}
				pos += totSize * layer;
			}
			let bytes4;
			let w1 = this.inf.width >> mipLevel - this.inf.mipOffset;
			let h1 = this.inf.height >> mipLevel - this.inf.mipOffset;
			if(w1 == 0) {
				w1 = 1;
			}
			if(h1 == 0) {
				h1 = 1;
			}
			if(this.inf.mipLevels + this.inf.mipOffset == 1 && (this.inf.flags & 1) == 0) {
				bytes4 = this.entry.getBytes();
			} else {
				let size = hxd_Pixels.calcDataSize(w1,h1,this.inf.pixelFormat);
				bytes4 = new haxe_io_Bytes(new ArrayBuffer(size));
				this.entry.readFull(bytes4,pos,size);
				pos = 0;
			}
			pixels = new hxd_Pixels(w1,h1,bytes4,this.inf.pixelFormat,pos);
			break;
		case 5:
			let bytes5 = this.entry.getBytes();
			pixels = new hxd_Pixels(this.inf.width,this.inf.height,bytes5,this.inf.pixelFormat);
			break;
		case 6:
			let data = hxd_fmt_hdr_Reader.decode(this.entry.getBytes(),false);
			pixels = new hxd_Pixels(data.width,data.height,data.bytes,this.inf.pixelFormat);
			break;
		}
		if(fmt != null) {
			pixels.convert(fmt);
		}
		if(flipY != null) {
			pixels.setFlip(flipY);
		}
		return pixels;
	}
	watchCallb() {
		let w = this.inf.width;
		let h = this.inf.height;
		this.inf = null;
		let s = this.getInfo();
		if(w != s.width || h != s.height) {
			this.tex.resize(s.width,s.height);
		}
		this.tex.realloc = null;
		this.loadTexture();
	}
	loadTexture(asyncData) {
		let _gthis = this;
		if(this.getInfo().dataFormat == 0) {
			this.tex.flags |= 512;
			this.entry.loadBitmap(function(bmp) {
				let bmp1 = hxd_fs_LoadedBitmap.toBitmap(bmp);
				_gthis.tex.alloc();
				_gthis.tex.uploadBitmap(bmp1);
				bmp1.ctx = null;
				bmp1.pixel = null;
				_gthis.tex.realloc = function() {
					_gthis.loadTexture();
				};
				_gthis.tex.flags &= -513;
				if(_gthis.tex.waitLoads != null) {
					let arr = _gthis.tex.waitLoads;
					_gthis.tex.waitLoads = null;
					let _g = 0;
					while(_g < arr.length) {
						let f = arr[_g];
						++_g;
						f();
					}
				}
				if(hxd_res_Image.ENABLE_AUTO_WATCH) {
					_gthis.watch($bind(_gthis,_gthis.watchCallb));
				}
			});
			return;
		}
		let load = function() {
			if((_gthis.enableAsyncLoading || (_gthis.tex.flags & 4096) != 0) && asyncData == null && hxd_res_Image.ASYNC_LOADER.isSupported(_gthis)) {
				_gthis.tex.dispose();
				_gthis.tex.format = hxd_PixelFormat.RGBA;
				_gthis.tex.width = 1;
				_gthis.tex.height = 1;
				_gthis.tex.customMipLevels = 1;
				_gthis.tex.flags |= 512;
				_gthis.tex.alloc();
				_gthis.tex.uploadPixels(hxd_res_Image.BLACK_1x1);
				_gthis.tex.width = _gthis.inf.width;
				_gthis.tex.height = _gthis.inf.height;
				hxd_res_Image.ASYNC_LOADER.load(_gthis);
				_gthis.tex.realloc = function() {
					_gthis.loadTexture();
				};
				return;
			}
			let t0 = HxOverrides.now() / 1000;
			_gthis.tex.customMipLevels = _gthis.inf.mipLevels;
			_gthis.tex.alloc();
			if(_gthis.inf.dataFormat == 4) {
				let pos = 128;
				if((_gthis.inf.flags & 2) != 0) {
					pos = 148;
				}
				let _g = 0;
				let _g1 = _gthis.tex.get_layerCount();
				while(_g < _g1) {
					let layer = _g++;
					let _g1 = 0;
					let _g2 = _gthis.inf.mipOffset;
					while(_g1 < _g2) {
						let mip = _g1++;
						let w = _gthis.inf.width << _gthis.inf.mipOffset >> mip;
						let h = _gthis.inf.height << _gthis.inf.mipOffset >> mip;
						let size = hxd_Pixels.calcDataSize(w,h,_gthis.inf.pixelFormat);
						pos += size;
					}
					let _g3 = 0;
					let _g4 = _gthis.inf.mipLevels;
					while(_g3 < _g4) {
						let mip = _g3++;
						let w = _gthis.inf.width >> mip;
						let h = _gthis.inf.height >> mip;
						if(w == 0) {
							w = 1;
						}
						if(h == 0) {
							h = 1;
						}
						let size = hxd_Pixels.calcDataSize(w,h,_gthis.inf.pixelFormat);
						let bytes = asyncData == null ? _gthis.entry.fetchBytes(pos,size) : asyncData;
						_gthis.tex.uploadPixels(new hxd_Pixels(w,h,bytes,_gthis.inf.pixelFormat,asyncData == null ? 0 : pos),mip,layer);
						pos += size;
					}
				}
			} else {
				let _g = 0;
				let _g1 = _gthis.tex.get_layerCount();
				while(_g < _g1) {
					let layer = _g++;
					let _g1 = 0;
					let _g2 = _gthis.inf.mipLevels;
					while(_g1 < _g2) {
						let mip = _g1++;
						let pixels = _gthis.getPixels(_gthis.tex.format,null,layer * _gthis.inf.mipLevels + mip);
						_gthis.tex.uploadPixels(pixels,mip,layer);
						pixels.dispose();
					}
				}
			}
			if(hxd_res_Image.LOG_TEXTURE_LOAD && asyncData == null) {
				let time = (HxOverrides.now() / 1000 - t0) * 1000.0;
				let fmtStr = _gthis.inf.pixelFormat._hx_index == 21 ? "DXT" : hxd_res_ImageFormat.getName(_gthis.inf.dataFormat);
				haxe_Log.trace(fmtStr + " " + (time | 0) + "." + (time * 10 | 0) % 10 + "ms " + _gthis.inf.width + "x" + _gthis.inf.height + " " + _gthis.entry.get_path(),{ fileName : "hxd/res/Image.hx", lineNumber : 582, className : "hxd.res.Image", methodName : "loadTexture"});
			}
			_gthis.tex.realloc = function() {
				_gthis.loadTexture();
			};
			if(hxd_res_Image.ENABLE_AUTO_WATCH) {
				_gthis.watch($bind(_gthis,_gthis.watchCallb));
			}
		};
		if(this.entry.get_isAvailable()) {
			load();
		} else {
			this.entry.load(load);
		}
	}
	toTexture() {
		if(this.tex != null) {
			return this.tex;
		}
		this.getInfo();
		let flags = [h3d_mat_TextureFlags.NoAlloc];
		let fmt = this.inf.pixelFormat;
		if(fmt == hxd_PixelFormat.BGRA || fmt == hxd_PixelFormat.ARGB || fmt == hxd_PixelFormat.RGBA) {
			fmt = h3d_mat_Texture.nativeFormat;
		}
		if((this.inf.flags & 1) != 0) {
			flags.push(h3d_mat_TextureFlags.Cube);
		}
		if(this.inf.mipLevels > 1) {
			flags.push(h3d_mat_TextureFlags.MipMapped);
			flags.push(h3d_mat_TextureFlags.ManualMipMapGen);
		}
		if(fmt == hxd_PixelFormat.R16U) {
			throw haxe_Exception.thrown("Unsupported texture format " + Std.string(fmt) + " for " + this.entry.get_path());
		}
		if(this.inf.layerCount > 1) {
			this.tex = new h3d_mat_TextureArray(this.inf.width,this.inf.height,this.inf.layerCount,flags,fmt);
		} else {
			this.tex = new h3d_mat_Texture(this.inf.width,this.inf.height,flags,fmt);
		}
		if(hxd_res_Image.DEFAULT_FILTER != h3d_mat_Filter.Linear) {
			this.tex.set_filter(hxd_res_Image.DEFAULT_FILTER);
		}
		this.tex.setName(this.entry.get_path());
		hxd_res_Image.setupTextureFlags(this.tex);
		this.loadTexture();
		return this.tex;
	}
	toTile() {
		this.getInfo();
		return h2d_Tile.fromTexture(this.toTexture()).sub(0,0,this.inf.width,this.inf.height);
	}
	static setupTextureFlags(tex) {
	}
}
$hxClasses["hxd.res.Image"] = hxd_res_Image;
hxd_res_Image.__name__ = "hxd.res.Image";
hxd_res_Image.__super__ = hxd_res_Resource;
Object.assign(hxd_res_Image.prototype, {
	__class__: hxd_res_Image
	,tex: null
	,inf: null
	,enableAsyncLoading: null
});
var hxd_res_Filter = $hxEnums["hxd.res.Filter"] = { __ename__:true,__constructs__:null
	,Fast: {_hx_name:"Fast",_hx_index:0,__enum__:"hxd.res.Filter",toString:$estr}
	,Chromatic: {_hx_name:"Chromatic",_hx_index:1,__enum__:"hxd.res.Filter",toString:$estr}
};
hxd_res_Filter.__constructs__ = [hxd_res_Filter.Fast,hxd_res_Filter.Chromatic];
hxd_res_Filter.__empty_constructs__ = [hxd_res_Filter.Fast,hxd_res_Filter.Chromatic];
class hxd_res__$NanoJpeg_Component {
	constructor() {
	}
}
$hxClasses["hxd.res._NanoJpeg.Component"] = hxd_res__$NanoJpeg_Component;
hxd_res__$NanoJpeg_Component.__name__ = "hxd.res._NanoJpeg.Component";
Object.assign(hxd_res__$NanoJpeg_Component.prototype, {
	__class__: hxd_res__$NanoJpeg_Component
	,cid: null
	,ssx: null
	,ssy: null
	,width: null
	,height: null
	,stride: null
	,qtsel: null
	,actabsel: null
	,dctabsel: null
	,dcpred: null
	,pixels: null
});
class hxd_res_NanoJpeg {
	constructor() {
		this.comps = [new hxd_res__$NanoJpeg_Component(),new hxd_res__$NanoJpeg_Component(),new hxd_res__$NanoJpeg_Component()].slice(0);
		this.qtab = [new Array(64),new Array(64),new Array(64),new Array(64)].slice(0);
		this.counts = new Array(16);
		this.block = new Array(64);
		this.njZZ = [0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63].slice(0);
		this.vlctab = [null,null,null,null,null,null,null,null].slice(0);
	}
	njInit(bytes,pos,size,filter) {
		this.bytes = bytes;
		this.pos = pos;
		this.filter = filter == null ? hxd_res_Filter.Chromatic : filter;
		if(size < 0) {
			size = bytes.length - pos;
		}
		if(this.vlctab[0] == null) {
			this.vlctab[0] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		if(this.vlctab[1] == null) {
			this.vlctab[1] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		if(this.vlctab[2] == null) {
			this.vlctab[2] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		if(this.vlctab[3] == null) {
			this.vlctab[3] = new haxe_io_Bytes(new ArrayBuffer(131072));
		}
		this.size = size;
		this.qtused = 0;
		this.qtavail = 0;
		this.rstinterval = 0;
		this.length = 0;
		this.buf = 0;
		this.bufbits = 0;
		this.progressive = false;
		this.comps[0].dcpred = 0;
		this.comps[1].dcpred = 0;
		this.comps[2].dcpred = 0;
	}
	cleanup() {
		this.bytes = null;
		let _g = 0;
		let _g1 = this.comps;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			if(c.pixels != null) {
				c.pixels = null;
			}
		}
		if(this.vlctab[0] != null) {
			this.vlctab[0] = null;
		}
		if(this.vlctab[1] != null) {
			this.vlctab[1] = null;
		}
		if(this.vlctab[2] != null) {
			this.vlctab[2] = null;
		}
		if(this.vlctab[3] != null) {
			this.vlctab[3] = null;
		}
		if(this.vlctab[4] != null) {
			this.vlctab[4] = null;
		}
		if(this.vlctab[5] != null) {
			this.vlctab[5] = null;
		}
		if(this.vlctab[6] != null) {
			this.vlctab[6] = null;
		}
		if(this.vlctab[7] != null) {
			this.vlctab[7] = null;
		}
	}
	njShowBits(bits) {
		if(bits == 0) {
			return 0;
		}
		while(this.bufbits < bits) {
			if(this.size <= 0) {
				this.buf = this.buf << 8 | 255;
				this.bufbits += 8;
				continue;
			}
			let newbyte = this.bytes.b[this.pos];
			this.pos++;
			this.size--;
			this.bufbits += 8;
			this.buf = this.buf << 8 | newbyte;
			if(newbyte == 255) {
				if(this.size == 0) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				let marker = this.bytes.b[this.pos];
				this.pos++;
				this.size--;
				switch(marker) {
				case 217:
					this.size = 0;
					break;
				case 0:case 255:
					break;
				default:
					if((marker & 248) != 208) {
						throw haxe_Exception.thrown("Invalid JPEG file");
					}
					this.buf = this.buf << 8 | marker;
					this.bufbits += 8;
				}
			}
		}
		return this.buf >> this.bufbits - bits & (1 << bits) - 1;
	}
	njDecodeSOF() {
		if(this.size < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		if(this.length > this.size) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		if(this.length < 9) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		if(this.bytes.b[this.pos] != 8) {
			this.notSupported();
		}
		this.height = this.bytes.b[this.pos + 1] << 8 | this.bytes.b[this.pos + 2];
		this.width = this.bytes.b[this.pos + 3] << 8 | this.bytes.b[this.pos + 4];
		this.ncomp = this.bytes.b[this.pos + 5];
		this.pos += 6;
		this.size -= 6;
		this.length -= 6;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		switch(this.ncomp) {
		case 1:case 3:
			break;
		default:
			this.notSupported();
		}
		if(this.length < this.ncomp * 3) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		let ssxmax = 0;
		let ssymax = 0;
		let _g = 0;
		let _g1 = this.ncomp;
		while(_g < _g1) {
			let i = _g++;
			let c = this.comps[i];
			c.cid = this.bytes.b[this.pos];
			c.ssx = this.bytes.b[this.pos + 1] >> 4;
			if(c.ssx == 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			if((c.ssx & c.ssx - 1) != 0) {
				this.notSupported();
			}
			c.ssy = this.bytes.b[this.pos + 1] & 15;
			if(c.ssy == 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			if((c.ssy & c.ssy - 1) != 0) {
				this.notSupported();
			}
			c.qtsel = this.bytes.b[this.pos + 2];
			if((c.qtsel & 252) != 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			this.pos += 3;
			this.size -= 3;
			this.length -= 3;
			if(this.size < 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			this.qtused |= 1 << c.qtsel;
			if(c.ssx > ssxmax) {
				ssxmax = c.ssx;
			}
			if(c.ssy > ssymax) {
				ssymax = c.ssy;
			}
		}
		if(this.ncomp == 1) {
			let c = this.comps[0];
			ssymax = 1;
			ssxmax = 1;
			c.ssx = c.ssy = 1;
		}
		this.mbsizex = ssxmax << 3;
		this.mbsizey = ssymax << 3;
		this.mbwidth = (this.width + this.mbsizex - 1) / this.mbsizex | 0;
		this.mbheight = (this.height + this.mbsizey - 1) / this.mbsizey | 0;
		let _g2 = 0;
		let _g3 = this.ncomp;
		while(_g2 < _g3) {
			let i = _g2++;
			let c = this.comps[i];
			c.width = (this.width * c.ssx + ssxmax - 1) / ssxmax | 0;
			c.stride = c.width + 7 & 2147483640;
			c.height = (this.height * c.ssy + ssymax - 1) / ssymax | 0;
			c.stride = this.mbwidth * this.mbsizex * c.ssx / ssxmax | 0;
			if(c.width < 3 && c.ssx != ssxmax || c.height < 3 && c.ssy != ssymax) {
				this.notSupported();
			}
			c.pixels = new haxe_io_Bytes(new ArrayBuffer(c.stride * (this.mbheight * this.mbsizey * c.ssy / ssymax | 0)));
		}
		let count = this.length;
		this.pos += count;
		this.size -= count;
		this.length -= count;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
	}
	njDecodeDQT() {
		if(this.size < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		if(this.length > this.size) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		while(this.length >= 65) {
			let i = this.bytes.b[this.pos];
			if((i & 252) != 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			this.qtavail |= 1 << i;
			let t = this.qtab[i];
			let _g = 0;
			while(_g < 64) {
				let k = _g++;
				t[k] = this.bytes.b[this.pos + (k + 1)];
			}
			this.pos += 65;
			this.size -= 65;
			this.length -= 65;
			if(this.size < 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
		}
		if(this.length != 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
	}
	njDecodeDHT() {
		if(this.size < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		if(this.length > this.size) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		while(this.length >= 17) {
			let i = this.bytes.b[this.pos];
			if((i & 236) != 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			i = i >> 4 & 1 | (i & 3) << 1;
			this.counts[0] = this.bytes.b[this.pos + 1];
			this.counts[1] = this.bytes.b[this.pos + 2];
			this.counts[2] = this.bytes.b[this.pos + 3];
			this.counts[3] = this.bytes.b[this.pos + 4];
			this.counts[4] = this.bytes.b[this.pos + 5];
			this.counts[5] = this.bytes.b[this.pos + 6];
			this.counts[6] = this.bytes.b[this.pos + 7];
			this.counts[7] = this.bytes.b[this.pos + 8];
			this.counts[8] = this.bytes.b[this.pos + 9];
			this.counts[9] = this.bytes.b[this.pos + 10];
			this.counts[10] = this.bytes.b[this.pos + 11];
			this.counts[11] = this.bytes.b[this.pos + 12];
			this.counts[12] = this.bytes.b[this.pos + 13];
			this.counts[13] = this.bytes.b[this.pos + 14];
			this.counts[14] = this.bytes.b[this.pos + 15];
			this.counts[15] = this.bytes.b[this.pos + 16];
			this.pos += 17;
			this.size -= 17;
			this.length -= 17;
			if(this.size < 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			let vlc = this.vlctab[i];
			let vpos = 0;
			let remain = 65536;
			let spread = 65536;
			let _g = 1;
			while(_g < 17) {
				let codelen = _g++;
				spread >>= 1;
				let currcnt = this.counts[codelen - 1];
				if(currcnt == 0) {
					continue;
				}
				if(this.length < currcnt) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				remain -= currcnt << 16 - codelen;
				if(remain < 0) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				let _g1 = 0;
				while(_g1 < currcnt) {
					let i = _g1++;
					let code = this.bytes.b[this.pos + i];
					let _g = 0;
					let _g2 = spread;
					while(_g < _g2) {
						++_g;
						vlc.b[vpos++] = codelen;
						vlc.b[vpos++] = code;
					}
				}
				this.pos += currcnt;
				this.size -= currcnt;
				this.length -= currcnt;
				if(this.size < 0) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
			}
			while(remain-- != 0) {
				vlc.b[vpos] = 0;
				vpos += 2;
			}
		}
		if(this.length != 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
	}
	njDecodeDRI() {
		if(this.size < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		if(this.length > this.size) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		if(this.length < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.rstinterval = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		let count = this.length;
		this.pos += count;
		this.size -= count;
		this.length -= count;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
	}
	njDecodeBlock(c,po) {
		let out = c.pixels;
		let value;
		let coef = 0;
		let _g = 0;
		while(_g < 64) {
			let i = _g++;
			this.block[i] = 0;
		}
		let c1 = c.dcpred;
		let vlc = this.vlctab[c.dctabsel];
		let value1 = this.njShowBits(16);
		let bits = vlc.b[value1 << 1];
		if(bits == 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		if(this.bufbits < bits) {
			this.njShowBits(bits);
		}
		this.bufbits -= bits;
		value1 = vlc.b[value1 << 1 | 1];
		this.vlcCode = value1;
		bits = value1 & 15;
		let tmp;
		if(bits == 0) {
			tmp = 0;
		} else {
			let r = this.njShowBits(bits);
			this.bufbits -= bits;
			value1 = r;
			if(r < 1 << bits - 1) {
				value1 = r + ((-1 << bits) + 1);
			}
			tmp = value1;
		}
		c.dcpred = c1 + tmp;
		let qt = this.qtab[c.qtsel];
		let at = this.vlctab[c.actabsel];
		this.block[0] = c.dcpred * qt[0];
		do {
			let value1 = this.njShowBits(16);
			let bits = at.b[value1 << 1];
			if(bits == 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			if(this.bufbits < bits) {
				this.njShowBits(bits);
			}
			this.bufbits -= bits;
			value1 = at.b[value1 << 1 | 1];
			this.vlcCode = value1;
			bits = value1 & 15;
			if(bits == 0) {
				value = 0;
			} else {
				let r = this.njShowBits(bits);
				this.bufbits -= bits;
				value1 = r;
				if(r < 1 << bits - 1) {
					value1 = r + ((-1 << bits) + 1);
				}
				value = value1;
			}
			if(this.vlcCode == 0) {
				break;
			}
			if((this.vlcCode & 15) == 0 && this.vlcCode != 240) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			coef += (this.vlcCode >> 4) + 1;
			if(coef > 63) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			this.block[this.njZZ[coef]] = value * qt[coef];
		} while(coef < 63);
		let x0;
		let x8;
		let x1 = this.block[4] << 11;
		let x2 = this.block[6];
		let x3 = this.block[2];
		let x4 = this.block[1];
		let x5 = this.block[7];
		let x6 = this.block[5];
		let x7 = this.block[3];
		if((x1 | x2 | x3 | x4 | x5 | x6 | x7) == 0) {
			let val = this.block[7] = this.block[0] << 3;
			let val1 = this.block[6] = val;
			let val2 = this.block[5] = val1;
			let val3 = this.block[4] = val2;
			let val4 = this.block[3] = val3;
			let val5 = this.block[2] = val4;
			let val6 = this.block[1] = val5;
			this.block[0] = val6;
		} else {
			x0 = (this.block[0] << 11) + 128;
			x8 = 565 * (x4 + x5);
			x4 = x8 + 2276 * x4;
			x5 = x8 - 3406 * x5;
			x8 = 2408 * (x6 + x7);
			x6 = x8 - 799 * x6;
			x7 = x8 - 4017 * x7;
			x8 = x0 + x1;
			x0 -= x1;
			x1 = 1108 * (x3 + x2);
			x2 = x1 - 3784 * x2;
			x3 = x1 + 1568 * x3;
			x1 = x4 + x6;
			x4 -= x6;
			x6 = x5 + x7;
			x5 -= x7;
			x7 = x8 + x3;
			x8 -= x3;
			x3 = x0 + x2;
			x0 -= x2;
			x2 = 181 * (x4 + x5) + 128 >> 8;
			x4 = 181 * (x4 - x5) + 128 >> 8;
			this.block[0] = x7 + x1 >> 8;
			this.block[1] = x3 + x2 >> 8;
			this.block[2] = x0 + x4 >> 8;
			this.block[3] = x8 + x6 >> 8;
			this.block[4] = x8 - x6 >> 8;
			this.block[5] = x0 - x4 >> 8;
			this.block[6] = x3 - x2 >> 8;
			this.block[7] = x7 - x1 >> 8;
		}
		let x01;
		let x81;
		let x11 = this.block[12] << 11;
		let x21 = this.block[14];
		let x31 = this.block[10];
		let x41 = this.block[9];
		let x51 = this.block[15];
		let x61 = this.block[13];
		let x71 = this.block[11];
		if((x11 | x21 | x31 | x41 | x51 | x61 | x71) == 0) {
			let val = this.block[15] = this.block[8] << 3;
			let val1 = this.block[14] = val;
			let val2 = this.block[13] = val1;
			let val3 = this.block[12] = val2;
			let val4 = this.block[11] = val3;
			let val5 = this.block[10] = val4;
			let val6 = this.block[9] = val5;
			this.block[8] = val6;
		} else {
			x01 = (this.block[8] << 11) + 128;
			x81 = 565 * (x41 + x51);
			x41 = x81 + 2276 * x41;
			x51 = x81 - 3406 * x51;
			x81 = 2408 * (x61 + x71);
			x61 = x81 - 799 * x61;
			x71 = x81 - 4017 * x71;
			x81 = x01 + x11;
			x01 -= x11;
			x11 = 1108 * (x31 + x21);
			x21 = x11 - 3784 * x21;
			x31 = x11 + 1568 * x31;
			x11 = x41 + x61;
			x41 -= x61;
			x61 = x51 + x71;
			x51 -= x71;
			x71 = x81 + x31;
			x81 -= x31;
			x31 = x01 + x21;
			x01 -= x21;
			x21 = 181 * (x41 + x51) + 128 >> 8;
			x41 = 181 * (x41 - x51) + 128 >> 8;
			this.block[8] = x71 + x11 >> 8;
			this.block[9] = x31 + x21 >> 8;
			this.block[10] = x01 + x41 >> 8;
			this.block[11] = x81 + x61 >> 8;
			this.block[12] = x81 - x61 >> 8;
			this.block[13] = x01 - x41 >> 8;
			this.block[14] = x31 - x21 >> 8;
			this.block[15] = x71 - x11 >> 8;
		}
		let x02;
		let x82;
		let x12 = this.block[20] << 11;
		let x22 = this.block[22];
		let x32 = this.block[18];
		let x42 = this.block[17];
		let x52 = this.block[23];
		let x62 = this.block[21];
		let x72 = this.block[19];
		if((x12 | x22 | x32 | x42 | x52 | x62 | x72) == 0) {
			let val = this.block[23] = this.block[16] << 3;
			let val1 = this.block[22] = val;
			let val2 = this.block[21] = val1;
			let val3 = this.block[20] = val2;
			let val4 = this.block[19] = val3;
			let val5 = this.block[18] = val4;
			let val6 = this.block[17] = val5;
			this.block[16] = val6;
		} else {
			x02 = (this.block[16] << 11) + 128;
			x82 = 565 * (x42 + x52);
			x42 = x82 + 2276 * x42;
			x52 = x82 - 3406 * x52;
			x82 = 2408 * (x62 + x72);
			x62 = x82 - 799 * x62;
			x72 = x82 - 4017 * x72;
			x82 = x02 + x12;
			x02 -= x12;
			x12 = 1108 * (x32 + x22);
			x22 = x12 - 3784 * x22;
			x32 = x12 + 1568 * x32;
			x12 = x42 + x62;
			x42 -= x62;
			x62 = x52 + x72;
			x52 -= x72;
			x72 = x82 + x32;
			x82 -= x32;
			x32 = x02 + x22;
			x02 -= x22;
			x22 = 181 * (x42 + x52) + 128 >> 8;
			x42 = 181 * (x42 - x52) + 128 >> 8;
			this.block[16] = x72 + x12 >> 8;
			this.block[17] = x32 + x22 >> 8;
			this.block[18] = x02 + x42 >> 8;
			this.block[19] = x82 + x62 >> 8;
			this.block[20] = x82 - x62 >> 8;
			this.block[21] = x02 - x42 >> 8;
			this.block[22] = x32 - x22 >> 8;
			this.block[23] = x72 - x12 >> 8;
		}
		let x03;
		let x83;
		let x13 = this.block[28] << 11;
		let x23 = this.block[30];
		let x33 = this.block[26];
		let x43 = this.block[25];
		let x53 = this.block[31];
		let x63 = this.block[29];
		let x73 = this.block[27];
		if((x13 | x23 | x33 | x43 | x53 | x63 | x73) == 0) {
			let val = this.block[31] = this.block[24] << 3;
			let val1 = this.block[30] = val;
			let val2 = this.block[29] = val1;
			let val3 = this.block[28] = val2;
			let val4 = this.block[27] = val3;
			let val5 = this.block[26] = val4;
			let val6 = this.block[25] = val5;
			this.block[24] = val6;
		} else {
			x03 = (this.block[24] << 11) + 128;
			x83 = 565 * (x43 + x53);
			x43 = x83 + 2276 * x43;
			x53 = x83 - 3406 * x53;
			x83 = 2408 * (x63 + x73);
			x63 = x83 - 799 * x63;
			x73 = x83 - 4017 * x73;
			x83 = x03 + x13;
			x03 -= x13;
			x13 = 1108 * (x33 + x23);
			x23 = x13 - 3784 * x23;
			x33 = x13 + 1568 * x33;
			x13 = x43 + x63;
			x43 -= x63;
			x63 = x53 + x73;
			x53 -= x73;
			x73 = x83 + x33;
			x83 -= x33;
			x33 = x03 + x23;
			x03 -= x23;
			x23 = 181 * (x43 + x53) + 128 >> 8;
			x43 = 181 * (x43 - x53) + 128 >> 8;
			this.block[24] = x73 + x13 >> 8;
			this.block[25] = x33 + x23 >> 8;
			this.block[26] = x03 + x43 >> 8;
			this.block[27] = x83 + x63 >> 8;
			this.block[28] = x83 - x63 >> 8;
			this.block[29] = x03 - x43 >> 8;
			this.block[30] = x33 - x23 >> 8;
			this.block[31] = x73 - x13 >> 8;
		}
		let x04;
		let x84;
		let x14 = this.block[36] << 11;
		let x24 = this.block[38];
		let x34 = this.block[34];
		let x44 = this.block[33];
		let x54 = this.block[39];
		let x64 = this.block[37];
		let x74 = this.block[35];
		if((x14 | x24 | x34 | x44 | x54 | x64 | x74) == 0) {
			let val = this.block[39] = this.block[32] << 3;
			let val1 = this.block[38] = val;
			let val2 = this.block[37] = val1;
			let val3 = this.block[36] = val2;
			let val4 = this.block[35] = val3;
			let val5 = this.block[34] = val4;
			let val6 = this.block[33] = val5;
			this.block[32] = val6;
		} else {
			x04 = (this.block[32] << 11) + 128;
			x84 = 565 * (x44 + x54);
			x44 = x84 + 2276 * x44;
			x54 = x84 - 3406 * x54;
			x84 = 2408 * (x64 + x74);
			x64 = x84 - 799 * x64;
			x74 = x84 - 4017 * x74;
			x84 = x04 + x14;
			x04 -= x14;
			x14 = 1108 * (x34 + x24);
			x24 = x14 - 3784 * x24;
			x34 = x14 + 1568 * x34;
			x14 = x44 + x64;
			x44 -= x64;
			x64 = x54 + x74;
			x54 -= x74;
			x74 = x84 + x34;
			x84 -= x34;
			x34 = x04 + x24;
			x04 -= x24;
			x24 = 181 * (x44 + x54) + 128 >> 8;
			x44 = 181 * (x44 - x54) + 128 >> 8;
			this.block[32] = x74 + x14 >> 8;
			this.block[33] = x34 + x24 >> 8;
			this.block[34] = x04 + x44 >> 8;
			this.block[35] = x84 + x64 >> 8;
			this.block[36] = x84 - x64 >> 8;
			this.block[37] = x04 - x44 >> 8;
			this.block[38] = x34 - x24 >> 8;
			this.block[39] = x74 - x14 >> 8;
		}
		let x05;
		let x85;
		let x15 = this.block[44] << 11;
		let x25 = this.block[46];
		let x35 = this.block[42];
		let x45 = this.block[41];
		let x55 = this.block[47];
		let x65 = this.block[45];
		let x75 = this.block[43];
		if((x15 | x25 | x35 | x45 | x55 | x65 | x75) == 0) {
			let val = this.block[47] = this.block[40] << 3;
			let val1 = this.block[46] = val;
			let val2 = this.block[45] = val1;
			let val3 = this.block[44] = val2;
			let val4 = this.block[43] = val3;
			let val5 = this.block[42] = val4;
			let val6 = this.block[41] = val5;
			this.block[40] = val6;
		} else {
			x05 = (this.block[40] << 11) + 128;
			x85 = 565 * (x45 + x55);
			x45 = x85 + 2276 * x45;
			x55 = x85 - 3406 * x55;
			x85 = 2408 * (x65 + x75);
			x65 = x85 - 799 * x65;
			x75 = x85 - 4017 * x75;
			x85 = x05 + x15;
			x05 -= x15;
			x15 = 1108 * (x35 + x25);
			x25 = x15 - 3784 * x25;
			x35 = x15 + 1568 * x35;
			x15 = x45 + x65;
			x45 -= x65;
			x65 = x55 + x75;
			x55 -= x75;
			x75 = x85 + x35;
			x85 -= x35;
			x35 = x05 + x25;
			x05 -= x25;
			x25 = 181 * (x45 + x55) + 128 >> 8;
			x45 = 181 * (x45 - x55) + 128 >> 8;
			this.block[40] = x75 + x15 >> 8;
			this.block[41] = x35 + x25 >> 8;
			this.block[42] = x05 + x45 >> 8;
			this.block[43] = x85 + x65 >> 8;
			this.block[44] = x85 - x65 >> 8;
			this.block[45] = x05 - x45 >> 8;
			this.block[46] = x35 - x25 >> 8;
			this.block[47] = x75 - x15 >> 8;
		}
		let x06;
		let x86;
		let x16 = this.block[52] << 11;
		let x26 = this.block[54];
		let x36 = this.block[50];
		let x46 = this.block[49];
		let x56 = this.block[55];
		let x66 = this.block[53];
		let x76 = this.block[51];
		if((x16 | x26 | x36 | x46 | x56 | x66 | x76) == 0) {
			let val = this.block[55] = this.block[48] << 3;
			let val1 = this.block[54] = val;
			let val2 = this.block[53] = val1;
			let val3 = this.block[52] = val2;
			let val4 = this.block[51] = val3;
			let val5 = this.block[50] = val4;
			let val6 = this.block[49] = val5;
			this.block[48] = val6;
		} else {
			x06 = (this.block[48] << 11) + 128;
			x86 = 565 * (x46 + x56);
			x46 = x86 + 2276 * x46;
			x56 = x86 - 3406 * x56;
			x86 = 2408 * (x66 + x76);
			x66 = x86 - 799 * x66;
			x76 = x86 - 4017 * x76;
			x86 = x06 + x16;
			x06 -= x16;
			x16 = 1108 * (x36 + x26);
			x26 = x16 - 3784 * x26;
			x36 = x16 + 1568 * x36;
			x16 = x46 + x66;
			x46 -= x66;
			x66 = x56 + x76;
			x56 -= x76;
			x76 = x86 + x36;
			x86 -= x36;
			x36 = x06 + x26;
			x06 -= x26;
			x26 = 181 * (x46 + x56) + 128 >> 8;
			x46 = 181 * (x46 - x56) + 128 >> 8;
			this.block[48] = x76 + x16 >> 8;
			this.block[49] = x36 + x26 >> 8;
			this.block[50] = x06 + x46 >> 8;
			this.block[51] = x86 + x66 >> 8;
			this.block[52] = x86 - x66 >> 8;
			this.block[53] = x06 - x46 >> 8;
			this.block[54] = x36 - x26 >> 8;
			this.block[55] = x76 - x16 >> 8;
		}
		let x07;
		let x87;
		let x17 = this.block[60] << 11;
		let x27 = this.block[62];
		let x37 = this.block[58];
		let x47 = this.block[57];
		let x57 = this.block[63];
		let x67 = this.block[61];
		let x77 = this.block[59];
		if((x17 | x27 | x37 | x47 | x57 | x67 | x77) == 0) {
			let val = this.block[63] = this.block[56] << 3;
			let val1 = this.block[62] = val;
			let val2 = this.block[61] = val1;
			let val3 = this.block[60] = val2;
			let val4 = this.block[59] = val3;
			let val5 = this.block[58] = val4;
			let val6 = this.block[57] = val5;
			this.block[56] = val6;
		} else {
			x07 = (this.block[56] << 11) + 128;
			x87 = 565 * (x47 + x57);
			x47 = x87 + 2276 * x47;
			x57 = x87 - 3406 * x57;
			x87 = 2408 * (x67 + x77);
			x67 = x87 - 799 * x67;
			x77 = x87 - 4017 * x77;
			x87 = x07 + x17;
			x07 -= x17;
			x17 = 1108 * (x37 + x27);
			x27 = x17 - 3784 * x27;
			x37 = x17 + 1568 * x37;
			x17 = x47 + x67;
			x47 -= x67;
			x67 = x57 + x77;
			x57 -= x77;
			x77 = x87 + x37;
			x87 -= x37;
			x37 = x07 + x27;
			x07 -= x27;
			x27 = 181 * (x47 + x57) + 128 >> 8;
			x47 = 181 * (x47 - x57) + 128 >> 8;
			this.block[56] = x77 + x17 >> 8;
			this.block[57] = x37 + x27 >> 8;
			this.block[58] = x07 + x47 >> 8;
			this.block[59] = x87 + x67 >> 8;
			this.block[60] = x87 - x67 >> 8;
			this.block[61] = x07 - x47 >> 8;
			this.block[62] = x37 - x27 >> 8;
			this.block[63] = x77 - x17 >> 8;
		}
		let po1 = po;
		let stride = c.stride;
		let x08;
		let x88;
		let x18 = this.block[32] << 8;
		let x28 = this.block[48];
		let x38 = this.block[16];
		let x48 = this.block[8];
		let x58 = this.block[56];
		let x68 = this.block[40];
		let x78 = this.block[24];
		if((x18 | x28 | x38 | x48 | x58 | x68 | x78) == 0) {
			let x = (this.block[0] + 32 >> 6) + 128;
			x18 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po] = x18;
			po1 = po + stride;
			out.b[po1] = x18;
			po1 += stride;
			out.b[po1] = x18;
			po1 += stride;
			out.b[po1] = x18;
			po1 += stride;
			out.b[po1] = x18;
			po1 += stride;
			out.b[po1] = x18;
			po1 += stride;
			out.b[po1] = x18;
			po1 += stride;
			out.b[po1] = x18;
		} else {
			x08 = (this.block[0] << 8) + 8192;
			x88 = 565 * (x48 + x58) + 4;
			x48 = x88 + 2276 * x48 >> 3;
			x58 = x88 - 3406 * x58 >> 3;
			x88 = 2408 * (x68 + x78) + 4;
			x68 = x88 - 799 * x68 >> 3;
			x78 = x88 - 4017 * x78 >> 3;
			x88 = x08 + x18;
			x08 -= x18;
			x18 = 1108 * (x38 + x28) + 4;
			x28 = x18 - 3784 * x28 >> 3;
			x38 = x18 + 1568 * x38 >> 3;
			x18 = x48 + x68;
			x48 -= x68;
			x68 = x58 + x78;
			x58 -= x78;
			x78 = x88 + x38;
			x88 -= x38;
			x38 = x08 + x28;
			x08 -= x28;
			x28 = 181 * (x48 + x58) + 128 >> 8;
			x48 = 181 * (x48 - x58) + 128 >> 8;
			let x = (x78 + x18 >> 14) + 128;
			out.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
			po1 = po + stride;
			let x1 = (x38 + x28 >> 14) + 128;
			out.b[po1] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			po1 += stride;
			let x2 = (x08 + x48 >> 14) + 128;
			out.b[po1] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			po1 += stride;
			let x3 = (x88 + x68 >> 14) + 128;
			out.b[po1] = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
			po1 += stride;
			let x4 = (x88 - x68 >> 14) + 128;
			out.b[po1] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
			po1 += stride;
			let x5 = (x08 - x48 >> 14) + 128;
			out.b[po1] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
			po1 += stride;
			let x6 = (x38 - x28 >> 14) + 128;
			out.b[po1] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			po1 += stride;
			let x7 = (x78 - x18 >> 14) + 128;
			out.b[po1] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
		}
		let po2 = 1 + po;
		let stride1 = c.stride;
		let x09;
		let x89;
		let x19 = this.block[33] << 8;
		let x29 = this.block[49];
		let x39 = this.block[17];
		let x49 = this.block[9];
		let x59 = this.block[57];
		let x69 = this.block[41];
		let x79 = this.block[25];
		if((x19 | x29 | x39 | x49 | x59 | x69 | x79) == 0) {
			let x = (this.block[1] + 32 >> 6) + 128;
			x19 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po2] = x19;
			po2 += stride1;
			out.b[po2] = x19;
			po2 += stride1;
			out.b[po2] = x19;
			po2 += stride1;
			out.b[po2] = x19;
			po2 += stride1;
			out.b[po2] = x19;
			po2 += stride1;
			out.b[po2] = x19;
			po2 += stride1;
			out.b[po2] = x19;
			po2 += stride1;
			out.b[po2] = x19;
		} else {
			x09 = (this.block[1] << 8) + 8192;
			x89 = 565 * (x49 + x59) + 4;
			x49 = x89 + 2276 * x49 >> 3;
			x59 = x89 - 3406 * x59 >> 3;
			x89 = 2408 * (x69 + x79) + 4;
			x69 = x89 - 799 * x69 >> 3;
			x79 = x89 - 4017 * x79 >> 3;
			x89 = x09 + x19;
			x09 -= x19;
			x19 = 1108 * (x39 + x29) + 4;
			x29 = x19 - 3784 * x29 >> 3;
			x39 = x19 + 1568 * x39 >> 3;
			x19 = x49 + x69;
			x49 -= x69;
			x69 = x59 + x79;
			x59 -= x79;
			x79 = x89 + x39;
			x89 -= x39;
			x39 = x09 + x29;
			x09 -= x29;
			x29 = 181 * (x49 + x59) + 128 >> 8;
			x49 = 181 * (x49 - x59) + 128 >> 8;
			let x = (x79 + x19 >> 14) + 128;
			out.b[po2] = x < 0 ? 0 : x > 255 ? 255 : x;
			po2 += stride1;
			let x1 = (x39 + x29 >> 14) + 128;
			out.b[po2] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			po2 += stride1;
			let x2 = (x09 + x49 >> 14) + 128;
			out.b[po2] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			po2 += stride1;
			let x3 = (x89 + x69 >> 14) + 128;
			out.b[po2] = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
			po2 += stride1;
			let x4 = (x89 - x69 >> 14) + 128;
			out.b[po2] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
			po2 += stride1;
			let x5 = (x09 - x49 >> 14) + 128;
			out.b[po2] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
			po2 += stride1;
			let x6 = (x39 - x29 >> 14) + 128;
			out.b[po2] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			po2 += stride1;
			let x7 = (x79 - x19 >> 14) + 128;
			out.b[po2] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
		}
		let po3 = 2 + po;
		let stride2 = c.stride;
		let x010;
		let x810;
		let x110 = this.block[34] << 8;
		let x210 = this.block[50];
		let x310 = this.block[18];
		let x410 = this.block[10];
		let x510 = this.block[58];
		let x610 = this.block[42];
		let x710 = this.block[26];
		if((x110 | x210 | x310 | x410 | x510 | x610 | x710) == 0) {
			let x = (this.block[2] + 32 >> 6) + 128;
			x110 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po3] = x110;
			po3 += stride2;
			out.b[po3] = x110;
			po3 += stride2;
			out.b[po3] = x110;
			po3 += stride2;
			out.b[po3] = x110;
			po3 += stride2;
			out.b[po3] = x110;
			po3 += stride2;
			out.b[po3] = x110;
			po3 += stride2;
			out.b[po3] = x110;
			po3 += stride2;
			out.b[po3] = x110;
		} else {
			x010 = (this.block[2] << 8) + 8192;
			x810 = 565 * (x410 + x510) + 4;
			x410 = x810 + 2276 * x410 >> 3;
			x510 = x810 - 3406 * x510 >> 3;
			x810 = 2408 * (x610 + x710) + 4;
			x610 = x810 - 799 * x610 >> 3;
			x710 = x810 - 4017 * x710 >> 3;
			x810 = x010 + x110;
			x010 -= x110;
			x110 = 1108 * (x310 + x210) + 4;
			x210 = x110 - 3784 * x210 >> 3;
			x310 = x110 + 1568 * x310 >> 3;
			x110 = x410 + x610;
			x410 -= x610;
			x610 = x510 + x710;
			x510 -= x710;
			x710 = x810 + x310;
			x810 -= x310;
			x310 = x010 + x210;
			x010 -= x210;
			x210 = 181 * (x410 + x510) + 128 >> 8;
			x410 = 181 * (x410 - x510) + 128 >> 8;
			let x = (x710 + x110 >> 14) + 128;
			out.b[po3] = x < 0 ? 0 : x > 255 ? 255 : x;
			po3 += stride2;
			let x1 = (x310 + x210 >> 14) + 128;
			out.b[po3] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			po3 += stride2;
			let x2 = (x010 + x410 >> 14) + 128;
			out.b[po3] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			po3 += stride2;
			let x3 = (x810 + x610 >> 14) + 128;
			out.b[po3] = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
			po3 += stride2;
			let x4 = (x810 - x610 >> 14) + 128;
			out.b[po3] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
			po3 += stride2;
			let x5 = (x010 - x410 >> 14) + 128;
			out.b[po3] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
			po3 += stride2;
			let x6 = (x310 - x210 >> 14) + 128;
			out.b[po3] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			po3 += stride2;
			let x7 = (x710 - x110 >> 14) + 128;
			out.b[po3] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
		}
		let po4 = 3 + po;
		let stride3 = c.stride;
		let x011;
		let x811;
		let x111 = this.block[35] << 8;
		let x211 = this.block[51];
		let x311 = this.block[19];
		let x411 = this.block[11];
		let x511 = this.block[59];
		let x611 = this.block[43];
		let x711 = this.block[27];
		if((x111 | x211 | x311 | x411 | x511 | x611 | x711) == 0) {
			let x = (this.block[3] + 32 >> 6) + 128;
			x111 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po4] = x111;
			po4 += stride3;
			out.b[po4] = x111;
			po4 += stride3;
			out.b[po4] = x111;
			po4 += stride3;
			out.b[po4] = x111;
			po4 += stride3;
			out.b[po4] = x111;
			po4 += stride3;
			out.b[po4] = x111;
			po4 += stride3;
			out.b[po4] = x111;
			po4 += stride3;
			out.b[po4] = x111;
		} else {
			x011 = (this.block[3] << 8) + 8192;
			x811 = 565 * (x411 + x511) + 4;
			x411 = x811 + 2276 * x411 >> 3;
			x511 = x811 - 3406 * x511 >> 3;
			x811 = 2408 * (x611 + x711) + 4;
			x611 = x811 - 799 * x611 >> 3;
			x711 = x811 - 4017 * x711 >> 3;
			x811 = x011 + x111;
			x011 -= x111;
			x111 = 1108 * (x311 + x211) + 4;
			x211 = x111 - 3784 * x211 >> 3;
			x311 = x111 + 1568 * x311 >> 3;
			x111 = x411 + x611;
			x411 -= x611;
			x611 = x511 + x711;
			x511 -= x711;
			x711 = x811 + x311;
			x811 -= x311;
			x311 = x011 + x211;
			x011 -= x211;
			x211 = 181 * (x411 + x511) + 128 >> 8;
			x411 = 181 * (x411 - x511) + 128 >> 8;
			let x = (x711 + x111 >> 14) + 128;
			out.b[po4] = x < 0 ? 0 : x > 255 ? 255 : x;
			po4 += stride3;
			let x1 = (x311 + x211 >> 14) + 128;
			out.b[po4] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			po4 += stride3;
			let x2 = (x011 + x411 >> 14) + 128;
			out.b[po4] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			po4 += stride3;
			let x3 = (x811 + x611 >> 14) + 128;
			out.b[po4] = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
			po4 += stride3;
			let x4 = (x811 - x611 >> 14) + 128;
			out.b[po4] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
			po4 += stride3;
			let x5 = (x011 - x411 >> 14) + 128;
			out.b[po4] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
			po4 += stride3;
			let x6 = (x311 - x211 >> 14) + 128;
			out.b[po4] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			po4 += stride3;
			let x7 = (x711 - x111 >> 14) + 128;
			out.b[po4] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
		}
		let po5 = 4 + po;
		let stride4 = c.stride;
		let x012;
		let x812;
		let x112 = this.block[36] << 8;
		let x212 = this.block[52];
		let x312 = this.block[20];
		let x412 = this.block[12];
		let x512 = this.block[60];
		let x612 = this.block[44];
		let x712 = this.block[28];
		if((x112 | x212 | x312 | x412 | x512 | x612 | x712) == 0) {
			let x = (this.block[4] + 32 >> 6) + 128;
			x112 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po5] = x112;
			po5 += stride4;
			out.b[po5] = x112;
			po5 += stride4;
			out.b[po5] = x112;
			po5 += stride4;
			out.b[po5] = x112;
			po5 += stride4;
			out.b[po5] = x112;
			po5 += stride4;
			out.b[po5] = x112;
			po5 += stride4;
			out.b[po5] = x112;
			po5 += stride4;
			out.b[po5] = x112;
		} else {
			x012 = (this.block[4] << 8) + 8192;
			x812 = 565 * (x412 + x512) + 4;
			x412 = x812 + 2276 * x412 >> 3;
			x512 = x812 - 3406 * x512 >> 3;
			x812 = 2408 * (x612 + x712) + 4;
			x612 = x812 - 799 * x612 >> 3;
			x712 = x812 - 4017 * x712 >> 3;
			x812 = x012 + x112;
			x012 -= x112;
			x112 = 1108 * (x312 + x212) + 4;
			x212 = x112 - 3784 * x212 >> 3;
			x312 = x112 + 1568 * x312 >> 3;
			x112 = x412 + x612;
			x412 -= x612;
			x612 = x512 + x712;
			x512 -= x712;
			x712 = x812 + x312;
			x812 -= x312;
			x312 = x012 + x212;
			x012 -= x212;
			x212 = 181 * (x412 + x512) + 128 >> 8;
			x412 = 181 * (x412 - x512) + 128 >> 8;
			let x = (x712 + x112 >> 14) + 128;
			out.b[po5] = x < 0 ? 0 : x > 255 ? 255 : x;
			po5 += stride4;
			let x1 = (x312 + x212 >> 14) + 128;
			out.b[po5] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			po5 += stride4;
			let x2 = (x012 + x412 >> 14) + 128;
			out.b[po5] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			po5 += stride4;
			let x3 = (x812 + x612 >> 14) + 128;
			out.b[po5] = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
			po5 += stride4;
			let x4 = (x812 - x612 >> 14) + 128;
			out.b[po5] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
			po5 += stride4;
			let x5 = (x012 - x412 >> 14) + 128;
			out.b[po5] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
			po5 += stride4;
			let x6 = (x312 - x212 >> 14) + 128;
			out.b[po5] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			po5 += stride4;
			let x7 = (x712 - x112 >> 14) + 128;
			out.b[po5] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
		}
		let po6 = 5 + po;
		let stride5 = c.stride;
		let x013;
		let x813;
		let x113 = this.block[37] << 8;
		let x213 = this.block[53];
		let x313 = this.block[21];
		let x413 = this.block[13];
		let x513 = this.block[61];
		let x613 = this.block[45];
		let x713 = this.block[29];
		if((x113 | x213 | x313 | x413 | x513 | x613 | x713) == 0) {
			let x = (this.block[5] + 32 >> 6) + 128;
			x113 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po6] = x113;
			po6 += stride5;
			out.b[po6] = x113;
			po6 += stride5;
			out.b[po6] = x113;
			po6 += stride5;
			out.b[po6] = x113;
			po6 += stride5;
			out.b[po6] = x113;
			po6 += stride5;
			out.b[po6] = x113;
			po6 += stride5;
			out.b[po6] = x113;
			po6 += stride5;
			out.b[po6] = x113;
		} else {
			x013 = (this.block[5] << 8) + 8192;
			x813 = 565 * (x413 + x513) + 4;
			x413 = x813 + 2276 * x413 >> 3;
			x513 = x813 - 3406 * x513 >> 3;
			x813 = 2408 * (x613 + x713) + 4;
			x613 = x813 - 799 * x613 >> 3;
			x713 = x813 - 4017 * x713 >> 3;
			x813 = x013 + x113;
			x013 -= x113;
			x113 = 1108 * (x313 + x213) + 4;
			x213 = x113 - 3784 * x213 >> 3;
			x313 = x113 + 1568 * x313 >> 3;
			x113 = x413 + x613;
			x413 -= x613;
			x613 = x513 + x713;
			x513 -= x713;
			x713 = x813 + x313;
			x813 -= x313;
			x313 = x013 + x213;
			x013 -= x213;
			x213 = 181 * (x413 + x513) + 128 >> 8;
			x413 = 181 * (x413 - x513) + 128 >> 8;
			let x = (x713 + x113 >> 14) + 128;
			out.b[po6] = x < 0 ? 0 : x > 255 ? 255 : x;
			po6 += stride5;
			let x1 = (x313 + x213 >> 14) + 128;
			out.b[po6] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			po6 += stride5;
			let x2 = (x013 + x413 >> 14) + 128;
			out.b[po6] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			po6 += stride5;
			let x3 = (x813 + x613 >> 14) + 128;
			out.b[po6] = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
			po6 += stride5;
			let x4 = (x813 - x613 >> 14) + 128;
			out.b[po6] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
			po6 += stride5;
			let x5 = (x013 - x413 >> 14) + 128;
			out.b[po6] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
			po6 += stride5;
			let x6 = (x313 - x213 >> 14) + 128;
			out.b[po6] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			po6 += stride5;
			let x7 = (x713 - x113 >> 14) + 128;
			out.b[po6] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
		}
		let po7 = 6 + po;
		let stride6 = c.stride;
		let x014;
		let x814;
		let x114 = this.block[38] << 8;
		let x214 = this.block[54];
		let x314 = this.block[22];
		let x414 = this.block[14];
		let x514 = this.block[62];
		let x614 = this.block[46];
		let x714 = this.block[30];
		if((x114 | x214 | x314 | x414 | x514 | x614 | x714) == 0) {
			let x = (this.block[6] + 32 >> 6) + 128;
			x114 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po7] = x114;
			po7 += stride6;
			out.b[po7] = x114;
			po7 += stride6;
			out.b[po7] = x114;
			po7 += stride6;
			out.b[po7] = x114;
			po7 += stride6;
			out.b[po7] = x114;
			po7 += stride6;
			out.b[po7] = x114;
			po7 += stride6;
			out.b[po7] = x114;
			po7 += stride6;
			out.b[po7] = x114;
		} else {
			x014 = (this.block[6] << 8) + 8192;
			x814 = 565 * (x414 + x514) + 4;
			x414 = x814 + 2276 * x414 >> 3;
			x514 = x814 - 3406 * x514 >> 3;
			x814 = 2408 * (x614 + x714) + 4;
			x614 = x814 - 799 * x614 >> 3;
			x714 = x814 - 4017 * x714 >> 3;
			x814 = x014 + x114;
			x014 -= x114;
			x114 = 1108 * (x314 + x214) + 4;
			x214 = x114 - 3784 * x214 >> 3;
			x314 = x114 + 1568 * x314 >> 3;
			x114 = x414 + x614;
			x414 -= x614;
			x614 = x514 + x714;
			x514 -= x714;
			x714 = x814 + x314;
			x814 -= x314;
			x314 = x014 + x214;
			x014 -= x214;
			x214 = 181 * (x414 + x514) + 128 >> 8;
			x414 = 181 * (x414 - x514) + 128 >> 8;
			let x = (x714 + x114 >> 14) + 128;
			out.b[po7] = x < 0 ? 0 : x > 255 ? 255 : x;
			po7 += stride6;
			let x1 = (x314 + x214 >> 14) + 128;
			out.b[po7] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			po7 += stride6;
			let x2 = (x014 + x414 >> 14) + 128;
			out.b[po7] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			po7 += stride6;
			let x3 = (x814 + x614 >> 14) + 128;
			out.b[po7] = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
			po7 += stride6;
			let x4 = (x814 - x614 >> 14) + 128;
			out.b[po7] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
			po7 += stride6;
			let x5 = (x014 - x414 >> 14) + 128;
			out.b[po7] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
			po7 += stride6;
			let x6 = (x314 - x214 >> 14) + 128;
			out.b[po7] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			po7 += stride6;
			let x7 = (x714 - x114 >> 14) + 128;
			out.b[po7] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
		}
		let po8 = 7 + po;
		let stride7 = c.stride;
		let x015;
		let x815;
		let x115 = this.block[39] << 8;
		let x215 = this.block[55];
		let x315 = this.block[23];
		let x415 = this.block[15];
		let x515 = this.block[63];
		let x615 = this.block[47];
		let x715 = this.block[31];
		if((x115 | x215 | x315 | x415 | x515 | x615 | x715) == 0) {
			let x = (this.block[7] + 32 >> 6) + 128;
			x115 = x < 0 ? 0 : x > 255 ? 255 : x;
			out.b[po8] = x115;
			po8 += stride7;
			out.b[po8] = x115;
			po8 += stride7;
			out.b[po8] = x115;
			po8 += stride7;
			out.b[po8] = x115;
			po8 += stride7;
			out.b[po8] = x115;
			po8 += stride7;
			out.b[po8] = x115;
			po8 += stride7;
			out.b[po8] = x115;
			po8 += stride7;
			out.b[po8] = x115;
		} else {
			x015 = (this.block[7] << 8) + 8192;
			x815 = 565 * (x415 + x515) + 4;
			x415 = x815 + 2276 * x415 >> 3;
			x515 = x815 - 3406 * x515 >> 3;
			x815 = 2408 * (x615 + x715) + 4;
			x615 = x815 - 799 * x615 >> 3;
			x715 = x815 - 4017 * x715 >> 3;
			x815 = x015 + x115;
			x015 -= x115;
			x115 = 1108 * (x315 + x215) + 4;
			x215 = x115 - 3784 * x215 >> 3;
			x315 = x115 + 1568 * x315 >> 3;
			x115 = x415 + x615;
			x415 -= x615;
			x615 = x515 + x715;
			x515 -= x715;
			x715 = x815 + x315;
			x815 -= x315;
			x315 = x015 + x215;
			x015 -= x215;
			x215 = 181 * (x415 + x515) + 128 >> 8;
			x415 = 181 * (x415 - x515) + 128 >> 8;
			let x = (x715 + x115 >> 14) + 128;
			out.b[po8] = x < 0 ? 0 : x > 255 ? 255 : x;
			po8 += stride7;
			let x1 = (x315 + x215 >> 14) + 128;
			out.b[po8] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			po8 += stride7;
			let x2 = (x015 + x415 >> 14) + 128;
			out.b[po8] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			po8 += stride7;
			let x3 = (x815 + x615 >> 14) + 128;
			out.b[po8] = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
			po8 += stride7;
			let x4 = (x815 - x615 >> 14) + 128;
			out.b[po8] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
			po8 += stride7;
			let x5 = (x015 - x415 >> 14) + 128;
			out.b[po8] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
			po8 += stride7;
			let x6 = (x315 - x215 >> 14) + 128;
			out.b[po8] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
			po8 += stride7;
			let x7 = (x715 - x115 >> 14) + 128;
			out.b[po8] = x7 < 0 ? 0 : x7 > 255 ? 255 : x7;
		}
	}
	notSupported() {
		throw haxe_Exception.thrown("This JPG file is not supported");
	}
	njDecodeScan() {
		if(this.size < 2) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
		if(this.length > this.size) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		if(this.length < 4 + 2 * this.ncomp) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		if(this.bytes.b[this.pos] != this.ncomp) {
			this.notSupported();
		}
		this.pos += 1;
		this.size -= 1;
		this.length -= 1;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		let _g = 0;
		let _g1 = this.ncomp;
		while(_g < _g1) {
			let i = _g++;
			let c = this.comps[i];
			if(this.bytes.b[this.pos] != c.cid) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			if((this.bytes.b[this.pos + 1] & 236) != 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			c.dctabsel = this.bytes.b[this.pos + 1] >> 4 << 1;
			c.actabsel = (this.bytes.b[this.pos + 1] & 3) << 1 | 1;
			this.pos += 2;
			this.size -= 2;
			this.length -= 2;
			if(this.size < 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
		}
		let start = this.bytes.b[this.pos];
		let count = this.bytes.b[this.pos + 1];
		let other = this.bytes.b[this.pos + 2];
		if(!this.progressive && start != 0 || count != 63 - start || other != 0) {
			this.notSupported();
		}
		let count1 = this.length;
		this.pos += count1;
		this.size -= count1;
		this.length -= count1;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		let mbx = 0;
		let mby = 0;
		let rstcount = this.rstinterval;
		let nextrst = 0;
		while(true) {
			let _g = 0;
			let _g1 = this.ncomp;
			while(_g < _g1) {
				let i = _g++;
				let c = this.comps[i];
				let _g1 = 0;
				let _g2 = c.ssy;
				while(_g1 < _g2) {
					let sby = _g1++;
					let _g = 0;
					let _g2 = c.ssx;
					while(_g < _g2) {
						let sbx = _g++;
						this.njDecodeBlock(c,(mby * c.ssy + sby) * c.stride + mbx * c.ssx + sbx << 3);
					}
				}
			}
			if(++mbx >= this.mbwidth) {
				mbx = 0;
				if(++mby >= this.mbheight) {
					break;
				}
			}
			if(this.rstinterval != 0 && --rstcount == 0) {
				this.bufbits &= 248;
				let r = this.njShowBits(16);
				this.bufbits -= 16;
				if((r & 65528) != 65488 || (r & 7) != nextrst) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				nextrst = nextrst + 1 & 7;
				rstcount = this.rstinterval;
				this.comps[0].dcpred = 0;
				this.comps[1].dcpred = 0;
				this.comps[2].dcpred = 0;
			}
		}
	}
	njUpsampleH(c) {
		let xmax = c.width - 3;
		let cout = new haxe_io_Bytes(new ArrayBuffer(c.width * c.height << 1));
		let lout = cout;
		let lin = c.pixels;
		let pi = 0;
		let po = 0;
		let _g = 0;
		let _g1 = c.height;
		while(_g < _g1) {
			++_g;
			let x = 139 * lin.b[pi] + -11 * lin.b[pi + 1] + 64 >> 7;
			lout.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
			let x1 = 104 * lin.b[pi] + 27 * lin.b[pi + 1] + -3 * lin.b[pi + 2] + 64 >> 7;
			lout.b[po + 1] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			let x2 = 28 * lin.b[pi] + 109 * lin.b[pi + 1] + -9 * lin.b[pi + 2] + 64 >> 7;
			lout.b[po + 2] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			let _g1 = 0;
			while(_g1 < xmax) {
				let x = _g1++;
				let x1 = -9 * lin.b[pi + x] + 111 * lin.b[pi + x + 1] + 29 * lin.b[pi + x + 2] + -3 * lin.b[pi + x + 3] + 64 >> 7;
				lout.b[po + (x << 1) + 3] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
				let x2 = -3 * lin.b[pi + x] + 29 * lin.b[pi + x + 1] + 111 * lin.b[pi + x + 2] + -9 * lin.b[pi + x + 3] + 64 >> 7;
				lout.b[po + (x << 1) + 4] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			}
			pi += c.stride;
			po += c.width << 1;
			let x3 = 28 * lin.b[pi - 1] + 109 * lin.b[pi - 2] + -9 * lin.b[pi - 3] + 64 >> 7;
			lout.b[po - 3] = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
			let x4 = 104 * lin.b[pi - 1] + 27 * lin.b[pi - 2] + -3 * lin.b[pi - 3] + 64 >> 7;
			lout.b[po - 2] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
			let x5 = 139 * lin.b[pi - 1] + -11 * lin.b[pi - 2] + 64 >> 7;
			lout.b[po - 1] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
		}
		c.width <<= 1;
		c.stride = c.width;
		c.pixels = cout;
	}
	njUpsampleV(c) {
		let w = c.width;
		let s1 = c.stride;
		let s2 = s1 + s1;
		let out = new haxe_io_Bytes(new ArrayBuffer(c.width * c.height << 1));
		let pi = 0;
		let po = 0;
		let cout = out;
		let cin = c.pixels;
		let _g = 0;
		while(_g < w) {
			let x = _g++;
			po = x;
			pi = x;
			let x1 = 139 * cin.b[pi] + -11 * cin.b[pi + s1] + 64 >> 7;
			cout.b[x] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
			po = x + w;
			let x2 = 104 * cin.b[pi] + 27 * cin.b[pi + s1] + -3 * cin.b[pi + s2] + 64 >> 7;
			cout.b[po] = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
			po += w;
			let x3 = 28 * cin.b[pi] + 109 * cin.b[pi + s1] + -9 * cin.b[pi + s2] + 64 >> 7;
			cout.b[po] = x3 < 0 ? 0 : x3 > 255 ? 255 : x3;
			po += w;
			pi += s1;
			let _g1 = 0;
			let _g2 = c.height - 2;
			while(_g1 < _g2) {
				++_g1;
				let x = -9 * cin.b[pi - s1] + 111 * cin.b[pi] + 29 * cin.b[pi + s1] + -3 * cin.b[pi + s2] + 64 >> 7;
				cout.b[po] = x < 0 ? 0 : x > 255 ? 255 : x;
				po += w;
				let x1 = -3 * cin.b[pi - s1] + 29 * cin.b[pi] + 111 * cin.b[pi + s1] + -9 * cin.b[pi + s2] + 64 >> 7;
				cout.b[po] = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
				po += w;
				pi += s1;
			}
			pi += s1;
			let x4 = 28 * cin.b[pi] + 109 * cin.b[pi - s1] + -9 * cin.b[pi - s2] + 64 >> 7;
			cout.b[po] = x4 < 0 ? 0 : x4 > 255 ? 255 : x4;
			po += w;
			let x5 = 104 * cin.b[pi] + 27 * cin.b[pi - s1] + -3 * cin.b[pi - s2] + 64 >> 7;
			cout.b[po] = x5 < 0 ? 0 : x5 > 255 ? 255 : x5;
			po += w;
			let x6 = 139 * cin.b[pi] + -11 * cin.b[pi - s1] + 64 >> 7;
			cout.b[po] = x6 < 0 ? 0 : x6 > 255 ? 255 : x6;
		}
		c.height <<= 1;
		c.stride = c.width;
		c.pixels = out;
	}
	njUpsample(c) {
		let xshift = 0;
		let yshift = 0;
		while(c.width < this.width) {
			c.width <<= 1;
			++xshift;
		}
		while(c.height < this.height) {
			c.height <<= 1;
			++yshift;
		}
		let out = new haxe_io_Bytes(new ArrayBuffer(c.width * c.height));
		let lin = c.pixels;
		let pout = 0;
		let lout = out;
		let _g = 0;
		let _g1 = c.height;
		while(_g < _g1) {
			let y = _g++;
			let pin = (y >> yshift) * c.stride;
			let _g1 = 0;
			let _g2 = c.width;
			while(_g1 < _g2) {
				let x = _g1++;
				lout.b[pout++] = lin.b[(x >> xshift) + pin];
			}
		}
		c.stride = c.width;
		c.pixels = out;
	}
	njConvert() {
		let _g = 0;
		let _g1 = this.ncomp;
		while(_g < _g1) {
			let i = _g++;
			let c = this.comps[i];
			switch(this.filter._hx_index) {
			case 0:
				if(c.width < this.width || c.height < this.height) {
					this.njUpsample(c);
				}
				break;
			case 1:
				while(c.width < this.width || c.height < this.height) {
					if(c.width < this.width) {
						this.njUpsampleH(c);
					}
					if(c.height < this.height) {
						this.njUpsampleV(c);
					}
				}
				break;
			}
			if(c.width < this.width || c.height < this.height) {
				throw haxe_Exception.thrown("assert");
			}
		}
		let pixels = new haxe_io_Bytes(new ArrayBuffer(this.width * this.height * 4));
		if(this.ncomp == 3) {
			let py = this.comps[0].pixels;
			let pcb = this.comps[1].pixels;
			let pcr = this.comps[2].pixels;
			let pix = pixels;
			let k1 = 0;
			let k2 = 0;
			let k3 = 0;
			let out = 0;
			let _g = 0;
			let _g1 = this.height;
			while(_g < _g1) {
				++_g;
				let _g1 = 0;
				let _g2 = this.width;
				while(_g1 < _g2) {
					++_g1;
					let y = py.b[k1++] << 8;
					let cb = pcb.b[k2++] - 128;
					let cr = pcr.b[k3++] - 128;
					let x = y + 359 * cr + 128 >> 8;
					let r = x < 0 ? 0 : x > 255 ? 255 : x;
					let x1 = y - 88 * cb - 183 * cr + 128 >> 8;
					let g = x1 < 0 ? 0 : x1 > 255 ? 255 : x1;
					let x2 = y + 454 * cb + 128 >> 8;
					let b = x2 < 0 ? 0 : x2 > 255 ? 255 : x2;
					pix.b[out++] = b;
					pix.b[out++] = g;
					pix.b[out++] = r;
					pix.b[out++] = 255;
				}
				k1 += this.comps[0].stride - this.width;
				k2 += this.comps[1].stride - this.width;
				k3 += this.comps[2].stride - this.width;
			}
		} else {
			throw haxe_Exception.thrown("TODO");
		}
		return pixels;
	}
	njDecode() {
		if(this.size < 2 || this.bytes.b[this.pos] != 255 || this.bytes.b[this.pos + 1] != 216) {
			throw haxe_Exception.thrown("This file is not a JPEG");
		}
		this.pos += 2;
		this.size -= 2;
		this.length -= 2;
		if(this.size < 0) {
			throw haxe_Exception.thrown("Invalid JPEG file");
		}
		_hx_loop1: while(true) {
			if(this.size < 2 || this.bytes.b[this.pos] != 255) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			this.pos += 2;
			this.size -= 2;
			this.length -= 2;
			if(this.size < 0) {
				throw haxe_Exception.thrown("Invalid JPEG file");
			}
			switch(this.bytes.b[this.pos + (-1)]) {
			case 192:
				this.njDecodeSOF();
				break;
			case 194:
				this.progressive = true;
				if(this.progressive) {
					throw haxe_Exception.thrown("Unsupported progressive JPG");
				}
				if(this.vlctab[4] == null) {
					this.vlctab[4] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				if(this.vlctab[5] == null) {
					this.vlctab[5] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				if(this.vlctab[6] == null) {
					this.vlctab[6] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				if(this.vlctab[7] == null) {
					this.vlctab[7] = new haxe_io_Bytes(new ArrayBuffer(131072));
				}
				this.njDecodeSOF();
				break;
			case 195:
				throw haxe_Exception.thrown("Unsupported lossless JPG");
			case 196:
				this.njDecodeDHT();
				break;
			case 218:
				this.njDecodeScan();
				break _hx_loop1;
			case 219:
				this.njDecodeDQT();
				break;
			case 221:
				this.njDecodeDRI();
				break;
			case 254:
				if(this.size < 2) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
				if(this.length > this.size) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				this.pos += 2;
				this.size -= 2;
				this.length -= 2;
				if(this.size < 0) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				let count = this.length;
				this.pos += count;
				this.size -= count;
				this.length -= count;
				if(this.size < 0) {
					throw haxe_Exception.thrown("Invalid JPEG file");
				}
				break;
			default:
				switch(this.bytes.b[this.pos + (-1)] & 240) {
				case 192:
					throw haxe_Exception.thrown("Unsupported jpeg type " + (this.bytes.b[this.pos + (-1)] & 15));
				case 224:
					if(this.size < 2) {
						throw haxe_Exception.thrown("Invalid JPEG file");
					}
					this.length = this.bytes.b[this.pos] << 8 | this.bytes.b[this.pos + 1];
					if(this.length > this.size) {
						throw haxe_Exception.thrown("Invalid JPEG file");
					}
					this.pos += 2;
					this.size -= 2;
					this.length -= 2;
					if(this.size < 0) {
						throw haxe_Exception.thrown("Invalid JPEG file");
					}
					let count1 = this.length;
					this.pos += count1;
					this.size -= count1;
					this.length -= count1;
					if(this.size < 0) {
						throw haxe_Exception.thrown("Invalid JPEG file");
					}
					break;
				default:
					throw haxe_Exception.thrown("Unsupported jpeg tag 0x" + StringTools.hex(this.bytes.b[this.pos + (-1)],2));
				}
			}
		}
		let pixels = this.njConvert();
		this.cleanup();
		return { pixels : pixels, width : this.width, height : this.height};
	}
	static decode(bytes,filter,position,size) {
		if(size == null) {
			size = -1;
		}
		if(position == null) {
			position = 0;
		}
		if(hxd_res_NanoJpeg.inst == null) {
			hxd_res_NanoJpeg.inst = new hxd_res_NanoJpeg();
		}
		hxd_res_NanoJpeg.inst.njInit(bytes,position,size,filter);
		return hxd_res_NanoJpeg.inst.njDecode();
	}
}
$hxClasses["hxd.res.NanoJpeg"] = hxd_res_NanoJpeg;
hxd_res_NanoJpeg.__name__ = "hxd.res.NanoJpeg";
Object.assign(hxd_res_NanoJpeg.prototype, {
	__class__: hxd_res_NanoJpeg
	,bytes: null
	,pos: null
	,size: null
	,length: null
	,width: null
	,height: null
	,ncomp: null
	,comps: null
	,counts: null
	,qtab: null
	,qtused: null
	,qtavail: null
	,vlctab: null
	,block: null
	,njZZ: null
	,progressive: null
	,mbsizex: null
	,mbsizey: null
	,mbwidth: null
	,mbheight: null
	,rstinterval: null
	,buf: null
	,bufbits: null
	,filter: null
	,vlcCode: null
});
class hxd_res_Sound extends hxd_res_Resource {
	constructor(entry) {
		hxd_res_Resource._hx_skip_constructor = true;
		super();
		hxd_res_Resource._hx_skip_constructor = false;
		this._hx_constructor(entry);
	}
	_hx_constructor(entry) {
		this.lastPlay = 0.;
		super._hx_constructor(entry);
	}
	getData() {
		if(this.data != null) {
			return this.data;
		}
		let bytes = this.entry.getBytes();
		switch(bytes.b[0]) {
		case 73:case 255:
			this.data = new hxd_snd_Mp3Data(bytes);
			break;
		case 79:
			this.data = new hxd_snd_OggData(bytes);
			break;
		case 82:
			this.data = new hxd_snd_WavData(bytes);
			break;
		default:
		}
		if(this.data == null) {
			throw haxe_Exception.thrown("Unsupported sound format " + this.entry.get_path());
		}
		if(hxd_res_Sound.ENABLE_AUTO_WATCH) {
			this.watch($bind(this,this.watchCallb));
		}
		return this.data;
	}
	dispose() {
		this.stop();
		this.data = null;
	}
	stop() {
		if(this.channel != null) {
			this.channel.stop();
			this.channel = null;
		}
	}
	play(loop,volume,channelGroup,soundGroup) {
		if(volume == null) {
			volume = 1.;
		}
		if(loop == null) {
			loop = false;
		}
		this.lastPlay = HxOverrides.now() / 1000;
		this.channel = hxd_snd_Manager.get().play(this,channelGroup,soundGroup);
		this.channel.loop = loop;
		this.channel.set_volume(volume);
		return this.channel;
	}
	watchCallb() {
		let old = this.data;
		this.data = null;
		let data = this.getData();
		if(old != null) {
			if(old.channels != data.channels || old.samples != data.samples || old.sampleFormat != data.sampleFormat || old.samplingRate != data.samplingRate) {
				let manager = hxd_snd_Manager.get();
				let ch = manager.getAll(this);
				while(ch.hasNext()) {
					let ch1 = ch.next();
					ch1.duration = data.get_duration();
					ch1.set_position(ch1.position);
				}
			}
		}
	}
}
$hxClasses["hxd.res.Sound"] = hxd_res_Sound;
hxd_res_Sound.__name__ = "hxd.res.Sound";
hxd_res_Sound.__super__ = hxd_res_Resource;
Object.assign(hxd_res_Sound.prototype, {
	__class__: hxd_res_Sound
	,data: null
	,channel: null
	,lastPlay: null
});
class hxd_snd_ChannelBase {
	constructor() {
		if(hxd_snd_ChannelBase._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
		this.volume = 1.;
		this.bindedEffects = [];
		this.effects = [];
		this.mute = false;
		this.priority = 0.;
	}
	getEffect(etype) {
		if(this.effects == null) {
			return null;
		}
		let _g = 0;
		let _g1 = this.effects;
		while(_g < _g1.length) {
			let e = _g1[_g];
			++_g;
			let e1 = js_Boot.__downcastCheck(e,etype) ? e : null;
			if(e1 != null) {
				return e1;
			}
		}
		return null;
	}
	set_volume(v) {
		this.currentFade = null;
		return this.volume = v;
	}
	updateCurrentVolume(now) {
		if(this.currentFade != null) {
			let f = this.currentFade;
			let dt = now - f.start;
			if(dt >= f.duration) {
				this.set_volume(f.targetVolume);
				if(f.onEnd != null) {
					f.onEnd();
				}
			} else {
				this.set_volume(f.startVolume + dt / f.duration * (f.targetVolume - f.startVolume));
				this.currentFade = f;
			}
		}
		this.currentVolume = this.volume;
	}
	addEffect(e) {
		if(e == null) {
			throw haxe_Exception.thrown("Can't add null effect");
		}
		if(this.effects.indexOf(e) >= 0) {
			throw haxe_Exception.thrown("effect already added on this channel");
		}
		this.effects.push(e);
		return e;
	}
	removeEffect(e) {
		HxOverrides.remove(this.effects,e);
	}
}
$hxClasses["hxd.snd.ChannelBase"] = hxd_snd_ChannelBase;
hxd_snd_ChannelBase.__name__ = "hxd.snd.ChannelBase";
Object.assign(hxd_snd_ChannelBase.prototype, {
	__class__: hxd_snd_ChannelBase
	,priority: null
	,mute: null
	,effects: null
	,bindedEffects: null
	,volume: null
	,currentFade: null
	,currentVolume: null
});
class hxd_snd_Channel extends hxd_snd_ChannelBase {
	constructor() {
		hxd_snd_ChannelBase._hx_skip_constructor = true;
		super();
		hxd_snd_ChannelBase._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.queue = [];
		this.positionChanged = false;
		this.isLoading = false;
		this.isVirtual = false;
		this.lastStamp = 0.0;
		this.audibleVolume = 1.0;
		this.allowVirtual = true;
		this.loop = false;
		this.pause = false;
		this.position = 0.0;
		super._hx_constructor();
		this.id = hxd_snd_Channel.ID++;
	}
	onEnd() {
	}
	set_position(v) {
		this.lastStamp = HxOverrides.now() / 1000;
		this.positionChanged = true;
		if(v > this.duration) {
			v = this.duration;
		} else if(v < 0) {
			v = 0;
		}
		return this.position = v;
	}
	set_pause(v) {
		if(!v) {
			this.lastStamp = HxOverrides.now() / 1000;
		}
		return this.pause = v;
	}
	updateCurrentVolume(now) {
		if(this.pause && this.currentFade != null) {
			let f = this.currentFade;
			this.currentFade = null;
			this.updateCurrentVolume(now);
			this.currentFade = f;
		}
		super.updateCurrentVolume(now);
		this.channelGroup.updateCurrentVolume(now);
		this.currentVolume *= this.channelGroup.currentVolume * this.soundGroup.volume;
		if(this.manager != null) {
			let _g = 0;
			let _g1 = this.channelGroup.effects;
			while(_g < _g1.length) {
				let e = _g1[_g];
				++_g;
				this.currentVolume *= e.getVolumeModifier();
			}
			let _g2 = 0;
			let _g3 = this.effects;
			while(_g2 < _g3.length) {
				let e = _g3[_g2];
				++_g2;
				this.currentVolume *= e.getVolumeModifier();
			}
		}
	}
	calcAudibleVolume(now) {
		this.updateCurrentVolume(now);
		this.audibleVolume = this.currentVolume;
		if(this.manager != null) {
			let _g = 0;
			let _g1 = this.channelGroup.effects;
			while(_g < _g1.length) {
				let e = _g1[_g];
				++_g;
				this.audibleVolume = e.applyAudibleVolumeModifier(this.audibleVolume);
			}
			let _g2 = 0;
			let _g3 = this.effects;
			while(_g2 < _g3.length) {
				let e = _g3[_g2];
				++_g2;
				this.audibleVolume = e.applyAudibleVolumeModifier(this.audibleVolume);
			}
		}
	}
	stop() {
		if(this.manager != null) {
			this.manager.releaseChannel(this);
		}
	}
}
$hxClasses["hxd.snd.Channel"] = hxd_snd_Channel;
hxd_snd_Channel.__name__ = "hxd.snd.Channel";
hxd_snd_Channel.__super__ = hxd_snd_ChannelBase;
Object.assign(hxd_snd_Channel.prototype, {
	__class__: hxd_snd_Channel
	,next: null
	,manager: null
	,source: null
	,id: null
	,sound: null
	,duration: null
	,soundGroup: null
	,channelGroup: null
	,position: null
	,pause: null
	,loop: null
	,allowVirtual: null
	,audibleVolume: null
	,lastStamp: null
	,isVirtual: null
	,isLoading: null
	,positionChanged: null
	,queue: null
});
class hxd_snd_ChannelGroup extends hxd_snd_ChannelBase {
	constructor(name) {
		super();
		this.name = name;
	}
}
$hxClasses["hxd.snd.ChannelGroup"] = hxd_snd_ChannelGroup;
hxd_snd_ChannelGroup.__name__ = "hxd.snd.ChannelGroup";
hxd_snd_ChannelGroup.__super__ = hxd_snd_ChannelBase;
Object.assign(hxd_snd_ChannelGroup.prototype, {
	__class__: hxd_snd_ChannelGroup
	,name: null
});
var hxd_snd_SampleFormat = $hxEnums["hxd.snd.SampleFormat"] = { __ename__:true,__constructs__:null
	,UI8: {_hx_name:"UI8",_hx_index:0,__enum__:"hxd.snd.SampleFormat",toString:$estr}
	,I16: {_hx_name:"I16",_hx_index:1,__enum__:"hxd.snd.SampleFormat",toString:$estr}
	,F32: {_hx_name:"F32",_hx_index:2,__enum__:"hxd.snd.SampleFormat",toString:$estr}
};
hxd_snd_SampleFormat.__constructs__ = [hxd_snd_SampleFormat.UI8,hxd_snd_SampleFormat.I16,hxd_snd_SampleFormat.F32];
hxd_snd_SampleFormat.__empty_constructs__ = [hxd_snd_SampleFormat.UI8,hxd_snd_SampleFormat.I16,hxd_snd_SampleFormat.F32];
class hxd_snd_Data {
	isLoading() {
		return false;
	}
	decode(out,outPos,sampleStart,sampleCount) {
		let bpp = this.getBytesPerSample();
		if(sampleStart < 0 || sampleCount < 0 || outPos < 0 || outPos + sampleCount * bpp > out.length) {
			let s = "sampleStart = " + sampleStart;
			s += " sampleCount = " + sampleCount;
			s += " outPos = " + outPos;
			s += " bpp = " + bpp;
			s += " out.length = " + out.length;
			throw haxe_Exception.thrown(s);
		}
		if(sampleStart + sampleCount >= this.samples) {
			let count = 0;
			if(sampleStart < this.samples) {
				count = this.samples - sampleStart;
				this.decodeBuffer(out,outPos,sampleStart,count);
			}
			out.fill(outPos + count * bpp,(sampleCount - count) * bpp,0);
			return;
		}
		this.decodeBuffer(out,outPos,sampleStart,sampleCount);
	}
	resample(rate,format,channels) {
		if(this.sampleFormat == format && this.samplingRate == rate && this.channels == channels) {
			return this;
		}
		let newSamples = Math.ceil(this.samples * (rate / this.samplingRate));
		let bpp = this.getBytesPerSample();
		let data = new haxe_io_Bytes(new ArrayBuffer(bpp * this.samples));
		this.decodeBuffer(data,0,0,this.samples);
		let out = channels * newSamples;
		let out1;
		switch(format._hx_index) {
		case 0:
			out1 = 1;
			break;
		case 1:
			out1 = 2;
			break;
		case 2:
			out1 = 4;
			break;
		}
		let out2 = new haxe_io_Bytes(new ArrayBuffer(out * out1));
		this.resampleBuffer(out2,0,data,0,rate,format,channels,this.samples);
		let data1 = new hxd_snd_WavData(null);
		data1.channels = channels;
		data1.samples = newSamples;
		data1.sampleFormat = format;
		data1.samplingRate = rate;
		data1.rawData = out2;
		return data1;
	}
	resampleBuffer(out,outPos,input,inPos,rate,format,channels,samples) {
		let bpp = this.getBytesPerSample();
		let newSamples = Math.ceil(samples * (rate / this.samplingRate));
		let resample = samples != newSamples;
		if(!resample && this.sampleFormat == hxd_snd_SampleFormat.I16 && format == hxd_snd_SampleFormat.I16 && channels == 1 && this.channels == 2) {
			let r = inPos;
			let w = outPos;
			let _g = 0;
			while(_g < samples) {
				++_g;
				let sl = input.getUInt16(r);
				r += 2;
				let sr = input.getUInt16(r);
				r += 2;
				let s;
				if((sl ^ sr) >= 32768) {
					if((sl & 32768) != 0) {
						sl |= -65536;
					}
					if((sr & 32768) != 0) {
						sr |= -65536;
					}
					s = sl + sr >> 1 & 65535;
				} else {
					s = sl + sr >> 1;
				}
				out.setUInt16(w,s);
				w += 2;
			}
			return;
		}
		let srcChannels = this.channels;
		let commonChannels = channels < srcChannels ? channels : srcChannels;
		let extraChannels = channels - commonChannels;
		let sval = 0.;
		let ival = 0;
		let _g = 0;
		while(_g < newSamples) {
			let i = _g++;
			let targetSample = i / (newSamples - 1) * (samples - 1);
			let isample = targetSample | 0;
			let offset = targetSample - isample;
			let srcPos = inPos + isample * bpp;
			if(isample == samples - 1) {
				resample = false;
			}
			let _g1 = 0;
			let _g2 = commonChannels;
			while(_g1 < _g2) {
				++_g1;
				let sval1;
				let sval2 = 0.;
				switch(this.sampleFormat._hx_index) {
				case 0:
					sval1 = input.b[srcPos] / 255;
					if(resample) {
						sval2 = input.b[srcPos + bpp] / 255;
					}
					++srcPos;
					break;
				case 1:
					let v = input.getUInt16(srcPos);
					sval1 = ((v & 32768) == 0 ? v : v | -65536) / 32768;
					if(resample) {
						let v = input.getUInt16(srcPos + bpp);
						sval2 = ((v & 32768) == 0 ? v : v | -65536) / 32768;
					}
					srcPos += 2;
					break;
				case 2:
					sval1 = input.getFloat(srcPos);
					if(resample) {
						sval2 = input.getFloat(srcPos + bpp);
					}
					srcPos += 4;
					break;
				}
				sval = resample ? sval1 + offset * (sval2 - sval1) : sval1;
				switch(format._hx_index) {
				case 0:
					ival = (sval + 1) * 128 | 0;
					if(ival > 255) {
						ival = 255;
					}
					out.b[outPos++] = ival;
					break;
				case 1:
					ival = sval * 32768 | 0;
					if(ival > 32767) {
						ival = 32767;
					}
					ival &= 65535;
					out.setUInt16(outPos,ival);
					outPos += 2;
					break;
				case 2:
					out.setFloat(outPos,sval);
					outPos += 4;
					break;
				}
			}
			let _g3 = 0;
			while(_g3 < extraChannels) {
				++_g3;
				switch(format._hx_index) {
				case 0:
					out.b[outPos++] = ival;
					break;
				case 1:
					out.setUInt16(outPos,ival);
					outPos += 2;
					break;
				case 2:
					out.setFloat(outPos,sval);
					outPos += 4;
					break;
				}
			}
		}
	}
	decodeBuffer(out,outPos,sampleStart,sampleCount) {
		throw haxe_Exception.thrown("Not implemented");
	}
	getBytesPerSample() {
		let tmp;
		switch(this.sampleFormat._hx_index) {
		case 0:
			tmp = 1;
			break;
		case 1:
			tmp = 2;
			break;
		case 2:
			tmp = 4;
			break;
		}
		return this.channels * tmp;
	}
	load(onEnd) {
		onEnd();
	}
	get_duration() {
		return this.samples / this.samplingRate;
	}
}
$hxClasses["hxd.snd.Data"] = hxd_snd_Data;
hxd_snd_Data.__name__ = "hxd.snd.Data";
Object.assign(hxd_snd_Data.prototype, {
	__class__: hxd_snd_Data
	,samples: null
	,samplingRate: null
	,sampleFormat: null
	,channels: null
});
class hxd_snd_EffectDriver {
	constructor() {
		if(hxd_snd_EffectDriver._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
	}
	acquire() {
	}
	release() {
	}
	update(e) {
	}
	bind(e,source) {
	}
	apply(e,source) {
	}
	unbind(e,source) {
	}
}
$hxClasses["hxd.snd.EffectDriver"] = hxd_snd_EffectDriver;
hxd_snd_EffectDriver.__name__ = "hxd.snd.EffectDriver";
Object.assign(hxd_snd_EffectDriver.prototype, {
	__class__: hxd_snd_EffectDriver
});
var hxd_snd_DriverFeature = $hxEnums["hxd.snd.DriverFeature"] = { __ename__:true,__constructs__:null
	,MasterVolume: {_hx_name:"MasterVolume",_hx_index:0,__enum__:"hxd.snd.DriverFeature",toString:$estr}
};
hxd_snd_DriverFeature.__constructs__ = [hxd_snd_DriverFeature.MasterVolume];
hxd_snd_DriverFeature.__empty_constructs__ = [hxd_snd_DriverFeature.MasterVolume];
class hxd_snd_Driver {
}
$hxClasses["hxd.snd.Driver"] = hxd_snd_Driver;
hxd_snd_Driver.__name__ = "hxd.snd.Driver";
hxd_snd_Driver.__isInterface__ = true;
Object.assign(hxd_snd_Driver.prototype, {
	__class__: hxd_snd_Driver
	,hasFeature: null
	,setMasterVolume: null
	,setListenerParams: null
	,createSource: null
	,playSource: null
	,stopSource: null
	,setSourceVolume: null
	,createBuffer: null
	,setBufferData: null
	,destroyBuffer: null
	,queueBuffer: null
	,unqueueBuffer: null
	,getProcessedBuffers: null
	,getPlayedSampleCount: null
	,update: null
	,getEffectDriver: null
});
class hxd_snd_Effect {
	constructor(type) {
		this.refs = 0;
		this.priority = 0;
		this.retainTime = 0.0;
		this.lastStamp = 0.0;
		let managerDriver = hxd_snd_Manager.get().driver;
		if(managerDriver != null) {
			this.driver = managerDriver.getEffectDriver(type);
		}
	}
	applyAudibleVolumeModifier(v) {
		return v;
	}
	getVolumeModifier() {
		return 1;
	}
}
$hxClasses["hxd.snd.Effect"] = hxd_snd_Effect;
hxd_snd_Effect.__name__ = "hxd.snd.Effect";
Object.assign(hxd_snd_Effect.prototype, {
	__class__: hxd_snd_Effect
	,next: null
	,refs: null
	,retainTime: null
	,lastStamp: null
	,driver: null
	,priority: null
});
class hxd_snd_Listener {
	constructor() {
		this.position = new h3d_Vector();
		this.velocity = new h3d_Vector();
		this.direction = new h3d_Vector(1,0,0);
		this.up = new h3d_Vector(0,0,1);
	}
	syncCamera(cam) {
		let _this = this.position;
		let v = cam.pos;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
		_this.w = v.w;
		let _this1 = this.direction;
		let x = cam.target.x - cam.pos.x;
		let y = cam.target.y - cam.pos.y;
		let z = cam.target.z - cam.pos.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this1.x = x;
		_this1.y = y;
		_this1.z = z;
		_this1.w = 1.;
		let _this2 = this.direction;
		let k = _this2.x * _this2.x + _this2.y * _this2.y + _this2.z * _this2.z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this2.x *= k;
		_this2.y *= k;
		_this2.z *= k;
		let _this3 = this.up;
		let v1 = cam.up;
		_this3.x = v1.x;
		_this3.y = v1.y;
		_this3.z = v1.z;
		_this3.w = v1.w;
	}
}
$hxClasses["hxd.snd.Listener"] = hxd_snd_Listener;
hxd_snd_Listener.__name__ = "hxd.snd.Listener";
Object.assign(hxd_snd_Listener.prototype, {
	__class__: hxd_snd_Listener
	,position: null
	,direction: null
	,velocity: null
	,up: null
});
class hxd_snd_Source {
	constructor(driver) {
		this.start = 0;
		this.playing = false;
		this.volume = -1.0;
		this.id = hxd_snd_Source.ID++;
		this.handle = driver.createSource();
		this.buffers = [];
	}
}
$hxClasses["hxd.snd.Source"] = hxd_snd_Source;
hxd_snd_Source.__name__ = "hxd.snd.Source";
Object.assign(hxd_snd_Source.prototype, {
	__class__: hxd_snd_Source
	,id: null
	,handle: null
	,channel: null
	,buffers: null
	,volume: null
	,playing: null
	,start: null
	,streamSound: null
	,streamBuffer: null
	,streamStart: null
	,streamPos: null
});
class hxd_snd_Buffer {
	constructor(driver) {
		this.handle = driver.createBuffer();
		this.refs = 0;
		this.lastStop = HxOverrides.now() / 1000;
	}
	dispose() {
		hxd_snd_Manager.get().driver.destroyBuffer(this.handle);
	}
}
$hxClasses["hxd.snd.Buffer"] = hxd_snd_Buffer;
hxd_snd_Buffer.__name__ = "hxd.snd.Buffer";
Object.assign(hxd_snd_Buffer.prototype, {
	__class__: hxd_snd_Buffer
	,handle: null
	,sound: null
	,isEnd: null
	,isStream: null
	,refs: null
	,lastStop: null
	,start: null
	,samples: null
	,sampleRate: null
});
class hxd_snd_Manager {
	constructor() {
		this.suspended = false;
		this.timeOffset = 0.;
		try {
			this.driver = new hxd_snd_webaudio_Driver();
		} catch( _g ) {
			if(typeof(haxe_Exception.caught(_g).unwrap()) == "string") {
				this.driver = null;
			} else {
				throw _g;
			}
		}
		this.masterVolume = 1.0;
		this.hasMasterVolume = this.driver == null ? true : this.driver.hasFeature(hxd_snd_DriverFeature.MasterVolume);
		this.masterSoundGroup = new hxd_snd_SoundGroup("master");
		this.masterChannelGroup = new hxd_snd_ChannelGroup("master");
		this.listener = new hxd_snd_Listener();
		this.soundBufferMap = new haxe_ds_StringMap();
		this.soundBufferKeys = [];
		this.freeStreamBuffers = [];
		this.effectGC = [];
		this.soundBufferCount = 0;
		if(this.driver != null) {
			this.sources = [];
			let _g = 0;
			let _g1 = hxd_snd_Manager.MAX_SOURCES;
			while(_g < _g1) {
				++_g;
				this.sources.push(new hxd_snd_Source(this.driver));
			}
		}
		this.cachedBytes = new haxe_io_Bytes(new ArrayBuffer(24));
		this.resampleBytes = new haxe_io_Bytes(new ArrayBuffer(hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * 2));
	}
	getTmpBytes(size) {
		if(this.cachedBytes.length < size) {
			this.cachedBytes = new haxe_io_Bytes(new ArrayBuffer(size));
		}
		return this.cachedBytes;
	}
	getResampleBytes(size) {
		if(this.resampleBytes.length < size) {
			this.resampleBytes = new haxe_io_Bytes(new ArrayBuffer(size));
		}
		return this.resampleBytes;
	}
	stopByName(name) {
		let c = this.channels;
		while(c != null) {
			let n = c.next;
			if(c.soundGroup != null && c.soundGroup.name == name) {
				c.stop();
			}
			c = n;
		}
	}
	getAll(sound) {
		let ch = this.channels;
		let result = [];
		while(ch != null) {
			if(ch.sound == sound) {
				result.push(ch);
			}
			ch = ch.next;
		}
		return new hxd_impl_ArrayIterator_$hxd_$snd_$Channel(result);
	}
	play(sound,channelGroup,soundGroup) {
		if(soundGroup == null) {
			soundGroup = this.masterSoundGroup;
		}
		if(channelGroup == null) {
			channelGroup = this.masterChannelGroup;
		}
		let sdat = sound.getData();
		if(sdat.samples == 0) {
			throw haxe_Exception.thrown(Std.string(sound) + " has no samples");
		}
		let c = new hxd_snd_Channel();
		c.sound = sound;
		c.duration = sdat.get_duration();
		c.manager = this;
		c.soundGroup = soundGroup;
		c.channelGroup = channelGroup;
		c.next = this.channels;
		c.isLoading = sdat.isLoading();
		c.isVirtual = this.driver == null;
		c.lastStamp = HxOverrides.now() / 1000;
		this.channels = c;
		return c;
	}
	updateVirtualChannels(now) {
		let c = this.channels;
		while(c != null) {
			if(c.pause || !c.isVirtual || c.isLoading) {
				c = c.next;
				continue;
			}
			let a = now - c.lastStamp;
			c.set_position(c.position + (a < 0.0 ? 0.0 : a));
			c.lastStamp = now;
			let next = c.next;
			while(c.position >= c.duration) {
				c.set_position(c.position - c.duration);
				c.onEnd();
				if(next != null && next.manager == null) {
					next = null;
				}
				if(c.queue.length > 0) {
					c.sound = c.queue.shift();
					c.duration = c.sound.getData().get_duration();
				} else if(!c.loop) {
					this.releaseChannel(c);
					break;
				}
			}
			c = next;
		}
	}
	update() {
		if(this.timeOffset != 0) {
			let c = this.channels;
			while(c != null) {
				c.lastStamp += this.timeOffset;
				if(c.currentFade != null) {
					c.currentFade.start += this.timeOffset;
				}
				c = c.next;
			}
			let _g = 0;
			let _g1 = this.sources;
			while(_g < _g1.length) {
				let s = _g1[_g];
				++_g;
				let _g2 = 0;
				let _g3 = s.buffers;
				while(_g2 < _g3.length) {
					let b = _g3[_g2];
					++_g2;
					b.lastStop += this.timeOffset;
				}
			}
			this.timeOffset = 0;
		}
		this.now = HxOverrides.now() / 1000;
		if(this.driver == null) {
			this.updateVirtualChannels(this.now);
			return;
		}
		let _g = 0;
		let _g1 = this.sources;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			let c = s.channel;
			if(c == null) {
				continue;
			}
			if(c.positionChanged) {
				this.releaseSource(s);
				continue;
			}
			let lastBuffer = null;
			let count = this.driver.getProcessedBuffers(s.handle);
			let _g2 = 0;
			while(_g2 < count) {
				++_g2;
				let b = this.unqueueBuffer(s);
				if(b == null) {
					continue;
				}
				lastBuffer = b;
				if(b.isEnd) {
					c.sound = b.sound;
					c.duration = b.sound.getData().get_duration();
					c.set_position(c.duration);
					c.positionChanged = false;
					c.onEnd();
					s.start = 0;
				}
			}
			if(s.buffers.length == 0) {
				if(!lastBuffer.isEnd) {
					c.set_position((lastBuffer.start + lastBuffer.samples) / lastBuffer.sampleRate);
					this.releaseSource(s);
				} else if(c.queue.length > 0) {
					c.sound = c.queue.shift();
					c.duration = c.sound.getData().get_duration();
					c.set_position(0);
					this.releaseSource(s);
				} else if(c.loop) {
					c.set_position(0);
					this.releaseSource(s);
				} else {
					this.releaseChannel(c);
				}
				continue;
			}
			c.sound = s.buffers[0].sound;
			c.duration = c.sound.getData().get_duration();
			let playedSamples = this.driver.getPlayedSampleCount(s.handle);
			if(playedSamples < 0) {
				haxe_Log.trace("playedSamples should positive : bug in driver",{ fileName : "hxd/snd/Manager.hx", lineNumber : 361, className : "hxd.snd.Manager", methodName : "update"});
				playedSamples = 0;
			}
			c.set_position(s.start / this.targetRate + playedSamples / s.buffers[0].sampleRate);
			c.positionChanged = false;
			if(s.buffers.length < hxd_snd_Manager.BUFFER_QUEUE_LENGTH) {
				let b = s.buffers[s.buffers.length - 1];
				if(!b.isEnd) {
					this.queueBuffer(s,b.sound,b.start + b.samples);
				} else if(c.queue.length > 0) {
					let snd = c.queue[0];
					if(this.queueBuffer(s,snd,0)) {
						c.queue.shift();
					}
				} else if(c.loop) {
					this.queueBuffer(s,b.sound,0);
				}
			}
		}
		let c = this.channels;
		while(c != null) {
			c.calcAudibleVolume(this.now);
			if(c.isLoading && !c.sound.getData().isLoading()) {
				c.isLoading = false;
			}
			c.isVirtual = this.suspended || c.pause || c.mute || c.channelGroup.mute || c.allowVirtual && c.audibleVolume < hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD || c.isLoading;
			c = c.next;
		}
		let list = this.channels;
		let cmp = $bind(this,this.sortChannel);
		let tmp;
		if(list == null) {
			tmp = null;
		} else {
			let insize = 1;
			let nmerges;
			let psize = 0;
			let qsize = 0;
			let p;
			let q;
			let e;
			let tail;
			while(true) {
				p = list;
				list = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					let _g = 0;
					let _g1 = insize;
					while(_g < _g1) {
						++_g;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || cmp(p,q) <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			tmp = list;
		}
		this.channels = tmp;
		let audibleCount = 0;
		let c1 = this.channels;
		while(c1 != null && !c1.isVirtual) {
			if(++audibleCount > this.sources.length) {
				c1.isVirtual = true;
			} else if(c1.soundGroup.maxAudible >= 0) {
				if(c1.soundGroup.lastUpdate != this.now) {
					c1.soundGroup.lastUpdate = this.now;
					c1.soundGroup.numAudible = 0;
				}
				if(++c1.soundGroup.numAudible > c1.soundGroup.maxAudible) {
					c1.isVirtual = true;
					--audibleCount;
				}
			}
			c1 = c1.next;
		}
		let _g2 = 0;
		let _g3 = this.sources;
		while(_g2 < _g3.length) {
			let s = _g3[_g2];
			++_g2;
			if(s.channel == null || !s.channel.isVirtual) {
				continue;
			}
			this.releaseSource(s);
		}
		let c2 = this.channels;
		while(c2 != null) {
			if(c2.source != null || c2.isVirtual) {
				c2 = c2.next;
				continue;
			}
			let s = null;
			let _g = 0;
			let _g1 = this.sources;
			while(_g < _g1.length) {
				let s2 = _g1[_g];
				++_g;
				if(s2.channel == null) {
					s = s2;
					break;
				}
			}
			if(s == null) {
				throw haxe_Exception.thrown("could not get a source");
			}
			s.channel = c2;
			c2.source = s;
			this.checkTargetFormat(c2.sound.getData(),c2.soundGroup.mono);
			s.start = Math.floor(c2.position * this.targetRate);
			if(s.start < 0) {
				s.start = 0;
			}
			this.queueBuffer(s,c2.sound,s.start);
			c2.positionChanged = false;
			c2 = c2.next;
		}
		let usedEffects = null;
		let volume = this.hasMasterVolume ? 1. : this.masterVolume;
		let _g4 = 0;
		let _g5 = this.sources;
		while(_g4 < _g5.length) {
			let s = _g5[_g4];
			++_g4;
			let c = s.channel;
			if(c == null) {
				continue;
			}
			let v = c.currentVolume * volume;
			if(s.volume != v) {
				if(v < 0) {
					v = 0;
				}
				s.volume = v;
				this.driver.setSourceVolume(s.handle,v);
			}
			if(!s.playing) {
				this.driver.playSource(s.handle);
				s.playing = true;
			}
			let i = c.bindedEffects.length;
			while(--i >= 0) {
				let e = c.bindedEffects[i];
				if(c.effects.indexOf(e) < 0 && c.channelGroup.effects.indexOf(e) < 0) {
					this.unbindEffect(c,s,e);
				}
			}
			let _g = 0;
			let _g1 = c.channelGroup.effects;
			while(_g < _g1.length) {
				let e = _g1[_g];
				++_g;
				if(c.bindedEffects.indexOf(e) < 0) {
					this.bindEffect(c,s,e);
				}
			}
			let _g2 = 0;
			let _g3 = c.effects;
			while(_g2 < _g3.length) {
				let e = _g3[_g2];
				++_g2;
				if(c.bindedEffects.indexOf(e) < 0) {
					this.bindEffect(c,s,e);
				}
			}
			let _g6 = 0;
			let _g7 = c.bindedEffects;
			while(_g6 < _g7.length) {
				let e = _g7[_g6];
				++_g6;
				usedEffects = hxd_snd_Manager.regEffect(usedEffects,e);
			}
		}
		let list1 = usedEffects;
		let cmp1 = $bind(this,this.sortEffect);
		if(list1 == null) {
			usedEffects = null;
		} else {
			let insize = 1;
			let nmerges;
			let psize = 0;
			let qsize = 0;
			let p;
			let q;
			let e;
			let tail;
			while(true) {
				p = list1;
				list1 = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					let _g = 0;
					let _g1 = insize;
					while(_g < _g1) {
						++_g;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || cmp1(p,q) <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list1 = e;
						}
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			usedEffects = list1;
		}
		let e = usedEffects;
		while(e != null) {
			e.driver.update(e);
			e = e.next;
		}
		let _g6 = 0;
		let _g7 = this.sources;
		while(_g6 < _g7.length) {
			let s = _g7[_g6];
			++_g6;
			let c = s.channel;
			if(c == null) {
				continue;
			}
			let _g = 0;
			let _g1 = c.bindedEffects;
			while(_g < _g1.length) {
				let e = _g1[_g];
				++_g;
				e.driver.apply(e,s.handle);
			}
		}
		let _g8 = 0;
		let _g9 = this.effectGC;
		while(_g8 < _g9.length) {
			let e = _g9[_g8];
			++_g8;
			if(this.now - e.lastStamp > e.retainTime) {
				e.driver.release();
				HxOverrides.remove(this.effectGC,e);
				break;
			}
		}
		this.updateVirtualChannels(this.now);
		let _this = this.listener.direction;
		let k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		_this.x *= k;
		_this.y *= k;
		_this.z *= k;
		let _this1 = this.listener.up;
		let k1 = _this1.x * _this1.x + _this1.y * _this1.y + _this1.z * _this1.z;
		if(k1 < 1e-10) {
			k1 = 0;
		} else {
			k1 = 1. / Math.sqrt(k1);
		}
		_this1.x *= k1;
		_this1.y *= k1;
		_this1.z *= k1;
		if(this.hasMasterVolume) {
			this.driver.setMasterVolume(this.masterVolume);
		}
		this.driver.setListenerParams(this.listener.position,this.listener.direction,this.listener.up,this.listener.velocity);
		this.driver.update();
		if(this.soundBufferCount >= hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE) {
			let now = HxOverrides.now() / 1000;
			let i = 0;
			while(i < this.soundBufferKeys.length) {
				let k = this.soundBufferKeys[i];
				let b = this.soundBufferMap.h[k];
				++i;
				if(b.refs > 0 || b.lastStop + 60.0 > now) {
					continue;
				}
				let _this = this.soundBufferMap;
				if(Object.prototype.hasOwnProperty.call(_this.h,k)) {
					delete(_this.h[k]);
				}
				HxOverrides.remove(this.soundBufferKeys,k);
				--i;
				b.dispose();
				--this.soundBufferCount;
			}
		}
	}
	progressiveDecodeBuffer(s,snd,start) {
		let data = snd.getData();
		let samples = Math.ceil(hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT / hxd_snd_Manager.BUFFER_STREAM_SPLIT);
		if(s.streamStart != start || s.streamSound != snd) {
			s.streamSound = snd;
			s.streamStart = start;
			s.streamPos = start;
		}
		let end = start + hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT;
		if(s.streamPos == end) {
			return true;
		}
		let bpp = data.getBytesPerSample();
		let reqSize = hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT * bpp;
		if(s.streamBuffer == null || s.streamBuffer.length < reqSize) {
			s.streamBuffer = new haxe_io_Bytes(new ArrayBuffer(reqSize));
			s.streamPos = start;
		}
		let remain = end - s.streamPos;
		if(remain > samples) {
			remain = samples;
		}
		data.decode(s.streamBuffer,(s.streamPos - start) * bpp,s.streamPos,remain);
		s.streamPos += remain;
		return s.streamPos == end;
	}
	queueBuffer(s,snd,start) {
		let data = snd.getData();
		let sgroup = s.channel.soundGroup;
		let b = null;
		if(data.get_duration() <= hxd_snd_Manager.STREAM_DURATION) {
			b = this.getSoundBuffer(snd,sgroup);
			this.driver.queueBuffer(s.handle,b.handle,start,true);
		} else {
			if(s.buffers.length > 0 && hxd_snd_Manager.BUFFER_STREAM_SPLIT > 1 && !this.progressiveDecodeBuffer(s,snd,start)) {
				return false;
			}
			b = this.getStreamBuffer(s,snd,sgroup,start);
			this.driver.queueBuffer(s.handle,b.handle,0,b.isEnd);
		}
		s.buffers.push(b);
		return true;
	}
	unqueueBuffer(s) {
		let b = s.buffers.shift();
		if(b == null) {
			return null;
		}
		this.driver.unqueueBuffer(s.handle,b.handle);
		if(b.isStream) {
			this.freeStreamBuffers.unshift(b);
		} else if(--b.refs == 0) {
			b.lastStop = HxOverrides.now() / 1000;
		}
		return b;
	}
	bindEffect(c,s,e) {
		if(e.refs == 0 && !HxOverrides.remove(this.effectGC,e)) {
			e.driver.acquire();
		}
		++e.refs;
		e.driver.bind(e,s.handle);
		c.bindedEffects.push(e);
	}
	unbindEffect(c,s,e) {
		e.driver.unbind(e,s.handle);
		HxOverrides.remove(c.bindedEffects,e);
		if(--e.refs == 0) {
			e.lastStamp = this.now;
			this.effectGC.push(e);
		}
	}
	releaseSource(s) {
		if(s.channel != null) {
			let _g = 0;
			let _g1 = s.channel.bindedEffects.slice();
			while(_g < _g1.length) {
				let e = _g1[_g];
				++_g;
				this.unbindEffect(s.channel,s,e);
			}
			s.channel.bindedEffects = [];
			s.channel.source = null;
			s.channel = null;
		}
		if(s.playing) {
			s.playing = false;
			this.driver.stopSource(s.handle);
			s.volume = -1.0;
		}
		while(s.buffers.length > 0) this.unqueueBuffer(s);
	}
	checkTargetFormat(dat,forceMono) {
		if(forceMono == null) {
			forceMono = false;
		}
		this.targetRate = dat.samplingRate;
		this.targetChannels = forceMono || dat.channels == 1 ? 1 : 2;
		let tmp;
		switch(dat.sampleFormat._hx_index) {
		case 0:
			tmp = hxd_snd_SampleFormat.UI8;
			break;
		case 1:
			tmp = hxd_snd_SampleFormat.I16;
			break;
		case 2:
			tmp = hxd_snd_SampleFormat.F32;
			break;
		}
		this.targetFormat = tmp;
		if(this.targetChannels == dat.channels && this.targetFormat == dat.sampleFormat) {
			return this.targetRate == dat.samplingRate;
		} else {
			return false;
		}
	}
	getSoundBuffer(snd,grp) {
		let data = snd.getData();
		let mono = grp.mono;
		let key = snd.entry.get_path();
		if(mono && data.channels != 1) {
			key += "mono";
		}
		let b = this.soundBufferMap.h[key];
		let _gthis = this;
		if(b == null) {
			b = new hxd_snd_Buffer(this.driver);
			b.isStream = false;
			b.isEnd = true;
			b.sound = snd;
			data.load(function() {
				_gthis.fillSoundBuffer(b,data,mono);
			});
			this.soundBufferMap.h[key] = b;
			this.soundBufferKeys.push(key);
			++this.soundBufferCount;
		}
		++b.refs;
		return b;
	}
	fillSoundBuffer(buf,dat,forceMono) {
		if(forceMono == null) {
			forceMono = false;
		}
		if(!this.checkTargetFormat(dat,forceMono)) {
			dat = dat.resample(this.targetRate,this.targetFormat,this.targetChannels);
		}
		let length = dat.samples * dat.getBytesPerSample();
		let bytes = this.getTmpBytes(length);
		dat.decode(bytes,0,0,dat.samples);
		this.driver.setBufferData(buf.handle,bytes,length,this.targetFormat,this.targetChannels,this.targetRate);
		buf.sampleRate = this.targetRate;
		buf.samples = dat.samples;
	}
	getStreamBuffer(src,snd,grp,start) {
		let data = snd.getData();
		let b = this.freeStreamBuffers.shift();
		if(b == null) {
			b = new hxd_snd_Buffer(this.driver);
			b.isStream = true;
		}
		let samples = hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT;
		if(start + samples >= data.samples) {
			samples = data.samples - start;
			b.isEnd = true;
		} else {
			b.isEnd = false;
		}
		b.sound = snd;
		b.samples = samples;
		b.start = start;
		let size = samples * data.getBytesPerSample();
		let bytes;
		if(src.streamSound == snd && src.streamStart == start) {
			while(!this.progressiveDecodeBuffer(src,snd,start)) {
			}
			bytes = src.streamBuffer;
		} else {
			bytes = this.getTmpBytes(size);
			data.decode(bytes,0,start,samples);
		}
		if(!this.checkTargetFormat(data,grp.mono)) {
			let size1 = Math.ceil(samples * (this.targetRate / data.samplingRate)) * this.targetChannels;
			let size2;
			switch(this.targetFormat._hx_index) {
			case 0:
				size2 = 1;
				break;
			case 1:
				size2 = 2;
				break;
			case 2:
				size2 = 4;
				break;
			}
			size = size1 * size2;
			let resampleBytes = this.getResampleBytes(size);
			data.resampleBuffer(resampleBytes,0,bytes,0,this.targetRate,this.targetFormat,this.targetChannels,samples);
			bytes = resampleBytes;
		}
		this.driver.setBufferData(b.handle,bytes,size,this.targetFormat,this.targetChannels,this.targetRate);
		b.sampleRate = this.targetRate;
		return b;
	}
	sortChannel(a,b) {
		if(a.isVirtual != b.isVirtual) {
			if(a.isVirtual) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.channelGroup.priority != b.channelGroup.priority) {
			if(a.channelGroup.priority < b.channelGroup.priority) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.priority != b.priority) {
			if(a.priority < b.priority) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.audibleVolume != b.audibleVolume) {
			if(a.audibleVolume < b.audibleVolume) {
				return 1;
			} else {
				return -1;
			}
		}
		if(a.id < b.id) {
			return 1;
		} else {
			return -1;
		}
	}
	sortEffect(a,b) {
		return b.priority - a.priority;
	}
	releaseChannel(c) {
		if(c.manager == null) {
			return;
		}
		if(this.channels == c) {
			this.channels = c.next;
		} else {
			let prev = this.channels;
			while(prev.next != c) prev = prev.next;
			prev.next = c.next;
		}
		let _g = 0;
		let _g1 = c.effects;
		while(_g < _g1.length) {
			let e = _g1[_g];
			++_g;
			c.removeEffect(e);
		}
		if(c.source != null) {
			this.releaseSource(c.source);
		}
		c.next = null;
		c.manager = null;
		c.effects = null;
		c.bindedEffects = null;
		c.currentFade = null;
		let snd = c.sound;
		if(snd != null && snd.channel == c) {
			snd.channel = null;
		}
	}
	static get() {
		if(hxd_snd_Manager.instance == null) {
			hxd_snd_Manager.instance = new hxd_snd_Manager();
			hxd_snd_Manager.instance.updateEvent = haxe_MainLoop.add(($_=hxd_snd_Manager.instance,$bind($_,$_.update)));
			hxd_snd_Manager.instance.updateEvent.isBlocking = false;
		}
		return hxd_snd_Manager.instance;
	}
	static regEffect(list,e) {
		let l = list;
		while(l != null) {
			if(l == e) {
				return list;
			}
			l = l.next;
		}
		e.next = list;
		return e;
	}
}
$hxClasses["hxd.snd.Manager"] = hxd_snd_Manager;
hxd_snd_Manager.__name__ = "hxd.snd.Manager";
Object.assign(hxd_snd_Manager.prototype, {
	__class__: hxd_snd_Manager
	,masterVolume: null
	,masterSoundGroup: null
	,masterChannelGroup: null
	,listener: null
	,timeOffset: null
	,updateEvent: null
	,cachedBytes: null
	,resampleBytes: null
	,driver: null
	,channels: null
	,sources: null
	,now: null
	,soundBufferCount: null
	,soundBufferMap: null
	,soundBufferKeys: null
	,freeStreamBuffers: null
	,effectGC: null
	,hasMasterVolume: null
	,suspended: null
	,targetRate: null
	,targetFormat: null
	,targetChannels: null
});
class hxd_snd_Mp3Data extends hxd_snd_Data {
	constructor(bytes) {
		super();
		let mp = new format_mp3_Reader(new haxe_io_BytesInput(bytes)).read();
		this.samples = mp.sampleCount;
		let frame = mp.frames[0].data;
		let lame = -1;
		let _g = 0;
		let _g1 = frame.length - 24;
		while(_g < _g1) {
			let i = _g++;
			if(frame.b[i] == 76 && frame.b[i + 1] == 65 && frame.b[i + 2] == 77 && frame.b[i + 3] == 69) {
				lame = i;
				break;
			}
		}
		if(lame >= 0) {
			let startEnd = frame.b[lame + 21] << 16 | frame.b[lame + 22] << 8 | frame.b[lame + 23];
			let start = startEnd >> 12;
			let end = startEnd & 4095;
			this.samples -= start + end + 1152;
		}
		let header = mp.frames[0].header;
		this.sampleFormat = hxd_snd_SampleFormat.F32;
		this.samplingRate = format_mp3_MPEG.srEnum2Num(header.samplingRate);
		this.channels = header.channelMode == format_mp3_ChannelMode.Mono ? 1 : 2;
		let ctx = hxd_snd_webaudio_Context.get();
		if(ctx == null) {
			return;
		}
		ctx.decodeAudioData(bytes.b.bufferValue,$bind(this,this.processBuffer));
		let decodedRate = ctx.sampleRate | 0;
		this.samples = Math.ceil(this.samples * decodedRate / this.samplingRate);
		this.samplingRate = decodedRate;
	}
	isLoading() {
		return this.buffer == null;
	}
	load(onEnd) {
		if(this.buffer != null) {
			onEnd();
		} else {
			this.onEnd = onEnd;
		}
	}
	processBuffer(buf) {
		let left = buf.getChannelData(0);
		this.samples = buf.length;
		if(this.channels == 1) {
			this.buffer = haxe_io_Bytes.ofData(left.buffer);
			return;
		}
		let right = buf.numberOfChannels < 2 ? left : buf.getChannelData(1);
		let join = new Float32Array(left.length * 2);
		let w = 0;
		let _g = 0;
		let _g1 = buf.length;
		while(_g < _g1) {
			let i = _g++;
			join[w++] = left[i];
			join[w++] = right[i];
		}
		this.buffer = haxe_io_Bytes.ofData(join.buffer);
		if(this.onEnd != null) {
			this.onEnd();
			this.onEnd = null;
		}
	}
	decodeBuffer(out,outPos,sampleStart,sampleCount) {
		if(this.buffer == null) {
			out.fill(outPos,sampleCount * 4 * this.channels,0);
		} else {
			out.blit(outPos,this.buffer,sampleStart * 4 * this.channels,sampleCount * 4 * this.channels);
		}
	}
}
$hxClasses["hxd.snd.Mp3Data"] = hxd_snd_Mp3Data;
hxd_snd_Mp3Data.__name__ = "hxd.snd.Mp3Data";
hxd_snd_Mp3Data.__super__ = hxd_snd_Data;
Object.assign(hxd_snd_Mp3Data.prototype, {
	__class__: hxd_snd_Mp3Data
	,buffer: null
	,onEnd: null
});
class hxd_snd__$OggData_BytesOutput extends haxe_io_Output {
	constructor() {
		super();
	}
	done() {
	}
	init(bytes,position) {
		this.bytes = bytes;
		this.position = position;
	}
	writeFloat(f) {
		this.bytes.setFloat(this.position,f);
		this.position += 4;
	}
	writeInt16(i) {
		this.bytes.setUInt16(this.position,i);
		this.position += 2;
	}
}
$hxClasses["hxd.snd._OggData.BytesOutput"] = hxd_snd__$OggData_BytesOutput;
hxd_snd__$OggData_BytesOutput.__name__ = "hxd.snd._OggData.BytesOutput";
hxd_snd__$OggData_BytesOutput.__super__ = haxe_io_Output;
Object.assign(hxd_snd__$OggData_BytesOutput.prototype, {
	__class__: hxd_snd__$OggData_BytesOutput
	,bytes: null
	,position: null
});
class hxd_snd_OggData extends hxd_snd_Data {
	constructor(bytes) {
		super();
		if(bytes != null) {
			this.reader = stb_format_vorbis_Reader.openFromBytes(bytes);
			this.samples = this.reader.get_totalSample();
			this.channels = this.reader.get_header().channel;
			this.samplingRate = this.reader.get_header().sampleRate;
			this.sampleFormat = hxd_snd_SampleFormat.F32;
		}
		this.output = new hxd_snd__$OggData_BytesOutput();
		this.decodedFirst = 0;
		this.decodedLast = 0;
	}
	resample(rate,format,channels) {
		if(this.sampleFormat == format && this.samplingRate == rate && this.channels == channels) {
			return this;
		}
		switch(format._hx_index) {
		case 1:case 2:
			if(rate % this.samplingRate == 0 && channels >= this.channels) {
				let c = new hxd_snd_OggData(null);
				c.reader = this.reader;
				c.samples = this.samples;
				c.samplingRate = this.samplingRate;
				c.sampleFormat = format;
				c.channels = channels;
				return c;
			} else {
				return super.resample(rate,format,channels);
			}
			break;
		default:
			return super.resample(rate,format,channels);
		}
	}
	decodeBuffer(out,outPos,sampleStart,sampleCount) {
		let last = sampleStart + sampleCount;
		let bpp = this.getBytesPerSample();
		if(sampleStart < this.decodedFirst || last > this.decodedLast) {
			let need = sampleCount - sampleStart;
			if(need > 132300 || this.samples > 132300) {
				this.output.init(out,outPos);
				this.reader.set_currentSample(sampleStart);
				this.reader.read(this.output,sampleCount,this.channels,this.samplingRate,this.sampleFormat == hxd_snd_SampleFormat.F32);
				this.output.done();
				return;
			}
			if(this.decoded == null) {
				this.decoded = new haxe_io_Bytes(new ArrayBuffer((this.samples < 132300 ? this.samples : 132300) * bpp));
			}
			need = 132300;
			if(sampleStart + 132300 > this.samples) {
				need = this.samples - sampleStart;
			}
			this.output.init(this.decoded,0);
			this.reader.set_currentSample(sampleStart);
			this.reader.read(this.output,need,this.channels,this.samplingRate,this.sampleFormat == hxd_snd_SampleFormat.F32);
			this.output.done();
			this.decodedFirst = sampleStart;
			this.decodedLast = sampleStart + need;
			if(sampleStart == 0 && need == this.samples) {
				this.reader = null;
				this.output = null;
			}
		}
		out.blit(outPos,this.decoded,(sampleStart - this.decodedFirst) * bpp,sampleCount * bpp);
	}
}
$hxClasses["hxd.snd.OggData"] = hxd_snd_OggData;
hxd_snd_OggData.__name__ = "hxd.snd.OggData";
hxd_snd_OggData.__super__ = hxd_snd_Data;
Object.assign(hxd_snd_OggData.prototype, {
	__class__: hxd_snd_OggData
	,reader: null
	,output: null
	,decodedFirst: null
	,decodedLast: null
	,decoded: null
});
class hxd_snd_SoundGroup {
	constructor(name) {
		this.name = name;
		this.maxAudible = -1;
		this.volume = 1;
		this.mono = false;
	}
}
$hxClasses["hxd.snd.SoundGroup"] = hxd_snd_SoundGroup;
hxd_snd_SoundGroup.__name__ = "hxd.snd.SoundGroup";
Object.assign(hxd_snd_SoundGroup.prototype, {
	__class__: hxd_snd_SoundGroup
	,name: null
	,volume: null
	,maxAudible: null
	,mono: null
	,numAudible: null
	,lastUpdate: null
});
class hxd_snd_WavData extends hxd_snd_Data {
	constructor(bytes) {
		super();
		if(bytes != null) {
			this.init(new format_wav_Reader(new haxe_io_BytesInput(bytes)).read());
		}
	}
	init(d) {
		let h = d.header;
		this.samplingRate = h.samplingRate;
		this.channels = h.channels;
		let tmp;
		switch(h.bitsPerSample) {
		case 8:
			tmp = hxd_snd_SampleFormat.UI8;
			break;
		case 16:
			tmp = hxd_snd_SampleFormat.I16;
			break;
		default:
			throw haxe_Exception.thrown("Unsupported WAV " + h.bitsPerSample + " bits");
		}
		this.sampleFormat = tmp;
		this.rawData = d.data;
		this.samples = this.rawData.length / this.getBytesPerSample() | 0;
	}
	decodeBuffer(out,outPos,sampleStart,sampleCount) {
		let bpp = this.getBytesPerSample();
		out.blit(outPos,this.rawData,sampleStart * bpp,sampleCount * bpp);
	}
}
$hxClasses["hxd.snd.WavData"] = hxd_snd_WavData;
hxd_snd_WavData.__name__ = "hxd.snd.WavData";
hxd_snd_WavData.__super__ = hxd_snd_Data;
Object.assign(hxd_snd_WavData.prototype, {
	__class__: hxd_snd_WavData
	,rawData: null
});
class hxd_snd_effect_LowPass extends hxd_snd_Effect {
	constructor() {
		super("lowpass");
		this.priority = 100;
		this.gainHF = 1.0;
	}
}
$hxClasses["hxd.snd.effect.LowPass"] = hxd_snd_effect_LowPass;
hxd_snd_effect_LowPass.__name__ = "hxd.snd.effect.LowPass";
hxd_snd_effect_LowPass.__super__ = hxd_snd_Effect;
Object.assign(hxd_snd_effect_LowPass.prototype, {
	__class__: hxd_snd_effect_LowPass
	,gainHF: null
});
class hxd_snd_effect_Pitch extends hxd_snd_Effect {
	constructor(value) {
		if(value == null) {
			value = 1.0;
		}
		super("pitch");
		this.value = value;
	}
}
$hxClasses["hxd.snd.effect.Pitch"] = hxd_snd_effect_Pitch;
hxd_snd_effect_Pitch.__name__ = "hxd.snd.effect.Pitch";
hxd_snd_effect_Pitch.__super__ = hxd_snd_Effect;
Object.assign(hxd_snd_effect_Pitch.prototype, {
	__class__: hxd_snd_effect_Pitch
	,value: null
});
class hxd_snd_effect_Spatialization extends hxd_snd_Effect {
	constructor() {
		super("spatialization");
		this.position = new h3d_Vector();
		this.velocity = new h3d_Vector();
		this.direction = new h3d_Vector();
		this.referenceDistance = 1.0;
		this.rollOffFactor = 1.0;
	}
	getVolumeModifier() {
		if(this.fadeDistance == null) {
			return 1.;
		}
		let _this = hxd_snd_Manager.get().listener.position;
		let v = this.position;
		let dx = v.x - _this.x;
		let dy = v.y - _this.y;
		let dz = v.z - _this.z;
		let dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
		if(this.maxDistance != null) {
			dist -= this.maxDistance;
		} else {
			dist -= this.referenceDistance;
		}
		let volume = 1 - dist / this.fadeDistance;
		if(volume > 1) {
			volume = 1;
		}
		if(volume < 0) {
			volume = 0;
		}
		return volume;
	}
	applyAudibleVolumeModifier(v) {
		let _this = hxd_snd_Manager.get().listener.position;
		let v1 = this.position;
		let dx = v1.x - _this.x;
		let dy = v1.y - _this.y;
		let dz = v1.z - _this.z;
		let dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
		let b = this.referenceDistance;
		if(dist < b) {
			dist = b;
		}
		if(this.maxDistance != null) {
			let b = this.maxDistance;
			if(dist > b) {
				dist = b;
			}
		}
		let volume = this.referenceDistance / (this.referenceDistance + this.rollOffFactor * (dist - this.referenceDistance));
		return v * volume;
	}
}
$hxClasses["hxd.snd.effect.Spatialization"] = hxd_snd_effect_Spatialization;
hxd_snd_effect_Spatialization.__name__ = "hxd.snd.effect.Spatialization";
hxd_snd_effect_Spatialization.__super__ = hxd_snd_Effect;
Object.assign(hxd_snd_effect_Spatialization.prototype, {
	__class__: hxd_snd_effect_Spatialization
	,position: null
	,velocity: null
	,direction: null
	,referenceDistance: null
	,maxDistance: null
	,fadeDistance: null
	,rollOffFactor: null
});
class hxd_snd_webaudio_BufferHandle {
	constructor() {
	}
}
$hxClasses["hxd.snd.webaudio.BufferHandle"] = hxd_snd_webaudio_BufferHandle;
hxd_snd_webaudio_BufferHandle.__name__ = "hxd.snd.webaudio.BufferHandle";
Object.assign(hxd_snd_webaudio_BufferHandle.prototype, {
	__class__: hxd_snd_webaudio_BufferHandle
	,inst: null
	,isEnd: null
	,samples: null
});
class hxd_snd_webaudio_SourceHandle {
	constructor() {
		this.buffers = [];
		this.sampleOffset = 0;
		this.pitch = 1;
		this.firstPlay = true;
	}
	updateDestination() {
		this.destination = this.gain;
		if(this.lowPass != null) {
			this.lowPass.connect(this.destination);
			this.destination = this.lowPass;
		}
		if(this.panner != null) {
			this.panner.connect(this.destination);
			this.destination = this.panner;
		}
		this.gain.connect(hxd_snd_webaudio_Context.destination);
		let _g = 0;
		let _g1 = this.buffers;
		while(_g < _g1.length) {
			let b = _g1[_g];
			++_g;
			if(b.node != null) {
				b.restart(this);
			}
		}
	}
	applyPitch() {
		let t = 0.;
		let _g = 0;
		let _g1 = this.buffers;
		while(_g < _g1.length) {
			let b = _g1[_g];
			++_g;
			t = b.readjust(t,this);
		}
	}
}
$hxClasses["hxd.snd.webaudio.SourceHandle"] = hxd_snd_webaudio_SourceHandle;
hxd_snd_webaudio_SourceHandle.__name__ = "hxd.snd.webaudio.SourceHandle";
Object.assign(hxd_snd_webaudio_SourceHandle.prototype, {
	__class__: hxd_snd_webaudio_SourceHandle
	,sampleOffset: null
	,playing: null
	,driver: null
	,lowPass: null
	,panner: null
	,gain: null
	,destination: null
	,buffers: null
	,pitch: null
	,firstPlay: null
});
class hxd_snd_webaudio_BufferPlayback {
	constructor() {
	}
	get_currentSample() {
		if(this.consumed) {
			return this.buffer.samples;
		}
		if(this.node == null || !this.dirty || this.node.context.currentTime < this.lastTime) {
			return 0;
		}
		this.lastSamples += Math.floor((this.node.context.currentTime - this.lastTime) * this.buffer.inst.sampleRate * this.node.playbackRate.value);
		this.lastTime = this.node.context.currentTime;
		return this.lastSamples;
	}
	set(buf,grainOffset) {
		this.buffer = buf;
		this.offset = isNaN(grainOffset) ? 0 : grainOffset;
		this.dirty = false;
		this.consumed = false;
		this.starts = 0;
		this.ends = 0;
	}
	start(ctx,source,time) {
		this.dirty = true;
		this.consumed = false;
		if(this.node != null) {
			this.stop();
		}
		if(source.firstPlay && this.buffer.samples > 10) {
			source.firstPlay = false;
			let _g = [];
			let _g1 = 0;
			let _g2 = this.buffer.inst.numberOfChannels;
			while(_g1 < _g2) {
				let i = _g1++;
				_g.push(this.buffer.inst.getChannelData(i));
			}
			let j = 0;
			let fade = 0.;
			while(j < 10) {
				let i = 0;
				while(i < _g.length) {
					_g[i][j] *= fade;
					++i;
				}
				++j;
				fade += 0.1;
				if(fade > 1) {
					fade = 1;
				}
			}
		}
		this.node = ctx.createBufferSource();
		this.node.buffer = this.buffer.inst;
		this.node.addEventListener("ended",$bind(this,this.onBufferConsumed));
		this.node.connect(source.destination);
		this.node.playbackRate.value = source.pitch;
		this.node.start(time,this.offset);
		this.lastSamples = 0;
		this.lastTime = time;
		this.starts = time;
		return this.ends = time + (this.buffer.inst.duration - this.offset) / source.pitch;
	}
	readjust(time,source) {
		if(this.consumed || this.node == null) {
			return this.ends;
		}
		let ctx = source.driver.ctx;
		let shiftTime = ctx.currentTime;
		this.node.playbackRate.setValueAtTime(source.pitch,shiftTime);
		let elapsed = shiftTime - this.starts;
		if(elapsed < 0) {
			return this.start(ctx,source,time == 0 ? shiftTime : time);
		}
		this.starts = shiftTime - elapsed / source.pitch;
		return this.ends = this.starts + (this.buffer.inst.duration - this.offset) / source.pitch;
	}
	restart(source) {
		if(this.consumed || this.node == null) {
			return;
		}
		let ctx = hxd_snd_webaudio_Context.get();
		if(ctx.currentTime > this.starts) {
			this.offset += (ctx.currentTime - this.starts) * source.pitch;
			this.start(ctx,source,ctx.currentTime);
		} else {
			this.start(ctx,source,this.starts);
		}
	}
	stop(immediate) {
		if(immediate == null) {
			immediate = true;
		}
		if(this.node != null) {
			this.node.removeEventListener("ended",$bind(this,this.onBufferConsumed));
			if(immediate) {
				this.node.disconnect();
			} else {
				this.node.stop();
			}
			this.node = null;
		}
	}
	onBufferConsumed(e) {
		this.node.removeEventListener("ended",$bind(this,this.onBufferConsumed));
		this.node.disconnect();
		this.node = null;
		this.consumed = true;
	}
	clear() {
		this.buffer = null;
		this.node = null;
	}
}
$hxClasses["hxd.snd.webaudio.BufferPlayback"] = hxd_snd_webaudio_BufferPlayback;
hxd_snd_webaudio_BufferPlayback.__name__ = "hxd.snd.webaudio.BufferPlayback";
Object.assign(hxd_snd_webaudio_BufferPlayback.prototype, {
	__class__: hxd_snd_webaudio_BufferPlayback
	,buffer: null
	,node: null
	,offset: null
	,dirty: null
	,consumed: null
	,starts: null
	,ends: null
	,lastSamples: null
	,lastTime: null
});
class hxd_snd_webaudio_Context {
	static get() {
		if(hxd_snd_webaudio_Context.ctx == null) {
			try {
				hxd_snd_webaudio_Context.ctx = new AudioContext();
			} catch( _g ) {
				try {
					hxd_snd_webaudio_Context.ctx = new window.webkitAudioContext();
				} catch( _g ) {
					hxd_snd_webaudio_Context.ctx = null;
				}
			}
			if(hxd_snd_webaudio_Context.ctx == null) {
				throw haxe_Exception.thrown("WebAudio API not available in this browser!");
			}
			if(hxd_snd_webaudio_Context.ctx.state == "suspended") {
				hxd_snd_webaudio_Context.waitForPageInput();
			}
			hxd_snd_webaudio_Context.ctx.addEventListener("statechange",function(_) {
				if(hxd_snd_webaudio_Context.ctx.state == "suspended") {
					hxd_snd_webaudio_Context.waitForPageInput();
				}
			});
			hxd_snd_webaudio_Context.bufferPool = [];
			hxd_snd_webaudio_Context.gainPool = [];
			hxd_snd_webaudio_Context.masterGain = hxd_snd_webaudio_Context.ctx.createGain();
			hxd_snd_webaudio_Context.masterGain.connect(hxd_snd_webaudio_Context.ctx.destination);
			hxd_snd_webaudio_Context.destination = hxd_snd_webaudio_Context.masterGain;
		}
		return hxd_snd_webaudio_Context.ctx;
	}
	static waitForPageInput() {
		if(!hxd_snd_webaudio_Context.suspended) {
			window.document.addEventListener("click",hxd_snd_webaudio_Context.resumeContext);
			window.document.addEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
			window.document.body.addEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
			window.document.body.addEventListener("touchend",hxd_snd_webaudio_Context.resumeContext);
			hxd_snd_webaudio_Context.suspended = true;
		}
	}
	static resumeContext(_) {
		if(hxd_snd_webaudio_Context.suspended) {
			if(hxd_snd_webaudio_Context.ctx != null) {
				hxd_snd_webaudio_Context.ctx.resume();
			}
			window.document.removeEventListener("click",hxd_snd_webaudio_Context.resumeContext);
			window.document.removeEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
			window.document.body.removeEventListener("keydown",hxd_snd_webaudio_Context.resumeContext);
			window.document.body.removeEventListener("touchend",hxd_snd_webaudio_Context.resumeContext);
			hxd_snd_webaudio_Context.suspended = false;
		}
	}
	static getBuffer(channels,sampleCount,rate) {
		let _g = 0;
		let _g1 = hxd_snd_webaudio_Context.bufferPool;
		while(_g < _g1.length) {
			let pool = _g1[_g];
			++_g;
			if(pool.channels == channels && pool.samples == sampleCount && pool.rate == rate) {
				if(pool.pool.length != 0) {
					return pool.pool.pop();
				} else {
					return hxd_snd_webaudio_Context.ctx.createBuffer(channels,sampleCount,rate);
				}
			}
		}
		let pool = new hxd_snd_webaudio__$Context_BufferPool(channels,sampleCount,rate);
		hxd_snd_webaudio_Context.bufferPool.push(pool);
		return hxd_snd_webaudio_Context.ctx.createBuffer(channels,sampleCount,rate);
	}
	static putBuffer(buf) {
		let rate = buf.sampleRate | 0;
		let _g = 0;
		let _g1 = hxd_snd_webaudio_Context.bufferPool;
		while(_g < _g1.length) {
			let pool = _g1[_g];
			++_g;
			if(pool.channels == buf.numberOfChannels && pool.samples == buf.length && pool.rate == rate) {
				pool.pool.push(buf);
				break;
			}
		}
	}
}
$hxClasses["hxd.snd.webaudio.Context"] = hxd_snd_webaudio_Context;
hxd_snd_webaudio_Context.__name__ = "hxd.snd.webaudio.Context";
class hxd_snd_webaudio__$Context_BufferPool {
	constructor(channels,samples,rate) {
		this.pool = [];
		this.channels = channels;
		this.samples = samples;
		this.rate = rate;
	}
}
$hxClasses["hxd.snd.webaudio._Context.BufferPool"] = hxd_snd_webaudio__$Context_BufferPool;
hxd_snd_webaudio__$Context_BufferPool.__name__ = "hxd.snd.webaudio._Context.BufferPool";
Object.assign(hxd_snd_webaudio__$Context_BufferPool.prototype, {
	__class__: hxd_snd_webaudio__$Context_BufferPool
	,pool: null
	,channels: null
	,samples: null
	,rate: null
});
class hxd_snd_webaudio_Driver {
	constructor() {
		this.playbackPool = [];
		this.ctx = hxd_snd_webaudio_Context.get();
	}
	hasFeature(d) {
		return true;
	}
	setMasterVolume(value) {
		hxd_snd_webaudio_Context.masterGain.gain.value = value;
	}
	setListenerParams(position,direction,up,velocity) {
		this.ctx.listener.setPosition(-position.x,position.y,position.z);
		this.ctx.listener.setOrientation(-direction.x,direction.y,direction.z,-up.x,up.y,up.z);
	}
	createSource() {
		let s = new hxd_snd_webaudio_SourceHandle();
		s.driver = this;
		s.gain = hxd_snd_webaudio_Context.gainPool.length != 0 ? hxd_snd_webaudio_Context.gainPool.pop() : hxd_snd_webaudio_Context.ctx.createGain();
		s.updateDestination();
		return s;
	}
	playSource(source) {
		if(!source.playing) {
			source.playing = true;
			if(source.buffers.length != 0) {
				let time = this.ctx.currentTime;
				let _g = 0;
				let _g1 = source.buffers;
				while(_g < _g1.length) {
					let b = _g1[_g];
					++_g;
					if(b.consumed) {
						continue;
					}
					time = b.start(this.ctx,source,time);
				}
			}
		}
	}
	stopSource(source) {
		source.playing = false;
		source.sampleOffset = 0;
	}
	setSourceVolume(source,value) {
		source.gain.gain.value = value;
	}
	createBuffer() {
		let b = new hxd_snd_webaudio_BufferHandle();
		b.samples = 0;
		return b;
	}
	setBufferData(buffer,data,size,format,channelCount,samplingRate) {
		let sampleCount;
		switch(format._hx_index) {
		case 0:
			sampleCount = 1;
			break;
		case 1:
			sampleCount = 2;
			break;
		case 2:
			sampleCount = 4;
			break;
		}
		let sampleCount1 = size / sampleCount / channelCount | 0;
		buffer.samples = sampleCount1;
		if(sampleCount1 == 0) {
			return;
		}
		if(buffer.inst == null) {
			buffer.inst = hxd_snd_webaudio_Context.getBuffer(channelCount,sampleCount1,samplingRate);
		} else if(buffer.inst.sampleRate != samplingRate || buffer.inst.numberOfChannels != channelCount || buffer.inst.length != sampleCount1) {
			hxd_snd_webaudio_Context.putBuffer(buffer.inst);
			buffer.inst = hxd_snd_webaudio_Context.getBuffer(channelCount,sampleCount1,samplingRate);
		}
		switch(format._hx_index) {
		case 0:
			let ui8 = new Uint8Array(data.b.bufferValue);
			if(channelCount == 1) {
				let chn = buffer.inst.getChannelData(0);
				let _g = 0;
				while(_g < sampleCount1) {
					let i = _g++;
					chn[i] = (ui8[i] - 128) / 128;
				}
			} else {
				let left = buffer.inst.getChannelData(0);
				let right = buffer.inst.getChannelData(1);
				let r = 0;
				let _g = 0;
				while(_g < sampleCount1) {
					let i = _g++;
					left[i] = (ui8[r] - 128) / 128;
					right[i] = (ui8[r + 1] - 128) / 128;
					r += channelCount;
				}
			}
			break;
		case 1:
			let i16 = new Int16Array(data.b.bufferValue);
			if(channelCount == 1) {
				let chn = buffer.inst.getChannelData(0);
				let _g = 0;
				while(_g < sampleCount1) {
					let i = _g++;
					chn[i] = i16[i] / 32768;
				}
			} else {
				let left = buffer.inst.getChannelData(0);
				let right = buffer.inst.getChannelData(1);
				let r = 0;
				let _g = 0;
				while(_g < sampleCount1) {
					let i = _g++;
					left[i] = i16[r] / 32768;
					right[i] = i16[r + 1] / 32768;
					r += channelCount;
				}
			}
			break;
		case 2:
			let f32 = new Float32Array(data.b.bufferValue);
			if(channelCount == 1) {
				let chn = buffer.inst.getChannelData(0);
				let _g = 0;
				while(_g < sampleCount1) {
					let i = _g++;
					chn[i] = f32[i];
				}
			} else {
				let left = buffer.inst.getChannelData(0);
				let right = buffer.inst.getChannelData(1);
				let r = 0;
				let _g = 0;
				while(_g < sampleCount1) {
					let i = _g++;
					left[i] = f32[r];
					right[i] = f32[r + 1];
					r += channelCount;
				}
			}
			break;
		}
	}
	destroyBuffer(buffer) {
		if(buffer.inst != null) {
			hxd_snd_webaudio_Context.putBuffer(buffer.inst);
		}
		buffer.inst = null;
	}
	queueBuffer(source,buffer,sampleStart,endOfStream) {
		let buf = this.playbackPool.length != 0 ? this.playbackPool.pop() : new hxd_snd_webaudio_BufferPlayback();
		if(buffer.inst == null) {
			return;
		}
		buf.set(buffer,sampleStart / buffer.inst.length * buffer.inst.duration);
		buffer.isEnd = endOfStream;
		source.buffers.push(buf);
		if(source.playing) {
			if(source.buffers.length != 1) {
				let t = source.buffers[source.buffers.length - 2].ends;
				let tmp = this.ctx;
				let tmp1;
				if(isFinite(t)) {
					let b = this.ctx.currentTime;
					tmp1 = t < b ? b : t;
				} else {
					tmp1 = this.ctx.currentTime;
				}
				buf.start(tmp,source,tmp1);
			} else {
				buf.start(this.ctx,source,this.ctx.currentTime);
			}
		}
	}
	unqueueBuffer(source,buffer) {
		while(0 < source.buffers.length) {
			let b = source.buffers[0];
			if(b.buffer == buffer) {
				source.buffers.splice(0,1);
				b.stop(!buffer.isEnd);
				b.clear();
				this.playbackPool.push(b);
				break;
			}
		}
		if(buffer.isEnd || !source.playing) {
			source.sampleOffset = 0;
		} else {
			source.sampleOffset += buffer.samples;
		}
	}
	getProcessedBuffers(source) {
		let cnt = 0;
		let _g = 0;
		let _g1 = source.buffers;
		while(_g < _g1.length) {
			let b = _g1[_g];
			++_g;
			if(b.consumed) {
				++cnt;
			}
		}
		return cnt;
	}
	getPlayedSampleCount(source) {
		let consumed = 0;
		let buf = null;
		let _g = 0;
		let _g1 = source.buffers;
		while(_g < _g1.length) {
			let b = _g1[_g];
			++_g;
			if(b.consumed) {
				consumed += b.buffer.samples;
			} else if(b.dirty) {
				buf = b;
				break;
			}
		}
		if(buf != null) {
			return source.sampleOffset + consumed + buf.get_currentSample();
		}
		return source.sampleOffset + consumed;
	}
	update() {
	}
	getEffectDriver(type) {
		switch(type) {
		case "lowpass":
			return new hxd_snd_webaudio_LowPassDriver();
		case "pitch":
			return new hxd_snd_webaudio_PitchDriver();
		case "spatialization":
			return new hxd_snd_webaudio_SpatializationDriver();
		default:
			return new hxd_snd_EffectDriver();
		}
	}
}
$hxClasses["hxd.snd.webaudio.Driver"] = hxd_snd_webaudio_Driver;
hxd_snd_webaudio_Driver.__name__ = "hxd.snd.webaudio.Driver";
hxd_snd_webaudio_Driver.__interfaces__ = [hxd_snd_Driver];
Object.assign(hxd_snd_webaudio_Driver.prototype, {
	__class__: hxd_snd_webaudio_Driver
	,ctx: null
	,playbackPool: null
});
class hxd_snd_webaudio_LowPassDriver extends hxd_snd_EffectDriver {
	constructor() {
		hxd_snd_EffectDriver._hx_skip_constructor = true;
		super();
		hxd_snd_EffectDriver._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.pool = [];
		super._hx_constructor();
	}
	get(ctx) {
		if(this.pool.length != 0) {
			return this.pool.pop();
		}
		let node = ctx.createBiquadFilter();
		node.type = "lowpass";
		return node;
	}
	bind(e,source) {
		source.lowPass = this.get(source.driver.ctx);
		source.updateDestination();
		this.apply(e,source);
	}
	apply(e,source) {
		let max = source.driver.ctx.sampleRate / 2;
		let octaves = Math.log(max / 40) / Math.LN2;
		source.lowPass.frequency.value = max * Math.pow(2,octaves * (e.gainHF - 1));
	}
	unbind(e,source) {
		this.pool.push(source.lowPass);
		source.lowPass.disconnect();
		source.lowPass = null;
		if(source.driver != null) {
			source.updateDestination();
		}
	}
}
$hxClasses["hxd.snd.webaudio.LowPassDriver"] = hxd_snd_webaudio_LowPassDriver;
hxd_snd_webaudio_LowPassDriver.__name__ = "hxd.snd.webaudio.LowPassDriver";
hxd_snd_webaudio_LowPassDriver.__super__ = hxd_snd_EffectDriver;
Object.assign(hxd_snd_webaudio_LowPassDriver.prototype, {
	__class__: hxd_snd_webaudio_LowPassDriver
	,pool: null
});
class hxd_snd_webaudio_PitchDriver extends hxd_snd_EffectDriver {
	constructor() {
		super();
	}
	apply(e,source) {
		if(source.pitch != e.value) {
			source.pitch = e.value;
			source.applyPitch();
		}
	}
	unbind(e,source) {
		source.pitch = 1;
		source.applyPitch();
	}
}
$hxClasses["hxd.snd.webaudio.PitchDriver"] = hxd_snd_webaudio_PitchDriver;
hxd_snd_webaudio_PitchDriver.__name__ = "hxd.snd.webaudio.PitchDriver";
hxd_snd_webaudio_PitchDriver.__super__ = hxd_snd_EffectDriver;
Object.assign(hxd_snd_webaudio_PitchDriver.prototype, {
	__class__: hxd_snd_webaudio_PitchDriver
});
class hxd_snd_webaudio_SpatializationDriver extends hxd_snd_EffectDriver {
	constructor() {
		hxd_snd_EffectDriver._hx_skip_constructor = true;
		super();
		hxd_snd_EffectDriver._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.pool = [];
		super._hx_constructor();
	}
	get(ctx) {
		if(this.pool.length != 0) {
			return this.pool.pop();
		}
		let node = ctx.createPanner();
		return node;
	}
	bind(e,source) {
		source.panner = this.get(source.driver.ctx);
		source.updateDestination();
		this.apply(e,source);
	}
	apply(e,source) {
		source.panner.setPosition(-e.position.x,e.position.y,e.position.z);
		source.panner.setOrientation(-e.direction.x,e.direction.y,e.direction.z);
		source.panner.rolloffFactor = e.rollOffFactor;
		source.panner.refDistance = e.referenceDistance;
		let maxDist = e.maxDistance == null ? 3.40282347e38 : e.maxDistance;
		source.panner.maxDistance = maxDist;
	}
	unbind(e,source) {
		this.pool.push(source.panner);
		source.panner.disconnect();
		source.panner = null;
		if(source.driver != null) {
			source.updateDestination();
		}
	}
}
$hxClasses["hxd.snd.webaudio.SpatializationDriver"] = hxd_snd_webaudio_SpatializationDriver;
hxd_snd_webaudio_SpatializationDriver.__name__ = "hxd.snd.webaudio.SpatializationDriver";
hxd_snd_webaudio_SpatializationDriver.__super__ = hxd_snd_EffectDriver;
Object.assign(hxd_snd_webaudio_SpatializationDriver.prototype, {
	__class__: hxd_snd_webaudio_SpatializationDriver
	,pool: null
});
var hxsl_Type = $hxEnums["hxsl.Type"] = { __ename__:true,__constructs__:null
	,TVoid: {_hx_name:"TVoid",_hx_index:0,__enum__:"hxsl.Type",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"hxsl.Type",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:2,__enum__:"hxsl.Type",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:3,__enum__:"hxsl.Type",toString:$estr}
	,TString: {_hx_name:"TString",_hx_index:4,__enum__:"hxsl.Type",toString:$estr}
	,TVec: ($_=function(size,t) { return {_hx_index:5,size:size,t:t,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TVec",$_.__params__ = ["size","t"],$_)
	,TMat3: {_hx_name:"TMat3",_hx_index:6,__enum__:"hxsl.Type",toString:$estr}
	,TMat4: {_hx_name:"TMat4",_hx_index:7,__enum__:"hxsl.Type",toString:$estr}
	,TMat3x4: {_hx_name:"TMat3x4",_hx_index:8,__enum__:"hxsl.Type",toString:$estr}
	,TBytes: ($_=function(size) { return {_hx_index:9,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TBytes",$_.__params__ = ["size"],$_)
	,TSampler2D: {_hx_name:"TSampler2D",_hx_index:10,__enum__:"hxsl.Type",toString:$estr}
	,TSampler2DArray: {_hx_name:"TSampler2DArray",_hx_index:11,__enum__:"hxsl.Type",toString:$estr}
	,TSamplerCube: {_hx_name:"TSamplerCube",_hx_index:12,__enum__:"hxsl.Type",toString:$estr}
	,TStruct: ($_=function(vl) { return {_hx_index:13,vl:vl,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TStruct",$_.__params__ = ["vl"],$_)
	,TFun: ($_=function(variants) { return {_hx_index:14,variants:variants,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TFun",$_.__params__ = ["variants"],$_)
	,TArray: ($_=function(t,size) { return {_hx_index:15,t:t,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TArray",$_.__params__ = ["t","size"],$_)
	,TBuffer: ($_=function(t,size) { return {_hx_index:16,t:t,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TBuffer",$_.__params__ = ["t","size"],$_)
	,TChannel: ($_=function(size) { return {_hx_index:17,size:size,__enum__:"hxsl.Type",toString:$estr}; },$_._hx_name="TChannel",$_.__params__ = ["size"],$_)
	,TMat2: {_hx_name:"TMat2",_hx_index:18,__enum__:"hxsl.Type",toString:$estr}
};
hxsl_Type.__constructs__ = [hxsl_Type.TVoid,hxsl_Type.TInt,hxsl_Type.TBool,hxsl_Type.TFloat,hxsl_Type.TString,hxsl_Type.TVec,hxsl_Type.TMat3,hxsl_Type.TMat4,hxsl_Type.TMat3x4,hxsl_Type.TBytes,hxsl_Type.TSampler2D,hxsl_Type.TSampler2DArray,hxsl_Type.TSamplerCube,hxsl_Type.TStruct,hxsl_Type.TFun,hxsl_Type.TArray,hxsl_Type.TBuffer,hxsl_Type.TChannel,hxsl_Type.TMat2];
hxsl_Type.__empty_constructs__ = [hxsl_Type.TVoid,hxsl_Type.TInt,hxsl_Type.TBool,hxsl_Type.TFloat,hxsl_Type.TString,hxsl_Type.TMat3,hxsl_Type.TMat4,hxsl_Type.TMat3x4,hxsl_Type.TSampler2D,hxsl_Type.TSampler2DArray,hxsl_Type.TSamplerCube,hxsl_Type.TMat2];
var hxsl_VecType = $hxEnums["hxsl.VecType"] = { __ename__:true,__constructs__:null
	,VInt: {_hx_name:"VInt",_hx_index:0,__enum__:"hxsl.VecType",toString:$estr}
	,VFloat: {_hx_name:"VFloat",_hx_index:1,__enum__:"hxsl.VecType",toString:$estr}
	,VBool: {_hx_name:"VBool",_hx_index:2,__enum__:"hxsl.VecType",toString:$estr}
};
hxsl_VecType.__constructs__ = [hxsl_VecType.VInt,hxsl_VecType.VFloat,hxsl_VecType.VBool];
hxsl_VecType.__empty_constructs__ = [hxsl_VecType.VInt,hxsl_VecType.VFloat,hxsl_VecType.VBool];
var hxsl_SizeDecl = $hxEnums["hxsl.SizeDecl"] = { __ename__:true,__constructs__:null
	,SConst: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hxsl.SizeDecl",toString:$estr}; },$_._hx_name="SConst",$_.__params__ = ["v"],$_)
	,SVar: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"hxsl.SizeDecl",toString:$estr}; },$_._hx_name="SVar",$_.__params__ = ["v"],$_)
};
hxsl_SizeDecl.__constructs__ = [hxsl_SizeDecl.SConst,hxsl_SizeDecl.SVar];
hxsl_SizeDecl.__empty_constructs__ = [];
class hxsl_Error {
	constructor(msg,pos) {
		this.msg = msg;
		this.pos = pos;
	}
	toString() {
		return "Error(" + this.msg + ")@" + Std.string(this.pos);
	}
	static t(msg,pos) {
		throw haxe_Exception.thrown(new hxsl_Error(msg,pos));
	}
}
$hxClasses["hxsl.Error"] = hxsl_Error;
hxsl_Error.__name__ = "hxsl.Error";
Object.assign(hxsl_Error.prototype, {
	__class__: hxsl_Error
	,msg: null
	,pos: null
});
var hxsl_VarKind = $hxEnums["hxsl.VarKind"] = { __ename__:true,__constructs__:null
	,Global: {_hx_name:"Global",_hx_index:0,__enum__:"hxsl.VarKind",toString:$estr}
	,Input: {_hx_name:"Input",_hx_index:1,__enum__:"hxsl.VarKind",toString:$estr}
	,Param: {_hx_name:"Param",_hx_index:2,__enum__:"hxsl.VarKind",toString:$estr}
	,Var: {_hx_name:"Var",_hx_index:3,__enum__:"hxsl.VarKind",toString:$estr}
	,Local: {_hx_name:"Local",_hx_index:4,__enum__:"hxsl.VarKind",toString:$estr}
	,Output: {_hx_name:"Output",_hx_index:5,__enum__:"hxsl.VarKind",toString:$estr}
	,Function: {_hx_name:"Function",_hx_index:6,__enum__:"hxsl.VarKind",toString:$estr}
};
hxsl_VarKind.__constructs__ = [hxsl_VarKind.Global,hxsl_VarKind.Input,hxsl_VarKind.Param,hxsl_VarKind.Var,hxsl_VarKind.Local,hxsl_VarKind.Output,hxsl_VarKind.Function];
hxsl_VarKind.__empty_constructs__ = [hxsl_VarKind.Global,hxsl_VarKind.Input,hxsl_VarKind.Param,hxsl_VarKind.Var,hxsl_VarKind.Local,hxsl_VarKind.Output,hxsl_VarKind.Function];
var hxsl_VarQualifier = $hxEnums["hxsl.VarQualifier"] = { __ename__:true,__constructs__:null
	,Const: ($_=function(max) { return {_hx_index:0,max:max,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Const",$_.__params__ = ["max"],$_)
	,Private: {_hx_name:"Private",_hx_index:1,__enum__:"hxsl.VarQualifier",toString:$estr}
	,Nullable: {_hx_name:"Nullable",_hx_index:2,__enum__:"hxsl.VarQualifier",toString:$estr}
	,PerObject: {_hx_name:"PerObject",_hx_index:3,__enum__:"hxsl.VarQualifier",toString:$estr}
	,Name: ($_=function(n) { return {_hx_index:4,n:n,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Name",$_.__params__ = ["n"],$_)
	,Shared: {_hx_name:"Shared",_hx_index:5,__enum__:"hxsl.VarQualifier",toString:$estr}
	,Precision: ($_=function(p) { return {_hx_index:6,p:p,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Precision",$_.__params__ = ["p"],$_)
	,Range: ($_=function(min,max) { return {_hx_index:7,min:min,max:max,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Range",$_.__params__ = ["min","max"],$_)
	,Ignore: {_hx_name:"Ignore",_hx_index:8,__enum__:"hxsl.VarQualifier",toString:$estr}
	,PerInstance: ($_=function(v) { return {_hx_index:9,v:v,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="PerInstance",$_.__params__ = ["v"],$_)
	,Doc: ($_=function(s) { return {_hx_index:10,s:s,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Doc",$_.__params__ = ["s"],$_)
	,Borrow: ($_=function(source) { return {_hx_index:11,source:source,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Borrow",$_.__params__ = ["source"],$_)
	,Sampler: ($_=function(name) { return {_hx_index:12,name:name,__enum__:"hxsl.VarQualifier",toString:$estr}; },$_._hx_name="Sampler",$_.__params__ = ["name"],$_)
};
hxsl_VarQualifier.__constructs__ = [hxsl_VarQualifier.Const,hxsl_VarQualifier.Private,hxsl_VarQualifier.Nullable,hxsl_VarQualifier.PerObject,hxsl_VarQualifier.Name,hxsl_VarQualifier.Shared,hxsl_VarQualifier.Precision,hxsl_VarQualifier.Range,hxsl_VarQualifier.Ignore,hxsl_VarQualifier.PerInstance,hxsl_VarQualifier.Doc,hxsl_VarQualifier.Borrow,hxsl_VarQualifier.Sampler];
hxsl_VarQualifier.__empty_constructs__ = [hxsl_VarQualifier.Private,hxsl_VarQualifier.Nullable,hxsl_VarQualifier.PerObject,hxsl_VarQualifier.Shared,hxsl_VarQualifier.Ignore];
var hxsl_Prec = $hxEnums["hxsl.Prec"] = { __ename__:true,__constructs__:null
	,Low: {_hx_name:"Low",_hx_index:0,__enum__:"hxsl.Prec",toString:$estr}
	,Medium: {_hx_name:"Medium",_hx_index:1,__enum__:"hxsl.Prec",toString:$estr}
	,High: {_hx_name:"High",_hx_index:2,__enum__:"hxsl.Prec",toString:$estr}
};
hxsl_Prec.__constructs__ = [hxsl_Prec.Low,hxsl_Prec.Medium,hxsl_Prec.High];
hxsl_Prec.__empty_constructs__ = [hxsl_Prec.Low,hxsl_Prec.Medium,hxsl_Prec.High];
var hxsl_Const = $hxEnums["hxsl.Const"] = { __ename__:true,__constructs__:null
	,CNull: {_hx_name:"CNull",_hx_index:0,__enum__:"hxsl.Const",toString:$estr}
	,CBool: ($_=function(b) { return {_hx_index:1,b:b,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CBool",$_.__params__ = ["b"],$_)
	,CInt: ($_=function(v) { return {_hx_index:2,v:v,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CInt",$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(v) { return {_hx_index:3,v:v,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CFloat",$_.__params__ = ["v"],$_)
	,CString: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"hxsl.Const",toString:$estr}; },$_._hx_name="CString",$_.__params__ = ["v"],$_)
};
hxsl_Const.__constructs__ = [hxsl_Const.CNull,hxsl_Const.CBool,hxsl_Const.CInt,hxsl_Const.CFloat,hxsl_Const.CString];
hxsl_Const.__empty_constructs__ = [hxsl_Const.CNull];
var hxsl_TExprDef = $hxEnums["hxsl.TExprDef"] = { __ename__:true,__constructs__:null
	,TConst: ($_=function(c) { return {_hx_index:0,c:c,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TConst",$_.__params__ = ["c"],$_)
	,TVar: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TVar",$_.__params__ = ["v"],$_)
	,TGlobal: ($_=function(g) { return {_hx_index:2,g:g,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TGlobal",$_.__params__ = ["g"],$_)
	,TParenthesis: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TParenthesis",$_.__params__ = ["e"],$_)
	,TBlock: ($_=function(el) { return {_hx_index:4,el:el,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TBlock",$_.__params__ = ["el"],$_)
	,TBinop: ($_=function(op,e1,e2) { return {_hx_index:5,op:op,e1:e1,e2:e2,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TBinop",$_.__params__ = ["op","e1","e2"],$_)
	,TUnop: ($_=function(op,e1) { return {_hx_index:6,op:op,e1:e1,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TUnop",$_.__params__ = ["op","e1"],$_)
	,TVarDecl: ($_=function(v,init) { return {_hx_index:7,v:v,init:init,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TVarDecl",$_.__params__ = ["v","init"],$_)
	,TCall: ($_=function(e,args) { return {_hx_index:8,e:e,args:args,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TCall",$_.__params__ = ["e","args"],$_)
	,TSwiz: ($_=function(e,regs) { return {_hx_index:9,e:e,regs:regs,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TSwiz",$_.__params__ = ["e","regs"],$_)
	,TIf: ($_=function(econd,eif,eelse) { return {_hx_index:10,econd:econd,eif:eif,eelse:eelse,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TIf",$_.__params__ = ["econd","eif","eelse"],$_)
	,TDiscard: {_hx_name:"TDiscard",_hx_index:11,__enum__:"hxsl.TExprDef",toString:$estr}
	,TReturn: ($_=function(e) { return {_hx_index:12,e:e,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TReturn",$_.__params__ = ["e"],$_)
	,TFor: ($_=function(v,it,loop) { return {_hx_index:13,v:v,it:it,loop:loop,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TFor",$_.__params__ = ["v","it","loop"],$_)
	,TContinue: {_hx_name:"TContinue",_hx_index:14,__enum__:"hxsl.TExprDef",toString:$estr}
	,TBreak: {_hx_name:"TBreak",_hx_index:15,__enum__:"hxsl.TExprDef",toString:$estr}
	,TArray: ($_=function(e,index) { return {_hx_index:16,e:e,index:index,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TArray",$_.__params__ = ["e","index"],$_)
	,TArrayDecl: ($_=function(el) { return {_hx_index:17,el:el,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TArrayDecl",$_.__params__ = ["el"],$_)
	,TSwitch: ($_=function(e,cases,def) { return {_hx_index:18,e:e,cases:cases,def:def,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TSwitch",$_.__params__ = ["e","cases","def"],$_)
	,TWhile: ($_=function(e,loop,normalWhile) { return {_hx_index:19,e:e,loop:loop,normalWhile:normalWhile,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TWhile",$_.__params__ = ["e","loop","normalWhile"],$_)
	,TMeta: ($_=function(m,args,e) { return {_hx_index:20,m:m,args:args,e:e,__enum__:"hxsl.TExprDef",toString:$estr}; },$_._hx_name="TMeta",$_.__params__ = ["m","args","e"],$_)
};
hxsl_TExprDef.__constructs__ = [hxsl_TExprDef.TConst,hxsl_TExprDef.TVar,hxsl_TExprDef.TGlobal,hxsl_TExprDef.TParenthesis,hxsl_TExprDef.TBlock,hxsl_TExprDef.TBinop,hxsl_TExprDef.TUnop,hxsl_TExprDef.TVarDecl,hxsl_TExprDef.TCall,hxsl_TExprDef.TSwiz,hxsl_TExprDef.TIf,hxsl_TExprDef.TDiscard,hxsl_TExprDef.TReturn,hxsl_TExprDef.TFor,hxsl_TExprDef.TContinue,hxsl_TExprDef.TBreak,hxsl_TExprDef.TArray,hxsl_TExprDef.TArrayDecl,hxsl_TExprDef.TSwitch,hxsl_TExprDef.TWhile,hxsl_TExprDef.TMeta];
hxsl_TExprDef.__empty_constructs__ = [hxsl_TExprDef.TDiscard,hxsl_TExprDef.TContinue,hxsl_TExprDef.TBreak];
var hxsl_FunctionKind = $hxEnums["hxsl.FunctionKind"] = { __ename__:true,__constructs__:null
	,Vertex: {_hx_name:"Vertex",_hx_index:0,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Fragment: {_hx_name:"Fragment",_hx_index:1,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Init: {_hx_name:"Init",_hx_index:2,__enum__:"hxsl.FunctionKind",toString:$estr}
	,Helper: {_hx_name:"Helper",_hx_index:3,__enum__:"hxsl.FunctionKind",toString:$estr}
};
hxsl_FunctionKind.__constructs__ = [hxsl_FunctionKind.Vertex,hxsl_FunctionKind.Fragment,hxsl_FunctionKind.Init,hxsl_FunctionKind.Helper];
hxsl_FunctionKind.__empty_constructs__ = [hxsl_FunctionKind.Vertex,hxsl_FunctionKind.Fragment,hxsl_FunctionKind.Init,hxsl_FunctionKind.Helper];
var hxsl_TGlobal = $hxEnums["hxsl.TGlobal"] = { __ename__:true,__constructs__:null
	,Radians: {_hx_name:"Radians",_hx_index:0,__enum__:"hxsl.TGlobal",toString:$estr}
	,Degrees: {_hx_name:"Degrees",_hx_index:1,__enum__:"hxsl.TGlobal",toString:$estr}
	,Sin: {_hx_name:"Sin",_hx_index:2,__enum__:"hxsl.TGlobal",toString:$estr}
	,Cos: {_hx_name:"Cos",_hx_index:3,__enum__:"hxsl.TGlobal",toString:$estr}
	,Tan: {_hx_name:"Tan",_hx_index:4,__enum__:"hxsl.TGlobal",toString:$estr}
	,Asin: {_hx_name:"Asin",_hx_index:5,__enum__:"hxsl.TGlobal",toString:$estr}
	,Acos: {_hx_name:"Acos",_hx_index:6,__enum__:"hxsl.TGlobal",toString:$estr}
	,Atan: {_hx_name:"Atan",_hx_index:7,__enum__:"hxsl.TGlobal",toString:$estr}
	,Pow: {_hx_name:"Pow",_hx_index:8,__enum__:"hxsl.TGlobal",toString:$estr}
	,Exp: {_hx_name:"Exp",_hx_index:9,__enum__:"hxsl.TGlobal",toString:$estr}
	,Log: {_hx_name:"Log",_hx_index:10,__enum__:"hxsl.TGlobal",toString:$estr}
	,Exp2: {_hx_name:"Exp2",_hx_index:11,__enum__:"hxsl.TGlobal",toString:$estr}
	,Log2: {_hx_name:"Log2",_hx_index:12,__enum__:"hxsl.TGlobal",toString:$estr}
	,Sqrt: {_hx_name:"Sqrt",_hx_index:13,__enum__:"hxsl.TGlobal",toString:$estr}
	,Inversesqrt: {_hx_name:"Inversesqrt",_hx_index:14,__enum__:"hxsl.TGlobal",toString:$estr}
	,Abs: {_hx_name:"Abs",_hx_index:15,__enum__:"hxsl.TGlobal",toString:$estr}
	,Sign: {_hx_name:"Sign",_hx_index:16,__enum__:"hxsl.TGlobal",toString:$estr}
	,Floor: {_hx_name:"Floor",_hx_index:17,__enum__:"hxsl.TGlobal",toString:$estr}
	,Ceil: {_hx_name:"Ceil",_hx_index:18,__enum__:"hxsl.TGlobal",toString:$estr}
	,Fract: {_hx_name:"Fract",_hx_index:19,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mod: {_hx_name:"Mod",_hx_index:20,__enum__:"hxsl.TGlobal",toString:$estr}
	,Min: {_hx_name:"Min",_hx_index:21,__enum__:"hxsl.TGlobal",toString:$estr}
	,Max: {_hx_name:"Max",_hx_index:22,__enum__:"hxsl.TGlobal",toString:$estr}
	,Clamp: {_hx_name:"Clamp",_hx_index:23,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mix: {_hx_name:"Mix",_hx_index:24,__enum__:"hxsl.TGlobal",toString:$estr}
	,Step: {_hx_name:"Step",_hx_index:25,__enum__:"hxsl.TGlobal",toString:$estr}
	,Smoothstep: {_hx_name:"Smoothstep",_hx_index:26,__enum__:"hxsl.TGlobal",toString:$estr}
	,Length: {_hx_name:"Length",_hx_index:27,__enum__:"hxsl.TGlobal",toString:$estr}
	,Distance: {_hx_name:"Distance",_hx_index:28,__enum__:"hxsl.TGlobal",toString:$estr}
	,Dot: {_hx_name:"Dot",_hx_index:29,__enum__:"hxsl.TGlobal",toString:$estr}
	,Cross: {_hx_name:"Cross",_hx_index:30,__enum__:"hxsl.TGlobal",toString:$estr}
	,Normalize: {_hx_name:"Normalize",_hx_index:31,__enum__:"hxsl.TGlobal",toString:$estr}
	,LReflect: {_hx_name:"LReflect",_hx_index:32,__enum__:"hxsl.TGlobal",toString:$estr}
	,Texture: {_hx_name:"Texture",_hx_index:33,__enum__:"hxsl.TGlobal",toString:$estr}
	,TextureLod: {_hx_name:"TextureLod",_hx_index:34,__enum__:"hxsl.TGlobal",toString:$estr}
	,Texel: {_hx_name:"Texel",_hx_index:35,__enum__:"hxsl.TGlobal",toString:$estr}
	,TextureSize: {_hx_name:"TextureSize",_hx_index:36,__enum__:"hxsl.TGlobal",toString:$estr}
	,ToInt: {_hx_name:"ToInt",_hx_index:37,__enum__:"hxsl.TGlobal",toString:$estr}
	,ToFloat: {_hx_name:"ToFloat",_hx_index:38,__enum__:"hxsl.TGlobal",toString:$estr}
	,ToBool: {_hx_name:"ToBool",_hx_index:39,__enum__:"hxsl.TGlobal",toString:$estr}
	,Vec2: {_hx_name:"Vec2",_hx_index:40,__enum__:"hxsl.TGlobal",toString:$estr}
	,Vec3: {_hx_name:"Vec3",_hx_index:41,__enum__:"hxsl.TGlobal",toString:$estr}
	,Vec4: {_hx_name:"Vec4",_hx_index:42,__enum__:"hxsl.TGlobal",toString:$estr}
	,IVec2: {_hx_name:"IVec2",_hx_index:43,__enum__:"hxsl.TGlobal",toString:$estr}
	,IVec3: {_hx_name:"IVec3",_hx_index:44,__enum__:"hxsl.TGlobal",toString:$estr}
	,IVec4: {_hx_name:"IVec4",_hx_index:45,__enum__:"hxsl.TGlobal",toString:$estr}
	,BVec2: {_hx_name:"BVec2",_hx_index:46,__enum__:"hxsl.TGlobal",toString:$estr}
	,BVec3: {_hx_name:"BVec3",_hx_index:47,__enum__:"hxsl.TGlobal",toString:$estr}
	,BVec4: {_hx_name:"BVec4",_hx_index:48,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat2: {_hx_name:"Mat2",_hx_index:49,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat3: {_hx_name:"Mat3",_hx_index:50,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat4: {_hx_name:"Mat4",_hx_index:51,__enum__:"hxsl.TGlobal",toString:$estr}
	,Mat3x4: {_hx_name:"Mat3x4",_hx_index:52,__enum__:"hxsl.TGlobal",toString:$estr}
	,Saturate: {_hx_name:"Saturate",_hx_index:53,__enum__:"hxsl.TGlobal",toString:$estr}
	,Pack: {_hx_name:"Pack",_hx_index:54,__enum__:"hxsl.TGlobal",toString:$estr}
	,Unpack: {_hx_name:"Unpack",_hx_index:55,__enum__:"hxsl.TGlobal",toString:$estr}
	,PackNormal: {_hx_name:"PackNormal",_hx_index:56,__enum__:"hxsl.TGlobal",toString:$estr}
	,UnpackNormal: {_hx_name:"UnpackNormal",_hx_index:57,__enum__:"hxsl.TGlobal",toString:$estr}
	,ScreenToUv: {_hx_name:"ScreenToUv",_hx_index:58,__enum__:"hxsl.TGlobal",toString:$estr}
	,UvToScreen: {_hx_name:"UvToScreen",_hx_index:59,__enum__:"hxsl.TGlobal",toString:$estr}
	,DFdx: {_hx_name:"DFdx",_hx_index:60,__enum__:"hxsl.TGlobal",toString:$estr}
	,DFdy: {_hx_name:"DFdy",_hx_index:61,__enum__:"hxsl.TGlobal",toString:$estr}
	,Fwidth: {_hx_name:"Fwidth",_hx_index:62,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelRead: {_hx_name:"ChannelRead",_hx_index:63,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelReadLod: {_hx_name:"ChannelReadLod",_hx_index:64,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelFetch: {_hx_name:"ChannelFetch",_hx_index:65,__enum__:"hxsl.TGlobal",toString:$estr}
	,ChannelTextureSize: {_hx_name:"ChannelTextureSize",_hx_index:66,__enum__:"hxsl.TGlobal",toString:$estr}
	,Trace: {_hx_name:"Trace",_hx_index:67,__enum__:"hxsl.TGlobal",toString:$estr}
	,VertexID: {_hx_name:"VertexID",_hx_index:68,__enum__:"hxsl.TGlobal",toString:$estr}
	,InstanceID: {_hx_name:"InstanceID",_hx_index:69,__enum__:"hxsl.TGlobal",toString:$estr}
	,FragCoord: {_hx_name:"FragCoord",_hx_index:70,__enum__:"hxsl.TGlobal",toString:$estr}
	,FrontFacing: {_hx_name:"FrontFacing",_hx_index:71,__enum__:"hxsl.TGlobal",toString:$estr}
};
hxsl_TGlobal.__constructs__ = [hxsl_TGlobal.Radians,hxsl_TGlobal.Degrees,hxsl_TGlobal.Sin,hxsl_TGlobal.Cos,hxsl_TGlobal.Tan,hxsl_TGlobal.Asin,hxsl_TGlobal.Acos,hxsl_TGlobal.Atan,hxsl_TGlobal.Pow,hxsl_TGlobal.Exp,hxsl_TGlobal.Log,hxsl_TGlobal.Exp2,hxsl_TGlobal.Log2,hxsl_TGlobal.Sqrt,hxsl_TGlobal.Inversesqrt,hxsl_TGlobal.Abs,hxsl_TGlobal.Sign,hxsl_TGlobal.Floor,hxsl_TGlobal.Ceil,hxsl_TGlobal.Fract,hxsl_TGlobal.Mod,hxsl_TGlobal.Min,hxsl_TGlobal.Max,hxsl_TGlobal.Clamp,hxsl_TGlobal.Mix,hxsl_TGlobal.Step,hxsl_TGlobal.Smoothstep,hxsl_TGlobal.Length,hxsl_TGlobal.Distance,hxsl_TGlobal.Dot,hxsl_TGlobal.Cross,hxsl_TGlobal.Normalize,hxsl_TGlobal.LReflect,hxsl_TGlobal.Texture,hxsl_TGlobal.TextureLod,hxsl_TGlobal.Texel,hxsl_TGlobal.TextureSize,hxsl_TGlobal.ToInt,hxsl_TGlobal.ToFloat,hxsl_TGlobal.ToBool,hxsl_TGlobal.Vec2,hxsl_TGlobal.Vec3,hxsl_TGlobal.Vec4,hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4,hxsl_TGlobal.BVec2,hxsl_TGlobal.BVec3,hxsl_TGlobal.BVec4,hxsl_TGlobal.Mat2,hxsl_TGlobal.Mat3,hxsl_TGlobal.Mat4,hxsl_TGlobal.Mat3x4,hxsl_TGlobal.Saturate,hxsl_TGlobal.Pack,hxsl_TGlobal.Unpack,hxsl_TGlobal.PackNormal,hxsl_TGlobal.UnpackNormal,hxsl_TGlobal.ScreenToUv,hxsl_TGlobal.UvToScreen,hxsl_TGlobal.DFdx,hxsl_TGlobal.DFdy,hxsl_TGlobal.Fwidth,hxsl_TGlobal.ChannelRead,hxsl_TGlobal.ChannelReadLod,hxsl_TGlobal.ChannelFetch,hxsl_TGlobal.ChannelTextureSize,hxsl_TGlobal.Trace,hxsl_TGlobal.VertexID,hxsl_TGlobal.InstanceID,hxsl_TGlobal.FragCoord,hxsl_TGlobal.FrontFacing];
hxsl_TGlobal.__empty_constructs__ = [hxsl_TGlobal.Radians,hxsl_TGlobal.Degrees,hxsl_TGlobal.Sin,hxsl_TGlobal.Cos,hxsl_TGlobal.Tan,hxsl_TGlobal.Asin,hxsl_TGlobal.Acos,hxsl_TGlobal.Atan,hxsl_TGlobal.Pow,hxsl_TGlobal.Exp,hxsl_TGlobal.Log,hxsl_TGlobal.Exp2,hxsl_TGlobal.Log2,hxsl_TGlobal.Sqrt,hxsl_TGlobal.Inversesqrt,hxsl_TGlobal.Abs,hxsl_TGlobal.Sign,hxsl_TGlobal.Floor,hxsl_TGlobal.Ceil,hxsl_TGlobal.Fract,hxsl_TGlobal.Mod,hxsl_TGlobal.Min,hxsl_TGlobal.Max,hxsl_TGlobal.Clamp,hxsl_TGlobal.Mix,hxsl_TGlobal.Step,hxsl_TGlobal.Smoothstep,hxsl_TGlobal.Length,hxsl_TGlobal.Distance,hxsl_TGlobal.Dot,hxsl_TGlobal.Cross,hxsl_TGlobal.Normalize,hxsl_TGlobal.LReflect,hxsl_TGlobal.Texture,hxsl_TGlobal.TextureLod,hxsl_TGlobal.Texel,hxsl_TGlobal.TextureSize,hxsl_TGlobal.ToInt,hxsl_TGlobal.ToFloat,hxsl_TGlobal.ToBool,hxsl_TGlobal.Vec2,hxsl_TGlobal.Vec3,hxsl_TGlobal.Vec4,hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4,hxsl_TGlobal.BVec2,hxsl_TGlobal.BVec3,hxsl_TGlobal.BVec4,hxsl_TGlobal.Mat2,hxsl_TGlobal.Mat3,hxsl_TGlobal.Mat4,hxsl_TGlobal.Mat3x4,hxsl_TGlobal.Saturate,hxsl_TGlobal.Pack,hxsl_TGlobal.Unpack,hxsl_TGlobal.PackNormal,hxsl_TGlobal.UnpackNormal,hxsl_TGlobal.ScreenToUv,hxsl_TGlobal.UvToScreen,hxsl_TGlobal.DFdx,hxsl_TGlobal.DFdy,hxsl_TGlobal.Fwidth,hxsl_TGlobal.ChannelRead,hxsl_TGlobal.ChannelReadLod,hxsl_TGlobal.ChannelFetch,hxsl_TGlobal.ChannelTextureSize,hxsl_TGlobal.Trace,hxsl_TGlobal.VertexID,hxsl_TGlobal.InstanceID,hxsl_TGlobal.FragCoord,hxsl_TGlobal.FrontFacing];
var hxsl_Component = $hxEnums["hxsl.Component"] = { __ename__:true,__constructs__:null
	,X: {_hx_name:"X",_hx_index:0,__enum__:"hxsl.Component",toString:$estr}
	,Y: {_hx_name:"Y",_hx_index:1,__enum__:"hxsl.Component",toString:$estr}
	,Z: {_hx_name:"Z",_hx_index:2,__enum__:"hxsl.Component",toString:$estr}
	,W: {_hx_name:"W",_hx_index:3,__enum__:"hxsl.Component",toString:$estr}
};
hxsl_Component.__constructs__ = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
hxsl_Component.__empty_constructs__ = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
class hxsl_Tools {
	static allocVarId() {
		return ++hxsl_Tools.UID;
	}
	static getName(v) {
		if(v.qualifiers == null) {
			return v.name;
		}
		let _g = 0;
		let _g1 = v.qualifiers;
		while(_g < _g1.length) {
			let q = _g1[_g];
			++_g;
			if(q._hx_index == 4) {
				return q.n;
			}
		}
		return v.name;
	}
	static getConstBits(v) {
		switch(v.type._hx_index) {
		case 1:
			let _g = 0;
			let _g1 = v.qualifiers;
			while(_g < _g1.length) {
				let q = _g1[_g];
				++_g;
				if(q._hx_index == 0) {
					let _g = q.max;
					if(_g != null) {
						let bits = 0;
						while(_g >= 1 << bits) ++bits;
						return bits;
					}
					return 8;
				}
			}
			break;
		case 2:
			return 1;
		case 17:
			return 3 + hxsl_Tools.MAX_CHANNELS_BITS;
		default:
		}
		return 0;
	}
	static isConst(v) {
		if(v.type._hx_index == 17) {
			return true;
		}
		if(v.qualifiers != null) {
			let _g = 0;
			let _g1 = v.qualifiers;
			while(_g < _g1.length) {
				let q = _g1[_g];
				++_g;
				if(q._hx_index == 0) {
					return true;
				}
			}
		}
		return false;
	}
	static hasQualifier(v,q) {
		if(v.qualifiers != null) {
			let _g = 0;
			let _g1 = v.qualifiers;
			while(_g < _g1.length) {
				let q2 = _g1[_g];
				++_g;
				if(q2 == q) {
					return true;
				}
			}
		}
		return false;
	}
	static hasBorrowQualifier(v,path) {
		if(v.qualifiers != null) {
			let _g = 0;
			let _g1 = v.qualifiers;
			while(_g < _g1.length) {
				let q = _g1[_g];
				++_g;
				if(q._hx_index == 11) {
					return path == q.source;
				}
			}
		}
		return false;
	}
	static isSampler(t) {
		switch(t._hx_index) {
		case 10:case 11:case 12:
			return true;
		case 17:
			return true;
		default:
			return false;
		}
	}
	static toString(t) {
		switch(t._hx_index) {
		case 5:
			let _g = t.size;
			let prefix;
			switch(t.t._hx_index) {
			case 0:
				prefix = "I";
				break;
			case 1:
				prefix = "";
				break;
			case 2:
				prefix = "B";
				break;
			}
			return prefix + "Vec" + _g;
		case 9:
			return "Bytes" + t.size;
		case 13:
			let _g1 = t.vl;
			let _g2 = [];
			let _g3 = 0;
			while(_g3 < _g1.length) {
				let v = _g1[_g3];
				++_g3;
				_g2.push(v.name + " : " + hxsl_Tools.toString(v.type));
			}
			return "{" + _g2.join(",") + "}";
		case 15:
			let _g4 = t.size;
			let tmp = hxsl_Tools.toString(t.t) + "[";
			let tmp1;
			switch(_g4._hx_index) {
			case 0:
				tmp1 = "" + _g4.v;
				break;
			case 1:
				tmp1 = _g4.v.name;
				break;
			}
			return tmp + tmp1 + "]";
		case 16:
			let _g5 = t.size;
			let tmp2 = "buffer " + hxsl_Tools.toString(t.t) + "[";
			let tmp3;
			switch(_g5._hx_index) {
			case 0:
				tmp3 = "" + _g5.v;
				break;
			case 1:
				tmp3 = _g5.v.name;
				break;
			}
			return tmp2 + tmp3 + "]";
		default:
			return HxOverrides.substr($hxEnums[t.__enum__].__constructs__[t._hx_index]._hx_name,1,null);
		}
	}
	static hasSideEffect(e) {
		while(true) {
			let _g = e.e;
			switch(_g._hx_index) {
			case 0:
				return false;
			case 1:
				return false;
			case 2:
				return false;
			case 3:
				e = _g.e;
				continue;
			case 4:
				let _g1 = _g.el;
				let _g2 = 0;
				while(_g2 < _g1.length) {
					let e = _g1[_g2];
					++_g2;
					if(hxsl_Tools.hasSideEffect(e)) {
						return true;
					}
				}
				return false;
			case 5:
				let _g3 = _g.e1;
				let _g4 = _g.e2;
				switch(_g.op._hx_index) {
				case 4:
					return true;
				case 20:
					return true;
				default:
					if(!hxsl_Tools.hasSideEffect(_g3)) {
						return hxsl_Tools.hasSideEffect(_g4);
					} else {
						return true;
					}
				}
				break;
			case 6:
				e = _g.e1;
				continue;
			case 7:
				return true;
			case 8:
				let _g5 = _g.args;
				if(_g.e.e._hx_index != 2) {
					return true;
				}
				let _g6 = 0;
				while(_g6 < _g5.length) {
					let p = _g5[_g6];
					++_g6;
					if(hxsl_Tools.hasSideEffect(p)) {
						return true;
					}
				}
				return false;
			case 9:
				e = _g.e;
				continue;
			case 10:
				let _g7 = _g.eelse;
				if(!(hxsl_Tools.hasSideEffect(_g.econd) || hxsl_Tools.hasSideEffect(_g.eif))) {
					if(_g7 != null) {
						return hxsl_Tools.hasSideEffect(_g7);
					} else {
						return false;
					}
				} else {
					return true;
				}
				break;
			case 12:
				return true;
			case 13:
				if(!hxsl_Tools.hasSideEffect(_g.it)) {
					return hxsl_Tools.hasSideEffect(_g.loop);
				} else {
					return true;
				}
				break;
			case 11:case 14:case 15:
				return true;
			case 16:
				if(!hxsl_Tools.hasSideEffect(_g.e)) {
					return hxsl_Tools.hasSideEffect(_g.index);
				} else {
					return true;
				}
				break;
			case 17:
				let _g8 = _g.el;
				let _g9 = 0;
				while(_g9 < _g8.length) {
					let e = _g8[_g9];
					++_g9;
					if(hxsl_Tools.hasSideEffect(e)) {
						return true;
					}
				}
				return false;
			case 18:
				let _g10 = _g.e;
				let _g11 = _g.cases;
				let _g12 = _g.def;
				let _g13 = 0;
				while(_g13 < _g11.length) {
					let c = _g11[_g13];
					++_g13;
					let _g = 0;
					let _g1 = c.values;
					while(_g < _g1.length) {
						let v = _g1[_g];
						++_g;
						if(hxsl_Tools.hasSideEffect(v)) {
							return true;
						}
					}
					if(hxsl_Tools.hasSideEffect(c.expr)) {
						return true;
					}
				}
				if(!hxsl_Tools.hasSideEffect(_g10)) {
					if(_g12 != null) {
						return hxsl_Tools.hasSideEffect(_g12);
					} else {
						return false;
					}
				} else {
					return true;
				}
				break;
			case 19:
				if(!hxsl_Tools.hasSideEffect(_g.e)) {
					return hxsl_Tools.hasSideEffect(_g.loop);
				} else {
					return true;
				}
				break;
			case 20:
				e = _g.e;
				continue;
			}
		}
	}
	static iter(e,f) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 0:
			break;
		case 1:
			break;
		case 2:
			break;
		case 3:
			f(_g.e);
			break;
		case 4:
			let _g1 = _g.el;
			let _g2 = 0;
			while(_g2 < _g1.length) {
				let e = _g1[_g2];
				++_g2;
				f(e);
			}
			break;
		case 5:
			f(_g.e1);
			f(_g.e2);
			break;
		case 6:
			f(_g.e1);
			break;
		case 7:
			let _g3 = _g.init;
			if(_g3 != null) {
				f(_g3);
			}
			break;
		case 8:
			let _g4 = _g.args;
			f(_g.e);
			let _g5 = 0;
			while(_g5 < _g4.length) {
				let a = _g4[_g5];
				++_g5;
				f(a);
			}
			break;
		case 9:
			f(_g.e);
			break;
		case 10:
			let _g6 = _g.eelse;
			f(_g.econd);
			f(_g.eif);
			if(_g6 != null) {
				f(_g6);
			}
			break;
		case 12:
			let _g7 = _g.e;
			if(_g7 != null) {
				f(_g7);
			}
			break;
		case 13:
			f(_g.it);
			f(_g.loop);
			break;
		case 11:case 14:case 15:
			break;
		case 16:
			f(_g.e);
			f(_g.index);
			break;
		case 17:
			let _g8 = _g.el;
			let _g9 = 0;
			while(_g9 < _g8.length) {
				let e = _g8[_g9];
				++_g9;
				f(e);
			}
			break;
		case 18:
			let _g10 = _g.cases;
			let _g11 = _g.def;
			f(_g.e);
			let _g12 = 0;
			while(_g12 < _g10.length) {
				let c = _g10[_g12];
				++_g12;
				let _g = 0;
				let _g1 = c.values;
				while(_g < _g1.length) {
					let v = _g1[_g];
					++_g;
					f(v);
				}
				f(c.expr);
			}
			if(_g11 != null) {
				f(_g11);
			}
			break;
		case 19:
			f(_g.e);
			f(_g.loop);
			break;
		case 20:
			f(_g.e);
			break;
		}
	}
	static map(e,f) {
		let ed;
		let _g = e.e;
		switch(_g._hx_index) {
		case 0:
			ed = e.e;
			break;
		case 1:
			ed = e.e;
			break;
		case 2:
			ed = e.e;
			break;
		case 3:
			ed = hxsl_TExprDef.TParenthesis(f(_g.e));
			break;
		case 4:
			let _g1 = _g.el;
			let _g2 = [];
			let _g3 = 0;
			while(_g3 < _g1.length) {
				let e = _g1[_g3];
				++_g3;
				_g2.push(f(e));
			}
			ed = hxsl_TExprDef.TBlock(_g2);
			break;
		case 5:
			ed = hxsl_TExprDef.TBinop(_g.op,f(_g.e1),f(_g.e2));
			break;
		case 6:
			ed = hxsl_TExprDef.TUnop(_g.op,f(_g.e1));
			break;
		case 7:
			let _g4 = _g.init;
			ed = hxsl_TExprDef.TVarDecl(_g.v,_g4 != null ? f(_g4) : null);
			break;
		case 8:
			let _g5 = _g.args;
			let ed1 = f(_g.e);
			let _g6 = [];
			let _g7 = 0;
			while(_g7 < _g5.length) {
				let a = _g5[_g7];
				++_g7;
				_g6.push(f(a));
			}
			ed = hxsl_TExprDef.TCall(ed1,_g6);
			break;
		case 9:
			ed = hxsl_TExprDef.TSwiz(f(_g.e),_g.regs);
			break;
		case 10:
			let _g8 = _g.eelse;
			ed = hxsl_TExprDef.TIf(f(_g.econd),f(_g.eif),_g8 != null ? f(_g8) : null);
			break;
		case 12:
			let _g9 = _g.e;
			ed = hxsl_TExprDef.TReturn(_g9 != null ? f(_g9) : null);
			break;
		case 13:
			ed = hxsl_TExprDef.TFor(_g.v,f(_g.it),f(_g.loop));
			break;
		case 11:case 14:case 15:
			ed = e.e;
			break;
		case 16:
			ed = hxsl_TExprDef.TArray(f(_g.e),f(_g.index));
			break;
		case 17:
			let _g10 = _g.el;
			let _g11 = [];
			let _g12 = 0;
			while(_g12 < _g10.length) {
				let e = _g10[_g12];
				++_g12;
				_g11.push(f(e));
			}
			ed = hxsl_TExprDef.TArrayDecl(_g11);
			break;
		case 18:
			let _g13 = _g.cases;
			let _g14 = _g.def;
			let ed2 = f(_g.e);
			let _g15 = [];
			let _g16 = 0;
			while(_g16 < _g13.length) {
				let c = _g13[_g16];
				++_g16;
				let _g = [];
				let _g1 = 0;
				let _g2 = c.values;
				while(_g1 < _g2.length) {
					let v = _g2[_g1];
					++_g1;
					_g.push(f(v));
				}
				_g15.push({ values : _g, expr : f(c.expr)});
			}
			ed = hxsl_TExprDef.TSwitch(ed2,_g15,_g14 == null ? null : f(_g14));
			break;
		case 19:
			ed = hxsl_TExprDef.TWhile(f(_g.e),f(_g.loop),_g.normalWhile);
			break;
		case 20:
			ed = hxsl_TExprDef.TMeta(_g.m,_g.args,f(_g.e));
			break;
		}
		return { e : ed, t : e.t, p : e.p};
	}
	static size(t) {
		switch(t._hx_index) {
		case 0:
			return 0;
		case 1:case 3:
			return 1;
		case 5:
			return t.size;
		case 6:
			return 9;
		case 7:
			return 16;
		case 8:
			return 12;
		case 9:
			return t.size;
		case 2:case 4:case 10:case 11:case 12:
			return 0;
		case 13:
			let _g = t.vl;
			let s = 0;
			let _g1 = 0;
			while(_g1 < _g.length) {
				let v = _g[_g1];
				++_g1;
				s += hxsl_Tools.size(v.type);
			}
			return s;
		case 14:
			return 0;
		case 15:
			let _g2 = t.t;
			let _g3 = t.size;
			switch(_g3._hx_index) {
			case 0:
				return hxsl_Tools.size(_g2) * _g3.v;
			case 1:
				return 0;
			}
			break;
		case 16:
			let _g4 = t.size;
			if(_g4._hx_index == 0) {
				return hxsl_Tools.size(t.t) * _g4.v;
			} else {
				return 0;
			}
			break;
		case 17:
			return t.size;
		case 18:
			return 4;
		}
	}
}
$hxClasses["hxsl.Tools"] = hxsl_Tools;
hxsl_Tools.__name__ = "hxsl.Tools";
class hxsl_Tools2 {
	static toString(g) {
		let n = $hxEnums[g.__enum__].__constructs__[g._hx_index]._hx_name;
		return n.charAt(0).toLowerCase() + HxOverrides.substr(n,1,null);
	}
}
$hxClasses["hxsl.Tools2"] = hxsl_Tools2;
hxsl_Tools2.__name__ = "hxsl.Tools2";
class hxsl_BatchShader extends hxsl_Shader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.Batch_Count__ = 0;
		super._hx_constructor();
	}
	get_Batch_HasOffset() {
		return this.Batch_HasOffset__;
	}
	set_Batch_HasOffset(_v) {
		this.constModified = true;
		return this.Batch_HasOffset__ = _v;
	}
	get_Batch_Count() {
		return this.Batch_Count__;
	}
	set_Batch_Count(_v) {
		this.constModified = true;
		return this.Batch_Count__ = _v;
	}
	get_Batch_Buffer() {
		return this.Batch_Buffer__;
	}
	set_Batch_Buffer(_v) {
		return this.Batch_Buffer__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.Batch_HasOffset__) {
			this.constBits |= 1;
		}
		let v = this.Batch_Count__;
		if(v >>> 17 != 0) {
			throw haxe_Exception.thrown("Batch_Count" + " is out of range " + v + ">" + 131071);
		}
		this.constBits |= v << 1;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.Batch_HasOffset__;
		case 1:
			return this.Batch_Count__;
		case 2:
			return this.Batch_Buffer__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(hxsl_BatchShader.prototype);
		s.shader = this.shader;
		s.Batch_HasOffset__ = this.Batch_HasOffset__;
		s.Batch_Count__ = this.Batch_Count__;
		s.Batch_Buffer__ = this.Batch_Buffer__;
		return s;
	}
}
$hxClasses["hxsl.BatchShader"] = hxsl_BatchShader;
hxsl_BatchShader.__name__ = "hxsl.BatchShader";
hxsl_BatchShader.__super__ = hxsl_Shader;
Object.assign(hxsl_BatchShader.prototype, {
	__class__: hxsl_BatchShader
	,params: null
	,paramsSize: null
	,Batch_HasOffset__: null
	,Batch_Count__: null
	,Batch_Buffer__: null
});
class hxsl_BatchInstanceParams {
	constructor(forcedPerInstance) {
		this.forcedPerInstance = forcedPerInstance;
	}
	getSignature() {
		if(this.cachedSignature == null) {
			let _g = 0;
			let _g1 = this.forcedPerInstance;
			while(_g < _g1.length) {
				let fp = _g1[_g];
				++_g;
				fp.params.sort(Reflect.compare);
			}
			let _g2 = [];
			let _g3 = 0;
			let _g4 = this.forcedPerInstance;
			while(_g3 < _g4.length) {
				let s = _g4[_g3];
				++_g3;
				_g2.push(s.shader + "=" + s.params.join(","));
			}
			this.cachedSignature = HxOverrides.substr(haxe_crypto_Md5.encode(_g2.join(";")),0,8);
		}
		return this.cachedSignature;
	}
}
$hxClasses["hxsl.BatchInstanceParams"] = hxsl_BatchInstanceParams;
hxsl_BatchInstanceParams.__name__ = "hxsl.BatchInstanceParams";
Object.assign(hxsl_BatchInstanceParams.prototype, {
	__class__: hxsl_BatchInstanceParams
	,forcedPerInstance: null
	,cachedSignature: null
});
class hxsl_SearchMap {
	constructor() {
		this.minId = 0;
		this.nexts = [];
	}
	set(id,s) {
		if(this.minId == 0) {
			this.minId = id;
			this.nexts = [s];
			return;
		}
		let offset = id - this.minId;
		if(offset < 0) {
			let n = [];
			let _g = 0;
			let _g1 = this.nexts.length;
			while(_g < _g1) {
				let i = _g++;
				n[i - offset] = this.nexts[i];
			}
			this.nexts = n;
			this.minId += offset;
			offset = 0;
		}
		this.nexts[offset] = s;
	}
}
$hxClasses["hxsl.SearchMap"] = hxsl_SearchMap;
hxsl_SearchMap.__name__ = "hxsl.SearchMap";
Object.assign(hxsl_SearchMap.prototype, {
	__class__: hxsl_SearchMap
	,linked: null
	,nexts: null
	,minId: null
});
class hxsl_Cache {
	constructor() {
		this.constsToGlobal = false;
		this.linkCache = new hxsl_SearchMap();
		this.linkShaders = new haxe_ds_StringMap();
		this.batchShaders = new haxe_ds_ObjectMap();
		this.batchShadersParams = new haxe_ds_StringMap();
		this.byID = new haxe_ds_StringMap();
	}
	getLinkShader(vars) {
		let _g = [];
		let _g1 = 0;
		while(_g1 < vars.length) {
			let v = vars[_g1];
			++_g1;
			_g.push(Std.string(v));
		}
		let key = _g.join(",");
		let shader = this.linkShaders.h[key];
		if(shader != null) {
			return shader;
		}
		let s = new hxsl_SharedShader("");
		let id = HxOverrides.substr(haxe_crypto_Md5.encode(key),0,8);
		s.data = { name : "shaderLinker_" + id, vars : [], funs : []};
		let pos = null;
		let outVars_h = Object.create(null);
		let outputCount = 0;
		let tvec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat);
		let makeVec = function(g,size,args,makeOutExpr) {
			let out = [];
			let rem = size;
			let _g = 0;
			let _g1 = args.length;
			while(_g < _g1) {
				let i = _g++;
				let e = makeOutExpr(args[args.length - 1 - i],rem - (args.length - 1 - i));
				rem -= hxsl_Tools.size(e.t);
				out.unshift(e);
			}
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(g), t : hxsl_Type.TVoid, p : pos},out), t : hxsl_Type.TVec(size,hxsl_VecType.VFloat), p : pos};
		};
		let makeVar = function(name,t,parent) {
			let path = parent == null ? name : hxsl_Tools.getName(parent) + "." + name;
			let v = outVars_h[path];
			if(v != null) {
				return v;
			}
			v = { id : hxsl_Tools.allocVarId(), name : name, type : t, kind : hxsl_VarKind.Var, parent : parent};
			if(parent == null) {
				s.data.vars.push(v);
			} else {
				let _g = parent.type;
				if(_g._hx_index == 13) {
					_g.vl.push(v);
				} else {
					throw haxe_Exception.thrown("assert");
				}
			}
			outVars_h[path] = v;
			return v;
		};
		let makeOutExpr = null;
		makeOutExpr = function(v,rem) {
			switch(v._hx_index) {
			case 0:
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(v.v)), t : hxsl_Type.TFloat, p : pos};
			case 1:
				let _g = v.v;
				let _g1 = v.size;
				let v1 = outVars_h[_g];
				if(v1 != null) {
					return { e : hxsl_TExprDef.TVar(v1), t : v1.type, p : pos};
				}
				let path = _g.split(".");
				let parent = null;
				while(path.length > 1) parent = makeVar(path.shift(),hxsl_Type.TStruct([]),parent);
				if(_g1 != null) {
					rem = _g1;
				}
				v1 = makeVar(path.shift(),rem == 1 ? hxsl_Type.TFloat : hxsl_Type.TVec(rem,hxsl_VecType.VFloat),parent);
				return { e : hxsl_TExprDef.TVar(v1), t : v1.type, p : pos};
			case 2:
				return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.PackNormal), t : hxsl_Type.TVoid, p : pos},[makeOutExpr(v.v,3)]), t : tvec4, p : pos};
			case 3:
				return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Pack), t : hxsl_Type.TVoid, p : pos},[makeOutExpr(v.v,1)]), t : tvec4, p : pos};
			case 4:
				return makeVec(hxsl_TGlobal.Vec2,2,v.a,makeOutExpr);
			case 5:
				return makeVec(hxsl_TGlobal.Vec3,3,v.a,makeOutExpr);
			case 6:
				return makeVec(hxsl_TGlobal.Vec4,4,v.a,makeOutExpr);
			case 7:
				let _g2 = v.swiz;
				return { e : hxsl_TExprDef.TSwiz(makeOutExpr(v.a,4),_g2), t : hxsl_Type.TVec(_g2.length,hxsl_VecType.VFloat), p : pos};
			}
		};
		let makeOutput = function(v) {
			outputCount += 1;
			let ov = { id : hxsl_Tools.allocVarId(), type : tvec4, name : "OUTPUT" + (outputCount - 1), kind : hxsl_VarKind.Output};
			s.data.vars.push(ov);
			return { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(ov), t : tvec4, p : pos},makeOutExpr(v,4)), t : hxsl_Type.TVoid, p : pos};
		};
		let defineFun = function(kind,vars) {
			let fv = { id : hxsl_Tools.allocVarId(), type : hxsl_Type.TFun([]), name : ("" + Std.string(kind)).toLowerCase(), kind : hxsl_VarKind.Function};
			let _g = [];
			let _g1 = 0;
			while(_g1 < vars.length) {
				let v = vars[_g1];
				++_g1;
				_g.push(makeOutput(v));
			}
			let f = { kind : kind, ref : fv, args : [], ret : hxsl_Type.TVoid, expr : { e : hxsl_TExprDef.TBlock(_g), p : pos, t : hxsl_Type.TVoid}};
			s.data.funs.push(f);
		};
		defineFun(hxsl_FunctionKind.Vertex,[hxsl_Output.Value("output.position")]);
		defineFun(hxsl_FunctionKind.Fragment,vars);
		shader = Object.create(hxsl_Shader.prototype);
		shader.shader = s;
		this.linkShaders.h[key] = shader;
		shader.updateConstantsFinal(null);
		return shader;
	}
	link(shaders,batchMode) {
		let c = this.linkCache;
		let last = null;
		let _g_l = shaders;
		while(_g_l != last) {
			let s = _g_l.s;
			_g_l = _g_l.next;
			let i = s.instance;
			let cs = c.nexts[i.id - c.minId];
			if(cs == null) {
				cs = new hxsl_SearchMap();
				c.set(i.id,cs);
			}
			c = cs;
		}
		if(c.linked == null) {
			c.linked = this.compileRuntimeShader(shaders,batchMode);
		}
		return c.linked;
	}
	compileRuntimeShader(shaders,batchMode) {
		let shaderDatas = [];
		let index = 0;
		let last = null;
		let _g_l = shaders;
		while(_g_l != last) {
			let s = _g_l.s;
			_g_l = _g_l.next;
			let i = s.instance;
			shaderDatas.push({ inst : i, p : s.priority, index : index++});
		}
		shaderDatas.reverse();
		haxe_ds_ArraySort.sort(shaderDatas,function(s1,s2) {
			return s2.p - s1.p;
		});
		let _g = 0;
		while(_g < shaderDatas.length) {
			let s = shaderDatas[_g];
			++_g;
			hxsl_Printer.check(s.inst.shader);
		}
		let linker = new hxsl_Linker(batchMode);
		let s;
		try {
			let _g = [];
			let _g1 = 0;
			while(_g1 < shaderDatas.length) {
				let s = shaderDatas[_g1];
				++_g1;
				_g.push(s.inst.shader);
			}
			s = linker.link(_g);
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxsl_Error)) {
				let e = _g1;
				let _g = [];
				let _g2 = 0;
				while(_g2 < shaderDatas.length) {
					let s = shaderDatas[_g2];
					++_g2;
					_g.push(hxsl_Printer.shaderToString(s.inst.shader));
				}
				e.msg += "\n\nin\n\n" + _g.join("\n-----\n");
				throw haxe_Exception.thrown(e);
			} else {
				throw _g;
			}
		}
		if(batchMode) {
			let checkRec = null;
			checkRec = function(v) {
				if(v.qualifiers != null && v.qualifiers.indexOf(hxsl_VarQualifier.PerObject) >= 0) {
					if(v.qualifiers.length == 1) {
						v.qualifiers = null;
					} else {
						v.qualifiers = v.qualifiers.slice();
						HxOverrides.remove(v.qualifiers,hxsl_VarQualifier.PerObject);
					}
					if(v.kind != hxsl_VarKind.Var) {
						v.kind = hxsl_VarKind.Local;
					}
				}
				let _g = v.type;
				if(_g._hx_index == 13) {
					let _g1 = _g.vl;
					let _g2 = 0;
					while(_g2 < _g1.length) {
						let v = _g1[_g2];
						++_g2;
						checkRec(v);
					}
				}
			};
			let _g = 0;
			let _g1 = s.vars;
			while(_g < _g1.length) {
				let v = _g1[_g];
				++_g;
				checkRec(v);
			}
		}
		let _g1 = [];
		let _g2 = 0;
		while(_g2 < shaderDatas.length) {
			let s = shaderDatas[_g2];
			++_g2;
			_g1.push(s.inst.shader);
		}
		hxsl_Printer.check(s,_g1);
		let prev = s;
		let splitter = new hxsl_Splitter();
		let s1;
		try {
			s1 = splitter.split(s);
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(((_g1) instanceof hxsl_Error)) {
				let e = _g1;
				e.msg += "\n\nin\n\n" + hxsl_Printer.shaderToString(s);
				throw haxe_Exception.thrown(e);
			} else {
				throw _g;
			}
		}
		let paramVars = new haxe_ds_IntMap();
		let _g3 = 0;
		let _g4 = linker.allVars;
		while(_g3 < _g4.length) {
			let v = _g4[_g3];
			++_g3;
			if(v.v.kind == hxsl_VarKind.Param) {
				if(v.v.type._hx_index == 13) {
					continue;
				}
				let inf = shaderDatas[v.instanceIndex];
				let nv = splitter.varMap.h[v.v.__id__];
				paramVars.h[nv == null ? v.id : nv.id] = { instance : inf.index, index : inf.inst.params.h[v.merged[0].id]};
			}
		}
		hxsl_Printer.check(s1.vertex,[prev]);
		hxsl_Printer.check(s1.fragment,[prev]);
		let prev1 = s1;
		let s2 = new hxsl_Dce().dce(s1.vertex,s1.fragment);
		hxsl_Printer.check(s2.vertex,[prev1.vertex]);
		hxsl_Printer.check(s2.fragment,[prev1.fragment]);
		let r = this.buildRuntimeShader(s2.vertex,s2.fragment,paramVars);
		let _g5 = [];
		let last1 = null;
		let _g_l1 = shaders;
		while(_g_l1 != last1) {
			let s = _g_l1.s;
			_g_l1 = _g_l1.next;
			_g5.push(new hxsl_ShaderInstanceDesc(s.shader,s.constBits));
		}
		r.spec = { instances : _g5, signature : null};
		let _g6 = 0;
		let _g7 = shaderDatas.length;
		while(_g6 < _g7) {
			let i = _g6++;
			let s = shaderDatas[shaderDatas.length - 1 - i];
			r.spec.instances[s.index].index = i;
		}
		let _g8 = [];
		let _g9 = 0;
		let _g10 = r.spec.instances;
		while(_g9 < _g10.length) {
			let i = _g10[_g9];
			++_g9;
			_g8.push(i.shader.data.name + "_" + i.bits + "_" + i.index);
		}
		let tmp = _g8.join(":");
		r.spec.signature = haxe_crypto_Md5.encode(tmp);
		r.signature = haxe_crypto_Md5.encode(hxsl_Printer.shaderToString(r.vertex.data) + hxsl_Printer.shaderToString(r.fragment.data));
		r.batchMode = batchMode;
		let r2 = this.byID.h[r.signature];
		if(r2 != null) {
			r.id = r2.id;
		} else {
			this.byID.h[r.signature] = r;
		}
		return r;
	}
	buildRuntimeShader(vertex,fragment,paramVars) {
		let r = new hxsl_RuntimeShader();
		r.vertex = this.flattenShader(vertex,hxsl_FunctionKind.Vertex,paramVars);
		r.vertex.vertex = true;
		r.fragment = this.flattenShader(fragment,hxsl_FunctionKind.Fragment,paramVars);
		r.globals = new haxe_ds_IntMap();
		this.initGlobals(r,r.vertex);
		this.initGlobals(r,r.fragment);
		hxsl_Printer.check(r.vertex.data,[vertex]);
		hxsl_Printer.check(r.fragment.data,[fragment]);
		return r;
	}
	initGlobals(r,s) {
		let p = s.globals;
		while(p != null) {
			r.globals.h[p.gid] = true;
			p = p.next;
		}
		let p1 = s.params;
		while(p1 != null) {
			if(p1.perObjectGlobal != null) {
				r.globals.h[p1.perObjectGlobal.gid] = true;
			}
			p1 = p1.next;
		}
	}
	getPath(v) {
		if(v.parent == null) {
			return v.name;
		}
		return this.getPath(v.parent) + "." + v.name;
	}
	flattenShader(s,kind,params) {
		let flat = new hxsl_Flatten();
		let c = new hxsl_RuntimeShaderData();
		let data = flat.flatten(s,kind,this.constsToGlobal);
		let textures = [];
		c.consts = flat.consts;
		c.texturesCount = 0;
		let g = flat.allocData.keys();
		while(g.hasNext()) {
			let g1 = g.next();
			let alloc = flat.allocData.h[g1.__id__];
			switch(g1.kind._hx_index) {
			case 0:
				let _g = [];
				let _g1 = 0;
				while(_g1 < alloc.length) {
					let a = alloc[_g1];
					++_g1;
					if(a.v != null) {
						_g.push(new hxsl_AllocGlobal(a.pos,this.getPath(a.v),a.v.type));
					}
				}
				let _g2 = 0;
				let _g3 = _g.length - 1;
				while(_g2 < _g3) {
					let i = _g2++;
					_g[i].next = _g[i + 1];
				}
				let _g4 = g1.type;
				if(_g4._hx_index == 15) {
					let _g1 = _g4.t;
					let _g2 = _g4.size;
					if(_g1._hx_index == 5) {
						if(_g1.size == 4) {
							if(_g1.t._hx_index == 1) {
								if(_g2._hx_index == 0) {
									c.globals = _g[0];
									c.globalsSize = _g2.v;
								} else {
									throw haxe_Exception.thrown("assert");
								}
							} else {
								throw haxe_Exception.thrown("assert");
							}
						} else {
							throw haxe_Exception.thrown("assert");
						}
					} else {
						throw haxe_Exception.thrown("assert");
					}
				} else {
					throw haxe_Exception.thrown("assert");
				}
				break;
			case 2:
				let out = [];
				let count = 0;
				let _g5 = 0;
				while(_g5 < alloc.length) {
					let a = alloc[_g5];
					++_g5;
					if(a.v == null) {
						continue;
					}
					let p = params.h[a.v.id];
					if(p == null) {
						let ap = new hxsl_AllocParam(a.v.name,a.pos,-1,-1,a.v.type);
						ap.perObjectGlobal = new hxsl_AllocGlobal(-1,this.getPath(a.v),a.v.type);
						out.push(ap);
						++count;
						continue;
					}
					let ap = new hxsl_AllocParam(a.v.name,a.pos,p.instance,p.index,a.v.type);
					let _g = a.v.type;
					if(_g._hx_index == 15) {
						if(hxsl_Tools.isSampler(_g.t)) {
							ap.pos = -a.size;
							count += a.size;
						} else {
							++count;
						}
					} else {
						++count;
					}
					out.push(ap);
				}
				let _g6 = 0;
				let _g7 = out.length - 1;
				while(_g6 < _g7) {
					let i = _g6++;
					out[i].next = out[i + 1];
				}
				let _g8 = g1.type;
				if(_g8._hx_index == 15) {
					let _g = _g8.t;
					let _g1 = _g8.size;
					if(hxsl_Tools.isSampler(_g)) {
						textures.push({ t : _g, all : out});
						c.texturesCount += count;
					} else {
						switch(_g._hx_index) {
						case 5:
							if(_g.size == 4) {
								if(_g.t._hx_index == 1) {
									if(_g1._hx_index == 0) {
										c.params = out[0];
										c.paramsSize = _g1.v;
									} else {
										throw haxe_Exception.thrown("assert");
									}
								} else {
									throw haxe_Exception.thrown("assert");
								}
							} else {
								throw haxe_Exception.thrown("assert");
							}
							break;
						case 16:
							c.buffers = out[0];
							c.bufferCount = out.length;
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
					}
				} else {
					throw haxe_Exception.thrown("assert");
				}
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
		}
		if(textures.length > 0) {
			textures.sort(function(t1,t2) {
				return t1.t._hx_index - t2.t._hx_index;
			});
			c.textures = textures[0].all[0];
			let _g = 1;
			let _g1 = textures.length;
			while(_g < _g1) {
				let i = _g++;
				let prevAll = textures[i - 1].all;
				let prev = prevAll[prevAll.length - 1];
				prev.next = textures[i].all[0];
			}
		}
		if(c.globals == null) {
			c.globalsSize = 0;
		}
		if(c.params == null) {
			c.paramsSize = 0;
		}
		if(c.buffers == null) {
			c.bufferCount = 0;
		}
		c.data = data;
		return c;
	}
	makeBatchShader(rt,shaders,params) {
		let batchMap;
		if(params == null) {
			batchMap = this.batchShaders;
		} else {
			let this1 = this.batchShadersParams;
			let key = params.getSignature();
			batchMap = this1.h[key];
			if(batchMap == null) {
				batchMap = new haxe_ds_ObjectMap();
				let this1 = this.batchShadersParams;
				let key = params.getSignature();
				this1.h[key] = batchMap;
			}
		}
		let sh = batchMap.h[rt.__id__];
		if(sh == null) {
			sh = this.createBatchShader(rt,shaders,params);
			batchMap.set(rt,sh);
		}
		let shader = Object.create(hxsl_BatchShader.prototype);
		shader.shader = sh.shader;
		shader.params = sh.params;
		shader.paramsSize = sh.size;
		return shader;
	}
	isPerInstance(v) {
		if(v.qualifiers == null) {
			return false;
		}
		let _g = 0;
		let _g1 = v.qualifiers;
		while(_g < _g1.length) {
			let q = _g1[_g];
			++_g;
			let tmp;
			switch(q._hx_index) {
			case 3:
				tmp = true;
				break;
			case 9:
				tmp = true;
				break;
			default:
				tmp = false;
			}
			if(tmp) {
				return true;
			}
		}
		return false;
	}
	createBatchShader(rt,shaders,params) {
		let s = new hxsl_SharedShader("");
		let id = HxOverrides.substr(params == null ? rt.spec.signature : haxe_crypto_Md5.encode(rt.spec.signature + params.getSignature()),0,8);
		let declVar = function(name,t,kind) {
			return { id : hxsl_Tools.allocVarId(), type : t, name : name, kind : kind};
		};
		let instancedParams = [];
		if(params != null) {
			let forcedPerInstance = params.forcedPerInstance;
			let instanceIndex = 1;
			let forcedIndex = forcedPerInstance.length - 1;
			let s = shaders;
			while(s != null && forcedIndex >= 0) {
				if(s.s.shader.data.name == forcedPerInstance[forcedIndex].shader) {
					instancedParams[instanceIndex] = forcedPerInstance[forcedIndex].params;
					--forcedIndex;
				}
				++instanceIndex;
				s = s.next;
			}
		}
		let pos = null;
		let hasOffset = declVar("Batch_HasOffset",hxsl_Type.TBool,hxsl_VarKind.Param);
		let inputOffset = declVar("Batch_Start",hxsl_Type.TFloat,hxsl_VarKind.Input);
		hasOffset.qualifiers = [hxsl_VarQualifier.Const()];
		inputOffset.qualifiers = [hxsl_VarQualifier.PerInstance(1)];
		let vcount = declVar("Batch_Count",hxsl_Type.TInt,hxsl_VarKind.Param);
		let vbuffer = declVar("Batch_Buffer",hxsl_Type.TBuffer(hxsl_Type.TVec(4,hxsl_VecType.VFloat),hxsl_SizeDecl.SVar(vcount)),hxsl_VarKind.Param);
		let voffset = declVar("Batch_Offset",hxsl_Type.TInt,hxsl_VarKind.Local);
		let ebuffer = { e : hxsl_TExprDef.TVar(vbuffer), p : pos, t : vbuffer.type};
		let eoffset = { e : hxsl_TExprDef.TVar(voffset), p : pos, t : voffset.type};
		let tvec4 = hxsl_Type.TVec(4,hxsl_VecType.VFloat);
		vcount.qualifiers = [hxsl_VarQualifier.Const(65536)];
		s.data = { name : "batchShader_" + id, vars : [vcount,hasOffset,vbuffer,voffset,inputOffset], funs : []};
		let getVarRec = null;
		getVarRec = function(v,name,kind) {
			if(v.kind == kind && v.name == name) {
				return v;
			}
			let _g = v.type;
			if(_g._hx_index == 13) {
				let _g1 = _g.vl;
				let _g2 = 0;
				while(_g2 < _g1.length) {
					let v = _g1[_g2];
					++_g2;
					let v1 = getVarRec(v,name,kind);
					if(v1 != null) {
						return v1;
					}
				}
			}
			return null;
		};
		let getVar = function(p) {
			let s = shaders;
			if(p.perObjectGlobal != null) {
				let path = p.perObjectGlobal.path.split(".");
				while(s != null) {
					let _g = 0;
					let _g1 = s.s.shader.data.vars;
					while(_g < _g1.length) {
						let v = _g1[_g];
						++_g;
						if(v.name != path[0]) {
							continue;
						}
						let v1 = getVarRec(v,p.name,hxsl_VarKind.Global);
						if(v1 != null) {
							return v1;
						}
					}
					s = s.next;
				}
			} else {
				let i = p.instance - 1;
				while(i > 0) {
					--i;
					s = s.next;
				}
				let name = p.name;
				while(true) {
					let _g = 0;
					let _g1 = s.s.shader.data.vars;
					while(_g < _g1.length) {
						let v = _g1[_g];
						++_g;
						let v1 = getVarRec(v,name,hxsl_VarKind.Param);
						if(v1 != null) {
							return v1;
						}
					}
					let cc = HxOverrides.cca(name,name.length - 1);
					if(cc >= 48 && cc <= 57) {
						name = HxOverrides.substr(name,0,-1);
					} else {
						break;
					}
				}
			}
			throw haxe_Exception.thrown("Var not found " + p.name);
		};
		let params1 = null;
		let used = [];
		let addParam = function(p) {
			let size;
			let _g = p.type;
			switch(_g._hx_index) {
			case 3:
				size = 1;
				break;
			case 5:
				if(_g.t._hx_index == 1) {
					size = _g.size;
				} else {
					throw haxe_Exception.thrown("Unsupported batch var type " + Std.string(p.type));
				}
				break;
			case 7:
				size = 16;
				break;
			default:
				throw haxe_Exception.thrown("Unsupported batch var type " + Std.string(p.type));
			}
			let index;
			if(size >= 4) {
				index = used.length << 2;
				let _g = 0;
				let _g1 = size >> 2;
				while(_g < _g1) {
					++_g;
					used.push(15);
				}
			} else if(size == 1) {
				let best = -1;
				let _g = 0;
				let _g1 = used.length;
				while(_g < _g1) {
					let i = _g++;
					if(used[i] != 15 && (best < 0 || used[best] < used[i])) {
						best = i;
					}
				}
				if(best < 0) {
					best = used.length;
					used.push(0);
				}
				index = best << 2;
				let _g2 = 0;
				while(_g2 < 4) {
					let k = _g2++;
					let bit = 3 - k;
					if((used[best] & 1 << bit) == 0) {
						used[best] |= 1 << bit;
						index += bit;
						break;
					}
				}
			} else {
				let k = size == 2 ? 3 : 7;
				let best = -1;
				let _g = 0;
				let _g1 = used.length;
				while(_g < _g1) {
					let i = _g++;
					if((used[i] & k) == 0) {
						used[i] |= k;
						best = i;
						break;
					}
				}
				if(best < 0) {
					best = used.length;
					used.push(k);
				}
				index = best << 2;
			}
			let p2 = new hxsl_AllocParam(p.name,index,p.instance,p.index,p.type);
			p2.perObjectGlobal = p.perObjectGlobal;
			p2.next = params1;
			params1 = p2;
		};
		let p = rt.vertex.params;
		while(p != null) {
			let v = getVar(p);
			let params = instancedParams[p.instance];
			if(params != null && params.indexOf(v.name) >= 0 ? true : this.isPerInstance(v)) {
				addParam(p);
			}
			p = p.next;
		}
		let p1 = rt.fragment.params;
		while(p1 != null) {
			let v = getVar(p1);
			let params = instancedParams[p1.instance];
			if(params != null && params.indexOf(v.name) >= 0 ? true : this.isPerInstance(v)) {
				addParam(p1);
			}
			p1 = p1.next;
		}
		let parentVars = new haxe_ds_ObjectMap();
		let swiz = [[hxsl_Component.X],[hxsl_Component.Y],[hxsl_Component.Z],[hxsl_Component.W]];
		let readOffset = function(index) {
			return { e : hxsl_TExprDef.TArray(ebuffer,{ e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,eoffset,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos}), t : tvec4, p : pos};
		};
		let extractVar = function(v) {
			let vreal = declVar(v.name,v.type,hxsl_VarKind.Local);
			if(v.perObjectGlobal != null) {
				let path = v.perObjectGlobal.path.split(".");
				path.pop();
				let cur = vreal;
				while(path.length > 0) {
					path.join(".");
					let name = path.pop();
					let vp = parentVars.h[path.__id__];
					if(vp == null) {
						vp = declVar(name,hxsl_Type.TStruct([]),hxsl_VarKind.Local);
						parentVars.set(path,vp);
					}
					let _g = vp.type;
					if(_g._hx_index == 13) {
						_g.vl.push(cur);
					}
					cur.parent = vp;
					cur = vp;
				}
			}
			s.data.vars.push(vreal);
			let index = v.pos >> 2;
			let extract;
			let _g = v.type;
			switch(_g._hx_index) {
			case 3:
				extract = { p : pos, t : v.type, e : hxsl_TExprDef.TSwiz(readOffset(index),swiz[v.pos & 3])};
				break;
			case 5:
				let _g1 = _g.t;
				switch(_g.size) {
				case 2:
					if(_g1._hx_index == 1) {
						let swiz;
						switch(v.pos & 3) {
						case 0:
							swiz = [hxsl_Component.X,hxsl_Component.Y];
							break;
						case 1:
							swiz = [hxsl_Component.Y,hxsl_Component.Z];
							break;
						default:
							swiz = [hxsl_Component.Z,hxsl_Component.W];
						}
						extract = { p : pos, t : v.type, e : hxsl_TExprDef.TSwiz(readOffset(index),swiz)};
					} else {
						throw haxe_Exception.thrown("assert");
					}
					break;
				case 3:
					if(_g1._hx_index == 1) {
						extract = { p : pos, t : v.type, e : hxsl_TExprDef.TSwiz(readOffset(index),(v.pos & 3) == 0 ? [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z] : [hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W])};
					} else {
						throw haxe_Exception.thrown("assert");
					}
					break;
				case 4:
					if(_g1._hx_index == 1) {
						extract = readOffset(index);
					} else {
						throw haxe_Exception.thrown("assert");
					}
					break;
				default:
					throw haxe_Exception.thrown("assert");
				}
				break;
			case 7:
				extract = { p : pos, t : v.type, e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4), t : hxsl_Type.TVoid, p : pos},[readOffset(index),readOffset(index + 1),readOffset(index + 2),readOffset(index + 3)])};
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			return { p : pos, e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(vreal), p : pos, t : v.type},extract), t : hxsl_Type.TVoid};
		};
		let exprs = [];
		let stride = used.length;
		let p2 = params1;
		while(p2 != null) {
			exprs.push(extractVar(p2));
			p2 = p2.next;
		}
		let inits = [];
		inits.push({ p : pos, e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,eoffset,{ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.InstanceID), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVoid});
		inits.push({ p : pos, e : hxsl_TExprDef.TIf({ e : hxsl_TExprDef.TVar(hasOffset), t : hxsl_Type.TBool, p : pos},{ p : pos, e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpAdd),eoffset,{ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToInt), t : hxsl_Type.TVoid, p : pos},[{ p : pos, t : hxsl_Type.TFloat, e : hxsl_TExprDef.TVar(inputOffset)}]), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVoid},null), t : hxsl_Type.TVoid});
		inits.push({ p : pos, t : hxsl_Type.TInt, e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssignOp(haxe_macro_Binop.OpMult),eoffset,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(stride)), t : hxsl_Type.TInt, p : pos})});
		let fv = declVar("init",hxsl_Type.TFun([]),hxsl_VarKind.Function);
		let f = { kind : hxsl_FunctionKind.Init, ref : fv, args : [], ret : hxsl_Type.TVoid, expr : { e : hxsl_TExprDef.TBlock(inits.concat(exprs)), p : pos, t : hxsl_Type.TVoid}};
		s.data.funs.push(f);
		s.consts = new hxsl_ShaderConst(vcount,1,17);
		s.consts.globalId = 0;
		s.consts.next = new hxsl_ShaderConst(hasOffset,0,1);
		s.consts.next.globalId = 0;
		return { shader : s, params : params1, size : stride};
	}
	static get() {
		let c = hxsl_Cache.INST;
		if(c == null) {
			c = new hxsl_Cache();
			hxsl_Cache.INST = c;
		}
		return c;
	}
}
$hxClasses["hxsl.Cache"] = hxsl_Cache;
hxsl_Cache.__name__ = "hxsl.Cache";
Object.assign(hxsl_Cache.prototype, {
	__class__: hxsl_Cache
	,linkCache: null
	,linkShaders: null
	,batchShaders: null
	,byID: null
	,batchShadersParams: null
	,constsToGlobal: null
});
var hxsl_Channel = $hxEnums["hxsl.Channel"] = { __ename__:true,__constructs__:null
	,Unknown: {_hx_name:"Unknown",_hx_index:0,__enum__:"hxsl.Channel",toString:$estr}
	,R: {_hx_name:"R",_hx_index:1,__enum__:"hxsl.Channel",toString:$estr}
	,G: {_hx_name:"G",_hx_index:2,__enum__:"hxsl.Channel",toString:$estr}
	,B: {_hx_name:"B",_hx_index:3,__enum__:"hxsl.Channel",toString:$estr}
	,A: {_hx_name:"A",_hx_index:4,__enum__:"hxsl.Channel",toString:$estr}
	,PackedFloat: {_hx_name:"PackedFloat",_hx_index:5,__enum__:"hxsl.Channel",toString:$estr}
	,PackedNormal: {_hx_name:"PackedNormal",_hx_index:6,__enum__:"hxsl.Channel",toString:$estr}
};
hxsl_Channel.__constructs__ = [hxsl_Channel.Unknown,hxsl_Channel.R,hxsl_Channel.G,hxsl_Channel.B,hxsl_Channel.A,hxsl_Channel.PackedFloat,hxsl_Channel.PackedNormal];
hxsl_Channel.__empty_constructs__ = [hxsl_Channel.Unknown,hxsl_Channel.R,hxsl_Channel.G,hxsl_Channel.B,hxsl_Channel.A,hxsl_Channel.PackedFloat,hxsl_Channel.PackedNormal];
class hxsl_Clone {
	constructor() {
		this.varMap = new haxe_ds_IntMap();
	}
	tvar(v) {
		let v2 = this.varMap.h[v.id];
		if(v2 != null) {
			return v2;
		}
		v2 = { id : hxsl_Tools.allocVarId(), type : v.type, name : v.name, kind : v.kind};
		this.varMap.h[v.id] = v2;
		if(v.parent != null) {
			v2.parent = this.tvar(v.parent);
		}
		if(v.qualifiers != null) {
			v2.qualifiers = v.qualifiers.slice();
		}
		v2.type = this.ttype(v.type);
		return v2;
	}
	tfun(f) {
		let tmp = this.ttype(f.ret);
		let f1 = f.kind;
		let tmp1 = this.tvar(f.ref);
		let _g = [];
		let _g1 = 0;
		let _g2 = f.args;
		while(_g1 < _g2.length) {
			let a = _g2[_g1];
			++_g1;
			_g.push(this.tvar(a));
		}
		return { ret : tmp, kind : f1, ref : tmp1, args : _g, expr : this.texpr(f.expr)};
	}
	ttype(t) {
		switch(t._hx_index) {
		case 13:
			let _g = t.vl;
			let _g1 = [];
			let _g2 = 0;
			while(_g2 < _g.length) {
				let v = _g[_g2];
				++_g2;
				_g1.push(this.tvar(v));
			}
			return hxsl_Type.TStruct(_g1);
		case 14:
			return hxsl_Type.TFun(t.variants);
		case 15:
			let _g3 = t.size;
			let tmp = this.ttype(t.t);
			let tmp1;
			switch(_g3._hx_index) {
			case 0:
				tmp1 = _g3;
				break;
			case 1:
				tmp1 = hxsl_SizeDecl.SVar(this.tvar(_g3.v));
				break;
			}
			return hxsl_Type.TArray(tmp,tmp1);
		default:
			return t;
		}
	}
	texpr(e) {
		let e2 = hxsl_Tools.map(e,$bind(this,this.texpr));
		e2.t = this.ttype(e.t);
		let _g = e2.e;
		let tmp;
		switch(_g._hx_index) {
		case 1:
			tmp = hxsl_TExprDef.TVar(this.tvar(_g.v));
			break;
		case 7:
			tmp = hxsl_TExprDef.TVarDecl(this.tvar(_g.v),_g.init);
			break;
		case 13:
			tmp = hxsl_TExprDef.TFor(this.tvar(_g.v),_g.it,_g.loop);
			break;
		default:
			tmp = e2.e;
		}
		e2.e = tmp;
		return e2;
	}
	shader(s) {
		let s1 = s.name;
		let _g = [];
		let _g1 = 0;
		let _g2 = s.vars;
		while(_g1 < _g2.length) {
			let v = _g2[_g1];
			++_g1;
			_g.push(this.tvar(v));
		}
		let _g3 = [];
		let _g4 = 0;
		let _g5 = s.funs;
		while(_g4 < _g5.length) {
			let f = _g5[_g4];
			++_g4;
			_g3.push(this.tfun(f));
		}
		return { name : s1, vars : _g, funs : _g3};
	}
	static shaderData(s) {
		return new hxsl_Clone().shader(s);
	}
}
$hxClasses["hxsl.Clone"] = hxsl_Clone;
hxsl_Clone.__name__ = "hxsl.Clone";
Object.assign(hxsl_Clone.prototype, {
	__class__: hxsl_Clone
	,varMap: null
});
class hxsl__$Dce_VarDeps {
	constructor(v) {
		this.v = v;
		this.used = false;
		this.deps = new haxe_ds_IntMap();
	}
}
$hxClasses["hxsl._Dce.VarDeps"] = hxsl__$Dce_VarDeps;
hxsl__$Dce_VarDeps.__name__ = "hxsl._Dce.VarDeps";
Object.assign(hxsl__$Dce_VarDeps.prototype, {
	__class__: hxsl__$Dce_VarDeps
	,v: null
	,keep: null
	,used: null
	,deps: null
});
class hxsl_Dce {
	constructor() {
	}
	dce(vertex,fragment) {
		this.used = new haxe_ds_IntMap();
		this.channelVars = [];
		let inputs = [];
		let _g = 0;
		let _g1 = vertex.vars;
		while(_g < _g1.length) {
			let v = _g1[_g];
			++_g;
			let i = this.get(v);
			if(v.kind == hxsl_VarKind.Input) {
				inputs.push(i);
			}
			if(v.kind == hxsl_VarKind.Output) {
				i.keep = true;
			}
		}
		let _g2 = 0;
		let _g3 = fragment.vars;
		while(_g2 < _g3.length) {
			let v = _g3[_g2];
			++_g2;
			let i = this.get(v);
			if(v.kind == hxsl_VarKind.Output) {
				i.keep = true;
			}
		}
		let _g4 = 0;
		let _g5 = vertex.funs;
		while(_g4 < _g5.length) {
			let f = _g5[_g4];
			++_g4;
			this.check(f.expr,[],[]);
		}
		let _g6 = 0;
		let _g7 = fragment.funs;
		while(_g6 < _g7.length) {
			let f = _g7[_g6];
			++_g6;
			this.check(f.expr,[],[]);
		}
		let outExprs = [];
		do {
			let v = this.used.iterator();
			while(v.hasNext()) {
				let v1 = v.next();
				if(v1.keep) {
					this.markRec(v1);
				}
			}
			while(inputs.length > 1 && !inputs[inputs.length - 1].used) inputs.pop();
			let _g = 0;
			while(_g < inputs.length) {
				let v = inputs[_g];
				++_g;
				this.markRec(v);
			}
			outExprs = [];
			let _g1 = 0;
			let _g2 = vertex.funs;
			while(_g1 < _g2.length) {
				let f = _g2[_g1];
				++_g1;
				outExprs.push(this.mapExpr(f.expr,false));
			}
			let _g3 = 0;
			let _g4 = fragment.funs;
			while(_g3 < _g4.length) {
				let f = _g4[_g3];
				++_g3;
				outExprs.push(this.mapExpr(f.expr,false));
			}
			this.markAsKeep = false;
			let _g5 = 0;
			while(_g5 < outExprs.length) {
				let e = outExprs[_g5];
				++_g5;
				this.checkBranches(e);
			}
		} while(this.markAsKeep);
		let _g8 = 0;
		let _g9 = vertex.funs;
		while(_g8 < _g9.length) {
			let f = _g9[_g8];
			++_g8;
			f.expr = outExprs.shift();
		}
		let _g10 = 0;
		let _g11 = fragment.funs;
		while(_g10 < _g11.length) {
			let f = _g11[_g10];
			++_g10;
			f.expr = outExprs.shift();
		}
		let v = this.used.iterator();
		while(v.hasNext()) {
			let v1 = v.next();
			if(v1.used) {
				continue;
			}
			if(v1.v.kind == hxsl_VarKind.Input) {
				continue;
			}
			HxOverrides.remove(vertex.vars,v1.v);
			HxOverrides.remove(fragment.vars,v1.v);
		}
		return { fragment : fragment, vertex : vertex};
	}
	get(v) {
		let vd = this.used.h[v.id];
		if(vd == null) {
			vd = new hxsl__$Dce_VarDeps(v);
			this.used.h[v.id] = vd;
		}
		return vd;
	}
	markRec(v) {
		if(v.used) {
			return;
		}
		v.used = true;
		let d = v.deps.iterator();
		while(d.hasNext()) {
			let d1 = d.next();
			this.markRec(d1);
		}
	}
	link(v,writeTo) {
		let vd = this.get(v);
		let _g = 0;
		while(_g < writeTo.length) {
			let w = writeTo[_g];
			++_g;
			if(w == null) {
				if(!vd.keep) {
					vd.keep = true;
					this.markAsKeep = true;
				}
				continue;
			}
			w.deps.h[v.id] = vd;
		}
	}
	check(e,writeTo,isAffected) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 1:
			this.link(_g.v,writeTo);
			break;
		case 4:
			let _g1 = _g.el;
			let noWrite = [];
			let _g2 = 0;
			let _g3 = _g1.length;
			while(_g2 < _g3) {
				let i = _g2++;
				this.check(_g1[i],i < _g1.length - 1 ? noWrite : writeTo,isAffected);
			}
			break;
		case 5:
			let _g4 = _g.e1;
			let _g5 = _g.e2;
			switch(_g.op._hx_index) {
			case 4:
				let _g6 = _g4.e;
				switch(_g6._hx_index) {
				case 1:
					let v = this.get(_g6.v);
					writeTo.push(v);
					this.check(_g5,writeTo,isAffected);
					writeTo.pop();
					if(isAffected.indexOf(v) < 0) {
						isAffected.push(v);
					}
					break;
				case 9:
					let _g7 = _g6.e.e;
					if(_g7._hx_index == 1) {
						let v = this.get(_g7.v);
						writeTo.push(v);
						this.check(_g5,writeTo,isAffected);
						writeTo.pop();
						if(isAffected.indexOf(v) < 0) {
							isAffected.push(v);
						}
					} else {
						let _g = this;
						let writeTo1 = writeTo;
						let isAffected1 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g.check(e,writeTo1,isAffected1);
						});
					}
					break;
				case 16:
					let _g8 = _g6.e.e;
					if(_g8._hx_index == 1) {
						let v = this.get(_g8.v);
						writeTo.push(v);
						this.check(_g6.index,writeTo,isAffected);
						this.check(_g5,writeTo,isAffected);
						writeTo.pop();
						if(isAffected.indexOf(v) < 0) {
							isAffected.push(v);
						}
					} else {
						let _g = this;
						let writeTo1 = writeTo;
						let isAffected1 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g.check(e,writeTo1,isAffected1);
						});
					}
					break;
				default:
					let _g9 = this;
					let writeTo1 = writeTo;
					let isAffected1 = isAffected;
					hxsl_Tools.iter(e,function(e) {
						_g9.check(e,writeTo1,isAffected1);
					});
				}
				break;
			case 20:
				let _g10 = _g4.e;
				switch(_g10._hx_index) {
				case 1:
					let v1 = this.get(_g10.v);
					writeTo.push(v1);
					this.check(_g5,writeTo,isAffected);
					writeTo.pop();
					if(isAffected.indexOf(v1) < 0) {
						isAffected.push(v1);
					}
					break;
				case 9:
					let _g11 = _g10.e.e;
					if(_g11._hx_index == 1) {
						let v = this.get(_g11.v);
						writeTo.push(v);
						this.check(_g5,writeTo,isAffected);
						writeTo.pop();
						if(isAffected.indexOf(v) < 0) {
							isAffected.push(v);
						}
					} else {
						let _g = this;
						let writeTo1 = writeTo;
						let isAffected1 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g.check(e,writeTo1,isAffected1);
						});
					}
					break;
				case 16:
					let _g12 = _g10.e.e;
					if(_g12._hx_index == 1) {
						let v = this.get(_g12.v);
						writeTo.push(v);
						this.check(_g10.index,writeTo,isAffected);
						this.check(_g5,writeTo,isAffected);
						writeTo.pop();
						if(isAffected.indexOf(v) < 0) {
							isAffected.push(v);
						}
					} else {
						let _g = this;
						let writeTo1 = writeTo;
						let isAffected1 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g.check(e,writeTo1,isAffected1);
						});
					}
					break;
				default:
					let _g13 = this;
					let writeTo2 = writeTo;
					let isAffected2 = isAffected;
					hxsl_Tools.iter(e,function(e) {
						_g13.check(e,writeTo2,isAffected2);
					});
				}
				break;
			default:
				let _g14 = this;
				let writeTo3 = writeTo;
				let isAffected3 = isAffected;
				hxsl_Tools.iter(e,function(e) {
					_g14.check(e,writeTo3,isAffected3);
				});
			}
			break;
		case 7:
			let _g15 = _g.init;
			if(_g15 != null) {
				writeTo.push(this.get(_g.v));
				this.check(_g15,writeTo,isAffected);
				writeTo.pop();
			} else {
				let _g = this;
				let writeTo1 = writeTo;
				let isAffected1 = isAffected;
				hxsl_Tools.iter(e,function(e) {
					_g.check(e,writeTo1,isAffected1);
				});
			}
			break;
		case 8:
			let _g16 = _g.args;
			let _g17 = _g.e.e;
			if(_g17._hx_index == 2) {
				switch(_g17.g._hx_index) {
				case 63:
					if(_g16.length == 3) {
						let _g = _g16[0].e;
						if(_g._hx_index == 1) {
							let _g1 = _g.v;
							let _g2 = _g16[2].e;
							if(_g2._hx_index == 0) {
								let _g = _g2.c;
								if(_g._hx_index == 2) {
									let _g2 = _g.v;
									this.check(_g16[1],writeTo,isAffected);
									if(this.channelVars[_g2] == null) {
										this.channelVars[_g2] = _g1;
										this.link(_g1,writeTo);
									} else {
										this.link(this.channelVars[_g2],writeTo);
									}
								} else {
									let _g = this;
									let writeTo1 = writeTo;
									let isAffected1 = isAffected;
									hxsl_Tools.iter(e,function(e) {
										_g.check(e,writeTo1,isAffected1);
									});
								}
							} else {
								let _g = this;
								let writeTo1 = writeTo;
								let isAffected1 = isAffected;
								hxsl_Tools.iter(e,function(e) {
									_g.check(e,writeTo1,isAffected1);
								});
							}
						} else {
							let _g = this;
							let writeTo1 = writeTo;
							let isAffected1 = isAffected;
							hxsl_Tools.iter(e,function(e) {
								_g.check(e,writeTo1,isAffected1);
							});
						}
					} else {
						let _g = this;
						let writeTo1 = writeTo;
						let isAffected1 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g.check(e,writeTo1,isAffected1);
						});
					}
					break;
				case 64:
					if(_g16.length == 4) {
						let _g = _g16[2];
						let _g1 = _g16[0].e;
						if(_g1._hx_index == 1) {
							let _g2 = _g1.v;
							let _g3 = _g16[3].e;
							if(_g3._hx_index == 0) {
								let _g1 = _g3.c;
								if(_g1._hx_index == 2) {
									let _g3 = _g1.v;
									this.check(_g16[1],writeTo,isAffected);
									this.check(_g,writeTo,isAffected);
									if(this.channelVars[_g3] == null) {
										this.channelVars[_g3] = _g2;
										this.link(_g2,writeTo);
									} else {
										this.link(this.channelVars[_g3],writeTo);
									}
								} else {
									let _g = this;
									let writeTo1 = writeTo;
									let isAffected1 = isAffected;
									hxsl_Tools.iter(e,function(e) {
										_g.check(e,writeTo1,isAffected1);
									});
								}
							} else {
								let _g = this;
								let writeTo1 = writeTo;
								let isAffected1 = isAffected;
								hxsl_Tools.iter(e,function(e) {
									_g.check(e,writeTo1,isAffected1);
								});
							}
						} else {
							let _g = this;
							let writeTo1 = writeTo;
							let isAffected1 = isAffected;
							hxsl_Tools.iter(e,function(e) {
								_g.check(e,writeTo1,isAffected1);
							});
						}
					} else {
						let _g = this;
						let writeTo1 = writeTo;
						let isAffected1 = isAffected;
						hxsl_Tools.iter(e,function(e) {
							_g.check(e,writeTo1,isAffected1);
						});
					}
					break;
				default:
					let _g18 = this;
					let writeTo4 = writeTo;
					let isAffected4 = isAffected;
					hxsl_Tools.iter(e,function(e) {
						_g18.check(e,writeTo4,isAffected4);
					});
				}
			} else {
				let _g = this;
				let writeTo1 = writeTo;
				let isAffected1 = isAffected;
				hxsl_Tools.iter(e,function(e) {
					_g.check(e,writeTo1,isAffected1);
				});
			}
			break;
		case 10:
			let _g19 = _g.econd;
			let _g20 = _g.eelse;
			let affect = [];
			this.check(_g.eif,writeTo,affect);
			if(_g20 != null) {
				this.check(_g20,writeTo,affect);
			}
			let len = affect.length;
			let _g21 = 0;
			while(_g21 < writeTo.length) {
				let v = writeTo[_g21];
				++_g21;
				if(affect.indexOf(v) < 0) {
					affect.push(v);
				}
			}
			this.check(_g19,affect,isAffected);
			let _g22 = 0;
			while(_g22 < len) {
				let i = _g22++;
				let v = affect[i];
				if(isAffected.indexOf(v) < 0) {
					isAffected.push(v);
				}
			}
			break;
		case 13:
			let affect1 = [];
			this.check(_g.loop,writeTo,affect1);
			this.check(_g.it,affect1,isAffected);
			let _g23 = 0;
			while(_g23 < affect1.length) {
				let v = affect1[_g23];
				++_g23;
				if(isAffected.indexOf(v) < 0) {
					isAffected.push(v);
				}
			}
			break;
		default:
			let _g24 = this;
			let writeTo5 = writeTo;
			let isAffected5 = isAffected;
			hxsl_Tools.iter(e,function(e) {
				_g24.check(e,writeTo5,isAffected5);
			});
		}
	}
	checkBranches(e) {
		let _g = e.e;
		if(_g._hx_index == 10) {
			let writeTo = [null];
			this.check(_g.econd,writeTo,[]);
		}
		hxsl_Tools.iter(e,$bind(this,this.checkBranches));
	}
	mapExpr(e,isVar) {
		let _gthis = this;
		let _g = e.e;
		switch(_g._hx_index) {
		case 4:
			let _g1 = _g.el;
			let out = [];
			let count = 0;
			let _g2 = 0;
			while(_g2 < _g1.length) {
				let e = _g1[_g2];
				++_g2;
				let isVar1 = isVar && count == _g1.length - 1;
				let e1 = this.mapExpr(e,isVar1);
				if(hxsl_Tools.hasSideEffect(e1) || isVar1) {
					out.push(e1);
				}
				++count;
			}
			return { e : hxsl_TExprDef.TBlock(out), p : e.p, t : e.t};
		case 5:
			let _g3 = _g.e1;
			switch(_g.op._hx_index) {
			case 4:
				let _g4 = _g3.e;
				switch(_g4._hx_index) {
				case 1:
					if(!this.get(_g4.v).used) {
						return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 9:
					let _g5 = _g4.e.e;
					if(_g5._hx_index == 1) {
						if(!this.get(_g5.v).used) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 16:
					let _g6 = _g4.e.e;
					if(_g6._hx_index == 1) {
						if(!this.get(_g6.v).used) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				default:
					return hxsl_Tools.map(e,function(e) {
						return _gthis.mapExpr(e,true);
					});
				}
				break;
			case 20:
				let _g7 = _g3.e;
				switch(_g7._hx_index) {
				case 1:
					if(!this.get(_g7.v).used) {
						return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 9:
					let _g8 = _g7.e.e;
					if(_g8._hx_index == 1) {
						if(!this.get(_g8.v).used) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 16:
					let _g9 = _g7.e.e;
					if(_g9._hx_index == 1) {
						if(!this.get(_g9.v).used) {
							return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				default:
					return hxsl_Tools.map(e,function(e) {
						return _gthis.mapExpr(e,true);
					});
				}
				break;
			default:
				return hxsl_Tools.map(e,function(e) {
					return _gthis.mapExpr(e,true);
				});
			}
			break;
		case 7:
			if(!this.get(_g.v).used) {
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
			} else {
				return hxsl_Tools.map(e,function(e) {
					return _gthis.mapExpr(e,true);
				});
			}
			break;
		case 8:
			let _g10 = _g.args;
			let _g11 = _g.e.e;
			if(_g11._hx_index == 2) {
				switch(_g11.g._hx_index) {
				case 63:
					if(_g10.length == 3) {
						let _g = _g10[2].e;
						if(_g._hx_index == 0) {
							let _g1 = _g.c;
							if(_g1._hx_index == 2) {
								let c = this.channelVars[_g1.v];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texture), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(_g10[1],true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 64:
					if(_g10.length == 4) {
						let _g = _g10[2];
						let _g1 = _g10[3].e;
						if(_g1._hx_index == 0) {
							let _g2 = _g1.c;
							if(_g2._hx_index == 2) {
								let c = this.channelVars[_g2.v];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureLod), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(_g10[1],true),this.mapExpr(_g,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
					} else {
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 65:
					switch(_g10.length) {
					case 3:
						let _g12 = _g10[2].e;
						if(_g12._hx_index == 0) {
							let _g = _g12.c;
							if(_g._hx_index == 2) {
								let c = this.channelVars[_g.v];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(_g10[1],true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					case 4:
						let _g13 = _g10[2];
						let _g14 = _g10[3].e;
						if(_g14._hx_index == 0) {
							let _g = _g14.c;
							if(_g._hx_index == 2) {
								let c = this.channelVars[_g.v];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Texel), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(_g10[1],true),this.mapExpr(_g13,true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					default:
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				case 66:
					switch(_g10.length) {
					case 2:
						let _g15 = _g10[1].e;
						if(_g15._hx_index == 0) {
							let _g = _g15.c;
							if(_g._hx_index == 2) {
								let c = this.channelVars[_g.v];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureSize), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p}]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					case 3:
						let _g16 = _g10[2].e;
						if(_g16._hx_index == 0) {
							let _g = _g16.c;
							if(_g._hx_index == 2) {
								let c = this.channelVars[_g.v];
								return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.TextureSize), p : e.p, t : hxsl_Type.TVoid},[{ e : hxsl_TExprDef.TVar(c), t : c.type, p : e.p},this.mapExpr(_g10[1],true)]), t : hxsl_Type.TVoid, p : e.p};
							} else {
								return hxsl_Tools.map(e,function(e) {
									return _gthis.mapExpr(e,true);
								});
							}
						} else {
							return hxsl_Tools.map(e,function(e) {
								return _gthis.mapExpr(e,true);
							});
						}
						break;
					default:
						return hxsl_Tools.map(e,function(e) {
							return _gthis.mapExpr(e,true);
						});
					}
					break;
				default:
					return hxsl_Tools.map(e,function(e) {
						return _gthis.mapExpr(e,true);
					});
				}
			} else {
				return hxsl_Tools.map(e,function(e) {
					return _gthis.mapExpr(e,true);
				});
			}
			break;
		case 10:
			let _g17 = _g.eelse;
			let e1 = this.mapExpr(_g.econd,true);
			let econd = this.mapExpr(_g.eif,isVar);
			let eelse = _g17 == null ? null : this.mapExpr(_g17,isVar);
			if(!isVar && !hxsl_Tools.hasSideEffect(econd) && (eelse == null || !hxsl_Tools.hasSideEffect(eelse))) {
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e1.t, p : e1.p};
			}
			return { e : hxsl_TExprDef.TIf(e1,econd,eelse), p : e1.p, t : e1.t};
		case 13:
			let it = this.mapExpr(_g.it,true);
			let loop = this.mapExpr(_g.loop,false);
			if(!hxsl_Tools.hasSideEffect(loop)) {
				return { e : hxsl_TExprDef.TConst(hxsl_Const.CNull), t : e.t, p : e.p};
			}
			return { e : hxsl_TExprDef.TFor(_g.v,it,loop), p : e.p, t : e.t};
		default:
			return hxsl_Tools.map(e,function(e) {
				return _gthis.mapExpr(e,true);
			});
		}
	}
}
$hxClasses["hxsl.Dce"] = hxsl_Dce;
hxsl_Dce.__name__ = "hxsl.Dce";
Object.assign(hxsl_Dce.prototype, {
	__class__: hxsl_Dce
	,used: null
	,channelVars: null
	,markAsKeep: null
});
class hxsl_Eval {
	constructor() {
		this.varMap = new haxe_ds_ObjectMap();
		this.funMap = new haxe_ds_ObjectMap();
		this.constants = new haxe_ds_IntMap();
	}
	setConstant(v,c) {
		this.constants.h[v.id] = hxsl_TExprDef.TConst(c);
	}
	mapVar(v) {
		let v2 = this.varMap.h[v.__id__];
		if(v2 != null) {
			if(v == v2) {
				return v2;
			} else {
				return this.mapVar(v2);
			}
		}
		if(v.parent != null) {
			this.mapVar(v.parent);
			v2 = this.varMap.h[v.__id__];
			if(v2 != null) {
				if(v == v2) {
					return v2;
				} else {
					return this.mapVar(v2);
				}
			}
		}
		v2 = { id : v.type._hx_index == 17 ? v.id : hxsl_Tools.allocVarId(), name : v.name, type : v.type, kind : v.kind};
		if(v.parent != null) {
			v2.parent = this.mapVar(v.parent);
		}
		if(v.qualifiers != null) {
			v2.qualifiers = v.qualifiers.slice();
		}
		this.varMap.set(v,v2);
		this.varMap.set(v2,v2);
		let _g = v2.type;
		switch(_g._hx_index) {
		case 13:
			let _g1 = _g.vl;
			let _g2 = [];
			let _g3 = 0;
			while(_g3 < _g1.length) {
				let v = _g1[_g3];
				++_g3;
				_g2.push(this.mapVar(v));
			}
			v2.type = hxsl_Type.TStruct(_g2);
			break;
		case 15:
			let _g4 = _g.t;
			let _g5 = _g.size;
			if(_g5._hx_index == 1) {
				let _g = _g5.v;
				let c = this.constants.h[_g.id];
				if(c != null) {
					if(c == null) {
						hxsl_Error.t("Integer value expected for array size constant " + _g.name,null);
					} else if(c._hx_index == 0) {
						let _g1 = c.c;
						if(_g1._hx_index == 2) {
							let _g = _g1.v;
							v2.type = v2.type._hx_index == 15 ? hxsl_Type.TArray(_g4,hxsl_SizeDecl.SConst(_g)) : hxsl_Type.TBuffer(_g4,hxsl_SizeDecl.SConst(_g));
						} else {
							hxsl_Error.t("Integer value expected for array size constant " + _g.name,null);
						}
					} else {
						hxsl_Error.t("Integer value expected for array size constant " + _g.name,null);
					}
				} else {
					let vs2 = this.mapVar(_g);
					v2.type = v2.type._hx_index == 15 ? hxsl_Type.TArray(_g4,hxsl_SizeDecl.SVar(vs2)) : hxsl_Type.TBuffer(_g4,hxsl_SizeDecl.SVar(vs2));
				}
			}
			break;
		case 16:
			let _g6 = _g.t;
			let _g7 = _g.size;
			if(_g7._hx_index == 1) {
				let _g = _g7.v;
				let c = this.constants.h[_g.id];
				if(c != null) {
					if(c == null) {
						hxsl_Error.t("Integer value expected for array size constant " + _g.name,null);
					} else if(c._hx_index == 0) {
						let _g1 = c.c;
						if(_g1._hx_index == 2) {
							let _g = _g1.v;
							v2.type = v2.type._hx_index == 15 ? hxsl_Type.TArray(_g6,hxsl_SizeDecl.SConst(_g)) : hxsl_Type.TBuffer(_g6,hxsl_SizeDecl.SConst(_g));
						} else {
							hxsl_Error.t("Integer value expected for array size constant " + _g.name,null);
						}
					} else {
						hxsl_Error.t("Integer value expected for array size constant " + _g.name,null);
					}
				} else {
					let vs2 = this.mapVar(_g);
					v2.type = v2.type._hx_index == 15 ? hxsl_Type.TArray(_g6,hxsl_SizeDecl.SVar(vs2)) : hxsl_Type.TBuffer(_g6,hxsl_SizeDecl.SVar(vs2));
				}
			}
			break;
		default:
		}
		return v2;
	}
	checkSamplerRec(t) {
		if(hxsl_Tools.isSampler(t)) {
			return true;
		}
		switch(t._hx_index) {
		case 13:
			let _g = t.vl;
			let _g1 = 0;
			while(_g1 < _g.length) {
				let v = _g[_g1];
				++_g1;
				if(this.checkSamplerRec(v.type)) {
					return true;
				}
			}
			return false;
		case 15:
			return this.checkSamplerRec(t.t);
		case 16:
			return true;
		default:
		}
		return false;
	}
	needsInline(f) {
		let _g = 0;
		let _g1 = f.args;
		while(_g < _g1.length) {
			let a = _g1[_g];
			++_g;
			if(this.checkSamplerRec(a.type)) {
				return true;
			}
		}
		return false;
	}
	eval(s) {
		let funs = [];
		let _g = 0;
		let _g1 = s.funs;
		while(_g < _g1.length) {
			let f = _g1[_g];
			++_g;
			let f1 = f.kind;
			let f2 = this.mapVar(f.ref);
			let _g2 = [];
			let _g3 = 0;
			let _g4 = f.args;
			while(_g3 < _g4.length) {
				let a = _g4[_g3];
				++_g3;
				_g2.push(this.mapVar(a));
			}
			let f21 = { kind : f1, ref : f2, args : _g2, ret : f.ret, expr : f.expr};
			if(f.kind == hxsl_FunctionKind.Helper && this.inlineCalls || this.needsInline(f21)) {
				this.funMap.set(f21.ref,f);
			} else {
				funs.push(f21);
			}
		}
		let _g2 = 0;
		let _g3 = funs.length;
		while(_g2 < _g3) {
			let i = _g2++;
			this.curFun = funs[i];
			this.curFun.expr = this.evalExpr(this.curFun.expr,false);
		}
		let s1 = s.name;
		let _g4 = [];
		let _g5 = 0;
		let _g6 = s.vars;
		while(_g5 < _g6.length) {
			let v = _g6[_g5];
			++_g5;
			_g4.push(this.mapVar(v));
		}
		return { name : s1, vars : _g4, funs : funs};
	}
	hasReturn(e) {
		this.markReturn = false;
		this.hasReturnLoop(e);
		return this.markReturn;
	}
	hasReturnLoop(e) {
		if(e.e._hx_index == 12) {
			this.markReturn = true;
		} else if(!this.markReturn) {
			hxsl_Tools.iter(e,$bind(this,this.hasReturnLoop));
		}
	}
	handleReturn(e,isFinal) {
		if(isFinal == null) {
			isFinal = false;
		}
		let _g = e.e;
		switch(_g._hx_index) {
		case 3:
			let v = this.handleReturn(_g.e,isFinal);
			return { e : hxsl_TExprDef.TParenthesis(v), t : v.t, p : e.p};
		case 4:
			let _g1 = _g.el;
			let i = 0;
			let last = _g1.length;
			let out = [];
			_hx_loop1: while(i < last) {
				let e = _g1[i++];
				if(i == last) {
					out.push(this.handleReturn(e,isFinal));
				} else {
					let _g = e.e;
					switch(_g._hx_index) {
					case 10:
						let _g2 = _g.eif;
						if(_g.eelse == null) {
							if(isFinal && this.hasReturn(_g2)) {
								out.push(this.handleReturn({ e : hxsl_TExprDef.TIf(_g.econd,_g2,{ e : hxsl_TExprDef.TBlock(_g1.slice(i)), t : e.t, p : e.p}), t : e.t, p : e.p}));
								break _hx_loop1;
							} else {
								out.push(this.handleReturn(e));
							}
						} else {
							out.push(this.handleReturn(e));
						}
						break;
					case 12:
						out.push(this.handleReturn(_g.e,isFinal));
						break _hx_loop1;
					default:
						out.push(this.handleReturn(e));
					}
				}
			}
			let t = isFinal ? out.length == 0 ? hxsl_Type.TVoid : out[out.length - 1].t : e.t;
			return { e : hxsl_TExprDef.TBlock(out), t : t, p : e.p};
		case 10:
			let _g2 = _g.eelse;
			if(_g2 != null && isFinal) {
				let cond = this.handleReturn(_g.econd);
				let eif = this.handleReturn(_g.eif,isFinal);
				return { e : hxsl_TExprDef.TIf(cond,eif,this.handleReturn(_g2,isFinal)), t : eif.t, p : e.p};
			} else {
				return hxsl_Tools.map(e,$bind(this,this.handleReturnDef));
			}
			break;
		case 12:
			let _g3 = _g.e;
			if(!isFinal) {
				hxsl_Error.t("Cannot inline not final return",e.p);
			}
			if(_g3 == null) {
				return { e : hxsl_TExprDef.TBlock([]), t : hxsl_Type.TVoid, p : e.p};
			}
			return this.handleReturn(_g3,true);
		default:
			return hxsl_Tools.map(e,$bind(this,this.handleReturnDef));
		}
	}
	handleReturnDef(e) {
		return this.handleReturn(e);
	}
	evalCall(g,args,oldArgs,pos) {
		switch(g._hx_index) {
		case 38:
			if(args.length == 1) {
				let _g = args[0].e;
				if(_g._hx_index == 0) {
					let _g1 = _g.c;
					if(_g1._hx_index == 2) {
						return hxsl_TExprDef.TConst(hxsl_Const.CFloat(_g1.v));
					} else {
						return null;
					}
				} else {
					return null;
				}
			} else {
				return null;
			}
			break;
		case 63:case 64:
			let i;
			let _g = args[0].e;
			if(_g._hx_index == 0) {
				let _g1 = _g.c;
				if(_g1._hx_index == 2) {
					i = _g1.v;
				} else {
					hxsl_Error.t("Cannot eval complex channel " + hxsl_Printer.toString(args[0],true) + " " + this.constantsToString(),pos);
					throw haxe_Exception.thrown("assert");
				}
			} else {
				hxsl_Error.t("Cannot eval complex channel " + hxsl_Printer.toString(args[0],true) + " " + this.constantsToString(),pos);
				throw haxe_Exception.thrown("assert");
			}
			let channel = oldArgs[0];
			let _g1 = channel.e;
			let channel1;
			if(_g1._hx_index == 1) {
				channel1 = hxsl_TExprDef.TVar(this.mapVar(_g1.v));
			} else {
				throw haxe_Exception.thrown("assert");
			}
			channel = { e : channel1, t : channel.t, p : channel.p};
			let count;
			let _g2 = channel.t;
			if(_g2._hx_index == 17) {
				count = _g2.size;
			} else {
				throw haxe_Exception.thrown("assert");
			}
			let channelMode = Type.createEnumIndex(hxsl_Channel,i & 7,null);
			let targs = [channel];
			let _g3 = 1;
			let _g4 = args.length;
			while(_g3 < _g4) {
				let i = _g3++;
				targs.push(args[i]);
			}
			targs.push({ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(i >> 3)), t : hxsl_Type.TInt, p : pos});
			let tget = { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(g), t : hxsl_Type.TVoid, p : pos},targs), t : hxsl_Type.TVoid, p : pos};
			switch(channelMode._hx_index) {
			case 0:
				let zero = { e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(0.)), t : hxsl_Type.TFloat, p : pos};
				if(count == 1) {
					return zero.e;
				}
				return hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal([hxsl_TGlobal.Vec2,hxsl_TGlobal.Vec3,hxsl_TGlobal.Vec4][count - 2]), t : hxsl_Type.TVoid, p : pos},[zero]);
			case 1:case 2:case 3:case 4:
				let tmp;
				switch(count) {
				case 1:
					switch(channelMode._hx_index) {
					case 1:
						tmp = [hxsl_Component.X];
						break;
					case 2:
						tmp = [hxsl_Component.Y];
						break;
					case 3:
						tmp = [hxsl_Component.Z];
						break;
					case 4:
						tmp = [hxsl_Component.W];
						break;
					default:
						throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
					}
					break;
				case 2:
					switch(channelMode._hx_index) {
					case 1:
						tmp = [hxsl_Component.X,hxsl_Component.Y];
						break;
					case 2:
						tmp = [hxsl_Component.Y,hxsl_Component.Z];
						break;
					case 3:
						tmp = [hxsl_Component.Z,hxsl_Component.W];
						break;
					default:
						throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
					}
					break;
				case 3:
					switch(channelMode._hx_index) {
					case 1:
						tmp = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z];
						break;
					case 2:
						tmp = [hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
						break;
					default:
						throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
					}
					break;
				default:
					throw haxe_Exception.thrown("Invalid channel value " + Std.string(channelMode) + " for " + count + " channels");
				}
				return hxsl_TExprDef.TSwiz(tget,tmp);
			case 5:
				return hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Unpack), t : hxsl_Type.TVoid, p : pos},[tget]);
			case 6:
				return hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.UnpackNormal), t : hxsl_Type.TVoid, p : pos},[tget]);
			}
			break;
		case 67:
			let _g5 = 0;
			while(_g5 < args.length) {
				let a = args[_g5];
				++_g5;
				haxe_Log.trace(hxsl_Printer.toString(a),{ fileName : a.p.file, lineNumber : 0, className : null, methodName : null});
			}
			return hxsl_TExprDef.TBlock([]);
		default:
			return null;
		}
	}
	constantsToString() {
		let _g = [];
		let c = this.constants.keys();
		while(c.hasNext()) {
			let c1 = c.next();
			_g.push(c1 + " => " + hxsl_Printer.toString({ e : this.constants.h[c1], t : hxsl_Type.TVoid, p : null},true));
		}
		return _g.toString();
	}
	ifBlock(e) {
		if(e == null || e.e._hx_index != 10) {
			return e;
		}
		return { e : hxsl_TExprDef.TBlock([e]), t : e.t, p : e.p};
	}
	evalExpr(e,isVal) {
		if(isVal == null) {
			isVal = true;
		}
		let _gthis = this;
		let d;
		let _g = e.e;
		switch(_g._hx_index) {
		case 0:
			d = e.e;
			break;
		case 1:
			let _g1 = _g.v;
			let c = this.constants.h[_g1.id];
			if(c != null) {
				d = c;
			} else {
				let v2 = this.mapVar(_g1);
				d = hxsl_TExprDef.TVar(v2);
			}
			break;
		case 2:
			d = e.e;
			break;
		case 3:
			let e1 = this.evalExpr(_g.e,isVal);
			d = e1.e._hx_index == 0 ? e1.e : hxsl_TExprDef.TParenthesis(e1);
			break;
		case 4:
			let _g2 = _g.el;
			let out = [];
			let last = _g2.length - 1;
			let _g3 = 0;
			let _g4 = _g2.length;
			while(_g3 < _g4) {
				let i = _g3++;
				let isVal1 = isVal && i == last;
				let e = this.evalExpr(_g2[i],isVal1);
				switch(e.e._hx_index) {
				case 0:
					if(isVal1) {
						out.push(e);
					}
					break;
				case 1:
					if(isVal1) {
						out.push(e);
					}
					break;
				default:
					out.push(e);
				}
			}
			d = out.length == 1 && this.curFun.kind != hxsl_FunctionKind.Init ? out[0].e : hxsl_TExprDef.TBlock(out);
			break;
		case 5:
			let _g5 = _g.op;
			let e11 = this.evalExpr(_g.e1);
			let e2 = this.evalExpr(_g.e2);
			switch(_g5._hx_index) {
			case 0:
				let _g6 = e11.e;
				let _g7 = e2.e;
				if(_g6._hx_index == 0) {
					let _g = _g6.c;
					switch(_g._hx_index) {
					case 2:
						if(_g7._hx_index == 0) {
							let _g1 = _g7.c;
							d = _g1._hx_index == 2 ? hxsl_TExprDef.TConst(hxsl_Const.CInt(_g.v + _g1.v | 0)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 3:
						if(_g7._hx_index == 0) {
							let _g1 = _g7.c;
							d = _g1._hx_index == 3 ? hxsl_TExprDef.TConst(hxsl_Const.CFloat(_g.v + _g1.v)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 1:
				let _g8 = e11.e;
				let _g9 = e2.e;
				if(_g8._hx_index == 0) {
					let _g = _g8.c;
					switch(_g._hx_index) {
					case 2:
						if(_g9._hx_index == 0) {
							let _g1 = _g9.c;
							d = _g1._hx_index == 2 ? hxsl_TExprDef.TConst(hxsl_Const.CInt(_g.v * _g1.v | 0)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 3:
						if(_g9._hx_index == 0) {
							let _g1 = _g9.c;
							d = _g1._hx_index == 3 ? hxsl_TExprDef.TConst(hxsl_Const.CFloat(_g.v * _g1.v)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 2:
				let _g10 = e11.e;
				let _g11 = e2.e;
				if(_g10._hx_index == 0) {
					let _g = _g10.c;
					switch(_g._hx_index) {
					case 2:
						if(_g11._hx_index == 0) {
							let _g1 = _g11.c;
							d = _g1._hx_index == 2 ? hxsl_TExprDef.TConst(hxsl_Const.CInt(_g.v / _g1.v | 0)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 3:
						if(_g11._hx_index == 0) {
							let _g1 = _g11.c;
							d = _g1._hx_index == 3 ? hxsl_TExprDef.TConst(hxsl_Const.CFloat(_g.v / _g1.v)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 3:
				let _g12 = e11.e;
				let _g13 = e2.e;
				if(_g12._hx_index == 0) {
					let _g = _g12.c;
					switch(_g._hx_index) {
					case 2:
						if(_g13._hx_index == 0) {
							let _g1 = _g13.c;
							d = _g1._hx_index == 2 ? hxsl_TExprDef.TConst(hxsl_Const.CInt(_g.v - _g1.v | 0)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 3:
						if(_g13._hx_index == 0) {
							let _g1 = _g13.c;
							d = _g1._hx_index == 3 ? hxsl_TExprDef.TConst(hxsl_Const.CFloat(_g.v - _g1.v)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 4:case 21:
				d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				break;
			case 5:
				let _g14 = e11.e;
				let _g15 = e2.e;
				if(_g14._hx_index == 0) {
					let _g = _g14.c;
					switch(_g._hx_index) {
					case 0:
						d = _g15._hx_index == 0 ? _g15.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						break;
					case 1:
						let _g1 = _g.b;
						if(_g15._hx_index == 0) {
							let _g = _g15.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 1:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g1 == _g.b ? 0 : 1) == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 2:
						let _g2 = _g.v;
						if(_g15._hx_index == 0) {
							let _g = _g15.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 2:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(_g2 - _g.v == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 3:
						let _g3 = _g.v;
						if(_g15._hx_index == 0) {
							let _g = _g15.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 3:
								let _g1 = _g.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g3 > _g1 ? 1 : _g3 == _g1 ? 0 : -1) == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 4:
						let _g4 = _g.v;
						if(_g15._hx_index == 0) {
							let _g = _g15.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 4:
								let _g1 = _g.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g4 > _g1 ? 1 : _g4 == _g1 ? 0 : -1) == 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 6:
				let _g16 = e11.e;
				let _g17 = e2.e;
				if(_g16._hx_index == 0) {
					let _g = _g16.c;
					switch(_g._hx_index) {
					case 0:
						d = _g17._hx_index == 0 ? _g17.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						break;
					case 1:
						let _g1 = _g.b;
						if(_g17._hx_index == 0) {
							let _g = _g17.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 1:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g1 == _g.b ? 0 : 1) != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 2:
						let _g2 = _g.v;
						if(_g17._hx_index == 0) {
							let _g = _g17.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 2:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(_g2 - _g.v != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 3:
						let _g3 = _g.v;
						if(_g17._hx_index == 0) {
							let _g = _g17.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 3:
								let _g1 = _g.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g3 > _g1 ? 1 : _g3 == _g1 ? 0 : -1) != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 4:
						let _g4 = _g.v;
						if(_g17._hx_index == 0) {
							let _g = _g17.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 4:
								let _g1 = _g.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g4 > _g1 ? 1 : _g4 == _g1 ? 0 : -1) != 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 7:
				let _g18 = e11.e;
				let _g19 = e2.e;
				if(_g18._hx_index == 0) {
					let _g = _g18.c;
					switch(_g._hx_index) {
					case 0:
						d = _g19._hx_index == 0 ? _g19.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						break;
					case 1:
						let _g1 = _g.b;
						if(_g19._hx_index == 0) {
							let _g = _g19.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 1:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g1 == _g.b ? 0 : 1) > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 2:
						let _g2 = _g.v;
						if(_g19._hx_index == 0) {
							let _g = _g19.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 2:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(_g2 - _g.v > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 3:
						let _g3 = _g.v;
						if(_g19._hx_index == 0) {
							let _g = _g19.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 3:
								let _g1 = _g.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g3 > _g1 ? 1 : _g3 == _g1 ? 0 : -1) > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 4:
						let _g4 = _g.v;
						if(_g19._hx_index == 0) {
							let _g = _g19.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 4:
								let _g1 = _g.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g4 > _g1 ? 1 : _g4 == _g1 ? 0 : -1) > 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 8:
				let _g20 = e11.e;
				let _g21 = e2.e;
				if(_g20._hx_index == 0) {
					let _g = _g20.c;
					switch(_g._hx_index) {
					case 0:
						d = _g21._hx_index == 0 ? _g21.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						break;
					case 1:
						let _g1 = _g.b;
						if(_g21._hx_index == 0) {
							let _g = _g21.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 1:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g1 == _g.b ? 0 : 1) >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 2:
						let _g2 = _g.v;
						if(_g21._hx_index == 0) {
							let _g = _g21.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 2:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(_g2 - _g.v >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 3:
						let _g3 = _g.v;
						if(_g21._hx_index == 0) {
							let _g = _g21.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 3:
								let _g1 = _g.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g3 > _g1 ? 1 : _g3 == _g1 ? 0 : -1) >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 4:
						let _g4 = _g.v;
						if(_g21._hx_index == 0) {
							let _g = _g21.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(true));
								break;
							case 4:
								let _g1 = _g.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g4 > _g1 ? 1 : _g4 == _g1 ? 0 : -1) >= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 9:
				let _g22 = e11.e;
				let _g23 = e2.e;
				if(_g22._hx_index == 0) {
					let _g = _g22.c;
					switch(_g._hx_index) {
					case 0:
						d = _g23._hx_index == 0 ? _g23.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(false)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						break;
					case 1:
						let _g1 = _g.b;
						if(_g23._hx_index == 0) {
							let _g = _g23.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 1:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g1 == _g.b ? 0 : 1) < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 2:
						let _g2 = _g.v;
						if(_g23._hx_index == 0) {
							let _g = _g23.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 2:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(_g2 - _g.v < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 3:
						let _g3 = _g.v;
						if(_g23._hx_index == 0) {
							let _g = _g23.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 3:
								let _g1 = _g.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g3 > _g1 ? 1 : _g3 == _g1 ? 0 : -1) < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 4:
						let _g4 = _g.v;
						if(_g23._hx_index == 0) {
							let _g = _g23.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 4:
								let _g1 = _g.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g4 > _g1 ? 1 : _g4 == _g1 ? 0 : -1) < 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 10:
				let _g24 = e11.e;
				let _g25 = e2.e;
				if(_g24._hx_index == 0) {
					let _g = _g24.c;
					switch(_g._hx_index) {
					case 0:
						d = _g25._hx_index == 0 ? _g25.c._hx_index == 0 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TConst(hxsl_Const.CBool(true)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						break;
					case 1:
						let _g1 = _g.b;
						if(_g25._hx_index == 0) {
							let _g = _g25.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 1:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g1 == _g.b ? 0 : 1) <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 2:
						let _g2 = _g.v;
						if(_g25._hx_index == 0) {
							let _g = _g25.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 2:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(_g2 - _g.v <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 3:
						let _g3 = _g.v;
						if(_g25._hx_index == 0) {
							let _g = _g25.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 3:
								let _g1 = _g.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g3 > _g1 ? 1 : _g3 == _g1 ? 0 : -1) <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 4:
						let _g4 = _g.v;
						if(_g25._hx_index == 0) {
							let _g = _g25.c;
							switch(_g._hx_index) {
							case 0:
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool(false));
								break;
							case 4:
								let _g1 = _g.v;
								d = hxsl_TExprDef.TConst(hxsl_Const.CBool((_g4 > _g1 ? 1 : _g4 == _g1 ? 0 : -1) <= 0));
								break;
							default:
								d = hxsl_TExprDef.TBinop(_g5,e11,e2);
							}
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 11:
				let _g26 = e11.e;
				let _g27 = e2.e;
				if(_g26._hx_index == 0) {
					let _g = _g26.c;
					if(_g._hx_index == 2) {
						if(_g27._hx_index == 0) {
							let _g1 = _g27.c;
							d = _g1._hx_index == 2 ? hxsl_TExprDef.TConst(hxsl_Const.CInt(_g.v & _g1.v)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
					} else {
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 12:
				let _g28 = e11.e;
				let _g29 = e2.e;
				if(_g28._hx_index == 0) {
					let _g = _g28.c;
					if(_g._hx_index == 2) {
						if(_g29._hx_index == 0) {
							let _g1 = _g29.c;
							d = _g1._hx_index == 2 ? hxsl_TExprDef.TConst(hxsl_Const.CInt(_g.v | _g1.v)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
					} else {
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 13:
				let _g30 = e11.e;
				let _g31 = e2.e;
				if(_g30._hx_index == 0) {
					let _g = _g30.c;
					if(_g._hx_index == 2) {
						if(_g31._hx_index == 0) {
							let _g1 = _g31.c;
							d = _g1._hx_index == 2 ? hxsl_TExprDef.TConst(hxsl_Const.CInt(_g.v ^ _g1.v)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
					} else {
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 14:
				let _g32 = e11.e;
				let _g33 = e2.e;
				if(_g32._hx_index == 0) {
					let _g = _g32.c;
					if(_g._hx_index == 1) {
						let _g1 = _g.b;
						if(_g33._hx_index == 0) {
							let _g = _g33.c;
							d = _g._hx_index == 1 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(_g1 && _g.b)) : _g1 == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(_g1)) : e2.e;
						} else {
							d = _g1 == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(_g1)) : e2.e;
						}
					} else if(_g33._hx_index == 0) {
						let _g = _g33.c;
						if(_g._hx_index == 1) {
							let _g1 = _g.b;
							d = _g1 == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(_g1)) : e11.e;
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
					} else {
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else if(_g33._hx_index == 0) {
					let _g = _g33.c;
					if(_g._hx_index == 1) {
						let _g1 = _g.b;
						d = _g1 == false ? hxsl_TExprDef.TConst(hxsl_Const.CBool(_g1)) : e11.e;
					} else {
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 15:
				let _g34 = e11.e;
				let _g35 = e2.e;
				if(_g34._hx_index == 0) {
					let _g = _g34.c;
					if(_g._hx_index == 1) {
						let _g1 = _g.b;
						if(_g35._hx_index == 0) {
							let _g = _g35.c;
							d = _g._hx_index == 1 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(_g1 || _g.b)) : _g1 == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(_g1)) : e2.e;
						} else {
							d = _g1 == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(_g1)) : e2.e;
						}
					} else if(_g35._hx_index == 0) {
						let _g = _g35.c;
						if(_g._hx_index == 1) {
							let _g1 = _g.b;
							d = _g1 == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(_g1)) : e11.e;
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
					} else {
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else if(_g35._hx_index == 0) {
					let _g = _g35.c;
					if(_g._hx_index == 1) {
						let _g1 = _g.b;
						d = _g1 == true ? hxsl_TExprDef.TConst(hxsl_Const.CBool(_g1)) : e11.e;
					} else {
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 16:
				let _g36 = e11.e;
				let _g37 = e2.e;
				if(_g36._hx_index == 0) {
					let _g = _g36.c;
					if(_g._hx_index == 2) {
						if(_g37._hx_index == 0) {
							let _g1 = _g37.c;
							d = _g1._hx_index == 2 ? hxsl_TExprDef.TConst(hxsl_Const.CInt(_g.v << _g1.v)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
					} else {
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 17:
				let _g38 = e11.e;
				let _g39 = e2.e;
				if(_g38._hx_index == 0) {
					let _g = _g38.c;
					if(_g._hx_index == 2) {
						if(_g39._hx_index == 0) {
							let _g1 = _g39.c;
							d = _g1._hx_index == 2 ? hxsl_TExprDef.TConst(hxsl_Const.CInt(_g.v >> _g1.v)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
					} else {
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 18:
				let _g40 = e11.e;
				let _g41 = e2.e;
				if(_g40._hx_index == 0) {
					let _g = _g40.c;
					if(_g._hx_index == 2) {
						if(_g41._hx_index == 0) {
							let _g1 = _g41.c;
							d = _g1._hx_index == 2 ? hxsl_TExprDef.TConst(hxsl_Const.CInt(_g.v >>> _g1.v)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
					} else {
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 19:
				let _g42 = e11.e;
				let _g43 = e2.e;
				if(_g42._hx_index == 0) {
					let _g = _g42.c;
					switch(_g._hx_index) {
					case 2:
						if(_g43._hx_index == 0) {
							let _g1 = _g43.c;
							d = _g1._hx_index == 2 ? hxsl_TExprDef.TConst(hxsl_Const.CInt(_g.v % _g1.v | 0)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					case 3:
						if(_g43._hx_index == 0) {
							let _g1 = _g43.c;
							d = _g1._hx_index == 3 ? hxsl_TExprDef.TConst(hxsl_Const.CFloat(_g.v % _g1.v)) : hxsl_TExprDef.TBinop(_g5,e11,e2);
						} else {
							d = hxsl_TExprDef.TBinop(_g5,e11,e2);
						}
						break;
					default:
						d = hxsl_TExprDef.TBinop(_g5,e11,e2);
					}
				} else {
					d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				}
				break;
			case 20:
				d = hxsl_TExprDef.TBinop(_g5,e11,e2);
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			break;
		case 6:
			let _g44 = _g.op;
			let e3 = this.evalExpr(_g.e1);
			let _g45 = e3.e;
			if(_g45._hx_index == 0) {
				let _g = _g45.c;
				switch(_g44._hx_index) {
				case 2:
					d = _g._hx_index == 1 ? hxsl_TExprDef.TConst(hxsl_Const.CBool(!_g.b)) : hxsl_TExprDef.TUnop(_g44,e3);
					break;
				case 3:
					switch(_g._hx_index) {
					case 2:
						d = hxsl_TExprDef.TConst(hxsl_Const.CInt(-_g.v));
						break;
					case 3:
						d = hxsl_TExprDef.TConst(hxsl_Const.CFloat(-_g.v));
						break;
					default:
						d = hxsl_TExprDef.TUnop(_g44,e3);
					}
					break;
				default:
					d = hxsl_TExprDef.TUnop(_g44,e3);
				}
			} else {
				d = hxsl_TExprDef.TUnop(_g44,e3);
			}
			break;
		case 7:
			let _g46 = _g.init;
			d = hxsl_TExprDef.TVarDecl(this.mapVar(_g.v),_g46 == null ? null : this.evalExpr(_g46));
			break;
		case 8:
			let _g47 = _g.args;
			let c1 = this.evalExpr(_g.e);
			let _g48 = [];
			let _g49 = 0;
			while(_g49 < _g47.length) {
				let a = _g47[_g49];
				++_g49;
				_g48.push(this.evalExpr(a));
			}
			let _g50 = c1.e;
			switch(_g50._hx_index) {
			case 1:
				let _g51 = _g50.v;
				if(this.funMap.h.__keys__[_g51.__id__] != null) {
					let f = this.funMap.h[_g51.__id__];
					let outExprs = [];
					let undo = [];
					let _g = 0;
					let _g1 = f.args.length;
					while(_g < _g1) {
						let i = _g++;
						let v = f.args[i];
						let e = _g48[i];
						let _g1 = e.e;
						switch(_g1._hx_index) {
						case 0:
							let old = this.constants.h[v.id];
							undo.push(function() {
								if(old == null) {
									_gthis.constants.remove(v.id);
								} else {
									_gthis.constants.h[v.id] = old;
								}
							});
							this.constants.h[v.id] = e.e;
							break;
						case 1:
							switch(_g1.v.kind._hx_index) {
							case 0:case 1:case 2:
								let old1 = this.constants.h[v.id];
								undo.push(function() {
									if(old1 == null) {
										_gthis.constants.remove(v.id);
									} else {
										_gthis.constants.h[v.id] = old1;
									}
								});
								this.constants.h[v.id] = e.e;
								break;
							default:
								let old2 = this.varMap.h[v.__id__];
								if(old2 == null) {
									undo.push(function() {
										_gthis.varMap.remove(v);
									});
								} else {
									this.varMap.remove(v);
									undo.push(function() {
										_gthis.varMap.set(v,old2);
									});
								}
								let v2 = this.mapVar(v);
								outExprs.push({ e : hxsl_TExprDef.TVarDecl(v2,e), t : hxsl_Type.TVoid, p : e.p});
							}
							break;
						default:
							let old3 = this.varMap.h[v.__id__];
							if(old3 == null) {
								undo.push(function() {
									_gthis.varMap.remove(v);
								});
							} else {
								this.varMap.remove(v);
								undo.push(function() {
									_gthis.varMap.set(v,old3);
								});
							}
							let v21 = this.mapVar(v);
							outExprs.push({ e : hxsl_TExprDef.TVarDecl(v21,e), t : hxsl_Type.TVoid, p : e.p});
						}
					}
					let e = this.handleReturn(this.evalExpr(f.expr,false),true);
					let _g2 = 0;
					while(_g2 < undo.length) {
						let u = undo[_g2];
						++_g2;
						u();
					}
					let _g3 = e.e;
					if(_g3._hx_index == 4) {
						let _g = _g3.el;
						let _g1 = 0;
						while(_g1 < _g.length) {
							let e = _g[_g1];
							++_g1;
							outExprs.push(e);
						}
					} else {
						outExprs.push(e);
					}
					d = hxsl_TExprDef.TBlock(outExprs);
				} else {
					d = hxsl_TExprDef.TCall(c1,_g48);
				}
				break;
			case 2:
				let v = this.evalCall(_g50.g,_g48,_g47,e.p);
				d = v != null ? v : hxsl_TExprDef.TCall(c1,_g48);
				break;
			default:
				d = hxsl_Error.t("Cannot eval non-static call expresssion '" + new hxsl_Printer().exprString(c1) + "'",c1.p);
			}
			break;
		case 9:
			d = hxsl_TExprDef.TSwiz(this.evalExpr(_g.e),_g.regs.slice());
			break;
		case 10:
			let _g52 = _g.eif;
			let _g53 = _g.eelse;
			let eif = _g52;
			let eelse = _g53;
			let econd = this.evalExpr(_g.econd);
			let _g54 = econd.e;
			if(_g54._hx_index == 0) {
				let _g = _g54.c;
				if(_g._hx_index == 1) {
					d = _g.b ? this.evalExpr(_g52,isVal).e : _g53 == null ? hxsl_TExprDef.TConst(hxsl_Const.CNull) : this.evalExpr(_g53,isVal).e;
				} else if(isVal && _g53 != null && this.eliminateConditionals) {
					d = hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), t : e.t, p : e.p},[this.evalExpr(_g53,true),this.evalExpr(_g52,true),{ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), t : hxsl_Type.TFun([]), p : econd.p},[econd]), t : hxsl_Type.TFloat, p : e.p}]);
				} else {
					eif = this.evalExpr(_g52,isVal);
					if(_g53 != null) {
						eelse = this.evalExpr(_g53,isVal);
						let _g = eelse.e;
						if(_g._hx_index == 0 && _g.c._hx_index == 0) {
							eelse = null;
						}
					}
					eif = this.ifBlock(eif);
					eelse = this.ifBlock(eelse);
					d = hxsl_TExprDef.TIf(econd,eif,eelse);
				}
			} else if(isVal && _g53 != null && this.eliminateConditionals) {
				d = hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mix), t : e.t, p : e.p},[this.evalExpr(_g53,true),this.evalExpr(_g52,true),{ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToFloat), t : hxsl_Type.TFun([]), p : econd.p},[econd]), t : hxsl_Type.TFloat, p : e.p}]);
			} else {
				eif = this.evalExpr(_g52,isVal);
				if(_g53 != null) {
					eelse = this.evalExpr(_g53,isVal);
					let _g = eelse.e;
					if(_g._hx_index == 0 && _g.c._hx_index == 0) {
						eelse = null;
					}
				}
				eif = this.ifBlock(eif);
				eelse = this.ifBlock(eelse);
				d = hxsl_TExprDef.TIf(econd,eif,eelse);
			}
			break;
		case 11:
			d = hxsl_TExprDef.TDiscard;
			break;
		case 12:
			let _g55 = _g.e;
			d = hxsl_TExprDef.TReturn(_g55 == null ? null : this.evalExpr(_g55));
			break;
		case 13:
			let _g56 = _g.v;
			let _g57 = _g.loop;
			let v2 = this.mapVar(_g56);
			let it = this.evalExpr(_g.it);
			let e4;
			let _g58 = it.e;
			if(_g58._hx_index == 5) {
				if(_g58.op._hx_index == 21) {
					let _g = _g58.e1.e;
					if(_g._hx_index == 0) {
						let _g1 = _g.c;
						if(_g1._hx_index == 2) {
							let _g = _g58.e2.e;
							if(_g._hx_index == 0) {
								let _g2 = _g.c;
								if(_g2._hx_index == 2) {
									let _g = _g2.v;
									if(this.unrollLoops) {
										let out = [];
										let _g2 = _g1.v;
										while(_g2 < _g) {
											let i = _g2++;
											this.constants.h[_g56.id] = hxsl_TExprDef.TConst(hxsl_Const.CInt(i));
											out.push(this.evalExpr(_g57,false));
										}
										this.constants.remove(_g56.id);
										e4 = hxsl_TExprDef.TBlock(out);
									} else {
										e4 = hxsl_TExprDef.TFor(v2,it,this.ifBlock(this.evalExpr(_g57,false)));
									}
								} else {
									e4 = hxsl_TExprDef.TFor(v2,it,this.ifBlock(this.evalExpr(_g57,false)));
								}
							} else {
								e4 = hxsl_TExprDef.TFor(v2,it,this.ifBlock(this.evalExpr(_g57,false)));
							}
						} else {
							e4 = hxsl_TExprDef.TFor(v2,it,this.ifBlock(this.evalExpr(_g57,false)));
						}
					} else {
						e4 = hxsl_TExprDef.TFor(v2,it,this.ifBlock(this.evalExpr(_g57,false)));
					}
				} else {
					e4 = hxsl_TExprDef.TFor(v2,it,this.ifBlock(this.evalExpr(_g57,false)));
				}
			} else {
				e4 = hxsl_TExprDef.TFor(v2,it,this.ifBlock(this.evalExpr(_g57,false)));
			}
			this.varMap.remove(_g56);
			d = e4;
			break;
		case 14:
			d = hxsl_TExprDef.TContinue;
			break;
		case 15:
			d = hxsl_TExprDef.TBreak;
			break;
		case 16:
			let e12 = this.evalExpr(_g.e);
			let e21 = this.evalExpr(_g.index);
			let _g59 = e12.e;
			let _g60 = e21.e;
			if(_g59._hx_index == 17) {
				let _g = _g59.el;
				if(_g60._hx_index == 0) {
					let _g1 = _g60.c;
					if(_g1._hx_index == 2) {
						let _g2 = _g1.v;
						d = _g2 >= 0 && _g2 < _g.length ? _g[_g2].e : hxsl_TExprDef.TArray(e12,e21);
					} else {
						d = hxsl_TExprDef.TArray(e12,e21);
					}
				} else {
					d = hxsl_TExprDef.TArray(e12,e21);
				}
			} else {
				d = hxsl_TExprDef.TArray(e12,e21);
			}
			break;
		case 17:
			let _g61 = _g.el;
			let _g62 = [];
			let _g63 = 0;
			while(_g63 < _g61.length) {
				let e = _g61[_g63];
				++_g63;
				_g62.push(this.evalExpr(e));
			}
			d = hxsl_TExprDef.TArrayDecl(_g62);
			break;
		case 18:
			let _g64 = _g.cases;
			let _g65 = _g.def;
			let e5 = this.evalExpr(_g.e);
			let _g66 = [];
			let _g67 = 0;
			while(_g67 < _g64.length) {
				let c = _g64[_g67];
				++_g67;
				let _g = [];
				let _g1 = 0;
				let _g2 = c.values;
				while(_g1 < _g2.length) {
					let v = _g2[_g1];
					++_g1;
					_g.push(this.evalExpr(v));
				}
				_g66.push({ values : _g, expr : this.evalExpr(c.expr,isVal)});
			}
			let def = _g65 == null ? null : this.evalExpr(_g65,isVal);
			let hasCase = false;
			let _g68 = e5.e;
			if(_g68._hx_index == 0) {
				let _g = _g68.c;
				if(_g._hx_index == 2) {
					let _g1 = _g.v;
					let _g2 = 0;
					while(_g2 < _g66.length) {
						let c = _g66[_g2];
						++_g2;
						let _g = 0;
						let _g3 = c.values;
						while(_g < _g3.length) {
							let v = _g3[_g];
							++_g;
							let _g2 = v.e;
							if(_g2._hx_index == 0) {
								let _g = _g2.c;
								switch(_g._hx_index) {
								case 2:
									if(_g.v == _g1) {
										return c.expr;
									}
									break;
								case 3:
									if(_g.v == _g1) {
										return c.expr;
									}
									break;
								default:
								}
							} else {
								hasCase = true;
							}
						}
					}
				} else {
					throw haxe_Exception.thrown("Unsupported switch constant " + Std.string(_g));
				}
			} else {
				hasCase = true;
			}
			d = hasCase ? hxsl_TExprDef.TSwitch(e5,_g66,def) : def == null ? hxsl_TExprDef.TBlock([]) : def.e;
			break;
		case 19:
			let cond = this.evalExpr(_g.e);
			let loop = this.evalExpr(_g.loop,false);
			d = hxsl_TExprDef.TWhile(cond,this.ifBlock(loop),_g.normalWhile);
			break;
		case 20:
			let _g69 = _g.m;
			let _g70 = _g.e;
			let e22;
			if(_g69 == "unroll") {
				this.unrollLoops = true;
				e22 = this.evalExpr(_g70,isVal);
				this.unrollLoops = false;
			} else {
				e22 = this.evalExpr(_g70,isVal);
			}
			d = hxsl_TExprDef.TMeta(_g69,_g.args,e22);
			break;
		}
		return { e : d, t : e.t, p : e.p};
	}
}
$hxClasses["hxsl.Eval"] = hxsl_Eval;
hxsl_Eval.__name__ = "hxsl.Eval";
Object.assign(hxsl_Eval.prototype, {
	__class__: hxsl_Eval
	,varMap: null
	,inlineCalls: null
	,unrollLoops: null
	,eliminateConditionals: null
	,constants: null
	,funMap: null
	,curFun: null
	,markReturn: null
});
class hxsl__$Flatten_Alloc {
	constructor(g,t,pos,size) {
		this.g = g;
		this.t = t;
		this.pos = pos;
		this.size = size;
	}
}
$hxClasses["hxsl._Flatten.Alloc"] = hxsl__$Flatten_Alloc;
hxsl__$Flatten_Alloc.__name__ = "hxsl._Flatten.Alloc";
Object.assign(hxsl__$Flatten_Alloc.prototype, {
	__class__: hxsl__$Flatten_Alloc
	,t: null
	,pos: null
	,size: null
	,g: null
	,v: null
});
var hxsl_ARead = $hxEnums["hxsl.ARead"] = { __ename__:true,__constructs__:null
	,AIndex: ($_=function(a) { return {_hx_index:0,a:a,__enum__:"hxsl.ARead",toString:$estr}; },$_._hx_name="AIndex",$_.__params__ = ["a"],$_)
	,AOffset: ($_=function(a,stride,delta) { return {_hx_index:1,a:a,stride:stride,delta:delta,__enum__:"hxsl.ARead",toString:$estr}; },$_._hx_name="AOffset",$_.__params__ = ["a","stride","delta"],$_)
};
hxsl_ARead.__constructs__ = [hxsl_ARead.AIndex,hxsl_ARead.AOffset];
hxsl_ARead.__empty_constructs__ = [];
class hxsl_Flatten {
	constructor() {
	}
	flatten(s,kind,constsToGlobal) {
		this.globals = [];
		this.params = [];
		this.outVars = [];
		if(constsToGlobal) {
			this.consts = [];
			let p = s.funs[0].expr.p;
			let gc = { id : hxsl_Tools.allocVarId(), name : "__consts__", kind : hxsl_VarKind.Global, type : null};
			this.econsts = { e : hxsl_TExprDef.TVar(gc), t : null, p : p};
			let s1 = s.name;
			let s2 = s.vars.slice();
			let _g = [];
			let _g1 = 0;
			let _g2 = s.funs;
			while(_g1 < _g2.length) {
				let f = _g2[_g1];
				++_g1;
				_g.push(this.mapFun(f,$bind(this,this.mapConsts)));
			}
			s = { name : s1, vars : s2, funs : _g};
			let _g3 = 0;
			let _g4 = s.vars;
			while(_g3 < _g4.length) {
				let v = _g4[_g3];
				++_g3;
				if(v.type._hx_index == 9) {
					this.allocConst(255,p);
				}
			}
			if(this.consts.length > 0) {
				gc.type = this.econsts.t = hxsl_Type.TArray(hxsl_Type.TFloat,hxsl_SizeDecl.SConst(this.consts.length));
				s.vars.push(gc);
			}
		}
		this.varMap = new haxe_ds_ObjectMap();
		this.allocData = new haxe_ds_ObjectMap();
		let _g = 0;
		let _g1 = s.vars;
		while(_g < _g1.length) {
			let v = _g1[_g];
			++_g;
			this.gatherVar(v);
		}
		let prefix;
		switch(kind._hx_index) {
		case 0:
			prefix = "vertex";
			break;
		case 1:
			prefix = "fragment";
			break;
		default:
			throw haxe_Exception.thrown("assert");
		}
		this.pack(prefix + "Globals",hxsl_VarKind.Global,this.globals,hxsl_VecType.VFloat);
		this.pack(prefix + "Params",hxsl_VarKind.Param,this.params,hxsl_VecType.VFloat);
		let allVars = this.globals.concat(this.params);
		this.packTextures(prefix + "Textures",allVars,hxsl_Type.TSampler2D).concat(this.packTextures(prefix + "TexturesCube",allVars,hxsl_Type.TSamplerCube)).concat(this.packTextures(prefix + "TexturesArray",allVars,hxsl_Type.TSampler2DArray));
		this.packBuffers(allVars);
		let _g2 = [];
		let _g3 = 0;
		let _g4 = s.funs;
		while(_g3 < _g4.length) {
			let f = _g4[_g3];
			++_g3;
			_g2.push(this.mapFun(f,$bind(this,this.mapExpr)));
		}
		return { name : s.name, vars : this.outVars, funs : _g2};
	}
	mapFun(f,mapExpr) {
		return { kind : f.kind, ret : f.ret, args : f.args, ref : f.ref, expr : mapExpr(f.expr)};
	}
	mapExpr(e) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 1:
			let _g1 = _g.v;
			let a = this.varMap.h[_g1.__id__];
			if(a != null) {
				e = this.access(a,_g1.type,e.p,hxsl_ARead.AIndex(a));
			}
			break;
		case 16:
			let _g2 = _g.e;
			let _g3 = _g.index;
			let _g4 = _g2.e;
			let _g5 = _g2.p;
			if(_g4._hx_index == 1) {
				let _g = _g4.v;
				let eindex = _g3;
				let _g1 = _g3.e;
				if(!(_g1._hx_index == 0 && _g1.c._hx_index == 2)) {
					let a = this.varMap.h[_g.__id__];
					if(a != null) {
						let _g1 = _g.type;
						if(_g1._hx_index == 15) {
							let _g = _g1.t;
							if(hxsl_Tools.isSampler(_g)) {
								eindex = this.toInt(this.mapExpr(_g3));
								e = this.access(a,_g,_g5,hxsl_ARead.AOffset(a,1,eindex));
							} else {
								let stride = this.varSize(_g,a.t);
								if(stride == 0 || (stride & 3) != 0) {
									throw haxe_Exception.thrown(new hxsl_Error("Dynamic access to an Array which size is not 4 components-aligned is not allowed",e.p));
								}
								stride >>= 2;
								eindex = this.toInt(this.mapExpr(_g3));
								e = this.access(a,_g,_g5,hxsl_ARead.AOffset(a,stride,stride == 1 ? eindex : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpMult,eindex,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(stride)), t : hxsl_Type.TInt, p : _g5}), t : hxsl_Type.TInt, p : _g5}));
							}
						} else {
							throw haxe_Exception.thrown("assert");
						}
					}
				} else {
					e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
				}
			} else {
				e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
			}
			break;
		default:
			e = hxsl_Tools.map(e,$bind(this,this.mapExpr));
		}
		return this.optimize(e);
	}
	mapConsts(e) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 0:
			let _g1 = _g.c;
			switch(_g1._hx_index) {
			case 2:
				return this.allocConst(_g1.v,e.p);
			case 3:
				return this.allocConst(_g1.v,e.p);
			default:
				return e;
			}
			break;
		case 2:
			switch(_g.g._hx_index) {
			case 0:
				this.allocConst(Math.PI / 180,e.p);
				break;
			case 1:
				this.allocConst(180 / Math.PI,e.p);
				break;
			case 9:
				this.allocConst(1.4426950408889634,e.p);
				break;
			case 10:
				this.allocConst(0.6931471805599453,e.p);
				break;
			case 24:
				this.allocConst(1,e.p);
				break;
			case 26:
				this.allocConst(2.0,e.p);
				this.allocConst(3.0,e.p);
				break;
			case 54:
				this.allocConsts([1,255,65025,16581375],e.p);
				this.allocConsts([0.00392156862745098,0.00392156862745098,0.00392156862745098,0],e.p);
				break;
			case 55:
				this.allocConsts([1,0.00392156862745098,1.5378700499807768e-005,6.0308629411010845e-008],e.p);
				break;
			case 56:
				this.allocConst(1,e.p);
				this.allocConst(0.5,e.p);
				break;
			case 57:
				this.allocConst(0.5,e.p);
				break;
			case 58:
				this.allocConsts([0.5,0.5],e.p);
				this.allocConsts([0.5,-0.5],e.p);
				break;
			case 59:
				this.allocConsts([2,-2],e.p);
				this.allocConsts([-1,1],e.p);
				break;
			default:
			}
			break;
		case 5:
			if(_g.op._hx_index == 1) {
				if(_g.e2.t._hx_index == 8) {
					this.allocConst(1,e.p);
				}
			}
			break;
		case 8:
			let _g2 = _g.args;
			let _g3 = _g.e.e;
			if(_g3._hx_index == 2) {
				if(_g3.g._hx_index == 42) {
					if(_g2.length == 2) {
						let _g = _g2[0];
						let _g1 = _g2[1];
						let _g3 = _g.e;
						let _g4 = _g.t;
						if(_g3._hx_index == 1) {
							switch(_g3.v.kind._hx_index) {
							case 0:
								if(_g4._hx_index == 5) {
									if(_g4.size == 3) {
										if(_g4.t._hx_index == 1) {
											let _g = _g1.e;
											if(_g._hx_index == 0) {
												let _g1 = _g.c;
												if(_g1._hx_index == 2) {
													if(_g1.v == 1) {
														return e;
													}
												}
											}
										}
									}
								}
								break;
							case 1:
								if(_g4._hx_index == 5) {
									if(_g4.size == 3) {
										if(_g4.t._hx_index == 1) {
											let _g = _g1.e;
											if(_g._hx_index == 0) {
												let _g1 = _g.c;
												if(_g1._hx_index == 2) {
													if(_g1.v == 1) {
														return e;
													}
												}
											}
										}
									}
								}
								break;
							case 2:
								if(_g4._hx_index == 5) {
									if(_g4.size == 3) {
										if(_g4.t._hx_index == 1) {
											let _g = _g1.e;
											if(_g._hx_index == 0) {
												let _g1 = _g.c;
												if(_g1._hx_index == 2) {
													if(_g1.v == 1) {
														return e;
													}
												}
											}
										}
									}
								}
								break;
							case 3:
								if(_g4._hx_index == 5) {
									if(_g4.size == 3) {
										if(_g4.t._hx_index == 1) {
											let _g = _g1.e;
											if(_g._hx_index == 0) {
												let _g1 = _g.c;
												if(_g1._hx_index == 2) {
													if(_g1.v == 1) {
														return e;
													}
												}
											}
										}
									}
								}
								break;
							default:
							}
						}
					}
				}
			}
			break;
		case 16:
			let _g4 = _g.e;
			let _g5 = _g.index;
			let _g6 = _g5.e;
			if(_g6._hx_index == 0) {
				if(_g6.c._hx_index == 2) {
					return { e : hxsl_TExprDef.TArray(this.mapConsts(_g4),_g5), t : e.t, p : e.p};
				} else {
					let _g = _g4.t;
					if(_g._hx_index == 15) {
						let stride = this.varSize(_g.t,hxsl_VecType.VFloat) >> 2;
						this.allocConst(stride,e.p);
					}
				}
			} else {
				let _g = _g4.t;
				if(_g._hx_index == 15) {
					let stride = this.varSize(_g.t,hxsl_VecType.VFloat) >> 2;
					this.allocConst(stride,e.p);
				}
			}
			break;
		default:
		}
		return hxsl_Tools.map(e,$bind(this,this.mapConsts));
	}
	allocConst(v,p) {
		let index = this.consts.indexOf(v);
		if(index < 0) {
			index = this.consts.length;
			this.consts.push(v);
		}
		return { e : hxsl_TExprDef.TArray(this.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p};
	}
	allocConsts(va,p) {
		let pad = va.length - 1 & 3;
		let index = -1;
		let _g = 0;
		let _g1 = this.consts.length - (va.length - 1);
		while(_g < _g1) {
			let i = _g++;
			if(i >> 2 != i + pad >> 2) {
				continue;
			}
			let found = true;
			let _g1 = 0;
			let _g2 = va.length;
			while(_g1 < _g2) {
				let j = _g1++;
				if(this.consts[i + j] != va[j]) {
					found = false;
					break;
				}
			}
			if(found) {
				index = i;
				break;
			}
		}
		if(index < 0) {
			while(this.consts.length >> 2 != this.consts.length + pad >> 2) this.consts.push(0);
			index = this.consts.length;
			let _g = 0;
			while(_g < va.length) {
				let v = va[_g];
				++_g;
				this.consts.push(v);
			}
		}
		switch(va.length) {
		case 1:
			return { e : hxsl_TExprDef.TArray(this.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p};
		case 2:
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec2), t : hxsl_Type.TVoid, p : p},[{ e : hxsl_TExprDef.TArray(this.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p},{ e : hxsl_TExprDef.TArray(this.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index + 1)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p}]), t : hxsl_Type.TVec(2,hxsl_VecType.VFloat), p : p};
		case 3:
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec3), t : hxsl_Type.TVoid, p : p},[{ e : hxsl_TExprDef.TArray(this.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p},{ e : hxsl_TExprDef.TArray(this.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index + 1)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p},{ e : hxsl_TExprDef.TArray(this.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index + 2)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p}]), t : hxsl_Type.TVec(3,hxsl_VecType.VFloat), p : p};
		case 4:
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec4), t : hxsl_Type.TVoid, p : p},[{ e : hxsl_TExprDef.TArray(this.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p},{ e : hxsl_TExprDef.TArray(this.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index + 1)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p},{ e : hxsl_TExprDef.TArray(this.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index + 3)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p},{ e : hxsl_TExprDef.TArray(this.econsts,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index + 4)), t : hxsl_Type.TInt, p : p}), t : hxsl_Type.TFloat, p : p}]), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : p};
		default:
			throw haxe_Exception.thrown("assert");
		}
	}
	access(a,t,pos,acc) {
		switch(t._hx_index) {
		case 6:
			let tmp = this.access(a,hxsl_Type.TMat3x4,pos,acc);
			return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3), t : hxsl_Type.TFun([]), p : pos},[tmp]), t : hxsl_Type.TMat3, p : pos};
		case 7:
			let tmp1 = hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat4);
			let tmp2 = hxsl_Type.TFun([]);
			let tmp3;
			switch(acc._hx_index) {
			case 0:
				let _g = acc.a;
				let offs = _g.t == null ? _g.pos : _g.pos >> 2;
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g.g), t : _g.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,_g.t), p : pos};
				break;
			case 1:
				let _g1 = acc.a;
				let _g2 = acc.delta;
				let index = _g1.t == null ? _g1.pos : _g1.pos >> 2;
				let offset = index == 0 ? _g2 : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,_g2,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp3 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g1.g), t : _g1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,_g1.t), p : pos};
				break;
			}
			let tmp4;
			switch(acc._hx_index) {
			case 0:
				let _g3 = acc.a;
				let offs1 = _g3.t == null ? _g3.pos : _g3.pos >> 2;
				tmp4 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g3.g), t : _g3.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs1 + 1)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,_g3.t), p : pos};
				break;
			case 1:
				let _g4 = acc.a;
				let _g5 = acc.delta;
				let index1 = (_g4.t == null ? _g4.pos : _g4.pos >> 2) + 1;
				let offset1 = index1 == 0 ? _g5 : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,_g5,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index1)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp4 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g4.g), t : _g4.g.type, p : pos},offset1), t : hxsl_Type.TVec(4,_g4.t), p : pos};
				break;
			}
			let tmp5;
			switch(acc._hx_index) {
			case 0:
				let _g6 = acc.a;
				let offs2 = _g6.t == null ? _g6.pos : _g6.pos >> 2;
				tmp5 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g6.g), t : _g6.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs2 + 2)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,_g6.t), p : pos};
				break;
			case 1:
				let _g7 = acc.a;
				let _g8 = acc.delta;
				let index2 = (_g7.t == null ? _g7.pos : _g7.pos >> 2) + 2;
				let offset2 = index2 == 0 ? _g8 : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,_g8,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index2)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp5 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g7.g), t : _g7.g.type, p : pos},offset2), t : hxsl_Type.TVec(4,_g7.t), p : pos};
				break;
			}
			let tmp6;
			switch(acc._hx_index) {
			case 0:
				let _g9 = acc.a;
				let offs3 = _g9.t == null ? _g9.pos : _g9.pos >> 2;
				tmp6 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g9.g), t : _g9.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs3 + 3)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,_g9.t), p : pos};
				break;
			case 1:
				let _g10 = acc.a;
				let _g11 = acc.delta;
				let index3 = (_g10.t == null ? _g10.pos : _g10.pos >> 2) + 3;
				let offset3 = index3 == 0 ? _g11 : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,_g11,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index3)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp6 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g10.g), t : _g10.g.type, p : pos},offset3), t : hxsl_Type.TVec(4,_g10.t), p : pos};
				break;
			}
			return { e : hxsl_TExprDef.TCall({ e : tmp1, t : tmp2, p : pos},[tmp3,tmp4,tmp5,tmp6]), t : hxsl_Type.TMat4, p : pos};
		case 8:
			let tmp7 = hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mat3x4);
			let tmp8 = hxsl_Type.TFun([]);
			let tmp9;
			switch(acc._hx_index) {
			case 0:
				let _g12 = acc.a;
				let offs4 = _g12.t == null ? _g12.pos : _g12.pos >> 2;
				tmp9 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g12.g), t : _g12.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs4)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,_g12.t), p : pos};
				break;
			case 1:
				let _g13 = acc.a;
				let _g14 = acc.delta;
				let index4 = _g13.t == null ? _g13.pos : _g13.pos >> 2;
				let offset4 = index4 == 0 ? _g14 : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,_g14,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index4)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp9 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g13.g), t : _g13.g.type, p : pos},offset4), t : hxsl_Type.TVec(4,_g13.t), p : pos};
				break;
			}
			let tmp10;
			switch(acc._hx_index) {
			case 0:
				let _g15 = acc.a;
				let offs5 = _g15.t == null ? _g15.pos : _g15.pos >> 2;
				tmp10 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g15.g), t : _g15.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs5 + 1)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,_g15.t), p : pos};
				break;
			case 1:
				let _g16 = acc.a;
				let _g17 = acc.delta;
				let index5 = (_g16.t == null ? _g16.pos : _g16.pos >> 2) + 1;
				let offset5 = index5 == 0 ? _g17 : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,_g17,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index5)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp10 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g16.g), t : _g16.g.type, p : pos},offset5), t : hxsl_Type.TVec(4,_g16.t), p : pos};
				break;
			}
			let tmp11;
			switch(acc._hx_index) {
			case 0:
				let _g18 = acc.a;
				let offs6 = _g18.t == null ? _g18.pos : _g18.pos >> 2;
				tmp11 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g18.g), t : _g18.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs6 + 2)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,_g18.t), p : pos};
				break;
			case 1:
				let _g19 = acc.a;
				let _g20 = acc.delta;
				let index6 = (_g19.t == null ? _g19.pos : _g19.pos >> 2) + 2;
				let offset6 = index6 == 0 ? _g20 : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,_g20,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index6)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				tmp11 = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g19.g), t : _g19.g.type, p : pos},offset6), t : hxsl_Type.TVec(4,_g19.t), p : pos};
				break;
			}
			return { e : hxsl_TExprDef.TCall({ e : tmp7, t : tmp8, p : pos},[tmp9,tmp10,tmp11]), t : hxsl_Type.TMat3x4, p : pos};
		case 15:
			let _g21 = t.t;
			let _g22 = t.size;
			if(_g22._hx_index == 0) {
				let _g = _g22.v;
				let stride = a.size / _g | 0;
				let _g1 = [];
				let _g2 = 0;
				while(_g2 < _g) {
					let i = _g2++;
					let a1 = new hxsl__$Flatten_Alloc(a.g,a.t,a.pos + stride * i,stride);
					_g1.push(this.access(a1,_g21,pos,hxsl_ARead.AIndex(a1)));
				}
				return { e : hxsl_TExprDef.TArrayDecl(_g1), t : _g21, p : pos};
			} else {
				if(hxsl_Tools.isSampler(t)) {
					let e;
					switch(acc._hx_index) {
					case 0:
						let _g = acc.a;
						let offs = _g.t == null ? _g.pos : _g.pos >> 2;
						e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g.g), t : _g.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,_g.t), p : pos};
						break;
					case 1:
						let _g1 = acc.a;
						let _g2 = acc.delta;
						let index = _g1.t == null ? _g1.pos : _g1.pos >> 2;
						let offset = index == 0 ? _g2 : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,_g2,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
						e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g1.g), t : _g1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,_g1.t), p : pos};
						break;
					}
					e.t = t;
					return e;
				}
				let size = this.varSize(t,a.t);
				if(size > 4) {
					return hxsl_Error.t("Access not supported for " + hxsl_Tools.toString(t),null);
				}
				let e;
				switch(acc._hx_index) {
				case 0:
					let _g = acc.a;
					let offs = _g.t == null ? _g.pos : _g.pos >> 2;
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g.g), t : _g.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,_g.t), p : pos};
					break;
				case 1:
					let _g1 = acc.a;
					let _g2 = acc.delta;
					let index = _g1.t == null ? _g1.pos : _g1.pos >> 2;
					let offset = index == 0 ? _g2 : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,_g2,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g1.g), t : _g1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,_g1.t), p : pos};
					break;
				}
				if(size == 4) {
					if(a.pos == -1) {
						return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec4), t : hxsl_Type.TFun([]), p : pos},[{ e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(0)), t : hxsl_Type.TFloat, p : pos}]), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : pos};
					}
					if((a.pos & 3) != 0) {
						throw haxe_Exception.thrown("assert");
					}
				} else {
					let sw = [];
					let _g = 0;
					while(_g < size) {
						let i = _g++;
						sw.push(hxsl_Tools.SWIZ[i + (a.pos & 3)]);
					}
					e = { e : hxsl_TExprDef.TSwiz(e,sw), t : t, p : pos};
				}
				switch(t._hx_index) {
				case 1:
					e.t = hxsl_Type.TFloat;
					e = this.toInt(e);
					break;
				case 5:
					let _g3 = t.size;
					if(t.t._hx_index == 0) {
						e.t = hxsl_Type.TVec(_g3,hxsl_VecType.VFloat);
						e = { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal([hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4][_g3 - 2]), t : hxsl_Type.TFun([]), p : pos},[e]), t : t, p : pos};
					}
					break;
				default:
				}
				return e;
			}
			break;
		default:
			if(hxsl_Tools.isSampler(t)) {
				let e;
				switch(acc._hx_index) {
				case 0:
					let _g = acc.a;
					let offs = _g.t == null ? _g.pos : _g.pos >> 2;
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g.g), t : _g.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,_g.t), p : pos};
					break;
				case 1:
					let _g1 = acc.a;
					let _g2 = acc.delta;
					let index = _g1.t == null ? _g1.pos : _g1.pos >> 2;
					let offset = index == 0 ? _g2 : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,_g2,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
					e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g1.g), t : _g1.g.type, p : pos},offset), t : hxsl_Type.TVec(4,_g1.t), p : pos};
					break;
				}
				e.t = t;
				return e;
			}
			let size = this.varSize(t,a.t);
			if(size > 4) {
				return hxsl_Error.t("Access not supported for " + hxsl_Tools.toString(t),null);
			}
			let e;
			switch(acc._hx_index) {
			case 0:
				let _g23 = acc.a;
				let offs7 = _g23.t == null ? _g23.pos : _g23.pos >> 2;
				e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g23.g), t : _g23.g.type, p : pos},{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(offs7)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TVec(4,_g23.t), p : pos};
				break;
			case 1:
				let _g24 = acc.a;
				let _g25 = acc.delta;
				let index7 = _g24.t == null ? _g24.pos : _g24.pos >> 2;
				let offset7 = index7 == 0 ? _g25 : { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAdd,_g25,{ e : hxsl_TExprDef.TConst(hxsl_Const.CInt(index7)), t : hxsl_Type.TInt, p : pos}), t : hxsl_Type.TInt, p : pos};
				e = { e : hxsl_TExprDef.TArray({ e : hxsl_TExprDef.TVar(_g24.g), t : _g24.g.type, p : pos},offset7), t : hxsl_Type.TVec(4,_g24.t), p : pos};
				break;
			}
			if(size == 4) {
				if(a.pos == -1) {
					return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Vec4), t : hxsl_Type.TFun([]), p : pos},[{ e : hxsl_TExprDef.TConst(hxsl_Const.CFloat(0)), t : hxsl_Type.TFloat, p : pos}]), t : hxsl_Type.TVec(4,hxsl_VecType.VFloat), p : pos};
				}
				if((a.pos & 3) != 0) {
					throw haxe_Exception.thrown("assert");
				}
			} else {
				let sw = [];
				let _g = 0;
				while(_g < size) {
					let i = _g++;
					sw.push(hxsl_Tools.SWIZ[i + (a.pos & 3)]);
				}
				e = { e : hxsl_TExprDef.TSwiz(e,sw), t : t, p : pos};
			}
			switch(t._hx_index) {
			case 1:
				e.t = hxsl_Type.TFloat;
				e = this.toInt(e);
				break;
			case 5:
				let _g26 = t.size;
				if(t.t._hx_index == 0) {
					e.t = hxsl_Type.TVec(_g26,hxsl_VecType.VFloat);
					e = { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal([hxsl_TGlobal.IVec2,hxsl_TGlobal.IVec3,hxsl_TGlobal.IVec4][_g26 - 2]), t : hxsl_Type.TFun([]), p : pos},[e]), t : t, p : pos};
				}
				break;
			default:
			}
			return e;
		}
	}
	toInt(e) {
		if(e.t == hxsl_Type.TInt) {
			return e;
		}
		return { e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.ToInt), t : hxsl_Type.TFun([]), p : e.p},[e]), t : hxsl_Type.TInt, p : e.p};
	}
	optimize(e) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 8:
			let _g1 = _g.args;
			let _g2 = _g.e.e;
			if(_g2._hx_index == 2) {
				if(_g2.g._hx_index == 52) {
					if(_g1.length == 1) {
						let _g = _g1[0].e;
						if(_g._hx_index == 8) {
							let _g1 = _g.args;
							let _g2 = _g.e.e;
							if(_g2._hx_index == 2) {
								if(_g2.g._hx_index == 51) {
									let rem = 0;
									let size = 0;
									while(size < 4) {
										let t = _g1[_g1.length - 1 - rem].t;
										size += this.varSize(t,hxsl_VecType.VFloat);
										++rem;
									}
									if(size == 4) {
										let _g = 0;
										let _g2 = rem;
										while(_g < _g2) {
											++_g;
											_g1.pop();
										}
										let emat;
										let _g3 = e.e;
										if(_g3._hx_index == 8) {
											emat = _g3.e;
										} else {
											throw haxe_Exception.thrown("assert");
										}
										return { e : hxsl_TExprDef.TCall(emat,_g1), t : e.t, p : e.p};
									}
								}
							}
						}
					}
				}
			}
			break;
		case 16:
			let _g3 = _g.e.e;
			if(_g3._hx_index == 17) {
				let _g1 = _g3.el;
				let _g2 = _g.index.e;
				if(_g2._hx_index == 0) {
					let _g = _g2.c;
					if(_g._hx_index == 2) {
						let _g2 = _g.v;
						if(_g2 >= 0 && _g2 < _g1.length) {
							return _g1[_g2];
						}
						hxsl_Error.t("Reading outside array bounds",e.p);
					}
				}
			}
			break;
		default:
		}
		return e;
	}
	packTextures(name,vars,t) {
		let alloc = [];
		let g = { id : hxsl_Tools.allocVarId(), name : name, type : t, kind : hxsl_VarKind.Param};
		let pos = 0;
		let samplers = [];
		let _g = 0;
		while(_g < vars.length) {
			let v = vars[_g];
			++_g;
			let count = 1;
			if(v.type != t) {
				let _g = v.type;
				switch(_g._hx_index) {
				case 15:
					let _g1 = _g.size;
					if(_g1._hx_index == 0) {
						if(_g.t == t) {
							count = _g1.v;
						} else {
							continue;
						}
					} else {
						continue;
					}
					break;
				case 17:
					if(t != hxsl_Type.TSampler2D) {
						continue;
					}
					break;
				default:
					continue;
				}
			}
			let a = new hxsl__$Flatten_Alloc(g,null,pos,count);
			a.v = v;
			if(v.qualifiers != null) {
				let _g = 0;
				let _g1 = v.qualifiers;
				while(_g < _g1.length) {
					let q = _g1[_g];
					++_g;
					if(q._hx_index == 12) {
						let _g = q.name;
						let _g1 = 0;
						let _g2 = count;
						while(_g1 < _g2) {
							let i = _g1++;
							samplers[pos + i] = _g;
						}
					}
				}
			}
			this.varMap.set(v,a);
			alloc.push(a);
			pos += count;
		}
		g.type = hxsl_Type.TArray(t,hxsl_SizeDecl.SConst(pos));
		if(samplers.length > 0) {
			let _g = 0;
			let _g1 = pos;
			while(_g < _g1) {
				let i = _g++;
				if(samplers[i] == null) {
					samplers[i] = "";
				}
			}
			if(g.qualifiers == null) {
				g.qualifiers = [];
			}
			g.qualifiers.push(hxsl_VarQualifier.Sampler(samplers.join(",")));
		}
		if(alloc.length > 0) {
			this.outVars.push(g);
			this.allocData.set(g,alloc);
		}
		return alloc;
	}
	packBuffers(vars) {
		let alloc = [];
		let g = { id : hxsl_Tools.allocVarId(), name : "buffers", type : hxsl_Type.TVoid, kind : hxsl_VarKind.Param};
		let _g = 0;
		while(_g < vars.length) {
			let v = vars[_g];
			++_g;
			if(v.type._hx_index == 16) {
				let a = new hxsl__$Flatten_Alloc(g,null,alloc.length,1);
				a.v = v;
				alloc.push(a);
				this.outVars.push(v);
			}
		}
		g.type = hxsl_Type.TArray(hxsl_Type.TBuffer(hxsl_Type.TVoid,hxsl_SizeDecl.SConst(0)),hxsl_SizeDecl.SConst(alloc.length));
		this.allocData.set(g,alloc);
	}
	pack(name,kind,vars,t) {
		let alloc = [];
		let apos = 0;
		let g = { id : hxsl_Tools.allocVarId(), name : name, type : hxsl_Type.TVec(0,t), kind : kind};
		let _g = 0;
		while(_g < vars.length) {
			let v = vars[_g];
			++_g;
			if(hxsl_Tools.isSampler(v.type) || v.type._hx_index == 16) {
				continue;
			}
			let _g1 = v.type;
			if(_g1._hx_index == 15) {
				if(hxsl_Tools.isSampler(_g1.t)) {
					continue;
				}
			}
			let size = this.varSize(v.type,t);
			if(size == 0) {
				let a = new hxsl__$Flatten_Alloc(g,t,-1,size);
				a.v = v;
				this.varMap.set(v,a);
				continue;
			}
			let best = null;
			let _g2 = 0;
			while(_g2 < alloc.length) {
				let a = alloc[_g2];
				++_g2;
				if(a.v == null && a.size >= size && (best == null || best.size > a.size)) {
					best = a;
				}
			}
			if(best != null) {
				let free = best.size - size;
				if(free > 0) {
					let i = alloc.indexOf(best);
					let a = new hxsl__$Flatten_Alloc(g,t,best.pos + size,free);
					alloc.splice(i + 1,0,a);
					best.size = size;
				}
				best.v = v;
				this.varMap.set(v,best);
			} else {
				let a = new hxsl__$Flatten_Alloc(g,t,apos,size);
				apos += size;
				a.v = v;
				this.varMap.set(v,a);
				alloc.push(a);
				let pad = (4 - size % 4) % 4;
				if(pad > 0) {
					let a = new hxsl__$Flatten_Alloc(g,t,apos,pad);
					apos += pad;
					alloc.push(a);
				}
			}
		}
		g.type = hxsl_Type.TArray(hxsl_Type.TVec(4,t),hxsl_SizeDecl.SConst(apos >> 2));
		if(apos > 0) {
			this.outVars.push(g);
			this.allocData.set(g,alloc);
		}
		return g;
	}
	varSize(v,t) {
		switch(v._hx_index) {
		case 1:case 3:
			if(t == hxsl_VecType.VFloat) {
				return 1;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 5:
			if(t == v.t) {
				return v.size;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 7:
			if(t == hxsl_VecType.VFloat) {
				return 16;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 6:case 8:
			if(t == hxsl_VecType.VFloat) {
				return 12;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		case 15:
			let _g = v.size;
			if(_g._hx_index == 0) {
				return this.varSize(v.t,t) * _g.v;
			} else {
				throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
			}
			break;
		default:
			throw haxe_Exception.thrown(hxsl_Tools.toString(v) + " size unknown for type " + Std.string(t));
		}
	}
	gatherVar(v) {
		let _g = v.type;
		if(_g._hx_index == 13) {
			let _g1 = _g.vl;
			let _g2 = 0;
			while(_g2 < _g1.length) {
				let v = _g1[_g2];
				++_g2;
				this.gatherVar(v);
			}
		} else {
			switch(v.kind._hx_index) {
			case 0:
				if(hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.PerObject)) {
					this.params.push(v);
				} else {
					this.globals.push(v);
				}
				break;
			case 2:
				this.params.push(v);
				break;
			default:
				this.outVars.push(v);
			}
		}
	}
}
$hxClasses["hxsl.Flatten"] = hxsl_Flatten;
hxsl_Flatten.__name__ = "hxsl.Flatten";
Object.assign(hxsl_Flatten.prototype, {
	__class__: hxsl_Flatten
	,globals: null
	,params: null
	,outVars: null
	,varMap: null
	,econsts: null
	,consts: null
	,allocData: null
});
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __interfLoop(cc,cl) {
		while(true) {
			if(cc == null) {
				return false;
			}
			if(cc == cl) {
				return true;
			}
			let intf = cc.__interfaces__;
			if(intf != null && (cc.__super__ == null || cc.__super__.__interfaces__ != intf)) {
				let _g = 0;
				let _g1 = intf.length;
				while(_g < _g1) {
					let i = _g++;
					let i1 = intf[i];
					if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
						return true;
					}
				}
			}
			cc = cc.__super__;
		}
	}
	static __instanceof(o,cl) {
		if(cl == null) {
			return false;
		}
		switch(cl) {
		case Array:
			return ((o) instanceof Array);
		case Bool:
			return typeof(o) == "boolean";
		case Dynamic:
			return o != null;
		case Float:
			return typeof(o) == "number";
		case Int:
			if(typeof(o) == "number") {
				return ((o | 0) === o);
			} else {
				return false;
			}
			break;
		case String:
			return typeof(o) == "string";
		default:
			if(o != null) {
				if(typeof(cl) == "function") {
					if(js_Boot.__downcastCheck(o,cl)) {
						return true;
					}
				} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
					if(((o) instanceof cl)) {
						return true;
					}
				}
			} else {
				return false;
			}
			if(cl == Class ? o.__name__ != null : false) {
				return true;
			}
			if(cl == Enum ? o.__ename__ != null : false) {
				return true;
			}
			return o.__enum__ != null ? $hxEnums[o.__enum__] == cl : false;
		}
	}
	static __downcastCheck(o,cl) {
		if(!((o) instanceof cl)) {
			if(cl.__isInterface__) {
				return js_Boot.__interfLoop(js_Boot.getClass(o),cl);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static __cast(o,t) {
		if(o == null || js_Boot.__instanceof(o,t)) {
			return o;
		} else {
			throw haxe_Exception.thrown("Cannot cast " + Std.string(o) + " to " + Std.string(t));
		}
	}
	static __nativeClassName(o) {
		let name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __isNativeObj(o) {
		return js_Boot.__nativeClassName(o) != null;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = "js.Boot";
class hxsl_GlslOut {
	constructor() {
		this.outIndex = 0;
		this.uniformBuffer = 0;
		this.exprIds = 0;
		this.varNames = new haxe_ds_IntMap();
		this.allNames = new haxe_ds_StringMap();
	}
	decl(s) {
		let _g = 0;
		let _g1 = this.decls;
		while(_g < _g1.length) {
			let d = _g1[_g];
			++_g;
			if(d == s) {
				return;
			}
		}
		if(HxOverrides.cca(s,0) == 35) {
			this.decls.unshift(s);
		} else {
			this.decls.push(s);
		}
	}
	addType(t) {
		switch(t._hx_index) {
		case 0:
			this.buf.b += "void";
			break;
		case 1:
			this.buf.b += "int";
			break;
		case 2:
			this.buf.b += "bool";
			break;
		case 3:
			this.buf.b += "float";
			break;
		case 4:
			this.buf.b += "string";
			break;
		case 5:
			let _g = t.size;
			switch(t.t._hx_index) {
			case 0:
				this.buf.b += "i";
				break;
			case 1:
				break;
			case 2:
				this.buf.b += "b";
				break;
			}
			this.buf.b += "vec";
			this.buf.b += Std.string(_g);
			break;
		case 6:
			this.buf.b += "mat3";
			break;
		case 7:
			this.buf.b += "mat4";
			break;
		case 8:
			this.decl(hxsl_GlslOut.MAT34);
			this.buf.b += "_mat3x4";
			break;
		case 9:
			this.buf.b += "vec";
			this.buf.b += Std.string(t.size);
			break;
		case 10:
			this.buf.b += "sampler2D";
			break;
		case 11:
			this.buf.b += "sampler2DArray";
			if(this.glES != null) {
				this.decl("precision lowp sampler2DArray;");
			}
			break;
		case 12:
			this.buf.b += "samplerCube";
			break;
		case 13:
			let _g1 = t.vl;
			this.buf.b += "struct { ";
			let _g2 = 0;
			while(_g2 < _g1.length) {
				let v = _g1[_g2];
				++_g2;
				this.addVar(v);
				this.buf.b += ";";
			}
			this.buf.b += " }";
			break;
		case 14:
			this.buf.b += "function";
			break;
		case 15:
			let _g3 = t.size;
			this.addType(t.t);
			this.buf.b += "[";
			switch(_g3._hx_index) {
			case 0:
				let _g4 = _g3.v;
				if(_g4 == 1) {
					if(this.intelDriverFix) {
						this.buf.b += "2";
					} else {
						this.buf.b += Std.string(_g4);
					}
				} else {
					this.buf.b += Std.string(_g4);
				}
				break;
			case 1:
				let v = this.varName(_g3.v);
				this.buf.b += Std.string(v);
				break;
			}
			this.buf.b += "]";
			break;
		case 16:
			throw haxe_Exception.thrown("assert");
		case 17:
			this.buf.b += Std.string("channel" + t.size);
			break;
		case 18:
			this.buf.b += "mat2";
			break;
		}
	}
	addVar(v) {
		let _g = v.type;
		switch(_g._hx_index) {
		case 15:
			let _g1 = _g.size;
			let old = v.type;
			v.type = _g.t;
			this.addVar(v);
			v.type = old;
			this.buf.b += "[";
			switch(_g1._hx_index) {
			case 0:
				let _g2 = _g1.v;
				if(_g2 == 1) {
					if(this.intelDriverFix) {
						this.buf.b += "2";
					} else {
						this.buf.b += Std.string(_g2);
					}
				} else {
					this.buf.b += Std.string(_g2);
				}
				break;
			case 1:
				let v1 = this.varName(_g1.v);
				this.buf.b += Std.string(v1);
				break;
			}
			this.buf.b += "]";
			break;
		case 16:
			let _g3 = _g.t;
			let _g4 = _g.size;
			this.buf.b += Std.string((this.isVertex ? "vertex_" : "") + "uniform_buffer" + this.uniformBuffer++);
			this.buf.b += " { ";
			v.type = hxsl_Type.TArray(_g3,_g4);
			this.addVar(v);
			v.type = hxsl_Type.TBuffer(_g3,_g4);
			this.buf.b += "; }";
			break;
		default:
			this.addType(v.type);
			this.buf.b += " ";
			let v2 = this.varName(v);
			this.buf.b += Std.string(v2);
		}
	}
	addValue(e,tabs) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 4:
			let name = "val" + this.exprIds++;
			let tmp = this.buf;
			this.buf = new StringBuf();
			this.addType(e.t);
			this.buf.b += " ";
			this.buf.b += Std.string(name);
			this.buf.b += "(void)";
			let el2 = _g.el.slice();
			let last = el2[el2.length - 1];
			el2[el2.length - 1] = { e : hxsl_TExprDef.TReturn(last), t : e.t, p : last.p};
			let e2 = { t : hxsl_Type.TVoid, e : hxsl_TExprDef.TBlock(el2), p : e.p};
			this.addExpr(e2,"");
			this.exprValues.push(this.buf.b);
			this.buf = tmp;
			this.buf.b += Std.string(name);
			this.buf.b += "()";
			break;
		case 10:
			this.buf.b += "( ";
			this.addValue(_g.econd,tabs);
			this.buf.b += " ) ? ";
			this.addValue(_g.eif,tabs);
			this.buf.b += " : ";
			this.addValue(_g.eelse,tabs);
			break;
		case 20:
			this.addValue(_g.e,tabs);
			break;
		default:
			this.addExpr(e,tabs);
		}
	}
	addBlock(e,tabs) {
		this.addExpr(e,tabs);
	}
	getFunName(g,args,rt) {
		switch(g._hx_index) {
		case 20:
			if(rt == hxsl_Type.TInt && this.glES != null) {
				this.decl("int _imod( int x, int y ) { return int(mod(float(x),float(y))); }");
				return "_imod";
			}
			break;
		case 33:
			switch(args[0].t._hx_index) {
			case 10:case 11:
				if(this.glES != null && this.glES <= 2) {
					return "texture2D";
				}
				break;
			case 12:
				if(this.glES != null && this.glES <= 2) {
					return "textureCube";
				}
				break;
			case 17:
				if(this.glES != null && this.glES <= 2) {
					return "texture2D";
				}
				break;
			default:
			}
			break;
		case 34:
			switch(args[0].t._hx_index) {
			case 10:case 11:
				if(this.glES != null && this.glES <= 2) {
					this.decl("#extension GL_EXT_shader_texture_lod : enable");
					return "texture2DLodEXT";
				}
				break;
			case 12:
				if(this.glES != null && this.glES <= 2) {
					this.decl("#extension GL_EXT_shader_texture_lod : enable");
					return "textureCubeLodEXT";
				}
				break;
			case 17:
				if(this.glES != null && this.glES <= 2) {
					this.decl("#extension GL_EXT_shader_texture_lod : enable");
					return "texture2DLodEXT";
				}
				break;
			default:
			}
			break;
		case 35:
			return "texelFetch";
		case 36:
			switch(args[0].t._hx_index) {
			case 10:
				this.decl("vec2 _textureSize(sampler2D sampler, int lod) { return vec2(textureSize(sampler, lod)); }");
				break;
			case 11:
				this.decl("vec3 _textureSize(sampler2DArray sampler, int lod) { return vec3(textureSize(sampler, lod)); }");
				break;
			case 12:
				this.decl("vec2 _textureSize(samplerCube sampler, int lod) { return vec2(textureSize(sampler, lod)); }");
				break;
			case 17:
				this.decl("vec2 _textureSize(sampler2D sampler, int lod) { return vec2(textureSize(sampler, lod)); }");
				break;
			default:
			}
			return "_textureSize";
		case 50:
			if(args[0].t == hxsl_Type.TMat3x4) {
				this.decl(hxsl_GlslOut.MAT34);
				this.decl("mat3 _mat3( _mat3x4 v ) { return mat3(v.a.xyz,v.b.xyz,v.c.xyz); }");
				return "_mat3";
			}
			break;
		case 52:
			this.decl(hxsl_GlslOut.MAT34);
			if(args.length == 1) {
				this.decl("_mat3x4 mat_to_34( mat4 m ) { return _mat3x4(m[0],m[1],m[2]); }");
				return "mat_to_34";
			}
			break;
		case 54:
			this.decl("vec4 pack( float v ) { vec4 color = fract(v * vec4(1, 255, 255.*255., 255.*255.*255.)); return color - color.yzww * vec4(1. / 255., 1. / 255., 1. / 255., 0.); }");
			break;
		case 55:
			this.decl("float unpack( vec4 color ) { return dot(color,vec4(1., 1. / 255., 1. / (255. * 255.), 1. / (255. * 255. * 255.))); }");
			break;
		case 56:
			this.decl("vec4 packNormal( vec3 v ) { return vec4((v + vec3(1.)) * vec3(0.5),1.); }");
			break;
		case 57:
			this.decl("vec3 unpackNormal( vec4 v ) { return normalize((v.xyz - vec3(0.5)) * vec3(2.)); }");
			break;
		case 58:
			this.decl("vec2 screenToUv( vec2 v ) { return v * vec2(0.5,-0.5) + vec2(0.5,0.5); }");
			break;
		case 59:
			this.decl("vec2 uvToScreen( vec2 v ) { return v * vec2(2.,-2.) + vec2(-1., 1.); }");
			break;
		case 60:case 61:case 62:
			if(this.isVertex) {
				throw haxe_Exception.thrown("Can't use " + Std.string(g) + " in vertex shader");
			}
			if(this.version < 300) {
				this.decl("#extension GL_OES_standard_derivatives:enable");
			}
			break;
		default:
		}
		return hxsl_GlslOut.GLOBALS[g._hx_index];
	}
	addExpr(e,tabs) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 0:
			let _g1 = _g.c;
			switch(_g1._hx_index) {
			case 0:
				this.buf.b += "null";
				break;
			case 1:
				this.buf.b += Std.string(_g1.b);
				break;
			case 2:
				this.buf.b += Std.string(_g1.v);
				break;
			case 3:
				let str = "" + _g1.v;
				this.buf.b += Std.string(str);
				if(str.indexOf(".") == -1 && str.indexOf("e") == -1) {
					this.buf.b += ".";
				}
				break;
			case 4:
				this.buf.b += Std.string("\"" + _g1.v + "\"");
				break;
			}
			break;
		case 1:
			let v = this.varName(_g.v);
			this.buf.b += Std.string(v);
			break;
		case 2:
			this.buf.b += Std.string(hxsl_GlslOut.GLOBALS[_g.g._hx_index]);
			break;
		case 3:
			this.buf.b += "(";
			this.addValue(_g.e,tabs);
			this.buf.b += ")";
			break;
		case 4:
			let _g2 = _g.el;
			this.buf.b += "{\n";
			let t2 = tabs + "\t";
			let _g3 = 0;
			while(_g3 < _g2.length) {
				let e = _g2[_g3];
				++_g3;
				this.buf.b += Std.string(t2);
				this.addExpr(e,t2);
				this.newLine(e);
			}
			this.buf.b += Std.string(tabs);
			this.buf.b += "}";
			break;
		case 5:
			let _g4 = _g.op;
			let _g5 = _g.e1;
			let _g6 = _g.e2;
			let _g7 = _g5.t;
			let _g8 = _g6.t;
			switch(_g4._hx_index) {
			case 1:
				if(_g7._hx_index == 5) {
					if(_g7.size == 3) {
						if(_g7.t._hx_index == 1) {
							if(_g8._hx_index == 8) {
								this.decl(hxsl_GlslOut.MAT34);
								this.decl("vec3 m3x4mult( vec3 v, _mat3x4 m) { vec4 ve = vec4(v,1.0); return vec3(dot(m.a,ve),dot(m.b,ve),dot(m.c,ve)); }");
								if(_g4._hx_index == 20) {
									this.addValue(_g5,tabs);
									this.buf.b += " = ";
								}
								this.buf.b += "m3x4mult(";
								this.addValue(_g5,tabs);
								this.buf.b += ",";
								this.addValue(_g6,tabs);
								this.buf.b += ")";
							} else {
								this.addValue(_g5,tabs);
								this.buf.b += " ";
								this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
								this.buf.b += " ";
								this.addValue(_g6,tabs);
							}
						} else {
							this.addValue(_g5,tabs);
							this.buf.b += " ";
							this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
							this.buf.b += " ";
							this.addValue(_g6,tabs);
						}
					} else {
						this.addValue(_g5,tabs);
						this.buf.b += " ";
						this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
						this.buf.b += " ";
						this.addValue(_g6,tabs);
					}
				} else {
					this.addValue(_g5,tabs);
					this.buf.b += " ";
					this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
					this.buf.b += " ";
					this.addValue(_g6,tabs);
				}
				break;
			case 5:
				if(_g7._hx_index == 5) {
					if(_g8._hx_index == 5) {
						this.buf.b += Std.string("vec" + _g7.size + "(");
						let v;
						switch(_g4._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += "(";
						this.addValue(_g5,tabs);
						this.buf.b += ",";
						this.addValue(_g6,tabs);
						this.buf.b += "))";
					} else {
						this.addValue(_g5,tabs);
						this.buf.b += " ";
						this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
						this.buf.b += " ";
						this.addValue(_g6,tabs);
					}
				} else {
					this.addValue(_g5,tabs);
					this.buf.b += " ";
					this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
					this.buf.b += " ";
					this.addValue(_g6,tabs);
				}
				break;
			case 6:
				if(_g7._hx_index == 5) {
					if(_g8._hx_index == 5) {
						this.buf.b += Std.string("vec" + _g7.size + "(");
						let v;
						switch(_g4._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += "(";
						this.addValue(_g5,tabs);
						this.buf.b += ",";
						this.addValue(_g6,tabs);
						this.buf.b += "))";
					} else {
						this.addValue(_g5,tabs);
						this.buf.b += " ";
						this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
						this.buf.b += " ";
						this.addValue(_g6,tabs);
					}
				} else {
					this.addValue(_g5,tabs);
					this.buf.b += " ";
					this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
					this.buf.b += " ";
					this.addValue(_g6,tabs);
				}
				break;
			case 7:
				if(_g7._hx_index == 5) {
					if(_g8._hx_index == 5) {
						this.buf.b += Std.string("vec" + _g7.size + "(");
						let v;
						switch(_g4._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += "(";
						this.addValue(_g5,tabs);
						this.buf.b += ",";
						this.addValue(_g6,tabs);
						this.buf.b += "))";
					} else {
						this.addValue(_g5,tabs);
						this.buf.b += " ";
						this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
						this.buf.b += " ";
						this.addValue(_g6,tabs);
					}
				} else {
					this.addValue(_g5,tabs);
					this.buf.b += " ";
					this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
					this.buf.b += " ";
					this.addValue(_g6,tabs);
				}
				break;
			case 8:
				if(_g7._hx_index == 5) {
					if(_g8._hx_index == 5) {
						this.buf.b += Std.string("vec" + _g7.size + "(");
						let v;
						switch(_g4._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += "(";
						this.addValue(_g5,tabs);
						this.buf.b += ",";
						this.addValue(_g6,tabs);
						this.buf.b += "))";
					} else {
						this.addValue(_g5,tabs);
						this.buf.b += " ";
						this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
						this.buf.b += " ";
						this.addValue(_g6,tabs);
					}
				} else {
					this.addValue(_g5,tabs);
					this.buf.b += " ";
					this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
					this.buf.b += " ";
					this.addValue(_g6,tabs);
				}
				break;
			case 9:
				if(_g7._hx_index == 5) {
					if(_g8._hx_index == 5) {
						this.buf.b += Std.string("vec" + _g7.size + "(");
						let v;
						switch(_g4._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += "(";
						this.addValue(_g5,tabs);
						this.buf.b += ",";
						this.addValue(_g6,tabs);
						this.buf.b += "))";
					} else {
						this.addValue(_g5,tabs);
						this.buf.b += " ";
						this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
						this.buf.b += " ";
						this.addValue(_g6,tabs);
					}
				} else {
					this.addValue(_g5,tabs);
					this.buf.b += " ";
					this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
					this.buf.b += " ";
					this.addValue(_g6,tabs);
				}
				break;
			case 10:
				if(_g7._hx_index == 5) {
					if(_g8._hx_index == 5) {
						this.buf.b += Std.string("vec" + _g7.size + "(");
						let v;
						switch(_g4._hx_index) {
						case 5:
							v = "equal";
							break;
						case 6:
							v = "notEqual";
							break;
						case 7:
							v = "greaterThan";
							break;
						case 8:
							v = "greaterThanEqual";
							break;
						case 9:
							v = "lessThan";
							break;
						case 10:
							v = "lessThanEqual";
							break;
						default:
							throw haxe_Exception.thrown("assert");
						}
						this.buf.b += Std.string(v);
						this.buf.b += "(";
						this.addValue(_g5,tabs);
						this.buf.b += ",";
						this.addValue(_g6,tabs);
						this.buf.b += "))";
					} else {
						this.addValue(_g5,tabs);
						this.buf.b += " ";
						this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
						this.buf.b += " ";
						this.addValue(_g6,tabs);
					}
				} else {
					this.addValue(_g5,tabs);
					this.buf.b += " ";
					this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
					this.buf.b += " ";
					this.addValue(_g6,tabs);
				}
				break;
			case 18:
				this.decl("int _ushr( int i, int j ) { return int(uint(i) >> uint(j)); }");
				this.buf.b += "_ushr(";
				this.addValue(_g5,tabs);
				this.buf.b += ",";
				this.addValue(_g6,tabs);
				this.buf.b += ")";
				break;
			case 19:
				if(e.t != hxsl_Type.TInt) {
					if(_g4._hx_index == 20) {
						this.addValue(_g5,tabs);
						this.buf.b += " = ";
					}
					this.addExpr({ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mod), t : hxsl_Type.TFun([]), p : e.p},[_g5,_g6]), t : e.t, p : e.p},tabs);
				} else {
					this.addValue(_g5,tabs);
					this.buf.b += " ";
					this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
					this.buf.b += " ";
					this.addValue(_g6,tabs);
				}
				break;
			case 20:
				switch(_g4.op._hx_index) {
				case 1:
					if(_g7._hx_index == 5) {
						if(_g7.size == 3) {
							if(_g7.t._hx_index == 1) {
								if(_g8._hx_index == 8) {
									this.decl(hxsl_GlslOut.MAT34);
									this.decl("vec3 m3x4mult( vec3 v, _mat3x4 m) { vec4 ve = vec4(v,1.0); return vec3(dot(m.a,ve),dot(m.b,ve),dot(m.c,ve)); }");
									if(_g4._hx_index == 20) {
										this.addValue(_g5,tabs);
										this.buf.b += " = ";
									}
									this.buf.b += "m3x4mult(";
									this.addValue(_g5,tabs);
									this.buf.b += ",";
									this.addValue(_g6,tabs);
									this.buf.b += ")";
								} else {
									this.addValue(_g5,tabs);
									this.buf.b += " ";
									this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
									this.buf.b += " ";
									this.addValue(_g6,tabs);
								}
							} else {
								this.addValue(_g5,tabs);
								this.buf.b += " ";
								this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
								this.buf.b += " ";
								this.addValue(_g6,tabs);
							}
						} else {
							this.addValue(_g5,tabs);
							this.buf.b += " ";
							this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
							this.buf.b += " ";
							this.addValue(_g6,tabs);
						}
					} else {
						this.addValue(_g5,tabs);
						this.buf.b += " ";
						this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
						this.buf.b += " ";
						this.addValue(_g6,tabs);
					}
					break;
				case 19:
					if(e.t != hxsl_Type.TInt) {
						if(_g4._hx_index == 20) {
							this.addValue(_g5,tabs);
							this.buf.b += " = ";
						}
						this.addExpr({ e : hxsl_TExprDef.TCall({ e : hxsl_TExprDef.TGlobal(hxsl_TGlobal.Mod), t : hxsl_Type.TFun([]), p : e.p},[_g5,_g6]), t : e.t, p : e.p},tabs);
					} else {
						this.addValue(_g5,tabs);
						this.buf.b += " ";
						this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
						this.buf.b += " ";
						this.addValue(_g6,tabs);
					}
					break;
				default:
					this.addValue(_g5,tabs);
					this.buf.b += " ";
					this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
					this.buf.b += " ";
					this.addValue(_g6,tabs);
				}
				break;
			default:
				this.addValue(_g5,tabs);
				this.buf.b += " ";
				this.buf.b += Std.string(hxsl_Printer.opStr(_g4));
				this.buf.b += " ";
				this.addValue(_g6,tabs);
			}
			break;
		case 6:
			let _g9 = _g.e1;
			let v1;
			switch(_g.op._hx_index) {
			case 0:
				v1 = "++";
				break;
			case 1:
				v1 = "--";
				break;
			case 2:
				v1 = "!";
				break;
			case 3:
				v1 = "-";
				break;
			case 4:
				v1 = "~";
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			this.buf.b += Std.string(v1);
			this.addValue(_g9,tabs);
			break;
		case 7:
			let _g10 = _g.v;
			let _g11 = _g.init;
			this.locals.h[_g10.id] = _g10;
			if(_g11 != null) {
				let v = this.varName(_g10);
				this.buf.b += Std.string(v);
				this.buf.b += " = ";
				this.addValue(_g11,tabs);
			} else {
				this.buf.b += "/*var*/";
			}
			break;
		case 8:
			let _g12 = _g.e;
			let _g13 = _g.args;
			let _g14 = _g12.e;
			if(_g14._hx_index == 2) {
				let _g = _g14.g;
				switch(_g._hx_index) {
				case 35:
					let v = this.getFunName(_g,_g13,e.t);
					this.buf.b += Std.string(v);
					this.buf.b += "(";
					this.addValue(_g13[0],tabs);
					this.buf.b += ", ";
					this.addValue(_g13[1],tabs);
					if(_g13.length != 2) {
						this.buf.b += ", ";
						this.addValue(_g13[2],tabs);
						this.buf.b += ")";
					} else {
						this.buf.b += ", 0)";
					}
					break;
				case 36:
					let v1 = this.getFunName(_g,_g13,e.t);
					this.buf.b += Std.string(v1);
					this.buf.b += "(";
					this.addValue(_g13[0],tabs);
					if(_g13.length != 1) {
						this.buf.b += ", ";
						this.addValue(_g13[1],tabs);
						this.buf.b += ")";
					} else {
						this.buf.b += ", 0)";
					}
					break;
				case 53:
					if(_g13.length == 1) {
						let _g = _g13[0];
						this.buf.b += "clamp(";
						this.addValue(_g,tabs);
						this.buf.b += ", 0., 1.)";
					} else {
						let _g = _g12.e;
						if(_g._hx_index == 2) {
							let v = this.getFunName(_g.g,_g13,e.t);
							this.buf.b += Std.string(v);
						} else {
							this.addValue(_g12,tabs);
						}
						this.buf.b += "(";
						let first = true;
						let _g1 = 0;
						while(_g1 < _g13.length) {
							let e = _g13[_g1];
							++_g1;
							if(first) {
								first = false;
							} else {
								this.buf.b += ", ";
							}
							this.addValue(e,tabs);
						}
						this.buf.b += ")";
					}
					break;
				default:
					let _g1 = _g12.e;
					if(_g1._hx_index == 2) {
						let v = this.getFunName(_g1.g,_g13,e.t);
						this.buf.b += Std.string(v);
					} else {
						this.addValue(_g12,tabs);
					}
					this.buf.b += "(";
					let first = true;
					let _g2 = 0;
					while(_g2 < _g13.length) {
						let e = _g13[_g2];
						++_g2;
						if(first) {
							first = false;
						} else {
							this.buf.b += ", ";
						}
						this.addValue(e,tabs);
					}
					this.buf.b += ")";
				}
			} else {
				let _g = _g12.e;
				if(_g._hx_index == 2) {
					let v = this.getFunName(_g.g,_g13,e.t);
					this.buf.b += Std.string(v);
				} else {
					this.addValue(_g12,tabs);
				}
				this.buf.b += "(";
				let first = true;
				let _g1 = 0;
				while(_g1 < _g13.length) {
					let e = _g13[_g1];
					++_g1;
					if(first) {
						first = false;
					} else {
						this.buf.b += ", ";
					}
					this.addValue(e,tabs);
				}
				this.buf.b += ")";
			}
			break;
		case 9:
			let _g15 = _g.e;
			let _g16 = _g.regs;
			if(_g15.t._hx_index == 3) {
				let _g = 0;
				while(_g < _g16.length) {
					let r = _g16[_g];
					++_g;
					if(r != hxsl_Component.X) {
						throw haxe_Exception.thrown("assert");
					}
				}
				switch(_g16.length) {
				case 1:
					this.addValue(_g15,tabs);
					break;
				case 2:
					this.decl("vec2 _vec2( float v ) { return vec2(v,v); }");
					this.buf.b += "_vec2(";
					this.addValue(_g15,tabs);
					this.buf.b += ")";
					break;
				case 3:
					this.decl("vec3 _vec3( float v ) { return vec3(v,v,v); }");
					this.buf.b += "_vec3(";
					this.addValue(_g15,tabs);
					this.buf.b += ")";
					break;
				case 4:
					this.decl("vec4 _vec4( float v ) { return vec4(v,v,v,v); }");
					this.buf.b += "_vec4(";
					this.addValue(_g15,tabs);
					this.buf.b += ")";
					break;
				default:
					throw haxe_Exception.thrown("assert");
				}
			} else {
				this.addValue(_g15,tabs);
				this.buf.b += ".";
				let _g = 0;
				while(_g < _g16.length) {
					let r = _g16[_g];
					++_g;
					let _this = this.buf;
					let _this1 = _this.b;
					let tmp;
					switch(r._hx_index) {
					case 0:
						tmp = "x";
						break;
					case 1:
						tmp = "y";
						break;
					case 2:
						tmp = "z";
						break;
					case 3:
						tmp = "w";
						break;
					}
					_this.b = _this1 + Std.string(tmp);
				}
			}
			break;
		case 10:
			let _g17 = _g.eif;
			let _g18 = _g.eelse;
			this.buf.b += "if( ";
			this.addValue(_g.econd,tabs);
			this.buf.b += ") ";
			this.addExpr(_g17,tabs);
			if(_g18 != null) {
				if(!this.isBlock(_g17)) {
					this.buf.b += ";";
				}
				this.buf.b += " else ";
				this.addExpr(_g18,tabs);
			}
			break;
		case 11:
			this.buf.b += "discard";
			break;
		case 12:
			let _g19 = _g.e;
			if(_g19 == null) {
				this.buf.b += "return";
			} else {
				this.buf.b += "return ";
				this.addValue(_g19,tabs);
			}
			break;
		case 13:
			let _g20 = _g.v;
			this.locals.h[_g20.id] = _g20;
			let _g21 = _g.it.e;
			if(_g21._hx_index == 5) {
				if(_g21.op._hx_index == 21) {
					this.buf.b += "for(";
					this.buf.b += Std.string(_g20.name + "=");
					this.addValue(_g21.e1,tabs);
					this.buf.b += Std.string(";" + _g20.name + "<");
					this.addValue(_g21.e2,tabs);
					this.buf.b += Std.string(";" + _g20.name + "++) ");
					this.addBlock(_g.loop,tabs);
				} else {
					throw haxe_Exception.thrown("assert");
				}
			} else {
				throw haxe_Exception.thrown("assert");
			}
			break;
		case 14:
			this.buf.b += "continue";
			break;
		case 15:
			this.buf.b += "break";
			break;
		case 16:
			this.addValue(_g.e,tabs);
			this.buf.b += "[";
			this.addValue(_g.index,tabs);
			this.buf.b += "]";
			break;
		case 17:
			let _g22 = _g.el;
			let _g23 = e.t;
			if(_g23._hx_index == 15) {
				this.addType(_g23.t);
			} else {
				throw haxe_Exception.thrown("assert");
			}
			this.buf.b += Std.string("[" + _g22.length + "]");
			this.buf.b += "(";
			let first = true;
			let _g24 = 0;
			while(_g24 < _g22.length) {
				let e = _g22[_g24];
				++_g24;
				if(first) {
					first = false;
				} else {
					this.buf.b += ", ";
				}
				this.addValue(e,tabs);
			}
			this.buf.b += ")";
			break;
		case 18:
			this.buf.b += "switch(...)";
			break;
		case 19:
			let _g25 = _g.e;
			let _g26 = _g.loop;
			if(_g.normalWhile == false) {
				tabs += "\t";
				this.buf.b += "do ";
				this.addBlock(_g26,tabs);
				this.buf.b += " while( ";
				this.addValue(_g25,tabs);
				this.buf.b += " )";
			} else {
				this.buf.b += "while( ";
				this.addValue(_g25,tabs);
				this.buf.b += " ) ";
				this.addBlock(_g26,tabs);
			}
			break;
		case 20:
			this.addExpr(_g.e,tabs);
			break;
		}
	}
	varName(v) {
		if(v.kind == hxsl_VarKind.Output) {
			if(this.isVertex) {
				return "gl_Position";
			}
			if(this.glES != null && this.glES <= 2) {
				if(this.outIndexes == null) {
					return "gl_FragColor";
				}
				return "gl_FragData[" + this.outIndexes.h[v.id] + "]";
			}
		}
		let n = this.varNames.h[v.id];
		if(n != null) {
			return n;
		}
		n = v.name;
		if(Object.prototype.hasOwnProperty.call(hxsl_GlslOut.KWDS.h,n)) {
			n = "_" + n;
		}
		if(Object.prototype.hasOwnProperty.call(this.allNames.h,n)) {
			let k = 2;
			n += "_";
			while(Object.prototype.hasOwnProperty.call(this.allNames.h,n + k)) ++k;
			n += k;
		}
		this.varNames.h[v.id] = n;
		this.allNames.h[n] = v.id;
		return n;
	}
	newLine(e) {
		if(this.isBlock(e)) {
			this.buf.b += "\n";
		} else {
			this.buf.b += ";\n";
		}
	}
	isBlock(e) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 4:
			return true;
		case 13:
			return this.isBlock(_g.loop);
		case 19:
			if(_g.normalWhile == true) {
				return this.isBlock(_g.loop);
			} else {
				return false;
			}
			break;
		default:
			return false;
		}
	}
	initVar(v) {
		switch(v.kind._hx_index) {
		case 0:case 2:
			if(v.type._hx_index == 16) {
				this.buf.b += "layout(std140) ";
			}
			this.buf.b += "uniform ";
			break;
		case 1:
			this.buf.b += Std.string(this.glES != null && this.glES <= 2 ? "attribute " : "in ");
			break;
		case 3:
			this.buf.b += Std.string(this.glES != null && this.glES <= 2 ? "varying " : this.isVertex ? "out " : "in ");
			break;
		case 4:
			break;
		case 5:
			if(this.glES != null && this.glES <= 2) {
				this.outIndexes.h[v.id] = this.outIndex++;
				return;
			}
			if(this.isVertex) {
				return;
			}
			if(this.glES != null) {
				this.buf.b += Std.string("layout(location=" + this.outIndex++ + ") ");
			}
			this.buf.b += "out ";
			break;
		case 6:
			return;
		}
		if(v.qualifiers != null) {
			let _g = 0;
			let _g1 = v.qualifiers;
			while(_g < _g1.length) {
				let q = _g1[_g];
				++_g;
				if(q._hx_index == 6) {
					switch(q.p._hx_index) {
					case 0:
						this.buf.b += "lowp ";
						break;
					case 1:
						this.buf.b += "mediump ";
						break;
					case 2:
						this.buf.b += "highp ";
						break;
					}
				}
			}
		}
		this.addVar(v);
		this.buf.b += ";\n";
	}
	initVars(s) {
		this.outIndex = 0;
		this.uniformBuffer = 0;
		this.outIndexes = new haxe_ds_IntMap();
		let _g = 0;
		let _g1 = s.vars;
		while(_g < _g1.length) {
			let v = _g1[_g];
			++_g;
			this.initVar(v);
		}
		this.buf.b += "\n";
		if(this.outIndex < 2) {
			this.outIndexes = null;
		} else if(!this.isVertex && (this.glES != null && this.glES <= 2)) {
			this.decl("#extension GL_EXT_draw_buffers : enable");
		}
	}
	run(s) {
		this.locals = new haxe_ds_IntMap();
		this.decls = [];
		this.buf = new StringBuf();
		this.exprValues = [];
		if(s.funs.length != 1) {
			throw haxe_Exception.thrown("assert");
		}
		let f = s.funs[0];
		this.isVertex = f.kind == hxsl_FunctionKind.Vertex;
		if(this.isVertex) {
			this.decl("precision highp float;");
		} else {
			this.decl("precision mediump float;");
		}
		this.initVars(s);
		let tmp = this.buf;
		this.buf = new StringBuf();
		this.buf.b += "void main(void) {\n";
		let _g = f.expr.e;
		if(_g._hx_index == 4) {
			let _g1 = _g.el;
			let _g2 = 0;
			while(_g2 < _g1.length) {
				let e = _g1[_g2];
				++_g2;
				this.buf.b += "\t";
				this.addExpr(e,"\t");
				this.newLine(e);
			}
		} else {
			this.addExpr(f.expr,"");
		}
		if(this.isVertex) {
			this.buf.b += "\tgl_Position.z += gl_Position.z - gl_Position.w;\n";
		}
		this.buf.b += "}";
		this.exprValues.push(this.buf.b);
		this.buf = tmp;
		let locals = Lambda.array(this.locals);
		locals.sort(function(v1,v2) {
			return Reflect.compare(v1.name,v2.name);
		});
		let _g1 = 0;
		while(_g1 < locals.length) {
			let v = locals[_g1];
			++_g1;
			this.addVar(v);
			this.buf.b += ";\n";
		}
		this.buf.b += "\n";
		let _g2 = 0;
		let _g3 = this.exprValues;
		while(_g2 < _g3.length) {
			let e = _g3[_g2];
			++_g2;
			this.buf.b += Std.string(e);
			this.buf.b += "\n\n";
		}
		if(this.glES != null) {
			this.decl("#version " + (this.version < 100 ? 100 : this.version) + (this.version > 150 ? " es" : ""));
		} else if(this.version != null) {
			this.decl("#version " + (this.version > 150 ? 150 : this.version));
		} else {
			this.decl("#version 130");
		}
		this.decls.push(this.buf.b);
		this.buf = null;
		return this.decls.join("\n");
	}
}
$hxClasses["hxsl.GlslOut"] = hxsl_GlslOut;
hxsl_GlslOut.__name__ = "hxsl.GlslOut";
Object.assign(hxsl_GlslOut.prototype, {
	__class__: hxsl_GlslOut
	,buf: null
	,exprIds: null
	,exprValues: null
	,locals: null
	,decls: null
	,isVertex: null
	,allNames: null
	,outIndexes: null
	,uniformBuffer: null
	,outIndex: null
	,varNames: null
	,glES: null
	,version: null
	,intelDriverFix: null
});
class hxsl__$Linker_AllocatedVar {
	constructor() {
	}
}
$hxClasses["hxsl._Linker.AllocatedVar"] = hxsl__$Linker_AllocatedVar;
hxsl__$Linker_AllocatedVar.__name__ = "hxsl._Linker.AllocatedVar";
Object.assign(hxsl__$Linker_AllocatedVar.prototype, {
	__class__: hxsl__$Linker_AllocatedVar
	,id: null
	,v: null
	,path: null
	,merged: null
	,kind: null
	,parent: null
	,rootShaderName: null
	,instanceIndex: null
});
class hxsl__$Linker_ShaderInfos {
	constructor(n,v) {
		this.name = n;
		this.uid = hxsl__$Linker_ShaderInfos.UID++;
		this.vertex = v;
		this.processed = new haxe_ds_IntMap();
		this.usedFunctions = [];
		this.read = new haxe_ds_IntMap();
		this.write = new haxe_ds_IntMap();
	}
}
$hxClasses["hxsl._Linker.ShaderInfos"] = hxsl__$Linker_ShaderInfos;
hxsl__$Linker_ShaderInfos.__name__ = "hxsl._Linker.ShaderInfos";
Object.assign(hxsl__$Linker_ShaderInfos.prototype, {
	__class__: hxsl__$Linker_ShaderInfos
	,uid: null
	,name: null
	,priority: null
	,body: null
	,usedFunctions: null
	,deps: null
	,read: null
	,write: null
	,processed: null
	,vertex: null
	,onStack: null
	,hasDiscard: null
	,marked: null
});
class hxsl_Linker {
	constructor(batchMode) {
		if(batchMode == null) {
			batchMode = false;
		}
		this.debugDepth = 0;
		this.batchMode = batchMode;
	}
	error(msg,p) {
		return hxsl_Error.t(msg,p);
	}
	mergeVar(path,v,v2,p,shaderName) {
		switch(v.kind._hx_index) {
		case 2:
			if(!(shaderName != null && hxsl_Tools.hasBorrowQualifier(v2,shaderName))) {
				throw haxe_Exception.thrown("assert");
			}
			break;
		case 0:case 1:case 3:case 4:case 5:
			break;
		case 6:
			throw haxe_Exception.thrown("assert");
		}
		if(v.kind != v2.kind && v.kind != hxsl_VarKind.Local && v2.kind != hxsl_VarKind.Local) {
			this.error("'" + path + "' kind does not match : " + Std.string(v.kind) + " should be " + Std.string(v2.kind),p);
		}
		let _g = v.type;
		let _g1 = v2.type;
		if(_g._hx_index == 13) {
			let _g2 = _g.vl;
			if(_g1._hx_index == 13) {
				let _g = _g1.vl;
				let _g3 = 0;
				while(_g3 < _g2.length) {
					let f1 = _g2[_g3];
					++_g3;
					let ft = null;
					let _g1 = 0;
					while(_g1 < _g.length) {
						let f2 = _g[_g1];
						++_g1;
						if(f1.name == f2.name) {
							ft = f2;
							break;
						}
					}
					if(ft == null) {
						_g.push(this.allocVar(f1,p,shaderName).v);
					} else {
						this.mergeVar(path + "." + ft.name,f1,ft,p,shaderName);
					}
				}
			} else if(!Type.enumEq(v.type,v2.type)) {
				this.error("'" + path + "' type does not match : " + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type),p);
			}
		} else if(!Type.enumEq(v.type,v2.type)) {
			this.error("'" + path + "' type does not match : " + hxsl_Tools.toString(v.type) + " should be " + hxsl_Tools.toString(v2.type),p);
		}
	}
	allocVar(v,p,shaderName,path,parent) {
		if(v.parent != null && parent == null) {
			parent = this.allocVar(v.parent,p,shaderName);
			let p1 = parent.v;
			path = p1.name;
			p1 = p1.parent;
			while(p1 != null) {
				path = p1.name + "." + path;
				p1 = p1.parent;
			}
		}
		let key = path == null ? v.name : path + "." + v.name;
		if(v.qualifiers != null) {
			let _g = 0;
			let _g1 = v.qualifiers;
			while(_g < _g1.length) {
				let q = _g1[_g];
				++_g;
				if(q._hx_index == 4) {
					key = q.n;
				}
			}
		}
		let v2 = this.varMap.h[key];
		let vname = v.name;
		if(v2 != null) {
			let _g = 0;
			let _g1 = v2.merged;
			while(_g < _g1.length) {
				let vm = _g1[_g];
				++_g;
				if(vm == v) {
					return v2;
				}
			}
			let tmp;
			if(!(v.kind == hxsl_VarKind.Param && !hxsl_Tools.hasBorrowQualifier(v2.v,shaderName) && !hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Shared) && !this.isBatchShader || v.kind == hxsl_VarKind.Function || (v.kind == hxsl_VarKind.Var || v.kind == hxsl_VarKind.Local) && hxsl_Tools.hasQualifier(v,hxsl_VarQualifier.Private))) {
				let v1 = v2.v;
				tmp = v1.kind == hxsl_VarKind.Param && !hxsl_Tools.hasBorrowQualifier(v,v2.rootShaderName) && !hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Shared) && !this.isBatchShader || v1.kind == hxsl_VarKind.Function || (v1.kind == hxsl_VarKind.Var || v1.kind == hxsl_VarKind.Local) && hxsl_Tools.hasQualifier(v1,hxsl_VarQualifier.Private);
			} else {
				tmp = true;
			}
			if(tmp || v.kind == hxsl_VarKind.Param && v2.v.kind == hxsl_VarKind.Param) {
				let k = 2;
				while(true) {
					let a = this.varMap.h[key + k];
					if(a == null) {
						break;
					}
					let _g = 0;
					let _g1 = a.merged;
					while(_g < _g1.length) {
						let vm = _g1[_g];
						++_g;
						if(vm == v) {
							return a;
						}
					}
					++k;
				}
				vname += k;
				key += k;
			} else {
				v2.merged.push(v);
				this.mergeVar(key,v,v2.v,p,v2.rootShaderName);
				this.varIdMap.h[v.id] = v2.id;
				return v2;
			}
		}
		let v21 = { id : hxsl_Tools.allocVarId(), name : vname, type : v.type, kind : v.kind, qualifiers : v.qualifiers, parent : parent == null ? null : parent.v};
		let a = new hxsl__$Linker_AllocatedVar();
		a.v = v21;
		a.merged = [v];
		a.path = key;
		a.id = v21.id;
		a.parent = parent;
		a.instanceIndex = this.curInstance;
		a.rootShaderName = shaderName;
		this.allVars.push(a);
		this.varMap.h[key] = a;
		let _g = v21.type;
		if(_g._hx_index == 13) {
			let _g1 = _g.vl;
			let _g2 = [];
			let _g3 = 0;
			while(_g3 < _g1.length) {
				let v = _g1[_g3];
				++_g3;
				_g2.push(this.allocVar(v,p,shaderName,key,a).v);
			}
			v21.type = hxsl_Type.TStruct(_g2);
		}
		return a;
	}
	mapExprVar(e) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 1:
			let _g1 = _g.v;
			if(!this.locals.h.hasOwnProperty(_g1.id)) {
				let v = this.allocVar(_g1,e.p);
				if(this.curShader != null && !this.curShader.write.h.hasOwnProperty(v.id)) {
					this.curShader.read.h[v.id] = v;
					if(this.curShader.vertex == null && v.v.kind == hxsl_VarKind.Var) {
						this.curShader.vertex = false;
					}
				}
				return { e : hxsl_TExprDef.TVar(v.v), t : v.v.type, p : e.p};
			}
			break;
		case 5:
			let _g2 = _g.op;
			let _g3 = _g.e1;
			let _g4 = _g.e2;
			let _g5 = _g3.e;
			switch(_g2._hx_index) {
			case 4:
				switch(_g5._hx_index) {
				case 1:
					let _g6 = _g5.v;
					if(!this.locals.h.hasOwnProperty(_g6.id)) {
						let e2 = this.mapExprVar(_g4);
						let v = this.allocVar(_g6,_g3.p);
						if(this.curShader != null) {
							this.curShader.write.h[v.id] = v;
						}
						return { e : hxsl_TExprDef.TBinop(_g2,{ e : hxsl_TExprDef.TVar(v.v), t : v.v.type, p : e.p},e2), t : e.t, p : e.p};
					} else if(!this.locals.h.hasOwnProperty(_g6.id)) {
						let e1 = this.mapExprVar(_g3);
						let e2 = this.mapExprVar(_g4);
						let v = this.allocVar(_g6,e1.p);
						if(this.curShader != null) {
							this.curShader.write.h[v.id] = v;
						}
						return { e : hxsl_TExprDef.TBinop(_g2,e1,e2), t : e.t, p : e.p};
					}
					break;
				case 9:
					let _g7 = _g5.e.e;
					if(_g7._hx_index == 1) {
						let _g = _g7.v;
						if(!this.locals.h.hasOwnProperty(_g.id)) {
							let e1 = this.mapExprVar(_g3);
							let e2 = this.mapExprVar(_g4);
							let v = this.allocVar(_g,e1.p);
							if(this.curShader != null) {
								this.curShader.write.h[v.id] = v;
							}
							return { e : hxsl_TExprDef.TBinop(_g2,e1,e2), t : e.t, p : e.p};
						}
					}
					break;
				default:
				}
				break;
			case 20:
				switch(_g5._hx_index) {
				case 1:
					let _g8 = _g5.v;
					if(!this.locals.h.hasOwnProperty(_g8.id)) {
						let e1 = this.mapExprVar(_g3);
						let e2 = this.mapExprVar(_g4);
						let v = this.allocVar(_g8,e1.p);
						if(this.curShader != null) {
							this.curShader.write.h[v.id] = v;
						}
						return { e : hxsl_TExprDef.TBinop(_g2,e1,e2), t : e.t, p : e.p};
					}
					break;
				case 9:
					let _g9 = _g5.e.e;
					if(_g9._hx_index == 1) {
						let _g = _g9.v;
						if(!this.locals.h.hasOwnProperty(_g.id)) {
							let e1 = this.mapExprVar(_g3);
							let e2 = this.mapExprVar(_g4);
							let v = this.allocVar(_g,e1.p);
							if(this.curShader != null) {
								this.curShader.write.h[v.id] = v;
							}
							return { e : hxsl_TExprDef.TBinop(_g2,e1,e2), t : e.t, p : e.p};
						}
					}
					break;
				default:
				}
				break;
			default:
			}
			break;
		case 7:
			this.locals.h[_g.v.id] = true;
			break;
		case 11:
			if(this.curShader != null) {
				this.curShader.vertex = false;
				this.curShader.hasDiscard = true;
			}
			break;
		case 13:
			this.locals.h[_g.v.id] = true;
			break;
		default:
		}
		return hxsl_Tools.map(e,$bind(this,this.mapExprVar));
	}
	addShader(name,vertex,e,p) {
		let s = new hxsl__$Linker_ShaderInfos(name,vertex);
		this.curShader = s;
		s.priority = p;
		s.body = this.mapExprVar(e);
		this.shaders.push(s);
		this.curShader = null;
		return s;
	}
	sortByPriorityDesc(s1,s2) {
		if(s1.priority == s2.priority) {
			return s1.uid - s2.uid;
		}
		return s2.priority - s1.priority;
	}
	buildDependency(s,v,isWritten) {
		let found = !isWritten;
		let _g = 0;
		let _g1 = this.shaders;
		while(_g < _g1.length) {
			let parent = _g1[_g];
			++_g;
			if(parent == s) {
				found = true;
				continue;
			} else if(!found) {
				continue;
			}
			if(!parent.write.h.hasOwnProperty(v.id)) {
				continue;
			}
			if(s.vertex) {
				if(parent.vertex == false) {
					continue;
				}
				if(parent.vertex == null) {
					parent.vertex = true;
				}
			}
			s.deps.set(parent,true);
			this.debugDepth++;
			this.initDependencies(parent);
			this.debugDepth--;
			if(!parent.read.h.hasOwnProperty(v.id)) {
				return;
			}
		}
		if(v.v.kind == hxsl_VarKind.Var) {
			this.error("Variable " + v.path + " required by " + s.name + " is missing initializer",null);
		}
	}
	initDependencies(s) {
		if(s.deps != null) {
			return;
		}
		s.deps = new haxe_ds_ObjectMap();
		let r = s.read.iterator();
		while(r.hasNext()) {
			let r1 = r.next();
			this.buildDependency(s,r1,s.write.h.hasOwnProperty(r1.id));
		}
		if(s.vertex == null) {
			let d = s.deps.keys();
			while(d.hasNext()) {
				let d1 = d.next();
				if(d1.vertex == false) {
					s.vertex = false;
					break;
				}
			}
		}
		if(s.vertex) {
			let d = s.deps.keys();
			while(d.hasNext()) {
				let d1 = d.next();
				if(d1.vertex == null) {
					d1.vertex = true;
				}
			}
		}
	}
	collect(cur,out,vertex) {
		if(cur.onStack) {
			this.error("Loop in shader dependencies (" + cur.name + ")",null);
		}
		if(cur.marked == vertex) {
			return;
		}
		cur.marked = vertex;
		cur.onStack = true;
		let _g = [];
		let d = cur.deps.keys();
		while(d.hasNext()) {
			let d1 = d.next();
			_g.push(d1);
		}
		_g.sort($bind(this,this.sortByPriorityDesc));
		let _g1 = 0;
		while(_g1 < _g.length) {
			let d = _g[_g1];
			++_g1;
			this.collect(d,out,vertex);
		}
		if(cur.vertex == null) {
			cur.vertex = vertex;
		}
		if(cur.vertex == vertex) {
			out.push(cur);
		}
		cur.onStack = false;
	}
	link(shadersData) {
		this.varMap = new haxe_ds_StringMap();
		this.varIdMap = new haxe_ds_IntMap();
		this.allVars = [];
		this.shaders = [];
		this.locals = new haxe_ds_IntMap();
		let dupShaders = [];
		let _g = [];
		let _g_current = 0;
		let _g_array = shadersData;
		while(_g_current < _g_array.length) {
			let _g_value = _g_array[_g_current];
			let _g_key = _g_current++;
			if(shadersData.indexOf(_g_value) < _g_key) {
				let s2 = hxsl_Clone.shaderData(_g_value);
				dupShaders.push({ origin : _g_value, cloned : s2});
				_g.push(s2);
			} else {
				_g.push(_g_value);
			}
		}
		this.curInstance = 0;
		let outVars = [];
		let _g1 = 0;
		while(_g1 < _g.length) {
			let s = _g[_g1];
			++_g1;
			this.isBatchShader = this.batchMode && s.name.startsWith("batchShader_");
			let _g2 = 0;
			let _g3 = s.vars;
			while(_g2 < _g3.length) {
				let v = _g3[_g2];
				++_g2;
				let v2 = this.allocVar(v,null,s.name);
				if(this.isBatchShader && v2.v.kind == hxsl_VarKind.Param && !v2.path.startsWith("Batch_")) {
					v2.v.kind = hxsl_VarKind.Local;
				}
				if(v.kind == hxsl_VarKind.Output) {
					outVars.push(v);
				}
			}
			let _g4 = 0;
			let _g5 = s.funs;
			while(_g4 < _g5.length) {
				let f = _g5[_g4];
				++_g4;
				let v = this.allocVar(f.ref,f.expr.p);
				v.kind = f.kind;
			}
			this.curInstance++;
		}
		let priority = 0;
		let initPrio_init = [-3000];
		let initPrio_vert = [-2000];
		let initPrio_frag = [-1000];
		let _g2 = 0;
		while(_g2 < _g.length) {
			let s = _g[_g2];
			++_g2;
			let _g1 = 0;
			let _g3 = s.funs;
			while(_g1 < _g3.length) {
				let f = _g3[_g1];
				++_g1;
				let v = this.allocVar(f.ref,f.expr.p);
				if(v.kind == null) {
					throw haxe_Exception.thrown("assert");
				}
				switch(v.kind._hx_index) {
				case 0:case 1:
					this.addShader(s.name + "." + (v.kind == hxsl_FunctionKind.Vertex ? "vertex" : "fragment"),v.kind == hxsl_FunctionKind.Vertex,f.expr,priority);
					break;
				case 2:
					let prio;
					let status;
					switch(f.ref.name) {
					case "__init__fragment":
						prio = initPrio_frag;
						status = false;
						break;
					case "__init__vertex":
						prio = initPrio_vert;
						status = true;
						break;
					default:
						prio = initPrio_init;
						status = null;
					}
					let _g = f.expr.e;
					if(_g._hx_index == 4) {
						let _g1 = _g.el;
						let index = 0;
						let _g2 = 0;
						while(_g2 < _g1.length) {
							let e = _g1[_g2];
							++_g2;
							this.addShader(s.name + "." + f.ref.name + index++,status,e,prio[0]++);
						}
					} else {
						this.addShader(s.name + "." + f.ref.name,status,f.expr,prio[0]++);
					}
					break;
				case 3:
					throw haxe_Exception.thrown("Unexpected helper function in linker " + v.v.name);
				}
			}
			++priority;
		}
		this.shaders.sort($bind(this,this.sortByPriorityDesc));
		let entry = new hxsl__$Linker_ShaderInfos("<entry>",false);
		entry.deps = new haxe_ds_ObjectMap();
		let _g3 = 0;
		while(_g3 < outVars.length) {
			let v = outVars[_g3];
			++_g3;
			this.buildDependency(entry,this.allocVar(v,null),false);
		}
		let _g4 = 0;
		let _g5 = this.shaders;
		while(_g4 < _g5.length) {
			let s = _g5[_g4];
			++_g4;
			if(s.hasDiscard) {
				this.initDependencies(s);
				entry.deps.set(s,true);
			}
		}
		let _g6 = 0;
		let _g7 = this.shaders;
		while(_g6 < _g7.length) {
			let s = _g7[_g6];
			++_g6;
			if(s.vertex != null) {
				continue;
			}
			let onlyParams = true;
			let r = s.read.iterator();
			while(r.hasNext()) {
				let r1 = r.next();
				if(r1.v.kind != hxsl_VarKind.Param) {
					onlyParams = false;
					break;
				}
			}
			if(onlyParams) {
				s.vertex = false;
			}
		}
		let v = [];
		let f = [];
		this.collect(entry,v,true);
		this.collect(entry,f,false);
		if(f.pop() != entry) {
			throw haxe_Exception.thrown("assert");
		}
		let _g8 = 0;
		let _g9 = this.shaders;
		while(_g8 < _g9.length) {
			let s = _g9[_g8];
			++_g8;
			s.marked = null;
		}
		let _g10 = 0;
		let _g11 = v.concat(f);
		while(_g10 < _g11.length) {
			let s = _g11[_g10];
			++_g10;
			let d = s.deps.keys();
			while(d.hasNext()) {
				let d1 = d.next();
				if(d1.marked == null) {
					this.error(d1.name + " needed by " + s.name + " is unreachable",null);
				}
			}
			s.marked = true;
		}
		let outVars1 = [];
		let varMap_h = { };
		let addVar = null;
		addVar = function(v) {
			while(true) {
				if(varMap_h.hasOwnProperty(v.id)) {
					return;
				}
				varMap_h[v.id] = true;
				if(v.v.parent != null) {
					v = v.parent;
					continue;
				} else {
					outVars1.push(v.v);
				}
				return;
			}
		};
		let _g12 = 0;
		let _g13 = v.concat(f);
		while(_g12 < _g13.length) {
			let s = _g13[_g12];
			++_g12;
			let v = s.read.iterator();
			while(v.hasNext()) {
				let v1 = v.next();
				addVar(v1);
			}
			let v1 = s.write.iterator();
			while(v1.hasNext()) {
				let v = v1.next();
				addVar(v);
			}
		}
		let cleanVar = null;
		cleanVar = function(v) {
			let _g = v.type;
			if(_g._hx_index == 13) {
				let _g1 = _g.vl;
				if(v.kind != hxsl_VarKind.Input) {
					let vout = [];
					let _g = 0;
					while(_g < _g1.length) {
						let v = _g1[_g];
						++_g;
						if(varMap_h.hasOwnProperty(v.id)) {
							cleanVar(v);
							vout.push(v);
						}
					}
					v.type = hxsl_Type.TStruct(vout);
				}
			}
		};
		let _g14 = 0;
		while(_g14 < outVars1.length) {
			let v = outVars1[_g14];
			++_g14;
			cleanVar(v);
		}
		let build = function(kind,name,a) {
			let v = { id : hxsl_Tools.allocVarId(), name : name, type : hxsl_Type.TFun([{ ret : hxsl_Type.TVoid, args : []}]), kind : hxsl_VarKind.Function};
			outVars1.push(v);
			let exprs = [];
			let _g = 0;
			while(_g < a.length) {
				let s = a[_g];
				++_g;
				let _g1 = s.body.e;
				if(_g1._hx_index == 4) {
					let _g = _g1.el;
					let _g2 = 0;
					while(_g2 < _g.length) {
						let e = _g[_g2];
						++_g2;
						exprs.push(e);
					}
				} else {
					exprs.push(s.body);
				}
			}
			let expr = { e : hxsl_TExprDef.TBlock(exprs), t : hxsl_Type.TVoid, p : exprs.length == 0 ? null : exprs[0].p};
			return { kind : kind, ref : v, ret : hxsl_Type.TVoid, args : [], expr : expr};
		};
		let funs = [build(hxsl_FunctionKind.Vertex,"vertex",v),build(hxsl_FunctionKind.Fragment,"fragment",f)];
		let _g15 = 0;
		while(_g15 < dupShaders.length) {
			let d = dupShaders[_g15];
			++_g15;
			let _g = 0;
			let _g1 = d.cloned.vars.length;
			while(_g < _g1) {
				let i = _g++;
				this.allocVar(d.cloned.vars[i],null).merged.unshift(d.origin.vars[i]);
			}
		}
		return { name : "out", vars : outVars1, funs : funs};
	}
}
$hxClasses["hxsl.Linker"] = hxsl_Linker;
hxsl_Linker.__name__ = "hxsl.Linker";
Object.assign(hxsl_Linker.prototype, {
	__class__: hxsl_Linker
	,allVars: null
	,varMap: null
	,curShader: null
	,shaders: null
	,varIdMap: null
	,locals: null
	,curInstance: null
	,batchMode: null
	,isBatchShader: null
	,debugDepth: null
});
var hxsl_Output = $hxEnums["hxsl.Output"] = { __ename__:true,__constructs__:null
	,Const: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Const",$_.__params__ = ["v"],$_)
	,Value: ($_=function(v,size) { return {_hx_index:1,v:v,size:size,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Value",$_.__params__ = ["v","size"],$_)
	,PackNormal: ($_=function(v) { return {_hx_index:2,v:v,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="PackNormal",$_.__params__ = ["v"],$_)
	,PackFloat: ($_=function(v) { return {_hx_index:3,v:v,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="PackFloat",$_.__params__ = ["v"],$_)
	,Vec2: ($_=function(a) { return {_hx_index:4,a:a,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Vec2",$_.__params__ = ["a"],$_)
	,Vec3: ($_=function(a) { return {_hx_index:5,a:a,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Vec3",$_.__params__ = ["a"],$_)
	,Vec4: ($_=function(a) { return {_hx_index:6,a:a,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Vec4",$_.__params__ = ["a"],$_)
	,Swiz: ($_=function(a,swiz) { return {_hx_index:7,a:a,swiz:swiz,__enum__:"hxsl.Output",toString:$estr}; },$_._hx_name="Swiz",$_.__params__ = ["a","swiz"],$_)
};
hxsl_Output.__constructs__ = [hxsl_Output.Const,hxsl_Output.Value,hxsl_Output.PackNormal,hxsl_Output.PackFloat,hxsl_Output.Vec2,hxsl_Output.Vec3,hxsl_Output.Vec4,hxsl_Output.Swiz];
hxsl_Output.__empty_constructs__ = [];
class hxsl_Printer {
	constructor(varId) {
		if(varId == null) {
			varId = false;
		}
		this.varId = varId;
	}
	shaderString(s) {
		this.buffer = new StringBuf();
		let _g = 0;
		let _g1 = s.vars;
		while(_g < _g1.length) {
			let v = _g1[_g];
			++_g;
			this.addVar(v,null);
			this.buffer.b += ";\n";
		}
		if(s.vars.length > 0) {
			this.buffer.b += "\n";
		}
		let _g2 = 0;
		let _g3 = s.funs;
		while(_g2 < _g3.length) {
			let f = _g3[_g2];
			++_g2;
			this.addFun(f);
			this.buffer.b += "\n\n";
		}
		return this.buffer.b;
	}
	exprString(e) {
		this.buffer = new StringBuf();
		this.addExpr(e,"");
		return this.buffer.b;
	}
	addVar(v,defKind,tabs,parent) {
		if(tabs == null) {
			tabs = "";
		}
		if(v.qualifiers != null) {
			let _g = 0;
			let _g1 = v.qualifiers;
			while(_g < _g1.length) {
				let q = _g1[_g];
				++_g;
				let v;
				switch(q._hx_index) {
				case 0:
					let _g2 = q.max;
					v = "const" + (_g2 == null ? "" : "(" + _g2 + ")");
					break;
				case 1:
					v = "private";
					break;
				case 2:
					v = "nullable";
					break;
				case 3:
					v = "perObject";
					break;
				case 4:
					v = "name('" + q.n + "')";
					break;
				case 5:
					v = "shared";
					break;
				case 6:
					let _g3 = q.p;
					v = $hxEnums[_g3.__enum__].__constructs__[_g3._hx_index]._hx_name.toLowerCase() + "p";
					break;
				case 7:
					v = "range(" + q.min + "," + q.max + ")";
					break;
				case 8:
					v = "ignore";
					break;
				case 9:
					v = "perInstance(" + q.v + ")";
					break;
				case 10:
					v = "doc(\"" + StringTools.replace(q.s,"\"","\\\"") + "\")";
					break;
				case 11:
					v = "borrow(" + q.source + ")";
					break;
				case 12:
					v = "sampler(" + q.name + ")";
					break;
				}
				this.buffer.b += Std.string("@" + v + " ");
			}
		}
		if(v.kind != defKind) {
			switch(v.kind._hx_index) {
			case 0:
				this.buffer.b += "@global ";
				break;
			case 1:
				this.buffer.b += "@input ";
				break;
			case 2:
				this.buffer.b += "@param ";
				break;
			case 3:
				this.buffer.b += "@varying ";
				break;
			case 4:
				this.buffer.b += "@local ";
				break;
			case 5:
				this.buffer.b += "@output ";
				break;
			case 6:
				this.buffer.b += "@function ";
				break;
			}
		}
		this.buffer.b += "var ";
		if(v.parent == parent) {
			this.buffer.b += Std.string(v.name + (this.varId ? "@" + v.id : ""));
		} else {
			this.addVarName(v);
		}
		this.buffer.b += " : ";
		let _g = v.type;
		if(_g._hx_index == 13) {
			let _g1 = _g.vl;
			this.buffer.b += "{";
			let first = true;
			let _g2 = 0;
			while(_g2 < _g1.length) {
				let v = _g1[_g2];
				++_g2;
				if(first) {
					first = false;
				} else {
					this.buffer.b += ", ";
				}
				this.addVar(v,v.kind,tabs,v);
			}
			this.buffer.b += "}";
		} else {
			let v1 = hxsl_Tools.toString(v.type);
			this.buffer.b += Std.string(v1);
		}
	}
	addFun(f) {
		this.buffer.b += Std.string("function " + f.ref.name + "(");
		let first = true;
		let _g = 0;
		let _g1 = f.args;
		while(_g < _g1.length) {
			let a = _g1[_g];
			++_g;
			if(first) {
				this.buffer.b += " ";
				first = false;
			} else {
				this.buffer.b += ", ";
			}
			this.addVar(a,hxsl_VarKind.Local);
		}
		if(f.args.length > 0) {
			this.buffer.b += " ";
		}
		let v = ") : " + hxsl_Tools.toString(f.ret) + " ";
		this.buffer.b += Std.string(v);
		this.addExpr(f.expr,"");
	}
	addVarName(v) {
		if(v.parent != null) {
			this.addVarName(v.parent);
			this.buffer.b += ".";
		}
		this.buffer.b += Std.string(v.name);
		if(this.varId) {
			this.buffer.b += Std.string("@" + v.id);
		}
	}
	addConst(c) {
		let _this = this.buffer;
		let _this1 = _this.b;
		let tmp;
		switch(c._hx_index) {
		case 0:
			tmp = "null";
			break;
		case 1:
			tmp = c.b;
			break;
		case 2:
			tmp = c.v;
			break;
		case 3:
			tmp = c.v;
			break;
		case 4:
			tmp = "\"" + c.v + "\"";
			break;
		}
		_this.b = _this1 + Std.string(tmp);
	}
	addExpr(e,tabs) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 0:
			this.addConst(_g.c);
			break;
		case 1:
			this.addVarName(_g.v);
			break;
		case 2:
			let v = hxsl_Tools2.toString(_g.g);
			this.buffer.b += Std.string(v);
			break;
		case 3:
			this.buffer.b += "(";
			this.addExpr(_g.e,tabs);
			this.buffer.b += ")";
			break;
		case 4:
			let _g1 = _g.el;
			this.buffer.b += "{";
			tabs += "\t";
			let _g2 = 0;
			while(_g2 < _g1.length) {
				let e = _g1[_g2];
				++_g2;
				this.buffer.b += Std.string("\n" + tabs);
				this.addExpr(e,tabs);
				this.buffer.b += ";";
			}
			tabs = HxOverrides.substr(tabs,1,null);
			if(_g1.length > 0) {
				this.buffer.b += Std.string("\n" + tabs);
			}
			this.buffer.b += "}";
			break;
		case 5:
			this.addExpr(_g.e1,tabs);
			this.buffer.b += Std.string(" " + hxsl_Printer.opStr(_g.op) + " ");
			this.addExpr(_g.e2,tabs);
			break;
		case 6:
			let _g3 = _g.e1;
			let v1;
			switch(_g.op._hx_index) {
			case 0:
				v1 = "++";
				break;
			case 1:
				v1 = "--";
				break;
			case 2:
				v1 = "!";
				break;
			case 3:
				v1 = "-";
				break;
			case 4:
				v1 = "~";
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			this.buffer.b += Std.string(v1);
			this.addExpr(_g3,tabs);
			break;
		case 7:
			let _g4 = _g.init;
			this.addVar(_g.v,hxsl_VarKind.Local,tabs);
			if(_g4 != null) {
				this.buffer.b += " = ";
				this.addExpr(_g4,tabs);
			}
			break;
		case 8:
			let _g5 = _g.args;
			this.addExpr(_g.e,tabs);
			this.buffer.b += "(";
			let first = true;
			let _g6 = 0;
			while(_g6 < _g5.length) {
				let e = _g5[_g6];
				++_g6;
				if(first) {
					first = false;
				} else {
					this.buffer.b += ", ";
				}
				this.addExpr(e,tabs);
			}
			this.buffer.b += ")";
			break;
		case 9:
			let _g7 = _g.regs;
			this.addExpr(_g.e,tabs);
			this.buffer.b += ".";
			let _g8 = 0;
			while(_g8 < _g7.length) {
				let r = _g7[_g8];
				++_g8;
				this.buffer.b += Std.string(hxsl_Printer.SWIZ[r._hx_index]);
			}
			break;
		case 10:
			let _g9 = _g.eelse;
			this.buffer.b += "if( ";
			this.addExpr(_g.econd,tabs);
			this.buffer.b += " ) ";
			this.addExpr(_g.eif,tabs);
			if(_g9 != null) {
				this.buffer.b += " else ";
				this.addExpr(_g9,tabs);
			}
			break;
		case 11:
			this.buffer.b += "discard";
			break;
		case 12:
			let _g10 = _g.e;
			this.buffer.b += "return";
			if(_g10 != null) {
				this.buffer.b += " ";
				this.addExpr(_g10,tabs);
			}
			break;
		case 13:
			this.buffer.b += "for( ";
			this.addVarName(_g.v);
			this.buffer.b += " in ";
			this.addExpr(_g.it,tabs);
			this.buffer.b += " ) ";
			this.addExpr(_g.loop,tabs);
			break;
		case 14:
			this.buffer.b += "continue";
			break;
		case 15:
			this.buffer.b += "break";
			break;
		case 16:
			this.addExpr(_g.e,tabs);
			this.buffer.b += "[";
			this.addExpr(_g.index,tabs);
			this.buffer.b += "]";
			break;
		case 17:
			let _g11 = _g.el;
			this.buffer.b += "[";
			let first1 = true;
			let _g12 = 0;
			while(_g12 < _g11.length) {
				let e = _g11[_g12];
				++_g12;
				if(first1) {
					first1 = false;
				} else {
					this.buffer.b += ", ";
				}
				this.addExpr(e,tabs);
			}
			this.buffer.b += "]";
			break;
		case 18:
			let _g13 = _g.cases;
			let _g14 = _g.def;
			this.buffer.b += "switch( ";
			this.addExpr(_g.e,tabs);
			this.buffer.b += ") {";
			let old = tabs;
			let _g15 = 0;
			while(_g15 < _g13.length) {
				let c = _g13[_g15];
				++_g15;
				this.buffer.b += Std.string("\n" + tabs);
				this.buffer.b += "case ";
				let first = true;
				let _g = 0;
				let _g1 = c.values;
				while(_g < _g1.length) {
					let v = _g1[_g];
					++_g;
					if(first) {
						first = false;
					} else {
						this.buffer.b += ", ";
					}
					this.addExpr(v,tabs);
				}
				tabs += "\t";
				this.buffer.b += Std.string(":\n" + tabs);
				this.addExpr(c.expr,tabs);
				tabs = old;
			}
			if(_g14 != null) {
				this.buffer.b += Std.string("\n" + tabs);
				tabs += "\t";
				this.buffer.b += Std.string("default:\n" + tabs);
				this.addExpr(_g14,tabs);
				tabs = old;
			}
			this.buffer.b += Std.string("\n" + tabs + "}");
			break;
		case 19:
			let _g16 = _g.e;
			let _g17 = _g.loop;
			if(_g.normalWhile == false) {
				let old = tabs;
				tabs += "\t";
				this.buffer.b += Std.string("do {\n" + tabs);
				this.addExpr(_g17,tabs);
				tabs = old;
				this.buffer.b += Std.string("\n" + old + "} while( ");
				this.addExpr(_g16,old);
				this.buffer.b += " )";
			} else {
				this.buffer.b += "while( ";
				this.addExpr(_g16,tabs);
				let old = tabs;
				tabs += "\t";
				this.buffer.b += Std.string(" ) {\n" + tabs);
				this.addExpr(_g17,tabs);
				tabs = old;
				this.buffer.b += Std.string("\n" + old + "}");
			}
			break;
		case 20:
			let _g18 = _g.args;
			let _g19 = _g.e;
			this.buffer.b += "@";
			this.buffer.b += Std.string(_g.m);
			if(_g18.length > 0) {
				this.buffer.b += "(";
				let first = true;
				let _g = 0;
				while(_g < _g18.length) {
					let c = _g18[_g];
					++_g;
					if(first) {
						first = false;
					} else {
						this.buffer.b += ", ";
					}
					this.addConst(c);
				}
				this.buffer.b += ")";
			}
			this.buffer.b += " ";
			this.addExpr(_g19,tabs);
			break;
		}
	}
	static opStr(op) {
		switch(op._hx_index) {
		case 0:
			return "+";
		case 1:
			return "*";
		case 2:
			return "/";
		case 3:
			return "-";
		case 4:
			return "=";
		case 5:
			return "==";
		case 6:
			return "!=";
		case 7:
			return ">";
		case 8:
			return ">=";
		case 9:
			return "<";
		case 10:
			return "<=";
		case 11:
			return "&";
		case 12:
			return "|";
		case 13:
			return "^";
		case 14:
			return "&&";
		case 15:
			return "||";
		case 16:
			return "<<";
		case 17:
			return ">>";
		case 18:
			return ">>>";
		case 19:
			return "%";
		case 20:
			return hxsl_Printer.opStr(op.op) + "=";
		case 21:
			return "...";
		case 22:
			return "=>";
		default:
			return "??" + Std.string(op);
		}
	}
	static toString(e,varId) {
		if(varId == null) {
			varId = false;
		}
		return new hxsl_Printer(varId).exprString(e);
	}
	static shaderToString(s,varId) {
		if(varId == null) {
			varId = false;
		}
		return new hxsl_Printer(varId).shaderString(s);
	}
	static check(s,from) {
		try {
			let vars = new haxe_ds_IntMap();
			let regVars = [];
			let regVar = null;
			regVar = function(v,reg) {
				if(reg) {
					if(vars.h.hasOwnProperty(v.id)) {
						throw haxe_Exception.thrown("Duplicate var " + v.id);
					}
					vars.h[v.id] = v;
					regVars.push(v);
				} else {
					vars.remove(v.id);
				}
				let _g = v.type;
				if(_g._hx_index == 13) {
					let _g1 = _g.vl;
					let _g2 = 0;
					while(_g2 < _g1.length) {
						let v = _g1[_g2];
						++_g2;
						regVar(v,reg);
					}
				}
			};
			let checkExpr = null;
			checkExpr = function(e) {
				let _g = e.e;
				switch(_g._hx_index) {
				case 1:
					let _g1 = _g.v;
					if(!vars.h.hasOwnProperty(_g1.id)) {
						throw haxe_Exception.thrown("Unbound var " + _g1.name + "@" + _g1.id);
					}
					break;
				case 4:
					let _g2 = _g.el;
					let old = regVars;
					regVars = [];
					let _g3 = 0;
					while(_g3 < _g2.length) {
						let e = _g2[_g3];
						++_g3;
						checkExpr(e);
					}
					let _g4 = 0;
					while(_g4 < regVars.length) {
						let v = regVars[_g4];
						++_g4;
						regVar(v,false);
					}
					regVars = old;
					break;
				case 7:
					let _g5 = _g.init;
					if(_g5 != null) {
						checkExpr(_g5);
					}
					regVar(_g.v,true);
					break;
				case 13:
					let _g6 = _g.v;
					checkExpr(_g.it);
					regVar(_g6,true);
					checkExpr(_g.loop);
					regVar(_g6,false);
					break;
				default:
					hxsl_Tools.iter(e,checkExpr);
				}
			};
			let _g = 0;
			let _g1 = s.vars;
			while(_g < _g1.length) {
				let v = _g1[_g];
				++_g;
				regVar(v,true);
			}
			let _g2 = 0;
			let _g3 = s.funs;
			while(_g2 < _g3.length) {
				let f = _g3[_g2];
				++_g2;
				let _g = 0;
				let _g1 = f.args;
				while(_g < _g1.length) {
					let v = _g1[_g];
					++_g;
					regVar(v,true);
				}
				checkExpr(f.expr);
				let _g4 = 0;
				let _g5 = f.args;
				while(_g4 < _g5.length) {
					let v = _g5[_g4];
					++_g4;
					regVar(v,false);
				}
			}
		} catch( _g ) {
			let _g1 = haxe_Exception.caught(_g).unwrap();
			if(typeof(_g1) == "string") {
				let e = _g1;
				let msg = e + "\n    in\n" + hxsl_Printer.shaderToString(s,true);
				if(from != null) {
					let _g = [];
					let _g1 = 0;
					while(_g1 < from.length) {
						let s = from[_g1];
						++_g1;
						_g.push(hxsl_Printer.shaderToString(s,true));
					}
					msg += "\n    from\n\n" + _g.join("\n\n");
				}
				throw haxe_Exception.thrown(msg);
			} else {
				throw _g;
			}
		}
	}
}
$hxClasses["hxsl.Printer"] = hxsl_Printer;
hxsl_Printer.__name__ = "hxsl.Printer";
Object.assign(hxsl_Printer.prototype, {
	__class__: hxsl_Printer
	,buffer: null
	,varId: null
});
class hxsl_AllocParam {
	constructor(name,pos,instance,index,type) {
		this.name = name;
		this.pos = pos;
		this.instance = instance;
		this.index = index;
		this.type = type;
	}
}
$hxClasses["hxsl.AllocParam"] = hxsl_AllocParam;
hxsl_AllocParam.__name__ = "hxsl.AllocParam";
Object.assign(hxsl_AllocParam.prototype, {
	__class__: hxsl_AllocParam
	,name: null
	,pos: null
	,instance: null
	,index: null
	,type: null
	,perObjectGlobal: null
	,next: null
});
class hxsl_AllocGlobal {
	constructor(pos,path,type) {
		this.pos = pos;
		this.path = path;
		this.gid = hxsl_Globals.allocID(path);
		this.type = type;
	}
}
$hxClasses["hxsl.AllocGlobal"] = hxsl_AllocGlobal;
hxsl_AllocGlobal.__name__ = "hxsl.AllocGlobal";
Object.assign(hxsl_AllocGlobal.prototype, {
	__class__: hxsl_AllocGlobal
	,pos: null
	,gid: null
	,path: null
	,type: null
	,next: null
});
class hxsl_RuntimeShaderData {
	constructor() {
	}
}
$hxClasses["hxsl.RuntimeShaderData"] = hxsl_RuntimeShaderData;
hxsl_RuntimeShaderData.__name__ = "hxsl.RuntimeShaderData";
Object.assign(hxsl_RuntimeShaderData.prototype, {
	__class__: hxsl_RuntimeShaderData
	,vertex: null
	,data: null
	,code: null
	,params: null
	,paramsSize: null
	,globals: null
	,globalsSize: null
	,textures: null
	,texturesCount: null
	,buffers: null
	,bufferCount: null
	,consts: null
});
class hxsl_ShaderInstanceDesc {
	constructor(shader,bits) {
		this.shader = shader;
		this.bits = bits;
	}
}
$hxClasses["hxsl.ShaderInstanceDesc"] = hxsl_ShaderInstanceDesc;
hxsl_ShaderInstanceDesc.__name__ = "hxsl.ShaderInstanceDesc";
Object.assign(hxsl_ShaderInstanceDesc.prototype, {
	__class__: hxsl_ShaderInstanceDesc
	,shader: null
	,bits: null
	,index: null
});
class hxsl_RuntimeShader {
	constructor() {
		this.id = hxsl_RuntimeShader.UID++;
	}
}
$hxClasses["hxsl.RuntimeShader"] = hxsl_RuntimeShader;
hxsl_RuntimeShader.__name__ = "hxsl.RuntimeShader";
Object.assign(hxsl_RuntimeShader.prototype, {
	__class__: hxsl_RuntimeShader
	,id: null
	,vertex: null
	,fragment: null
	,globals: null
	,signature: null
	,batchMode: null
	,spec: null
});
class hxsl_Serializer {
	constructor() {
	}
	readVarInt() {
		let b = this.input.readByte();
		if(b < 128) {
			return b;
		}
		if(b == 255) {
			return this.input.readInt32();
		}
		return (b & 127) << 8 | this.input.readByte();
	}
	readType() {
		switch(this.input.readByte()) {
		case 0:
			return hxsl_Type.TVoid;
		case 1:
			return hxsl_Type.TInt;
		case 2:
			return hxsl_Type.TBool;
		case 3:
			return hxsl_Type.TFloat;
		case 4:
			return hxsl_Type.TString;
		case 5:
			let bits = this.input.readByte();
			let v = hxsl_Serializer.TVECS.h[bits];
			if(v == null) {
				v = hxsl_Type.TVec(bits & 7,Type.createEnumIndex(hxsl_VecType,bits >> 3,null));
				hxsl_Serializer.TVECS.h[bits] = v;
			}
			return v;
		case 6:
			return hxsl_Type.TMat3;
		case 7:
			return hxsl_Type.TMat4;
		case 8:
			return hxsl_Type.TMat3x4;
		case 9:
			return hxsl_Type.TBytes(this.input.readInt32());
		case 10:
			return hxsl_Type.TSampler2D;
		case 11:
			return hxsl_Type.TSampler2DArray;
		case 12:
			return hxsl_Type.TSamplerCube;
		case 13:
			let id = this.readVarInt();
			let t = this.types[id];
			if(t != null) {
				return t;
			}
			let f = $bind(this,this.readVar);
			let _g = [];
			let _g1 = 0;
			let _g2 = this.readVarInt();
			while(_g1 < _g2) {
				++_g1;
				_g.push(f());
			}
			t = hxsl_Type.TStruct(_g);
			this.types[id] = t;
			return t;
		case 14:
			return hxsl_Type.TFun(null);
		case 15:
			let t1 = this.readType();
			let v1 = this.readVar();
			return hxsl_Type.TArray(t1,v1 == null ? hxsl_SizeDecl.SConst(this.readVarInt()) : hxsl_SizeDecl.SVar(v1));
		case 16:
			let t2 = this.readType();
			let v2 = this.readVar();
			return hxsl_Type.TBuffer(t2,v2 == null ? hxsl_SizeDecl.SConst(this.readVarInt()) : hxsl_SizeDecl.SVar(v2));
		case 17:
			return hxsl_Type.TChannel(this.input.readByte());
		case 18:
			return hxsl_Type.TMat2;
		default:
			throw haxe_Exception.thrown("assert");
		}
	}
	readString() {
		let len = this.readVarInt();
		let s = this.input.read(len).getString(0,len);
		return s;
	}
	readConst() {
		switch(this.input.readByte()) {
		case 0:
			return hxsl_Const.CNull;
		case 1:
			return hxsl_Const.CBool(this.input.readByte() != 0);
		case 2:
			return hxsl_Const.CInt(this.input.readInt32());
		case 3:
			return hxsl_Const.CFloat(this.input.readDouble());
		case 4:
			return hxsl_Const.CString(this.readString());
		default:
			throw haxe_Exception.thrown("assert");
		}
	}
	readExpr() {
		let k = this.input.readByte();
		if(k-- == 0) {
			return null;
		}
		let e;
		switch(k) {
		case 0:
			e = hxsl_TExprDef.TConst(this.readConst());
			break;
		case 1:
			e = hxsl_TExprDef.TVar(this.readVar());
			break;
		case 2:
			e = hxsl_TExprDef.TGlobal(hxsl_Serializer.TGLOBALS[this.input.readByte()]);
			break;
		case 3:
			e = hxsl_TExprDef.TParenthesis(this.readExpr());
			break;
		case 4:
			let f = $bind(this,this.readExpr);
			let _g = [];
			let _g1 = 0;
			let _g2 = this.readVarInt();
			while(_g1 < _g2) {
				++_g1;
				_g.push(f());
			}
			e = hxsl_TExprDef.TBlock(_g);
			break;
		case 5:
			let op = this.input.readByte();
			e = hxsl_TExprDef.TBinop(op >= 128 ? haxe_macro_Binop.OpAssignOp(hxsl_Serializer.BOPS[op & 127]) : hxsl_Serializer.BOPS[op],this.readExpr(),this.readExpr());
			break;
		case 6:
			e = hxsl_TExprDef.TUnop(hxsl_Serializer.UNOPS[this.input.readByte()],this.readExpr());
			break;
		case 7:
			e = hxsl_TExprDef.TVarDecl(this.readVar(),this.readExpr());
			break;
		case 8:
			let e1 = this.readExpr();
			let f1 = $bind(this,this.readExpr);
			let _g3 = [];
			let _g4 = 0;
			let _g5 = this.readVarInt();
			while(_g4 < _g5) {
				++_g4;
				_g3.push(f1());
			}
			e = hxsl_TExprDef.TCall(e1,_g3);
			break;
		case 9:
			let e2 = this.readExpr();
			let bits = this.input.readUInt16();
			let swiz = hxsl_Serializer.TSWIZ.h[bits];
			if(swiz == null) {
				let _g = [];
				let _g1 = 0;
				let _g2 = (bits & 3) + 1;
				while(_g1 < _g2) {
					let i = _g1++;
					_g.push(hxsl_Serializer.REGS[bits >> i * 2 + 2 & 3]);
				}
				swiz = _g;
				hxsl_Serializer.TSWIZ.h[bits] = _g;
			}
			e = hxsl_TExprDef.TSwiz(e2,swiz);
			break;
		case 10:
			e = hxsl_TExprDef.TIf(this.readExpr(),this.readExpr(),this.readExpr());
			break;
		case 11:
			e = hxsl_TExprDef.TDiscard;
			break;
		case 12:
			e = hxsl_TExprDef.TReturn(this.readExpr());
			break;
		case 13:
			e = hxsl_TExprDef.TFor(this.readVar(),this.readExpr(),this.readExpr());
			break;
		case 14:
			e = hxsl_TExprDef.TContinue;
			break;
		case 15:
			e = hxsl_TExprDef.TBreak;
			break;
		case 16:
			e = hxsl_TExprDef.TArray(this.readExpr(),this.readExpr());
			break;
		case 17:
			let f2 = $bind(this,this.readExpr);
			let _g6 = [];
			let _g7 = 0;
			let _g8 = this.readVarInt();
			while(_g7 < _g8) {
				++_g7;
				_g6.push(f2());
			}
			e = hxsl_TExprDef.TArrayDecl(_g6);
			break;
		case 18:
			let e3 = this.readExpr();
			let _g9 = [];
			let _g10 = 0;
			let _g11 = this.readVarInt();
			while(_g10 < _g11) {
				++_g10;
				let f = $bind(this,this.readExpr);
				let _g = [];
				let _g1 = 0;
				let _g2 = this.readVarInt();
				while(_g1 < _g2) {
					++_g1;
					_g.push(f());
				}
				_g9.push({ values : _g, expr : this.readExpr()});
			}
			e = hxsl_TExprDef.TSwitch(e3,_g9,this.readExpr());
			break;
		case 19:
			e = hxsl_TExprDef.TWhile(this.readExpr(),this.readExpr(),this.input.readByte() != 0);
			break;
		case 20:
			let e4 = this.readString();
			let f3 = $bind(this,this.readConst);
			let _g12 = [];
			let _g13 = 0;
			let _g14 = this.readVarInt();
			while(_g13 < _g14) {
				++_g13;
				_g12.push(f3());
			}
			e = hxsl_TExprDef.TMeta(e4,_g12,this.readExpr());
			break;
		default:
			throw haxe_Exception.thrown("assert");
		}
		return { e : e, t : this.readType(), p : null};
	}
	readVar() {
		let id = this.readVarInt();
		if(id == 0) {
			return null;
		}
		let v = this.varMap.h[id];
		if(v != null) {
			return v;
		}
		v = { id : hxsl_Tools.allocVarId(), name : this.readString(), type : null, kind : null};
		this.varMap.h[id] = v;
		v.type = this.readType();
		v.kind = hxsl_Serializer.VKINDS[this.input.readByte()];
		v.parent = this.readVar();
		let nq = this.input.readByte();
		if(nq > 0) {
			v.qualifiers = [];
			let _g = 0;
			while(_g < nq) {
				++_g;
				let qid = this.input.readByte();
				let q;
				switch(qid) {
				case 0:
					let n = this.input.readInt32();
					q = hxsl_VarQualifier.Const(n == 0 ? null : n);
					break;
				case 1:
					q = hxsl_VarQualifier.Private;
					break;
				case 2:
					q = hxsl_VarQualifier.Nullable;
					break;
				case 3:
					q = hxsl_VarQualifier.PerObject;
					break;
				case 4:
					q = hxsl_VarQualifier.Name(this.readString());
					break;
				case 5:
					q = hxsl_VarQualifier.Shared;
					break;
				case 6:
					q = hxsl_VarQualifier.Precision(hxsl_Serializer.PRECS[this.input.readByte()]);
					break;
				case 7:
					q = hxsl_VarQualifier.Range(this.input.readDouble(),this.input.readDouble());
					break;
				case 8:
					q = hxsl_VarQualifier.Ignore;
					break;
				case 9:
					q = hxsl_VarQualifier.PerInstance(this.input.readInt32());
					break;
				case 10:
					q = hxsl_VarQualifier.Doc(this.readString());
					break;
				case 11:
					q = hxsl_VarQualifier.Borrow(this.readString());
					break;
				case 12:
					q = hxsl_VarQualifier.Sampler(this.readString());
					break;
				default:
					throw haxe_Exception.thrown("assert");
				}
				v.qualifiers.push(q);
			}
		}
		return v;
	}
	readFun() {
		let tmp = hxsl_Serializer.FKIND[this.input.readByte()];
		let tmp1 = this.readVar();
		let f = $bind(this,this.readVar);
		let _g = [];
		let _g1 = 0;
		let _g2 = this.readVarInt();
		while(_g1 < _g2) {
			++_g1;
			_g.push(f());
		}
		return { kind : tmp, ref : tmp1, args : _g, ret : this.readType(), expr : this.readExpr()};
	}
	unserialize(data) {
		this.input = new haxe_io_BytesInput(haxe_crypto_Base64.decode(data,false));
		if(this.input.readByte() != (hxsl_Serializer.SIGN & 255) || this.input.readByte() != (hxsl_Serializer.SIGN >> 8 & 255) || this.input.readByte() != (hxsl_Serializer.SIGN >> 16 & 255)) {
			throw haxe_Exception.thrown("Invalid HXSL data");
		}
		this.varMap = new haxe_ds_IntMap();
		this.types = [];
		let tmp = this.readString();
		let f = $bind(this,this.readVar);
		let _g = [];
		let _g1 = 0;
		let _g2 = this.readVarInt();
		while(_g1 < _g2) {
			++_g1;
			_g.push(f());
		}
		let f1 = $bind(this,this.readFun);
		let _g3 = [];
		let _g4 = 0;
		let _g5 = this.readVarInt();
		while(_g4 < _g5) {
			++_g4;
			_g3.push(f1());
		}
		return { name : tmp, vars : _g, funs : _g3};
	}
}
$hxClasses["hxsl.Serializer"] = hxsl_Serializer;
hxsl_Serializer.__name__ = "hxsl.Serializer";
Object.assign(hxsl_Serializer.prototype, {
	__class__: hxsl_Serializer
	,input: null
	,varMap: null
	,types: null
});
class hxsl_ShaderList {
	constructor(s,n) {
		this.s = s;
		this.next = n;
	}
	clone() {
		return new hxsl_ShaderList(this.s.clone(),this.next == null ? null : this.next.clone());
	}
	static addSort(s,shaders) {
		let prev = null;
		let hd = shaders;
		while(hd != null && hd.s.priority < s.priority) {
			prev = hd;
			hd = hd.next;
		}
		if(prev == null) {
			let l = new hxsl_ShaderList(s,shaders);
			hxsl_ShaderList.checkSize(l);
			return l;
		}
		prev.next = new hxsl_ShaderList(s,prev.next);
		hxsl_ShaderList.checkSize(shaders);
		return shaders;
	}
	static checkSize(list) {
		if(hxsl_ShaderList.MAX_LIST_SIZE <= 0) {
			return;
		}
		let hd = list;
		let count = 0;
		while(hd != null) {
			if(!hxsl_ShaderList.ALLOW_DUPLICATES && hd.next != null && hd.next.s == hd.s) {
				throw haxe_Exception.thrown("Duplicate shader " + Std.string(hd.s));
			}
			++count;
			hd = hd.next;
		}
		if(count > hxsl_ShaderList.MAX_LIST_SIZE) {
			throw haxe_Exception.thrown("Too many shaders");
		}
	}
}
$hxClasses["hxsl.ShaderList"] = hxsl_ShaderList;
hxsl_ShaderList.__name__ = "hxsl.ShaderList";
Object.assign(hxsl_ShaderList.prototype, {
	__class__: hxsl_ShaderList
	,s: null
	,next: null
});
class hxsl_ShaderInstance {
	constructor(shader) {
		this.id = ++hxsl_ShaderInstance.UID;
		this.shader = shader;
		this.params = new haxe_ds_IntMap();
	}
}
$hxClasses["hxsl.ShaderInstance"] = hxsl_ShaderInstance;
hxsl_ShaderInstance.__name__ = "hxsl.ShaderInstance";
Object.assign(hxsl_ShaderInstance.prototype, {
	__class__: hxsl_ShaderInstance
	,id: null
	,shader: null
	,params: null
});
class hxsl_ShaderGlobal {
	constructor(v,gid) {
		this.v = v;
		this.globalId = gid;
	}
}
$hxClasses["hxsl.ShaderGlobal"] = hxsl_ShaderGlobal;
hxsl_ShaderGlobal.__name__ = "hxsl.ShaderGlobal";
Object.assign(hxsl_ShaderGlobal.prototype, {
	__class__: hxsl_ShaderGlobal
	,v: null
	,globalId: null
});
class hxsl_ShaderConst {
	constructor(v,pos,bits) {
		this.v = v;
		this.pos = pos;
		this.bits = bits;
	}
}
$hxClasses["hxsl.ShaderConst"] = hxsl_ShaderConst;
hxsl_ShaderConst.__name__ = "hxsl.ShaderConst";
Object.assign(hxsl_ShaderConst.prototype, {
	__class__: hxsl_ShaderConst
	,v: null
	,pos: null
	,bits: null
	,globalId: null
	,next: null
});
class hxsl_SharedShader {
	constructor(src) {
		this.instanceCache = new haxe_ds_IntMap();
		this.consts = null;
		this.globals = [];
		if(src == "") {
			return;
		}
		this.data = new hxsl_Serializer().unserialize(src);
		let _g = 0;
		let _g1 = this.data.vars;
		while(_g < _g1.length) {
			let v = _g1[_g];
			++_g;
			this.initVarId(v);
		}
		this.data = hxsl_SharedShader.compactMem(this.data);
		this.initialize();
	}
	initialize() {
		let _g = 0;
		let _g1 = this.data.vars;
		while(_g < _g1.length) {
			let v = _g1[_g];
			++_g;
			this.browseVar(v);
		}
	}
	makeInstance(constBits) {
		let $eval = new hxsl_Eval();
		let c = this.consts;
		while(c != null) {
			let c1 = c.v;
			let tmp;
			switch(c.v.type._hx_index) {
			case 1:
				tmp = hxsl_Const.CInt(constBits >>> c.pos & (1 << c.bits) - 1);
				break;
			case 2:
				tmp = hxsl_Const.CBool((constBits >>> c.pos & 1) != 0);
				break;
			case 17:
				tmp = hxsl_Const.CInt(constBits >>> c.pos & (1 << c.bits) - 1);
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
			$eval.setConstant(c1,tmp);
			c = c.next;
		}
		$eval.inlineCalls = true;
		$eval.unrollLoops = hxsl_SharedShader.UNROLL_LOOPS;
		let edata = $eval.eval(this.data);
		edata = hxsl_SharedShader.compactMem(edata);
		let i = new hxsl_ShaderInstance(edata);
		hxsl_Printer.check(i.shader,[this.data]);
		this.paramsCount = 0;
		let _g = 0;
		let _g1 = this.data.vars;
		while(_g < _g1.length) {
			let v = _g1[_g];
			++_g;
			this.addParam($eval,i,v);
		}
		this.instanceCache.h[constBits] = i;
		return i;
	}
	addParam($eval,i,v) {
		let _g = v.type;
		if(_g._hx_index == 13) {
			let _g1 = _g.vl;
			let _g2 = 0;
			while(_g2 < _g1.length) {
				let v = _g1[_g2];
				++_g2;
				this.addParam($eval,i,v);
			}
		} else if(v.kind == hxsl_VarKind.Param) {
			i.params.h[$eval.varMap.h[v.__id__].id] = this.paramsCount;
			this.paramsCount++;
		}
	}
	initVarId(v) {
		v.id = hxsl_Tools.allocVarId();
		let _g = v.type;
		if(_g._hx_index == 13) {
			let _g1 = _g.vl;
			let _g2 = 0;
			while(_g2 < _g1.length) {
				let v = _g1[_g2];
				++_g2;
				this.initVarId(v);
			}
		}
	}
	browseVar(v,path) {
		if(path == null) {
			path = hxsl_Tools.getName(v);
		} else {
			path += "." + v.name;
		}
		let _g = v.type;
		if(_g._hx_index == 13) {
			let _g1 = _g.vl;
			let _g2 = 0;
			while(_g2 < _g1.length) {
				let vs = _g1[_g2];
				++_g2;
				this.browseVar(vs,path);
			}
		} else {
			let globalId = 0;
			if(v.kind == hxsl_VarKind.Global) {
				globalId = hxsl_Globals.allocID(path);
				this.globals.push(new hxsl_ShaderGlobal(v,globalId));
			}
			if(!hxsl_Tools.isConst(v)) {
				return;
			}
			let bits = hxsl_Tools.getConstBits(v);
			if(bits > 0) {
				let pos = this.consts == null ? 0 : this.consts.pos + this.consts.bits;
				let c = new hxsl_ShaderConst(v,pos,bits);
				c.globalId = globalId;
				c.next = this.consts;
				this.consts = c;
			}
		}
	}
	static compactMem(mem) {
		return mem;
	}
}
$hxClasses["hxsl.SharedShader"] = hxsl_SharedShader;
hxsl_SharedShader.__name__ = "hxsl.SharedShader";
Object.assign(hxsl_SharedShader.prototype, {
	__class__: hxsl_SharedShader
	,data: null
	,globals: null
	,consts: null
	,instanceCache: null
	,paramsCount: null
});
class hxsl__$Splitter_VarProps {
	constructor(v) {
		this.v = v;
		this.read = 0;
		this.write = 0;
	}
}
$hxClasses["hxsl._Splitter.VarProps"] = hxsl__$Splitter_VarProps;
hxsl__$Splitter_VarProps.__name__ = "hxsl._Splitter.VarProps";
Object.assign(hxsl__$Splitter_VarProps.prototype, {
	__class__: hxsl__$Splitter_VarProps
	,origin: null
	,v: null
	,read: null
	,write: null
	,local: null
	,requireInit: null
});
class hxsl_Splitter {
	constructor() {
	}
	split(s) {
		let vfun = null;
		let vvars = new haxe_ds_IntMap();
		let ffun = null;
		let fvars = new haxe_ds_IntMap();
		this.varNames = new haxe_ds_StringMap();
		this.varMap = new haxe_ds_ObjectMap();
		let _g = 0;
		let _g1 = s.funs;
		while(_g < _g1.length) {
			let f = _g1[_g];
			++_g;
			switch(f.kind._hx_index) {
			case 0:
				this.vars = vvars;
				vfun = f;
				this.checkExpr(f.expr);
				break;
			case 1:
				this.vars = fvars;
				ffun = f;
				this.checkExpr(f.expr);
				break;
			default:
				throw haxe_Exception.thrown("assert");
			}
		}
		let vafterMap = [];
		let _gthis = this;
		let _g2 = 0;
		let _g3 = Lambda.array(vvars);
		while(_g2 < _g3.length) {
			let inf = _g3[_g2];
			++_g2;
			let v = inf.v;
			if(inf.local) {
				continue;
			}
			switch(v.kind._hx_index) {
			case 3:case 4:
				let fv = fvars.h[inf.origin.id];
				v.kind = fv != null && fv.read > 0 ? hxsl_VarKind.Var : hxsl_VarKind.Local;
				break;
			default:
			}
			switch(v.kind._hx_index) {
			case 3:case 5:
				if(inf.read > 0 || inf.write > 1) {
					let nv = { id : hxsl_Tools.allocVarId(), name : v.name, kind : hxsl_VarKind.Local, type : v.type};
					this.uniqueName(nv);
					this.varMap.set(inf.origin,nv);
					let ninf = new hxsl__$Splitter_VarProps(nv);
					ninf.read++;
					vvars.h[nv.id] = ninf;
					let p = vfun.expr.p;
					let e = { e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(v), t : nv.type, p : p},{ e : hxsl_TExprDef.TVar(nv), t : v.type, p : p}), t : nv.type, p : p};
					vafterMap.push(function() {
						_gthis.addExpr(vfun,e);
					});
					if(v.kind == hxsl_VarKind.Var) {
						vafterMap.push(function() {
							_gthis.varMap.set(inf.origin,v);
						});
					}
				}
				break;
			default:
			}
		}
		vfun = { ret : vfun.ret, ref : vfun.ref, kind : vfun.kind, args : vfun.args, expr : this.mapVars(vfun.expr)};
		let _g4 = 0;
		while(_g4 < vafterMap.length) {
			let f = vafterMap[_g4];
			++_g4;
			f();
		}
		let finits = [];
		let inf = fvars.iterator();
		while(inf.hasNext()) {
			let inf1 = inf.next();
			let v = inf1.v;
			switch(v.kind._hx_index) {
			case 1:
				let nv = { id : hxsl_Tools.allocVarId(), name : v.name, kind : hxsl_VarKind.Var, type : v.type};
				this.uniqueName(nv);
				let i = vvars.h[inf1.origin.id];
				if(i == null) {
					i = new hxsl__$Splitter_VarProps(v);
					vvars.h[inf1.origin.id] = i;
				}
				i.read++;
				this.varMap.set(inf1.origin,nv);
				let ninf = new hxsl__$Splitter_VarProps(nv);
				ninf.origin = inf1.origin;
				fvars.h[inf1.origin.id] = ninf;
				vvars.h[nv.id] = ninf;
				this.addExpr(vfun,{ e : hxsl_TExprDef.TBinop(haxe_macro_Binop.OpAssign,{ e : hxsl_TExprDef.TVar(nv), t : v.type, p : vfun.expr.p},{ e : hxsl_TExprDef.TVar(v), t : v.type, p : vfun.expr.p}), t : v.type, p : vfun.expr.p});
				break;
			case 3:
				if(inf1.write > 0) {
					let nv = { id : hxsl_Tools.allocVarId(), name : v.name, kind : hxsl_VarKind.Local, type : v.type};
					this.uniqueName(nv);
					finits.push({ e : hxsl_TExprDef.TVarDecl(nv,{ e : hxsl_TExprDef.TVar(v), t : v.type, p : ffun.expr.p}), t : hxsl_Type.TVoid, p : ffun.expr.p});
					this.varMap.set(inf1.origin,nv);
				}
				break;
			default:
			}
		}
		let v = vvars.iterator();
		while(v.hasNext()) {
			let v1 = v.next();
			this.checkVar(v1,true,vvars,vfun.expr.p);
		}
		let v1 = fvars.iterator();
		while(v1.hasNext()) {
			let v = v1.next();
			this.checkVar(v,false,vvars,ffun.expr.p);
		}
		ffun = { ret : ffun.ret, ref : ffun.ref, kind : ffun.kind, args : ffun.args, expr : this.mapVars(ffun.expr)};
		let _g5 = ffun.expr.e;
		if(_g5._hx_index == 4) {
			let _g = _g5.el;
			let _g1 = 0;
			while(_g1 < finits.length) {
				let e = finits[_g1];
				++_g1;
				_g.unshift(e);
			}
		} else {
			finits.push(ffun.expr);
			ffun.expr = { e : hxsl_TExprDef.TBlock(finits), t : hxsl_Type.TVoid, p : ffun.expr.p};
		}
		let _g6 = [];
		let v2 = vvars.iterator();
		while(v2.hasNext()) {
			let v = v2.next();
			if(!v.local) {
				_g6.push(v);
			}
		}
		let _g7 = [];
		let v3 = fvars.iterator();
		while(v3.hasNext()) {
			let v = v3.next();
			if(!v.local) {
				_g7.push(v);
			}
		}
		_g6.sort(function(v1,v2) {
			return (v1.origin == null ? v1.v.id : v1.origin.id) - (v2.origin == null ? v2.v.id : v2.origin.id);
		});
		_g7.sort(function(v1,v2) {
			return (v1.origin == null ? v1.v.id : v1.origin.id) - (v2.origin == null ? v2.v.id : v2.origin.id);
		});
		let _g8 = [];
		let _g9 = 0;
		while(_g9 < _g6.length) {
			let v = _g6[_g9];
			++_g9;
			_g8.push(v.v);
		}
		let tmp = { name : "vertex", vars : _g8, funs : [vfun]};
		let _g10 = [];
		let _g11 = 0;
		while(_g11 < _g7.length) {
			let v = _g7[_g11];
			++_g11;
			_g10.push(v.v);
		}
		return { vertex : tmp, fragment : { name : "fragment", vars : _g10, funs : [ffun]}};
	}
	addExpr(f,e) {
		let _g = f.expr.e;
		if(_g._hx_index == 4) {
			_g.el.push(e);
		} else {
			f.expr = { e : hxsl_TExprDef.TBlock([f.expr,e]), t : hxsl_Type.TVoid, p : f.expr.p};
		}
	}
	checkVar(v,vertex,vvars,p) {
		switch(v.v.kind._hx_index) {
		case 3:
			if(!vertex) {
				let i = vvars.h[v.origin.id];
				if(i != null && i.v.kind == hxsl_VarKind.Input) {
					return;
				}
				if(i == null || i.write == 0) {
					throw haxe_Exception.thrown(new hxsl_Error("Varying " + v.v.name + " is not written by vertex shader",p));
				}
			}
			break;
		case 4:
			if(v.requireInit) {
				throw haxe_Exception.thrown(new hxsl_Error("Variable " + v.v.name + " is used without being initialized",p));
			}
			break;
		default:
		}
	}
	mapVars(e) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 1:
			let v2 = this.varMap.h[_g.v.__id__];
			if(v2 == null) {
				return e;
			} else {
				return { e : hxsl_TExprDef.TVar(v2), t : e.t, p : e.p};
			}
			break;
		case 7:
			let _g1 = _g.init;
			let v21 = this.varMap.h[_g.v.__id__];
			if(v21 == null) {
				return hxsl_Tools.map(e,$bind(this,this.mapVars));
			} else {
				return { e : hxsl_TExprDef.TVarDecl(v21,_g1 == null ? null : this.mapVars(_g1)), t : e.t, p : e.p};
			}
			break;
		case 13:
			let v22 = this.varMap.h[_g.v.__id__];
			if(v22 == null) {
				return hxsl_Tools.map(e,$bind(this,this.mapVars));
			} else {
				return { e : hxsl_TExprDef.TFor(v22,this.mapVars(_g.it),this.mapVars(_g.loop)), t : e.t, p : e.p};
			}
			break;
		default:
			return hxsl_Tools.map(e,$bind(this,this.mapVars));
		}
	}
	get(v) {
		let i = this.vars.h[v.id];
		if(i == null) {
			let nv = this.varMap.h[v.__id__];
			if(nv == null) {
				if(v.kind == hxsl_VarKind.Global || v.kind == hxsl_VarKind.Output || v.kind == hxsl_VarKind.Input) {
					nv = v;
				} else {
					nv = { id : hxsl_Tools.allocVarId(), name : v.name, kind : v.kind, type : v.type};
					this.uniqueName(nv);
				}
				this.varMap.set(v,nv);
			}
			i = new hxsl__$Splitter_VarProps(nv);
			i.origin = v;
			this.vars.h[v.id] = i;
		}
		return i;
	}
	uniqueName(v) {
		if(v.kind == hxsl_VarKind.Global || v.kind == hxsl_VarKind.Output || v.kind == hxsl_VarKind.Input) {
			return;
		}
		let n = this.varNames.h[v.name];
		if(n != null && n != v) {
			let prefix = v.name;
			while(HxOverrides.cca(prefix,prefix.length - 1) >= 48 && HxOverrides.cca(prefix,prefix.length - 1) <= 57) prefix = HxOverrides.substr(prefix,0,-1);
			let k = prefix == v.name ? 2 : Std.parseInt(HxOverrides.substr(v.name,prefix.length,null));
			while(Object.prototype.hasOwnProperty.call(this.varNames.h,prefix + k)) ++k;
			v.name = prefix + k;
		}
		this.varNames.h[v.name] = v;
	}
	checkExpr(e) {
		let _g = e.e;
		switch(_g._hx_index) {
		case 1:
			let inf = this.get(_g.v);
			if(inf.write == 0) {
				inf.requireInit = true;
			}
			inf.read++;
			break;
		case 5:
			let _g1 = _g.e1;
			let _g2 = _g.e2;
			switch(_g.op._hx_index) {
			case 4:
				let _g3 = _g1.e;
				switch(_g3._hx_index) {
				case 1:
					let inf1 = this.get(_g3.v);
					inf1.write++;
					this.checkExpr(_g2);
					break;
				case 9:
					let _g4 = _g3.e.e;
					if(_g4._hx_index == 1) {
						let inf = this.get(_g4.v);
						inf.write++;
						this.checkExpr(_g2);
					} else {
						hxsl_Tools.iter(e,$bind(this,this.checkExpr));
					}
					break;
				default:
					hxsl_Tools.iter(e,$bind(this,this.checkExpr));
				}
				break;
			case 20:
				let _g5 = _g1.e;
				switch(_g5._hx_index) {
				case 1:
					let inf2 = this.get(_g5.v);
					if(inf2.write == 0) {
						inf2.requireInit = true;
					}
					inf2.read++;
					inf2.write++;
					this.checkExpr(_g2);
					break;
				case 9:
					let _g6 = _g5.e.e;
					if(_g6._hx_index == 1) {
						let inf = this.get(_g6.v);
						if(inf.write == 0) {
							inf.requireInit = true;
						}
						inf.read++;
						inf.write++;
						this.checkExpr(_g2);
					} else {
						hxsl_Tools.iter(e,$bind(this,this.checkExpr));
					}
					break;
				default:
					hxsl_Tools.iter(e,$bind(this,this.checkExpr));
				}
				break;
			default:
				hxsl_Tools.iter(e,$bind(this,this.checkExpr));
			}
			break;
		case 7:
			let _g7 = _g.init;
			let inf3 = this.get(_g.v);
			inf3.local = true;
			if(_g7 != null) {
				this.checkExpr(_g7);
				inf3.write++;
			}
			break;
		case 13:
			this.checkExpr(_g.it);
			let inf4 = this.get(_g.v);
			inf4.local = true;
			inf4.write++;
			this.checkExpr(_g.loop);
			break;
		default:
			hxsl_Tools.iter(e,$bind(this,this.checkExpr));
		}
	}
}
$hxClasses["hxsl.Splitter"] = hxsl_Splitter;
hxsl_Splitter.__name__ = "hxsl.Splitter";
Object.assign(hxsl_Splitter.prototype, {
	__class__: hxsl_Splitter
	,vars: null
	,varNames: null
	,varMap: null
});
class js_html__$CanvasElement_CanvasUtil {
	static getContextWebGL(canvas,attribs) {
		let ctx = canvas.getContext("webgl",attribs);
		if(ctx != null) {
			return ctx;
		}
		let ctx1 = canvas.getContext("experimental-webgl",attribs);
		if(ctx1 != null) {
			return ctx1;
		}
		return null;
	}
}
$hxClasses["js.html._CanvasElement.CanvasUtil"] = js_html__$CanvasElement_CanvasUtil;
js_html__$CanvasElement_CanvasUtil.__name__ = "js.html._CanvasElement.CanvasUtil";
Math.__name__ = "Math";
class mesh_Polygon extends h3d_prim_MeshPrimitive {
	constructor(points,idx) {
		super();
		this.points = points;
		this.idx = idx;
	}
	getBounds() {
		if(this.bounds == null) {
			let b = new h3d_col_Bounds();
			let _g = 0;
			let _g1 = this.points;
			while(_g < _g1.length) {
				let p = _g1[_g];
				++_g;
				if(p.x < b.xMin) {
					b.xMin = p.x;
				}
				if(p.x > b.xMax) {
					b.xMax = p.x;
				}
				if(p.y < b.yMin) {
					b.yMin = p.y;
				}
				if(p.y > b.yMax) {
					b.yMax = p.y;
				}
				if(p.z < b.zMin) {
					b.zMin = p.z;
				}
				if(p.z > b.zMax) {
					b.zMax = p.z;
				}
			}
			this.bounds = b;
		}
		return this.bounds;
	}
	alloc(engine) {
		this.dispose();
		let size = 3;
		let names = ["position"];
		let positions = [0];
		if(this.normals != null) {
			names.push("normal");
			positions.push(3);
			size = 6;
		}
		if(this.tangents != null) {
			names.push("t");
			positions.push(size);
			size += 3;
		}
		if(this.bitangents != null) {
			names.push("b");
			positions.push(size);
			size += 3;
		}
		if(this.texMatNormals != null) {
			names.push("n");
			positions.push(size);
			size += 3;
		}
		if(this.uvs != null) {
			names.push("uv");
			positions.push(size);
			size += 2;
		}
		let buf = hxd__$FloatBuffer_Float32Expand._new(0);
		let _g = 0;
		let _g1 = this.points.length;
		while(_g < _g1) {
			let k = _g++;
			let p = this.points[k];
			let v = p.x;
			if(buf.pos == buf.array.length) {
				let newSize = buf.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(buf.array);
				buf.array = newArray;
			}
			buf.array[buf.pos++] = v;
			let v1 = p.y;
			if(buf.pos == buf.array.length) {
				let newSize = buf.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(buf.array);
				buf.array = newArray;
			}
			buf.array[buf.pos++] = v1;
			let v2 = p.z;
			if(buf.pos == buf.array.length) {
				let newSize = buf.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(buf.array);
				buf.array = newArray;
			}
			buf.array[buf.pos++] = v2;
			if(this.normals != null) {
				let n = this.normals[k];
				let v = n.x;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v;
				let v1 = n.y;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v1;
				let v2 = n.z;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v2;
			}
			if(this.tangents != null) {
				let t = this.tangents[k];
				let v = t.x;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v;
				let v1 = t.y;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v1;
				let v2 = t.z;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v2;
			}
			if(this.bitangents != null) {
				let t = this.bitangents[k];
				let v = t.x;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v;
				let v1 = t.y;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v1;
				let v2 = t.z;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v2;
			}
			if(this.texMatNormals != null) {
				let t = this.texMatNormals[k];
				let v = t.x;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v;
				let v1 = t.y;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v1;
				let v2 = t.z;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v2;
			}
			if(this.uvs != null) {
				let t = this.uvs[k];
				let v = t.u;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v;
				let v1 = t.v;
				if(buf.pos == buf.array.length) {
					let newSize = buf.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(buf.array);
					buf.array = newArray;
				}
				buf.array[buf.pos++] = v1;
			}
		}
		let flags = [];
		if(this.idx == null) {
			flags.push(h3d_BufferFlag.Triangles);
		}
		if(this.normals == null || this.tangents != null) {
			flags.push(h3d_BufferFlag.RawFormat);
		}
		this.buffer = h3d_Buffer.ofFloats(buf,size,flags);
		let _g2 = 0;
		let _g3 = names.length;
		while(_g2 < _g3) {
			let i = _g2++;
			this.addBuffer(names[i],this.buffer,positions[i]);
		}
		if(this.idx != null) {
			this.indexes = h3d_Indexes.alloc(this.idx);
		}
	}
	addNormals() {
		this.normals = [];
		let _g = 0;
		let _g1 = this.points.length;
		while(_g < _g1) {
			let i = _g++;
			this.normals[i] = new h3d_col_Point();
		}
		let pos = 0;
		let _g2 = 0;
		let _g3 = this.triCount();
		while(_g2 < _g3) {
			++_g2;
			let i0;
			let i1;
			let i2;
			if(this.idx == null) {
				++pos;
				i0 = pos - 1;
				++pos;
				i1 = pos - 1;
				++pos;
				i2 = pos - 1;
			} else {
				i0 = this.idx[pos++];
				i1 = this.idx[pos++];
				i2 = this.idx[pos++];
			}
			let p0 = this.points[i0];
			let p1 = this.points[i1];
			let p2 = this.points[i2];
			let x = p1.x - p0.x;
			let y = p1.y - p0.y;
			let z = p1.z - p0.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let _this_x = x;
			let _this_y = y;
			let _this_z = z;
			let x1 = p2.x - p0.x;
			let y1 = p2.y - p0.y;
			let z1 = p2.z - p0.z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let p_x = x1;
			let p_y = y1;
			let p_z = z1;
			let x2 = _this_y * p_z - _this_z * p_y;
			let y2 = _this_z * p_x - _this_x * p_z;
			let z2 = _this_x * p_y - _this_y * p_x;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let n_x = x2;
			let n_y = y2;
			let n_z = z2;
			this.normals[i0].x += n_x;
			this.normals[i0].y += n_y;
			this.normals[i0].z += n_z;
			this.normals[i1].x += n_x;
			this.normals[i1].y += n_y;
			this.normals[i1].z += n_z;
			this.normals[i2].x += n_x;
			this.normals[i2].y += n_y;
			this.normals[i2].z += n_z;
		}
		let _g4 = 0;
		let _g5 = this.normals;
		while(_g4 < _g5.length) {
			let n = _g5[_g4];
			++_g4;
			let k = n.x * n.x + n.y * n.y + n.z * n.z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			n.x *= k;
			n.y *= k;
			n.z *= k;
		}
	}
	addTangents() {
		if(this.normals == null) {
			this.addNormals();
		}
		if(this.uvs == null) {
			this.addUVs();
		}
		this.tangents = [];
		let _g = 0;
		let _g1 = this.points.length;
		while(_g < _g1) {
			let i = _g++;
			this.tangents[i] = new h3d_col_Point();
		}
		let pos = 0;
		let _g2 = 0;
		let _g3 = this.triCount();
		while(_g2 < _g3) {
			++_g2;
			let i0;
			let i1;
			let i2;
			if(this.idx == null) {
				++pos;
				i0 = pos - 1;
				++pos;
				i1 = pos - 1;
				++pos;
				i2 = pos - 1;
			} else {
				i0 = this.idx[pos++];
				i1 = this.idx[pos++];
				i2 = this.idx[pos++];
			}
			let p0 = this.points[i0];
			let p1 = this.points[i1];
			let p2 = this.points[i2];
			let uv0 = this.uvs[i0];
			let uv1 = this.uvs[i1];
			let uv2 = this.uvs[i2];
			let n = this.normals[i0];
			let x = p1.x - p0.x;
			let y = p1.y - p0.y;
			let z = p1.z - p0.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let k0_x = x;
			let k0_y = y;
			let k0_z = z;
			let x1 = p2.x - p0.x;
			let y1 = p2.y - p0.y;
			let z1 = p2.z - p0.z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let k1_x = x1;
			let k1_y = y1;
			let k1_z = z1;
			let v = uv2.v - uv0.v;
			k0_x *= v;
			k0_y *= v;
			k0_z *= v;
			let v1 = uv1.v - uv0.v;
			k1_x *= v1;
			k1_y *= v1;
			k1_z *= v1;
			let t = new h3d_col_Point(k0_x - k1_x,k0_y - k1_y,k0_z - k1_z);
			let x2 = n.y * t.z - n.z * t.y;
			let y2 = n.z * t.x - n.x * t.z;
			let z2 = n.x * t.y - n.y * t.x;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let b_x = x2;
			let b_y = y2;
			let b_z = z2;
			let k = b_x * b_x + b_y * b_y + b_z * b_z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			b_x *= k;
			b_y *= k;
			b_z *= k;
			t = new h3d_col_Point(b_y * n.z - b_z * n.y,b_z * n.x - b_x * n.z,b_x * n.y - b_y * n.x);
			let k1 = t.x * t.x + t.y * t.y + t.z * t.z;
			if(k1 < 1e-10) {
				k1 = 0;
			} else {
				k1 = 1. / Math.sqrt(k1);
			}
			t.x *= k1;
			t.y *= k1;
			t.z *= k1;
			this.tangents[i0].x += t.x;
			this.tangents[i0].y += t.y;
			this.tangents[i0].z += t.z;
			this.tangents[i1].x += t.x;
			this.tangents[i1].y += t.y;
			this.tangents[i1].z += t.z;
			this.tangents[i2].x += t.x;
			this.tangents[i2].y += t.y;
			this.tangents[i2].z += t.z;
		}
		let _g4 = 0;
		let _g5 = this.tangents;
		while(_g4 < _g5.length) {
			let t = _g5[_g4];
			++_g4;
			let k = t.x * t.x + t.y * t.y + t.z * t.z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			t.x *= k;
			t.y *= k;
			t.z *= k;
		}
	}
	addUVs() {
		this.uvs = [];
		let _g = 0;
		let _g1 = this.points.length;
		while(_g < _g1) {
			let i = _g++;
			this.uvs[i] = new h3d_prim_UV(this.points[i].x,this.points[i].y);
		}
	}
	triCount() {
		let n = super.triCount();
		if(n != 0) {
			return n;
		}
		return (this.idx == null ? this.points.length : this.idx.length) / 3 | 0;
	}
	render(engine) {
		let tmp;
		if(this.buffer != null) {
			let _this = this.buffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.alloc(engine);
		}
		let bufs = this.getBuffers(engine);
		if(this.indexes != null) {
			engine.renderMultiBuffers(bufs,this.indexes);
		} else if((this.buffer.flags & 4) != 0) {
			engine.renderMultiBuffers(bufs,engine.mem.quadIndexes,0,this.triCount());
		} else {
			engine.renderMultiBuffers(bufs,engine.mem.triIndexes,0,this.triCount());
		}
	}
}
$hxClasses["mesh.Polygon"] = mesh_Polygon;
mesh_Polygon.__name__ = "mesh.Polygon";
mesh_Polygon.__super__ = h3d_prim_MeshPrimitive;
Object.assign(mesh_Polygon.prototype, {
	__class__: mesh_Polygon
	,points: null
	,normals: null
	,tangents: null
	,bitangents: null
	,texMatNormals: null
	,uvs: null
	,idx: null
	,bounds: null
});
class mis_MisFile {
	constructor() {
	}
}
$hxClasses["mis.MisFile"] = mis_MisFile;
mis_MisFile.__name__ = "mis.MisFile";
Object.assign(mis_MisFile.prototype, {
	__class__: mis_MisFile
	,root: null
	,marbleAttributes: null
	,activatedPackages: null
});
class mis_MisParser {
	constructor(text) {
		this.currentElementId = 0;
		this.index = 0;
		this.text = text;
		if(mis_MisParser.localizations == null) {
			let lfile = src_ResourceLoader.getFileEntry("data/englishStrings.inf");
			let contents = lfile.entry.getText();
			let lines = contents.split("\n");
			mis_MisParser.localizations = new haxe_ds_StringMap();
			let rgx = new EReg("(\\$(?:\\w|\\d|:)+)\\s*=\\s*\"(.+?)\";","g");
			let _g = 0;
			while(_g < lines.length) {
				let line = lines[_g];
				++_g;
				if(rgx.match(line)) {
					let this1 = mis_MisParser.localizations;
					let key = StringTools.trim(rgx.matched(1));
					if(!Object.prototype.hasOwnProperty.call(this1.h,key)) {
						let this1 = mis_MisParser.localizations;
						let key = StringTools.trim(rgx.matched(1));
						let value = StringTools.trim(rgx.matched(2));
						this1.h[key] = value;
					}
				}
			}
		}
	}
	parse() {
		let objectWriteBeginIndex = this.text.indexOf("//--- OBJECT WRITE BEGIN ---");
		let objectWriteEndIndex = this.text.lastIndexOf("//--- OBJECT WRITE END ---");
		let outsideText = this.text.substring(0,objectWriteBeginIndex) + this.text.substring(objectWriteEndIndex);
		let _g = new haxe_ds_StringMap();
		_g.h["$usermods"] = "\"\"";
		this.variables = _g;
		let h = mis_MisParser.localizations.h;
		let _g_keys = Object.keys(h);
		let _g_length = _g_keys.length;
		let _g_current = 0;
		while(_g_current < _g_length) {
			let key = _g_keys[_g_current++];
			let _g_value = h[key];
			this.variables.h[key] = "\"" + _g_value + "\"";
		}
		let startText = outsideText;
		while(mis_MisParser_assignmentRegEx.match(startText)) {
			let this1 = this.variables;
			let key = mis_MisParser_assignmentRegEx.matched(1);
			if(!Object.prototype.hasOwnProperty.call(this1.h,key)) {
				let this1 = this.variables;
				let key = mis_MisParser_assignmentRegEx.matched(1);
				let value = mis_MisParser_assignmentRegEx.matched(2);
				this1.h[key] = value;
			}
			startText = mis_MisParser_assignmentRegEx.matchedRight();
		}
		let marbleAttributes = new haxe_ds_StringMap();
		startText = outsideText;
		while(mis_MisParser_marbleAttributesRegEx.match(startText)) {
			let key = mis_MisParser_marbleAttributesRegEx.matched(1).toLowerCase();
			let value = this.resolveExpression(mis_MisParser_marbleAttributesRegEx.matched(2));
			marbleAttributes.h[key] = value;
			startText = mis_MisParser_marbleAttributesRegEx.matchedRight();
		}
		let activatedPackages = [];
		startText = outsideText;
		let customMaterials_h = Object.create(null);
		while(mis_MisParser_materialPropertyRegEx.match(startText)) {
			let materialName = mis_MisParser_materialPropertyRegEx.matched(1);
			let subs = mis_MisParser_materialPropertyRegEx.matched(2);
			let kvps_h = Object.create(null);
			let _this = subs.split(";");
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = StringTools.trim(_this[i]).toLowerCase();
			}
			let _g2 = 0;
			while(_g2 < result.length) {
				let prop = result[_g2];
				++_g2;
				let _this = prop.split("=");
				let result1 = new Array(_this.length);
				let _g = 0;
				let _g1 = _this.length;
				while(_g < _g1) {
					let i = _g++;
					result1[i] = StringTools.trim(_this[i]).toLowerCase();
				}
				let value = parseFloat(result1[1]);
				kvps_h[result1[0]] = value;
			}
			let tmp = kvps_h["friction"];
			let tmp1 = kvps_h["restitution"];
			let tmp2 = kvps_h["force"];
			let material = { friction : tmp != null ? tmp : 1.0, restitution : tmp1 != null ? tmp1 : 1.0, force : tmp2 != null ? tmp2 : 0.0};
			customMaterials_h[materialName] = material;
			startText = mis_MisParser_materialPropertyRegEx.matchedRight();
		}
		startText = outsideText;
		let materialMappings = new haxe_ds_StringMap();
		while(mis_MisParser_addMaterialMappingRegEx.match(startText)) {
			let mmap = mis_MisParser_addMaterialMappingRegEx.matched(2);
			if(Object.prototype.hasOwnProperty.call(customMaterials_h,mmap)) {
				let key = mis_MisParser_addMaterialMappingRegEx.matched(1).toLowerCase();
				materialMappings.h[key] = customMaterials_h[mmap];
			}
			startText = mis_MisParser_addMaterialMappingRegEx.matchedRight();
		}
		src_DifBuilder.setCustomMaterialDefinitions(materialMappings);
		startText = outsideText;
		while(mis_MisParser_activatePackageRegEx.match(startText)) {
			activatedPackages.push(this.resolveExpression(mis_MisParser_activatePackageRegEx.matched(1)));
			startText = mis_MisParser_marbleAttributesRegEx.matchedRight();
		}
		if(objectWriteBeginIndex != -1 && objectWriteEndIndex != -1) {
			this.text = this.text.substring(objectWriteBeginIndex,objectWriteEndIndex);
		}
		let currentIndex = 0;
		while(true) {
			let blockMatch = mis_MisParser_blockCommentRegEx.matchSub(this.text,currentIndex);
			let lineMatch = mis_MisParser_lineCommentRegEx.matchSub(this.text,currentIndex);
			if(blockMatch && src_Util.indexIsInStringLiteral(this.text,mis_MisParser_blockCommentRegEx.matchedPos().pos)) {
				blockMatch = false;
			}
			if(lineMatch && src_Util.indexIsInStringLiteral(this.text,mis_MisParser_lineCommentRegEx.matchedPos().pos)) {
				lineMatch = false;
			}
			if(!blockMatch && !lineMatch) {
				break;
			} else if(!lineMatch || blockMatch && lineMatch && mis_MisParser_blockCommentRegEx.matchedPos().pos < mis_MisParser_lineCommentRegEx.matchedPos().pos) {
				this.text = this.text.substring(0,mis_MisParser_blockCommentRegEx.matchedPos().pos) + this.text.substring(mis_MisParser_blockCommentRegEx.matchedPos().pos + mis_MisParser_blockCommentRegEx.matchedPos().len);
				currentIndex += mis_MisParser_blockCommentRegEx.matchedPos().pos;
			} else {
				this.text = this.text.substring(0,mis_MisParser_lineCommentRegEx.matchedPos().pos) + this.text.substring(mis_MisParser_lineCommentRegEx.matchedPos().pos + mis_MisParser_lineCommentRegEx.matchedPos().len);
				currentIndex += mis_MisParser_lineCommentRegEx.matchedPos().pos;
			}
		}
		let indexOfMissionGroup = this.text.indexOf("new SimGroup(MissionGroup)");
		if(indexOfMissionGroup != -1) {
			this.index = indexOfMissionGroup;
		}
		let elements = [];
		while(this.hasNextElement()) {
			let element = this.readElement();
			if(element == null) {
				continue;
			}
			elements.push(element);
		}
		if(elements.length != 1) {
			throw new haxe_Exception("Mission file doesn't have exactly 1 outer element!");
		}
		let mf = new mis_MisFile();
		mf.root = elements[0];
		mf.marbleAttributes = marbleAttributes;
		mf.activatedPackages = activatedPackages;
		return mf;
	}
	parseMissionInfo() {
		let _g = new haxe_ds_StringMap();
		_g.h["$usermods"] = "\"\"";
		this.variables = _g;
		let h = mis_MisParser.localizations.h;
		let _g_keys = Object.keys(h);
		let _g_length = _g_keys.length;
		let _g_current = 0;
		while(_g_current < _g_length) {
			let key = _g_keys[_g_current++];
			let _g_value = h[key];
			this.variables.h[key] = "\"" + _g_value + "\"";
		}
		let missionInfoIndex = this.text.indexOf("new ScriptObject(MissionInfo)");
		this.index = missionInfoIndex;
		let mInfo = this.readElement();
		return mInfo;
	}
	readElement() {
		mis_MisParser_elementHeadRegEx.match(this.text.substring(this.index));
		this.index += mis_MisParser_elementHeadRegEx.matchedPos().pos + mis_MisParser_elementHeadRegEx.matchedPos().len;
		let type = mis_MisParser_elementHeadRegEx.matched(1);
		let name = mis_MisParser_elementHeadRegEx.matched(2);
		let element = null;
		let _gthis = this;
		switch(type) {
		case "AudioProfile":
			let fn = function() {
				let obj = new mis_MissionElementAudioProfile();
				obj._type = mis_MissionElementType.AudioProfile;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn();
			break;
		case "InteriorInstance":
			let fn1 = function() {
				let obj = new mis_MissionElementInteriorInstance();
				obj._type = mis_MissionElementType.InteriorInstance;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn1();
			break;
		case "Item":
			let fn2 = function() {
				let obj = new mis_MissionElementItem();
				obj._type = mis_MissionElementType.Item;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn2();
			break;
		case "Marker":
			let fn3 = function() {
				let obj = new mis_MissionElementMarker();
				obj._type = mis_MissionElementType.Marker;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn3();
			break;
		case "MessageVector":
			let fn4 = function() {
				let obj = new mis_MissionElementMessageVector();
				obj._type = mis_MissionElementType.MessageVector;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn4();
			break;
		case "MissionArea":
			let fn5 = function() {
				let obj = new mis_MissionElementMissionArea();
				obj._type = mis_MissionElementType.MissionArea;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn5();
			break;
		case "ParticleEmitterNode":
			let fn6 = function() {
				let obj = new mis_MissionElementParticleEmitterNode();
				obj._type = mis_MissionElementType.ParticleEmitterNode;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn6();
			break;
		case "Path":
			element = this.readPath(name);
			break;
		case "PathedInterior":
			let fn7 = function() {
				let obj = new mis_MissionElementPathedInterior();
				obj._type = mis_MissionElementType.PathedInterior;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn7();
			break;
		case "ScriptObject":
			let fn8 = function() {
				let obj = new mis_MissionElementScriptObject();
				obj._type = mis_MissionElementType.ScriptObject;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn8();
			break;
		case "SimGroup":
			element = this.readSimGroup(name);
			break;
		case "Sky":
			let fn9 = function() {
				let obj = new mis_MissionElementSky();
				obj._type = mis_MissionElementType.Sky;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn9();
			break;
		case "SpawnSphere":
			let fn10 = function() {
				let obj = new mis_MissionElementSpawnSphere();
				obj._type = mis_MissionElementType.SpawnSphere;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn10();
			break;
		case "StaticShape":
			let fn11 = function() {
				let obj = new mis_MissionElementStaticShape();
				obj._type = mis_MissionElementType.StaticShape;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn11();
			break;
		case "Sun":
			let fn12 = function() {
				let obj = new mis_MissionElementSun();
				obj._type = mis_MissionElementType.Sun;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn12();
			break;
		case "TSStatic":
			let fn13 = function() {
				let obj = new mis_MissionElementTSStatic();
				obj._type = mis_MissionElementType.TSStatic;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn13();
			break;
		case "Trigger":
			let fn14 = function() {
				let obj = new mis_MissionElementTrigger();
				obj._type = mis_MissionElementType.Trigger;
				obj._name = name;
				_gthis.copyFields(obj);
				return obj;
			};
			element = fn14();
			break;
		default:
			src_Console.instance.addEntry("warn","Unknown element type! " + type);
			let endingBraceIndex = src_Util.indexOfIgnoreStringLiterals(this.text,"};",this.index);
			if(endingBraceIndex == -1) {
				endingBraceIndex = this.text.length;
			}
			this.index = endingBraceIndex + 2;
		}
		if(element != null) {
			element._id = this.currentElementId++;
		}
		return element;
	}
	hasNextElement() {
		if(!mis_MisParser_elementHeadRegEx.matchSub(this.text,Math.min(this.text.length - 1,this.index) | 0)) {
			return false;
		}
		if(src_Util.indexOfIgnoreStringLiterals(this.text.substring(this.index,mis_MisParser_elementHeadRegEx.matchedPos().pos),"}") != -1) {
			return false;
		}
		return true;
	}
	readSimGroup(name) {
		let elements = [];
		while(this.hasNextElement()) {
			let element = this.readElement();
			if(element == null) {
				continue;
			}
			elements.push(element);
		}
		let endingBraceIndex = src_Util.indexOfIgnoreStringLiterals(this.text,"};",this.index);
		if(endingBraceIndex == -1) {
			endingBraceIndex = this.text.length;
		}
		this.index = endingBraceIndex + 2;
		let sg = new mis_MissionElementSimGroup();
		sg._name = name;
		sg._type = mis_MissionElementType.SimGroup;
		sg.elements = elements;
		return sg;
	}
	readValues() {
		let obj = new haxe_ds_StringMap();
		let endingBraceIndex = src_Util.indexOfIgnoreStringLiterals(this.text,"};",this.index);
		if(endingBraceIndex == -1) {
			endingBraceIndex = this.text.length;
		}
		let section = StringTools.trim(this.text.substring(this.index,endingBraceIndex));
		let _this = src_Util.splitIgnoreStringLiterals(section,";");
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = StringTools.trim(_this[i]);
		}
		let _g2 = 0;
		while(_g2 < result.length) {
			let statement = result[_g2];
			++_g2;
			if(statement == null || statement == "") {
				continue;
			}
			let splitIndex = statement.indexOf("=");
			if(splitIndex == -1) {
				continue;
			}
			let _this = [statement.substring(0,splitIndex),statement.substring(splitIndex + 1)];
			let result1 = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result1[i] = StringTools.trim(_this[i]);
			}
			if(result1.length != 2) {
				continue;
			}
			let key = result1[0];
			key = key.toLowerCase();
			if(key.endsWith("]")) {
				let openingIndex = key.indexOf("[");
				let arrayName = key.substring(0,openingIndex);
				let array;
				if(Object.prototype.hasOwnProperty.call(obj.h,arrayName)) {
					array = obj.h[arrayName];
				} else {
					array = [];
					obj.h[arrayName] = array;
				}
				let index = Std.parseInt(key.substring(openingIndex + 1,-1));
				array[index] = this.resolveExpression(result1[1]);
			} else {
				let value = [this.resolveExpression(result1[1])];
				obj.h[key] = value;
			}
		}
		this.index = endingBraceIndex + 2;
		return obj;
	}
	copyFields(obj) {
		let values = this.readValues();
		let objfields = Type.getInstanceFields(js_Boot.getClass(obj));
		let h = values.h;
		let _g_keys = Object.keys(h);
		let _g_length = _g_keys.length;
		let _g_current = 0;
		while(_g_current < _g_length) {
			let key = _g_keys[_g_current++];
			let _g_value = h[key];
			let key1 = key;
			if(_g_value.length > 1) {
				let _g = 0;
				let _g1 = _g_value.length;
				while(_g < _g1) {
					let i = _g++;
					let fname = "" + key + i;
					if(objfields.includes(fname)) {
						obj[fname] = _g_value[i];
					}
				}
			} else {
				if(key == "static") {
					key1 = "isStatic";
				}
				if(objfields.includes(key1)) {
					obj[key1] = _g_value[0];
				}
			}
		}
		obj["fields"] = values;
	}
	readPath(name) {
		let sg = this.readSimGroup(name);
		let obj = new mis_MissionElementPath();
		obj._type = mis_MissionElementType.Path;
		obj._name = name;
		let _this = sg.elements;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = _this[i];
		}
		obj.markers = result;
		obj.markers.sort(function(a,b) {
			return mis_MisParser.parseNumber(a.seqnum) - mis_MisParser.parseNumber(b.seqnum);
		});
		return obj;
	}
	resolveExpression(expr) {
		let _this = src_Util.splitIgnoreStringLiterals(expr,"@");
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			let x = _this[i];
			x = StringTools.trim(x);
			if(x.startsWith("$") && this.variables.h[x] != null) {
				x = this.resolveExpression(this.variables.h[x]);
			} else if(x.startsWith("\"") && x.endsWith("\"")) {
				x = src_Util.unescape(x.substring(1,x.length - 1));
			}
			result[i] = x;
		}
		return result.join("");
	}
	static parseVector3(string) {
		if(string == null) {
			return new h3d_Vector();
		}
		let _this = string.split(" ");
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = parseFloat(_this[i]);
		}
		if(result.length < 3) {
			return new h3d_Vector();
		}
		let _g2 = [];
		let _g3 = 0;
		while(_g3 < result.length) {
			let v = result[_g3];
			++_g3;
			if(!isFinite(v)) {
				_g2.push(v);
			}
		}
		if(_g2.length != 0) {
			return new h3d_Vector();
		}
		return new h3d_Vector(result[0],result[1],result[2]);
	}
	static parseVector4(string) {
		if(string == null) {
			return new h3d_Vector();
		}
		let _this = string.split(" ");
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = parseFloat(_this[i]);
		}
		if(result.length < 4) {
			return new h3d_Vector();
		}
		let _g2 = [];
		let _g3 = 0;
		while(_g3 < result.length) {
			let v = result[_g3];
			++_g3;
			if(!isFinite(v)) {
				_g2.push(v);
			}
		}
		if(_g2.length != 0) {
			return new h3d_Vector();
		}
		return new h3d_Vector(result[0],result[1],result[2],result[3]);
	}
	static parseRotation(string) {
		if(string == null) {
			return new h3d_Quat();
		}
		let _this = string.split(" ");
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = parseFloat(_this[i]);
		}
		if(result.length < 4) {
			return new h3d_Quat();
		}
		let _g2 = [];
		let _g3 = 0;
		while(_g3 < result.length) {
			let v = result[_g3];
			++_g3;
			if(!isFinite(v)) {
				_g2.push(v);
			}
		}
		if(_g2.length != 0) {
			return new h3d_Quat();
		}
		let quaternion = new h3d_Quat();
		let x = result[0];
		let y = result[1];
		let z = result[2];
		let a = -result[3] * Math.PI / 180;
		let sin = Math.sin(a / 2);
		let cos = Math.cos(a / 2);
		quaternion.x = x * sin;
		quaternion.y = y * sin;
		quaternion.z = z * sin;
		quaternion.w = cos * Math.sqrt(x * x + y * y + z * z);
		let len = quaternion.x * quaternion.x + quaternion.y * quaternion.y + quaternion.z * quaternion.z + quaternion.w * quaternion.w;
		if(len < 1e-10) {
			quaternion.x = quaternion.y = quaternion.z = 0;
			quaternion.w = 1;
		} else {
			let m = 1. / Math.sqrt(len);
			quaternion.x *= m;
			quaternion.y *= m;
			quaternion.z *= m;
			quaternion.w *= m;
		}
		return quaternion;
	}
	static parseNumber(string) {
		if(string == null) {
			return 0;
		}
		let val = parseFloat(string.split(",")[0]);
		if(isNaN(val)) {
			return 0;
		}
		return val;
	}
	static parseNumberList(string) {
		let parts = string.split(" ");
		let result = [];
		let _g = 0;
		while(_g < parts.length) {
			let part = parts[_g];
			++_g;
			let number = parseFloat(part);
			if(!isNaN(number)) {
				result.push(number);
			} else {
				while(part.length > 0) {
					let dotIndex = part.indexOf(".");
					if(dotIndex == -1) {
						break;
					}
					let section = part.substring(0,Math.min(dotIndex + 7 + 1,part.length));
					result.push(parseFloat(section));
					part = part.substring(dotIndex + 7 + 1);
				}
			}
		}
		return result;
	}
	static parseBoolean(string) {
		if(string == "true") {
			return true;
		}
		if(string == "false") {
			return false;
		}
		if(string == null) {
			return false;
		}
		if(string == "") {
			return false;
		}
		if(string == "0") {
			return false;
		}
		return true;
	}
}
$hxClasses["mis.MisParser"] = mis_MisParser;
mis_MisParser.__name__ = "mis.MisParser";
Object.assign(mis_MisParser.prototype, {
	__class__: mis_MisParser
	,text: null
	,index: null
	,currentElementId: null
	,variables: null
});
var mis_MissionElementType = $hxEnums["mis.MissionElementType"] = { __ename__:true,__constructs__:null
	,SimGroup: {_hx_name:"SimGroup",_hx_index:0,__enum__:"mis.MissionElementType",toString:$estr}
	,ScriptObject: {_hx_name:"ScriptObject",_hx_index:1,__enum__:"mis.MissionElementType",toString:$estr}
	,MissionArea: {_hx_name:"MissionArea",_hx_index:2,__enum__:"mis.MissionElementType",toString:$estr}
	,Sky: {_hx_name:"Sky",_hx_index:3,__enum__:"mis.MissionElementType",toString:$estr}
	,Sun: {_hx_name:"Sun",_hx_index:4,__enum__:"mis.MissionElementType",toString:$estr}
	,InteriorInstance: {_hx_name:"InteriorInstance",_hx_index:5,__enum__:"mis.MissionElementType",toString:$estr}
	,StaticShape: {_hx_name:"StaticShape",_hx_index:6,__enum__:"mis.MissionElementType",toString:$estr}
	,SpawnSphere: {_hx_name:"SpawnSphere",_hx_index:7,__enum__:"mis.MissionElementType",toString:$estr}
	,Item: {_hx_name:"Item",_hx_index:8,__enum__:"mis.MissionElementType",toString:$estr}
	,Path: {_hx_name:"Path",_hx_index:9,__enum__:"mis.MissionElementType",toString:$estr}
	,Marker: {_hx_name:"Marker",_hx_index:10,__enum__:"mis.MissionElementType",toString:$estr}
	,PathedInterior: {_hx_name:"PathedInterior",_hx_index:11,__enum__:"mis.MissionElementType",toString:$estr}
	,Trigger: {_hx_name:"Trigger",_hx_index:12,__enum__:"mis.MissionElementType",toString:$estr}
	,AudioProfile: {_hx_name:"AudioProfile",_hx_index:13,__enum__:"mis.MissionElementType",toString:$estr}
	,MessageVector: {_hx_name:"MessageVector",_hx_index:14,__enum__:"mis.MissionElementType",toString:$estr}
	,TSStatic: {_hx_name:"TSStatic",_hx_index:15,__enum__:"mis.MissionElementType",toString:$estr}
	,ParticleEmitterNode: {_hx_name:"ParticleEmitterNode",_hx_index:16,__enum__:"mis.MissionElementType",toString:$estr}
};
mis_MissionElementType.__constructs__ = [mis_MissionElementType.SimGroup,mis_MissionElementType.ScriptObject,mis_MissionElementType.MissionArea,mis_MissionElementType.Sky,mis_MissionElementType.Sun,mis_MissionElementType.InteriorInstance,mis_MissionElementType.StaticShape,mis_MissionElementType.SpawnSphere,mis_MissionElementType.Item,mis_MissionElementType.Path,mis_MissionElementType.Marker,mis_MissionElementType.PathedInterior,mis_MissionElementType.Trigger,mis_MissionElementType.AudioProfile,mis_MissionElementType.MessageVector,mis_MissionElementType.TSStatic,mis_MissionElementType.ParticleEmitterNode];
mis_MissionElementType.__empty_constructs__ = [mis_MissionElementType.SimGroup,mis_MissionElementType.ScriptObject,mis_MissionElementType.MissionArea,mis_MissionElementType.Sky,mis_MissionElementType.Sun,mis_MissionElementType.InteriorInstance,mis_MissionElementType.StaticShape,mis_MissionElementType.SpawnSphere,mis_MissionElementType.Item,mis_MissionElementType.Path,mis_MissionElementType.Marker,mis_MissionElementType.PathedInterior,mis_MissionElementType.Trigger,mis_MissionElementType.AudioProfile,mis_MissionElementType.MessageVector,mis_MissionElementType.TSStatic,mis_MissionElementType.ParticleEmitterNode];
class mis_MissionElementBase {
}
$hxClasses["mis.MissionElementBase"] = mis_MissionElementBase;
mis_MissionElementBase.__name__ = "mis.MissionElementBase";
Object.assign(mis_MissionElementBase.prototype, {
	__class__: mis_MissionElementBase
	,_type: null
	,_name: null
	,_id: null
	,fields: null
});
class mis_MissionElementSimGroup extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.SimGroup;
	}
}
$hxClasses["mis.MissionElementSimGroup"] = mis_MissionElementSimGroup;
mis_MissionElementSimGroup.__name__ = "mis.MissionElementSimGroup";
mis_MissionElementSimGroup.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementSimGroup.prototype, {
	__class__: mis_MissionElementSimGroup
	,elements: null
});
class mis_MissionElementScriptObject extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.ScriptObject;
	}
}
$hxClasses["mis.MissionElementScriptObject"] = mis_MissionElementScriptObject;
mis_MissionElementScriptObject.__name__ = "mis.MissionElementScriptObject";
mis_MissionElementScriptObject.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementScriptObject.prototype, {
	__class__: mis_MissionElementScriptObject
	,time: null
	,name: null
	,desc: null
	,type: null
	,starthelptext: null
	,level: null
	,artist: null
	,goldtime: null
	,ultimatetime: null
	,game: null
	,difficulty: null
	,gamemode: null
	,gemgroupradius: null
	,maxgemspergroup: null
});
class mis_MissionElementMissionArea extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.MissionArea;
	}
}
$hxClasses["mis.MissionElementMissionArea"] = mis_MissionElementMissionArea;
mis_MissionElementMissionArea.__name__ = "mis.MissionElementMissionArea";
mis_MissionElementMissionArea.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementMissionArea.prototype, {
	__class__: mis_MissionElementMissionArea
});
class mis_MissionElementSky extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.Sky;
	}
}
$hxClasses["mis.MissionElementSky"] = mis_MissionElementSky;
mis_MissionElementSky.__name__ = "mis.MissionElementSky";
mis_MissionElementSky.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementSky.prototype, {
	__class__: mis_MissionElementSky
	,visibledistance: null
	,useskytextures: null
	,skysolidcolor: null
	,fogcolor: null
	,materiallist: null
});
class mis_MissionElementSun extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.Sun;
	}
}
$hxClasses["mis.MissionElementSun"] = mis_MissionElementSun;
mis_MissionElementSun.__name__ = "mis.MissionElementSun";
mis_MissionElementSun.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementSun.prototype, {
	__class__: mis_MissionElementSun
	,direction: null
	,color: null
	,ambient: null
});
class mis_MissionElementInteriorInstance extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.InteriorInstance;
	}
}
$hxClasses["mis.MissionElementInteriorInstance"] = mis_MissionElementInteriorInstance;
mis_MissionElementInteriorInstance.__name__ = "mis.MissionElementInteriorInstance";
mis_MissionElementInteriorInstance.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementInteriorInstance.prototype, {
	__class__: mis_MissionElementInteriorInstance
	,position: null
	,rotation: null
	,scale: null
	,interiorfile: null
});
class mis_MissionElementStaticShape extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.StaticShape;
	}
}
$hxClasses["mis.MissionElementStaticShape"] = mis_MissionElementStaticShape;
mis_MissionElementStaticShape.__name__ = "mis.MissionElementStaticShape";
mis_MissionElementStaticShape.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementStaticShape.prototype, {
	__class__: mis_MissionElementStaticShape
	,position: null
	,rotation: null
	,scale: null
	,datablock: null
});
class mis_MissionElementSpawnSphere extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.SpawnSphere;
	}
}
$hxClasses["mis.MissionElementSpawnSphere"] = mis_MissionElementSpawnSphere;
mis_MissionElementSpawnSphere.__name__ = "mis.MissionElementSpawnSphere";
mis_MissionElementSpawnSphere.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementSpawnSphere.prototype, {
	__class__: mis_MissionElementSpawnSphere
	,position: null
	,rotation: null
	,datablock: null
	,gemdatablock: null
});
class mis_MissionElementItem extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.Item;
	}
}
$hxClasses["mis.MissionElementItem"] = mis_MissionElementItem;
mis_MissionElementItem.__name__ = "mis.MissionElementItem";
mis_MissionElementItem.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementItem.prototype, {
	__class__: mis_MissionElementItem
	,position: null
	,rotation: null
	,scale: null
	,datablock: null
	,permanent: null
	,showhelponpickup: null
	,timebonus: null
	,timepenalty: null
});
class mis_MissionElementPath extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.Path;
	}
}
$hxClasses["mis.MissionElementPath"] = mis_MissionElementPath;
mis_MissionElementPath.__name__ = "mis.MissionElementPath";
mis_MissionElementPath.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementPath.prototype, {
	__class__: mis_MissionElementPath
	,markers: null
});
class mis_MissionElementMarker extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.Marker;
	}
}
$hxClasses["mis.MissionElementMarker"] = mis_MissionElementMarker;
mis_MissionElementMarker.__name__ = "mis.MissionElementMarker";
mis_MissionElementMarker.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementMarker.prototype, {
	__class__: mis_MissionElementMarker
	,position: null
	,rotation: null
	,seqnum: null
	,mstonext: null
	,smoothingtype: null
});
class mis_MissionElementPathedInterior extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.PathedInterior;
	}
}
$hxClasses["mis.MissionElementPathedInterior"] = mis_MissionElementPathedInterior;
mis_MissionElementPathedInterior.__name__ = "mis.MissionElementPathedInterior";
mis_MissionElementPathedInterior.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementPathedInterior.prototype, {
	__class__: mis_MissionElementPathedInterior
	,datablock: null
	,interiorresource: null
	,interiorindex: null
	,baseposition: null
	,baserotation: null
	,basescale: null
	,initialtargetposition: null
	,initialposition: null
});
class mis_MissionElementTrigger extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.Trigger;
	}
}
$hxClasses["mis.MissionElementTrigger"] = mis_MissionElementTrigger;
mis_MissionElementTrigger.__name__ = "mis.MissionElementTrigger";
mis_MissionElementTrigger.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementTrigger.prototype, {
	__class__: mis_MissionElementTrigger
	,position: null
	,rotation: null
	,scale: null
	,datablock: null
	,polyhedron: null
	,text: null
	,targettime: null
	,instant: null
	,icontinuetottime: null
	,sequence: null
});
class mis_MissionElementAudioProfile extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.AudioProfile;
	}
}
$hxClasses["mis.MissionElementAudioProfile"] = mis_MissionElementAudioProfile;
mis_MissionElementAudioProfile.__name__ = "mis.MissionElementAudioProfile";
mis_MissionElementAudioProfile.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementAudioProfile.prototype, {
	__class__: mis_MissionElementAudioProfile
});
class mis_MissionElementMessageVector extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.MessageVector;
	}
}
$hxClasses["mis.MissionElementMessageVector"] = mis_MissionElementMessageVector;
mis_MissionElementMessageVector.__name__ = "mis.MissionElementMessageVector";
mis_MissionElementMessageVector.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementMessageVector.prototype, {
	__class__: mis_MissionElementMessageVector
});
class mis_MissionElementTSStatic extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.TSStatic;
	}
}
$hxClasses["mis.MissionElementTSStatic"] = mis_MissionElementTSStatic;
mis_MissionElementTSStatic.__name__ = "mis.MissionElementTSStatic";
mis_MissionElementTSStatic.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementTSStatic.prototype, {
	__class__: mis_MissionElementTSStatic
	,position: null
	,rotation: null
	,scale: null
	,shapename: null
});
class mis_MissionElementParticleEmitterNode extends mis_MissionElementBase {
	constructor() {
		super();
		this._type = mis_MissionElementType.ParticleEmitterNode;
	}
}
$hxClasses["mis.MissionElementParticleEmitterNode"] = mis_MissionElementParticleEmitterNode;
mis_MissionElementParticleEmitterNode.__name__ = "mis.MissionElementParticleEmitterNode";
mis_MissionElementParticleEmitterNode.__super__ = mis_MissionElementBase;
Object.assign(mis_MissionElementParticleEmitterNode.prototype, {
	__class__: mis_MissionElementParticleEmitterNode
});
var modes_ScoreType = $hxEnums["modes.ScoreType"] = { __ename__:true,__constructs__:null
	,Time: {_hx_name:"Time",_hx_index:0,__enum__:"modes.ScoreType",toString:$estr}
	,Score: {_hx_name:"Score",_hx_index:1,__enum__:"modes.ScoreType",toString:$estr}
};
modes_ScoreType.__constructs__ = [modes_ScoreType.Time,modes_ScoreType.Score];
modes_ScoreType.__empty_constructs__ = [modes_ScoreType.Time,modes_ScoreType.Score];
class modes_GameMode {
}
$hxClasses["modes.GameMode"] = modes_GameMode;
modes_GameMode.__name__ = "modes.GameMode";
modes_GameMode.__isInterface__ = true;
Object.assign(modes_GameMode.prototype, {
	__class__: modes_GameMode
	,getSpawnTransform: null
	,getRespawnTransform: null
	,missionScan: null
	,getStartTime: null
	,timeMultiplier: null
	,getScoreType: null
	,getFinishScore: null
	,getRewindState: null
	,onTimeExpire: null
	,onRestart: null
	,onClientRestart: null
	,onRespawn: null
	,onGemPickup: null
	,getPreloadFiles: null
	,constructRewindState: null
});
class modes_GameModeFactory {
	static getGameMode(level,mode) {
		if(mode != null) {
			if(mode.toLowerCase() == "scrum") {
				return new modes_HuntMode(level);
			}
		}
		return new modes_NullMode(level);
	}
}
$hxClasses["modes.GameModeFactory"] = modes_GameModeFactory;
modes_GameModeFactory.__name__ = "modes.GameModeFactory";
class modes_GemSpawnSphere {
	constructor(elem) {
		this.position = mis_MisParser.parseVector3(elem.position);
		this.position.x *= -1;
		this.rotation = mis_MisParser.parseRotation(elem.rotation);
		this.rotation.x *= -1;
		this.rotation.w *= -1;
		this.element = elem;
		this.gemColor = "red";
		if(elem.gemdatablock != null) {
			switch(elem.gemdatablock.toLowerCase()) {
			case "gemitem_2pts":
				this.gemColor = "yellow";
				break;
			case "gemitem_5pts":
				this.gemColor = "blue";
				break;
			default:
				this.gemColor = "red";
			}
		}
	}
}
$hxClasses["modes.GemSpawnSphere"] = modes_GemSpawnSphere;
modes_GemSpawnSphere.__name__ = "modes.GemSpawnSphere";
Object.assign(modes_GemSpawnSphere.prototype, {
	__class__: modes_GemSpawnSphere
	,netIndex: null
	,position: null
	,rotation: null
	,element: null
	,gem: null
	,gemBeam: null
	,gemColor: null
});
class modes_GemOctreeElem {
	constructor(vec,spawn,spawnIndex) {
		this.boundingBox = new h3d_col_Bounds();
		let _this = this.boundingBox;
		let x = vec.x + (-0.5);
		let y = vec.y + (-0.5);
		let z = vec.z + (-0.5);
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let _this_x = x;
		let _this_y = y;
		let _this_z = z;
		let x1 = _this_x;
		let y1 = _this_y;
		let z1 = _this_z;
		if(_this_z == null) {
			z1 = 0.;
		}
		if(_this_y == null) {
			y1 = 0.;
		}
		if(_this_x == null) {
			x1 = 0.;
		}
		let p_x = x1;
		let p_y = y1;
		let p_z = z1;
		if(p_x < _this.xMin) {
			_this.xMin = p_x;
		}
		if(p_x > _this.xMax) {
			_this.xMax = p_x;
		}
		if(p_y < _this.yMin) {
			_this.yMin = p_y;
		}
		if(p_y > _this.yMax) {
			_this.yMax = p_y;
		}
		if(p_z < _this.zMin) {
			_this.zMin = p_z;
		}
		if(p_z > _this.zMax) {
			_this.zMax = p_z;
		}
		let _this1 = this.boundingBox;
		let x2 = vec.x + 0.5;
		let y2 = vec.y + 0.5;
		let z2 = vec.z + 0.5;
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let _this_x1 = x2;
		let _this_y1 = y2;
		let _this_z1 = z2;
		let x3 = _this_x1;
		let y3 = _this_y1;
		let z3 = _this_z1;
		if(_this_z1 == null) {
			z3 = 0.;
		}
		if(_this_y1 == null) {
			y3 = 0.;
		}
		if(_this_x1 == null) {
			x3 = 0.;
		}
		let p_x1 = x3;
		let p_y1 = y3;
		let p_z1 = z3;
		if(p_x1 < _this1.xMin) {
			_this1.xMin = p_x1;
		}
		if(p_x1 > _this1.xMax) {
			_this1.xMax = p_x1;
		}
		if(p_y1 < _this1.yMin) {
			_this1.yMin = p_y1;
		}
		if(p_y1 > _this1.yMax) {
			_this1.yMax = p_y1;
		}
		if(p_z1 < _this1.zMin) {
			_this1.zMin = p_z1;
		}
		if(p_z1 > _this1.zMax) {
			_this1.zMax = p_z1;
		}
		this.spawn = spawn;
		this.spawnIndex = spawnIndex;
	}
	getElementType() {
		return 2;
	}
	setPriority(priority) {
		this.priority = priority;
	}
}
$hxClasses["modes.GemOctreeElem"] = modes_GemOctreeElem;
modes_GemOctreeElem.__name__ = "modes.GemOctreeElem";
modes_GemOctreeElem.__interfaces__ = [octree_IOctreeObject];
Object.assign(modes_GemOctreeElem.prototype, {
	__class__: modes_GemOctreeElem
	,boundingBox: null
	,spawn: null
	,spawnIndex: null
	,priority: null
});
class rewind_RewindableState {
}
$hxClasses["rewind.RewindableState"] = rewind_RewindableState;
rewind_RewindableState.__name__ = "rewind.RewindableState";
rewind_RewindableState.__isInterface__ = true;
Object.assign(rewind_RewindableState.prototype, {
	__class__: rewind_RewindableState
	,apply: null
	,getSize: null
	,serialize: null
	,deserialize: null
});
class modes_HuntState {
	constructor() {
	}
	apply(level) {
		let mode = level.gameMode;
		mode.applyRewindState(this);
	}
	getSize() {
		let size = 2;
		size = 2 + (2 + this.activeGemSpawnGroup.length * 2);
		size += 2 + this.activeGems.length * 2;
		size += 4;
		size += 4;
		size += 4;
		return size;
	}
	serialize(rm,bw) {
		bw.writeUInt16(this.points);
		bw.writeUInt16(this.activeGemSpawnGroup.length);
		let _g = 0;
		let _g1 = this.activeGemSpawnGroup;
		while(_g < _g1.length) {
			let elem = _g1[_g];
			++_g;
			bw.writeUInt16(elem);
		}
		bw.writeUInt16(this.activeGems.length);
		let _g2 = 0;
		let _g3 = this.activeGems;
		while(_g2 < _g3.length) {
			let elem = _g3[_g2];
			++_g2;
			bw.writeUInt16(rm.allocGO(elem));
		}
		bw.writeInt32(this.rngState);
		bw.writeInt32(this.rngState2);
	}
	deserialize(rm,br) {
		this.points = br.readUInt16();
		this.activeGemSpawnGroup = [];
		let len = br.readUInt16();
		let _g = 0;
		while(_g < len) {
			++_g;
			this.activeGemSpawnGroup.push(br.readUInt16());
		}
		this.activeGems = [];
		let len1 = br.readUInt16();
		let _g1 = 0;
		while(_g1 < len1) {
			++_g1;
			let uid = br.readUInt16();
			this.activeGems.push(rm.getGO(uid));
		}
		this.rngState = br.readInt32();
		this.rngState2 = br.readInt32();
	}
}
$hxClasses["modes.HuntState"] = modes_HuntState;
modes_HuntState.__name__ = "modes.HuntState";
modes_HuntState.__interfaces__ = [rewind_RewindableState];
Object.assign(modes_HuntState.prototype, {
	__class__: modes_HuntState
	,activeGemSpawnGroup: null
	,activeGems: null
	,points: null
	,rngState: null
	,rngState2: null
});
class modes_NullMode {
	constructor(level) {
		if(modes_NullMode._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(level);
	}
	_hx_constructor(level) {
		this.level = level;
	}
	getSpawnTransform() {
		let _this = this.level.dtsObjects;
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this.length) {
			let v = _this[_g1];
			++_g1;
			if(((v) instanceof shapes_StartPad)) {
				_g.push(v);
			}
		}
		let startPad = _g.pop();
		let position;
		let quat = new h3d_Quat();
		if(startPad != null) {
			let _this = startPad.getAbsPos();
			let v = new h3d_Vector();
			let x = _this._41;
			let y = _this._42;
			let z = _this._43;
			let w = _this._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			v.x = x;
			v.y = y;
			v.z = z;
			v.w = w;
			position = v;
			let _this1 = startPad.getRotationQuat();
			quat = new h3d_Quat(_this1.x,_this1.y,_this1.z,_this1.w);
		} else {
			position = new h3d_Vector(0,0,300);
		}
		position.z += 0.727843;
		return { position : position, orientation : quat, up : new h3d_Vector(0,0,1)};
	}
	getRespawnTransform(marble) {
		return null;
	}
	missionScan(mission) {
	}
	getStartTime() {
		return 0.0;
	}
	timeMultiplier() {
		return 1.0;
	}
	onRestart() {
	}
	onRespawn(marble) {
	}
	onGemPickup(marble,gem) {
		this.level.gemCount++;
		let string;
		if(this.level.gemCount == this.level.totalGems) {
			string = "You have all the gems, head for the finish!";
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/gem_all.wav",src_ResourceLoader.getAudio,this.level.soundResources));
		} else {
			string = "You picked up a gem. ";
			let remaining = this.level.totalGems - this.level.gemCount;
			if(remaining == 1) {
				string = "You picked up a gem. " + "Only one gem to go!";
			} else {
				string = "You picked up a gem. " + ("" + remaining + " gems to go!");
			}
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/gem_collect.wav",src_ResourceLoader.getAudio,this.level.soundResources));
		}
		this.level.displayAlert(string);
		this.level.playGui.formatGemCounter(this.level.gemCount,this.level.totalGems);
	}
	getPreloadFiles() {
		return ["data/sound/gem_all.wav"];
	}
	onTimeExpire() {
	}
	getScoreType() {
		return modes_ScoreType.Time;
	}
	getFinishScore() {
		return this.level.finishTime.gameplayClock;
	}
	getRewindState() {
		return null;
	}
	constructRewindState() {
		return null;
	}
	onClientRestart() {
	}
}
$hxClasses["modes.NullMode"] = modes_NullMode;
modes_NullMode.__name__ = "modes.NullMode";
modes_NullMode.__interfaces__ = [modes_GameMode];
Object.assign(modes_NullMode.prototype, {
	__class__: modes_NullMode
	,level: null
});
class modes_HuntMode extends modes_NullMode {
	constructor(level) {
		modes_NullMode._hx_skip_constructor = true;
		super();
		modes_NullMode._hx_skip_constructor = false;
		this._hx_constructor(level);
	}
	_hx_constructor(level) {
		this.points = 0;
		this.rng2 = new RandomLCG(100);
		this.rng = new RandomLCG(100);
		this.gemToBeamMap = new haxe_ds_ObjectMap();
		this.gemBeams = [];
		this.activeGems = [];
		this.spawnPointTaken = [];
		this.playerSpawnPoints = [];
		this.gemSpawnPoints = [];
		super._hx_constructor(level);
	}
	missionScan(mission) {
		let scanMission = null;
		let _gthis = this;
		scanMission = function(simGroup) {
			let _g = 0;
			let _g1 = simGroup.elements;
			while(_g < _g1.length) {
				let element = _g1[_g];
				++_g;
				if([mis_MissionElementType.SpawnSphere].includes(element._type)) {
					let spawnSphere = element;
					let dbname = spawnSphere.datablock.toLowerCase();
					if(dbname == "spawnspheremarker") {
						_gthis.playerSpawnPoints.push(spawnSphere);
						_gthis.spawnPointTaken.push(false);
					}
					if(dbname == "gemspawnspheremarker") {
						let sphere = new modes_GemSpawnSphere(spawnSphere);
						sphere.netIndex = _gthis.gemSpawnPoints.length;
						_gthis.gemSpawnPoints.push(sphere);
						if(_gthis.level.isMultiplayer) {
							_gthis.level.gemPredictions.predictions.push(true);
						}
					}
				} else if(element._type == mis_MissionElementType.SimGroup) {
					scanMission(element);
				}
			}
		};
		scanMission(mission.root);
	}
	getSpawnTransform() {
		let idx = Math.floor(this.rng2.randRange(0,this.playerSpawnPoints.length - 1));
		while(this.spawnPointTaken[idx]) idx = Math.floor(this.rng2.randRange(0,this.playerSpawnPoints.length - 1));
		this.spawnPointTaken[idx] = true;
		let randomSpawn = this.playerSpawnPoints[idx];
		let spawnPos = mis_MisParser.parseVector3(randomSpawn.position);
		spawnPos.x *= -1;
		let spawnRot = mis_MisParser.parseRotation(randomSpawn.rotation);
		spawnRot.x *= -1;
		spawnRot.w *= -1;
		let m = null;
		m = new h3d_Matrix();
		let xx = spawnRot.x * spawnRot.x;
		let xy = spawnRot.x * spawnRot.y;
		let xz = spawnRot.x * spawnRot.z;
		let xw = spawnRot.x * spawnRot.w;
		let yy = spawnRot.y * spawnRot.y;
		let yz = spawnRot.y * spawnRot.z;
		let yw = spawnRot.y * spawnRot.w;
		let zz = spawnRot.z * spawnRot.z;
		let zw = spawnRot.z * spawnRot.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		let spawnMat = m;
		let v = new h3d_Vector(spawnMat._31,spawnMat._32,spawnMat._33);
		let k = v.x * v.x + v.y * v.y + v.z * v.z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		v.x *= k;
		v.y *= k;
		v.z *= k;
		let x = v.x * 0.24261433333333335;
		let y = v.y * 0.24261433333333335;
		let z = v.z * 0.24261433333333335;
		let w = v.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let v_x = x;
		let v_y = y;
		let v_z = z;
		let v_w = w;
		spawnPos = new h3d_Vector(spawnPos.x + v_x,spawnPos.y + v_y,spawnPos.z + v_z,spawnPos.w + v_w);
		return { position : spawnPos, orientation : spawnRot, up : v};
	}
	getRespawnTransform(marble) {
		let lastContactPos = marble.lastContactPosition;
		if(lastContactPos == null) {
			return this.getSpawnTransform();
		}
		let closestSpawn = null;
		let closestDistance = 1e10;
		let _g = 0;
		let _g1 = this.playerSpawnPoints;
		while(_g < _g1.length) {
			let spawn = _g1[_g];
			++_g;
			let pos = mis_MisParser.parseVector3(spawn.position);
			pos.x *= -1;
			let dx = lastContactPos.x - pos.x;
			let dy = lastContactPos.y - pos.y;
			let dz = lastContactPos.z - pos.z;
			let dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
			if(dist < closestDistance) {
				closestDistance = dist;
				closestSpawn = spawn;
			}
		}
		if(closestSpawn != null) {
			let spawnPos = mis_MisParser.parseVector3(closestSpawn.position);
			spawnPos.x *= -1;
			let spawnRot = mis_MisParser.parseRotation(closestSpawn.rotation);
			spawnRot.x *= -1;
			spawnRot.w *= -1;
			let m = null;
			m = new h3d_Matrix();
			let xx = spawnRot.x * spawnRot.x;
			let xy = spawnRot.x * spawnRot.y;
			let xz = spawnRot.x * spawnRot.z;
			let xw = spawnRot.x * spawnRot.w;
			let yy = spawnRot.y * spawnRot.y;
			let yz = spawnRot.y * spawnRot.z;
			let yw = spawnRot.y * spawnRot.w;
			let zz = spawnRot.z * spawnRot.z;
			let zw = spawnRot.z * spawnRot.w;
			m._11 = 1 - 2 * (yy + zz);
			m._12 = 2 * (xy + zw);
			m._13 = 2 * (xz - yw);
			m._14 = 0;
			m._21 = 2 * (xy - zw);
			m._22 = 1 - 2 * (xx + zz);
			m._23 = 2 * (yz + xw);
			m._24 = 0;
			m._31 = 2 * (xz + yw);
			m._32 = 2 * (yz - xw);
			m._33 = 1 - 2 * (xx + yy);
			m._34 = 0;
			m._41 = 0;
			m._42 = 0;
			m._43 = 0;
			m._44 = 1;
			let spawnMat = m;
			let v = new h3d_Vector(spawnMat._31,spawnMat._32,spawnMat._33);
			let k = v.x * v.x + v.y * v.y + v.z * v.z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			v.x *= k;
			v.y *= k;
			v.z *= k;
			let x = v.x * 0.24261433333333335;
			let y = v.y * 0.24261433333333335;
			let z = v.z * 0.24261433333333335;
			let w = v.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let v_x = x;
			let v_y = y;
			let v_z = z;
			let v_w = w;
			spawnPos = new h3d_Vector(spawnPos.x + v_x,spawnPos.y + v_y,spawnPos.z + v_z,spawnPos.w + v_w);
			return { position : spawnPos, orientation : spawnRot, up : v};
		}
		return null;
	}
	onRespawn(marble) {
		if(marble.controllable && this.activeGemSpawnGroup.length != 0) {
			let gemAvg = new h3d_Vector();
			let _g = 0;
			let _g1 = this.activeGemSpawnGroup;
			while(_g < _g1.length) {
				let gi = _g1[_g];
				++_g;
				let g = this.gemSpawnPoints[gi];
				let v = g.position;
				gemAvg = new h3d_Vector(gemAvg.x + v.x,gemAvg.y + v.y,gemAvg.z + v.z,gemAvg.w + v.w);
			}
			let f = 1 / this.activeGemSpawnGroup.length;
			gemAvg.x *= f;
			gemAvg.y *= f;
			gemAvg.z *= f;
			let _this = marble.getAbsPos();
			let v_x = 0.;
			let v_y = 0.;
			let v_z = 0.;
			let v_w = 1.;
			let x = _this._41;
			let y = _this._42;
			let z = _this._43;
			let w = _this._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			v_x = x;
			v_y = y;
			v_z = z;
			v_w = w;
			let x1 = gemAvg.x - v_x;
			let y1 = gemAvg.y - v_y;
			let z1 = gemAvg.z - v_z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let delta_x = x1;
			let delta_y = y1;
			let delta_z = z1;
			let _this1 = this.level.getOrientationQuat(0);
			let m = null;
			m = new h3d_Matrix();
			let xx = _this1.x * _this1.x;
			let xy = _this1.x * _this1.y;
			let xz = _this1.x * _this1.z;
			let xw = _this1.x * _this1.w;
			let yy = _this1.y * _this1.y;
			let yz = _this1.y * _this1.z;
			let yw = _this1.y * _this1.w;
			let zz = _this1.z * _this1.z;
			let zw = _this1.z * _this1.w;
			m._11 = 1 - 2 * (yy + zz);
			m._12 = 2 * (xy + zw);
			m._13 = 2 * (xz - yw);
			m._14 = 0;
			m._21 = 2 * (xy - zw);
			m._22 = 1 - 2 * (xx + zz);
			m._23 = 2 * (yz + xw);
			m._24 = 0;
			m._31 = 2 * (xz + yw);
			m._32 = 2 * (yz - xw);
			m._33 = 1 - 2 * (xx + yy);
			m._34 = 0;
			m._41 = 0;
			m._42 = 0;
			m._43 = 0;
			m._44 = 1;
			let gravFrame = m;
			let x2 = gravFrame._11;
			let y2 = gravFrame._12;
			let z2 = gravFrame._13;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let v1_x = x2;
			let v1_y = y2;
			let v1_z = z2;
			let k = v1_x * v1_x + v1_y * v1_y + v1_z * v1_z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			v1_x *= k;
			v1_y *= k;
			v1_z *= k;
			let x3 = gravFrame._21;
			let y3 = gravFrame._22;
			let z3 = gravFrame._23;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			let v2_x = x3;
			let v2_y = y3;
			let v2_z = z3;
			let k1 = v2_x * v2_x + v2_y * v2_y + v2_z * v2_z;
			if(k1 < 1e-10) {
				k1 = 0;
			} else {
				k1 = 1. / Math.sqrt(k1);
			}
			v2_x *= k1;
			v2_y *= k1;
			v2_z *= k1;
			let x4 = delta_x * v2_x + delta_y * v2_y + delta_z * v2_z;
			let y4 = delta_x * v1_x + delta_y * v1_y + delta_z * v1_z;
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			let deltaRot_x = x4;
			let deltaRot_y = y4;
			if(Math.sqrt(deltaRot_x * deltaRot_x + deltaRot_y * deltaRot_y) >= 0.001) {
				let ang = Math.atan2(deltaRot_x,deltaRot_y);
				marble.camera.CameraYaw = ang;
				marble.camera.nextCameraYaw = ang;
			}
		}
	}
	getStartTime() {
		return this.level.mission.qualifyTime;
	}
	timeMultiplier() {
		return -1;
	}
	onRestart() {
		if(!this.level.isMultiplayer || net_Net.isHost) {
			this.rng.setSeed(100);
			this.rng2.setSeed(100);
			if(src_Settings.optionsSettings.huntRandom || net_Net.isMP) {
				this.rng.setSeed(Math.random() * 10000);
				this.rng2.setSeed(Math.random() * 10000);
			}
			this.setupGems();
		}
		this.points = 0;
		this.level.playGui.formatGemHuntCounter(this.points);
		if(!net_Net.isMP) {
			this.freeSpawns();
		}
	}
	onClientRestart() {
		let _g = 0;
		let _g1 = this.gemSpawnPoints.length;
		while(_g < _g1) {
			let gi = _g++;
			let gemSpawn = this.gemSpawnPoints[gi];
			if(gemSpawn.gem != null) {
				gemSpawn.gem.setHide(true);
				gemSpawn.gem.pickedUp = true;
				gemSpawn.gemBeam.setHide(true);
			}
		}
	}
	onGemPickup(marble,gem) {
		if(!marble.isNetUpdate && net_Net.isHost || !net_Net.isMP) {
			if(marble == this.level.marble) {
				src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/gem_collect.wav",src_ResourceLoader.getAudio,this.level.soundResources));
			} else {
				src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/opponent_gem_collect.wav",src_ResourceLoader.getAudio,this.level.soundResources));
			}
		}
		HxOverrides.remove(this.activeGems,gem);
		let beam = this.gemToBeamMap.h[gem.__id__];
		beam.setHide(true);
		if(!this.level.isMultiplayer || net_Net.isHost) {
			this.refillGemGroups();
		}
		let incr = 0;
		switch(gem.gemColor) {
		case "blue.gem":
			incr = 5;
			break;
		case "red.gem":
			incr = 1;
			break;
		case "yellow.gem":
			incr = 2;
			break;
		}
		if(!marble.isNetUpdate) {
			if(marble == this.level.marble) {
				switch(gem.gemColor) {
				case "blue.gem":
					this.points += 5;
					this.level.playGui.addMiddleMessage("+5",6711039);
					break;
				case "red.gem":
					this.points += 1;
					this.level.playGui.addMiddleMessage("+1",16737894);
					break;
				case "yellow.gem":
					this.points += 2;
					this.level.playGui.addMiddleMessage("+2",16777062);
					break;
				}
				this.level.playGui.formatGemHuntCounter(this.points);
			}
		}
		if(this.level.isMultiplayer && net_Net.isHost) {
			let packet = new net_GemPickupPacket();
			packet.clientId = marble.connection == null ? 0 : marble.connection.id;
			packet.gemId = gem.netIndex;
			packet.serverTicks = this.level.timeState.ticks;
			packet.scoreIncr = incr;
			let os = new net_OutputBitStream();
			os.writeByte(9);
			os.writeByte(packet.clientId);
			os.writeUInt16(packet.serverTicks);
			os.writeInt(packet.gemId,11);
			os.writeInt(packet.scoreIncr,4);
			net_Net.sendPacketToIngame(os);
			src_Settings.playStatistics.totalMPScore += incr;
			this.level.playGui.incrementPlayerScore(packet.clientId,packet.scoreIncr);
		}
		if(this.level.isMultiplayer && net_Net.isClient) {
			gem.pickUpClient = marble.connection == null ? net_Net.clientId : marble.connection.id;
		}
	}
	freeSpawns() {
		let _g = 0;
		let _g1 = this.playerSpawnPoints.length;
		while(_g < _g1) {
			let i = _g++;
			this.spawnPointTaken[i] = false;
		}
	}
	setupGems() {
		this.gemGroupRadius = 20.0;
		this.maxGemsPerGroup = 4;
		if(this.level.mission.missionInfo.gemgroupradius != null && this.level.mission.missionInfo.gemgroupradius != "") {
			this.gemGroupRadius = parseFloat(this.level.mission.missionInfo.gemgroupradius);
		}
		if(this.level.mission.missionInfo.maxgemspergroup != null && this.level.mission.missionInfo.maxgemspergroup != "") {
			this.maxGemsPerGroup = Std.parseInt(this.level.mission.missionInfo.maxgemspergroup);
		}
		this.gemOctree = new octree_Octree();
		let _g = 0;
		let _g1 = this.gemSpawnPoints.length;
		while(_g < _g1) {
			let gi = _g++;
			let gemSpawn = this.gemSpawnPoints[gi];
			let vec = gemSpawn.position;
			this.gemOctree.insert(new modes_GemOctreeElem(vec,gemSpawn,gi));
			if(gemSpawn.gem != null) {
				gemSpawn.gem.setHide(true);
				gemSpawn.gem.pickedUp = true;
				gemSpawn.gemBeam.setHide(true);
			}
		}
		if(this.activeGemSpawnGroup != null) {
			let _g = 0;
			let _g1 = this.activeGemSpawnGroup;
			while(_g < _g1.length) {
				let gemSpawnIndex = _g1[_g];
				++_g;
				let gemSpawn = this.gemSpawnPoints[gemSpawnIndex];
				if(gemSpawn.gem != null) {
					gemSpawn.gem.pickedUp = true;
					gemSpawn.gem.setHide(true);
					gemSpawn.gemBeam.setHide(true);
				}
			}
		}
		this.activeGemSpawnGroup = [];
		this.activeGems = [];
		this.refillGemGroups();
		let gemAvg = new h3d_Vector();
		let _g2 = 0;
		let _g3 = this.activeGemSpawnGroup;
		while(_g2 < _g3.length) {
			let gi = _g3[_g2];
			++_g2;
			let g = this.gemSpawnPoints[gi];
			let v = g.position;
			gemAvg = new h3d_Vector(gemAvg.x + v.x,gemAvg.y + v.y,gemAvg.z + v.z,gemAvg.w + v.w);
		}
		let f = 1 / this.activeGemSpawnGroup.length;
		gemAvg.x *= f;
		gemAvg.y *= f;
		gemAvg.z *= f;
		let _this = this.level.marble.getAbsPos();
		let v_x = 0.;
		let v_y = 0.;
		let v_z = 0.;
		let v_w = 1.;
		let x = _this._41;
		let y = _this._42;
		let z = _this._43;
		let w = _this._44;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v_x = x;
		v_y = y;
		v_z = z;
		v_w = w;
		let x1 = gemAvg.x - v_x;
		let y1 = gemAvg.y - v_y;
		let z1 = gemAvg.z - v_z;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let delta_x = x1;
		let delta_y = y1;
		let delta_z = z1;
		let _this1 = this.level.getOrientationQuat(0);
		let m = null;
		m = new h3d_Matrix();
		let xx = _this1.x * _this1.x;
		let xy = _this1.x * _this1.y;
		let xz = _this1.x * _this1.z;
		let xw = _this1.x * _this1.w;
		let yy = _this1.y * _this1.y;
		let yz = _this1.y * _this1.z;
		let yw = _this1.y * _this1.w;
		let zz = _this1.z * _this1.z;
		let zw = _this1.z * _this1.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		let gravFrame = m;
		let x2 = gravFrame._11;
		let y2 = gravFrame._12;
		let z2 = gravFrame._13;
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let v1_x = x2;
		let v1_y = y2;
		let v1_z = z2;
		let k = v1_x * v1_x + v1_y * v1_y + v1_z * v1_z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		v1_x *= k;
		v1_y *= k;
		v1_z *= k;
		let x3 = gravFrame._21;
		let y3 = gravFrame._22;
		let z3 = gravFrame._23;
		if(z3 == null) {
			z3 = 0.;
		}
		if(y3 == null) {
			y3 = 0.;
		}
		if(x3 == null) {
			x3 = 0.;
		}
		let v2_x = x3;
		let v2_y = y3;
		let v2_z = z3;
		let k1 = v2_x * v2_x + v2_y * v2_y + v2_z * v2_z;
		if(k1 < 1e-10) {
			k1 = 0;
		} else {
			k1 = 1. / Math.sqrt(k1);
		}
		v2_x *= k1;
		v2_y *= k1;
		v2_z *= k1;
		let x4 = delta_x * v2_x + delta_y * v2_y + delta_z * v2_z;
		let y4 = delta_x * v1_x + delta_y * v1_y + delta_z * v1_z;
		if(y4 == null) {
			y4 = 0.;
		}
		if(x4 == null) {
			x4 = 0.;
		}
		let deltaRot_x = x4;
		let deltaRot_y = y4;
		if(Math.sqrt(deltaRot_x * deltaRot_x + deltaRot_y * deltaRot_y) >= 0.001) {
			let ang = Math.atan2(deltaRot_x,deltaRot_y);
			this.level.marble.camera.CameraYaw = ang;
			this.level.marble.camera.nextCameraYaw = ang;
		}
	}
	refillGemGroups() {
		if(this.activeGems.length == 0) {
			let spawnGroup = this.pickGemSpawnGroup();
			this.activeGemSpawnGroup = spawnGroup;
			this.fillGemGroup(spawnGroup);
			this.level.radar.blink();
			if(this.level.isMultiplayer && net_Net.isHost) {
				let bs = new net_OutputBitStream();
				bs.writeByte(8);
				let packet = new net_GemSpawnPacket();
				packet.gemIds = spawnGroup;
				packet.serialize(bs);
				net_Net.sendPacketToIngame(bs);
			}
		}
	}
	fillGemGroup(group) {
		let _gthis = this;
		let _g = 0;
		while(_g < group.length) {
			let gi = group[_g];
			++_g;
			let gemSpawn = this.gemSpawnPoints[gi];
			if(gemSpawn.gem != null) {
				gemSpawn.gem.pickedUp = false;
				gemSpawn.gem.setHide(false);
				gemSpawn.gemBeam.setHide(false);
				this.activeGems.push(gemSpawn.gem);
			} else {
				let melem = new mis_MissionElementItem();
				melem.datablock = "GemItem" + gemSpawn.gemColor;
				let gem = new shapes_Gem(melem);
				gem.netIndex = gi;
				gemSpawn.gem = gem;
				let x = gemSpawn.position.x;
				let y = gemSpawn.position.y;
				let z = gemSpawn.position.z;
				gem.x = x;
				gem.flags |= 1;
				gem.y = y;
				gem.flags |= 1;
				gem.z = z;
				gem.flags |= 1;
				gem.flags |= 1;
				gem.setRotationQuat(gemSpawn.rotation);
				this.activeGems.push(gem);
				let gemBeam = new shapes_GemBeam();
				let x1 = gemSpawn.position.x;
				let y1 = gemSpawn.position.y;
				let z1 = gemSpawn.position.z;
				gemBeam.x = x1;
				gemBeam.flags |= 1;
				gemBeam.y = y1;
				gemBeam.flags |= 1;
				gemBeam.z = z1;
				gemBeam.flags |= 1;
				gemBeam.flags |= 1;
				gemBeam.setRotationQuat(gemSpawn.rotation);
				this.gemBeams.push(gemBeam);
				gemSpawn.gemBeam = gemBeam;
				this.gemToBeamMap.set(gem,gemBeam);
				this.level.addDtsObject(gemBeam,function() {
					_gthis.level.addDtsObject(gem,function() {
						_gthis.level.gems.push(gem);
					});
				});
			}
		}
	}
	setActiveSpawnSphere(spawnGroup) {
		src_Console.instance.addEntry("log","Got new gem spawn from server!");
		if(this.activeGemSpawnGroup != null) {
			let _g = 0;
			let _g1 = this.activeGemSpawnGroup;
			while(_g < _g1.length) {
				let agem = _g1[_g];
				++_g;
				let gemSpawn = this.gemSpawnPoints[agem];
				if(gemSpawn.gem != null) {
					gemSpawn.gem.pickedUp = true;
					gemSpawn.gem.setHide(true);
					gemSpawn.gemBeam.setHide(true);
					HxOverrides.remove(this.activeGems,gemSpawn.gem);
				}
			}
		}
		let _gthis = this;
		let _g = 0;
		while(_g < spawnGroup.length) {
			let sphereId = spawnGroup[_g];
			++_g;
			src_Console.instance.addEntry("log","Spawning gem id " + sphereId);
			let gemSpawn = this.gemSpawnPoints[sphereId];
			if(gemSpawn.gem != null) {
				gemSpawn.gem.pickedUp = false;
				gemSpawn.gem.setHide(false);
				gemSpawn.gemBeam.setHide(false);
				this.activeGems.push(gemSpawn.gem);
			} else {
				let melem = new mis_MissionElementItem();
				melem.datablock = "GemItem" + gemSpawn.gemColor;
				let gem = new shapes_Gem(melem);
				gem.netIndex = sphereId;
				gemSpawn.gem = gem;
				let x = gemSpawn.position.x;
				let y = gemSpawn.position.y;
				let z = gemSpawn.position.z;
				gem.x = x;
				gem.flags |= 1;
				gem.y = y;
				gem.flags |= 1;
				gem.z = z;
				gem.flags |= 1;
				gem.flags |= 1;
				gem.setRotationQuat(gemSpawn.rotation);
				this.activeGems.push(gem);
				let gemBeam = new shapes_GemBeam();
				let x1 = gemSpawn.position.x;
				let y1 = gemSpawn.position.y;
				let z1 = gemSpawn.position.z;
				gemBeam.x = x1;
				gemBeam.flags |= 1;
				gemBeam.y = y1;
				gemBeam.flags |= 1;
				gemBeam.z = z1;
				gemBeam.flags |= 1;
				gemBeam.flags |= 1;
				gemBeam.setRotationQuat(gemSpawn.rotation);
				this.gemBeams.push(gemBeam);
				gemSpawn.gemBeam = gemBeam;
				this.gemToBeamMap.set(gem,gemBeam);
				this.level.addDtsObject(gemBeam,function() {
					_gthis.level.addDtsObject(gem,function() {
						_gthis.level.gems.push(gem);
					});
				});
			}
		}
		this.activeGemSpawnGroup = spawnGroup;
	}
	pickGemSpawnGroup() {
		let searchRadius = this.gemGroupRadius * 2;
		let _g = 0;
		while(_g < 6) {
			++_g;
			let groupMainPt = new h3d_Vector();
			let group = this.findGemSpawnGroup(groupMainPt);
			if(group.length == 0) {
				src_Console.instance.addEntry("log","Gem spawn group has no spawn points!");
				continue;
			}
			let ok = true;
			if(this.activeGemSpawnGroup != null) {
				let _g = 0;
				let _g1 = this.activeGemSpawnGroup;
				while(_g < _g1.length) {
					let gi = _g1[_g];
					++_g;
					let gemSpawn = this.gemSpawnPoints[gi];
					let _this = gemSpawn.position;
					let dx = groupMainPt.x - _this.x;
					let dy = groupMainPt.y - _this.y;
					let dz = groupMainPt.z - _this.z;
					if(Math.sqrt(dx * dx + dy * dy + dz * dz) < searchRadius) {
						ok = false;
						break;
					}
				}
			}
			if(!ok) {
				continue;
			}
			return group;
		}
		src_Console.instance.addEntry("log","Unable to find spawn group that works with active gem groups, using random!");
		let groupMainPt = new h3d_Vector();
		return this.findGemSpawnGroup(groupMainPt);
	}
	findGemSpawnGroup(outSpawnPoint) {
		let rnd = this.rng.randRange(0,this.gemSpawnPoints.length - 1) | 0;
		if(this.level.isRecording) {
			this.level.replay.recordRandomGenState(rnd);
		}
		if(this.level.isWatching) {
			rnd = this.level.replay.getRandomGenState();
		}
		let spawnPoint = this.gemSpawnPoints[rnd];
		let pos = spawnPoint.position;
		let results = [];
		let search = this.gemOctree.radiusSearch(pos,this.gemGroupRadius);
		let _g = 0;
		while(_g < search.length) {
			let elem = search[_g];
			++_g;
			let gemElem = elem;
			results.push(gemElem.spawnIndex);
			if(results.length >= this.maxGemsPerGroup) {
				break;
			}
		}
		outSpawnPoint.x = pos.x;
		outSpawnPoint.y = pos.y;
		outSpawnPoint.z = pos.z;
		outSpawnPoint.w = pos.w;
		return results;
	}
	getPreloadFiles() {
		return ["data/shapes/items/yellow.gem.png","data/skies/gemCubemapUp2.png","data/shapes/items/blue.gem.png","data/skies/gemCubemapUp3.png","data/shapes/items/red.gem.png","data/skies/gemCubemapUp.png","sound/gem_collect.wav","sound/opponent_gem_collect.wav"];
	}
	getScoreType() {
		return modes_ScoreType.Score;
	}
	onTimeExpire() {
		if(this.level.finishTime != null) {
			return;
		}
		src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/finish.wav",src_ResourceLoader.getAudio,this.level.soundResources));
		this.level.finishTime = this.level.timeState.clone();
		this.level.marble.setMode(src_Mode.Start);
		this.level.marble.camera.finish = true;
		this.level.finishYaw = this.level.marble.camera.CameraYaw;
		this.level.finishPitch = this.level.marble.camera.CameraPitch;
		if(this.level.isMultiplayer) {
			this.level.playGui.doMPEndGameMessage();
		} else {
			this.level.displayAlert("Congratulations! You've finished!");
		}
		this.level.cancel(this.level.oobSchedule);
		this.level.cancel(this.level.marble.oobSchedule);
		let _gthis = this;
		if(!this.level.isWatching) {
			if(this.level.isMultiplayer) {
				let _g = 0;
				let _g1 = this.level.marbles;
				while(_g < _g1.length) {
					let marble = _g1[_g];
					++_g;
					marble.setMode(src_Mode.Start);
					this.level.cancel(marble.oobSchedule);
				}
				if(net_Net.isHost) {
					net_NetCommands.timerRanOut();
				}
				if(!this.level.isWatching) {
					this.level.schedule(this.level.timeState.currentAttemptTime + 5,function() {
						return _gthis.level.mpFinish();
					});
				}
			} else {
				let myScore = { name : "Player", time : this.getFinishScore()};
				src_Settings.saveScore(this.level.mission.path,myScore,this.getScoreType());
				let notifies = gui_AchievementsGui.check();
				let achDelay = 0.0;
				if((notifies & 1) > 0) {
					achDelay = 3.;
				}
				if((notifies & 2) > 0) {
					achDelay += 3;
				}
				if((notifies & 4) > 0) {
					achDelay += 3;
				}
				if((notifies & 8) > 0) {
					achDelay += 3;
				}
				if((notifies & 16) > 0) {
					achDelay += 3;
				}
				if((notifies & 32) > 0) {
					achDelay += 3;
				}
				if((notifies & 64) > 0) {
					achDelay += 3;
				}
				if((notifies & 128) > 0) {
					achDelay += 3;
				}
				if((notifies & 256) > 0) {
					achDelay += 3;
				}
				if(notifies > 0) {
					achDelay += 0.5;
				}
				this.level.schedule(this.level.timeState.currentAttemptTime + Math.max(5.0,achDelay),function() {
					return _gthis.level.showFinishScreen();
				});
			}
		}
		if(this.level.timeTravelSound != null) {
			this.level.timeTravelSound.stop();
			this.level.timeTravelSound = null;
		}
	}
	getFinishScore() {
		return this.points;
	}
	getRewindState() {
		let s = new modes_HuntState();
		s.points = this.points;
		s.activeGemSpawnGroup = this.activeGemSpawnGroup;
		s.activeGems = this.activeGems.slice();
		s.rngState = this.rng.seed;
		s.rngState2 = this.rng2.seed;
		return s;
	}
	applyRewindState(state) {
		let s = state;
		this.points = s.points;
		this.level.playGui.formatGemHuntCounter(this.points);
		let _g = 0;
		let _g1 = this.activeGems;
		while(_g < _g1.length) {
			let gem = _g1[_g];
			++_g;
			gem.pickedUp = true;
			gem.setHide(true);
			let gemBeam = this.gemToBeamMap.h[gem.__id__];
			gemBeam.setHide(true);
		}
		this.activeGemSpawnGroup = s.activeGemSpawnGroup;
		this.activeGems = s.activeGems;
		let _g2 = 0;
		let _g3 = this.activeGems;
		while(_g2 < _g3.length) {
			let gem = _g3[_g2];
			++_g2;
			gem.pickedUp = false;
			gem.setHide(false);
			let gemBeam = this.gemToBeamMap.h[gem.__id__];
			gemBeam.setHide(false);
		}
		if(!src_Settings.optionsSettings.huntRandom) {
			this.rng.setSeed(s.rngState);
			this.rng2.setSeed(s.rngState2);
		}
	}
	constructRewindState() {
		return new modes_HuntState();
	}
}
$hxClasses["modes.HuntMode"] = modes_HuntMode;
modes_HuntMode.__name__ = "modes.HuntMode";
modes_HuntMode.__super__ = modes_NullMode;
Object.assign(modes_HuntMode.prototype, {
	__class__: modes_HuntMode
	,gemSpawnPoints: null
	,playerSpawnPoints: null
	,spawnPointTaken: null
	,gemOctree: null
	,gemGroupRadius: null
	,maxGemsPerGroup: null
	,activeGemSpawnGroup: null
	,activeGems: null
	,gemBeams: null
	,gemToBeamMap: null
	,rng: null
	,rng2: null
	,points: null
});
class net_InputBitStream {
	constructor(data) {
		this.data = data;
		this.position = 0;
		this.shift = 0;
	}
	readBits(bits) {
		if(bits == null) {
			bits = 8;
		}
		if(this.shift + bits >= 8) {
			let extra = (this.shift + bits) % 8;
			let remain = bits - extra;
			let first = this.data.b[this.position] >> this.shift;
			let result = first;
			this.position++;
			if(extra > 0) {
				let second = (this.data.b[this.position] & 255 >> 8 - extra) << remain;
				result = first | second;
			}
			this.shift = extra;
			return result;
		} else {
			let result = this.data.b[this.position] >> this.shift & 255 >> 8 - bits;
			this.shift += bits;
			return result;
		}
	}
	readInt(bits) {
		if(bits == null) {
			bits = 32;
		}
		let value = 0;
		let shift = 0;
		while(bits > 0) {
			value |= this.readBits(bits < 8 ? bits : 8) << shift;
			shift += 8;
			bits -= 8;
		}
		return value;
	}
	readFlag() {
		return this.readInt(1) != 0;
	}
	readByte() {
		return this.readInt(8);
	}
	readUInt16() {
		return this.readInt(16);
	}
	readInt32() {
		return this.readInt(32);
	}
	readFloat() {
		return haxe_io_FPHelper.i32ToFloat(this.readInt32());
	}
	readString() {
		let length = this.readUInt16();
		let str = "";
		let _g = 0;
		let _g1 = length;
		while(_g < _g1) {
			_g++;
			let code = this.readByte();
			str += String.fromCodePoint(code);
		}
		return str;
	}
}
$hxClasses["net.InputBitStream"] = net_InputBitStream;
net_InputBitStream.__name__ = "net.InputBitStream";
Object.assign(net_InputBitStream.prototype, {
	__class__: net_InputBitStream
	,data: null
	,position: null
	,shift: null
});
class net_OutputBitStream {
	constructor(data) {
		this.data = data;
		if(this.data == null) {
			this.data = new haxe_io_BytesOutput();
		}
		this.position = 0;
		this.shift = 0;
		this.lastByte = 0;
	}
	writeBits(value,bits) {
		value &= 255 >> 8 - bits;
		if(this.shift + bits >= 8) {
			let extra = (this.shift + bits) % 8;
			let remain = bits - extra;
			let first = value & 255 >> 8 - remain;
			this.lastByte |= first << this.shift;
			let second = value >> remain & 255 >> 8 - extra;
			this.data.writeByte(this.lastByte);
			this.lastByte = second;
			this.shift = extra;
		} else {
			this.lastByte |= value << this.shift & 255 >> 8 - bits - this.shift;
			this.shift += bits;
		}
	}
	writeInt(value,bits) {
		if(bits == null) {
			bits = 32;
		}
		while(bits > 0) {
			this.writeBits(value & 255,bits < 8 ? bits : 8);
			value >>= 8;
			bits -= 8;
		}
	}
	writeFlag(value) {
		this.writeInt(value ? 1 : 0,1);
	}
	writeByte(value) {
		this.writeInt(value,8);
	}
	writeUInt16(value) {
		this.writeInt(value,16);
	}
	writeInt32(value) {
		this.writeInt(value,32);
	}
	getBytes() {
		this.data.writeByte(this.lastByte);
		return this.data.getBytes();
	}
	writeFloat(value) {
		this.writeInt(haxe_io_FPHelper.floatToI32(value),32);
	}
	writeString(value) {
		this.writeUInt16(value.length);
		let _g = 0;
		let _g1 = value.length;
		while(_g < _g1) {
			let i = _g++;
			this.writeByte(value.charCodeAt(i));
		}
	}
}
$hxClasses["net.OutputBitStream"] = net_OutputBitStream;
net_OutputBitStream.__name__ = "net.OutputBitStream";
Object.assign(net_OutputBitStream.prototype, {
	__class__: net_OutputBitStream
	,data: null
	,position: null
	,shift: null
	,lastByte: null
});
class net_GameConnection {
	constructor(id) {
		if(net_GameConnection._hx_skip_constructor) {
			return;
		}
		this._hx_constructor(id);
	}
	_hx_constructor(id) {
		this.id = id;
		this.moveManager = new net_MoveManager(this);
		this.lobbyReady = false;
	}
	ready() {
		this.state = 2;
	}
	toggleLobbyReady() {
		this.lobbyReady = !this.lobbyReady;
	}
	queueMove(m) {
		let _this = this.moveManager;
		if(_this.serverLastRecvMove < m.id && _this.serverLastAckMove < m.id) {
			_this.queuedMoves.push(m);
			_this.serverLastRecvMove = m.id;
		}
	}
	recordMove(marble,motionDir,timeState,serverTicks) {
		return this.moveManager.recordMove(marble,motionDir,timeState,serverTicks);
	}
	getNextMove() {
		return this.moveManager.getNextMove();
	}
	sendBytes(b) {
	}
}
$hxClasses["net.GameConnection"] = net_GameConnection;
net_GameConnection.__name__ = "net.GameConnection";
Object.assign(net_GameConnection.prototype, {
	__class__: net_GameConnection
	,id: null
	,state: null
	,moveManager: null
	,name: null
	,lobbyReady: null
	,platform: null
	,marbleId: null
	,isPrivate: null
});
class net_ClientConnection extends net_GameConnection {
	constructor(id,socket,datachannel,datachannelUnreliable) {
		net_GameConnection._hx_skip_constructor = true;
		super();
		net_GameConnection._hx_skip_constructor = false;
		this._hx_constructor(id,socket,datachannel,datachannelUnreliable);
	}
	_hx_constructor(id,socket,datachannel,datachannelUnreliable) {
		this.leftAlready = false;
		this.didWarnTimeout = false;
		this._rttRecords = [];
		super._hx_constructor(id);
		this.socket = socket;
		this.datachannel = datachannel;
		this.datachannelUnreliable = datachannelUnreliable;
		this.state = 1;
		this.rtt = 0;
		this.name = "Unknown";
	}
	sendBytes(b) {
		this.datachannel.sendBytes(b);
	}
}
$hxClasses["net.ClientConnection"] = net_ClientConnection;
net_ClientConnection.__name__ = "net.ClientConnection";
net_ClientConnection.__super__ = net_GameConnection;
Object.assign(net_ClientConnection.prototype, {
	__class__: net_ClientConnection
	,socket: null
	,datachannel: null
	,datachannelUnreliable: null
	,rtt: null
	,pingSendTime: null
	,_rttRecords: null
	,lastRecvTime: null
	,didWarnTimeout: null
	,leftAlready: null
});
class net_DummyConnection extends net_GameConnection {
	constructor(id) {
		super(id);
		this.state = 2;
		this.lobbyReady = true;
	}
}
$hxClasses["net.DummyConnection"] = net_DummyConnection;
net_DummyConnection.__name__ = "net.DummyConnection";
net_DummyConnection.__super__ = net_GameConnection;
Object.assign(net_DummyConnection.prototype, {
	__class__: net_DummyConnection
});
class net_GemPredictionStore {
	constructor() {
		this.predictions = [];
	}
}
$hxClasses["net.GemPredictionStore"] = net_GemPredictionStore;
net_GemPredictionStore.__name__ = "net.GemPredictionStore";
Object.assign(net_GemPredictionStore.prototype, {
	__class__: net_GemPredictionStore
	,predictions: null
});
class net_MarblePrediction {
	constructor(marble,tick) {
		this.tick = tick;
		let _this = marble.newPos;
		this.position = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
		let _this1 = marble.velocity;
		this.velocity = new h3d_Vector(_this1.x,_this1.y,_this1.z,_this1.w);
		let _this2 = marble.omega;
		this.omega = new h3d_Vector(_this2.x,_this2.y,_this2.z,_this2.w);
		this.blastAmount = marble.blastTicks;
		this.isControl = marble.controllable;
	}
}
$hxClasses["net.MarblePrediction"] = net_MarblePrediction;
net_MarblePrediction.__name__ = "net.MarblePrediction";
Object.assign(net_MarblePrediction.prototype, {
	__class__: net_MarblePrediction
	,tick: null
	,position: null
	,velocity: null
	,omega: null
	,isControl: null
	,blastAmount: null
});
class net_MarblePredictionStore {
	constructor() {
		this.predictions = new haxe_ds_ObjectMap();
	}
	storeState(marble,tick) {
		let state = new net_MarblePrediction(marble,tick);
		if(this.predictions.h.__keys__[marble.__id__] != null) {
			let arr = this.predictions.h[marble.__id__];
			while(arr.length != 0 && arr[0].tick >= tick) arr.shift();
			arr.push(state);
		} else {
			this.predictions.set(marble,[state]);
		}
	}
	retrieveState(marble,tick) {
		if(this.predictions.h.__keys__[marble.__id__] != null) {
			let arr = this.predictions.h[marble.__id__];
			while(arr.length != 0 && arr[0].tick < tick) arr.shift();
			if(arr.length == 0) {
				return null;
			}
			let p = arr[0];
			if(p.tick == tick) {
				return p;
			}
			return null;
		}
		return null;
	}
	clearStatesAfterTick(marble,tick) {
		if(this.predictions.h.__keys__[marble.__id__] != null) {
			let arr = this.predictions.h[marble.__id__];
			while(arr.length != 0 && arr[arr.length - 1].tick >= tick) arr.pop();
		}
	}
	removeMarbleFromPrediction(marble) {
		this.predictions.remove(marble);
	}
}
$hxClasses["net.MarblePredictionStore"] = net_MarblePredictionStore;
net_MarblePredictionStore.__name__ = "net.MarblePredictionStore";
Object.assign(net_MarblePredictionStore.prototype, {
	__class__: net_MarblePredictionStore
	,predictions: null
});
class net_OtherMarbleUpdate {
	constructor() {
		this.packets = [];
	}
}
$hxClasses["net.OtherMarbleUpdate"] = net_OtherMarbleUpdate;
net_OtherMarbleUpdate.__name__ = "net.OtherMarbleUpdate";
Object.assign(net_OtherMarbleUpdate.prototype, {
	__class__: net_OtherMarbleUpdate
	,packets: null
	,lastBlastTick: null
	,lastHeliTick: null
	,lastMegaTick: null
	,lastPowerUpId: null
	,lastGravityUp: null
});
class net_MarbleUpdateQueue {
	constructor() {
		this.ourMoveApplied = false;
		this.otherMarbleUpdates = new haxe_ds_IntMap();
	}
	enqueue(update) {
		let cc = update.clientId;
		if(cc != net_Net.clientId) {
			if(this.otherMarbleUpdates.h.hasOwnProperty(cc)) {
				let otherUpdate = this.otherMarbleUpdates.h[cc];
				let ourList = otherUpdate.packets;
				if((update.netFlags & 1) == 0) {
					update.blastTick = otherUpdate.lastBlastTick;
				} else {
					otherUpdate.lastBlastTick = update.blastTick;
				}
				if((update.netFlags & 2) == 0) {
					update.heliTick = otherUpdate.lastHeliTick;
				} else {
					otherUpdate.lastHeliTick = update.heliTick;
				}
				if((update.netFlags & 4) == 0) {
					update.megaTick = otherUpdate.lastMegaTick;
				} else {
					otherUpdate.lastMegaTick = update.megaTick;
				}
				if((update.netFlags & 8) == 0) {
					update.powerUpId = otherUpdate.lastPowerUpId;
				} else {
					otherUpdate.lastPowerUpId = update.powerUpId;
				}
				if((update.netFlags & 16) == 0) {
					update.gravityDirection = otherUpdate.lastGravityUp;
				} else {
					otherUpdate.lastGravityUp = update.gravityDirection;
				}
				ourList.push(update);
			} else {
				let otherUpdate = new net_OtherMarbleUpdate();
				otherUpdate.packets.push(update);
				if((update.netFlags & 1) != 0) {
					otherUpdate.lastBlastTick = update.blastTick;
				}
				if((update.netFlags & 2) != 0) {
					otherUpdate.lastHeliTick = update.heliTick;
				}
				if((update.netFlags & 4) != 0) {
					otherUpdate.lastMegaTick = update.megaTick;
				}
				if((update.netFlags & 8) != 0) {
					otherUpdate.lastPowerUpId = update.powerUpId;
				}
				if((update.netFlags & 16) != 0) {
					otherUpdate.lastGravityUp = update.gravityDirection;
				}
				this.otherMarbleUpdates.h[cc] = otherUpdate;
			}
		} else if(this.myMarbleUpdate == null || update.serverTicks > this.myMarbleUpdate.serverTicks) {
			if(this.myMarbleUpdate != null) {
				if((update.netFlags & 1) == 0) {
					update.blastTick = this.myMarbleUpdate.blastTick;
				}
				if((update.netFlags & 2) == 0) {
					update.heliTick = this.myMarbleUpdate.heliTick;
				}
				if((update.netFlags & 4) == 0) {
					update.megaTick = this.myMarbleUpdate.megaTick;
				}
				if((update.netFlags & 8) == 0) {
					update.powerUpId = this.myMarbleUpdate.powerUpId;
				}
				if((update.netFlags & 16) == 0) {
					update.gravityDirection = this.myMarbleUpdate.gravityDirection;
				}
			}
			this.myMarbleUpdate = update;
			this.ourMoveApplied = false;
		}
	}
}
$hxClasses["net.MarbleUpdateQueue"] = net_MarbleUpdateQueue;
net_MarbleUpdateQueue.__name__ = "net.MarbleUpdateQueue";
Object.assign(net_MarbleUpdateQueue.prototype, {
	__class__: net_MarbleUpdateQueue
	,otherMarbleUpdates: null
	,myMarbleUpdate: null
	,ourMoveApplied: null
});
class net_MasterServerClient {
	constructor(onOpenFunc,onErrorFunc) {
		this.open = false;
		net_MasterServerClient.wsToken++;
		let myToken = net_MasterServerClient.wsToken;
		this.ws = haxe_net_WebSocket.create(net_MasterServerClient.serverIp);
		let _gthis = this;
		this.ws.onopen = function() {
			_gthis.open = true;
			onOpenFunc();
		};
		this.ws.onmessageString = function(m) {
			_gthis.handleMessage(m);
		};
		this.ws.onerror = function(m) {
			src_MarbleGame.canvas.pushDialog(new gui_MessageBoxOkDlg("Failed to connect to master server: " + m));
			if(onErrorFunc != null) {
				onErrorFunc();
			}
			if(myToken == net_MasterServerClient.wsToken) {
				_gthis.open = false;
				_gthis.ws = null;
				net_MasterServerClient.instance = null;
			}
		};
		this.ws.onclose = function(e) {
			if(myToken == net_MasterServerClient.wsToken) {
				_gthis.open = false;
				_gthis.ws = null;
				net_MasterServerClient.instance = null;
			}
		};
	}
	queueMessage(m) {
		this.ws.sendString(m);
	}
	heartBeat() {
		this.queueMessage(JSON.stringify({ type : "heartbeat"}));
	}
	sendServerInfo(serverInfo) {
		this.queueMessage(JSON.stringify({ type : "serverInfo", name : serverInfo.name, players : serverInfo.players, maxPlayers : serverInfo.maxPlayers, privateSlots : serverInfo.privateSlots, privateServer : serverInfo.privateServer, inviteCode : serverInfo.inviteCode, state : serverInfo.state, platform : serverInfo.platform, version : src_MarbleGame.currentVersion}));
	}
	sendConnectToServer(serverName,sdp,isInvite) {
		if(isInvite == null) {
			isInvite = false;
		}
		if(!isInvite) {
			this.queueMessage(JSON.stringify({ type : "connect", serverName : serverName, sdp : sdp}));
		} else {
			this.queueMessage(JSON.stringify({ type : "connectInvite", sdp : sdp, inviteCode : serverName}));
		}
	}
	getServerList(serverListCb) {
		this.serverListCb = serverListCb;
		this.queueMessage(JSON.stringify({ type : "serverList"}));
	}
	handleMessage(message) {
		let conts = JSON.parse(message);
		src_Console.instance.addEntry("log","Received " + conts.type);
		if(conts.type == "serverList") {
			if(this.serverListCb != null) {
				this.serverListCb(conts.servers);
			}
		}
		let _gthis = this;
		if(conts.type == "connect") {
			if(!net_Net.isHost) {
				this.queueMessage(JSON.stringify({ type : "connectFailed", success : false, reason : "The server has shut down"}));
				return;
			}
			let joiningPrivate = conts.isPrivate;
			if(net_Net.serverInfo.players >= net_Net.serverInfo.maxPlayers) {
				this.queueMessage(JSON.stringify({ type : "connectFailed", success : false, reason : "The server is full"}));
				return;
			}
			let pubSlotsAvail = net_Net.serverInfo.maxPlayers - net_Net.serverInfo.privateSlots;
			let privSlotsAvail = net_Net.serverInfo.privateSlots;
			let pubCount = 1;
			let privCount = 0;
			let this1 = net_Net.clientIdMap;
			let _g_keys = this1.keys();
			while(_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = this1.get(key);
				if(_g_value.isPrivate) {
					++privCount;
				} else {
					++pubCount;
				}
			}
			if(!joiningPrivate && pubCount >= pubSlotsAvail) {
				this.queueMessage(JSON.stringify({ type : "connectFailed", success : false, reason : "The server is full"}));
				return;
			}
			if(joiningPrivate && privCount >= privSlotsAvail) {
				joiningPrivate = false;
			}
			net_Net.addClientFromSdp(conts.sdp,joiningPrivate,function(sdpReply) {
				_gthis.queueMessage(JSON.stringify({ success : true, type : "connectResponse", sdp : sdpReply, clientId : conts.clientId}));
			});
		}
		if(conts.type == "connectResponse") {
			src_Console.instance.addEntry("log","Remote Description Received!");
			let sdpObj = JSON.parse(conts.sdp);
			if(net_Net.client != null) {
				net_Net.client.setRemoteDescription(sdpObj.sdp,sdpObj.type);
			}
		}
		if(conts.type == "connectFailed") {
			let loadGui = src_MarbleGame.canvas.content;
			if(loadGui != null) {
				loadGui.setErrorStatus(conts.reason);
			}
		}
		if(conts.type == "turnserver") {
			net_Net.turnServer = conts.server;
		}
	}
	static connectToMasterServer(onConnect,onError) {
		if(net_MasterServerClient.instance == null) {
			net_MasterServerClient.instance = new net_MasterServerClient(onConnect,onError);
		} else if(net_MasterServerClient.instance.open) {
			onConnect();
		} else {
			if(net_MasterServerClient.instance != null && net_MasterServerClient.instance.ws != null) {
				net_MasterServerClient.instance.ws.close();
			}
			net_MasterServerClient.instance = new net_MasterServerClient(onConnect,onError);
		}
	}
	static disconnectFromMasterServer() {
		if(net_MasterServerClient.instance != null && net_MasterServerClient.instance.ws != null) {
			net_MasterServerClient.instance.ws.close();
			if(net_MasterServerClient.instance != null) {
				net_MasterServerClient.instance.open = false;
				net_MasterServerClient.instance.ws = null;
				net_MasterServerClient.instance = null;
			}
		}
	}
}
$hxClasses["net.MasterServerClient"] = net_MasterServerClient;
net_MasterServerClient.__name__ = "net.MasterServerClient";
Object.assign(net_MasterServerClient.prototype, {
	__class__: net_MasterServerClient
	,ws: null
	,serverListCb: null
	,open: null
});
class net_Move {
	constructor() {
	}
}
$hxClasses["net.Move"] = net_Move;
net_Move.__name__ = "net.Move";
Object.assign(net_Move.prototype, {
	__class__: net_Move
	,d: null
	,jump: null
	,powerup: null
	,blast: null
});
class net_NetMove {
	constructor(move,motionDir,timeState,serverTicks,id) {
		this.move = move;
		this.motionDir = motionDir;
		this.id = id;
		this.serverTicks = serverTicks;
		this.timeState = timeState;
	}
}
$hxClasses["net.NetMove"] = net_NetMove;
net_NetMove.__name__ = "net.NetMove";
Object.assign(net_NetMove.prototype, {
	__class__: net_NetMove
	,motionDir: null
	,move: null
	,id: null
	,timeState: null
	,serverTicks: null
});
class net_MoveManager {
	constructor(connection) {
		this.stall = false;
		this.serverLastAckMove = 0;
		this.serverLastRecvMove = 0;
		this.serverMoveListSizeSlack = 1.5;
		this.serverSmoothMoveAvg = 0.15;
		this.serverAvgMoveListSize = 3.0;
		this.serverMaxMoveListSize = 8;
		this.serverTargetMoveListSize = 3;
		this.maxSendMoveListSize = 30;
		this.maxMoves = 45;
		this.ackRTT = -1;
		this.lastAckMoveId = -1;
		this.queuedMoves = [];
		this.nextMoveId = 0;
		this.connection = connection;
		let mv = new net_Move();
		mv.d = new h3d_Vector(0,0);
	}
	recordMove(marble,motionDir,timeState,serverTicks) {
		if(this.queuedMoves.length >= this.maxMoves || this.stall) {
			return this.queuedMoves[this.queuedMoves.length - 1];
		}
		let move = new net_Move();
		move.d = new h3d_Vector();
		if(!src_MarbleGame.instance.paused) {
			move.d.x = src_Gamepad.getAxis(src_Settings.gamepadSettings.moveYAxis);
			move.d.y = -src_Gamepad.getAxis(src_Settings.gamepadSettings.moveXAxis);
			if(src_Settings.controlsSettings.moddedController) {
				let moveLen = Math.sqrt(move.d.x * move.d.x + move.d.y * move.d.y);
				if(moveLen > 0.00001) {
					let normalizedX = move.d.x / moveLen;
					let normalizedY = move.d.y / moveLen;
					let scaleFactor = Math.max(Math.abs(normalizedX),Math.abs(normalizedY));
					if(scaleFactor > 0) {
						move.d.x = normalizedX / scaleFactor * moveLen;
						move.d.y = normalizedY / scaleFactor * moveLen;
					}
				}
			}
			let tmp = src_MarbleGame.instance.world.playGui.chatCtrl;
			if(!(tmp != null ? tmp.chatFocused : null)) {
				if(hxd_Key.isDown(src_Settings.controlsSettings.forward)) {
					move.d.x -= 1;
				}
				if(hxd_Key.isDown(src_Settings.controlsSettings.backward)) {
					move.d.x += 1;
				}
				if(hxd_Key.isDown(src_Settings.controlsSettings.left)) {
					move.d.y += 1;
				}
				if(hxd_Key.isDown(src_Settings.controlsSettings.right)) {
					move.d.y -= 1;
				}
				let value = move.d.x;
				move.d.x = value < -1 ? -1 : value > 1 ? 1 : value;
				let value1 = move.d.y;
				move.d.y = value1 < -1 ? -1 : value1 > 1 ? 1 : value1;
				if(hxd_Key.isDown(src_Settings.controlsSettings.jump) || src_MarbleGame.instance.touchInput.jumpButton.pressed || src_Gamepad.isDown(src_Settings.gamepadSettings.jump)) {
					move.jump = true;
				}
				if(!src_Util.isTouchDevice() && hxd_Key.isDown(src_Settings.controlsSettings.powerup) || src_Util.isTouchDevice() && src_MarbleGame.instance.touchInput.powerupButton.pressed || src_Gamepad.isDown(src_Settings.gamepadSettings.powerup)) {
					move.powerup = true;
				}
				if(hxd_Key.isDown(src_Settings.controlsSettings.blast) || src_MarbleGame.instance.touchInput.blastbutton.pressed || src_Gamepad.isDown(src_Settings.gamepadSettings.blast)) {
					move.blast = true;
				}
				if(src_MarbleGame.instance.touchInput.movementInput.pressed) {
					move.d.y = -src_MarbleGame.instance.touchInput.movementInput.value.x;
					move.d.x = src_MarbleGame.instance.touchInput.movementInput.value.y;
				}
			}
			let qx = move.d.x * 16 + 16 | 0;
			let qy = move.d.y * 16 + 16 | 0;
			move.d.x = (qx - 16) / 16.0;
			move.d.y = (qy - 16) / 16.0;
		}
		let netMove = new net_NetMove(move,motionDir,timeState.clone(),serverTicks,this.nextMoveId++);
		this.queuedMoves.push(netMove);
		if(this.nextMoveId >= 65535) {
			this.nextMoveId = 0;
		}
		let moveStartIdx = this.queuedMoves.length - this.maxSendMoveListSize;
		if(moveStartIdx < 0) {
			moveStartIdx = 0;
		}
		let b = new net_OutputBitStream();
		let movePacket = new net_MarbleMovePacket();
		movePacket.clientId = net_Net.clientId;
		movePacket.moves = this.queuedMoves.slice(moveStartIdx);
		movePacket.clientTicks = timeState.ticks;
		b.writeByte(6);
		b.writeByte(movePacket.clientId);
		b.writeUInt16(movePacket.clientTicks);
		b.writeInt(movePacket.moves.length,5);
		let _g = 0;
		let _g1 = movePacket.moves;
		while(_g < _g1.length) {
			let move = _g1[_g];
			++_g;
			b.writeUInt16(move.id);
			b.writeByte(move.move.d.x * 16 + 16 | 0);
			b.writeByte(move.move.d.y * 16 + 16 | 0);
			b.writeFlag(move.move.jump);
			b.writeFlag(move.move.powerup);
			b.writeFlag(move.move.blast);
			b.writeFloat(move.motionDir.x);
			b.writeFloat(move.motionDir.y);
			b.writeFloat(move.motionDir.z);
		}
		net_Net.sendPacketToHostUnreliable(b);
		return netMove;
	}
	getNextMove() {
		if(net_Net.isHost) {
			this.serverAvgMoveListSize = (this.serverAvgMoveListSize *= 1 - this.serverSmoothMoveAvg) + this.serverSmoothMoveAvg * this.queuedMoves.length;
			if(this.serverAvgMoveListSize < this.serverTargetMoveListSize - this.serverMoveListSizeSlack && this.queuedMoves.length < this.serverTargetMoveListSize && this.queuedMoves.length != 0) {
				this.serverAvgMoveListSize = Math.max(this.serverAvgMoveListSize + this.serverMoveListSizeSlack + 0.5 | 0,this.queuedMoves.length);
				return null;
			}
			if(this.queuedMoves.length > this.serverMaxMoveListSize || this.serverAvgMoveListSize > this.serverTargetMoveListSize + this.serverMoveListSizeSlack && this.queuedMoves.length > this.serverTargetMoveListSize) {
				let dropAmt = this.queuedMoves.length - this.serverTargetMoveListSize;
				while(dropAmt-- > 0) this.queuedMoves.pop();
				this.serverAvgMoveListSize = this.serverTargetMoveListSize;
			}
		}
		if(this.queuedMoves.length == 0) {
			return this.lastMove;
		} else {
			this.lastMove = this.queuedMoves[0];
			this.queuedMoves.shift();
			this.lastAckMoveId = this.lastMove.id;
			return this.lastMove;
		}
	}
	acknowledgeMove(m,timeState) {
		if(m.id == 65535 || m.id == -1) {
			return null;
		}
		if(m.id <= this.lastAckMoveId) {
			return null;
		}
		if(this.queuedMoves.length == 0) {
			return null;
		}
		if(m.id >= this.nextMoveId) {
			return this.queuedMoves[0];
		}
		while(m.id != this.queuedMoves[0].id) this.queuedMoves.shift();
		let mv = null;
		if(m.id == this.queuedMoves[0].id) {
			mv = this.queuedMoves.shift();
			this.ackRTT = timeState.ticks - mv.timeState.ticks;
		}
		this.lastAckMoveId = m.id;
		return mv;
	}
}
$hxClasses["net.MoveManager"] = net_MoveManager;
net_MoveManager.__name__ = "net.MoveManager";
Object.assign(net_MoveManager.prototype, {
	__class__: net_MoveManager
	,connection: null
	,queuedMoves: null
	,nextMoveId: null
	,lastMove: null
	,lastAckMoveId: null
	,ackRTT: null
	,maxMoves: null
	,maxSendMoveListSize: null
	,serverTargetMoveListSize: null
	,serverMaxMoveListSize: null
	,serverAvgMoveListSize: null
	,serverSmoothMoveAvg: null
	,serverMoveListSizeSlack: null
	,serverLastRecvMove: null
	,serverLastAckMove: null
	,stall: null
});
class net_ServerInfo {
	constructor(name,players,maxPlayers,privateSlots,privateServer,inviteCode,state,platform) {
		this.name = name;
		this.players = players;
		this.maxPlayers = maxPlayers;
		this.privateSlots = privateSlots;
		this.privateServer = privateServer;
		this.inviteCode = inviteCode;
		this.state = state;
		this.platform = platform;
	}
}
$hxClasses["net.ServerInfo"] = net_ServerInfo;
net_ServerInfo.__name__ = "net.ServerInfo";
Object.assign(net_ServerInfo.prototype, {
	__class__: net_ServerInfo
	,name: null
	,players: null
	,maxPlayers: null
	,privateSlots: null
	,privateServer: null
	,inviteCode: null
	,state: null
	,platform: null
});
class net_Net {
	static hostServer(name,maxPlayers,privateSlots,privateServer,onHosted) {
		net_Net.serverInfo = new net_ServerInfo(name,1,maxPlayers,privateSlots,privateServer,999999 * Math.random() | 0,"LOBBY",3);
		net_MasterServerClient.connectToMasterServer(function() {
			net_Net.isHost = true;
			net_Net.isClient = false;
			net_Net.clientId = 0;
			net_Net.isMP = true;
			net_MasterServerClient.instance.sendServerInfo(net_Net.serverInfo);
			onHosted();
		});
	}
	static addClientFromSdp(sdpString,privateJoin,onFinishSdp) {
		let peer = new datachannel_RTCPeerConnection(net_Net.stunServers,"0.0.0.0");
		let sdpObj = JSON.parse(sdpString);
		peer.setRemoteDescription(sdpObj.sdp,sdpObj.type);
		net_Net.addClient(peer,privateJoin,onFinishSdp);
	}
	static addClient(peer,privateJoin,onFinishSdp) {
		let candidates = [];
		peer.onLocalCandidate = function(c) {
			src_Console.instance.addEntry("log","Local candidate: " + c);
			if(c != "") {
				candidates.push("a=" + c);
			}
		};
		peer.onStateChange = function(s) {
			switch(s) {
			case 0:
				src_Console.instance.addEntry("log","RTC State change: New...");
				break;
			case 1:
				src_Console.instance.addEntry("log","RTC State change: Connecting...");
				break;
			case 2:
				src_Console.instance.addEntry("log","RTC State change: Connected!");
				break;
			case 3:
				src_Console.instance.addEntry("log","RTC State change: Disconnected!");
				break;
			case 4:
				src_Console.instance.addEntry("log","RTC State change: Failed!");
				break;
			case 5:
				src_Console.instance.addEntry("log","RTC State change: Connection closed!");
				break;
			}
		};
		let sdpFinished = false;
		let finishSdp = function() {
			if(sdpFinished) {
				return;
			}
			if(peer == null) {
				return;
			}
			sdpFinished = true;
			let sdpObj = StringTools.trim(peer.localDescription);
			sdpObj = sdpObj + "\r\n" + candidates.join("\r\n") + "\r\n";
			onFinishSdp(JSON.stringify({ sdp : sdpObj, type : "answer"}));
		};
		peer.onGatheringStateChange = function(s) {
			switch(s) {
			case 0:
				src_Console.instance.addEntry("log","Gathering new...");
				break;
			case 1:
				src_Console.instance.addEntry("log","Gathering in progress...");
				break;
			case 2:
				src_Console.instance.addEntry("log","Gathering complete!");
				break;
			}
			if(s == 2) {
				finishSdp();
			}
		};
		let reliable = null;
		let unreliable = null;
		peer.onDataChannel = function(dc) {
			if(dc.get_name() == "mp") {
				reliable = dc;
			}
			if(dc.get_name() == "unreliable") {
				unreliable = dc;
				let _g = dc.get_reliability();
				switch(_g._hx_index) {
				case 0:
					src_Console.instance.addEntry("log","Error opening unreliable datachannel!");
					break;
				case 1:
					src_Console.instance.addEntry("log","Opened unreliable datachannel: " + _g.maxRetransmits + " " + _g.maxLifetime);
					break;
				}
			}
			if(reliable != null && unreliable != null) {
				net_Net.onClientConnect(peer,reliable,unreliable,privateJoin);
			}
		};
	}
	static addGhost(id) {
		let ghost = new net_DummyConnection(id);
		net_Net.clientIdMap.h[id] = ghost;
	}
	static joinServer(serverName,isInvite,connectedCb) {
		net_MasterServerClient.connectToMasterServer(function() {
			net_Net.client = new datachannel_RTCPeerConnection(net_Net.stunServers,"0.0.0.0");
			let candidates = [];
			let closing = false;
			net_Net.isMP = true;
			net_Net.isHost = false;
			net_Net.isClient = true;
			let closeFunc = function(msg,forceShow) {
				if(closing) {
					return;
				}
				closing = true;
				let weLeftOurselves = !net_Net.isClient;
				net_Net.disconnect();
				if(src_MarbleGame.instance.world != null) {
					src_MarbleGame.instance.quitMission();
				}
				if(!weLeftOurselves || forceShow) {
					if(!((src_MarbleGame.canvas.content) instanceof gui_MultiplayerLoadingGui)) {
						let loadGui = new gui_MultiplayerLoadingGui(msg);
						src_MarbleGame.canvas.setContent(loadGui);
						loadGui.setErrorStatus(msg);
					} else {
						let loadGui = js_Boot.__cast(src_MarbleGame.canvas.content , gui_MultiplayerLoadingGui);
						loadGui.setErrorStatus(msg);
					}
				}
			};
			net_Net.client.onLocalCandidate = function(c) {
				src_Console.instance.addEntry("log","Local candidate: " + c);
				if(c != "") {
					candidates.push("a=" + c);
				}
			};
			net_Net.client.onStateChange = function(s) {
				switch(s) {
				case 0:
					src_Console.instance.addEntry("log","RTC State change: New...");
					break;
				case 1:
					src_Console.instance.addEntry("log","RTC State change: Connecting...");
					break;
				case 2:
					src_Console.instance.addEntry("log","RTC State change: Connected!");
					break;
				case 3:
					src_Console.instance.addEntry("log","RTC State change: Disconnected!");
					break;
				case 4:
					src_Console.instance.addEntry("log","RTC State change: Failed!");
					break;
				case 5:
					src_Console.instance.addEntry("log","RTC State change: Connection closed!");
					closeFunc("Connection closed",true);
					break;
				}
			};
			let sdpFinished = false;
			let finishSdp = function() {
				if(sdpFinished) {
					return;
				}
				sdpFinished = true;
				if(net_Net.client == null) {
					return;
				}
				src_Console.instance.addEntry("log","Local Description Set!");
				let sdpObj = StringTools.trim(net_Net.client.localDescription);
				sdpObj = sdpObj + "\r\n" + candidates.join("\r\n") + "\r\n";
				net_MasterServerClient.instance.sendConnectToServer(serverName,JSON.stringify({ sdp : sdpObj, type : "offer"}),isInvite);
			};
			net_Net.client.onGatheringStateChange = function(s) {
				switch(s) {
				case 0:
					src_Console.instance.addEntry("log","Gathering new...");
					break;
				case 1:
					src_Console.instance.addEntry("log","Gathering in progress...");
					break;
				case 2:
					src_Console.instance.addEntry("log","Gathering complete!");
					break;
				}
				if(s == 2) {
					finishSdp();
				}
			};
			net_Net.clientDatachannel = net_Net.client.createDatachannel("mp");
			net_Net.clientDatachannelUnreliable = net_Net.client.createDatachannelWithOptions("unreliable",true,null,600);
			let openFlags = 0;
			let onDatachannelOpen = function(idx) {
				if(!net_Net.isMP) {
					net_Net.client.close();
					return;
				}
				openFlags |= idx;
				if(openFlags == 3) {
					if(((src_MarbleGame.canvas.content) instanceof gui_MultiplayerLoadingGui)) {
						let loadGui = src_MarbleGame.canvas.content;
						if(loadGui != null) {
							loadGui.setLoadingStatus("Handshaking");
						}
					}
					src_Console.instance.addEntry("log","Successfully connected!");
					net_Net.clients.set(net_Net.client,new net_ClientConnection(0,net_Net.client,net_Net.clientDatachannel,net_Net.clientDatachannelUnreliable));
					let v = net_Net.clients.h[net_Net.client.__id__];
					net_Net.clientIdMap.h[0] = v;
					net_Net.clientConnection = net_Net.clients.h[net_Net.client.__id__];
					net_Net.onConnectedToServer();
					haxe_Timer.delay(function() {
						connectedCb();
					},1500);
				}
			};
			let onDatachannelMessage = function(dc,b) {
				net_Net.onPacketReceived(net_Net.clientConnection,net_Net.client,net_Net.clientDatachannel,new net_InputBitStream(b));
			};
			let onDatachannelClose = function(dc) {
				closeFunc("Disconnected",true);
			};
			let onDatachannelError = function(msg) {
				src_Console.instance.addEntry("log","Errored out due to " + msg);
				closeFunc("Connection error",true);
			};
			net_Net.clientDatachannel.onOpen = function(n) {
				onDatachannelOpen(1);
			};
			net_Net.clientDatachannel.onMessage = function(b) {
				onDatachannelMessage(net_Net.clientDatachannel,b);
			};
			net_Net.clientDatachannel.onClosed = function() {
				onDatachannelClose(net_Net.clientDatachannel);
			};
			net_Net.clientDatachannel.onError = function(msg) {
				onDatachannelError(msg);
			};
			net_Net.clientDatachannelUnreliable.onOpen = function(n) {
				onDatachannelOpen(2);
			};
			net_Net.clientDatachannelUnreliable.onMessage = function(b) {
				onDatachannelMessage(net_Net.clientDatachannelUnreliable,b);
			};
			net_Net.clientDatachannelUnreliable.onClosed = function() {
				onDatachannelClose(net_Net.clientDatachannelUnreliable);
			};
			net_Net.clientDatachannelUnreliable.onError = function(msg) {
				onDatachannelError(msg);
			};
		});
	}
	static disconnect() {
		if(net_Net.isClient) {
			net_NetCommands.clientLeave(net_Net.clientId);
			net_Net.isMP = false;
			net_Net.isClient = false;
			net_Net.isHost = false;
			if(net_Net.client != null) {
				net_Net.client.close();
			}
			net_Net.client = null;
			net_Net.clientDatachannel = null;
			net_Net.clientId = 0;
			net_Net.clientIdAllocs = 1;
			net_Net.clients.h = { __keys__ : { }};
			net_Net.clientIdMap.h = { };
			net_Net.clientConnection = null;
			net_Net.serverInfo = null;
			net_Net.remoteServerInfo = null;
			net_Net.lobbyHostReady = false;
			net_Net.lobbyClientReady = false;
			net_Net.hostReady = false;
			gui_MultiplayerLevelSelectGui.custSelected = false;
		}
		if(net_Net.isHost) {
			net_NetCommands.serverClosed();
			let this1 = net_Net.clients;
			let _g_keys = this1.keys();
			while(_g_keys.hasNext()) {
				let key = _g_keys.next();
				this1.get(key);
				key.close();
			}
			net_Net.isMP = false;
			net_Net.isClient = false;
			net_Net.isHost = false;
			net_Net.clientId = 0;
			net_Net.clientIdAllocs = 1;
			net_Net.clients.h = { __keys__ : { }};
			net_Net.clientIdMap.h = { };
			net_MasterServerClient.disconnectFromMasterServer();
			net_Net.serverInfo = null;
			net_Net.remoteServerInfo = null;
			net_Net.lobbyHostReady = false;
			net_Net.lobbyClientReady = false;
			net_Net.hostReady = false;
			gui_MultiplayerLevelSelectGui.custSelected = false;
		}
	}
	static checkPacketTimeout(dt) {
		if(!net_Net.isMP) {
			return;
		}
		net_Net.checkPacketTimeout_accum += dt;
		net_Net.checkPacketTimeout_wsAccum += dt;
		if(net_Net.checkPacketTimeout_accum > 1.0) {
			net_Net.checkPacketTimeout_accum = 0;
			let t = HxOverrides.now() / 1000;
			let this1 = net_Net.clients;
			let _g_keys = this1.keys();
			while(_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = this1.get(key);
				if(((_g_value) instanceof net_ClientConnection)) {
					let conn = js_Boot.__cast(_g_value , net_ClientConnection);
					if(t - conn.lastRecvTime > 10 && !conn.didWarnTimeout) {
						conn.didWarnTimeout = true;
						if(net_Net.isClient) {
							net_NetCommands.requestPing();
						}
						if(net_Net.isHost) {
							net_NetCommands.pingClient(_g_value,t);
						}
					}
					if(t - conn.lastRecvTime > 15 && conn.didWarnTimeout) {
						if(net_Net.isHost) {
							key.close();
							net_Net.onClientLeave(conn);
						}
						if(net_Net.isClient) {
							net_Net.disconnect();
							if(src_MarbleGame.instance.world != null) {
								src_MarbleGame.instance.quitMission();
							}
							if(!((src_MarbleGame.canvas.content) instanceof gui_MultiplayerLoadingGui)) {
								let loadGui = new gui_MultiplayerLoadingGui("Timed out");
								src_MarbleGame.canvas.setContent(loadGui);
								loadGui.setErrorStatus("Timed out");
							}
						}
					}
				}
			}
		}
		if(net_Net.checkPacketTimeout_wsAccum >= 15.0) {
			net_Net.checkPacketTimeout_wsAccum = 0;
			if(net_Net.isHost) {
				if(net_MasterServerClient.instance != null) {
					net_MasterServerClient.instance.sendServerInfo(net_Net.serverInfo);
				} else {
					net_MasterServerClient.connectToMasterServer(function() {
						net_MasterServerClient.instance.sendServerInfo(net_Net.serverInfo);
					});
				}
			}
			if(net_Net.isClient) {
				if(net_MasterServerClient.instance != null) {
					net_MasterServerClient.instance.heartBeat();
				} else {
					net_MasterServerClient.connectToMasterServer(function() {
						net_MasterServerClient.instance.heartBeat();
					});
				}
			}
		}
	}
	static onClientConnect(c,dc,dcu,joiningPrivate) {
		if(!net_Net.isMP) {
			c.close();
			return;
		}
		let clientId = net_Net.allocateClientId();
		if(clientId == -1) {
			c.close();
			return;
		}
		let cc = new net_ClientConnection(clientId,c,dc,dcu);
		net_Net.clients.set(c,cc);
		cc.isPrivate = joiningPrivate;
		let v = net_Net.clients.h[c.__id__];
		net_Net.clientIdMap.h[clientId] = v;
		cc.lastRecvTime = HxOverrides.now() / 1000;
		let closing = false;
		let onMessage = function(dc,msgBytes) {
			net_Net.onPacketReceived(cc,c,dc,new net_InputBitStream(msgBytes));
		};
		let onClosed = function() {
			if(closing) {
				return;
			}
			closing = true;
			net_Net.clients.remove(c);
			net_Net.onClientLeave(cc);
		};
		let onError = function(msg) {
			if(closing) {
				return;
			}
			closing = true;
			net_Net.clients.remove(c);
			src_Console.instance.addEntry("log","Client " + cc.id + " errored out due to: " + msg);
			net_Net.onClientLeave(cc);
		};
		dc.onMessage = function(msgBytes) {
			onMessage(dc,msgBytes);
		};
		dc.onClosed = function() {
			onClosed();
		};
		dc.onError = function(msg) {
			onError(msg);
		};
		dcu.onMessage = function(msgBytes) {
			onMessage(dcu,msgBytes);
		};
		dcu.onClosed = function() {
			onClosed();
		};
		dcu.onError = function(msg) {
			onError(msg);
		};
		let b = new haxe_io_Bytes(new ArrayBuffer(2));
		b.b[0] = 1;
		b.b[1] = clientId;
		dc.sendBytes(b);
		src_Console.instance.addEntry("log","Client has connected!");
		let b1 = new haxe_io_Bytes(new ArrayBuffer(2));
		b1.b[0] = 3;
		b1.b[1] = 3;
		(js_Boot.__cast(net_Net.clients.h[c.__id__] , net_ClientConnection)).pingSendTime = HxOverrides.now() / 1000;
		dc.sendBytes(b1);
		src_Console.instance.addEntry("log","Sending ping packet!");
		src_AudioManager.playSound(src_ResourceLoader.getAudio("data/sound/spawn_alternate.wav").resource);
		net_Net.serverInfo.players = 1;
		let this1 = net_Net.clients;
		let _g_keys = this1.keys();
		while(_g_keys.hasNext()) {
			let key = _g_keys.next();
			this1.get(key);
			net_Net.serverInfo.players++;
		}
		net_Net.serverInfo.players++;
		net_MasterServerClient.instance.sendServerInfo(net_Net.serverInfo);
		if(((src_MarbleGame.canvas.content) instanceof gui_MultiplayerLevelSelectGui)) {
			(js_Boot.__cast(src_MarbleGame.canvas.content , gui_MultiplayerLevelSelectGui)).updateLobbyNames();
		}
	}
	static onConnectedToServer() {
		src_Console.instance.addEntry("log","Connected to the server!");
		let b = new haxe_io_Bytes(new ArrayBuffer(2));
		b.b[0] = 3;
		b.b[1] = 3;
		(js_Boot.__cast(net_Net.clients.h[net_Net.client.__id__] , net_ClientConnection)).pingSendTime = HxOverrides.now() / 1000;
		net_Net.clientDatachannel.sendBytes(b);
		src_Console.instance.addEntry("log","Sending ping packet!");
	}
	static onClientLeave(cc) {
		if(!net_Net.isMP || cc == null) {
			return;
		}
		if(cc.leftAlready) {
			return;
		}
		cc.leftAlready = true;
		net_NetCommands.clientDisconnected(cc.id);
		if(cc.id != 0) {
			net_Net.freeClientId(cc.id);
		}
		net_Net.serverInfo.players = 1;
		let this1 = net_Net.clients;
		let _g_keys = this1.keys();
		while(_g_keys.hasNext()) {
			let key = _g_keys.next();
			this1.get(key);
			net_Net.serverInfo.players++;
		}
		net_MasterServerClient.instance.sendServerInfo(net_Net.serverInfo);
		src_AudioManager.playSound(src_ResourceLoader.getAudio("data/sound/infotutorial.wav").resource);
		if(((src_MarbleGame.canvas.content) instanceof gui_MultiplayerLevelSelectGui)) {
			(js_Boot.__cast(src_MarbleGame.canvas.content , gui_MultiplayerLevelSelectGui)).updateLobbyNames();
		}
	}
	static onClientHandshakeComplete(conn) {
		if(gui_MultiplayerLevelSelectGui.custSelected) {
			net_NetCommands.setLobbyCustLevelNameClient(conn,gui_MultiplayerLevelSelectGui.custPath);
		} else {
			net_NetCommands.setLobbyLevelIndexClient(conn,gui_MultiplayerLevelSelectGui.currentSelectionStatic);
		}
		if(net_Net.serverInfo.state == "PLAYING") {
			if(gui_MultiplayerLevelSelectGui.custSelected) {
				net_NetCommands.playCustomLevelMidJoinClient(conn,gui_MultiplayerLevelSelectGui.custPath);
			} else {
				net_NetCommands.playLevelMidJoinClient(conn,gui_MultiplayerLevelSelectGui.currentSelectionStatic);
			}
			src_MarbleGame.instance.world.addJoiningClient(conn,function() {
			});
			let playerInfoBytes = net_Net.sendPlayerInfosBytes();
			let this1 = net_Net.clients;
			let _g_keys = this1.keys();
			while(_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = this1.get(key);
				if(_g_value != conn) {
					_g_value.sendBytes(playerInfoBytes);
					net_NetCommands.addMidGameJoinMarbleClient(_g_value,conn.id);
				}
			}
		}
		if(net_Net.serverInfo.state == "LOBBY") {
			net_NetCommands.enterLobbyClient(conn);
		}
	}
	static sendPlayerInfosBytes() {
		let b = new haxe_io_BytesOutput();
		b.writeByte(10);
		let cnt = 0;
		let c = net_Net.clientIdMap.iterator();
		while(c.hasNext()) {
			c.next();
			++cnt;
		}
		b.writeByte(cnt + 1);
		let this1 = net_Net.clientIdMap;
		let _g_keys = this1.keys();
		while(_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = this1.get(key);
			b.writeByte(key);
			b.writeByte(_g_value.lobbyReady ? 1 : 0);
			b.writeByte(_g_value.platform);
			b.writeByte(_g_value.marbleId);
			let name = _g_value.name;
			b.writeByte(name.length);
			let _g = 0;
			let _g1 = name.length;
			while(_g < _g1) {
				let i = _g++;
				b.writeByte(name.charCodeAt(i));
			}
		}
		b.writeByte(0);
		b.writeByte(net_Net.lobbyHostReady ? 1 : 0);
		b.writeByte(3);
		b.writeByte(src_Settings.optionsSettings.marbleIndex);
		let name = src_Settings.highscoreName;
		b.writeByte(name.length);
		let _g = 0;
		let _g1 = name.length;
		while(_g < _g1) {
			let i = _g++;
			b.writeByte(name.charCodeAt(i));
		}
		return b.getBytes();
	}
	static onPacketReceived(conn,c,dc,input) {
		if(!net_Net.isMP) {
			return;
		}
		conn.lastRecvTime = HxOverrides.now() / 1000;
		conn.didWarnTimeout = false;
		let packetType = input.readByte();
		switch(packetType) {
		case 1:
			net_Net.clientId = input.readByte();
			src_Console.instance.addEntry("log","Client ID set to " + net_Net.clientId);
			net_NetCommands.setPlayerData(net_Net.clientId,src_Settings.highscoreName,src_Settings.optionsSettings.marbleIndex);
			net_NetCommands.transmitPlatform(net_Net.clientId,3);
			break;
		case 2:
			net_NetCommands.readPacket(input);
			break;
		case 3:
			let pingLeft = input.readByte();
			src_Console.instance.addEntry("log","Got ping packet!");
			let b = new haxe_io_Bytes(new ArrayBuffer(2));
			b.b[0] = 4;
			b.b[1] = pingLeft;
			dc.sendBytes(b);
			break;
		case 4:
			let pingLeft1 = input.readByte();
			src_Console.instance.addEntry("log","Got pingback packet!");
			let now = HxOverrides.now() / 1000;
			conn._rttRecords.push(now - conn.pingSendTime);
			if(pingLeft1 > 0) {
				conn.pingSendTime = now;
				let b = new haxe_io_Bytes(new ArrayBuffer(2));
				b.b[0] = 3;
				b.b[1] = pingLeft1 - 1;
				dc.sendBytes(b);
			} else {
				let _g = 0;
				let _g1 = conn._rttRecords;
				while(_g < _g1.length) {
					let r = _g1[_g];
					++_g;
					conn.rtt += r;
				}
				conn.rtt /= conn._rttRecords.length;
				src_Console.instance.addEntry("log","Got RTT " + conn.rtt + " for client " + conn.id);
				if(net_Net.isHost) {
					let b = net_Net.sendPlayerInfosBytes();
					let cc = net_Net.clients.iterator();
					while(cc.hasNext()) {
						let cc1 = cc.next();
						cc1.sendBytes(b);
					}
					net_Net.onClientHandshakeComplete(conn);
				}
			}
			break;
		case 5:
			let marbleUpdatePacket = new net_MarbleUpdatePacket();
			marbleUpdatePacket.clientId = input.readByte();
			let moveId = input.readUInt16();
			let move = new net_Move();
			move.d = new h3d_Vector();
			let tmp = input.readByte() - 16;
			move.d.x = tmp / 16.0;
			let tmp1 = input.readByte() - 16;
			move.d.y = tmp1 / 16.0;
			move.jump = input.readFlag();
			move.powerup = input.readFlag();
			move.blast = input.readFlag();
			let motionDir = new h3d_Vector();
			motionDir.x = input.readFloat();
			motionDir.y = input.readFloat();
			motionDir.z = input.readFloat();
			let netMove = new net_NetMove(move,motionDir,src_MarbleGame.instance.world.timeState.clone(),0,moveId);
			marbleUpdatePacket.move = netMove;
			marbleUpdatePacket.serverTicks = input.readUInt16();
			marbleUpdatePacket.moveQueueSize = input.readByte();
			marbleUpdatePacket.position = new h3d_Vector(input.readFloat(),input.readFloat(),input.readFloat());
			marbleUpdatePacket.velocity = new h3d_Vector(input.readFloat(),input.readFloat(),input.readFloat());
			marbleUpdatePacket.omega = new h3d_Vector(input.readFloat(),input.readFloat(),input.readFloat());
			marbleUpdatePacket.lastContactNormal = new h3d_Vector(input.readFloat(),input.readFloat(),input.readFloat());
			marbleUpdatePacket.blastAmount = input.readInt(11);
			marbleUpdatePacket.netFlags = 0;
			if(input.readFlag()) {
				marbleUpdatePacket.blastTick = input.readUInt16();
				marbleUpdatePacket.netFlags |= 1;
			}
			if(input.readFlag()) {
				marbleUpdatePacket.heliTick = input.readUInt16();
				marbleUpdatePacket.netFlags |= 2;
			}
			if(input.readFlag()) {
				marbleUpdatePacket.megaTick = input.readUInt16();
				marbleUpdatePacket.netFlags |= 4;
			}
			marbleUpdatePacket.oob = input.readFlag();
			if(input.readFlag()) {
				marbleUpdatePacket.netFlags |= 32;
			}
			if(input.readFlag()) {
				marbleUpdatePacket.powerUpId = input.readInt(9);
				marbleUpdatePacket.netFlags |= 8;
			}
			if(input.readFlag()) {
				marbleUpdatePacket.gravityDirection = new h3d_Vector(input.readFloat(),input.readFloat(),input.readFloat());
				marbleUpdatePacket.netFlags |= 16;
			}
			if(src_MarbleGame.instance.world != null && !src_MarbleGame.instance.world._disposed) {
				let m = src_MarbleGame.instance.world.lastMoves;
				m.enqueue(marbleUpdatePacket);
			}
			break;
		case 6:
			if(src_MarbleGame.instance.world != null && !src_MarbleGame.instance.world._disposed) {
				let movePacket = new net_MarbleMovePacket();
				movePacket.clientId = input.readByte();
				movePacket.clientTicks = input.readUInt16();
				let count = input.readInt(5);
				movePacket.moves = [];
				let _g = 0;
				let _g1 = count;
				while(_g < _g1) {
					_g++;
					let movePacket1 = movePacket.moves;
					let moveId = input.readUInt16();
					let move = new net_Move();
					move.d = new h3d_Vector();
					let tmp = input.readByte() - 16;
					move.d.x = tmp / 16.0;
					let tmp1 = input.readByte() - 16;
					move.d.y = tmp1 / 16.0;
					move.jump = input.readFlag();
					move.powerup = input.readFlag();
					move.blast = input.readFlag();
					let motionDir = new h3d_Vector();
					motionDir.x = input.readFloat();
					motionDir.y = input.readFloat();
					motionDir.z = input.readFloat();
					let netMove = new net_NetMove(move,motionDir,src_MarbleGame.instance.world.timeState.clone(),0,moveId);
					movePacket1.push(netMove);
				}
				let cc = net_Net.clientIdMap.h[movePacket.clientId];
				if(cc.state == 2) {
					let _g = 0;
					let _g1 = movePacket.moves;
					while(_g < _g1.length) {
						let move = _g1[_g];
						++_g;
						cc.queueMove(move);
					}
				}
			}
			break;
		case 7:
			let powerupPickupPacket = new net_PowerupPickupPacket();
			powerupPickupPacket.clientId = input.readByte();
			powerupPickupPacket.serverTicks = input.readUInt16();
			powerupPickupPacket.powerupItemId = input.readInt(10);
			if(src_MarbleGame.instance.world != null && !src_MarbleGame.instance.world._disposed) {
				let m = src_MarbleGame.instance.world.powerupPredictions;
				m.predictions[powerupPickupPacket.powerupItemId] = src_MarbleGame.instance.world.timeState.currentAttemptTime - net_Net.clientConnection.moveManager.queuedMoves.length * 0.032;
			}
			break;
		case 8:
			let gemSpawnPacket = new net_GemSpawnPacket();
			gemSpawnPacket.deserialize(input);
			if(src_MarbleGame.instance.world != null && !src_MarbleGame.instance.world._disposed) {
				src_MarbleGame.instance.world.spawnHuntGemsClientSide(gemSpawnPacket.gemIds);
				let _this = src_MarbleGame.instance.world.gemPredictions;
				let _g = 0;
				let _g1 = gemSpawnPacket.gemIds;
				while(_g < _g1.length) {
					let gemId = _g1[_g];
					++_g;
					_this.predictions[gemId] = false;
				}
			}
			break;
		case 9:
			let gemPickupPacket = new net_GemPickupPacket();
			gemPickupPacket.clientId = input.readByte();
			gemPickupPacket.serverTicks = input.readUInt16();
			gemPickupPacket.gemId = input.readInt(11);
			gemPickupPacket.scoreIncr = input.readInt(4);
			if(src_MarbleGame.instance.world != null && !src_MarbleGame.instance.world._disposed) {
				src_MarbleGame.instance.world.playGui.incrementPlayerScore(gemPickupPacket.clientId,gemPickupPacket.scoreIncr);
				src_MarbleGame.instance.world.gemPredictions.predictions[gemPickupPacket.gemId] = true;
			}
			break;
		case 10:
			let count = input.readByte();
			let newP = false;
			let _g = 0;
			let _g1 = count;
			while(_g < _g1) {
				_g++;
				let id = input.readByte();
				let cready = input.readByte() == 1;
				let platform = input.readByte();
				let marble = input.readByte();
				if(id != 0 && id != net_Net.clientId && !net_Net.clientIdMap.h.hasOwnProperty(id)) {
					src_Console.instance.addEntry("log","Adding ghost connection " + id);
					net_Net.addGhost(id);
					newP = true;
				}
				let nameLength = input.readByte();
				let name = "";
				let _g1 = 0;
				let _g2 = nameLength;
				while(_g1 < _g2) {
					_g1++;
					let code = input.readByte();
					name += String.fromCodePoint(code);
				}
				if(net_Net.clientIdMap.h.hasOwnProperty(id)) {
					net_Net.clientIdMap.h[id].name = name;
					net_Net.clientIdMap.h[id].marbleId = marble;
					net_Net.clientIdMap.h[id].lobbyReady = cready;
					net_Net.clientIdMap.h[id].platform = platform;
				}
				if(net_Net.clientId == id) {
					net_Net.lobbyClientReady = cready;
				}
			}
			if(((src_MarbleGame.canvas.content) instanceof gui_MultiplayerLevelSelectGui)) {
				(js_Boot.__cast(src_MarbleGame.canvas.content , gui_MultiplayerLevelSelectGui)).updateLobbyNames();
			}
			break;
		case 11:
			let scoreboardPacket = new net_ScoreboardPacket();
			let count1 = input.readInt(4);
			let _g2 = 0;
			let _g3 = count1;
			while(_g2 < _g3) {
				_g2++;
				let this1 = scoreboardPacket.scoreBoard;
				let k = input.readInt(6);
				let v = input.readInt(10);
				this1.h[k] = v;
			}
			if(src_MarbleGame.instance.world != null && !src_MarbleGame.instance.world._disposed) {
				src_MarbleGame.instance.world.playGui.updatePlayerScores(scoreboardPacket);
			}
			break;
		default:
			src_Console.instance.addEntry("log","unknown command: " + packetType);
		}
	}
	static allocateClientId() {
		let _g = 0;
		while(_g < 32) {
			let id = _g++;
			if((net_Net.clientIdAllocs & 1 << id) == 0) {
				net_Net.clientIdAllocs |= 1 << id;
				return id;
			}
		}
		return -1;
	}
	static freeClientId(id) {
		net_Net.clientIdAllocs &= ~(1 << id);
	}
	static sendPacketToAll(packetData) {
		let bytes = packetData.getBytes();
		let this1 = net_Net.clients;
		let _g_keys = this1.keys();
		while(_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = this1.get(key);
			_g_value.sendBytes(bytes);
		}
	}
	static sendPacketToIngame(packetData) {
		let bytes = packetData.getBytes();
		let this1 = net_Net.clients;
		let _g_keys = this1.keys();
		while(_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = this1.get(key);
			if(_g_value.state == 2) {
				_g_value.sendBytes(bytes);
			}
		}
	}
	static sendPacketToHost(packetData) {
		if(net_Net.clientDatachannel.state == datachannel_RTCDataChannelState.Open) {
			let bytes = packetData.getBytes();
			net_Net.clientDatachannel.sendBytes(bytes);
		}
	}
	static sendPacketToHostUnreliable(packetData) {
		if(net_Net.clientDatachannelUnreliable.state == datachannel_RTCDataChannelState.Open) {
			let bytes = packetData.getBytes();
			net_Net.clientDatachannelUnreliable.sendBytes(bytes);
		}
	}
	static sendPacketToClient(client,packetData) {
		let bytes = packetData.getBytes();
		client.sendBytes(bytes);
	}
	static addDummyConnection() {
		if(net_Net.isHost) {
			net_Net.addGhost(net_Net.clientId++);
		}
	}
}
$hxClasses["net.Net"] = net_Net;
net_Net.__name__ = "net.Net";
class net_NetCommands {
	static setLobbyLevelIndex(i) {
		if(gui_MultiplayerLevelSelectGui.setLevelFn == null) {
			gui_MultiplayerLevelSelectGui.currentSelectionStatic = i;
		} else {
			gui_MultiplayerLevelSelectGui.setLevelFn(i);
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(1);
			stream.writeInt32(i);
			net_Net.sendPacketToAll(stream);
		}
	}
	static setLobbyCustLevelName(str) {
		if(gui_MultiplayerLevelSelectGui.setLevelFn != null) {
			gui_MultiplayerLevelSelectGui.setLevelStr(str);
		} else {
			gui_MultiplayerLevelSelectGui.custSelected = true;
			gui_MultiplayerLevelSelectGui.custPath = str;
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(2);
			stream.writeString(str);
			net_Net.sendPacketToAll(stream);
		}
	}
	static playLevel(levelIndex) {
		gui_MultiplayerLevelSelectGui.playSelectedLevel(levelIndex);
		if(net_Net.isHost) {
			net_Net.serverInfo.state = "WAITING";
			net_MasterServerClient.instance.sendServerInfo(net_Net.serverInfo);
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(3);
			stream.writeInt32(levelIndex);
			net_Net.sendPacketToAll(stream);
		}
	}
	static playCustomLevel(levelPath) {
		let _this = MPCustoms.missionList;
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this.length) {
			let v = _this[_g1];
			++_g1;
			if(v.path == levelPath) {
				_g.push(v);
			}
		}
		let levelEntry = _g[0];
		src_MarbleGame.canvas.setContent(new gui_MultiplayerLoadingGui("Downloading",false));
		MPCustoms.play(levelEntry,function() {
		},function() {
			src_MarbleGame.canvas.setContent(new gui_MultiplayerGui());
			net_Net.disconnect();
		});
		if(net_Net.isHost) {
			net_Net.serverInfo.state = "WAITING";
			net_MasterServerClient.instance.sendServerInfo(net_Net.serverInfo);
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(4);
			stream.writeString(levelPath);
			net_Net.sendPacketToAll(stream);
		}
	}
	static playLevelMidJoin(index) {
		if(net_Net.isClient) {
			let difficultyMissions = src_MissionList.missionList.h["ultra"].h["multiplayer"];
			let curMission = difficultyMissions[index];
			src_MarbleGame.instance.playMission(curMission,true);
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(5);
			stream.writeInt32(index);
			net_Net.sendPacketToAll(stream);
		}
	}
	static playCustomLevelMidJoin(path) {
		if(net_Net.isClient) {
			net_NetCommands.playCustomLevel(path);
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(6);
			stream.writeString(path);
			net_Net.sendPacketToAll(stream);
		}
	}
	static enterLobby() {
		if(net_Net.isClient) {
			src_MarbleGame.canvas.setContent(new gui_MultiplayerLevelSelectGui(false));
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(7);
			net_Net.sendPacketToAll(stream);
		}
	}
	static setNetworkRNG(rng) {
		net_Net.networkRNG = rng;
		if(src_MarbleGame.instance.world != null) {
			let gameMode = src_MarbleGame.instance.world.gameMode;
			if(((gameMode) instanceof modes_HuntMode)) {
				let hunt = gameMode;
				hunt.rng.setSeed(rng);
				hunt.rng2.setSeed(rng);
			}
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(8);
			stream.writeFloat(rng);
			net_Net.sendPacketToAll(stream);
		}
	}
	static toggleReadiness(clientId) {
		if(net_Net.isHost) {
			if(clientId == 0) {
				net_Net.lobbyHostReady = !net_Net.lobbyHostReady;
			} else {
				net_Net.clientIdMap.h[clientId].toggleLobbyReady();
			}
			let allReady = true;
			let this1 = net_Net.clientIdMap;
			let _g_keys = this1.keys();
			while(_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = this1.get(key);
				if(!_g_value.lobbyReady) {
					allReady = false;
					break;
				}
			}
			if(((src_MarbleGame.canvas.content) instanceof gui_MultiplayerLevelSelectGui)) {
				(js_Boot.__cast(src_MarbleGame.canvas.content , gui_MultiplayerLevelSelectGui)).updateLobbyNames();
			}
			let b = net_Net.sendPlayerInfosBytes();
			let cc = net_Net.clients.iterator();
			while(cc.hasNext()) {
				let cc1 = cc.next();
				cc1.sendBytes(b);
			}
			if(allReady && net_Net.lobbyHostReady) {
				if(gui_MultiplayerLevelSelectGui.custSelected) {
					net_NetCommands.playCustomLevel(gui_MultiplayerLevelSelectGui.custPath);
				} else {
					net_NetCommands.playLevel(gui_MultiplayerLevelSelectGui.currentSelectionStatic);
				}
			}
		}
		if(!net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(9);
			stream.writeInt32(clientId);
			net_Net.sendPacketToHost(stream);
		}
	}
	static clientIsReady(clientId) {
		if(net_Net.isHost) {
			if(net_Net.serverInfo.state == "WAITING") {
				src_Console.instance.addEntry("log","Client " + clientId + " is ready!");
				if(clientId != -1) {
					net_Net.clientIdMap.h[clientId].ready();
				} else {
					net_Net.hostReady = true;
				}
				let allReady = true;
				let this1 = net_Net.clientIdMap;
				let _g_keys = this1.keys();
				while(_g_keys.hasNext()) {
					let key = _g_keys.next();
					let _g_value = this1.get(key);
					if(_g_value.state != 2) {
						allReady = false;
						break;
					}
				}
				if(allReady && net_Net.hostReady) {
					if(src_MarbleGame.instance.world != null) {
						src_Console.instance.addEntry("log","All are ready, starting");
						src_MarbleGame.instance.world.allClientsReady();
					}
					net_Net.serverInfo.state = "PLAYING";
					net_MasterServerClient.instance.sendServerInfo(net_Net.serverInfo);
				}
			} else {
				src_Console.instance.addEntry("log","Mid game join for client " + clientId);
				if(src_MarbleGame.instance.world != null) {
					let packets = src_MarbleGame.instance.world.getWorldStateForClientJoin();
					let c = net_Net.clientIdMap.h[clientId];
					let _g = 0;
					while(_g < packets.length) {
						let packet = packets[_g];
						++_g;
						c.sendBytes(packet);
					}
					net_Net.clientIdMap.h[clientId].ready();
					if(src_MarbleGame.instance.world.serverStartTicks == 0) {
						let allReady = true;
						let this1 = net_Net.clientIdMap;
						let _g_keys = this1.keys();
						while(_g_keys.hasNext()) {
							let key = _g_keys.next();
							let _g_value = this1.get(key);
							if(_g_value.state != 2) {
								allReady = false;
								break;
							}
						}
						if(allReady) {
							if(src_MarbleGame.instance.world != null) {
								src_MarbleGame.instance.world.allClientsReady();
							}
						}
					} else {
						net_NetCommands.setStartTicksMidJoinClient(c,src_MarbleGame.instance.world.serverStartTicks,src_MarbleGame.instance.world.timeState.ticks);
					}
				}
			}
		}
		if(!net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(10);
			stream.writeInt32(clientId);
			net_Net.sendPacketToHost(stream);
		}
	}
	static addMidGameJoinMarble(cc) {
		if(net_Net.isClient) {
			if(src_MarbleGame.instance.world != null) {
				src_MarbleGame.instance.world.addJoiningClientGhost(net_Net.clientIdMap.h[cc],function() {
				});
			}
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(11);
			stream.writeInt32(cc);
			net_Net.sendPacketToAll(stream);
		}
	}
	static setStartTicks(ticks) {
		if(src_MarbleGame.instance.world != null) {
			src_MarbleGame.instance.world.serverStartTicks = ticks + 1;
			if(net_Net.isClient) {
				src_MarbleGame.instance.world.marble.serverTicks = ticks;
			}
			src_MarbleGame.instance.world.startTime = src_MarbleGame.instance.world.timeState.timeSinceLoad + 3.5 + 0.032;
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(12);
			stream.writeInt32(ticks);
			net_Net.sendPacketToAll(stream);
		}
	}
	static setStartTicksMidJoin(startTicks,currentTicks) {
		if(src_MarbleGame.instance.world != null) {
			src_MarbleGame.instance.world.serverStartTicks = startTicks + 1;
			src_MarbleGame.instance.world.startTime = src_MarbleGame.instance.world.timeState.timeSinceLoad + 0.032;
			src_MarbleGame.instance.world.timeState.ticks = currentTicks;
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(13);
			stream.writeInt32(startTicks);
			stream.writeInt32(currentTicks);
			net_Net.sendPacketToAll(stream);
		}
	}
	static timerRanOut() {
		if(net_Net.isClient && src_MarbleGame.instance.world != null) {
			if(src_MarbleGame.instance.paused) {
				src_MarbleGame.instance.handlePauseGame();
			}
			let huntMode = src_MarbleGame.instance.world.gameMode;
			huntMode.onTimeExpire();
		}
		if(net_Net.isHost) {
			net_Net.serverInfo.state = "WAITING";
			net_MasterServerClient.instance.sendServerInfo(net_Net.serverInfo);
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(14);
			net_Net.sendPacketToAll(stream);
		}
	}
	static clientDisconnected(clientId) {
		let conn = net_Net.clientIdMap.h[clientId];
		if(src_MarbleGame.instance.world != null) {
			src_MarbleGame.instance.world.removePlayer(conn);
			let allReady = true;
			let this1 = net_Net.clientIdMap;
			let _g_keys = this1.keys();
			while(_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = this1.get(key);
				if(_g_value.state != 2 && _g_value != conn) {
					allReady = false;
					break;
				}
			}
			if(allReady && src_MarbleGame.instance.world.serverStartTicks == 0) {
				src_MarbleGame.instance.world.allClientsReady();
			}
		}
		net_Net.clientIdMap.remove(clientId);
		if(((src_MarbleGame.canvas.content) instanceof gui_MultiplayerLevelSelectGui)) {
			(js_Boot.__cast(src_MarbleGame.canvas.content , gui_MultiplayerLevelSelectGui)).updateLobbyNames();
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(15);
			stream.writeInt32(clientId);
			net_Net.sendPacketToAll(stream);
		}
	}
	static clientJoin(clientId) {
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(16);
			stream.writeInt32(clientId);
			net_Net.sendPacketToAll(stream);
		}
	}
	static clientLeave(clientId) {
		if(net_Net.isHost) {
			net_Net.onClientLeave(net_Net.clientIdMap.h[clientId]);
		}
		if(!net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(17);
			stream.writeInt32(clientId);
			net_Net.sendPacketToHost(stream);
		}
	}
	static serverClosed() {
		if(net_Net.isClient) {
			if(src_MarbleGame.instance.world != null) {
				src_MarbleGame.instance.quitMission();
			}
			let loadGui = new gui_MultiplayerLoadingGui("Server closed");
			src_MarbleGame.canvas.setContent(loadGui);
			loadGui.setErrorStatus("Server closed");
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(18);
			net_Net.sendPacketToAll(stream);
		}
	}
	static setPlayerData(clientId,name,marble) {
		if(net_Net.isHost) {
			net_Net.clientIdMap.h[clientId].name = name;
			net_Net.clientIdMap.h[clientId].marbleId = marble;
			if(((src_MarbleGame.canvas.content) instanceof gui_MultiplayerLevelSelectGui)) {
				(js_Boot.__cast(src_MarbleGame.canvas.content , gui_MultiplayerLevelSelectGui)).updateLobbyNames();
			}
		}
		if(!net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(19);
			stream.writeInt32(clientId);
			stream.writeString(name);
			stream.writeInt32(marble);
			net_Net.sendPacketToHost(stream);
		}
	}
	static transmitPlatform(clientId,platform) {
		if(net_Net.isHost) {
			net_Net.clientIdMap.h[clientId].platform = platform;
			if(((src_MarbleGame.canvas.content) instanceof gui_MultiplayerLevelSelectGui)) {
				(js_Boot.__cast(src_MarbleGame.canvas.content , gui_MultiplayerLevelSelectGui)).updateLobbyNames();
			}
		}
		if(!net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(20);
			stream.writeInt32(clientId);
			stream.writeInt32(platform);
			net_Net.sendPacketToHost(stream);
		}
	}
	static endGame() {
		let this1 = net_Net.clientIdMap;
		let _g_keys = this1.keys();
		while(_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = this1.get(key);
			_g_value.state = 1;
			_g_value.lobbyReady = false;
		}
		if(net_Net.isClient) {
			if(src_MarbleGame.instance.world != null) {
				src_MarbleGame.instance.quitMission();
			}
		}
		if(net_Net.isHost) {
			net_Net.lobbyHostReady = false;
			net_Net.hostReady = false;
			net_Net.serverInfo.state = "LOBBY";
			net_MasterServerClient.instance.sendServerInfo(net_Net.serverInfo);
			let b = net_Net.sendPlayerInfosBytes();
			let cc = net_Net.clients.iterator();
			while(cc.hasNext()) {
				let cc1 = cc.next();
				cc1.sendBytes(b);
			}
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(21);
			net_Net.sendPacketToAll(stream);
		}
	}
	static restartGame() {
		let world = src_MarbleGame.instance.world;
		if(net_Net.isHost) {
			world.startTime = 1e8;
			haxe_Timer.delay(function() {
				world.allClientsReady();
			},1500);
		}
		if(net_Net.isClient) {
			let gui = src_MarbleGame.canvas.children[src_MarbleGame.canvas.children.length - 1];
			if(((gui) instanceof gui_EndGameGui)) {
				let egg = js_Boot.__cast(gui , gui_EndGameGui);
				egg.retryFunc(null);
				world.restartMultiplayerState();
			}
		}
		world.multiplayerStarted = false;
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(22);
			net_Net.sendPacketToAll(stream);
		}
	}
	static ping(sendTime) {
		if(net_Net.isClient) {
			net_NetCommands.pingBack(HxOverrides.now() / 1000 - sendTime);
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(23);
			stream.writeFloat(sendTime);
			net_Net.sendPacketToAll(stream);
		}
	}
	static pingBack(ping) {
		if(!net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(24);
			stream.writeFloat(ping);
			net_Net.sendPacketToHost(stream);
		}
	}
	static requestPing() {
		if(net_Net.isHost) {
			net_NetCommands.ping(HxOverrides.now() / 1000);
		}
		if(!net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(25);
			net_Net.sendPacketToHost(stream);
		}
	}
	static sendChatMessage(msg) {
		if(net_Net.isHost) {
			net_NetCommands.sendServerChatMessage(msg);
		}
		if(!net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(26);
			stream.writeString(msg);
			net_Net.sendPacketToHost(stream);
		}
	}
	static sendServerChatMessage(msg) {
		if(src_MarbleGame.instance.world != null) {
			if(src_MarbleGame.instance.world._ready) {
				src_MarbleGame.instance.world.playGui.chatCtrl.addChatMessage(msg);
			}
		} else if(((src_MarbleGame.canvas.content) instanceof gui_MultiplayerLevelSelectGui)) {
			(js_Boot.__cast(src_MarbleGame.canvas.content , gui_MultiplayerLevelSelectGui)).addChatMessage(msg);
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(27);
			stream.writeString(msg);
			net_Net.sendPacketToAll(stream);
		}
	}
	static readPacket(stream) {
		let fnId = stream.readByte();
		switch(fnId) {
		case 1:
			let i = stream.readInt32();
			net_NetCommands.setLobbyLevelIndex(i);
			break;
		case 2:
			let str = stream.readString();
			net_NetCommands.setLobbyCustLevelName(str);
			break;
		case 3:
			let levelIndex = stream.readInt32();
			net_NetCommands.playLevel(levelIndex);
			break;
		case 4:
			let levelPath = stream.readString();
			net_NetCommands.playCustomLevel(levelPath);
			break;
		case 5:
			let index = stream.readInt32();
			net_NetCommands.playLevelMidJoin(index);
			break;
		case 6:
			let path = stream.readString();
			net_NetCommands.playCustomLevelMidJoin(path);
			break;
		case 7:
			net_NetCommands.enterLobby();
			break;
		case 8:
			let rng = stream.readFloat();
			net_NetCommands.setNetworkRNG(rng);
			break;
		case 9:
			let clientId = stream.readInt32();
			net_NetCommands.toggleReadiness(clientId);
			break;
		case 10:
			let clientId1 = stream.readInt32();
			net_NetCommands.clientIsReady(clientId1);
			break;
		case 11:
			let cc = stream.readInt32();
			net_NetCommands.addMidGameJoinMarble(cc);
			break;
		case 12:
			let ticks = stream.readInt32();
			net_NetCommands.setStartTicks(ticks);
			break;
		case 13:
			let startTicks = stream.readInt32();
			let currentTicks = stream.readInt32();
			net_NetCommands.setStartTicksMidJoin(startTicks,currentTicks);
			break;
		case 14:
			net_NetCommands.timerRanOut();
			break;
		case 15:
			let clientId2 = stream.readInt32();
			net_NetCommands.clientDisconnected(clientId2);
			break;
		case 16:
			let clientId3 = stream.readInt32();
			net_NetCommands.clientJoin(clientId3);
			break;
		case 17:
			let clientId4 = stream.readInt32();
			net_NetCommands.clientLeave(clientId4);
			break;
		case 18:
			net_NetCommands.serverClosed();
			break;
		case 19:
			let clientId5 = stream.readInt32();
			let name = stream.readString();
			let marble = stream.readInt32();
			net_NetCommands.setPlayerData(clientId5,name,marble);
			break;
		case 20:
			let clientId6 = stream.readInt32();
			let platform = stream.readInt32();
			net_NetCommands.transmitPlatform(clientId6,platform);
			break;
		case 21:
			net_NetCommands.endGame();
			break;
		case 22:
			net_NetCommands.restartGame();
			break;
		case 23:
			let sendTime = stream.readFloat();
			net_NetCommands.ping(sendTime);
			break;
		case 24:
			let ping = stream.readFloat();
			net_NetCommands.pingBack(ping);
			break;
		case 25:
			net_NetCommands.requestPing();
			break;
		case 26:
			let msg = stream.readString();
			net_NetCommands.sendChatMessage(msg);
			break;
		case 27:
			let msg1 = stream.readString();
			net_NetCommands.sendServerChatMessage(msg1);
			break;
		}
	}
	static setLobbyLevelIndexClient(client,i) {
		if(gui_MultiplayerLevelSelectGui.setLevelFn == null) {
			gui_MultiplayerLevelSelectGui.currentSelectionStatic = i;
		} else {
			gui_MultiplayerLevelSelectGui.setLevelFn(i);
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(1);
			stream.writeInt32(i);
			net_Net.sendPacketToClient(client,stream);
		}
	}
	static setLobbyCustLevelNameClient(client,str) {
		if(gui_MultiplayerLevelSelectGui.setLevelFn != null) {
			gui_MultiplayerLevelSelectGui.setLevelStr(str);
		} else {
			gui_MultiplayerLevelSelectGui.custSelected = true;
			gui_MultiplayerLevelSelectGui.custPath = str;
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(2);
			stream.writeString(str);
			net_Net.sendPacketToClient(client,stream);
		}
	}
	static playLevelMidJoinClient(client,index) {
		if(net_Net.isClient) {
			let difficultyMissions = src_MissionList.missionList.h["ultra"].h["multiplayer"];
			let curMission = difficultyMissions[index];
			src_MarbleGame.instance.playMission(curMission,true);
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(5);
			stream.writeInt32(index);
			net_Net.sendPacketToClient(client,stream);
		}
	}
	static playCustomLevelMidJoinClient(client,path) {
		if(net_Net.isClient) {
			net_NetCommands.playCustomLevel(path);
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(6);
			stream.writeString(path);
			net_Net.sendPacketToClient(client,stream);
		}
	}
	static enterLobbyClient(client) {
		if(net_Net.isClient) {
			src_MarbleGame.canvas.setContent(new gui_MultiplayerLevelSelectGui(false));
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(7);
			net_Net.sendPacketToClient(client,stream);
		}
	}
	static addMidGameJoinMarbleClient(client,cc) {
		if(net_Net.isClient) {
			if(src_MarbleGame.instance.world != null) {
				src_MarbleGame.instance.world.addJoiningClientGhost(net_Net.clientIdMap.h[cc],function() {
				});
			}
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(11);
			stream.writeInt32(cc);
			net_Net.sendPacketToClient(client,stream);
		}
	}
	static setStartTicksMidJoinClient(client,startTicks,currentTicks) {
		if(src_MarbleGame.instance.world != null) {
			src_MarbleGame.instance.world.serverStartTicks = startTicks + 1;
			src_MarbleGame.instance.world.startTime = src_MarbleGame.instance.world.timeState.timeSinceLoad + 0.032;
			src_MarbleGame.instance.world.timeState.ticks = currentTicks;
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(13);
			stream.writeInt32(startTicks);
			stream.writeInt32(currentTicks);
			net_Net.sendPacketToClient(client,stream);
		}
	}
	static pingClient(client,sendTime) {
		if(net_Net.isClient) {
			net_NetCommands.pingBack(HxOverrides.now() / 1000 - sendTime);
		}
		if(net_Net.isHost) {
			let stream = new net_OutputBitStream();
			stream.writeByte(2);
			stream.writeByte(23);
			stream.writeFloat(sendTime);
			net_Net.sendPacketToClient(client,stream);
		}
	}
}
$hxClasses["net.NetCommands"] = net_NetCommands;
net_NetCommands.__name__ = "net.NetCommands";
class net_NetPacket {
}
$hxClasses["net.NetPacket"] = net_NetPacket;
net_NetPacket.__name__ = "net.NetPacket";
net_NetPacket.__isInterface__ = true;
class net_MarbleMovePacket {
	constructor() {
		this.moves = [];
	}
}
$hxClasses["net.MarbleMovePacket"] = net_MarbleMovePacket;
net_MarbleMovePacket.__name__ = "net.MarbleMovePacket";
net_MarbleMovePacket.__interfaces__ = [net_NetPacket];
Object.assign(net_MarbleMovePacket.prototype, {
	__class__: net_MarbleMovePacket
	,clientId: null
	,clientTicks: null
	,moves: null
});
class net_MarbleUpdatePacket {
	constructor() {
		this.calculationTicks = -1;
	}
}
$hxClasses["net.MarbleUpdatePacket"] = net_MarbleUpdatePacket;
net_MarbleUpdatePacket.__name__ = "net.MarbleUpdatePacket";
net_MarbleUpdatePacket.__interfaces__ = [net_NetPacket];
Object.assign(net_MarbleUpdatePacket.prototype, {
	__class__: net_MarbleUpdatePacket
	,clientId: null
	,move: null
	,serverTicks: null
	,calculationTicks: null
	,position: null
	,velocity: null
	,omega: null
	,lastContactNormal: null
	,blastAmount: null
	,blastTick: null
	,megaTick: null
	,heliTick: null
	,gravityDirection: null
	,oob: null
	,powerUpId: null
	,moveQueueSize: null
	,netFlags: null
});
class net_PowerupPickupPacket {
	constructor() {
	}
}
$hxClasses["net.PowerupPickupPacket"] = net_PowerupPickupPacket;
net_PowerupPickupPacket.__name__ = "net.PowerupPickupPacket";
net_PowerupPickupPacket.__interfaces__ = [net_NetPacket];
Object.assign(net_PowerupPickupPacket.prototype, {
	__class__: net_PowerupPickupPacket
	,clientId: null
	,serverTicks: null
	,powerupItemId: null
});
class net_GemSpawnPacket {
	constructor() {
		this.gemIds = [];
	}
	serialize(b) {
		b.writeInt(this.gemIds.length,5);
		let _g = 0;
		let _g1 = this.gemIds;
		while(_g < _g1.length) {
			let gemId = _g1[_g];
			++_g;
			b.writeInt(gemId,11);
		}
	}
	deserialize(b) {
		let count = b.readInt(5);
		let _g = 0;
		while(_g < count) {
			++_g;
			this.gemIds.push(b.readInt(11));
		}
	}
}
$hxClasses["net.GemSpawnPacket"] = net_GemSpawnPacket;
net_GemSpawnPacket.__name__ = "net.GemSpawnPacket";
net_GemSpawnPacket.__interfaces__ = [net_NetPacket];
Object.assign(net_GemSpawnPacket.prototype, {
	__class__: net_GemSpawnPacket
	,gemIds: null
});
class net_GemPickupPacket {
	constructor() {
	}
}
$hxClasses["net.GemPickupPacket"] = net_GemPickupPacket;
net_GemPickupPacket.__name__ = "net.GemPickupPacket";
net_GemPickupPacket.__interfaces__ = [net_NetPacket];
Object.assign(net_GemPickupPacket.prototype, {
	__class__: net_GemPickupPacket
	,clientId: null
	,serverTicks: null
	,gemId: null
	,scoreIncr: null
});
class net_ScoreboardPacket {
	constructor() {
		this.scoreBoard = new haxe_ds_IntMap();
	}
}
$hxClasses["net.ScoreboardPacket"] = net_ScoreboardPacket;
net_ScoreboardPacket.__name__ = "net.ScoreboardPacket";
net_ScoreboardPacket.__interfaces__ = [net_NetPacket];
Object.assign(net_ScoreboardPacket.prototype, {
	__class__: net_ScoreboardPacket
	,scoreBoard: null
});
class net_PowerupPredictionStore {
	constructor() {
		this.predictions = [];
	}
}
$hxClasses["net.PowerupPredictionStore"] = net_PowerupPredictionStore;
net_PowerupPredictionStore.__name__ = "net.PowerupPredictionStore";
Object.assign(net_PowerupPredictionStore.prototype, {
	__class__: net_PowerupPredictionStore
	,predictions: null
});
class net_Uuid {
	static splitmix64_seed(index) {
		let b_high = -1640531527;
		let b_low = 2135587861;
		let high = index.high + b_high | 0;
		let low = index.low + b_low | 0;
		if(haxe_Int32.ucompare(low,index.low) < 0) {
			++high;
			high = high | 0;
		}
		let result = new haxe__$Int64__$_$_$Int64(high,low);
		let b = new haxe__$Int64__$_$_$Int64(result.high >> 30,result.high << 2 | result.low >>> 30);
		let high1 = result.high ^ b.high;
		let low1 = result.low ^ b.low;
		let b_high1 = -1084733587;
		let b_low1 = 484763065;
		let al = low1 & 65535;
		let ah = low1 >>> 16;
		let bl = b_low1 & 65535;
		let bh = b_low1 >>> 16;
		let p00 = haxe_Int32._mul(al,bl);
		let p10 = haxe_Int32._mul(ah,bl);
		let p01 = haxe_Int32._mul(al,bh);
		let p11 = haxe_Int32._mul(ah,bh);
		let low2 = p00;
		let high2 = (p11 + (p01 >>> 16) | 0) + (p10 >>> 16) | 0;
		p01 <<= 16;
		low2 = p00 + p01 | 0;
		if(haxe_Int32.ucompare(low2,p01) < 0) {
			++high2;
			high2 = high2 | 0;
		}
		p10 <<= 16;
		low2 = low2 + p10 | 0;
		if(haxe_Int32.ucompare(low2,p10) < 0) {
			++high2;
			high2 = high2 | 0;
		}
		high2 = high2 + (haxe_Int32._mul(low1,b_high1) + haxe_Int32._mul(high1,b_low1) | 0) | 0;
		result = new haxe__$Int64__$_$_$Int64(high2,low2);
		let b1 = new haxe__$Int64__$_$_$Int64(result.high >> 27,result.high << 5 | result.low >>> 27);
		let high3 = result.high ^ b1.high;
		let low3 = result.low ^ b1.low;
		let b_high2 = -1798288965;
		let b_low2 = 321982955;
		let al1 = low3 & 65535;
		let ah1 = low3 >>> 16;
		let bl1 = b_low2 & 65535;
		let bh1 = b_low2 >>> 16;
		let p001 = haxe_Int32._mul(al1,bl1);
		let p101 = haxe_Int32._mul(ah1,bl1);
		let p011 = haxe_Int32._mul(al1,bh1);
		let p111 = haxe_Int32._mul(ah1,bh1);
		let low4 = p001;
		let high4 = (p111 + (p011 >>> 16) | 0) + (p101 >>> 16) | 0;
		p011 <<= 16;
		low4 = p001 + p011 | 0;
		if(haxe_Int32.ucompare(low4,p011) < 0) {
			++high4;
			high4 = high4 | 0;
		}
		p101 <<= 16;
		low4 = low4 + p101 | 0;
		if(haxe_Int32.ucompare(low4,p101) < 0) {
			++high4;
			high4 = high4 | 0;
		}
		high4 = high4 + (haxe_Int32._mul(low3,b_high2) + haxe_Int32._mul(high3,b_low2) | 0) | 0;
		result = new haxe__$Int64__$_$_$Int64(high4,low4);
		let b2 = new haxe__$Int64__$_$_$Int64(result.high >> 31,result.high << 1 | result.low >>> 31);
		return new haxe__$Int64__$_$_$Int64(result.high ^ b2.high,result.low ^ b2.low);
	}
	static randomFromRange(min,max) {
		let s1 = net_Uuid.state0;
		let s0 = net_Uuid.state1;
		net_Uuid.state0 = s0;
		let b = new haxe__$Int64__$_$_$Int64(s1.high << 23 | s1.low >>> 9,s1.low << 23);
		s1 = new haxe__$Int64__$_$_$Int64(s1.high ^ b.high,s1.low ^ b.low);
		let b1 = new haxe__$Int64__$_$_$Int64(s1.high >>> 18,s1.high << 14 | s1.low >>> 18);
		let b2 = new haxe__$Int64__$_$_$Int64(s0.high >>> 5,s0.high << 27 | s0.low >>> 5);
		net_Uuid.state1 = new haxe__$Int64__$_$_$Int64(s1.high ^ s0.high ^ b1.high ^ b2.high,s1.low ^ s0.low ^ b1.low ^ b2.low);
		let a = net_Uuid.state1;
		let high = a.high + s0.high | 0;
		let low = a.low + s0.low | 0;
		if(haxe_Int32.ucompare(low,a.low) < 0) {
			++high;
			high = high | 0;
		}
		let x = max - min + 1;
		let result = haxe_Int64.divMod(new haxe__$Int64__$_$_$Int64(high,low),new haxe__$Int64__$_$_$Int64(x >> 31,x)).modulus.low;
		if(result < 0) {
			result = -result;
		}
		return result + min;
	}
	static randomByte() {
		return net_Uuid.randomFromRange(0,255);
	}
	static toShort(uuid,separator,toAlphabet) {
		if(toAlphabet == null) {
			toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
		}
		if(separator == null) {
			separator = "-";
		}
		uuid = StringTools.replace(uuid,separator,"").toLowerCase();
		return net_Uuid.convert(uuid,"0123456789abcdef",toAlphabet);
	}
	static v4(randBytes,randomFunc,separator,shortUuid,toAlphabet) {
		if(toAlphabet == null) {
			toAlphabet = "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ";
		}
		if(shortUuid == null) {
			shortUuid = false;
		}
		if(separator == null) {
			separator = "-";
		}
		if(randomFunc == null) {
			randomFunc = net_Uuid.randomByte;
		}
		let buffer = randBytes;
		if(randBytes == null) {
			buffer = new haxe_io_Bytes(new ArrayBuffer(16));
			let v = randomFunc();
			buffer.b[0] = v;
			let v1 = randomFunc();
			buffer.b[1] = v1;
			let v2 = randomFunc();
			buffer.b[2] = v2;
			let v3 = randomFunc();
			buffer.b[3] = v3;
			let v4 = randomFunc();
			buffer.b[4] = v4;
			let v5 = randomFunc();
			buffer.b[5] = v5;
			let v6 = randomFunc();
			buffer.b[6] = v6;
			let v7 = randomFunc();
			buffer.b[7] = v7;
			let v8 = randomFunc();
			buffer.b[8] = v8;
			let v9 = randomFunc();
			buffer.b[9] = v9;
			let v10 = randomFunc();
			buffer.b[10] = v10;
			let v11 = randomFunc();
			buffer.b[11] = v11;
			let v12 = randomFunc();
			buffer.b[12] = v12;
			let v13 = randomFunc();
			buffer.b[13] = v13;
			let v14 = randomFunc();
			buffer.b[14] = v14;
			let v15 = randomFunc();
			buffer.b[15] = v15;
		} else if(randBytes.length < 16) {
			throw haxe_Exception.thrown("Random bytes should be at least 16 bytes");
		}
		buffer.b[6] = buffer.b[6] & 15 | 64;
		buffer.b[8] = buffer.b[8] & 63 | 128;
		let uuid = net_Uuid.stringify(buffer,separator);
		if(shortUuid) {
			uuid = net_Uuid.toShort(uuid,separator,toAlphabet);
		}
		return uuid;
	}
	static stringify(data,separator) {
		if(separator == null) {
			separator = "-";
		}
		return net_Uuid.hexToUuid(data.toHex(),separator);
	}
	static hexToUuid(hex,separator) {
		return HxOverrides.substr(hex,0,8) + separator + HxOverrides.substr(hex,8,4) + separator + HxOverrides.substr(hex,12,4) + separator + HxOverrides.substr(hex,16,4) + separator + HxOverrides.substr(hex,20,12);
	}
	static convert(number,fromAlphabet,toAlphabet) {
		let fromBase = fromAlphabet.length;
		let toBase = toAlphabet.length;
		let len = number.length;
		let buf = "";
		let numberMap = new Array(len);
		let divide = 0;
		let newlen = 0;
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			numberMap[i] = fromAlphabet.indexOf(number.charAt(i));
		}
		do {
			divide = 0;
			newlen = 0;
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				divide = divide * fromBase + numberMap[i];
				if(divide >= toBase) {
					numberMap[newlen++] = Math.floor(divide / toBase);
					divide %= toBase;
				} else if(newlen > 0) {
					numberMap[newlen++] = 0;
				}
			}
			len = newlen;
			buf = toAlphabet.charAt(divide) + buf;
		} while(newlen != 0);
		return buf;
	}
}
$hxClasses["net.Uuid"] = net_Uuid;
net_Uuid.__name__ = "net.Uuid";
class octree_RayIntersectionData {
	constructor(point,normal,object) {
		this.point = point;
		this.normal = normal;
		this.object = object;
	}
}
$hxClasses["octree.RayIntersectionData"] = octree_RayIntersectionData;
octree_RayIntersectionData.__name__ = "octree.RayIntersectionData";
Object.assign(octree_RayIntersectionData.prototype, {
	__class__: octree_RayIntersectionData
	,point: null
	,normal: null
	,object: null
});
class octree_Octree {
	constructor() {
		this.root = new octree_OctreeNode(this,0);
		this.objectToNode = new haxe_ds_ObjectMap();
	}
	insert(object) {
		let node = this.objectToNode.h[object.__id__];
		if(node != null) {
			return;
		}
		while(true) {
			let tmp;
			let _this = this.root;
			if(_this.xMin <= object.boundingBox.xMin && _this.yMin <= object.boundingBox.yMin && _this.zMin <= object.boundingBox.zMin && _this.xMax >= object.boundingBox.xMax && _this.yMax >= object.boundingBox.yMax && _this.zMax >= object.boundingBox.zMax) {
				let _this = this.root;
				let _this1 = object.boundingBox;
				let x = (_this1.xMin + _this1.xMax) * 0.5;
				let y = (_this1.yMin + _this1.yMax) * 0.5;
				let z = (_this1.zMin + _this1.zMax) * 0.5;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let p_x = x;
				let p_y = y;
				let p_z = z;
				tmp = !(p_x >= _this.xMin && p_x < _this.xMax && p_y >= _this.yMin && p_y < _this.yMax && p_z >= _this.zMin && p_z < _this.zMax);
			} else {
				tmp = true;
			}
			if(!tmp) {
				break;
			}
			if(this.root.depth == -32) {
				return;
			}
			this.grow(object);
		}
		let emptyBefore = this.root.count == 0;
		this.root.insert(object);
		if(emptyBefore) {
			this.shrink();
		}
	}
	remove(object) {
		let node = this.objectToNode.h[object.__id__];
		if(node == null) {
			return;
		}
		node.remove(object);
		this.objectToNode.remove(object);
		this.shrink();
	}
	update(object) {
		if(this.objectToNode.h.__keys__[object.__id__] == null) {
			this.insert(object);
			return;
		}
		let success = this.objectToNode.h[object.__id__].update(object);
		if(!success) {
			this.objectToNode.remove(object);
			this.insert(object);
		}
	}
	grow(towards) {
		let averagePoint = new h3d_Vector();
		let count = 0;
		let _g = 0;
		while(_g < 8) {
			let i = _g++;
			let vec_x = 0.;
			let vec_y = 0.;
			let vec_z = 0.;
			vec_x = (i & 1) == 1 ? towards.boundingBox.xMin : towards.boundingBox.xMax;
			vec_y = (i & 2) == 2 ? towards.boundingBox.yMin : towards.boundingBox.yMax;
			vec_z = (i & 4) == 4 ? towards.boundingBox.zMin : towards.boundingBox.zMax;
			let _this = this.root;
			if(!(vec_x >= _this.xMin && vec_x < _this.xMax && vec_y >= _this.yMin && vec_y < _this.yMax && vec_z >= _this.zMin && vec_z < _this.zMax)) {
				averagePoint = new h3d_Vector(averagePoint.x + vec_x,averagePoint.y + vec_y,averagePoint.z + vec_z,averagePoint.w + 1.);
				++count;
			}
		}
		let v = 1 / count;
		let x = averagePoint.x * v;
		let y = averagePoint.y * v;
		let z = averagePoint.z * v;
		let w = averagePoint.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let v_x = x;
		let v_y = y;
		let v_z = z;
		let v_w = w;
		averagePoint.x = v_x;
		averagePoint.y = v_y;
		averagePoint.z = v_z;
		averagePoint.w = v_w;
		let x1 = (this.root.xMax + this.root.xMin) / 2;
		let y1 = (this.root.yMax + this.root.yMin) / 2;
		let z1 = (this.root.zMax + this.root.zMin) / 2;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let rootCenter_x = x1;
		let rootCenter_y = y1;
		let rootCenter_z = z1;
		let x2 = averagePoint.x - rootCenter_x;
		let y2 = averagePoint.y - rootCenter_y;
		let z2 = averagePoint.z - rootCenter_z;
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let direction_x = x2;
		let direction_y = y2;
		let direction_z = z2;
		let newRoot = new octree_OctreeNode(this,this.root.depth - 1);
		newRoot.xMin = this.root.xMin;
		newRoot.yMin = this.root.yMin;
		newRoot.zMin = this.root.zMin;
		newRoot.xMax = 2 * this.root.xMax - this.root.xMin;
		newRoot.yMax = 2 * this.root.yMax - this.root.yMin;
		newRoot.zMax = 2 * this.root.zMax - this.root.zMin;
		if(direction_x < 0) {
			newRoot.xMin -= this.root.xMax - this.root.xMin;
		}
		if(direction_y < 0) {
			newRoot.yMin -= this.root.yMax - this.root.yMin;
		}
		if(direction_z < 0) {
			newRoot.zMin -= this.root.zMax - this.root.zMin;
		}
		if(this.root.count > 0) {
			let octantIndex = (direction_x < 0 ? 1 : 0) + (direction_y < 0 ? 2 : 0) + (direction_z < 0 ? 4 : 0);
			newRoot.createOctants();
			newRoot.octants[octantIndex] = this.root;
			this.root.parent = newRoot;
			newRoot.count = this.root.count;
			newRoot.merge();
		}
		this.root = newRoot;
	}
	shrink() {
		if(this.root.xMax - this.root.xMin < 1 || this.root.yMax - this.root.yMin < 1 || this.root.zMax - this.root.zMin < 1 || this.root.objects.length > 0) {
			return;
		}
		if(this.root.count == 0) {
			this.root.xMin = this.root.yMin = this.root.zMin = 0;
			this.root.xMax = this.root.yMax = this.root.zMax = 1;
			this.root.depth = 0;
			return;
		}
		if(this.root.octants == null) {
			this.root.createOctants();
			let fittingOctant = null;
			let _g = 0;
			let _g1 = this.root.objects;
			while(_g < _g1.length) {
				let obj = _g1[_g];
				++_g;
				let _this = this.root.octants[0];
				if(_this.xMin <= obj.boundingBox.xMin && _this.yMin <= obj.boundingBox.yMin && _this.zMin <= obj.boundingBox.zMin && _this.xMax >= obj.boundingBox.xMax && _this.yMax >= obj.boundingBox.yMax && _this.zMax >= obj.boundingBox.zMax) {
					let octant = this.root.octants[0];
					let _this = obj.boundingBox;
					let x = (_this.xMin + _this.xMax) * 0.5;
					let y = (_this.yMin + _this.yMax) * 0.5;
					let z = (_this.zMin + _this.zMax) * 0.5;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let p_x = x;
					let p_y = y;
					let p_z = z;
					if(p_x >= octant.xMin && p_x < octant.xMax && p_y >= octant.yMin && p_y < octant.yMax && p_z >= octant.zMin && p_z < octant.zMax) {
						if(fittingOctant != null && fittingOctant != octant) {
							return;
						}
						fittingOctant = octant;
					}
					let octant1 = this.root.octants[1];
					let _this1 = obj.boundingBox;
					let x1 = (_this1.xMin + _this1.xMax) * 0.5;
					let y1 = (_this1.yMin + _this1.yMax) * 0.5;
					let z1 = (_this1.zMin + _this1.zMax) * 0.5;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let p_x1 = x1;
					let p_y1 = y1;
					let p_z1 = z1;
					if(p_x1 >= octant1.xMin && p_x1 < octant1.xMax && p_y1 >= octant1.yMin && p_y1 < octant1.yMax && p_z1 >= octant1.zMin && p_z1 < octant1.zMax) {
						if(fittingOctant != null && fittingOctant != octant1) {
							return;
						}
						fittingOctant = octant1;
					}
					let octant2 = this.root.octants[2];
					let _this2 = obj.boundingBox;
					let x2 = (_this2.xMin + _this2.xMax) * 0.5;
					let y2 = (_this2.yMin + _this2.yMax) * 0.5;
					let z2 = (_this2.zMin + _this2.zMax) * 0.5;
					if(z2 == null) {
						z2 = 0.;
					}
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					let p_x2 = x2;
					let p_y2 = y2;
					let p_z2 = z2;
					if(p_x2 >= octant2.xMin && p_x2 < octant2.xMax && p_y2 >= octant2.yMin && p_y2 < octant2.yMax && p_z2 >= octant2.zMin && p_z2 < octant2.zMax) {
						if(fittingOctant != null && fittingOctant != octant2) {
							return;
						}
						fittingOctant = octant2;
					}
					let octant3 = this.root.octants[3];
					let _this3 = obj.boundingBox;
					let x3 = (_this3.xMin + _this3.xMax) * 0.5;
					let y3 = (_this3.yMin + _this3.yMax) * 0.5;
					let z3 = (_this3.zMin + _this3.zMax) * 0.5;
					if(z3 == null) {
						z3 = 0.;
					}
					if(y3 == null) {
						y3 = 0.;
					}
					if(x3 == null) {
						x3 = 0.;
					}
					let p_x3 = x3;
					let p_y3 = y3;
					let p_z3 = z3;
					if(p_x3 >= octant3.xMin && p_x3 < octant3.xMax && p_y3 >= octant3.yMin && p_y3 < octant3.yMax && p_z3 >= octant3.zMin && p_z3 < octant3.zMax) {
						if(fittingOctant != null && fittingOctant != octant3) {
							return;
						}
						fittingOctant = octant3;
					}
					let octant4 = this.root.octants[4];
					let _this4 = obj.boundingBox;
					let x4 = (_this4.xMin + _this4.xMax) * 0.5;
					let y4 = (_this4.yMin + _this4.yMax) * 0.5;
					let z4 = (_this4.zMin + _this4.zMax) * 0.5;
					if(z4 == null) {
						z4 = 0.;
					}
					if(y4 == null) {
						y4 = 0.;
					}
					if(x4 == null) {
						x4 = 0.;
					}
					let p_x4 = x4;
					let p_y4 = y4;
					let p_z4 = z4;
					if(p_x4 >= octant4.xMin && p_x4 < octant4.xMax && p_y4 >= octant4.yMin && p_y4 < octant4.yMax && p_z4 >= octant4.zMin && p_z4 < octant4.zMax) {
						if(fittingOctant != null && fittingOctant != octant4) {
							return;
						}
						fittingOctant = octant4;
					}
					let octant5 = this.root.octants[5];
					let _this5 = obj.boundingBox;
					let x5 = (_this5.xMin + _this5.xMax) * 0.5;
					let y5 = (_this5.yMin + _this5.yMax) * 0.5;
					let z5 = (_this5.zMin + _this5.zMax) * 0.5;
					if(z5 == null) {
						z5 = 0.;
					}
					if(y5 == null) {
						y5 = 0.;
					}
					if(x5 == null) {
						x5 = 0.;
					}
					let p_x5 = x5;
					let p_y5 = y5;
					let p_z5 = z5;
					if(p_x5 >= octant5.xMin && p_x5 < octant5.xMax && p_y5 >= octant5.yMin && p_y5 < octant5.yMax && p_z5 >= octant5.zMin && p_z5 < octant5.zMax) {
						if(fittingOctant != null && fittingOctant != octant5) {
							return;
						}
						fittingOctant = octant5;
					}
					let octant6 = this.root.octants[6];
					let _this6 = obj.boundingBox;
					let x6 = (_this6.xMin + _this6.xMax) * 0.5;
					let y6 = (_this6.yMin + _this6.yMax) * 0.5;
					let z6 = (_this6.zMin + _this6.zMax) * 0.5;
					if(z6 == null) {
						z6 = 0.;
					}
					if(y6 == null) {
						y6 = 0.;
					}
					if(x6 == null) {
						x6 = 0.;
					}
					let p_x6 = x6;
					let p_y6 = y6;
					let p_z6 = z6;
					if(p_x6 >= octant6.xMin && p_x6 < octant6.xMax && p_y6 >= octant6.yMin && p_y6 < octant6.yMax && p_z6 >= octant6.zMin && p_z6 < octant6.zMax) {
						if(fittingOctant != null && fittingOctant != octant6) {
							return;
						}
						fittingOctant = octant6;
					}
					let octant7 = this.root.octants[7];
					let _this7 = obj.boundingBox;
					let x7 = (_this7.xMin + _this7.xMax) * 0.5;
					let y7 = (_this7.yMin + _this7.yMax) * 0.5;
					let z7 = (_this7.zMin + _this7.zMax) * 0.5;
					if(z7 == null) {
						z7 = 0.;
					}
					if(y7 == null) {
						y7 = 0.;
					}
					if(x7 == null) {
						x7 = 0.;
					}
					let p_x7 = x7;
					let p_y7 = y7;
					let p_z7 = z7;
					if(p_x7 >= octant7.xMin && p_x7 < octant7.xMax && p_y7 >= octant7.yMin && p_y7 < octant7.yMax && p_z7 >= octant7.zMin && p_z7 < octant7.zMax) {
						if(fittingOctant != null && fittingOctant != octant7) {
							return;
						}
						fittingOctant = octant7;
					}
				} else {
					return;
				}
			}
		}
		let nonEmptyOctant = null;
		let octant = this.root.octants[0];
		if(octant.count > 0) {
			nonEmptyOctant = octant;
		}
		let octant1 = this.root.octants[1];
		if(octant1.count > 0) {
			if(nonEmptyOctant != null) {
				return;
			} else {
				nonEmptyOctant = octant1;
			}
		}
		let octant2 = this.root.octants[2];
		if(octant2.count > 0) {
			if(nonEmptyOctant != null) {
				return;
			} else {
				nonEmptyOctant = octant2;
			}
		}
		let octant3 = this.root.octants[3];
		if(octant3.count > 0) {
			if(nonEmptyOctant != null) {
				return;
			} else {
				nonEmptyOctant = octant3;
			}
		}
		let octant4 = this.root.octants[4];
		if(octant4.count > 0) {
			if(nonEmptyOctant != null) {
				return;
			} else {
				nonEmptyOctant = octant4;
			}
		}
		let octant5 = this.root.octants[5];
		if(octant5.count > 0) {
			if(nonEmptyOctant != null) {
				return;
			} else {
				nonEmptyOctant = octant5;
			}
		}
		let octant6 = this.root.octants[6];
		if(octant6.count > 0) {
			if(nonEmptyOctant != null) {
				return;
			} else {
				nonEmptyOctant = octant6;
			}
		}
		let octant7 = this.root.octants[7];
		if(octant7.count > 0) {
			if(nonEmptyOctant != null) {
				return;
			} else {
				nonEmptyOctant = octant7;
			}
		}
		this.root = nonEmptyOctant;
		nonEmptyOctant.parent = null;
		this.shrink();
	}
	boundingSearch(bounds,useCache) {
		if(useCache == null) {
			useCache = false;
		}
		let intersections = [];
		if(useCache) {
			if(this.prevBoundSearch != null) {
				let _this = this.prevBoundSearch;
				if(_this.xMin <= bounds.xMin && _this.yMin <= bounds.yMin && _this.zMin <= bounds.zMin && _this.xMax >= bounds.xMax && _this.yMax >= bounds.yMax && _this.zMax >= bounds.zMax) {
					return this.boundSearchCache;
				}
			}
		}
		this.root.boundingSearch(bounds,intersections);
		if(useCache) {
			this.prevBoundSearch = bounds;
			this.boundSearchCache = intersections;
		}
		return intersections;
	}
	radiusSearch(point,maximumDistance) {
		let getClosestPoint = function(box,point) {
			let closest = new h3d_Vector();
			if(box.xMin > point.x) {
				closest.x = box.xMin;
			} else if(box.xMax < point.x) {
				closest.x = box.xMax;
			} else {
				closest.x = point.x;
			}
			if(box.yMin > point.y) {
				closest.y = box.yMin;
			} else if(box.yMax < point.y) {
				closest.y = box.yMax;
			} else {
				closest.y = point.y;
			}
			if(box.zMin > point.z) {
				closest.z = box.zMin;
			} else if(box.zMax < point.z) {
				closest.z = box.zMax;
			} else {
				closest.z = point.z;
			}
			return closest;
		};
		let L = [];
		let queue = new octree_PriorityQueue_$octree_$IOctreeElement();
		let maxDistSq = maximumDistance * maximumDistance;
		let _this = this.root;
		let x = Math.min(Math.max(_this.xMin,point.x),_this.xMax);
		let y = Math.min(Math.max(_this.yMin,point.y),_this.yMax);
		let z = Math.min(Math.max(_this.zMin,point.z),_this.zMax);
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let closestPoint_x = x;
		let closestPoint_y = y;
		let closestPoint_z = z;
		let dx = point.x - closestPoint_x;
		let dy = point.y - closestPoint_y;
		let dz = point.z - closestPoint_z;
		let distSq = dx * dx + dy * dy + dz * dz;
		if(distSq > maximumDistance) {
			return L;
		}
		this.root.setPriority(-distSq);
		queue.enqueue(this.root,distSq);
		while(queue.count > 0) {
			let node = queue.dequeue();
			switch(node.getElementType()) {
			case 1:
				let octant = js_Boot.__cast(node , octree_OctreeNode);
				if(octant.objects != null) {
					let _g = 0;
					let _g1 = octant.objects;
					while(_g < _g1.length) {
						let object = _g1[_g];
						++_g;
						let v = getClosestPoint(object.boundingBox,point);
						let dx = v.x - point.x;
						let dy = v.y - point.y;
						let dz = v.z - point.z;
						let dist = dx * dx + dy * dy + dz * dz;
						if(dist < maxDistSq) {
							object.setPriority(-dist);
							queue.enqueue(object,dist);
						}
					}
				}
				if(octant.octants != null) {
					let _g = 0;
					let _g1 = octant.octants;
					while(_g < _g1.length) {
						let suboctant = _g1[_g];
						++_g;
						let x = Math.min(Math.max(suboctant.xMin,point.x),suboctant.xMax);
						let y = Math.min(Math.max(suboctant.yMin,point.y),suboctant.yMax);
						let z = Math.min(Math.max(suboctant.zMin,point.z),suboctant.zMax);
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let v_x = x;
						let v_y = y;
						let v_z = z;
						let dx = v_x - point.x;
						let dy = v_y - point.y;
						let dz = v_z - point.z;
						let dist = dx * dx + dy * dy + dz * dz;
						if(dist < maxDistSq) {
							suboctant.setPriority(-dist);
							queue.enqueue(suboctant,dist);
						}
					}
				}
				break;
			case 2:
				L.push(js_Boot.__cast(node , octree_IOctreeObject));
				break;
			}
		}
		return L;
	}
}
$hxClasses["octree.Octree"] = octree_Octree;
octree_Octree.__name__ = "octree.Octree";
Object.assign(octree_Octree.prototype, {
	__class__: octree_Octree
	,root: null
	,objectToNode: null
	,prevBoundSearch: null
	,boundSearchCache: null
});
class octree_OctreeNode {
	constructor(octree,depth) {
		this.count = 0;
		this.objects = [];
		this.octants = null;
		this.parent = null;
		this.octree = octree;
		this.depth = depth;
		this.xMin = 0;
		this.yMin = 0;
		this.zMin = 0;
		this.xMax = 1;
		this.yMax = 1;
		this.zMax = 1;
	}
	insert(object) {
		this.count++;
		if(this.octants != null) {
			let _this = this.octants[0];
			if(_this.xMin <= object.boundingBox.xMin && _this.yMin <= object.boundingBox.yMin && _this.zMin <= object.boundingBox.zMin && _this.xMax >= object.boundingBox.xMax && _this.yMax >= object.boundingBox.yMax && _this.zMax >= object.boundingBox.zMax) {
				let octant = this.octants[0];
				let _this = object.boundingBox;
				let x = (_this.xMin + _this.xMax) * 0.5;
				let y = (_this.yMin + _this.yMax) * 0.5;
				let z = (_this.zMin + _this.zMax) * 0.5;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let p_x = x;
				let p_y = y;
				let p_z = z;
				if(p_x >= octant.xMin && p_x < octant.xMax && p_y >= octant.yMin && p_y < octant.yMax && p_z >= octant.zMin && p_z < octant.zMax) {
					octant.insert(object);
					return;
				}
				let octant1 = this.octants[1];
				let _this1 = object.boundingBox;
				let x1 = (_this1.xMin + _this1.xMax) * 0.5;
				let y1 = (_this1.yMin + _this1.yMax) * 0.5;
				let z1 = (_this1.zMin + _this1.zMax) * 0.5;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let p_x1 = x1;
				let p_y1 = y1;
				let p_z1 = z1;
				if(p_x1 >= octant1.xMin && p_x1 < octant1.xMax && p_y1 >= octant1.yMin && p_y1 < octant1.yMax && p_z1 >= octant1.zMin && p_z1 < octant1.zMax) {
					octant1.insert(object);
					return;
				}
				let octant2 = this.octants[2];
				let _this2 = object.boundingBox;
				let x2 = (_this2.xMin + _this2.xMax) * 0.5;
				let y2 = (_this2.yMin + _this2.yMax) * 0.5;
				let z2 = (_this2.zMin + _this2.zMax) * 0.5;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let p_x2 = x2;
				let p_y2 = y2;
				let p_z2 = z2;
				if(p_x2 >= octant2.xMin && p_x2 < octant2.xMax && p_y2 >= octant2.yMin && p_y2 < octant2.yMax && p_z2 >= octant2.zMin && p_z2 < octant2.zMax) {
					octant2.insert(object);
					return;
				}
				let octant3 = this.octants[3];
				let _this3 = object.boundingBox;
				let x3 = (_this3.xMin + _this3.xMax) * 0.5;
				let y3 = (_this3.yMin + _this3.yMax) * 0.5;
				let z3 = (_this3.zMin + _this3.zMax) * 0.5;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				let p_x3 = x3;
				let p_y3 = y3;
				let p_z3 = z3;
				if(p_x3 >= octant3.xMin && p_x3 < octant3.xMax && p_y3 >= octant3.yMin && p_y3 < octant3.yMax && p_z3 >= octant3.zMin && p_z3 < octant3.zMax) {
					octant3.insert(object);
					return;
				}
				let octant4 = this.octants[4];
				let _this4 = object.boundingBox;
				let x4 = (_this4.xMin + _this4.xMax) * 0.5;
				let y4 = (_this4.yMin + _this4.yMax) * 0.5;
				let z4 = (_this4.zMin + _this4.zMax) * 0.5;
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				let p_x4 = x4;
				let p_y4 = y4;
				let p_z4 = z4;
				if(p_x4 >= octant4.xMin && p_x4 < octant4.xMax && p_y4 >= octant4.yMin && p_y4 < octant4.yMax && p_z4 >= octant4.zMin && p_z4 < octant4.zMax) {
					octant4.insert(object);
					return;
				}
				let octant5 = this.octants[5];
				let _this5 = object.boundingBox;
				let x5 = (_this5.xMin + _this5.xMax) * 0.5;
				let y5 = (_this5.yMin + _this5.yMax) * 0.5;
				let z5 = (_this5.zMin + _this5.zMax) * 0.5;
				if(z5 == null) {
					z5 = 0.;
				}
				if(y5 == null) {
					y5 = 0.;
				}
				if(x5 == null) {
					x5 = 0.;
				}
				let p_x5 = x5;
				let p_y5 = y5;
				let p_z5 = z5;
				if(p_x5 >= octant5.xMin && p_x5 < octant5.xMax && p_y5 >= octant5.yMin && p_y5 < octant5.yMax && p_z5 >= octant5.zMin && p_z5 < octant5.zMax) {
					octant5.insert(object);
					return;
				}
				let octant6 = this.octants[6];
				let _this6 = object.boundingBox;
				let x6 = (_this6.xMin + _this6.xMax) * 0.5;
				let y6 = (_this6.yMin + _this6.yMax) * 0.5;
				let z6 = (_this6.zMin + _this6.zMax) * 0.5;
				if(z6 == null) {
					z6 = 0.;
				}
				if(y6 == null) {
					y6 = 0.;
				}
				if(x6 == null) {
					x6 = 0.;
				}
				let p_x6 = x6;
				let p_y6 = y6;
				let p_z6 = z6;
				if(p_x6 >= octant6.xMin && p_x6 < octant6.xMax && p_y6 >= octant6.yMin && p_y6 < octant6.yMax && p_z6 >= octant6.zMin && p_z6 < octant6.zMax) {
					octant6.insert(object);
					return;
				}
				let octant7 = this.octants[7];
				let _this7 = object.boundingBox;
				let x7 = (_this7.xMin + _this7.xMax) * 0.5;
				let y7 = (_this7.yMin + _this7.yMax) * 0.5;
				let z7 = (_this7.zMin + _this7.zMax) * 0.5;
				if(z7 == null) {
					z7 = 0.;
				}
				if(y7 == null) {
					y7 = 0.;
				}
				if(x7 == null) {
					x7 = 0.;
				}
				let p_x7 = x7;
				let p_y7 = y7;
				let p_z7 = z7;
				if(p_x7 >= octant7.xMin && p_x7 < octant7.xMax && p_y7 >= octant7.yMin && p_y7 < octant7.yMax && p_z7 >= octant7.zMin && p_z7 < octant7.zMax) {
					octant7.insert(object);
					return;
				}
			}
			this.objects.push(object);
			this.octree.objectToNode.set(object,this);
		} else {
			this.objects.push(object);
			this.octree.objectToNode.set(object,this);
			this.split();
		}
	}
	split() {
		if(this.objects.length <= 8 || this.depth == 8) {
			return;
		}
		this.createOctants();
		let _g = 0;
		let _g1 = this.objects;
		while(_g < _g1.length) {
			let object = _g1[_g];
			++_g;
			let _this = this.octants[0];
			if(_this.xMin <= object.boundingBox.xMin && _this.yMin <= object.boundingBox.yMin && _this.zMin <= object.boundingBox.zMin && _this.xMax >= object.boundingBox.xMax && _this.yMax >= object.boundingBox.yMax && _this.zMax >= object.boundingBox.zMax) {
				let octant = this.octants[0];
				let _this = object.boundingBox;
				let x = (_this.xMin + _this.xMax) * 0.5;
				let y = (_this.yMin + _this.yMax) * 0.5;
				let z = (_this.zMin + _this.zMax) * 0.5;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let p_x = x;
				let p_y = y;
				let p_z = z;
				if(p_x >= octant.xMin && p_x < octant.xMax && p_y >= octant.yMin && p_y < octant.yMax && p_z >= octant.zMin && p_z < octant.zMax) {
					octant.insert(object);
					HxOverrides.remove(this.objects,object);
				}
				let octant1 = this.octants[1];
				let _this1 = object.boundingBox;
				let x1 = (_this1.xMin + _this1.xMax) * 0.5;
				let y1 = (_this1.yMin + _this1.yMax) * 0.5;
				let z1 = (_this1.zMin + _this1.zMax) * 0.5;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let p_x1 = x1;
				let p_y1 = y1;
				let p_z1 = z1;
				if(p_x1 >= octant1.xMin && p_x1 < octant1.xMax && p_y1 >= octant1.yMin && p_y1 < octant1.yMax && p_z1 >= octant1.zMin && p_z1 < octant1.zMax) {
					octant1.insert(object);
					HxOverrides.remove(this.objects,object);
				}
				let octant2 = this.octants[2];
				let _this2 = object.boundingBox;
				let x2 = (_this2.xMin + _this2.xMax) * 0.5;
				let y2 = (_this2.yMin + _this2.yMax) * 0.5;
				let z2 = (_this2.zMin + _this2.zMax) * 0.5;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let p_x2 = x2;
				let p_y2 = y2;
				let p_z2 = z2;
				if(p_x2 >= octant2.xMin && p_x2 < octant2.xMax && p_y2 >= octant2.yMin && p_y2 < octant2.yMax && p_z2 >= octant2.zMin && p_z2 < octant2.zMax) {
					octant2.insert(object);
					HxOverrides.remove(this.objects,object);
				}
				let octant3 = this.octants[3];
				let _this3 = object.boundingBox;
				let x3 = (_this3.xMin + _this3.xMax) * 0.5;
				let y3 = (_this3.yMin + _this3.yMax) * 0.5;
				let z3 = (_this3.zMin + _this3.zMax) * 0.5;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				let p_x3 = x3;
				let p_y3 = y3;
				let p_z3 = z3;
				if(p_x3 >= octant3.xMin && p_x3 < octant3.xMax && p_y3 >= octant3.yMin && p_y3 < octant3.yMax && p_z3 >= octant3.zMin && p_z3 < octant3.zMax) {
					octant3.insert(object);
					HxOverrides.remove(this.objects,object);
				}
				let octant4 = this.octants[4];
				let _this4 = object.boundingBox;
				let x4 = (_this4.xMin + _this4.xMax) * 0.5;
				let y4 = (_this4.yMin + _this4.yMax) * 0.5;
				let z4 = (_this4.zMin + _this4.zMax) * 0.5;
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				let p_x4 = x4;
				let p_y4 = y4;
				let p_z4 = z4;
				if(p_x4 >= octant4.xMin && p_x4 < octant4.xMax && p_y4 >= octant4.yMin && p_y4 < octant4.yMax && p_z4 >= octant4.zMin && p_z4 < octant4.zMax) {
					octant4.insert(object);
					HxOverrides.remove(this.objects,object);
				}
				let octant5 = this.octants[5];
				let _this5 = object.boundingBox;
				let x5 = (_this5.xMin + _this5.xMax) * 0.5;
				let y5 = (_this5.yMin + _this5.yMax) * 0.5;
				let z5 = (_this5.zMin + _this5.zMax) * 0.5;
				if(z5 == null) {
					z5 = 0.;
				}
				if(y5 == null) {
					y5 = 0.;
				}
				if(x5 == null) {
					x5 = 0.;
				}
				let p_x5 = x5;
				let p_y5 = y5;
				let p_z5 = z5;
				if(p_x5 >= octant5.xMin && p_x5 < octant5.xMax && p_y5 >= octant5.yMin && p_y5 < octant5.yMax && p_z5 >= octant5.zMin && p_z5 < octant5.zMax) {
					octant5.insert(object);
					HxOverrides.remove(this.objects,object);
				}
				let octant6 = this.octants[6];
				let _this6 = object.boundingBox;
				let x6 = (_this6.xMin + _this6.xMax) * 0.5;
				let y6 = (_this6.yMin + _this6.yMax) * 0.5;
				let z6 = (_this6.zMin + _this6.zMax) * 0.5;
				if(z6 == null) {
					z6 = 0.;
				}
				if(y6 == null) {
					y6 = 0.;
				}
				if(x6 == null) {
					x6 = 0.;
				}
				let p_x6 = x6;
				let p_y6 = y6;
				let p_z6 = z6;
				if(p_x6 >= octant6.xMin && p_x6 < octant6.xMax && p_y6 >= octant6.yMin && p_y6 < octant6.yMax && p_z6 >= octant6.zMin && p_z6 < octant6.zMax) {
					octant6.insert(object);
					HxOverrides.remove(this.objects,object);
				}
				let octant7 = this.octants[7];
				let _this7 = object.boundingBox;
				let x7 = (_this7.xMin + _this7.xMax) * 0.5;
				let y7 = (_this7.yMin + _this7.yMax) * 0.5;
				let z7 = (_this7.zMin + _this7.zMax) * 0.5;
				if(z7 == null) {
					z7 = 0.;
				}
				if(y7 == null) {
					y7 = 0.;
				}
				if(x7 == null) {
					x7 = 0.;
				}
				let p_x7 = x7;
				let p_y7 = y7;
				let p_z7 = z7;
				if(p_x7 >= octant7.xMin && p_x7 < octant7.xMax && p_y7 >= octant7.yMin && p_y7 < octant7.yMax && p_z7 >= octant7.zMin && p_z7 < octant7.zMax) {
					octant7.insert(object);
					HxOverrides.remove(this.objects,object);
				}
			}
		}
		this.octants[0].split();
		this.octants[1].split();
		this.octants[2].split();
		this.octants[3].split();
		this.octants[4].split();
		this.octants[5].split();
		this.octants[6].split();
		this.octants[7].split();
	}
	createOctants() {
		this.octants = [];
		let _g = 0;
		while(_g < 8) {
			let i = _g++;
			let newNode = new octree_OctreeNode(this.octree,this.depth + 1);
			newNode.parent = this;
			let x = this.xMax - this.xMin;
			let y = this.yMax - this.yMin;
			let z = this.zMax - this.zMin;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let newSize_x = x;
			let newSize_y = y;
			let newSize_z = z;
			newNode.xMin = this.xMin + newSize_x * (i & 1);
			newNode.yMin = this.yMin + newSize_y * ((i & 2) >> 1);
			newNode.zMin = this.zMin + newSize_z * ((i & 4) >> 2);
			newNode.xMax = newNode.xMin + newSize_x;
			newNode.yMax = newNode.yMin + newSize_y;
			newNode.zMax = newNode.zMin + newSize_z;
			this.octants.push(newNode);
		}
	}
	remove(object) {
		HxOverrides.remove(this.objects,object);
		this.count--;
		this.merge();
		let node = this.parent;
		while(node != null) {
			node.count--;
			node.merge();
			node = node.parent;
		}
	}
	update(object) {
		HxOverrides.remove(this.objects,object);
		let node = this;
		while(node != null) {
			node.count--;
			node.merge();
			let tmp;
			if(node.xMin <= object.boundingBox.xMin && node.yMin <= object.boundingBox.yMin && node.zMin <= object.boundingBox.zMin && node.xMax >= object.boundingBox.xMax && node.yMax >= object.boundingBox.yMax && node.zMax >= object.boundingBox.zMax) {
				let _this = object.boundingBox;
				let x = (_this.xMin + _this.xMax) * 0.5;
				let y = (_this.yMin + _this.yMax) * 0.5;
				let z = (_this.zMin + _this.zMax) * 0.5;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let p_x = x;
				let p_y = y;
				let p_z = z;
				tmp = p_x >= node.xMin && p_x < node.xMax && p_y >= node.yMin && p_y < node.yMax && p_z >= node.zMin && p_z < node.zMax;
			} else {
				tmp = false;
			}
			if(tmp) {
				node.insert(object);
				return true;
			}
			node = node.parent;
		}
		return false;
	}
	merge() {
		if(this.count > 8 || this.octants == null) {
			return;
		}
		let octant = this.octants[0];
		let _g = 0;
		let _g1 = octant.objects;
		while(_g < _g1.length) {
			let object = _g1[_g];
			++_g;
			this.objects.push(object);
			this.octree.objectToNode.set(object,this);
		}
		let octant1 = this.octants[1];
		let _g2 = 0;
		let _g3 = octant1.objects;
		while(_g2 < _g3.length) {
			let object = _g3[_g2];
			++_g2;
			this.objects.push(object);
			this.octree.objectToNode.set(object,this);
		}
		let octant2 = this.octants[2];
		let _g4 = 0;
		let _g5 = octant2.objects;
		while(_g4 < _g5.length) {
			let object = _g5[_g4];
			++_g4;
			this.objects.push(object);
			this.octree.objectToNode.set(object,this);
		}
		let octant3 = this.octants[3];
		let _g6 = 0;
		let _g7 = octant3.objects;
		while(_g6 < _g7.length) {
			let object = _g7[_g6];
			++_g6;
			this.objects.push(object);
			this.octree.objectToNode.set(object,this);
		}
		let octant4 = this.octants[4];
		let _g8 = 0;
		let _g9 = octant4.objects;
		while(_g8 < _g9.length) {
			let object = _g9[_g8];
			++_g8;
			this.objects.push(object);
			this.octree.objectToNode.set(object,this);
		}
		let octant5 = this.octants[5];
		let _g10 = 0;
		let _g11 = octant5.objects;
		while(_g10 < _g11.length) {
			let object = _g11[_g10];
			++_g10;
			this.objects.push(object);
			this.octree.objectToNode.set(object,this);
		}
		let octant6 = this.octants[6];
		let _g12 = 0;
		let _g13 = octant6.objects;
		while(_g12 < _g13.length) {
			let object = _g13[_g12];
			++_g12;
			this.objects.push(object);
			this.octree.objectToNode.set(object,this);
		}
		let octant7 = this.octants[7];
		let _g14 = 0;
		let _g15 = octant7.objects;
		while(_g14 < _g15.length) {
			let object = _g15[_g14];
			++_g14;
			this.objects.push(object);
			this.octree.objectToNode.set(object,this);
		}
		this.octants = null;
	}
	boundingSearch(b,intersections) {
		if(!(this.xMin > b.xMax || this.yMin > b.yMax || this.zMin > b.zMax || this.xMax < b.xMin || this.yMax < b.yMin || this.zMax < b.zMin)) {
			let _g = 0;
			let _g1 = this.objects;
			while(_g < _g1.length) {
				let obj = _g1[_g];
				++_g;
				let _this = obj.boundingBox;
				if(!(_this.xMin > b.xMax || _this.yMin > b.yMax || _this.zMin > b.zMax || _this.xMax < b.xMin || _this.yMax < b.yMin || _this.zMax < b.zMin)) {
					intersections.push(obj);
				}
			}
			if(this.octants != null) {
				let _g = 0;
				let _g1 = this.octants;
				while(_g < _g1.length) {
					let octant = _g1[_g];
					++_g;
					octant.boundingSearch(b,intersections);
				}
			}
		}
	}
	getElementType() {
		return 1;
	}
	setPriority(priority) {
		this.priority = priority;
	}
}
$hxClasses["octree.OctreeNode"] = octree_OctreeNode;
octree_OctreeNode.__name__ = "octree.OctreeNode";
octree_OctreeNode.__interfaces__ = [octree_IOctreeElement];
Object.assign(octree_OctreeNode.prototype, {
	__class__: octree_OctreeNode
	,octree: null
	,parent: null
	,priority: null
	,xMin: null
	,yMin: null
	,zMin: null
	,xMax: null
	,yMax: null
	,zMax: null
	,octants: null
	,objects: null
	,count: null
	,depth: null
});
class octree_PriorityQueueNode_$octree_$IOctreeElement {
	constructor(value,priority) {
		this.value = value;
		this.priority = priority;
	}
}
$hxClasses["octree.PriorityQueueNode_octree_IOctreeElement"] = octree_PriorityQueueNode_$octree_$IOctreeElement;
octree_PriorityQueueNode_$octree_$IOctreeElement.__name__ = "octree.PriorityQueueNode_octree_IOctreeElement";
Object.assign(octree_PriorityQueueNode_$octree_$IOctreeElement.prototype, {
	__class__: octree_PriorityQueueNode_$octree_$IOctreeElement
	,value: null
	,priority: null
});
class octree_PriorityQueue_$octree_$IOctreeElement {
	constructor() {
		this.count = 0;
		this.queue = [];
	}
	enqueue(val,priority) {
		let node = new octree_PriorityQueueNode_$octree_$IOctreeElement(val,priority);
		if(this.queue == null || this.queue.length == 0) {
			this.queue = [node];
		} else if(this.queue[0].priority >= priority) {
			this.queue.splice(0,0,node);
		} else {
			let insertIndex = 0;
			while(insertIndex < this.queue.length) {
				if(this.queue[insertIndex].priority > node.priority) {
					break;
				}
				++insertIndex;
			}
			this.queue.splice(insertIndex,0,node);
		}
		this.count++;
	}
	dequeue() {
		let ret = this.queue[0];
		this.queue.splice(0,1);
		this.count--;
		return ret.value;
	}
}
$hxClasses["octree.PriorityQueue_octree_IOctreeElement"] = octree_PriorityQueue_$octree_$IOctreeElement;
octree_PriorityQueue_$octree_$IOctreeElement.__name__ = "octree.PriorityQueue_octree_IOctreeElement";
Object.assign(octree_PriorityQueue_$octree_$IOctreeElement.prototype, {
	__class__: octree_PriorityQueue_$octree_$IOctreeElement
	,queue: null
	,count: null
});
class rewind_InputRecorderFrame {
	constructor() {
	}
}
$hxClasses["rewind.InputRecorderFrame"] = rewind_InputRecorderFrame;
rewind_InputRecorderFrame.__name__ = "rewind.InputRecorderFrame";
Object.assign(rewind_InputRecorderFrame.prototype, {
	__class__: rewind_InputRecorderFrame
	,time: null
});
class rewind_InputRecorder {
	constructor(level) {
		this.frames = [];
		this.level = level;
	}
	getMovesFrom(t) {
		if(this.frames.length == 0) {
			return [];
		}
		let start = 0;
		let end = this.frames.length - 1;
		let mid = this.frames.length / 2 | 0;
		while(end - start > 1) {
			mid = start / 2 + end / 2 | 0;
			if(this.frames[mid].time < t) {
				start = mid + 1;
			} else if(this.frames[mid].time > t) {
				end = mid - 1;
			} else {
				end = mid;
				start = end;
			}
		}
		return this.frames.slice(start - 1);
	}
}
$hxClasses["rewind.InputRecorder"] = rewind_InputRecorder;
rewind_InputRecorder.__name__ = "rewind.InputRecorder";
Object.assign(rewind_InputRecorder.prototype, {
	__class__: rewind_InputRecorder
	,frames: null
	,level: null
});
class rewind_RewindMPState {
	constructor() {
	}
}
$hxClasses["rewind.RewindMPState"] = rewind_RewindMPState;
rewind_RewindMPState.__name__ = "rewind.RewindMPState";
Object.assign(rewind_RewindMPState.prototype, {
	__class__: rewind_RewindMPState
	,currentTime: null
	,targetTime: null
	,stoppedPosition: null
	,prevPosition: null
	,position: null
	,velocity: null
});
class rewind_RewindFrame {
	constructor() {
	}
}
$hxClasses["rewind.RewindFrame"] = rewind_RewindFrame;
rewind_RewindFrame.__name__ = "rewind.RewindFrame";
Object.assign(rewind_RewindFrame.prototype, {
	__class__: rewind_RewindFrame
	,timeState: null
	,rewindAccumulator: null
	,marbleColliderTransform: null
	,marblePrevPosition: null
	,marbleNextPosition: null
	,marblePhysicsAccmulator: null
	,marbleOrientation: null
	,marblePrevOrientation: null
	,marbleVelocity: null
	,marbleAngularVelocity: null
	,marblePowerup: null
	,bonusTime: null
	,mpStates: null
	,gemCount: null
	,gemStates: null
	,powerupStates: null
	,landMineStates: null
	,activePowerupStates: null
	,currentUp: null
	,trapdoorStates: null
	,lastContactNormal: null
	,blastAmt: null
	,oobState: null
	,checkpointState: null
	,modeState: null
});
class rewind_RewindManager {
	constructor(level) {
		this.saveResolution = 0.032;
		this.timeAccumulator = 0.0;
		this.timeScale = 1;
		this.allocMeId = 0;
		this.allocId = 0;
		this.allocMes = [];
		this.allocMeMap = new haxe_ds_ObjectMap();
		this.allocObjs = [];
		this.allocObjMap = new haxe_ds_ObjectMap();
		this.frameSizes = [];
		this.frameDataOffsets = [];
		this.frameElapsedTimes = [];
		this.level = level;
		this.timeScale = src_Settings.optionsSettings.rewindTimescale;
		this.frameData = new haxe_io_BytesBuffer();
	}
	recordFrame() {
		this.timeAccumulator += this.level.timeState.dt;
		while(this.timeAccumulator >= this.saveResolution) {
			let rf_rewindAccumulator = this.timeAccumulator -= this.saveResolution;
			let rf_timeState = this.level.timeState.clone();
			let rf_marbleColliderTransform = this.level.marble.collider.transform.clone();
			let _this = this.level.marble.oldPos;
			let x = _this.x;
			let y = _this.y;
			let z = _this.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let rf_marblePrevPosition_x = x;
			let rf_marblePrevPosition_y = y;
			let rf_marblePrevPosition_z = z;
			let _this1 = this.level.marble.newPos;
			let x1 = _this1.x;
			let y1 = _this1.y;
			let z1 = _this1.z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let rf_marbleNextPosition_x = x1;
			let rf_marbleNextPosition_y = y1;
			let rf_marbleNextPosition_z = z1;
			let _this2 = this.level.marble.getRotationQuat();
			let x2 = _this2.x;
			let y2 = _this2.y;
			let z2 = _this2.z;
			let w = _this2.w;
			if(w == null) {
				w = 1.;
			}
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let rf_marbleOrientation_x = x2;
			let rf_marbleOrientation_y = y2;
			let rf_marbleOrientation_z = z2;
			let rf_marbleOrientation_w = w;
			let _this3 = this.level.marble.prevRot;
			let x3 = _this3.x;
			let y3 = _this3.y;
			let z3 = _this3.z;
			let w1 = _this3.w;
			if(w1 == null) {
				w1 = 1.;
			}
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			let rf_marblePrevOrientation_x = x3;
			let rf_marblePrevOrientation_y = y3;
			let rf_marblePrevOrientation_z = z3;
			let rf_marblePrevOrientation_w = w1;
			let rf_marblePhysicsAccmulator = this.level.marble.physicsAccumulator;
			let _this4 = this.level.marble.velocity;
			let x4 = _this4.x;
			let y4 = _this4.y;
			let z4 = _this4.z;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			let rf_marbleVelocity_x = x4;
			let rf_marbleVelocity_y = y4;
			let rf_marbleVelocity_z = z4;
			let _this5 = this.level.marble.omega;
			let x5 = _this5.x;
			let y5 = _this5.y;
			let z5 = _this5.z;
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			let rf_marbleAngularVelocity_x = x5;
			let rf_marbleAngularVelocity_y = y5;
			let rf_marbleAngularVelocity_z = z5;
			let rf_marblePowerup = this.level.marble.heldPowerup;
			let rf_bonusTime = this.level.bonusTime;
			let rf_gemCount = this.level.gemCount;
			let _this6 = this.level.gems;
			let result = new Array(_this6.length);
			let _g = 0;
			let _g1 = _this6.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _this6[i].pickedUp;
			}
			let rf_activePowerupStates_0 = this.level.marble.helicopterEnableTime;
			let rf_activePowerupStates_1 = this.level.marble.megaMarbleEnableTime;
			let _this7 = this.level.marble.currentUp;
			let x6 = _this7.x;
			let y6 = _this7.y;
			let z6 = _this7.z;
			if(z6 == null) {
				z6 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			let rf_currentUp_x = x6;
			let rf_currentUp_y = y6;
			let rf_currentUp_z = z6;
			let _this8 = this.level.marble.lastContactNormal;
			let x7 = _this8.x;
			let y7 = _this8.y;
			let z7 = _this8.z;
			if(z7 == null) {
				z7 = 0.;
			}
			if(y7 == null) {
				y7 = 0.;
			}
			if(x7 == null) {
				x7 = 0.;
			}
			let rf_lastContactNormal_x = x7;
			let rf_lastContactNormal_y = y7;
			let rf_lastContactNormal_z = z7;
			let _this9 = this.level.pathedInteriors;
			let result1 = new Array(_this9.length);
			let _g2 = 0;
			let _g3 = _this9.length;
			while(_g2 < _g3) {
				let i = _g2++;
				let x = _this9[i];
				let mpstate = new rewind_RewindMPState();
				mpstate.currentTime = x.currentTime;
				mpstate.targetTime = x.targetTime;
				let _this = x.velocity;
				mpstate.velocity = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
				let rf_mpStates;
				if(x.stopped) {
					let _this = x.stoppedPosition;
					rf_mpStates = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
				} else {
					rf_mpStates = null;
				}
				mpstate.stoppedPosition = rf_mpStates;
				let _this1 = x.position;
				mpstate.position = new h3d_Vector(_this1.x,_this1.y,_this1.z,_this1.w);
				let _this2 = x.prevPosition;
				mpstate.prevPosition = new h3d_Vector(_this2.x,_this2.y,_this2.z,_this2.w);
				result1[i] = mpstate;
			}
			let rf_powerupStates = [];
			let rf_landMineStates = [];
			let rf_trapdoorStates = [];
			let _g4 = 0;
			let _g5 = this.level.dtsObjects;
			while(_g4 < _g5.length) {
				let dts = _g5[_g4];
				++_g4;
				if(((dts) instanceof shapes_PowerUp)) {
					let pow = dts;
					rf_powerupStates.push(pow.lastPickUpTime);
				}
				if(((dts) instanceof shapes_Trapdoor)) {
					let td = dts;
					rf_trapdoorStates.push({ lastCompletion : td.lastCompletion, lastDirection : td.lastDirection, lastContactTime : td.lastContactTime});
				}
				if(((dts) instanceof shapes_AbstractBumper)) {
					let ab = dts;
					rf_powerupStates.push(ab.lastContactTime);
				}
			}
			let rf_blastAmt = this.level.marble.blastAmount;
			let rf_oobState_oob = this.level.marble.outOfBounds;
			let rf_oobState_timeState = this.level.marble.outOfBoundsTime != null ? this.level.marble.outOfBoundsTime.clone() : null;
			let rf_checkpointState = { currentCheckpoint : this.level.currentCheckpoint, currentCheckpointTrigger : this.level.currentCheckpointTrigger, checkpointBlast : this.level.cheeckpointBlast, checkpointCollectedGems : this.level.checkpointCollectedGems.copy(), checkpointHeldPowerup : this.level.checkpointHeldPowerup};
			let rf_modeState = this.level.gameMode.getRewindState();
			this.frameElapsedTimes.push(this.level.timeState.currentAttemptTime);
			this.frameDataOffsets.push(this.frameData.pos);
			let bb = new haxe_io_BytesOutput();
			let framesize = 0;
			framesize = 32;
			framesize = 40;
			framesize = 168;
			framesize = 192;
			framesize = 216;
			framesize = 224;
			framesize = 256;
			framesize = 288;
			framesize = 312;
			framesize = 336;
			framesize = 338;
			framesize = 346;
			framesize = 348;
			framesize = 348 + (2 + result.length);
			framesize += 2 + rf_powerupStates.length * 8;
			framesize += 2 + rf_landMineStates.length * 8;
			framesize += 16;
			framesize += 24;
			framesize += 24;
			framesize += 2;
			let _g6 = 0;
			while(_g6 < result1.length) {
				let s = result1[_g6];
				++_g6;
				framesize += 8;
				framesize += 8;
				++framesize;
				if(s.stoppedPosition != null) {
					framesize += 24;
				}
				framesize += 24;
				framesize += 24;
				framesize += 24;
			}
			framesize += 2;
			let _g7 = 0;
			while(_g7 < rf_trapdoorStates.length) {
				++_g7;
				framesize += 8;
				++framesize;
				framesize += 8;
			}
			framesize += 8;
			if(rf_oobState_oob) {
				++framesize;
			}
			framesize += 32;
			++framesize;
			if(rf_checkpointState != null) {
				framesize += 2;
			}
			framesize += 2;
			framesize += 2;
			let gem = rf_checkpointState.checkpointCollectedGems.keys();
			while(gem.hasNext()) {
				gem.next();
				framesize += 2;
				++framesize;
			}
			framesize += 2;
			framesize += 8;
			++framesize;
			if(rf_modeState != null) {
				framesize += rf_modeState.getSize();
			}
			bb.prepare(framesize);
			bb.writeDouble(rf_timeState.currentAttemptTime);
			bb.writeDouble(rf_timeState.timeSinceLoad);
			bb.writeDouble(rf_timeState.gameplayClock);
			bb.writeDouble(rf_timeState.dt);
			bb.writeDouble(rf_rewindAccumulator);
			bb.writeDouble(rf_marbleColliderTransform._11);
			bb.writeDouble(rf_marbleColliderTransform._12);
			bb.writeDouble(rf_marbleColliderTransform._13);
			bb.writeDouble(rf_marbleColliderTransform._14);
			bb.writeDouble(rf_marbleColliderTransform._21);
			bb.writeDouble(rf_marbleColliderTransform._22);
			bb.writeDouble(rf_marbleColliderTransform._23);
			bb.writeDouble(rf_marbleColliderTransform._24);
			bb.writeDouble(rf_marbleColliderTransform._31);
			bb.writeDouble(rf_marbleColliderTransform._32);
			bb.writeDouble(rf_marbleColliderTransform._33);
			bb.writeDouble(rf_marbleColliderTransform._34);
			bb.writeDouble(rf_marbleColliderTransform._41);
			bb.writeDouble(rf_marbleColliderTransform._42);
			bb.writeDouble(rf_marbleColliderTransform._43);
			bb.writeDouble(rf_marbleColliderTransform._44);
			bb.writeDouble(rf_marblePrevPosition_x);
			bb.writeDouble(rf_marblePrevPosition_y);
			bb.writeDouble(rf_marblePrevPosition_z);
			bb.writeDouble(rf_marbleNextPosition_x);
			bb.writeDouble(rf_marbleNextPosition_y);
			bb.writeDouble(rf_marbleNextPosition_z);
			bb.writeDouble(rf_marblePhysicsAccmulator);
			bb.writeDouble(rf_marbleOrientation_x);
			bb.writeDouble(rf_marbleOrientation_y);
			bb.writeDouble(rf_marbleOrientation_z);
			bb.writeDouble(rf_marbleOrientation_w);
			bb.writeDouble(rf_marblePrevOrientation_x);
			bb.writeDouble(rf_marblePrevOrientation_y);
			bb.writeDouble(rf_marblePrevOrientation_z);
			bb.writeDouble(rf_marblePrevOrientation_w);
			bb.writeDouble(rf_marbleVelocity_x);
			bb.writeDouble(rf_marbleVelocity_y);
			bb.writeDouble(rf_marbleVelocity_z);
			bb.writeDouble(rf_marbleAngularVelocity_x);
			bb.writeDouble(rf_marbleAngularVelocity_y);
			bb.writeDouble(rf_marbleAngularVelocity_z);
			bb.writeInt16(this.allocGO(rf_marblePowerup));
			bb.writeDouble(rf_bonusTime);
			bb.writeInt16(rf_gemCount);
			bb.writeInt16(result.length);
			let _g8 = 0;
			while(_g8 < result.length) {
				let s = result[_g8];
				++_g8;
				bb.writeByte(s ? 1 : 0);
			}
			bb.writeInt16(rf_powerupStates.length);
			let _g9 = 0;
			while(_g9 < rf_powerupStates.length) {
				let s = rf_powerupStates[_g9];
				++_g9;
				bb.writeDouble(s);
			}
			bb.writeInt16(rf_landMineStates.length);
			let _g10 = 0;
			while(_g10 < rf_landMineStates.length) {
				let s = rf_landMineStates[_g10];
				++_g10;
				bb.writeDouble(s);
			}
			bb.writeDouble(rf_activePowerupStates_0);
			bb.writeDouble(rf_activePowerupStates_1);
			bb.writeDouble(rf_currentUp_x);
			bb.writeDouble(rf_currentUp_y);
			bb.writeDouble(rf_currentUp_z);
			bb.writeDouble(rf_lastContactNormal_x);
			bb.writeDouble(rf_lastContactNormal_y);
			bb.writeDouble(rf_lastContactNormal_z);
			bb.writeInt16(result1.length);
			let _g11 = 0;
			while(_g11 < result1.length) {
				let s = result1[_g11];
				++_g11;
				bb.writeDouble(s.currentTime);
				bb.writeDouble(s.targetTime);
				bb.writeByte(s.stoppedPosition == null ? 0 : 1);
				if(s.stoppedPosition != null) {
					bb.writeDouble(s.stoppedPosition.x);
					bb.writeDouble(s.stoppedPosition.y);
					bb.writeDouble(s.stoppedPosition.z);
				}
				bb.writeDouble(s.prevPosition.x);
				bb.writeDouble(s.prevPosition.y);
				bb.writeDouble(s.prevPosition.z);
				bb.writeDouble(s.position.x);
				bb.writeDouble(s.position.y);
				bb.writeDouble(s.position.z);
				bb.writeDouble(s.velocity.x);
				bb.writeDouble(s.velocity.y);
				bb.writeDouble(s.velocity.z);
			}
			bb.writeInt16(rf_trapdoorStates.length);
			let _g12 = 0;
			while(_g12 < rf_trapdoorStates.length) {
				let s = rf_trapdoorStates[_g12];
				++_g12;
				bb.writeDouble(s.lastContactTime);
				bb.writeByte(s.lastDirection);
				bb.writeDouble(s.lastCompletion);
			}
			bb.writeDouble(rf_blastAmt);
			bb.writeByte(rf_oobState_oob ? 1 : 0);
			if(rf_oobState_oob) {
				bb.writeDouble(rf_oobState_timeState.currentAttemptTime);
				bb.writeDouble(rf_oobState_timeState.timeSinceLoad);
				bb.writeDouble(rf_oobState_timeState.gameplayClock);
				bb.writeDouble(rf_oobState_timeState.dt);
			}
			bb.writeByte(rf_checkpointState.currentCheckpoint == null ? 0 : 1);
			if(rf_checkpointState.currentCheckpoint != null) {
				bb.writeInt16(this.allocGO(rf_checkpointState.currentCheckpoint));
			}
			bb.writeInt16(this.allocGO(rf_checkpointState.currentCheckpointTrigger));
			let chkgemcount = 0;
			let g = rf_checkpointState.checkpointCollectedGems.iterator();
			while(g.hasNext()) {
				g.next();
				++chkgemcount;
			}
			bb.writeInt16(chkgemcount);
			let gem1 = rf_checkpointState.checkpointCollectedGems.keys();
			while(gem1.hasNext()) {
				let gem = gem1.next();
				bb.writeInt16(this.allocGO(gem));
				bb.writeByte(rf_checkpointState.checkpointCollectedGems.h[gem.__id__] ? 1 : 0);
			}
			bb.writeInt16(this.allocGO(rf_checkpointState.checkpointHeldPowerup));
			bb.writeDouble(rf_checkpointState.checkpointBlast);
			bb.writeByte(rf_modeState == null ? 0 : 1);
			if(rf_modeState != null) {
				rf_modeState.serialize(this,bb);
			}
			let frameDataSerialized = bb.getBytes();
			this.frameSizes.push(frameDataSerialized.length);
			this.frameData.addBytes(frameDataSerialized,0,frameDataSerialized.length);
		}
	}
	applyFrame(rf) {
		this.timeAccumulator = rf.rewindAccumulator;
		this.level.timeState = rf.timeState.clone();
		let _this = this.level.marble.oldPos;
		let v = rf.marblePrevPosition;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
		_this.w = v.w;
		let _this1 = this.level.marble.newPos;
		let v1 = rf.marbleNextPosition;
		_this1.x = v1.x;
		_this1.y = v1.y;
		_this1.z = v1.z;
		_this1.w = v1.w;
		this.level.marble.collider.transform.load(rf.marbleColliderTransform);
		this.level.marble.physicsAccumulator = rf.marblePhysicsAccmulator;
		let _this2 = this.level.marble.prevRot;
		let q = rf.marblePrevOrientation;
		_this2.x = q.x;
		_this2.y = q.y;
		_this2.z = q.z;
		_this2.w = q.w;
		let _this3 = rf.marbleOrientation;
		this.level.marble.setRotationQuat(new h3d_Quat(_this3.x,_this3.y,_this3.z,_this3.w));
		let _this4 = this.level.marble.velocity;
		let v2 = rf.marbleVelocity;
		_this4.x = v2.x;
		_this4.y = v2.y;
		_this4.z = v2.z;
		_this4.w = v2.w;
		let _this5 = this.level.marble.omega;
		let v3 = rf.marbleAngularVelocity;
		_this5.x = v3.x;
		_this5.y = v3.y;
		_this5.z = v3.z;
		_this5.w = v3.w;
		if(this.level.marble.heldPowerup == null) {
			if(rf.marblePowerup != null) {
				this.level.pickUpPowerUp(this.level.marble,rf.marblePowerup);
			}
		} else if(rf.marblePowerup == null) {
			this.level.deselectPowerUp(this.level.marble);
		} else {
			this.level.pickUpPowerUp(this.level.marble,rf.marblePowerup);
		}
		this.level.bonusTime = rf.bonusTime;
		this.level.gemCount = rf.gemCount;
		this.level.playGui.formatGemCounter(this.level.gemCount,this.level.totalGems);
		let _g = 0;
		let _g1 = rf.gemStates.length;
		while(_g < _g1) {
			let i = _g++;
			this.level.gems[i].setHide(rf.gemStates[i]);
		}
		this.level.marble.helicopterEnableTime = rf.activePowerupStates[0];
		this.level.marble.megaMarbleEnableTime = rf.activePowerupStates[1];
		if(this.level.marble.currentUp.x != rf.currentUp.x || this.level.marble.currentUp.y != rf.currentUp.y || this.level.marble.currentUp.z != rf.currentUp.z) {
			this.level.setUp(this.level.marble,rf.currentUp,this.level.timeState);
			this.level.orientationChangeTime = this.level.timeState.currentAttemptTime - 300;
			let oldorient = this.level.newOrientationQuat;
			this.level.newOrientationQuat = this.level.oldOrientationQuat;
			this.level.oldOrientationQuat = oldorient;
		}
		let value = (this.level.timeState.currentAttemptTime - this.level.orientationChangeTime) / 300;
		let gravitycompletion = value < 0 ? 0 : value > 1 ? 1 : value;
		if(gravitycompletion == 0) {
			this.level.newOrientationQuat = this.level.oldOrientationQuat;
			this.level.orientationChangeTime = -1e8;
		}
		let _this6 = this.level.marble.currentUp;
		let v4 = rf.currentUp;
		_this6.x = v4.x;
		_this6.y = v4.y;
		_this6.z = v4.z;
		_this6.w = v4.w;
		let _this7 = this.level.marble.lastContactNormal;
		let v5 = rf.lastContactNormal;
		_this7.x = v5.x;
		_this7.y = v5.y;
		_this7.z = v5.z;
		_this7.w = v5.w;
		let _g2 = 0;
		let _g3 = rf.mpStates.length;
		while(_g2 < _g3) {
			let i = _g2++;
			this.level.pathedInteriors[i].currentTime = rf.mpStates[i].currentTime;
			this.level.pathedInteriors[i].targetTime = rf.mpStates[i].targetTime;
			let _this = this.level.pathedInteriors[i].velocity;
			let v = rf.mpStates[i].velocity;
			_this.x = v.x;
			_this.y = v.y;
			_this.z = v.z;
			_this.w = v.w;
			this.level.pathedInteriors[i].stopped = rf.mpStates[i].stoppedPosition != null;
			let _this1 = this.level.pathedInteriors[i].position;
			let v1 = rf.mpStates[i].position;
			_this1.x = v1.x;
			_this1.y = v1.y;
			_this1.z = v1.z;
			_this1.w = v1.w;
			let _this2 = this.level.pathedInteriors[i].prevPosition;
			let v2 = rf.mpStates[i].prevPosition;
			_this2.x = v2.x;
			_this2.y = v2.y;
			_this2.z = v2.z;
			_this2.w = v2.w;
			this.level.pathedInteriors[i].stoppedPosition = rf.mpStates[i].stoppedPosition;
			if(this.level.pathedInteriors[i].isCollideable) {
				let tform = this.level.pathedInteriors[i].getAbsPos().clone();
				let v = rf.mpStates[i].position;
				tform._41 = v.x;
				tform._42 = v.y;
				tform._43 = v.z;
				tform._44 = v.w;
				this.level.pathedInteriors[i].collider.setTransform(tform);
				this.level.collisionWorld.updateTransform(this.level.pathedInteriors[i].collider);
			}
		}
		let pstates = rf.powerupStates.slice();
		rf.landMineStates.slice();
		let tstates = rf.trapdoorStates.slice();
		let _g4 = 0;
		let _g5 = this.level.dtsObjects;
		while(_g4 < _g5.length) {
			let dts = _g5[_g4];
			++_g4;
			if(((dts) instanceof shapes_PowerUp)) {
				let pow = dts;
				pow.lastPickUpTime = pstates.shift();
			}
			if(((dts) instanceof shapes_Trapdoor)) {
				let td = dts;
				let tdState = tstates.shift();
				td.lastCompletion = tdState.lastCompletion;
				td.lastDirection = tdState.lastDirection;
				td.lastContactTime = tdState.lastContactTime;
			}
			if(((dts) instanceof shapes_AbstractBumper)) {
				let ab = dts;
				ab.lastContactTime = pstates.shift();
			}
		}
		if(!rf.oobState.oob) {
			this.level.cancel(this.level.oobSchedule);
			this.level.cancel(this.level.marble.oobSchedule);
		} else {
			this.level.goOutOfBounds(this.level.marble);
		}
		this.level.marble.outOfBounds = rf.oobState.oob;
		if(this.level.marble.outOfBounds) {
			this.level.playGui.setCenterText("Out of Bounds");
		} else {
			this.level.playGui.setCenterText("");
		}
		this.level.marble.camera.oob = rf.oobState.oob;
		let tmp = rf.oobState.timeState != null ? rf.oobState.timeState.clone() : null;
		this.level.marble.outOfBoundsTime = tmp;
		this.level.marble.blastAmount = rf.blastAmt;
		this.level.checkpointCollectedGems = rf.checkpointState.checkpointCollectedGems;
		this.level.cheeckpointBlast = rf.checkpointState.checkpointBlast;
		this.level.checkpointHeldPowerup = rf.checkpointState.checkpointHeldPowerup;
		this.level.currentCheckpoint = rf.checkpointState.currentCheckpoint;
		this.level.currentCheckpointTrigger = rf.checkpointState.currentCheckpointTrigger;
		if(rf.modeState != null) {
			rf.modeState.apply(this.level);
		}
	}
	getNextRewindFrame(absTime) {
		if(this.frameElapsedTimes.length == 0) {
			return null;
		}
		let topFrame = this.frameElapsedTimes[this.frameElapsedTimes.length - 1];
		while(topFrame > absTime) {
			if(this.frameElapsedTimes.length == 1) {
				return this.getFrameAtIndex(0);
			}
			this.popFrame();
			if(this.frameElapsedTimes.length == 0) {
				return null;
			}
			topFrame = this.frameElapsedTimes[this.frameElapsedTimes.length - 1];
		}
		return this.getFrameAtIndex(this.frameElapsedTimes.length - 1);
	}
	getFrameAtIndex(index) {
		let offset = this.frameDataOffsets[index];
		let size = this.frameSizes[index];
		let frameBytes = this.frameData.buffer.slice(offset,offset + size);
		let bi = new haxe_io_BytesInput(haxe_io_Bytes.ofData(frameBytes));
		let fr = new rewind_RewindFrame();
		fr.marbleColliderTransform = new h3d_Matrix();
		fr.marblePrevPosition = new h3d_Vector();
		fr.marbleNextPosition = new h3d_Vector();
		fr.marblePrevOrientation = new h3d_Quat();
		fr.marbleOrientation = new h3d_Quat();
		fr.marbleVelocity = new h3d_Vector();
		fr.marbleAngularVelocity = new h3d_Vector();
		fr.currentUp = new h3d_Vector();
		fr.lastContactNormal = new h3d_Vector();
		fr.timeState = new src_TimeState();
		fr.timeState.currentAttemptTime = bi.readDouble();
		fr.timeState.timeSinceLoad = bi.readDouble();
		fr.timeState.gameplayClock = bi.readDouble();
		fr.timeState.dt = bi.readDouble();
		fr.rewindAccumulator = bi.readDouble();
		fr.marbleColliderTransform._11 = bi.readDouble();
		fr.marbleColliderTransform._12 = bi.readDouble();
		fr.marbleColliderTransform._13 = bi.readDouble();
		fr.marbleColliderTransform._14 = bi.readDouble();
		fr.marbleColliderTransform._21 = bi.readDouble();
		fr.marbleColliderTransform._22 = bi.readDouble();
		fr.marbleColliderTransform._23 = bi.readDouble();
		fr.marbleColliderTransform._24 = bi.readDouble();
		fr.marbleColliderTransform._31 = bi.readDouble();
		fr.marbleColliderTransform._32 = bi.readDouble();
		fr.marbleColliderTransform._33 = bi.readDouble();
		fr.marbleColliderTransform._34 = bi.readDouble();
		fr.marbleColliderTransform._41 = bi.readDouble();
		fr.marbleColliderTransform._42 = bi.readDouble();
		fr.marbleColliderTransform._43 = bi.readDouble();
		fr.marbleColliderTransform._44 = bi.readDouble();
		fr.marblePrevPosition.x = bi.readDouble();
		fr.marblePrevPosition.y = bi.readDouble();
		fr.marblePrevPosition.z = bi.readDouble();
		fr.marbleNextPosition.x = bi.readDouble();
		fr.marbleNextPosition.y = bi.readDouble();
		fr.marbleNextPosition.z = bi.readDouble();
		fr.marblePhysicsAccmulator = bi.readDouble();
		fr.marbleOrientation.x = bi.readDouble();
		fr.marbleOrientation.y = bi.readDouble();
		fr.marbleOrientation.z = bi.readDouble();
		fr.marbleOrientation.w = bi.readDouble();
		fr.marblePrevOrientation.x = bi.readDouble();
		fr.marblePrevOrientation.y = bi.readDouble();
		fr.marblePrevOrientation.z = bi.readDouble();
		fr.marblePrevOrientation.w = bi.readDouble();
		fr.marbleVelocity.x = bi.readDouble();
		fr.marbleVelocity.y = bi.readDouble();
		fr.marbleVelocity.z = bi.readDouble();
		fr.marbleAngularVelocity.x = bi.readDouble();
		fr.marbleAngularVelocity.y = bi.readDouble();
		fr.marbleAngularVelocity.z = bi.readDouble();
		fr.marblePowerup = this.getGO(bi.readInt16());
		fr.bonusTime = bi.readDouble();
		fr.gemCount = bi.readInt16();
		fr.gemStates = [];
		let gemStates_len = bi.readInt16();
		let _g = 0;
		while(_g < gemStates_len) {
			++_g;
			fr.gemStates.push(bi.readByte() != 0);
		}
		fr.powerupStates = [];
		let powerupStates_len = bi.readInt16();
		let _g1 = 0;
		while(_g1 < powerupStates_len) {
			++_g1;
			fr.powerupStates.push(bi.readDouble());
		}
		fr.landMineStates = [];
		let landMineStates_len = bi.readInt16();
		let _g2 = 0;
		while(_g2 < landMineStates_len) {
			++_g2;
			fr.landMineStates.push(bi.readDouble());
		}
		fr.activePowerupStates = [];
		fr.activePowerupStates.push(bi.readDouble());
		fr.activePowerupStates.push(bi.readDouble());
		fr.currentUp.x = bi.readDouble();
		fr.currentUp.y = bi.readDouble();
		fr.currentUp.z = bi.readDouble();
		fr.lastContactNormal.x = bi.readDouble();
		fr.lastContactNormal.y = bi.readDouble();
		fr.lastContactNormal.z = bi.readDouble();
		fr.mpStates = [];
		let mpStates_len = bi.readInt16();
		let _g3 = 0;
		while(_g3 < mpStates_len) {
			++_g3;
			let mpStates_item = new rewind_RewindMPState();
			mpStates_item.currentTime = bi.readDouble();
			mpStates_item.targetTime = bi.readDouble();
			mpStates_item.stoppedPosition = new h3d_Vector();
			mpStates_item.prevPosition = new h3d_Vector();
			mpStates_item.position = new h3d_Vector();
			mpStates_item.velocity = new h3d_Vector();
			if(bi.readByte() != 0) {
				mpStates_item.stoppedPosition.x = bi.readDouble();
				mpStates_item.stoppedPosition.y = bi.readDouble();
				mpStates_item.stoppedPosition.z = bi.readDouble();
			} else {
				mpStates_item.stoppedPosition = null;
			}
			mpStates_item.prevPosition.x = bi.readDouble();
			mpStates_item.prevPosition.y = bi.readDouble();
			mpStates_item.prevPosition.z = bi.readDouble();
			mpStates_item.position.x = bi.readDouble();
			mpStates_item.position.y = bi.readDouble();
			mpStates_item.position.z = bi.readDouble();
			mpStates_item.velocity.x = bi.readDouble();
			mpStates_item.velocity.y = bi.readDouble();
			mpStates_item.velocity.z = bi.readDouble();
			fr.mpStates.push(mpStates_item);
		}
		fr.trapdoorStates = [];
		let trapdoorStates_len = bi.readInt16();
		let _g4 = 0;
		while(_g4 < trapdoorStates_len) {
			++_g4;
			let trapdoorStates_item = { lastContactTime : 0.0, lastDirection : 0, lastCompletion : 0.0};
			trapdoorStates_item.lastContactTime = bi.readDouble();
			trapdoorStates_item.lastDirection = bi.readByte();
			trapdoorStates_item.lastCompletion = bi.readDouble();
			fr.trapdoorStates.push(trapdoorStates_item);
		}
		fr.blastAmt = bi.readDouble();
		fr.oobState = { oob : bi.readByte() != 0, timeState : null};
		if(fr.oobState.oob) {
			fr.oobState.timeState = new src_TimeState();
			fr.oobState.timeState.currentAttemptTime = bi.readDouble();
			fr.oobState.timeState.timeSinceLoad = bi.readDouble();
			fr.oobState.timeState.gameplayClock = bi.readDouble();
			fr.oobState.timeState.dt = bi.readDouble();
		}
		let hasCheckpoint = bi.readByte() != 0;
		fr.checkpointState = { currentCheckpoint : null, currentCheckpointTrigger : null, checkpointCollectedGems : new haxe_ds_ObjectMap(), checkpointHeldPowerup : null, checkpointBlast : 0.0};
		if(hasCheckpoint) {
			let co = this.getGO(bi.readInt16());
			fr.checkpointState.currentCheckpoint = co;
		}
		let tmp = bi.readInt16();
		fr.checkpointState.currentCheckpointTrigger = this.getGO(tmp);
		let checkpointState_checkpointCollectedGems_len = bi.readInt16();
		let _g5 = 0;
		while(_g5 < checkpointState_checkpointCollectedGems_len) {
			++_g5;
			let gem = this.getGO(bi.readInt16());
			let c = bi.readByte() != 0;
			fr.checkpointState.checkpointCollectedGems.set(gem,c);
		}
		let tmp1 = bi.readInt16();
		fr.checkpointState.checkpointHeldPowerup = this.getGO(tmp1);
		fr.checkpointState.checkpointBlast = bi.readDouble();
		let hasModeState = bi.readByte() != 0;
		if(hasModeState) {
			fr.modeState = this.level.gameMode.constructRewindState();
			fr.modeState.deserialize(this,bi);
		}
		return fr;
	}
	popFrame() {
		this.frameElapsedTimes.pop();
		let offset = this.frameDataOffsets[this.frameDataOffsets.length - 1];
		this.frameData.pos = offset;
		this.frameDataOffsets.pop();
		this.frameSizes.pop();
	}
	allocGO(go) {
		if(go == null) {
			return -1;
		}
		if(this.allocObjMap.h.__keys__[go.__id__] != null) {
			return this.allocObjMap.h[go.__id__];
		}
		let newId = this.allocId++;
		this.allocObjMap.set(go,newId);
		this.allocObjs.push(go);
		return newId;
	}
	getGO(id) {
		if(id == -1) {
			return null;
		}
		return this.allocObjs[id];
	}
	clear() {
		this.frameData = new haxe_io_BytesBuffer();
		this.frameDataOffsets = [];
		this.frameElapsedTimes = [];
		this.frameSizes = [];
		this.allocObjs = [];
		this.allocObjMap = new haxe_ds_ObjectMap();
		this.allocMes = [];
		this.allocMeMap = new haxe_ds_ObjectMap();
		this.allocId = 0;
		this.allocMeId = 0;
		this.timeAccumulator = 0.0;
	}
}
$hxClasses["rewind.RewindManager"] = rewind_RewindManager;
rewind_RewindManager.__name__ = "rewind.RewindManager";
Object.assign(rewind_RewindManager.prototype, {
	__class__: rewind_RewindManager
	,frameData: null
	,frameElapsedTimes: null
	,frameDataOffsets: null
	,frameSizes: null
	,allocObjMap: null
	,allocObjs: null
	,allocMeMap: null
	,allocMes: null
	,level: null
	,allocId: null
	,allocMeId: null
	,timeScale: null
	,timeAccumulator: null
	,saveResolution: null
});
class shaders_Billboard extends hxsl_Shader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.color__ = new h3d_Vector();
		this.rotation__ = 0;
		this.scale__ = 0;
		super._hx_constructor();
	}
	get_scale() {
		return this.scale__;
	}
	set_scale(_v) {
		return this.scale__ = _v;
	}
	get_rotation() {
		return this.rotation__;
	}
	set_rotation(_v) {
		return this.rotation__ = _v;
	}
	get_color() {
		return this.color__;
	}
	set_color(_v) {
		return this.color__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.scale__;
		case 1:
			return this.rotation__;
		case 2:
			return this.color__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 0:
			return this.scale__;
		case 1:
			return this.rotation__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_Billboard.prototype);
		s.shader = this.shader;
		s.scale__ = this.scale__;
		s.rotation__ = this.rotation__;
		s.color__ = this.color__;
		return s;
	}
}
$hxClasses["shaders.Billboard"] = shaders_Billboard;
shaders_Billboard.__name__ = "shaders.Billboard";
shaders_Billboard.__super__ = hxsl_Shader;
Object.assign(shaders_Billboard.prototype, {
	__class__: shaders_Billboard
	,scale__: null
	,rotation__: null
	,color__: null
});
class shaders_Blur extends h3d_shader_ScreenShader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.divisor__ = 0;
		this.kernel__ = [];
		super._hx_constructor();
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	get_kernel() {
		return this.kernel__;
	}
	set_kernel(_v) {
		return this.kernel__ = _v;
	}
	get_divisor() {
		return this.divisor__;
	}
	set_divisor(_v) {
		return this.divisor__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.kernel__;
		case 3:
			return this.divisor__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 3:
			return this.divisor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_Blur.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		s.kernel__ = this.kernel__;
		s.divisor__ = this.divisor__;
		return s;
	}
}
$hxClasses["shaders.Blur"] = shaders_Blur;
shaders_Blur.__name__ = "shaders.Blur";
shaders_Blur.__super__ = h3d_shader_ScreenShader;
Object.assign(shaders_Blur.prototype, {
	__class__: shaders_Blur
	,texture__: null
	,kernel__: null
	,divisor__: null
});
class shaders_CubemapRenderer {
	constructor(scene,sky,useSky) {
		if(useSky == null) {
			useSky = false;
		}
		this.usingSky = false;
		this.lastRenderTime = 0;
		this.updateFps = 360.0;
		this.facesPerRender = 2;
		this.scene = scene;
		this.sky = sky;
		this.usingSky = useSky;
		if(useSky) {
			this.cubemap = sky.cubemap;
		} else {
			this.cubemap = new h3d_mat_Texture(128,128,[h3d_mat_TextureFlags.Cube,h3d_mat_TextureFlags.Dynamic,h3d_mat_TextureFlags.Target],hxd_PixelFormat.RGBA);
			this.cubemap.depthBuffer = new h3d_mat_DepthBuffer(128,128,h3d_mat_DepthFormat.Depth16);
		}
		this.camera = new h3d_Camera(90,1,1,0.1,1000);
		this.position = new h3d_Vector();
		this.nextFaceToRender = 0;
	}
	render(e) {
		if(this.usingSky) {
			return;
		}
		let start = HxOverrides.now() / 1000;
		if(start - this.lastRenderTime > this.facesPerRender * 1.0 / this.updateFps) {
			this.lastRenderTime = start;
		} else {
			return;
		}
		let scenecam = this.scene.camera;
		this.scene.camera = this.camera;
		let renderedFaces = 0;
		src_Renderer.cubemapPass = true;
		let _g = 0;
		let _g1 = this.facesPerRender;
		while(_g < _g1) {
			let i = _g++;
			let index = (this.nextFaceToRender + i) % 6;
			if(src_Settings.optionsSettings.reflectionDetail >= 4) {
				src_Renderer.dirtyBuffers = true;
			}
			e.pushTarget(this.cubemap,index);
			js_Boot.__cast(this.scene.renderer , src_Renderer);
			this.camera.setCubeMap(index,this.position);
			this.camera.update();
			e.clear(0,1);
			this.scene.render(e);
			e.popTarget();
			++renderedFaces;
			let time = HxOverrides.now() / 1000;
			let elapsed = time - start;
			let elapsedPerFace = elapsed / renderedFaces;
			if(elapsedPerFace * (renderedFaces + 1) >= 0.002) {
				break;
			}
		}
		src_Renderer.cubemapPass = false;
		this.scene.camera = scenecam;
		this.nextFaceToRender = (this.nextFaceToRender += renderedFaces) % 6;
	}
	getCameraFrustums() {
		let frustums = [];
		let prevFar = this.camera.zFar;
		this.camera.zFar = 300;
		this.camera.setCubeMap(0,this.position);
		this.camera.update();
		frustums.push(this.camera.frustum.clone());
		this.camera.setCubeMap(1,this.position);
		this.camera.update();
		frustums.push(this.camera.frustum.clone());
		this.camera.setCubeMap(2,this.position);
		this.camera.update();
		frustums.push(this.camera.frustum.clone());
		this.camera.setCubeMap(3,this.position);
		this.camera.update();
		frustums.push(this.camera.frustum.clone());
		this.camera.setCubeMap(4,this.position);
		this.camera.update();
		frustums.push(this.camera.frustum.clone());
		this.camera.setCubeMap(5,this.position);
		this.camera.update();
		frustums.push(this.camera.frustum.clone());
		this.camera.zFar = prevFar;
		return frustums;
	}
}
$hxClasses["shaders.CubemapRenderer"] = shaders_CubemapRenderer;
shaders_CubemapRenderer.__name__ = "shaders.CubemapRenderer";
Object.assign(shaders_CubemapRenderer.prototype, {
	__class__: shaders_CubemapRenderer
	,cubemap: null
	,sky: null
	,position: null
	,camera: null
	,scene: null
	,nextFaceToRender: null
	,facesPerRender: null
	,updateFps: null
	,lastRenderTime: null
	,usingSky: null
});
class shaders_DefaultCubemapMaterial extends hxsl_Shader {
	constructor(diffuse,normal,shininess,specularColor,secondaryMapUvFactor,skybox) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,normal,shininess,specularColor,secondaryMapUvFactor,skybox);
	}
	_hx_constructor(diffuse,normal,shininess,specularColor,secondaryMapUvFactor,skybox) {
		this.secondaryMapUvFactor__ = 0;
		this.shininess__ = 0;
		this.specularColor__ = new h3d_Vector();
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.cubeMap__ = skybox;
		this.normalMap__ = normal;
		this.shininess__ = shininess;
		this.specularColor__ = specularColor;
		this.secondaryMapUvFactor__ = secondaryMapUvFactor;
		this.constModified = true;
		this.doGammaRamp__ = true;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	get_normalMap() {
		return this.normalMap__;
	}
	set_normalMap(_v) {
		return this.normalMap__ = _v;
	}
	get_cubeMap() {
		return this.cubeMap__;
	}
	set_cubeMap(_v) {
		return this.cubeMap__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	get_secondaryMapUvFactor() {
		return this.secondaryMapUvFactor__;
	}
	set_secondaryMapUvFactor(_v) {
		return this.secondaryMapUvFactor__ = _v;
	}
	get_doGammaRamp() {
		return this.doGammaRamp__;
	}
	set_doGammaRamp(_v) {
		this.constModified = true;
		return this.doGammaRamp__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.doGammaRamp__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.specularColor__;
		case 2:
			return this.normalMap__;
		case 3:
			return this.cubeMap__;
		case 4:
			return this.shininess__;
		case 5:
			return this.secondaryMapUvFactor__;
		case 6:
			return this.doGammaRamp__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 4:
			return this.shininess__;
		case 5:
			return this.secondaryMapUvFactor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_DefaultCubemapMaterial.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.specularColor__ = this.specularColor__;
		s.normalMap__ = this.normalMap__;
		s.cubeMap__ = this.cubeMap__;
		s.shininess__ = this.shininess__;
		s.secondaryMapUvFactor__ = this.secondaryMapUvFactor__;
		s.doGammaRamp__ = this.doGammaRamp__;
		return s;
	}
}
$hxClasses["shaders.DefaultCubemapMaterial"] = shaders_DefaultCubemapMaterial;
shaders_DefaultCubemapMaterial.__name__ = "shaders.DefaultCubemapMaterial";
shaders_DefaultCubemapMaterial.__super__ = hxsl_Shader;
Object.assign(shaders_DefaultCubemapMaterial.prototype, {
	__class__: shaders_DefaultCubemapMaterial
	,diffuseMap__: null
	,specularColor__: null
	,normalMap__: null
	,cubeMap__: null
	,shininess__: null
	,secondaryMapUvFactor__: null
	,doGammaRamp__: null
});
class shaders_DefaultCubemapNormalMaterial extends hxsl_Shader {
	constructor(diffuse,cubeMap,shininess,specularColor,secondaryMapUvFactor) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,cubeMap,shininess,specularColor,secondaryMapUvFactor);
	}
	_hx_constructor(diffuse,cubeMap,shininess,specularColor,secondaryMapUvFactor) {
		this.secondaryMapUvFactor__ = 0;
		this.shininess__ = 0;
		this.specularColor__ = new h3d_Vector();
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.cubeMap__ = cubeMap;
		this.shininess__ = shininess;
		this.specularColor__ = specularColor;
		this.secondaryMapUvFactor__ = secondaryMapUvFactor;
		this.constModified = true;
		this.doGammaRamp__ = true;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	get_secondaryMapUvFactor() {
		return this.secondaryMapUvFactor__;
	}
	set_secondaryMapUvFactor(_v) {
		return this.secondaryMapUvFactor__ = _v;
	}
	get_cubeMap() {
		return this.cubeMap__;
	}
	set_cubeMap(_v) {
		return this.cubeMap__ = _v;
	}
	get_doGammaRamp() {
		return this.doGammaRamp__;
	}
	set_doGammaRamp(_v) {
		this.constModified = true;
		return this.doGammaRamp__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.doGammaRamp__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.specularColor__;
		case 2:
			return this.shininess__;
		case 3:
			return this.secondaryMapUvFactor__;
		case 4:
			return this.cubeMap__;
		case 5:
			return this.doGammaRamp__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 2:
			return this.shininess__;
		case 3:
			return this.secondaryMapUvFactor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_DefaultCubemapNormalMaterial.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.specularColor__ = this.specularColor__;
		s.shininess__ = this.shininess__;
		s.secondaryMapUvFactor__ = this.secondaryMapUvFactor__;
		s.cubeMap__ = this.cubeMap__;
		s.doGammaRamp__ = this.doGammaRamp__;
		return s;
	}
}
$hxClasses["shaders.DefaultCubemapNormalMaterial"] = shaders_DefaultCubemapNormalMaterial;
shaders_DefaultCubemapNormalMaterial.__name__ = "shaders.DefaultCubemapNormalMaterial";
shaders_DefaultCubemapNormalMaterial.__super__ = hxsl_Shader;
Object.assign(shaders_DefaultCubemapNormalMaterial.prototype, {
	__class__: shaders_DefaultCubemapNormalMaterial
	,diffuseMap__: null
	,specularColor__: null
	,shininess__: null
	,secondaryMapUvFactor__: null
	,cubeMap__: null
	,doGammaRamp__: null
});
class shaders_DefaultCubemapNormalNoSpecMaterial extends hxsl_Shader {
	constructor(diffuse,secondaryMapUvFactor,skybox) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,secondaryMapUvFactor,skybox);
	}
	_hx_constructor(diffuse,secondaryMapUvFactor,skybox) {
		this.secondaryMapUvFactor__ = 0;
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.cubeMap__ = skybox;
		this.secondaryMapUvFactor__ = secondaryMapUvFactor;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_cubeMap() {
		return this.cubeMap__;
	}
	set_cubeMap(_v) {
		return this.cubeMap__ = _v;
	}
	get_secondaryMapUvFactor() {
		return this.secondaryMapUvFactor__;
	}
	set_secondaryMapUvFactor(_v) {
		return this.secondaryMapUvFactor__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.cubeMap__;
		case 2:
			return this.secondaryMapUvFactor__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 2) {
			return this.secondaryMapUvFactor__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_DefaultCubemapNormalNoSpecMaterial.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.cubeMap__ = this.cubeMap__;
		s.secondaryMapUvFactor__ = this.secondaryMapUvFactor__;
		return s;
	}
}
$hxClasses["shaders.DefaultCubemapNormalNoSpecMaterial"] = shaders_DefaultCubemapNormalNoSpecMaterial;
shaders_DefaultCubemapNormalNoSpecMaterial.__name__ = "shaders.DefaultCubemapNormalNoSpecMaterial";
shaders_DefaultCubemapNormalNoSpecMaterial.__super__ = hxsl_Shader;
Object.assign(shaders_DefaultCubemapNormalNoSpecMaterial.prototype, {
	__class__: shaders_DefaultCubemapNormalNoSpecMaterial
	,diffuseMap__: null
	,cubeMap__: null
	,secondaryMapUvFactor__: null
});
class shaders_DefaultDiffuseMaterial extends hxsl_Shader {
	constructor(diffuse) {
		super();
		this.diffuseMap__ = diffuse;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.diffuseMap__;
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_DefaultDiffuseMaterial.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		return s;
	}
}
$hxClasses["shaders.DefaultDiffuseMaterial"] = shaders_DefaultDiffuseMaterial;
shaders_DefaultDiffuseMaterial.__name__ = "shaders.DefaultDiffuseMaterial";
shaders_DefaultDiffuseMaterial.__super__ = hxsl_Shader;
Object.assign(shaders_DefaultDiffuseMaterial.prototype, {
	__class__: shaders_DefaultDiffuseMaterial
	,diffuseMap__: null
});
class shaders_DefaultMaterial extends hxsl_Shader {
	constructor(diffuse,normal,shininess,specularColor,secondaryMapUvFactor,isHalfTile) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,normal,shininess,specularColor,secondaryMapUvFactor,isHalfTile);
	}
	_hx_constructor(diffuse,normal,shininess,specularColor,secondaryMapUvFactor,isHalfTile) {
		if(isHalfTile == null) {
			isHalfTile = false;
		}
		this.secondaryMapUvFactor__ = 0;
		this.shininess__ = 0;
		this.specularColor__ = new h3d_Vector();
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.normalMap__ = normal;
		this.shininess__ = shininess;
		this.specularColor__ = specularColor;
		this.secondaryMapUvFactor__ = secondaryMapUvFactor;
		this.constModified = true;
		this.isHalfTile__ = isHalfTile;
		this.constModified = true;
		this.doGammaRamp__ = true;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	get_normalMap() {
		return this.normalMap__;
	}
	set_normalMap(_v) {
		return this.normalMap__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	get_secondaryMapUvFactor() {
		return this.secondaryMapUvFactor__;
	}
	set_secondaryMapUvFactor(_v) {
		return this.secondaryMapUvFactor__ = _v;
	}
	get_isHalfTile() {
		return this.isHalfTile__;
	}
	set_isHalfTile(_v) {
		this.constModified = true;
		return this.isHalfTile__ = _v;
	}
	get_doGammaRamp() {
		return this.doGammaRamp__;
	}
	set_doGammaRamp(_v) {
		this.constModified = true;
		return this.doGammaRamp__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.isHalfTile__) {
			this.constBits |= 1;
		}
		if(this.doGammaRamp__) {
			this.constBits |= 2;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.specularColor__;
		case 2:
			return this.normalMap__;
		case 3:
			return this.shininess__;
		case 4:
			return this.secondaryMapUvFactor__;
		case 5:
			return this.isHalfTile__;
		case 6:
			return this.doGammaRamp__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 3:
			return this.shininess__;
		case 4:
			return this.secondaryMapUvFactor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_DefaultMaterial.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.specularColor__ = this.specularColor__;
		s.normalMap__ = this.normalMap__;
		s.shininess__ = this.shininess__;
		s.secondaryMapUvFactor__ = this.secondaryMapUvFactor__;
		s.isHalfTile__ = this.isHalfTile__;
		s.doGammaRamp__ = this.doGammaRamp__;
		return s;
	}
}
$hxClasses["shaders.DefaultMaterial"] = shaders_DefaultMaterial;
shaders_DefaultMaterial.__name__ = "shaders.DefaultMaterial";
shaders_DefaultMaterial.__super__ = hxsl_Shader;
Object.assign(shaders_DefaultMaterial.prototype, {
	__class__: shaders_DefaultMaterial
	,diffuseMap__: null
	,specularColor__: null
	,normalMap__: null
	,shininess__: null
	,secondaryMapUvFactor__: null
	,isHalfTile__: null
	,doGammaRamp__: null
});
class shaders_DefaultNormalMaterial extends hxsl_Shader {
	constructor(diffuse,shininess,specularColor,secondaryMapUvFactor) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,shininess,specularColor,secondaryMapUvFactor);
	}
	_hx_constructor(diffuse,shininess,specularColor,secondaryMapUvFactor) {
		this.secondaryMapUvFactor__ = 0;
		this.shininess__ = 0;
		this.specularColor__ = new h3d_Vector();
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.shininess__ = shininess;
		this.specularColor__ = specularColor;
		this.secondaryMapUvFactor__ = secondaryMapUvFactor;
		this.constModified = true;
		this.doGammaRamp__ = true;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	get_secondaryMapUvFactor() {
		return this.secondaryMapUvFactor__;
	}
	set_secondaryMapUvFactor(_v) {
		return this.secondaryMapUvFactor__ = _v;
	}
	get_doGammaRamp() {
		return this.doGammaRamp__;
	}
	set_doGammaRamp(_v) {
		this.constModified = true;
		return this.doGammaRamp__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.doGammaRamp__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.specularColor__;
		case 2:
			return this.shininess__;
		case 3:
			return this.secondaryMapUvFactor__;
		case 4:
			return this.doGammaRamp__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 2:
			return this.shininess__;
		case 3:
			return this.secondaryMapUvFactor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_DefaultNormalMaterial.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.specularColor__ = this.specularColor__;
		s.shininess__ = this.shininess__;
		s.secondaryMapUvFactor__ = this.secondaryMapUvFactor__;
		s.doGammaRamp__ = this.doGammaRamp__;
		return s;
	}
}
$hxClasses["shaders.DefaultNormalMaterial"] = shaders_DefaultNormalMaterial;
shaders_DefaultNormalMaterial.__name__ = "shaders.DefaultNormalMaterial";
shaders_DefaultNormalMaterial.__super__ = hxsl_Shader;
Object.assign(shaders_DefaultNormalMaterial.prototype, {
	__class__: shaders_DefaultNormalMaterial
	,diffuseMap__: null
	,specularColor__: null
	,shininess__: null
	,secondaryMapUvFactor__: null
	,doGammaRamp__: null
});
class shaders_DirLight extends h3d_scene_fwd_Light {
	constructor(dir,parent) {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(dir,parent);
	}
	_hx_constructor(dir,parent) {
		this.dshader = new shaders_DirLightShader();
		super._hx_constructor(this.dshader,parent);
		this.priority = 100;
		this.direction = dir;
		if(dir != null) {
			this.setDirection(dir);
		}
	}
	set_color(v) {
		return this.dshader.color__ = v;
	}
	getShadowDirection() {
		if(src_MarbleGame.instance.world == null || src_MarbleGame.instance.world.marble == null) {
			return new h3d_Vector(0,0,-1);
		}
		let _this = src_MarbleGame.instance.world.marble.currentUp;
		return new h3d_Vector(_this.x * -1,_this.y * -1,_this.z * -1,_this.w);
	}
	emit(ctx) {
		let _this = this.dshader.direction__;
		let _this1 = this.absPos;
		let x = _this1._11;
		let y = _this1._12;
		let z = _this1._13;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let v_x = x;
		let v_y = y;
		let v_z = z;
		let k = v_x * v_x + v_y * v_y + v_z * v_z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		v_x *= k;
		v_y *= k;
		v_z *= k;
		_this.x = v_x;
		_this.y = v_y;
		_this.z = v_z;
		_this.w = 1.;
		let _this2 = this.dshader.direction__;
		let k1 = _this2.x * _this2.x + _this2.y * _this2.y + _this2.z * _this2.z;
		if(k1 < 1e-10) {
			k1 = 0;
		} else {
			k1 = 1. / Math.sqrt(k1);
		}
		_this2.x *= k1;
		_this2.y *= k1;
		_this2.z *= k1;
		super.emit(ctx);
	}
}
$hxClasses["shaders.DirLight"] = shaders_DirLight;
shaders_DirLight.__name__ = "shaders.DirLight";
shaders_DirLight.__super__ = h3d_scene_fwd_Light;
Object.assign(shaders_DirLight.prototype, {
	__class__: shaders_DirLight
	,dshader: null
	,direction: null
});
class shaders_DirLightShader extends hxsl_Shader {
	constructor() {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.direction__ = new h3d_Vector();
		this.color__ = new h3d_Vector();
		super._hx_constructor();
		let _this = this.color__;
		_this.x = 1;
		_this.y = 1;
		_this.z = 1;
		_this.w = 1.;
	}
	get_color() {
		return this.color__;
	}
	set_color(_v) {
		return this.color__ = _v;
	}
	get_direction() {
		return this.direction__;
	}
	set_direction(_v) {
		return this.direction__ = _v;
	}
	get_enableSpecular() {
		return this.enableSpecular__;
	}
	set_enableSpecular(_v) {
		this.constModified = true;
		return this.enableSpecular__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.enableSpecular__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.color__;
		case 1:
			return this.direction__;
		case 2:
			return this.enableSpecular__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_DirLightShader.prototype);
		s.shader = this.shader;
		s.color__ = this.color__;
		s.direction__ = this.direction__;
		s.enableSpecular__ = this.enableSpecular__;
		return s;
	}
}
$hxClasses["shaders.DirLightShader"] = shaders_DirLightShader;
shaders_DirLightShader.__name__ = "shaders.DirLightShader";
shaders_DirLightShader.__super__ = hxsl_Shader;
Object.assign(shaders_DirLightShader.prototype, {
	__class__: shaders_DirLightShader
	,color__: null
	,direction__: null
	,enableSpecular__: null
});
class shaders_DtsTexture extends hxsl_Shader {
	constructor(tex) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(tex);
	}
	_hx_constructor(tex) {
		this.currentOpacity__ = 0;
		this.killAlphaThreshold__ = 0;
		super._hx_constructor();
		this.texture__ = tex;
		this.killAlphaThreshold__ = h3d_mat_Defaults.defaultKillAlphaThreshold;
		this.constModified = true;
		this.normalizeNormals__ = true;
	}
	get_additive() {
		return this.additive__;
	}
	set_additive(_v) {
		this.constModified = true;
		return this.additive__ = _v;
	}
	get_killAlpha() {
		return this.killAlpha__;
	}
	set_killAlpha(_v) {
		this.constModified = true;
		return this.killAlpha__ = _v;
	}
	get_specularAlpha() {
		return this.specularAlpha__;
	}
	set_specularAlpha(_v) {
		this.constModified = true;
		return this.specularAlpha__ = _v;
	}
	get_killAlphaThreshold() {
		return this.killAlphaThreshold__;
	}
	set_killAlphaThreshold(_v) {
		return this.killAlphaThreshold__ = _v;
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	get_normalizeNormals() {
		return this.normalizeNormals__;
	}
	set_normalizeNormals(_v) {
		this.constModified = true;
		return this.normalizeNormals__ = _v;
	}
	get_passThrough() {
		return this.passThrough__;
	}
	set_passThrough(_v) {
		this.constModified = true;
		return this.passThrough__ = _v;
	}
	get_currentOpacity() {
		return this.currentOpacity__;
	}
	set_currentOpacity(_v) {
		return this.currentOpacity__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.additive__) {
			this.constBits |= 1;
		}
		if(this.killAlpha__) {
			this.constBits |= 2;
		}
		if(this.specularAlpha__) {
			this.constBits |= 4;
		}
		if(this.normalizeNormals__) {
			this.constBits |= 8;
		}
		if(this.passThrough__) {
			this.constBits |= 16;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.additive__;
		case 1:
			return this.killAlpha__;
		case 2:
			return this.specularAlpha__;
		case 3:
			return this.killAlphaThreshold__;
		case 4:
			return this.texture__;
		case 5:
			return this.normalizeNormals__;
		case 6:
			return this.passThrough__;
		case 7:
			return this.currentOpacity__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 3:
			return this.killAlphaThreshold__;
		case 7:
			return this.currentOpacity__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_DtsTexture.prototype);
		s.shader = this.shader;
		s.additive__ = this.additive__;
		s.killAlpha__ = this.killAlpha__;
		s.specularAlpha__ = this.specularAlpha__;
		s.killAlphaThreshold__ = this.killAlphaThreshold__;
		s.texture__ = this.texture__;
		s.normalizeNormals__ = this.normalizeNormals__;
		s.passThrough__ = this.passThrough__;
		s.currentOpacity__ = this.currentOpacity__;
		return s;
	}
}
$hxClasses["shaders.DtsTexture"] = shaders_DtsTexture;
shaders_DtsTexture.__name__ = "shaders.DtsTexture";
shaders_DtsTexture.__super__ = hxsl_Shader;
Object.assign(shaders_DtsTexture.prototype, {
	__class__: shaders_DtsTexture
	,additive__: null
	,killAlpha__: null
	,specularAlpha__: null
	,killAlphaThreshold__: null
	,texture__: null
	,normalizeNormals__: null
	,passThrough__: null
	,currentOpacity__: null
});
class shaders_EnvMap extends hxsl_Shader {
	constructor(skybox,shininess) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(skybox,shininess);
	}
	_hx_constructor(skybox,shininess) {
		this.shininess__ = 0;
		super._hx_constructor();
		this.envMap__ = skybox;
		this.shininess__ = shininess;
	}
	get_envMap() {
		return this.envMap__;
	}
	set_envMap(_v) {
		return this.envMap__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.envMap__;
		case 1:
			return this.shininess__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 1) {
			return this.shininess__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_EnvMap.prototype);
		s.shader = this.shader;
		s.envMap__ = this.envMap__;
		s.shininess__ = this.shininess__;
		return s;
	}
}
$hxClasses["shaders.EnvMap"] = shaders_EnvMap;
shaders_EnvMap.__name__ = "shaders.EnvMap";
shaders_EnvMap.__super__ = hxsl_Shader;
Object.assign(shaders_EnvMap.prototype, {
	__class__: shaders_EnvMap
	,envMap__: null
	,shininess__: null
});
class shaders_GammaRamp extends h3d_shader_ScreenShader {
	constructor(texture) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(texture);
	}
	_hx_constructor(texture) {
		this.gammaRampInvSize__ = 0.0009765625;
		super._hx_constructor();
		this.texture__ = texture;
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	get_gammaRampInvSize() {
		return this.gammaRampInvSize__;
	}
	set_gammaRampInvSize(_v) {
		return this.gammaRampInvSize__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 1:
			return this.texture__;
		case 2:
			return this.gammaRampInvSize__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 0:
			return this.flipY__;
		case 2:
			return this.gammaRampInvSize__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_GammaRamp.prototype);
		s.shader = this.shader;
		s.flipY__ = this.flipY__;
		s.texture__ = this.texture__;
		s.gammaRampInvSize__ = this.gammaRampInvSize__;
		return s;
	}
}
$hxClasses["shaders.GammaRamp"] = shaders_GammaRamp;
shaders_GammaRamp.__name__ = "shaders.GammaRamp";
shaders_GammaRamp.__super__ = h3d_shader_ScreenShader;
Object.assign(shaders_GammaRamp.prototype, {
	__class__: shaders_GammaRamp
	,texture__: null
	,gammaRampInvSize__: null
});
class shaders_MarbleReflection extends hxsl_Shader {
	constructor(texture) {
		super();
		this.texture__ = texture;
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.texture__;
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_MarbleReflection.prototype);
		s.shader = this.shader;
		s.texture__ = this.texture__;
		return s;
	}
}
$hxClasses["shaders.MarbleReflection"] = shaders_MarbleReflection;
shaders_MarbleReflection.__name__ = "shaders.MarbleReflection";
shaders_MarbleReflection.__super__ = hxsl_Shader;
Object.assign(shaders_MarbleReflection.prototype, {
	__class__: shaders_MarbleReflection
	,texture__: null
});
class shaders_NoiseTileMaterial extends hxsl_Shader {
	constructor(diffuse,normal,noise,shininess,specularColor,secondaryMapUvFactor) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,normal,noise,shininess,specularColor,secondaryMapUvFactor);
	}
	_hx_constructor(diffuse,normal,noise,shininess,specularColor,secondaryMapUvFactor) {
		this.secondaryMapUvFactor__ = 0;
		this.shininess__ = 0;
		this.specularColor__ = new h3d_Vector();
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.normalMap__ = normal;
		this.noiseMap__ = noise;
		this.shininess__ = shininess;
		this.specularColor__ = specularColor;
		this.secondaryMapUvFactor__ = secondaryMapUvFactor;
		this.constModified = true;
		this.useAccurateNoise__ = false;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	get_normalMap() {
		return this.normalMap__;
	}
	set_normalMap(_v) {
		return this.normalMap__ = _v;
	}
	get_noiseMap() {
		return this.noiseMap__;
	}
	set_noiseMap(_v) {
		return this.noiseMap__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	get_secondaryMapUvFactor() {
		return this.secondaryMapUvFactor__;
	}
	set_secondaryMapUvFactor(_v) {
		return this.secondaryMapUvFactor__ = _v;
	}
	get_useAccurateNoise() {
		return this.useAccurateNoise__;
	}
	set_useAccurateNoise(_v) {
		this.constModified = true;
		return this.useAccurateNoise__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.useAccurateNoise__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.specularColor__;
		case 2:
			return this.normalMap__;
		case 3:
			return this.noiseMap__;
		case 4:
			return this.shininess__;
		case 5:
			return this.secondaryMapUvFactor__;
		case 6:
			return this.useAccurateNoise__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 4:
			return this.shininess__;
		case 5:
			return this.secondaryMapUvFactor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_NoiseTileMaterial.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.specularColor__ = this.specularColor__;
		s.normalMap__ = this.normalMap__;
		s.noiseMap__ = this.noiseMap__;
		s.shininess__ = this.shininess__;
		s.secondaryMapUvFactor__ = this.secondaryMapUvFactor__;
		s.useAccurateNoise__ = this.useAccurateNoise__;
		return s;
	}
}
$hxClasses["shaders.NoiseTileMaterial"] = shaders_NoiseTileMaterial;
shaders_NoiseTileMaterial.__name__ = "shaders.NoiseTileMaterial";
shaders_NoiseTileMaterial.__super__ = hxsl_Shader;
Object.assign(shaders_NoiseTileMaterial.prototype, {
	__class__: shaders_NoiseTileMaterial
	,diffuseMap__: null
	,specularColor__: null
	,normalMap__: null
	,noiseMap__: null
	,shininess__: null
	,secondaryMapUvFactor__: null
	,useAccurateNoise__: null
});
class shaders_NormalMaterial extends hxsl_Shader {
	constructor(diffuse,normal,ambientLight,dirLight,dirLightDir) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,normal,ambientLight,dirLight,dirLightDir);
	}
	_hx_constructor(diffuse,normal,ambientLight,dirLight,dirLightDir) {
		this.dirLightDir__ = new h3d_Vector();
		this.dirLight__ = new h3d_Vector();
		this.ambientLight__ = new h3d_Vector();
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.normalMap__ = normal;
		this.ambientLight__ = ambientLight.clone();
		this.dirLight__ = dirLight.clone();
		this.dirLightDir__ = dirLightDir.clone();
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_normalMap() {
		return this.normalMap__;
	}
	set_normalMap(_v) {
		return this.normalMap__ = _v;
	}
	get_ambientLight() {
		return this.ambientLight__;
	}
	set_ambientLight(_v) {
		return this.ambientLight__ = _v;
	}
	get_dirLight() {
		return this.dirLight__;
	}
	set_dirLight(_v) {
		return this.dirLight__ = _v;
	}
	get_dirLightDir() {
		return this.dirLightDir__;
	}
	set_dirLightDir(_v) {
		return this.dirLightDir__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.normalMap__;
		case 2:
			return this.ambientLight__;
		case 3:
			return this.dirLight__;
		case 4:
			return this.dirLightDir__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_NormalMaterial.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.normalMap__ = this.normalMap__;
		s.ambientLight__ = this.ambientLight__;
		s.dirLight__ = this.dirLight__;
		s.dirLightDir__ = this.dirLightDir__;
		return s;
	}
}
$hxClasses["shaders.NormalMaterial"] = shaders_NormalMaterial;
shaders_NormalMaterial.__name__ = "shaders.NormalMaterial";
shaders_NormalMaterial.__super__ = hxsl_Shader;
Object.assign(shaders_NormalMaterial.prototype, {
	__class__: shaders_NormalMaterial
	,diffuseMap__: null
	,normalMap__: null
	,ambientLight__: null
	,dirLight__: null
	,dirLightDir__: null
});
class shaders_PhongMaterial extends hxsl_Shader {
	constructor(diffuse,normal,shininess,specularVal,ambientLight,dirLight,dirLightDir,uvScaleFactor) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,normal,shininess,specularVal,ambientLight,dirLight,dirLightDir,uvScaleFactor);
	}
	_hx_constructor(diffuse,normal,shininess,specularVal,ambientLight,dirLight,dirLightDir,uvScaleFactor) {
		this.isHalfTile__ = false;
		this.uvScaleFactor__ = 0;
		this.dirLightDir__ = new h3d_Vector();
		this.dirLight__ = new h3d_Vector();
		this.ambientLight__ = new h3d_Vector();
		this.specularColor__ = new h3d_Vector();
		this.shininess__ = 0;
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.normalMap__ = normal;
		this.shininess__ = shininess;
		this.specularColor__ = specularVal;
		this.ambientLight__ = ambientLight.clone();
		this.dirLight__ = dirLight.clone();
		this.dirLightDir__ = dirLightDir.clone();
		this.uvScaleFactor__ = uvScaleFactor;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_normalMap() {
		return this.normalMap__;
	}
	set_normalMap(_v) {
		return this.normalMap__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	get_ambientLight() {
		return this.ambientLight__;
	}
	set_ambientLight(_v) {
		return this.ambientLight__ = _v;
	}
	get_dirLight() {
		return this.dirLight__;
	}
	set_dirLight(_v) {
		return this.dirLight__ = _v;
	}
	get_dirLightDir() {
		return this.dirLightDir__;
	}
	set_dirLightDir(_v) {
		return this.dirLightDir__ = _v;
	}
	get_uvScaleFactor() {
		return this.uvScaleFactor__;
	}
	set_uvScaleFactor(_v) {
		return this.uvScaleFactor__ = _v;
	}
	get_isHalfTile() {
		return this.isHalfTile__;
	}
	set_isHalfTile(_v) {
		this.constModified = true;
		return this.isHalfTile__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.isHalfTile__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.normalMap__;
		case 2:
			return this.shininess__;
		case 3:
			return this.specularColor__;
		case 4:
			return this.ambientLight__;
		case 5:
			return this.dirLight__;
		case 6:
			return this.dirLightDir__;
		case 7:
			return this.uvScaleFactor__;
		case 8:
			return this.isHalfTile__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 2:
			return this.shininess__;
		case 7:
			return this.uvScaleFactor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_PhongMaterial.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.normalMap__ = this.normalMap__;
		s.shininess__ = this.shininess__;
		s.specularColor__ = this.specularColor__;
		s.ambientLight__ = this.ambientLight__;
		s.dirLight__ = this.dirLight__;
		s.dirLightDir__ = this.dirLightDir__;
		s.uvScaleFactor__ = this.uvScaleFactor__;
		s.isHalfTile__ = this.isHalfTile__;
		return s;
	}
}
$hxClasses["shaders.PhongMaterial"] = shaders_PhongMaterial;
shaders_PhongMaterial.__name__ = "shaders.PhongMaterial";
shaders_PhongMaterial.__super__ = hxsl_Shader;
Object.assign(shaders_PhongMaterial.prototype, {
	__class__: shaders_PhongMaterial
	,diffuseMap__: null
	,normalMap__: null
	,shininess__: null
	,specularColor__: null
	,ambientLight__: null
	,dirLight__: null
	,dirLightDir__: null
	,uvScaleFactor__: null
	,isHalfTile__: null
});
class shaders_RefractMaterial extends hxsl_Shader {
	constructor(diffuse,normal,shininess,specularColor,secondaryMapUvFactor) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,normal,shininess,specularColor,secondaryMapUvFactor);
	}
	_hx_constructor(diffuse,normal,shininess,specularColor,secondaryMapUvFactor) {
		this.secondaryMapUvFactor__ = 0;
		this.shininess__ = 0;
		this.specularColor__ = new h3d_Vector();
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.normalMap__ = normal;
		this.shininess__ = shininess;
		this.specularColor__ = specularColor;
		this.secondaryMapUvFactor__ = secondaryMapUvFactor;
		this.constModified = true;
		this.doGammaRamp__ = true;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_refractMap() {
		return this.refractMap__;
	}
	set_refractMap(_v) {
		return this.refractMap__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	get_normalMap() {
		return this.normalMap__;
	}
	set_normalMap(_v) {
		return this.normalMap__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	get_secondaryMapUvFactor() {
		return this.secondaryMapUvFactor__;
	}
	set_secondaryMapUvFactor(_v) {
		return this.secondaryMapUvFactor__ = _v;
	}
	get_doGammaRamp() {
		return this.doGammaRamp__;
	}
	set_doGammaRamp(_v) {
		this.constModified = true;
		return this.doGammaRamp__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		if(this.doGammaRamp__) {
			this.constBits |= 1;
		}
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.refractMap__;
		case 2:
			return this.specularColor__;
		case 3:
			return this.normalMap__;
		case 4:
			return this.shininess__;
		case 5:
			return this.secondaryMapUvFactor__;
		case 6:
			return this.doGammaRamp__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 4:
			return this.shininess__;
		case 5:
			return this.secondaryMapUvFactor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_RefractMaterial.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.refractMap__ = this.refractMap__;
		s.specularColor__ = this.specularColor__;
		s.normalMap__ = this.normalMap__;
		s.shininess__ = this.shininess__;
		s.secondaryMapUvFactor__ = this.secondaryMapUvFactor__;
		s.doGammaRamp__ = this.doGammaRamp__;
		return s;
	}
}
$hxClasses["shaders.RefractMaterial"] = shaders_RefractMaterial;
shaders_RefractMaterial.__name__ = "shaders.RefractMaterial";
shaders_RefractMaterial.__super__ = hxsl_Shader;
Object.assign(shaders_RefractMaterial.prototype, {
	__class__: shaders_RefractMaterial
	,diffuseMap__: null
	,refractMap__: null
	,specularColor__: null
	,normalMap__: null
	,shininess__: null
	,secondaryMapUvFactor__: null
	,doGammaRamp__: null
});
class shaders_RendererDefaultPass extends h3d_pass_Base {
	constructor(name) {
		h3d_pass_Base._hx_skip_constructor = true;
		super();
		h3d_pass_Base._hx_skip_constructor = false;
		this._hx_constructor(name);
	}
	_hx_constructor(name) {
		this.defaultSort = ($_=new h3d_pass_SortByMaterial(),$bind($_,$_.sort));
		super._hx_constructor(name);
		this.manager = new h3d_pass_ShaderManager(this.getOutputs());
		this.initGlobals();
	}
	getCurrentPixelSize() {
		let t = this.ctx.engine.getCurrentTarget();
		return new h3d_Vector(2 / (t == null ? this.ctx.engine.width : t.width),2 / (t == null ? this.ctx.engine.height : t.height));
	}
	getOutputs() {
		return [hxsl_Output.Value("output.color")];
	}
	processShaders(p,shaders) {
		let p1 = this.ctx.extraShaders;
		while(p1 != null) {
			shaders = this.ctx.allocShaderList(p1.s,shaders);
			p1 = p1.next;
		}
		return shaders;
	}
	setupShaders(passes) {
		let lightInit = false;
		let _g_o = passes.current;
		while(_g_o != null) {
			let tmp = _g_o;
			_g_o = _g_o.next;
			let shaders = tmp.pass.getShadersRec();
			shaders = this.processShaders(tmp,shaders);
			if(tmp.pass.enableLights && this.ctx.lightSystem != null) {
				if(!lightInit) {
					this.ctx.lightSystem.initGlobals(this.manager.globals);
					lightInit = true;
				}
				shaders = this.ctx.lightSystem.computeLight(tmp.obj,shaders);
			}
			tmp.shader = this.manager.compileShaders(shaders,tmp.pass.batchMode);
			tmp.shaders = shaders;
			let t = tmp.shader.fragment.textures;
			if(t == null || t.type._hx_index == 15) {
				tmp.texture = 0;
			} else {
				let _this = this.manager;
				let t1;
				if(t.perObjectGlobal != null) {
					let v = _this.globals.map.h[t.perObjectGlobal.gid];
					if(v == null) {
						throw haxe_Exception.thrown("Missing global value " + t.perObjectGlobal.path + " for shader " + _this.shaderInfo(shaders,t.perObjectGlobal.path));
					}
					t1 = t.type._hx_index == 17 ? v.texture : v;
				} else {
					let si = shaders;
					let n = t.instance;
					while(--n > 0) si = si.next;
					let v = si.s.getParamValue(t.index);
					t1 = v;
				}
				tmp.texture = t1 == null ? 0 : t1.id;
			}
		}
	}
	drawObject(p) {
		this.ctx.drawPass = p;
		this.ctx.engine.selectMaterial(p.pass);
		p.obj.draw(this.ctx);
	}
	draw(passes,sort) {
		if(passes.current == null) {
			return;
		}
		let _g = 0;
		let _g1 = this.ctx.sharedGlobals;
		while(_g < _g1.length) {
			let g = _g1[_g];
			++_g;
			this.manager.globals.map.h[g.gid] = g.value;
		}
		this.setGlobals();
		this.setupShaders(passes);
		if(sort == null) {
			this.defaultSort(passes);
		} else {
			sort(passes);
		}
		this.ctx.currentManager = this.manager;
		let buf = this.ctx.shaderBuffers;
		let prevShader = null;
		let _g_o = passes.current;
		while(_g_o != null) {
			let tmp = _g_o;
			_g_o = _g_o.next;
			let v = tmp.obj.absPos;
			this.manager.globals.map.h[this.globalModelView_id] = v;
			if(tmp.shader.globals.h.hasOwnProperty(this.globalModelViewTranspose_id)) {
				let v = this.manager.globals.map.h[this.globalModelView_id].clone();
				this.manager.globals.map.h[this.globalModelViewTranspose_id] = v;
				this.manager.globals.map.h[this.globalModelViewTranspose_id].transpose();
			}
			if(tmp.shader.globals.h.hasOwnProperty(this.globalModelViewInverse_id)) {
				let v = tmp.obj.getInvPos();
				this.manager.globals.map.h[this.globalModelViewInverse_id] = v;
			}
			if(prevShader != tmp.shader) {
				prevShader = tmp.shader;
				try {
					this.ctx.engine.selectShader(tmp.shader);
				} catch( _g ) {
					let _g1 = haxe_Exception.caught(_g).unwrap();
					shaders_RendererDefaultPass.onShaderError(_g1,tmp);
					continue;
				}
				if(buf == null) {
					buf = this.ctx.shaderBuffers = new h3d_shader_Buffers(tmp.shader);
				} else {
					let s = tmp.shader;
					buf.vertex.grow(s.vertex);
					buf.fragment.grow(s.fragment);
				}
				this.manager.fillGlobals(buf,tmp.shader);
				this.ctx.engine.uploadShaderBuffers(buf,0);
			}
			if(!tmp.pass.dynamicParameters) {
				this.manager.fillParams(buf,tmp.shader,tmp.shaders);
				this.ctx.engine.uploadShaderBuffers(buf,1);
				this.ctx.engine.uploadShaderBuffers(buf,2);
				this.ctx.engine.uploadShaderBuffers(buf,3);
			}
			this.drawObject(tmp);
		}
		let _this = this.ctx;
		_this.cachedPos = 0;
		_this.drawPass = null;
	}
	initGlobals() {
		this.cameraView_id = hxsl_Globals.allocID("camera.view");
		this.cameraNear_id = hxsl_Globals.allocID("camera.zNear");
		this.cameraFar_id = hxsl_Globals.allocID("camera.zFar");
		this.cameraProj_id = hxsl_Globals.allocID("camera.proj");
		this.cameraPos_id = hxsl_Globals.allocID("camera.position");
		this.cameraProjDiag_id = hxsl_Globals.allocID("camera.projDiag");
		this.cameraProjFlip_id = hxsl_Globals.allocID("camera.projFlip");
		this.cameraViewProj_id = hxsl_Globals.allocID("camera.viewProj");
		this.cameraInverseViewProj_id = hxsl_Globals.allocID("camera.inverseViewProj");
		this.globalTime_id = hxsl_Globals.allocID("global.time");
		this.pixelSize_id = hxsl_Globals.allocID("global.pixelSize");
		this.globalModelView_id = hxsl_Globals.allocID("global.modelView");
		this.globalModelViewInverse_id = hxsl_Globals.allocID("global.modelViewInverse");
		this.globalModelViewTranspose_id = hxsl_Globals.allocID("global.modelViewTranspose");
	}
	setGlobals() {
		let v = this.ctx.camera.mcam;
		this.manager.globals.map.h[this.cameraView_id] = v;
		let v1 = this.ctx.camera.zNear;
		this.manager.globals.map.h[this.cameraNear_id] = v1;
		let v2 = this.ctx.camera.zFar;
		this.manager.globals.map.h[this.cameraFar_id] = v2;
		let v3 = this.ctx.camera.mproj;
		this.manager.globals.map.h[this.cameraProj_id] = v3;
		let v4 = this.ctx.camera.pos;
		this.manager.globals.map.h[this.cameraPos_id] = v4;
		let v5 = new h3d_Vector(this.ctx.camera.mproj._11,this.ctx.camera.mproj._22,this.ctx.camera.mproj._33,this.ctx.camera.mproj._44);
		this.manager.globals.map.h[this.cameraProjDiag_id] = v5;
		let v6 = this.ctx.engine.driver.hasFeature(h3d_impl_Feature.BottomLeftCoords) && this.ctx.engine.getCurrentTarget() != null ? -1 : 1;
		this.manager.globals.map.h[this.cameraProjFlip_id] = v6;
		let v7 = this.ctx.camera.m;
		this.manager.globals.map.h[this.cameraViewProj_id] = v7;
		let v8 = this.ctx.camera.getInverseViewProj();
		this.manager.globals.map.h[this.cameraInverseViewProj_id] = v8;
		let v9 = this.ctx.time;
		this.manager.globals.map.h[this.globalTime_id] = v9;
		let v10 = this.getCurrentPixelSize();
		this.manager.globals.map.h[this.pixelSize_id] = v10;
	}
	static onShaderError(e,p) {
		throw haxe_Exception.thrown(e);
	}
}
$hxClasses["shaders.RendererDefaultPass"] = shaders_RendererDefaultPass;
shaders_RendererDefaultPass.__name__ = "shaders.RendererDefaultPass";
shaders_RendererDefaultPass.__super__ = h3d_pass_Base;
Object.assign(shaders_RendererDefaultPass.prototype, {
	__class__: shaders_RendererDefaultPass
	,manager: null
	,defaultSort: null
	,cameraView_id: null
	,cameraNear_id: null
	,cameraFar_id: null
	,cameraProj_id: null
	,cameraPos_id: null
	,cameraProjDiag_id: null
	,cameraProjFlip_id: null
	,cameraViewProj_id: null
	,cameraInverseViewProj_id: null
	,globalTime_id: null
	,pixelSize_id: null
	,globalModelView_id: null
	,globalModelViewInverse_id: null
	,globalModelViewTranspose_id: null
});
class shaders_Skybox extends hxsl_Shader {
	constructor(texture) {
		super();
		this.texture__ = texture;
	}
	get_texture() {
		return this.texture__;
	}
	set_texture(_v) {
		return this.texture__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.texture__;
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_Skybox.prototype);
		s.shader = this.shader;
		s.texture__ = this.texture__;
		return s;
	}
}
$hxClasses["shaders.Skybox"] = shaders_Skybox;
shaders_Skybox.__name__ = "shaders.Skybox";
shaders_Skybox.__super__ = hxsl_Shader;
Object.assign(shaders_Skybox.prototype, {
	__class__: shaders_Skybox
	,texture__: null
});
class shaders_TrivialMaterial extends hxsl_Shader {
	constructor(diffuse) {
		super();
		this.diffuseMap__ = diffuse;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		if(index == 0) {
			return this.diffuseMap__;
		}
		return null;
	}
	getParamFloatValue(index) {
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_TrivialMaterial.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		return s;
	}
}
$hxClasses["shaders.TrivialMaterial"] = shaders_TrivialMaterial;
shaders_TrivialMaterial.__name__ = "shaders.TrivialMaterial";
shaders_TrivialMaterial.__super__ = hxsl_Shader;
Object.assign(shaders_TrivialMaterial.prototype, {
	__class__: shaders_TrivialMaterial
	,diffuseMap__: null
});
class shaders_UVRotAnim extends hxsl_Shader {
	constructor(vx,vy,speed) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(vx,vy,speed);
	}
	_hx_constructor(vx,vy,speed) {
		if(speed == null) {
			speed = 1.;
		}
		if(vy == null) {
			vy = 0.;
		}
		if(vx == null) {
			vx = 0.;
		}
		this.uvRotSpeed__ = 0;
		this.offset__ = new h3d_Vector();
		super._hx_constructor();
		let _this = this.offset__;
		let x = vx;
		let y = vy;
		if(vy == null) {
			y = 0.;
		}
		if(vx == null) {
			x = 0.;
		}
		_this.x = x;
		_this.y = y;
		_this.z = 0.;
		_this.w = 1.;
		this.uvRotSpeed__ = speed;
	}
	get_offset() {
		return this.offset__;
	}
	set_offset(_v) {
		return this.offset__ = _v;
	}
	get_uvRotSpeed() {
		return this.uvRotSpeed__;
	}
	set_uvRotSpeed(_v) {
		return this.uvRotSpeed__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.offset__;
		case 1:
			return this.uvRotSpeed__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 1) {
			return this.uvRotSpeed__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_UVRotAnim.prototype);
		s.shader = this.shader;
		s.offset__ = this.offset__;
		s.uvRotSpeed__ = this.uvRotSpeed__;
		return s;
	}
}
$hxClasses["shaders.UVRotAnim"] = shaders_UVRotAnim;
shaders_UVRotAnim.__name__ = "shaders.UVRotAnim";
shaders_UVRotAnim.__super__ = hxsl_Shader;
Object.assign(shaders_UVRotAnim.prototype, {
	__class__: shaders_UVRotAnim
	,offset__: null
	,uvRotSpeed__: null
});
class shaders_marble_ClassicGlass extends hxsl_Shader {
	constructor(diffuse,normal,skybox,shininess,specularVal,uvScaleFactor) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,normal,skybox,shininess,specularVal,uvScaleFactor);
	}
	_hx_constructor(diffuse,normal,skybox,shininess,specularVal,uvScaleFactor) {
		this.uvScaleFactor__ = 0;
		this.specularColor__ = new h3d_Vector();
		this.shininess__ = 0;
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.normalMap__ = normal;
		this.envMap__ = skybox;
		this.shininess__ = shininess;
		this.specularColor__ = specularVal;
		this.uvScaleFactor__ = uvScaleFactor;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_normalMap() {
		return this.normalMap__;
	}
	set_normalMap(_v) {
		return this.normalMap__ = _v;
	}
	get_envMap() {
		return this.envMap__;
	}
	set_envMap(_v) {
		return this.envMap__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	get_uvScaleFactor() {
		return this.uvScaleFactor__;
	}
	set_uvScaleFactor(_v) {
		return this.uvScaleFactor__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.normalMap__;
		case 2:
			return this.envMap__;
		case 3:
			return this.shininess__;
		case 4:
			return this.specularColor__;
		case 5:
			return this.uvScaleFactor__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 3:
			return this.shininess__;
		case 5:
			return this.uvScaleFactor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_marble_ClassicGlass.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.normalMap__ = this.normalMap__;
		s.envMap__ = this.envMap__;
		s.shininess__ = this.shininess__;
		s.specularColor__ = this.specularColor__;
		s.uvScaleFactor__ = this.uvScaleFactor__;
		return s;
	}
}
$hxClasses["shaders.marble.ClassicGlass"] = shaders_marble_ClassicGlass;
shaders_marble_ClassicGlass.__name__ = "shaders.marble.ClassicGlass";
shaders_marble_ClassicGlass.__super__ = hxsl_Shader;
Object.assign(shaders_marble_ClassicGlass.prototype, {
	__class__: shaders_marble_ClassicGlass
	,diffuseMap__: null
	,normalMap__: null
	,envMap__: null
	,shininess__: null
	,specularColor__: null
	,uvScaleFactor__: null
});
class shaders_marble_ClassicGlassPureSphere extends hxsl_Shader {
	constructor(diffuse,normal,skybox,shininess,specularVal,uvScaleFactor) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,normal,skybox,shininess,specularVal,uvScaleFactor);
	}
	_hx_constructor(diffuse,normal,skybox,shininess,specularVal,uvScaleFactor) {
		this.uvScaleFactor__ = 0;
		this.specularColor__ = new h3d_Vector();
		this.shininess__ = 0;
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.normalMap__ = normal;
		this.envMap__ = skybox;
		this.shininess__ = shininess;
		this.specularColor__ = specularVal;
		this.uvScaleFactor__ = uvScaleFactor;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_normalMap() {
		return this.normalMap__;
	}
	set_normalMap(_v) {
		return this.normalMap__ = _v;
	}
	get_envMap() {
		return this.envMap__;
	}
	set_envMap(_v) {
		return this.envMap__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	get_uvScaleFactor() {
		return this.uvScaleFactor__;
	}
	set_uvScaleFactor(_v) {
		return this.uvScaleFactor__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.normalMap__;
		case 2:
			return this.envMap__;
		case 3:
			return this.shininess__;
		case 4:
			return this.specularColor__;
		case 5:
			return this.uvScaleFactor__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 3:
			return this.shininess__;
		case 5:
			return this.uvScaleFactor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_marble_ClassicGlassPureSphere.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.normalMap__ = this.normalMap__;
		s.envMap__ = this.envMap__;
		s.shininess__ = this.shininess__;
		s.specularColor__ = this.specularColor__;
		s.uvScaleFactor__ = this.uvScaleFactor__;
		return s;
	}
}
$hxClasses["shaders.marble.ClassicGlassPureSphere"] = shaders_marble_ClassicGlassPureSphere;
shaders_marble_ClassicGlassPureSphere.__name__ = "shaders.marble.ClassicGlassPureSphere";
shaders_marble_ClassicGlassPureSphere.__super__ = hxsl_Shader;
Object.assign(shaders_marble_ClassicGlassPureSphere.prototype, {
	__class__: shaders_marble_ClassicGlassPureSphere
	,diffuseMap__: null
	,normalMap__: null
	,envMap__: null
	,shininess__: null
	,specularColor__: null
	,uvScaleFactor__: null
});
class shaders_marble_ClassicMarb extends hxsl_Shader {
	constructor(diffuse,skybox,shininess,specularVal,uvScaleFactor) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,skybox,shininess,specularVal,uvScaleFactor);
	}
	_hx_constructor(diffuse,skybox,shininess,specularVal,uvScaleFactor) {
		this.uvScaleFactor__ = 0;
		this.specularColor__ = new h3d_Vector();
		this.shininess__ = 0;
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.envMap__ = skybox;
		this.shininess__ = shininess;
		this.specularColor__ = specularVal;
		this.uvScaleFactor__ = uvScaleFactor;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_envMap() {
		return this.envMap__;
	}
	set_envMap(_v) {
		return this.envMap__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	get_uvScaleFactor() {
		return this.uvScaleFactor__;
	}
	set_uvScaleFactor(_v) {
		return this.uvScaleFactor__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.envMap__;
		case 2:
			return this.shininess__;
		case 3:
			return this.specularColor__;
		case 4:
			return this.uvScaleFactor__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 2:
			return this.shininess__;
		case 4:
			return this.uvScaleFactor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_marble_ClassicMarb.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.envMap__ = this.envMap__;
		s.shininess__ = this.shininess__;
		s.specularColor__ = this.specularColor__;
		s.uvScaleFactor__ = this.uvScaleFactor__;
		return s;
	}
}
$hxClasses["shaders.marble.ClassicMarb"] = shaders_marble_ClassicMarb;
shaders_marble_ClassicMarb.__name__ = "shaders.marble.ClassicMarb";
shaders_marble_ClassicMarb.__super__ = hxsl_Shader;
Object.assign(shaders_marble_ClassicMarb.prototype, {
	__class__: shaders_marble_ClassicMarb
	,diffuseMap__: null
	,envMap__: null
	,shininess__: null
	,specularColor__: null
	,uvScaleFactor__: null
});
class shaders_marble_ClassicMarb2 extends hxsl_Shader {
	constructor(diffuse,skybox,shininess,specularVal,uvScaleFactor) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,skybox,shininess,specularVal,uvScaleFactor);
	}
	_hx_constructor(diffuse,skybox,shininess,specularVal,uvScaleFactor) {
		this.uvScaleFactor__ = 0;
		this.specularColor__ = new h3d_Vector();
		this.shininess__ = 0;
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.envMap__ = skybox;
		this.shininess__ = shininess;
		this.specularColor__ = specularVal;
		this.uvScaleFactor__ = uvScaleFactor;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_envMap() {
		return this.envMap__;
	}
	set_envMap(_v) {
		return this.envMap__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	get_uvScaleFactor() {
		return this.uvScaleFactor__;
	}
	set_uvScaleFactor(_v) {
		return this.uvScaleFactor__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.envMap__;
		case 2:
			return this.shininess__;
		case 3:
			return this.specularColor__;
		case 4:
			return this.uvScaleFactor__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 2:
			return this.shininess__;
		case 4:
			return this.uvScaleFactor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_marble_ClassicMarb2.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.envMap__ = this.envMap__;
		s.shininess__ = this.shininess__;
		s.specularColor__ = this.specularColor__;
		s.uvScaleFactor__ = this.uvScaleFactor__;
		return s;
	}
}
$hxClasses["shaders.marble.ClassicMarb2"] = shaders_marble_ClassicMarb2;
shaders_marble_ClassicMarb2.__name__ = "shaders.marble.ClassicMarb2";
shaders_marble_ClassicMarb2.__super__ = hxsl_Shader;
Object.assign(shaders_marble_ClassicMarb2.prototype, {
	__class__: shaders_marble_ClassicMarb2
	,diffuseMap__: null
	,envMap__: null
	,shininess__: null
	,specularColor__: null
	,uvScaleFactor__: null
});
class shaders_marble_ClassicMarb3 extends hxsl_Shader {
	constructor(diffuse,skybox,shininess,specularVal,uvScaleFactor) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,skybox,shininess,specularVal,uvScaleFactor);
	}
	_hx_constructor(diffuse,skybox,shininess,specularVal,uvScaleFactor) {
		this.uvScaleFactor__ = 0;
		this.specularColor__ = new h3d_Vector();
		this.shininess__ = 0;
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.envMap__ = skybox;
		this.shininess__ = shininess;
		this.specularColor__ = specularVal;
		this.uvScaleFactor__ = uvScaleFactor;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_envMap() {
		return this.envMap__;
	}
	set_envMap(_v) {
		return this.envMap__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	get_uvScaleFactor() {
		return this.uvScaleFactor__;
	}
	set_uvScaleFactor(_v) {
		return this.uvScaleFactor__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.envMap__;
		case 2:
			return this.shininess__;
		case 3:
			return this.specularColor__;
		case 4:
			return this.uvScaleFactor__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 2:
			return this.shininess__;
		case 4:
			return this.uvScaleFactor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_marble_ClassicMarb3.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.envMap__ = this.envMap__;
		s.shininess__ = this.shininess__;
		s.specularColor__ = this.specularColor__;
		s.uvScaleFactor__ = this.uvScaleFactor__;
		return s;
	}
}
$hxClasses["shaders.marble.ClassicMarb3"] = shaders_marble_ClassicMarb3;
shaders_marble_ClassicMarb3.__name__ = "shaders.marble.ClassicMarb3";
shaders_marble_ClassicMarb3.__super__ = hxsl_Shader;
Object.assign(shaders_marble_ClassicMarb3.prototype, {
	__class__: shaders_marble_ClassicMarb3
	,diffuseMap__: null
	,envMap__: null
	,shininess__: null
	,specularColor__: null
	,uvScaleFactor__: null
});
class shaders_marble_ClassicMetal extends hxsl_Shader {
	constructor(diffuse,normal,skybox,shininess,specularVal,uvScaleFactor) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,normal,skybox,shininess,specularVal,uvScaleFactor);
	}
	_hx_constructor(diffuse,normal,skybox,shininess,specularVal,uvScaleFactor) {
		this.uvScaleFactor__ = 0;
		this.specularColor__ = new h3d_Vector();
		this.shininess__ = 0;
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.normalMap__ = normal;
		this.envMap__ = skybox;
		this.shininess__ = shininess;
		this.specularColor__ = specularVal;
		this.uvScaleFactor__ = uvScaleFactor;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_normalMap() {
		return this.normalMap__;
	}
	set_normalMap(_v) {
		return this.normalMap__ = _v;
	}
	get_envMap() {
		return this.envMap__;
	}
	set_envMap(_v) {
		return this.envMap__ = _v;
	}
	get_shininess() {
		return this.shininess__;
	}
	set_shininess(_v) {
		return this.shininess__ = _v;
	}
	get_specularColor() {
		return this.specularColor__;
	}
	set_specularColor(_v) {
		return this.specularColor__ = _v;
	}
	get_uvScaleFactor() {
		return this.uvScaleFactor__;
	}
	set_uvScaleFactor(_v) {
		return this.uvScaleFactor__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.normalMap__;
		case 2:
			return this.envMap__;
		case 3:
			return this.shininess__;
		case 4:
			return this.specularColor__;
		case 5:
			return this.uvScaleFactor__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		switch(index) {
		case 3:
			return this.shininess__;
		case 5:
			return this.uvScaleFactor__;
		default:
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_marble_ClassicMetal.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.normalMap__ = this.normalMap__;
		s.envMap__ = this.envMap__;
		s.shininess__ = this.shininess__;
		s.specularColor__ = this.specularColor__;
		s.uvScaleFactor__ = this.uvScaleFactor__;
		return s;
	}
}
$hxClasses["shaders.marble.ClassicMetal"] = shaders_marble_ClassicMetal;
shaders_marble_ClassicMetal.__name__ = "shaders.marble.ClassicMetal";
shaders_marble_ClassicMetal.__super__ = hxsl_Shader;
Object.assign(shaders_marble_ClassicMetal.prototype, {
	__class__: shaders_marble_ClassicMetal
	,diffuseMap__: null
	,normalMap__: null
	,envMap__: null
	,shininess__: null
	,specularColor__: null
	,uvScaleFactor__: null
});
class shaders_marble_CrystalMarb extends hxsl_Shader {
	constructor(diffuse,normal,skybox,uvScaleFactor) {
		hxsl_Shader._hx_skip_constructor = true;
		super();
		hxsl_Shader._hx_skip_constructor = false;
		this._hx_constructor(diffuse,normal,skybox,uvScaleFactor);
	}
	_hx_constructor(diffuse,normal,skybox,uvScaleFactor) {
		this.uvScaleFactor__ = 0;
		super._hx_constructor();
		this.diffuseMap__ = diffuse;
		this.normalMap__ = normal;
		this.envMap__ = skybox;
		this.uvScaleFactor__ = uvScaleFactor;
	}
	get_diffuseMap() {
		return this.diffuseMap__;
	}
	set_diffuseMap(_v) {
		return this.diffuseMap__ = _v;
	}
	get_normalMap() {
		return this.normalMap__;
	}
	set_normalMap(_v) {
		return this.normalMap__ = _v;
	}
	get_envMap() {
		return this.envMap__;
	}
	set_envMap(_v) {
		return this.envMap__ = _v;
	}
	get_uvScaleFactor() {
		return this.uvScaleFactor__;
	}
	set_uvScaleFactor(_v) {
		return this.uvScaleFactor__ = _v;
	}
	updateConstants(globals) {
		this.constBits = 0;
		this.updateConstantsFinal(globals);
	}
	getParamValue(index) {
		switch(index) {
		case 0:
			return this.diffuseMap__;
		case 1:
			return this.normalMap__;
		case 2:
			return this.envMap__;
		case 3:
			return this.uvScaleFactor__;
		default:
		}
		return null;
	}
	getParamFloatValue(index) {
		if(index == 3) {
			return this.uvScaleFactor__;
		}
		return 0.;
	}
	clone() {
		let s = Object.create(shaders_marble_CrystalMarb.prototype);
		s.shader = this.shader;
		s.diffuseMap__ = this.diffuseMap__;
		s.normalMap__ = this.normalMap__;
		s.envMap__ = this.envMap__;
		s.uvScaleFactor__ = this.uvScaleFactor__;
		return s;
	}
}
$hxClasses["shaders.marble.CrystalMarb"] = shaders_marble_CrystalMarb;
shaders_marble_CrystalMarb.__name__ = "shaders.marble.CrystalMarb";
shaders_marble_CrystalMarb.__super__ = hxsl_Shader;
Object.assign(shaders_marble_CrystalMarb.prototype, {
	__class__: shaders_marble_CrystalMarb
	,diffuseMap__: null
	,normalMap__: null
	,envMap__: null
	,uvScaleFactor__: null
});
class src_GameObject extends h3d_scene_Object {
	constructor(parent) {
		if(h3d_scene_Object._hx_skip_constructor) {
			super();
			return;
		}
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(parent);
	}
	_hx_constructor(parent) {
		this.soundResources = [];
		this.textureResources = [];
		this.animateSubObjectOpacities = false;
		this.enableCollideCallbacks = false;
		this.isBoundingBoxCollideable = false;
		this.isCollideable = false;
		this.currentOpacity = 1;
		super._hx_constructor(parent);
	}
	getSubObjectOpacity(obj) {
		return this.currentOpacity;
	}
	onMarbleContact(marble,time,contact) {
	}
	onMarbleInside(marble,time) {
	}
	onMarbleEnter(marble,time) {
	}
	onMarbleLeave(marble,time) {
	}
	onLevelStart() {
	}
	reset() {
	}
	dispose() {
		let _g = 0;
		let _g1 = this.textureResources;
		while(_g < _g1.length) {
			let textureResource = _g1[_g];
			++_g;
			textureResource.release();
		}
		let _g2 = 0;
		let _g3 = this.soundResources;
		while(_g2 < _g3.length) {
			let audioResource = _g3[_g2];
			++_g2;
			audioResource.release();
		}
	}
}
$hxClasses["src.GameObject"] = src_GameObject;
src_GameObject.__name__ = "src.GameObject";
src_GameObject.__super__ = h3d_scene_Object;
Object.assign(src_GameObject.prototype, {
	__class__: src_GameObject
	,identifier: null
	,currentOpacity: null
	,isCollideable: null
	,isBoundingBoxCollideable: null
	,enableCollideCallbacks: null
	,animateSubObjectOpacities: null
	,textureResources: null
	,soundResources: null
});
class src_DtsObject extends src_GameObject {
	constructor() {
		if(h3d_scene_Object._hx_skip_constructor) {
			super();
			return;
		}
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.idInLevel = -1;
		this.ambientSpinFactor = -0.16666666666666666 * Math.PI * 2;
		this.ambientRotate = false;
		this._regenNormals = false;
		this.isInstanced = false;
		this.hasNonVisualSequences = true;
		this.showSequences = true;
		this.useInstancing = true;
		this.meshes = [];
		this.meshToIndex = new haxe_ds_ObjectMap();
		this.meshVisibilities = [];
		this.dirtyTransforms = [];
		this.graphNodes = [];
		this.isSharedGraphNodesRoot = false;
		this.sharedGraphNodes = [];
		this.sharedNodeTransforms = false;
		this.lastSequenceKeyframes = new haxe_ds_ObjectMap();
		this.sequenceKeyframeOverride = new haxe_ds_ObjectMap();
		this.matNameOverride = new haxe_ds_StringMap();
		this.materialInfos = new haxe_ds_ObjectMap();
		this.materials = [];
		super._hx_constructor();
	}
	init(level,onFinish) {
		this.dtsResource = src_ResourceLoader.loadDts(this.dtsPath);
		this.dtsResource.acquire();
		this.dts = this.dtsResource.resource;
		if(this.sequencePath != null) {
			this.dts.importSequences(this.sequencePath);
		}
		this.directoryPath = haxe_io_Path.directory(this.dtsPath);
		if(level != null) {
			this.level = level;
			this.collisionWorld = this.level.collisionWorld;
		}
		this.isInstanced = false;
		if(!src_Util.isIOSInstancingSupported()) {
			this.useInstancing = false;
		}
		if(this.level != null) {
			this.isInstanced = this.level.instanceManager.isInstanced(this) && this.useInstancing;
		}
		if(!this.isInstanced) {
			this.computeMaterials();
		}
		let graphNodes = [];
		let rootNodesIdx = [];
		this.colliders = [];
		let _g = [];
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		_g.push(-1);
		this.mountPointNodes = _g;
		let _g1 = 0;
		let _g2 = this.dts.nodes.length;
		while(_g1 < _g2) {
			++_g1;
			graphNodes.push(new h3d_scene_Object());
		}
		let _g3 = 0;
		let _g4 = this.dts.objects.length;
		while(_g3 < _g4) {
			++_g3;
			this.meshes.push(null);
			this.meshVisibilities.push(1);
		}
		let _g5 = 0;
		let _g6 = this.dts.nodes.length;
		while(_g5 < _g6) {
			let i = _g5++;
			let node = this.dts.nodes[i];
			if(node.parent != -1) {
				graphNodes[node.parent].addChild(graphNodes[i]);
			} else {
				rootNodesIdx.push(i);
			}
		}
		this.graphNodes = graphNodes;
		let _g7 = 0;
		let _g8 = this.dts.nodes.length;
		while(_g7 < _g8) {
			let i = _g7++;
			let _this = this.dts.objects;
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(v.node == i) {
					_g.push(v);
				}
			}
			if(HxOverrides.substr(this.dts.names[this.dts.nodes[i].name],0,5) == "mount") {
				let mountindex = HxOverrides.substr(this.dts.names[this.dts.nodes[i].name],5,null);
				let mountNode = Std.parseInt(mountindex);
				this.mountPointNodes[mountNode] = i;
			}
			let _g2 = 0;
			while(_g2 < _g.length) {
				let object = _g[_g2];
				++_g2;
				let isCollisionObject = HxOverrides.substr(this.dts.names[object.name],0,3).toLowerCase() == "col";
				if(isCollisionObject) {
					continue;
				}
				let _g1 = object.firstMesh;
				let _g3 = object.firstMesh + object.numMeshes;
				while(_g1 < _g3) {
					let j = _g1++;
					if(j >= this.dts.meshes.length) {
						continue;
					}
					let mesh = this.dts.meshes[j];
					if(mesh == null) {
						continue;
					}
					if(mesh.parent >= 0) {
						continue;
					}
					if(mesh.vertices.length == 0) {
						continue;
					}
					if(!this.isInstanced) {
						let _this = mesh.vertices;
						let result = new Array(_this.length);
						let _g = 0;
						let _g1 = _this.length;
						while(_g < _g1) {
							let i = _g++;
							let v = _this[i];
							result[i] = new h3d_Vector(-v.x,v.y,v.z);
						}
						let _this1 = mesh.normals;
						let result1 = new Array(_this1.length);
						let _g2 = 0;
						let _g3 = _this1.length;
						while(_g2 < _g3) {
							let i = _g2++;
							let v = _this1[i];
							result1[i] = new h3d_Vector(-v.x,v.y,v.z);
						}
						let geometry = this.generateMaterialGeometry(mesh,result,result1);
						let _g4 = 0;
						let _g5 = geometry.length;
						while(_g4 < _g5) {
							let k = _g4++;
							if(geometry[k].vertices.length == 0) {
								continue;
							}
							let poly = new mesh_Polygon(geometry[k].vertices);
							poly.normals = geometry[k].normals;
							poly.uvs = geometry[k].uvs;
							poly.tangents = geometry[k].tangents;
							poly.bitangents = geometry[k].bitangents;
							poly.texMatNormals = geometry[k].texNormals;
							let obj = new h3d_scene_Mesh(poly,this.materials[k],this.graphNodes[i]);
							this.meshToIndex.set(obj,this.dts.objects.indexOf(object));
						}
					} else {
						let usedMats = [];
						let _g = 0;
						let _g1 = mesh.primitives;
						while(_g < _g1.length) {
							let prim = _g1[_g];
							++_g;
							if(!usedMats.includes(prim.matIndex)) {
								usedMats.push(prim.matIndex);
							}
						}
						let _g2 = 0;
						while(_g2 < usedMats.length) {
							++_g2;
							let obj = new h3d_scene_Object(this.graphNodes[i]);
							this.meshToIndex.set(obj,this.dts.objects.indexOf(object));
						}
					}
				}
				this.meshes[this.dts.objects.indexOf(object)] = graphNodes[i];
			}
		}
		if(this.isCollideable) {
			let _g = 0;
			let _g1 = this.dts.nodes.length;
			while(_g < _g1) {
				let i = _g++;
				let _this = this.dts.objects;
				let _g1 = [];
				let _g2 = 0;
				while(_g2 < _this.length) {
					let v = _this[_g2];
					++_g2;
					if(v.node == i) {
						_g1.push(v);
					}
				}
				let localColliders = [];
				let _g3 = 0;
				while(_g3 < _g1.length) {
					let object = _g1[_g3];
					++_g3;
					let isCollisionObject = HxOverrides.substr(this.dts.names[object.name],0,3).toLowerCase() == "col";
					if(isCollisionObject) {
						let _g = object.firstMesh;
						let _g1 = object.firstMesh + object.numMeshes;
						while(_g < _g1) {
							let j = _g++;
							if(j >= this.dts.meshes.length) {
								continue;
							}
							let mesh = this.dts.meshes[j];
							if(mesh == null) {
								continue;
							}
							let _this = mesh.vertices;
							let result = new Array(_this.length);
							let _g1 = 0;
							let _g2 = _this.length;
							while(_g1 < _g2) {
								let i = _g1++;
								let v = _this[i];
								result[i] = new h3d_Vector(-v.x,v.y,v.z);
							}
							let _this1 = mesh.normals;
							let result1 = new Array(_this1.length);
							let _g3 = 0;
							let _g4 = _this1.length;
							while(_g3 < _g4) {
								let i = _g3++;
								let v = _this1[i];
								result1[i] = new h3d_Vector(-v.x,v.y,v.z);
							}
							let hulls = this.generateCollisionGeometry(mesh,result,result1,i);
							localColliders = localColliders.concat(hulls);
						}
					}
				}
				this.colliders = this.colliders.concat(localColliders);
			}
		}
		this.updateNodeTransforms();
		let _g9 = 0;
		let _g10 = this.dts.meshes.length;
		while(_g9 < _g10) {
			let i = _g9++;
			let mesh = this.dts.meshes[i];
			if(mesh == null) {
				continue;
			}
			if(mesh.meshType == 1) {
				let skinObj = new h3d_scene_Object();
				if(!this.isInstanced) {
					let _this = mesh.vertices;
					let result = new Array(_this.length);
					let _g = 0;
					let _g1 = _this.length;
					while(_g < _g1) {
						let i = _g++;
						let v = _this[i];
						result[i] = new h3d_Vector(-v.x,v.y,v.z);
					}
					let _this1 = mesh.normals;
					let result1 = new Array(_this1.length);
					let _g2 = 0;
					let _g3 = _this1.length;
					while(_g2 < _g3) {
						let i = _g2++;
						let v = _this1[i];
						result1[i] = new h3d_Vector(-v.x,v.y,v.z);
					}
					let geometry = this.generateMaterialGeometry(mesh,result,result1);
					let _g4 = 0;
					let _g5 = geometry.length;
					while(_g4 < _g5) {
						let k = _g4++;
						if(geometry[k].vertices.length == 0) {
							continue;
						}
						let poly = new src_DynamicPolygon(geometry[k].vertices);
						poly.normals = geometry[k].normals;
						poly.uvs = geometry[k].uvs;
						new h3d_scene_Mesh(poly,this.materials[k],skinObj);
					}
					this.skinMeshData = { meshIndex : i, vertices : result, normals : result1, indices : [], geometry : skinObj};
					let result2 = new Array(geometry.length);
					let _g6 = 0;
					let _g7 = geometry.length;
					while(_g6 < _g7) {
						let i = _g6++;
						result2[i] = geometry[i].indices;
					}
					let _g8 = 0;
					while(_g8 < result2.length) {
						let indexes = result2[_g8];
						++_g8;
						this.skinMeshData.indices = this.skinMeshData.indices.concat(indexes);
					}
				} else {
					let usedMats = [];
					let _g = 0;
					let _g1 = mesh.primitives;
					while(_g < _g1.length) {
						let prim = _g1[_g];
						++_g;
						if(!usedMats.includes(prim.matIndex)) {
							usedMats.push(prim.matIndex);
						}
					}
					let _g2 = 0;
					while(_g2 < usedMats.length) {
						++_g2;
						new h3d_scene_Object(skinObj);
					}
					this.skinMeshData = { meshIndex : i, vertices : [], normals : [], indices : [], geometry : skinObj};
				}
			}
		}
		if(!this.isInstanced) {
			let _g = 0;
			let _g1 = this.materials.length;
			while(_g < _g1) {
				let i = _g++;
				let info = this.materialInfos.h[this.materials[i].__id__];
				if(info == null) {
					continue;
				}
				let _this = this.dts.sequences;
				let _g1 = [];
				let _g2 = 0;
				while(_g2 < _this.length) {
					let v = _this[_g2];
					++_g2;
					if(v.iflMatters.length > 0 && v.iflMatters[0] > 0) {
						_g1.push(v);
					}
				}
				if(_g1.length == 0) {
					continue;
				}
				let completion = 0 / _g1[0].duration;
				let keyframe = Math.floor(completion * info.length) % info.length;
				let currentFile = info[keyframe];
				let texture = src_ResourceLoader.getResource(this.directoryPath + "/" + currentFile,src_ResourceLoader.getTexture,this.textureResources);
				let flags = this.dts.matFlags[i];
				if((flags & 1) > 0 || (flags & 2) > 0) {
					texture.set_wrap(h3d_mat_Wrap.Repeat);
				}
				this.materials[i].set_texture(texture);
			}
		}
		this.rootObject = new h3d_scene_Object(this);
		if(this.sharedNodeTransforms) {
			if(Object.prototype.hasOwnProperty.call(src_DtsObject.sharedGraphNodesMap.h,this.identifier)) {
				this.sharedGraphNodes = src_DtsObject.sharedGraphNodesMap.h[this.identifier];
				this.isSharedGraphNodesRoot = false;
			} else {
				let this1 = src_DtsObject.sharedGraphNodesMap;
				let key = this.identifier;
				let value = graphNodes.concat([this.rootObject]);
				this1.h[key] = value;
				this.isSharedGraphNodesRoot = true;
			}
		}
		let _g11 = 0;
		while(_g11 < rootNodesIdx.length) {
			let i = rootNodesIdx[_g11];
			++_g11;
			this.rootObject.addChild(this.graphNodes[i]);
		}
		if(this.skinMeshData != null) {
			this.rootObject.addChild(this.skinMeshData.geometry);
		}
		if(this.level != null && this.isBoundingBoxCollideable) {
			let boundthing = new h3d_col_Bounds();
			let _g = 0;
			let _g1 = this.dts.meshes;
			while(_g < _g1.length) {
				let mesh = _g1[_g];
				++_g;
				if(mesh == null) {
					continue;
				}
				let _g2 = 0;
				let _g3 = mesh.vertices;
				while(_g2 < _g3.length) {
					let pt = _g3[_g2];
					++_g2;
					let x = -pt.x;
					let y = pt.y;
					let z = pt.z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let p_x = x;
					let p_y = y;
					let p_z = z;
					if(p_x < boundthing.xMin) {
						boundthing.xMin = p_x;
					}
					if(p_x > boundthing.xMax) {
						boundthing.xMax = p_x;
					}
					if(p_y < boundthing.yMin) {
						boundthing.yMin = p_y;
					}
					if(p_y > boundthing.yMax) {
						boundthing.yMax = p_y;
					}
					if(p_z < boundthing.zMin) {
						boundthing.zMin = p_z;
					}
					if(p_z > boundthing.zMax) {
						boundthing.zMax = p_z;
					}
				}
			}
			let x = -this.dts.bounds.minX;
			let y = this.dts.bounds.minY;
			let z = this.dts.bounds.minZ;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let p_x = x;
			let p_y = y;
			let p_z = z;
			if(p_x < boundthing.xMin) {
				boundthing.xMin = p_x;
			}
			if(p_x > boundthing.xMax) {
				boundthing.xMax = p_x;
			}
			if(p_y < boundthing.yMin) {
				boundthing.yMin = p_y;
			}
			if(p_y > boundthing.yMax) {
				boundthing.yMax = p_y;
			}
			if(p_z < boundthing.zMin) {
				boundthing.zMin = p_z;
			}
			if(p_z > boundthing.zMax) {
				boundthing.zMax = p_z;
			}
			let x1 = -this.dts.bounds.maxX;
			let y1 = this.dts.bounds.maxY;
			let z1 = this.dts.bounds.maxZ;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let p_x1 = x1;
			let p_y1 = y1;
			let p_z1 = z1;
			if(p_x1 < boundthing.xMin) {
				boundthing.xMin = p_x1;
			}
			if(p_x1 > boundthing.xMax) {
				boundthing.xMax = p_x1;
			}
			if(p_y1 < boundthing.yMin) {
				boundthing.yMin = p_y1;
			}
			if(p_y1 > boundthing.yMax) {
				boundthing.yMax = p_y1;
			}
			if(p_z1 < boundthing.zMin) {
				boundthing.zMin = p_z1;
			}
			if(p_z1 > boundthing.zMax) {
				boundthing.zMax = p_z1;
			}
			this.boundingCollider = new collision_BoxCollisionEntity(boundthing,this);
			this.boundingCollider.setTransform(this.getTransform());
		}
		this.dirtyTransforms = [];
		let _g12 = 0;
		let _g13 = graphNodes.length;
		while(_g12 < _g13) {
			++_g12;
			this.dirtyTransforms.push(true);
		}
		onFinish();
	}
	postProcessMaterial(matName,material) {
	}
	getPreloadMaterials(dts) {
		let texToLoad = [];
		let directoryPath = haxe_io_Path.directory(this.dtsPath);
		let _g = 0;
		let _g1 = dts.matNames.length;
		while(_g < _g1) {
			let i = _g++;
			let matName = Object.prototype.hasOwnProperty.call(this.matNameOverride.h,dts.matNames[i]) ? this.matNameOverride.h[dts.matNames[i]] : dts.matNames[i];
			if(matName.indexOf("/") != -1) {
				matName = matName.substring(matName.lastIndexOf("/") + 1);
			}
			let _this = src_ResourceLoader.getFullNamesOf(directoryPath + "/" + matName);
			let _g1 = [];
			let _g2 = 0;
			while(_g2 < _this.length) {
				let v = _this[_g2];
				++_g2;
				if(haxe_io_Path.extension(v) != "dts") {
					_g1.push(v);
				}
			}
			let fullName = _g1.length > 0 ? _g1[0] : null;
			if(fullName != null) {
				texToLoad.push(fullName);
			}
		}
		return texToLoad;
	}
	computeMaterials() {
		let environmentMaterial = null;
		let _g = 0;
		let _g1 = this.dts.matNames.length;
		while(_g < _g1) {
			let i = _g++;
			let matName = Object.prototype.hasOwnProperty.call(this.matNameOverride.h,this.dts.matNames[i]) ? this.matNameOverride.h[this.dts.matNames[i]] : this.dts.matNames[i];
			if(matName.indexOf("/") != -1) {
				matName = matName.substring(matName.lastIndexOf("/") + 1);
			}
			let flags = this.dts.matFlags[i];
			let _this = src_ResourceLoader.getFullNamesOf(this.directoryPath + "/" + matName);
			let _g1 = [];
			let _g2 = 0;
			while(_g2 < _this.length) {
				let v = _this[_g2];
				++_g2;
				if(haxe_io_Path.extension(v) != "dts") {
					_g1.push(v);
				}
			}
			let fullName = _g1.length > 0 ? _g1[0] : null;
			if(this.isTSStatic && environmentMaterial != null && src_DtsObject_DROP_TEXTURE_FOR_ENV_MAP.includes(this.dtsPath)) {
				this.materials.push(environmentMaterial);
				continue;
			}
			let material = h3d_mat_Material.create();
			let iflMaterial = false;
			if(fullName == null || this.isTSStatic && (flags & -2147483648) > 0) {
				if(this.isTSStatic) {
					material.passes.set_enableLights(false);
					if((flags & -2147483648) > 0) {
						environmentMaterial = material;
					}
				}
			} else if(haxe_io_Path.extension(fullName) == "ifl") {
				let keyframes = this.parseIfl(fullName);
				this.materialInfos.set(material,keyframes);
				iflMaterial = true;
			} else {
				let texture = src_ResourceLoader.getResource(fullName,src_ResourceLoader.getTexture,this.textureResources);
				texture.set_wrap(h3d_mat_Wrap.Repeat);
				material.set_texture(texture);
				if(this.identifier != "Marble") {
					let dtsshader = new shaders_DtsTexture();
					dtsshader.texture__ = texture;
					dtsshader.currentOpacity__ = 1;
					if(this.identifier == "Tornado") {
						dtsshader.constModified = true;
						dtsshader.normalizeNormals__ = false;
					}
					material.passes.removeShader(material.textureShader);
					material.passes.addShader(dtsshader);
				}
			}
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			if(this.isCollideable) {
				material.set_receiveShadows(true);
			}
			if(material.get_texture() == null && !iflMaterial) {
				let dtsshader = new shaders_DtsTexture();
				dtsshader.currentOpacity__ = 1;
				if(this.identifier == "Tornado") {
					dtsshader.constModified = true;
					dtsshader.normalizeNormals__ = false;
				}
				let texture = src_ResourceLoader.getResource("data/shapes/hazards/null.png",src_ResourceLoader.getTexture,this.textureResources);
				texture.set_wrap(h3d_mat_Wrap.Repeat);
				src_Console.instance.addEntry("warn","Unable to load " + matName);
				material.set_texture(texture);
				dtsshader.texture__ = texture;
				material.passes.addShader(dtsshader);
				material.set_castShadows(false);
				material.set_receiveShadows(false);
			}
			if((flags & 4) > 0) {
				material.set_blendMode(h2d_BlendMode.Alpha);
				material.passes.set_culling(h3d_mat_Face.None);
				material.set_receiveShadows(false);
				material.passes.set_depthWrite(false);
			}
			if((flags & 8) > 0) {
				material.set_blendMode(h2d_BlendMode.Add);
			}
			if((flags & 16) > 0) {
				material.set_blendMode(h2d_BlendMode.Sub);
			}
			if((flags & 32) > 0) {
				material.passes.set_enableLights(false);
				material.set_receiveShadows(false);
			}
			if(this.isTSStatic && (flags & 64) <= 0) {
				let reflectivity = this.dts.matNames.length == 1 ? 1 : environmentMaterial != null ? 0.5 : 0.333;
				let cubemapshader = new shaders_EnvMap(this.level.sky.cubemap,reflectivity);
				material.passes.addShader(cubemapshader);
			}
			this.postProcessMaterial(matName,material);
			if(src_Debug.wireFrame) {
				material.passes.set_wireframe(true);
			}
			this.materials.push(material);
		}
		if(this.materials.length == 0) {
			let texture = src_ResourceLoader.getResource("data/shapes/pads/white.jpg",src_ResourceLoader.getTexture,this.textureResources);
			texture.set_wrap(h3d_mat_Wrap.Repeat);
			let dtsshader = new shaders_DtsTexture();
			let mat = h3d_mat_Material.create();
			mat.set_texture(texture);
			dtsshader.texture__ = texture;
			mat.passes.addShader(dtsshader);
			mat.set_castShadows(false);
			mat.set_receiveShadows(false);
			this.materials.push(mat);
			src_Console.instance.addEntry("warn","No materials found for " + this.dtsPath + "}");
		}
	}
	parseIfl(path) {
		let text = src_ResourceLoader.getFileEntry(path).entry.getText();
		let lines = text.split("\n");
		let keyframes = [];
		let _g = 0;
		while(_g < lines.length) {
			let line = lines[_g];
			++_g;
			line = StringTools.trim(line);
			if(HxOverrides.substr(line,0,2) == "//") {
				continue;
			}
			if(line == "") {
				continue;
			}
			let parts = line.split(" ");
			let count = parts.length > 1 ? Std.parseInt(parts[1]) : 1;
			let _g1 = 0;
			let _g2 = count;
			while(_g1 < _g2) {
				++_g1;
				keyframes.push(parts[0]);
			}
		}
		return keyframes;
	}
	updateNodeTransforms(quaternions,translations,bitField) {
		if(bitField == null) {
			bitField = -1;
		}
		let _g = 0;
		let _g1 = this.graphNodes.length;
		while(_g < _g1) {
			let i = _g++;
			let translation = this.dts.defaultTranslations[i];
			let rotation = this.dts.defaultRotations[i];
			let mat = h3d_Matrix.I();
			let x = -rotation.x;
			let y = rotation.y;
			let z = rotation.z;
			let w = -rotation.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let quat_x = x;
			let quat_y = y;
			let quat_z = z;
			let quat_w = w;
			let len = quat_x * quat_x + quat_y * quat_y + quat_z * quat_z + quat_w * quat_w;
			if(len < 1e-10) {
				quat_z = 0;
				quat_y = quat_z;
				quat_x = quat_y;
				quat_w = 1;
			} else {
				let m = 1. / Math.sqrt(len);
				quat_x *= m;
				quat_y *= m;
				quat_z *= m;
				quat_w *= m;
			}
			quat_x = -quat_x;
			quat_y = -quat_y;
			quat_z = -quat_z;
			let m = mat;
			if(mat == null) {
				m = new h3d_Matrix();
			}
			let xx = quat_x * quat_x;
			let xy = quat_x * quat_y;
			let xz = quat_x * quat_z;
			let xw = quat_x * quat_w;
			let yy = quat_y * quat_y;
			let yz = quat_y * quat_z;
			let yw = quat_y * quat_w;
			let zz = quat_z * quat_z;
			let zw = quat_z * quat_w;
			m._11 = 1 - 2 * (yy + zz);
			m._12 = 2 * (xy + zw);
			m._13 = 2 * (xz - yw);
			m._14 = 0;
			m._21 = 2 * (xy - zw);
			m._22 = 1 - 2 * (xx + zz);
			m._23 = 2 * (yz + xw);
			m._24 = 0;
			m._31 = 2 * (xz + yw);
			m._32 = 2 * (yz - xw);
			m._33 = 1 - 2 * (xx + yy);
			m._34 = 0;
			m._41 = 0;
			m._42 = 0;
			m._43 = 0;
			m._44 = 1;
			let x1 = -translation.x;
			let y1 = translation.y;
			let z1 = translation.z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let v_x = x1;
			let v_y = y1;
			let v_z = z1;
			mat._41 = v_x;
			mat._42 = v_y;
			mat._43 = v_z;
			mat._44 = 1.;
			this.graphNodes[i].setTransform(mat);
			let absTform = this.graphNodes[i].getAbsPos().clone();
			if(this.colliders[i] != null) {
				this.colliders[i].setTransform(absTform);
			}
		}
	}
	generateCollisionGeometry(dtsMesh,vertices,vertexNormals,node) {
		let hulls = [new collision_CollisionEntity(this)];
		let ent = hulls[0];
		ent.userData = node;
		ent.correctNormals = true;
		let _g = 0;
		let _g1 = dtsMesh.primitives;
		while(_g < _g1.length) {
			let primitive = _g1[_g];
			++_g;
			let hs = new collision_CollisionSurface();
			hs.points = [];
			hs.normals = [];
			hs.indices = [];
			hs.transformKeys = [];
			let material = this.dts.matNames[primitive.matIndex & dts_TSDrawPrimitive.MaterialMask];
			if(Object.prototype.hasOwnProperty.call(src_DtsObject_dtsMaterials.h,material) && !this.isTSStatic) {
				let data = src_DtsObject_dtsMaterials.h[material];
				hs.friction = data.friction;
				hs.force = data.force;
				hs.restitution = data.restitution;
			}
			let drawType = primitive.matIndex & dts_TSDrawPrimitive.TypeMask;
			if(drawType == dts_TSDrawPrimitive.Triangles) {
				let i = primitive.firstElement;
				while(i < primitive.firstElement + primitive.numElements) {
					let i1 = dtsMesh.indices[i];
					let i2 = dtsMesh.indices[i + 1];
					let i3 = dtsMesh.indices[i + 2];
					let vertex = vertices[i1];
					let y = vertex.y;
					let z = vertex.z;
					hs.points.push(vertex.x);
					hs.points.push(y);
					hs.points.push(z);
					hs.transformKeys.push(0);
					let normal = vertexNormals[i1];
					let y1 = normal.y;
					let z1 = normal.z;
					hs.normals.push(normal.x);
					hs.normals.push(y1);
					hs.normals.push(z1);
					let vertex1 = vertices[i2];
					let y2 = vertex1.y;
					let z2 = vertex1.z;
					hs.points.push(vertex1.x);
					hs.points.push(y2);
					hs.points.push(z2);
					hs.transformKeys.push(0);
					let normal1 = vertexNormals[i2];
					let y3 = normal1.y;
					let z3 = normal1.z;
					hs.normals.push(normal1.x);
					hs.normals.push(y3);
					hs.normals.push(z3);
					let vertex2 = vertices[i3];
					let y4 = vertex2.y;
					let z4 = vertex2.z;
					hs.points.push(vertex2.x);
					hs.points.push(y4);
					hs.points.push(z4);
					hs.transformKeys.push(0);
					let normal2 = vertexNormals[i3];
					let y5 = normal2.y;
					let z5 = normal2.z;
					hs.normals.push(normal2.x);
					hs.normals.push(y5);
					hs.normals.push(z5);
					hs.indices.push(hs.indices.length);
					hs.indices.push(hs.indices.length);
					hs.indices.push(hs.indices.length);
					i += 3;
				}
			} else if(drawType == dts_TSDrawPrimitive.Strip) {
				let k = 0;
				let _g = primitive.firstElement;
				let _g1 = primitive.firstElement + primitive.numElements - 2;
				while(_g < _g1) {
					let i = _g++;
					let i1 = dtsMesh.indices[i];
					let i2 = dtsMesh.indices[i + 1];
					let i3 = dtsMesh.indices[i + 2];
					if(k % 2 == 0) {
						let temp = i1;
						i1 = i3;
						i3 = temp;
					}
					let index = i1;
					let vertex = vertices[index];
					let y = vertex.y;
					let z = vertex.z;
					hs.points.push(vertex.x);
					hs.points.push(y);
					hs.points.push(z);
					hs.transformKeys.push(0);
					let normal = vertexNormals[index];
					let y1 = normal.y;
					let z1 = normal.z;
					hs.normals.push(normal.x);
					hs.normals.push(y1);
					hs.normals.push(z1);
					let vertex1 = vertices[i2];
					let y2 = vertex1.y;
					let z2 = vertex1.z;
					hs.points.push(vertex1.x);
					hs.points.push(y2);
					hs.points.push(z2);
					hs.transformKeys.push(0);
					let normal1 = vertexNormals[i2];
					let y3 = normal1.y;
					let z3 = normal1.z;
					hs.normals.push(normal1.x);
					hs.normals.push(y3);
					hs.normals.push(z3);
					let index1 = i3;
					let vertex2 = vertices[index1];
					let y4 = vertex2.y;
					let z4 = vertex2.z;
					hs.points.push(vertex2.x);
					hs.points.push(y4);
					hs.points.push(z4);
					hs.transformKeys.push(0);
					let normal2 = vertexNormals[index1];
					let y5 = normal2.y;
					let z5 = normal2.z;
					hs.normals.push(normal2.x);
					hs.normals.push(y5);
					hs.normals.push(z5);
					hs.indices.push(hs.indices.length);
					hs.indices.push(hs.indices.length);
					hs.indices.push(hs.indices.length);
					++k;
				}
			} else if(drawType == dts_TSDrawPrimitive.Fan) {
				let i = primitive.firstElement;
				while(i < primitive.firstElement + primitive.numElements - 2) {
					let i1 = dtsMesh.indices[primitive.firstElement];
					let i2 = dtsMesh.indices[i + 1];
					let i3 = dtsMesh.indices[i + 2];
					let vertex = vertices[i1];
					let y = vertex.y;
					let z = vertex.z;
					hs.points.push(vertex.x);
					hs.points.push(y);
					hs.points.push(z);
					hs.transformKeys.push(0);
					let normal = vertexNormals[i1];
					let y1 = normal.y;
					let z1 = normal.z;
					hs.normals.push(normal.x);
					hs.normals.push(y1);
					hs.normals.push(z1);
					let vertex1 = vertices[i2];
					let y2 = vertex1.y;
					let z2 = vertex1.z;
					hs.points.push(vertex1.x);
					hs.points.push(y2);
					hs.points.push(z2);
					hs.transformKeys.push(0);
					let normal1 = vertexNormals[i2];
					let y3 = normal1.y;
					let z3 = normal1.z;
					hs.normals.push(normal1.x);
					hs.normals.push(y3);
					hs.normals.push(z3);
					let vertex2 = vertices[i3];
					let y4 = vertex2.y;
					let z4 = vertex2.z;
					hs.points.push(vertex2.x);
					hs.points.push(y4);
					hs.points.push(z4);
					hs.transformKeys.push(0);
					let normal2 = vertexNormals[i3];
					let y5 = normal2.y;
					let z5 = normal2.z;
					hs.normals.push(normal2.x);
					hs.normals.push(y5);
					hs.normals.push(z5);
					hs.indices.push(hs.indices.length);
					hs.indices.push(hs.indices.length);
					hs.indices.push(hs.indices.length);
					++i;
				}
			}
			hs.generateBoundingBox();
			ent.addSurface(hs);
		}
		ent.generateBoundingBox();
		ent.finalize();
		return hulls;
	}
	generateMaterialGeometry(dtsMesh,vertices,vertexNormals) {
		let _this = this.dts.matNames;
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = { vertices : [], normals : [], uvs : [], indices : [], tangents : [], bitangents : [], texNormals : []};
		}
		if(result.length == 0 && dtsMesh.primitives.length > 0) {
			result.push({ vertices : [], normals : [], uvs : [], indices : [], tangents : [], bitangents : [], texNormals : []});
		}
		let normalizeSafe = function(v) {
			let mag = v.x * v.x <= 1e-4 && v.y * v.y <= 1e-4 && v.z * v.z <= 1e-4 ? 0.0 : Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
			if(mag > 1e-4) {
				let f = 1 / mag;
				v.x *= f;
				v.y *= f;
				v.z *= f;
			}
		};
		let createTextureSpaceMatrix = function(i0,i1,i2) {
			let t0 = new h3d_Vector();
			let t1 = new h3d_Vector();
			let t2 = new h3d_Vector();
			let b0 = new h3d_Vector();
			let b1 = new h3d_Vector();
			let b2 = new h3d_Vector();
			let fVar1 = vertices[i1].x - vertices[i0].x;
			let fVar2 = vertices[i2].x - vertices[i0].x;
			let fVar4 = dtsMesh.uv[i1].x - dtsMesh.uv[i0].x;
			let fVar5 = dtsMesh.uv[i2].x - dtsMesh.uv[i0].x;
			let fVar6 = dtsMesh.uv[i1].y - dtsMesh.uv[i0].y;
			let fVar7 = dtsMesh.uv[i2].y - dtsMesh.uv[i0].y;
			let fVar3 = fVar7 * fVar4 - fVar5 * fVar6;
			if(1e-12 < Math.abs(fVar3)) {
				fVar3 = 1.0 / fVar3;
				fVar4 = -(fVar3 * (fVar5 * fVar1 - fVar4 * fVar2));
				fVar1 = -(fVar3 * (fVar6 * fVar2 - fVar7 * fVar1));
				t0.x = fVar1;
				t1.x = fVar1;
				t2.x = fVar1;
				b0.x = fVar4;
				b1.x = fVar4;
				b2.x = fVar4;
			}
			fVar1 = dtsMesh.uv[i1].x - dtsMesh.uv[i0].x;
			fVar2 = dtsMesh.uv[i2].x - dtsMesh.uv[i0].x;
			fVar3 = dtsMesh.uv[i1].y - dtsMesh.uv[i0].y;
			fVar6 = vertices[i1].y - vertices[i0].y;
			fVar4 = dtsMesh.uv[i2].y - dtsMesh.uv[i0].y;
			fVar7 = vertices[i2].y - vertices[i0].y;
			fVar5 = fVar4 * fVar1 - fVar2 * fVar3;
			if(1e-12 < Math.abs(fVar5)) {
				fVar5 = 1.0 / fVar5;
				fVar3 = -(fVar5 * (fVar3 * fVar7 - fVar4 * fVar6));
				fVar1 = -(fVar5 * (fVar2 * fVar6 - fVar1 * fVar7));
				b0.y = fVar1;
				b1.y = fVar1;
				b2.y = fVar1;
				t0.y = fVar3;
				t1.y = fVar3;
				t2.y = fVar3;
			}
			fVar1 = dtsMesh.uv[i1].x - dtsMesh.uv[i0].x;
			fVar2 = dtsMesh.uv[i2].x - dtsMesh.uv[i0].x;
			fVar3 = dtsMesh.uv[i1].y - dtsMesh.uv[i0].y;
			fVar5 = vertices[i1].z - vertices[i0].z;
			fVar4 = dtsMesh.uv[i2].y - dtsMesh.uv[i0].y;
			fVar6 = vertices[i2].z - vertices[i0].z;
			fVar7 = fVar4 * fVar1 - fVar2 * fVar3;
			if(1e-12 < Math.abs(fVar7)) {
				fVar7 = 1.0 / fVar7;
				fVar3 = -(fVar7 * (fVar3 * fVar6 - fVar4 * fVar5));
				fVar1 = -(fVar7 * (fVar2 * fVar5 - fVar1 * fVar6));
				b0.z = fVar1;
				b1.z = fVar1;
				b2.z = fVar1;
				t0.z = fVar3;
				t1.z = fVar3;
				t2.z = fVar3;
			}
			normalizeSafe(t0);
			normalizeSafe(b0);
			let x = t0.y * b0.z - t0.z * b0.y;
			let y = t0.z * b0.x - t0.x * b0.z;
			let z = t0.x * b0.y - t0.y * b0.x;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let n0_x = x;
			let n0_y = y;
			let n0_z = z;
			let v = vertexNormals[i0];
			if(n0_x * v.x + n0_y * v.y + n0_z * v.z < 0.0) {
				n0_x *= -1;
				n0_y *= -1;
				n0_z *= -1;
			}
			normalizeSafe(t1);
			normalizeSafe(b1);
			let x1 = t1.y * b1.z - t1.z * b1.y;
			let y1 = t1.z * b1.x - t1.x * b1.z;
			let z1 = t1.x * b1.y - t1.y * b1.x;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let n1_x = x1;
			let n1_y = y1;
			let n1_z = z1;
			let v1 = vertexNormals[i1];
			if(n1_x * v1.x + n1_y * v1.y + n1_z * v1.z < 0.0) {
				n1_x *= -1;
				n1_y *= -1;
				n1_z *= -1;
			}
			normalizeSafe(t2);
			normalizeSafe(b2);
			let x2 = t2.y * b2.z - t2.z * b2.y;
			let y2 = t2.z * b2.x - t2.x * b2.z;
			let z2 = t2.x * b2.y - t2.y * b2.x;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let n2_x = x2;
			let n2_y = y2;
			let n2_z = z2;
			let v2 = vertexNormals[i2];
			if(n2_x * v2.x + n2_y * v2.y + n2_z * v2.z < 0.0) {
				n2_x *= -1;
				n2_y *= -1;
				n2_z *= -1;
			}
			t0.x *= -1;
			t1.x *= -1;
			t2.x *= -1;
			b0.x *= -1;
			b1.x *= -1;
			b2.x *= -1;
			n0_x *= -1;
			n1_x *= -1;
			n2_x *= -1;
			return [{ tangent : new h3d_col_Point(t0.x,t0.y,t0.z), bitangent : new h3d_col_Point(b0.x,b0.y,b0.z), normal : new h3d_col_Point(n0_x,n0_y,n0_z)},{ tangent : new h3d_col_Point(t1.x,t1.y,t1.z), bitangent : new h3d_col_Point(b1.x,b1.y,b1.z), normal : new h3d_col_Point(n1_x,n1_y,n1_z)},{ tangent : new h3d_col_Point(t2.x,t2.y,t2.z), bitangent : new h3d_col_Point(b2.x,b2.y,b2.z), normal : new h3d_col_Point(n2_x,n2_y,n2_z)}];
		};
		let triangles = [];
		let ab_z;
		let ab_y;
		let ab_x;
		let ab_w;
		ab_x = 0.;
		ab_y = 0.;
		ab_z = 0.;
		ab_w = 1.;
		let ac_z;
		let ac_y;
		let ac_x;
		let ac_w;
		ac_x = 0.;
		ac_y = 0.;
		ac_z = 0.;
		ac_w = 1.;
		let addTriangleFromIndices = function(i1,i2,i3,materialIndex) {
			let x = vertices[i2].x - vertices[i1].x;
			let y = vertices[i2].y - vertices[i1].y;
			let z = vertices[i2].z - vertices[i1].z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			ab_x = x;
			ab_y = y;
			ab_z = z;
			ab_w = 1.;
			let x1 = vertices[i3].x - vertices[i1].x;
			let y1 = vertices[i3].y - vertices[i1].y;
			let z1 = vertices[i3].z - vertices[i1].z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			ac_x = x1;
			ac_y = y1;
			ac_z = z1;
			ac_w = 1.;
			let x2 = ab_y * ac_z - ab_z * ac_y;
			let y2 = ab_z * ac_x - ab_x * ac_z;
			let z2 = ab_x * ac_y - ab_y * ac_x;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let tri = { material : materialIndex, vertices : [new h3d_col_Point(vertices[i3].x,vertices[i3].y,vertices[i3].z),new h3d_col_Point(vertices[i2].x,vertices[i2].y,vertices[i2].z),new h3d_col_Point(vertices[i1].x,vertices[i1].y,vertices[i1].z)], uvs : [new h3d_prim_UV(dtsMesh.uv[i3].x,dtsMesh.uv[i3].y),new h3d_prim_UV(dtsMesh.uv[i2].x,dtsMesh.uv[i2].y),new h3d_prim_UV(dtsMesh.uv[i1].x,dtsMesh.uv[i1].y)], normals : [new h3d_col_Point(vertexNormals[i3].x,vertexNormals[i3].y,vertexNormals[i3].z),new h3d_col_Point(vertexNormals[i2].x,vertexNormals[i2].y,vertexNormals[i2].z),new h3d_col_Point(vertexNormals[i1].x,vertexNormals[i1].y,vertexNormals[i1].z)], indices : [i1,i2,i3], t : [], b : [], n : []};
			return tri;
		};
		let _g2 = 0;
		let _g3 = dtsMesh.primitives;
		while(_g2 < _g3.length) {
			let primitive = _g3[_g2];
			++_g2;
			let materialIndex = primitive.matIndex & dts_TSDrawPrimitive.MaterialMask;
			let drawType = primitive.matIndex & dts_TSDrawPrimitive.TypeMask;
			if(drawType == dts_TSDrawPrimitive.Triangles) {
				let i = primitive.firstElement;
				while(i < primitive.firstElement + primitive.numElements) {
					let i1 = dtsMesh.indices[i];
					let i2 = dtsMesh.indices[i + 1];
					let i3 = dtsMesh.indices[i + 2];
					let tri = addTriangleFromIndices(i1,i2,i3,materialIndex);
					let tbn = createTextureSpaceMatrix(dtsMesh.indices[i],dtsMesh.indices[i + 1],dtsMesh.indices[i + 2]);
					tri.t.push(tbn[2].tangent);
					tri.t.push(tbn[1].tangent);
					tri.t.push(tbn[0].tangent);
					tri.b.push(tbn[2].bitangent);
					tri.b.push(tbn[1].bitangent);
					tri.b.push(tbn[0].bitangent);
					tri.n.push(tbn[2].normal);
					tri.n.push(tbn[1].normal);
					tri.n.push(tbn[0].normal);
					triangles.push(tri);
					i += 3;
				}
			} else if(drawType == dts_TSDrawPrimitive.Strip) {
				let k = 0;
				let _g = primitive.firstElement;
				let _g1 = primitive.firstElement + primitive.numElements - 2;
				while(_g < _g1) {
					let i = _g++;
					let i1 = dtsMesh.indices[i];
					let i2 = dtsMesh.indices[i + 1];
					let i3 = dtsMesh.indices[i + 2];
					if(k % 2 == 0) {
						let temp = i1;
						i1 = i3;
						i3 = temp;
					}
					let tri = addTriangleFromIndices(i1,i2,i3,materialIndex);
					let tbn = createTextureSpaceMatrix(dtsMesh.indices[i],dtsMesh.indices[i + 1],dtsMesh.indices[i + 2]);
					tri.t.push(tbn[2].tangent);
					tri.t.push(tbn[1].tangent);
					tri.t.push(tbn[0].tangent);
					tri.b.push(tbn[2].bitangent);
					tri.b.push(tbn[1].bitangent);
					tri.b.push(tbn[0].bitangent);
					tri.n.push(tbn[2].normal);
					tri.n.push(tbn[1].normal);
					tri.n.push(tbn[0].normal);
					triangles.push(tri);
					++k;
				}
			} else if(drawType == dts_TSDrawPrimitive.Fan) {
				let i = primitive.firstElement;
				while(i < primitive.firstElement + primitive.numElements - 2) {
					let i1 = dtsMesh.indices[primitive.firstElement];
					let i2 = dtsMesh.indices[i + 1];
					let i3 = dtsMesh.indices[i + 2];
					let tri = addTriangleFromIndices(i1,i2,i3,materialIndex);
					let tbn = createTextureSpaceMatrix(dtsMesh.indices[primitive.firstElement],dtsMesh.indices[i + 1],dtsMesh.indices[i + 2]);
					tri.t.push(tbn[2].tangent);
					tri.t.push(tbn[1].tangent);
					tri.t.push(tbn[0].tangent);
					tri.b.push(tbn[2].bitangent);
					tri.b.push(tbn[1].bitangent);
					tri.b.push(tbn[0].bitangent);
					tri.n.push(tbn[2].normal);
					tri.n.push(tbn[1].normal);
					tri.n.push(tbn[0].normal);
					triangles.push(tri);
					++i;
				}
			}
		}
		let vertexBuckets = new haxe_ds_ObjectMap();
		let _g4 = 0;
		let _g5 = triangles.length;
		while(_g4 < _g5) {
			let i = _g4++;
			let tri = triangles[i];
			let _this = tri.normals[0];
			let p = tri.normals[1];
			let x = _this.x + p.x;
			let y = _this.y + p.y;
			let z = _this.z + p.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let _this_x = x;
			let _this_y = y;
			let _this_z = z;
			let p1 = tri.normals[2];
			let x1 = _this_x + p1.x;
			let y1 = _this_y + p1.y;
			let z1 = _this_z + p1.z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let _this_x1 = x1;
			let _this_y1 = y1;
			let _this_z1 = z1;
			let norm = new h3d_col_Point(_this_x1 * 0.33333333333333331,_this_y1 * 0.33333333333333331,_this_z1 * 0.33333333333333331);
			let _g = 0;
			let _g1 = triangles[i].vertices.length;
			while(_g < _g1) {
				let k = _g++;
				let v = triangles[i].vertices[k];
				let buckets = vertexBuckets.h[v.__id__];
				if(buckets == null) {
					buckets = [];
					vertexBuckets.set(v,buckets);
				}
				let bucket = null;
				let _g1 = 0;
				let _g2 = buckets.length;
				while(_g1 < _g2) {
					let j = _g1++;
					bucket = buckets[j];
					let _this = tri.normals[k];
					let p = bucket.refNormal;
					if(_this.x * p.x + _this.y * p.y + _this.z * p.z > Math.cos(Math.PI / 12)) {
						break;
					}
					bucket = null;
				}
				if(bucket == null) {
					bucket = { refNormal : norm, triangles : [], normals : [], ns : []};
					buckets.push(bucket);
				}
				bucket.triangles.push(i);
				bucket.normals.push(tri.normals[k]);
				bucket.ns.push(tri.n[k]);
			}
		}
		let map = vertexBuckets;
		let _g_keys = map.keys();
		while(_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = map.get(key);
			let _g = 0;
			let _g1 = _g_value.length;
			while(_g < _g1) {
				let i = _g++;
				let bucket = _g_value[i];
				let avgNormal = new h3d_col_Point();
				let averageN = new h3d_col_Point();
				let _g1 = 0;
				let _g2 = bucket.normals;
				while(_g1 < _g2.length) {
					let normal = _g2[_g1];
					++_g1;
					avgNormal = new h3d_col_Point(avgNormal.x + normal.x,avgNormal.y + normal.y,avgNormal.z + normal.z);
				}
				let v = 1 / bucket.normals.length;
				avgNormal.x *= v;
				avgNormal.y *= v;
				avgNormal.z *= v;
				let _g3 = 0;
				let _g4 = bucket.ns;
				while(_g3 < _g4.length) {
					let n = _g4[_g3];
					++_g3;
					averageN = new h3d_col_Point(averageN.x + n.x,averageN.y + n.y,averageN.z + n.z);
				}
				let v1 = 1 / bucket.ns.length;
				averageN.x *= v1;
				averageN.y *= v1;
				averageN.z *= v1;
				let _g5 = 0;
				let _g6 = bucket.triangles.length;
				while(_g5 < _g6) {
					let j = _g5++;
					let index = bucket.triangles[j];
					let tri = triangles[index];
					if(tri.vertices[0] == key) {
						tri.normals[0] = avgNormal;
						tri.n[0] = averageN;
						let _this = tri.t[0];
						let p = tri.t[0];
						let v = averageN.x * p.x + averageN.y * p.y + averageN.z * p.z;
						let x = averageN.x * v;
						let y = averageN.y * v;
						let z = averageN.z * v;
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let p_x = x;
						let p_y = y;
						let p_z = z;
						let x1 = _this.x - p_x;
						let y1 = _this.y - p_y;
						let z1 = _this.z - p_z;
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let _this_x = x1;
						let _this_y = y1;
						let _this_z = z1;
						let k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
						if(k < 1e-10) {
							k = 0;
						} else {
							k = 1. / Math.sqrt(k);
						}
						tri.t[0] = new h3d_col_Point(_this_x * k,_this_y * k,_this_z * k);
						let _this1 = tri.b[0];
						let p1 = tri.b[0];
						let v1 = averageN.x * p1.x + averageN.y * p1.y + averageN.z * p1.z;
						let x2 = averageN.x * v1;
						let y2 = averageN.y * v1;
						let z2 = averageN.z * v1;
						if(z2 == null) {
							z2 = 0.;
						}
						if(y2 == null) {
							y2 = 0.;
						}
						if(x2 == null) {
							x2 = 0.;
						}
						let p_x1 = x2;
						let p_y1 = y2;
						let p_z1 = z2;
						let x3 = _this1.x - p_x1;
						let y3 = _this1.y - p_y1;
						let z3 = _this1.z - p_z1;
						if(z3 == null) {
							z3 = 0.;
						}
						if(y3 == null) {
							y3 = 0.;
						}
						if(x3 == null) {
							x3 = 0.;
						}
						let _this_x1 = x3;
						let _this_y1 = y3;
						let _this_z1 = z3;
						let k1 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
						if(k1 < 1e-10) {
							k1 = 0;
						} else {
							k1 = 1. / Math.sqrt(k1);
						}
						tri.b[0] = new h3d_col_Point(_this_x1 * k1,_this_y1 * k1,_this_z1 * k1);
					}
					if(tri.vertices[1] == key) {
						tri.normals[1] = avgNormal;
						tri.n[1] = averageN;
						let _this = tri.t[1];
						let p = tri.t[1];
						let v = averageN.x * p.x + averageN.y * p.y + averageN.z * p.z;
						let x = averageN.x * v;
						let y = averageN.y * v;
						let z = averageN.z * v;
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let p_x = x;
						let p_y = y;
						let p_z = z;
						let x1 = _this.x - p_x;
						let y1 = _this.y - p_y;
						let z1 = _this.z - p_z;
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let _this_x = x1;
						let _this_y = y1;
						let _this_z = z1;
						let k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
						if(k < 1e-10) {
							k = 0;
						} else {
							k = 1. / Math.sqrt(k);
						}
						tri.t[1] = new h3d_col_Point(_this_x * k,_this_y * k,_this_z * k);
						let _this1 = tri.b[1];
						let p1 = tri.b[1];
						let v1 = averageN.x * p1.x + averageN.y * p1.y + averageN.z * p1.z;
						let x2 = averageN.x * v1;
						let y2 = averageN.y * v1;
						let z2 = averageN.z * v1;
						if(z2 == null) {
							z2 = 0.;
						}
						if(y2 == null) {
							y2 = 0.;
						}
						if(x2 == null) {
							x2 = 0.;
						}
						let p_x1 = x2;
						let p_y1 = y2;
						let p_z1 = z2;
						let x3 = _this1.x - p_x1;
						let y3 = _this1.y - p_y1;
						let z3 = _this1.z - p_z1;
						if(z3 == null) {
							z3 = 0.;
						}
						if(y3 == null) {
							y3 = 0.;
						}
						if(x3 == null) {
							x3 = 0.;
						}
						let _this_x1 = x3;
						let _this_y1 = y3;
						let _this_z1 = z3;
						let k1 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
						if(k1 < 1e-10) {
							k1 = 0;
						} else {
							k1 = 1. / Math.sqrt(k1);
						}
						tri.b[1] = new h3d_col_Point(_this_x1 * k1,_this_y1 * k1,_this_z1 * k1);
					}
					if(tri.vertices[2] == key) {
						tri.normals[2] = avgNormal;
						tri.n[2] = averageN;
						let _this = tri.t[2];
						let p = tri.t[2];
						let v = averageN.x * p.x + averageN.y * p.y + averageN.z * p.z;
						let x = averageN.x * v;
						let y = averageN.y * v;
						let z = averageN.z * v;
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let p_x = x;
						let p_y = y;
						let p_z = z;
						let x1 = _this.x - p_x;
						let y1 = _this.y - p_y;
						let z1 = _this.z - p_z;
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let _this_x = x1;
						let _this_y = y1;
						let _this_z = z1;
						let k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
						if(k < 1e-10) {
							k = 0;
						} else {
							k = 1. / Math.sqrt(k);
						}
						tri.t[2] = new h3d_col_Point(_this_x * k,_this_y * k,_this_z * k);
						let _this1 = tri.b[2];
						let p1 = tri.b[2];
						let v1 = averageN.x * p1.x + averageN.y * p1.y + averageN.z * p1.z;
						let x2 = averageN.x * v1;
						let y2 = averageN.y * v1;
						let z2 = averageN.z * v1;
						if(z2 == null) {
							z2 = 0.;
						}
						if(y2 == null) {
							y2 = 0.;
						}
						if(x2 == null) {
							x2 = 0.;
						}
						let p_x1 = x2;
						let p_y1 = y2;
						let p_z1 = z2;
						let x3 = _this1.x - p_x1;
						let y3 = _this1.y - p_y1;
						let z3 = _this1.z - p_z1;
						if(z3 == null) {
							z3 = 0.;
						}
						if(y3 == null) {
							y3 = 0.;
						}
						if(x3 == null) {
							x3 = 0.;
						}
						let _this_x1 = x3;
						let _this_y1 = y3;
						let _this_z1 = z3;
						let k1 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
						if(k1 < 1e-10) {
							k1 = 0;
						} else {
							k1 = 1. / Math.sqrt(k1);
						}
						tri.b[2] = new h3d_col_Point(_this_x1 * k1,_this_y1 * k1,_this_z1 * k1);
					}
				}
			}
		}
		let _g6 = 0;
		while(_g6 < triangles.length) {
			let tri = triangles[_g6];
			++_g6;
			let matGeo = result[tri.material];
			matGeo.vertices.push(tri.vertices[0]);
			matGeo.vertices.push(tri.vertices[1]);
			matGeo.vertices.push(tri.vertices[2]);
			matGeo.normals.push(tri.normals[0]);
			matGeo.normals.push(tri.normals[1]);
			matGeo.normals.push(tri.normals[2]);
			matGeo.tangents.push(tri.t[0]);
			matGeo.tangents.push(tri.t[1]);
			matGeo.tangents.push(tri.t[2]);
			matGeo.bitangents.push(tri.b[0]);
			matGeo.bitangents.push(tri.b[1]);
			matGeo.bitangents.push(tri.b[2]);
			matGeo.texNormals.push(tri.n[0]);
			matGeo.texNormals.push(tri.n[1]);
			matGeo.texNormals.push(tri.n[2]);
			matGeo.uvs.push(tri.uvs[0]);
			matGeo.uvs.push(tri.uvs[1]);
			matGeo.uvs.push(tri.uvs[2]);
			matGeo.indices.push(tri.indices[0]);
			matGeo.indices.push(tri.indices[1]);
			matGeo.indices.push(tri.indices[2]);
		}
		return result;
	}
	setTransform(mat) {
		super.setTransform(mat);
		if(this.isBoundingBoxCollideable) {
			this.boundingCollider.setTransform(mat);
			this.collisionWorld.updateTransform(this.boundingCollider);
		}
		let _g = 0;
		let _g1 = this.dirtyTransforms.length;
		while(_g < _g1) {
			let i = _g++;
			this.dirtyTransforms[i] = true;
		}
	}
	propagateDirtyFlags(nodeIndex,doSiblings) {
		if(doSiblings == null) {
			doSiblings = false;
		}
		this.dirtyTransforms[nodeIndex] = true;
		if(this.dts.nodes[nodeIndex].firstChild != -1) {
			this.propagateDirtyFlags(this.dts.nodes[nodeIndex].firstChild,true);
		}
		if(doSiblings) {
			if(this.dts.nodes[nodeIndex].nextSibling != -1) {
				this.propagateDirtyFlags(this.dts.nodes[nodeIndex].nextSibling,true);
			}
		}
	}
	update(timeState) {
		let _g = 0;
		let _g1 = this.dts.sequences;
		while(_g < _g1.length) {
			let sequence = _g1[_g];
			++_g;
			if(!this.showSequences) {
				break;
			}
			if(!this.hasNonVisualSequences) {
				break;
			}
			let rot = sequence.rotationMatters.length > 0 ? sequence.rotationMatters[0] : 0;
			let trans = sequence.translationMatters.length > 0 ? sequence.translationMatters[0] : 0;
			let scale = sequence.scaleMatters.length > 0 ? sequence.scaleMatters[0] : 0;
			let vis = sequence.visMatters.length > 0 ? sequence.visMatters[0] : 0;
			let affectedCount = 0;
			let completion = timeState.timeSinceLoad / sequence.duration;
			if(this.doSequenceOnce) {
				let value = (timeState.timeSinceLoad - this.doSequenceOnceBeginTime) / sequence.duration;
				completion = value < 0 ? 0 : value > 0.98 ? 0.98 : value;
			}
			let actualKeyframe = this.sequenceKeyframeOverride.h.__keys__[sequence.__id__] != null ? this.sequenceKeyframeOverride.h[sequence.__id__] : completion * sequence.numKeyFrames % sequence.numKeyFrames;
			if(this.lastSequenceKeyframes.h[sequence.__id__] == actualKeyframe) {
				continue;
			}
			this.lastSequenceKeyframes.set(sequence,actualKeyframe);
			let keyframeLow = Math.floor(actualKeyframe);
			let keyframeHigh = this.doSequenceOnce ? Math.ceil(actualKeyframe) : Math.ceil(actualKeyframe) % sequence.numKeyFrames;
			if(this.doSequenceOnce && keyframeHigh >= sequence.numKeyFrames) {
				continue;
			}
			let t = (actualKeyframe - keyframeLow) % 1;
			if(rot > 0 || trans > 0 || scale > 0) {
				if(!this.sharedNodeTransforms || this.isSharedGraphNodesRoot) {
					if(rot > 0) {
						let _g = 0;
						let _g1 = this.dts.nodes.length;
						while(_g < _g1) {
							let i = _g++;
							let affected = (1 << i & rot) != 0;
							if(affected) {
								let rot1 = this.dts.nodeRotations[sequence.baseRotation + sequence.numKeyFrames * affectedCount + keyframeLow];
								let rot2 = this.dts.nodeRotations[sequence.baseRotation + sequence.numKeyFrames * affectedCount + keyframeHigh];
								let x = -rot1.x;
								let y = rot1.y;
								let z = rot1.z;
								let w = -rot1.w;
								if(w == null) {
									w = 1.;
								}
								if(z == null) {
									z = 0.;
								}
								if(y == null) {
									y = 0.;
								}
								if(x == null) {
									x = 0.;
								}
								let q1_x = x;
								let q1_y = y;
								let q1_z = z;
								let q1_w = w;
								let len = q1_x * q1_x + q1_y * q1_y + q1_z * q1_z + q1_w * q1_w;
								if(len < 1e-10) {
									q1_z = 0;
									q1_y = q1_z;
									q1_x = q1_y;
									q1_w = 1;
								} else {
									let m = 1. / Math.sqrt(len);
									q1_x *= m;
									q1_y *= m;
									q1_z *= m;
									q1_w *= m;
								}
								q1_x = -q1_x;
								q1_y = -q1_y;
								q1_z = -q1_z;
								let x1 = -rot2.x;
								let y1 = rot2.y;
								let z1 = rot2.z;
								let w1 = -rot2.w;
								if(w1 == null) {
									w1 = 1.;
								}
								if(z1 == null) {
									z1 = 0.;
								}
								if(y1 == null) {
									y1 = 0.;
								}
								if(x1 == null) {
									x1 = 0.;
								}
								let q2_x = x1;
								let q2_y = y1;
								let q2_z = z1;
								let q2_w = w1;
								let len1 = q2_x * q2_x + q2_y * q2_y + q2_z * q2_z + q2_w * q2_w;
								if(len1 < 1e-10) {
									q2_z = 0;
									q2_y = q2_z;
									q2_x = q2_y;
									q2_w = 1;
								} else {
									let m = 1. / Math.sqrt(len1);
									q2_x *= m;
									q2_y *= m;
									q2_z *= m;
									q2_w *= m;
								}
								q2_x = -q2_x;
								q2_y = -q2_y;
								q2_z = -q2_z;
								let quat_x = 0.;
								let quat_y = 0.;
								let quat_z = 0.;
								let quat_w = 1.;
								let cosHalfTheta = q1_x * q2_x + q1_y * q2_y + q1_z * q2_z + q1_w * q2_w;
								if((cosHalfTheta < 0 ? -cosHalfTheta : cosHalfTheta) >= 1) {
									quat_x = q1_x;
									quat_y = q1_y;
									quat_z = q1_z;
									quat_w = q1_w;
								} else {
									let halfTheta = Math.acos(cosHalfTheta);
									let invSinHalfTheta = 1. / Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
									if((invSinHalfTheta < 0 ? -invSinHalfTheta : invSinHalfTheta) > 1e3) {
										let v = 0.5;
										if(q1_x * q2_x + q1_y * q2_y + q1_z * q2_z + q1_w * q2_w < 0) {
											v = -0.5;
										}
										let x = q1_x * 0.5 + q2_x * v;
										let y = q1_y * 0.5 + q2_y * v;
										let z = q1_z * 0.5 + q2_z * v;
										let w = q1_w * 0.5 + q2_w * v;
										quat_x = x;
										quat_y = y;
										quat_z = z;
										quat_w = w;
									} else {
										let a = Math.sin((1 - t) * halfTheta) * invSinHalfTheta;
										let b = Math.sin(t * halfTheta) * invSinHalfTheta * (cosHalfTheta < 0 ? -1 : 1);
										quat_x = q1_x * a + q2_x * b;
										quat_y = q1_y * a + q2_y * b;
										quat_z = q1_z * a + q2_z * b;
										quat_w = q1_w * a + q2_w * b;
									}
								}
								let len2 = quat_x * quat_x + quat_y * quat_y + quat_z * quat_z + quat_w * quat_w;
								if(len2 < 1e-10) {
									quat_z = 0;
									quat_y = quat_z;
									quat_x = quat_y;
									quat_w = 1;
								} else {
									let m = 1. / Math.sqrt(len2);
									quat_x *= m;
									quat_y *= m;
									quat_z *= m;
									quat_w *= m;
								}
								let _this = this.graphNodes[i].getRotationQuat();
								_this.x = quat_x;
								_this.y = quat_y;
								_this.z = quat_z;
								_this.w = quat_w;
								let _this1 = this.graphNodes[i];
								_this1.flags |= 1;
								this.propagateDirtyFlags(i);
								++affectedCount;
							} else {
								let rotation = this.dts.defaultRotations[i];
								let x = -rotation.x;
								let y = rotation.y;
								let z = rotation.z;
								let w = -rotation.w;
								if(w == null) {
									w = 1.;
								}
								if(z == null) {
									z = 0.;
								}
								if(y == null) {
									y = 0.;
								}
								if(x == null) {
									x = 0.;
								}
								let quat_x = x;
								let quat_y = y;
								let quat_z = z;
								let quat_w = w;
								let len = quat_x * quat_x + quat_y * quat_y + quat_z * quat_z + quat_w * quat_w;
								if(len < 1e-10) {
									quat_z = 0;
									quat_y = quat_z;
									quat_x = quat_y;
									quat_w = 1;
								} else {
									let m = 1. / Math.sqrt(len);
									quat_x *= m;
									quat_y *= m;
									quat_z *= m;
									quat_w *= m;
								}
								quat_x = -quat_x;
								quat_y = -quat_y;
								quat_z = -quat_z;
								let _this = this.graphNodes[i].getRotationQuat();
								_this.x = quat_x;
								_this.y = quat_y;
								_this.z = quat_z;
								_this.w = quat_w;
								let _this1 = this.graphNodes[i];
								_this1.flags |= 1;
							}
						}
					}
					affectedCount = 0;
					if(trans > 0) {
						let _g = 0;
						let _g1 = this.dts.nodes.length;
						while(_g < _g1) {
							let i = _g++;
							let affected = (1 << i & trans) != 0;
							if(affected) {
								let trans1 = this.dts.nodeTranslations[sequence.baseTranslation + sequence.numKeyFrames * affectedCount + keyframeLow];
								let trans2 = this.dts.nodeTranslations[sequence.baseTranslation + sequence.numKeyFrames * affectedCount + keyframeHigh];
								let x = -trans1.x;
								let y = trans1.y;
								let z = trans1.z;
								if(z == null) {
									z = 0.;
								}
								if(y == null) {
									y = 0.;
								}
								if(x == null) {
									x = 0.;
								}
								let v1_x = x;
								let v1_y = y;
								let v1_z = z;
								let x1 = -trans2.x;
								let y1 = trans2.y;
								let z1 = trans2.z;
								if(z1 == null) {
									z1 = 0.;
								}
								if(y1 == null) {
									y1 = 0.;
								}
								if(x1 == null) {
									x1 = 0.;
								}
								let v2_x = x1;
								let v2_y = y1;
								let v2_z = z1;
								let x2 = v1_x + (v2_x - v1_x) * t;
								let y2 = v1_y + (v2_y - v1_y) * t;
								let z2 = v1_z + (v2_z - v1_z) * t;
								if(z2 == null) {
									z2 = 0.;
								}
								if(y2 == null) {
									y2 = 0.;
								}
								if(x2 == null) {
									x2 = 0.;
								}
								let trans_x = x2;
								let trans_y = y2;
								let trans_z = z2;
								let _this = this.graphNodes[i];
								_this.x = trans_x;
								_this.flags |= 1;
								_this.y = trans_y;
								_this.flags |= 1;
								_this.z = trans_z;
								_this.flags |= 1;
								_this.flags |= 1;
								this.propagateDirtyFlags(i);
								++affectedCount;
							} else {
								let translation = this.dts.defaultTranslations[i];
								let x = -translation.x;
								let y = translation.y;
								let z = translation.z;
								if(z == null) {
									z = 0.;
								}
								if(y == null) {
									y = 0.;
								}
								if(x == null) {
									x = 0.;
								}
								let trans_x = x;
								let trans_y = y;
								let trans_z = z;
								let _this = this.graphNodes[i];
								_this.x = trans_x;
								_this.flags |= 1;
								_this.y = trans_y;
								_this.flags |= 1;
								_this.z = trans_z;
								_this.flags |= 1;
								_this.flags |= 1;
							}
						}
					}
					affectedCount = 0;
					if(scale > 0) {
						if((sequence.flags & 1) > 0) {
							let _g = 0;
							let _g1 = this.dts.nodes.length;
							while(_g < _g1) {
								let i = _g++;
								let affected = (1 << i & scale) != 0;
								if(affected) {
									let scale1 = this.dts.nodeUniformScales[sequence.baseScale + sequence.numKeyFrames * affectedCount + keyframeLow];
									let scale2 = this.dts.nodeUniformScales[sequence.baseScale + sequence.numKeyFrames * affectedCount + keyframeHigh];
									let x = scale1;
									let y = scale1;
									let z = scale1;
									if(scale1 == null) {
										z = 0.;
									}
									if(scale1 == null) {
										y = 0.;
									}
									if(scale1 == null) {
										x = 0.;
									}
									let v1_x = x;
									let v1_y = y;
									let v1_z = z;
									let x1 = scale2;
									let y1 = scale2;
									let z1 = scale2;
									if(scale2 == null) {
										z1 = 0.;
									}
									if(scale2 == null) {
										y1 = 0.;
									}
									if(scale2 == null) {
										x1 = 0.;
									}
									let v2_x = x1;
									let v2_y = y1;
									let v2_z = z1;
									let x2 = v1_x + (v2_x - v1_x) * t;
									let y2 = v1_y + (v2_y - v1_y) * t;
									let z2 = v1_z + (v2_z - v1_z) * t;
									if(z2 == null) {
										z2 = 0.;
									}
									if(y2 == null) {
										y2 = 0.;
									}
									if(x2 == null) {
										x2 = 0.;
									}
									let scaleVec_x = x2;
									let scaleVec_y = y2;
									let scaleVec_z = z2;
									let _this = this.graphNodes[i];
									_this.scaleX = scaleVec_x;
									_this.flags |= 1;
									let _this1 = this.graphNodes[i];
									_this1.scaleY = scaleVec_y;
									_this1.flags |= 1;
									let _this2 = this.graphNodes[i];
									_this2.scaleZ = scaleVec_z;
									_this2.flags |= 1;
									++affectedCount;
									this.propagateDirtyFlags(i);
								} else {
									let _this = this.graphNodes[i];
									_this.scaleX = 1;
									_this.flags |= 1;
									let _this1 = this.graphNodes[i];
									_this1.scaleY = 1;
									_this1.flags |= 1;
									let _this2 = this.graphNodes[i];
									_this2.scaleZ = 1;
									_this2.flags |= 1;
								}
							}
						}
						if((sequence.flags & 2) > 0) {
							let _g = 0;
							let _g1 = this.dts.nodes.length;
							while(_g < _g1) {
								let i = _g++;
								let affected = (1 << i & scale) != 0;
								if(affected) {
									let scale1 = this.dts.nodeAlignedScales[sequence.baseScale + sequence.numKeyFrames * affectedCount + keyframeLow];
									let scale2 = this.dts.nodeAlignedScales[sequence.baseScale + sequence.numKeyFrames * affectedCount + keyframeHigh];
									let x = scale1.x;
									let y = scale1.y;
									let z = scale1.z;
									if(z == null) {
										z = 0.;
									}
									if(y == null) {
										y = 0.;
									}
									if(x == null) {
										x = 0.;
									}
									let v1_x = x;
									let v1_y = y;
									let v1_z = z;
									let x1 = scale2.x;
									let y1 = scale2.y;
									let z1 = scale2.z;
									if(z1 == null) {
										z1 = 0.;
									}
									if(y1 == null) {
										y1 = 0.;
									}
									if(x1 == null) {
										x1 = 0.;
									}
									let v2_x = x1;
									let v2_y = y1;
									let v2_z = z1;
									let x2 = v1_x + (v2_x - v1_x) * t;
									let y2 = v1_y + (v2_y - v1_y) * t;
									let z2 = v1_z + (v2_z - v1_z) * t;
									if(z2 == null) {
										z2 = 0.;
									}
									if(y2 == null) {
										y2 = 0.;
									}
									if(x2 == null) {
										x2 = 0.;
									}
									let scaleVec_x = x2;
									let scaleVec_y = y2;
									let scaleVec_z = z2;
									let _this = this.graphNodes[i];
									_this.scaleX = scaleVec_x;
									_this.flags |= 1;
									let _this1 = this.graphNodes[i];
									_this1.scaleY = scaleVec_y;
									_this1.flags |= 1;
									let _this2 = this.graphNodes[i];
									_this2.scaleZ = scaleVec_z;
									_this2.flags |= 1;
									++affectedCount;
									this.propagateDirtyFlags(i);
								} else {
									let _this = this.graphNodes[i];
									_this.scaleX = 1;
									_this.flags |= 1;
									let _this1 = this.graphNodes[i];
									_this1.scaleY = 1;
									_this1.flags |= 1;
									let _this2 = this.graphNodes[i];
									_this2.scaleZ = 1;
									_this2.flags |= 1;
								}
							}
						}
						if((sequence.flags & 4) > 0) {
							let _g = 0;
							let _g1 = this.dts.nodes.length;
							while(_g < _g1) {
								let i = _g++;
								let affected = (1 << i & scale) != 0;
								if(affected) {
									let scale1 = this.dts.nodeArbitraryScaleFactors[sequence.baseScale + sequence.numKeyFrames * affectedCount + keyframeLow];
									let scale2 = this.dts.nodeArbitraryScaleFactors[sequence.baseScale + sequence.numKeyFrames * affectedCount + keyframeHigh];
									let x = scale1.x;
									let y = scale1.y;
									let z = scale1.z;
									if(z == null) {
										z = 0.;
									}
									if(y == null) {
										y = 0.;
									}
									if(x == null) {
										x = 0.;
									}
									let v1_x = x;
									let v1_y = y;
									let v1_z = z;
									let x1 = scale2.x;
									let y1 = scale2.y;
									let z1 = scale2.z;
									if(z1 == null) {
										z1 = 0.;
									}
									if(y1 == null) {
										y1 = 0.;
									}
									if(x1 == null) {
										x1 = 0.;
									}
									let v2_x = x1;
									let v2_y = y1;
									let v2_z = z1;
									let x2 = v1_x + (v2_x - v1_x) * t;
									let y2 = v1_y + (v2_y - v1_y) * t;
									let z2 = v1_z + (v2_z - v1_z) * t;
									if(z2 == null) {
										z2 = 0.;
									}
									if(y2 == null) {
										y2 = 0.;
									}
									if(x2 == null) {
										x2 = 0.;
									}
									let scaleVec_x = x2;
									let scaleVec_y = y2;
									let scaleVec_z = z2;
									let _this = this.graphNodes[i];
									_this.scaleX = scaleVec_x;
									_this.flags |= 1;
									let _this1 = this.graphNodes[i];
									_this1.scaleY = scaleVec_y;
									_this1.flags |= 1;
									let _this2 = this.graphNodes[i];
									_this2.scaleZ = scaleVec_z;
									_this2.flags |= 1;
									++affectedCount;
									this.propagateDirtyFlags(i);
								} else {
									let _this = this.graphNodes[i];
									_this.scaleX = 1;
									_this.flags |= 1;
									let _this1 = this.graphNodes[i];
									_this1.scaleY = 1;
									_this1.flags |= 1;
									let _this2 = this.graphNodes[i];
									_this2.scaleZ = 1;
									_this2.flags |= 1;
								}
							}
						}
					}
				}
				if(this.sharedNodeTransforms && !this.isSharedGraphNodesRoot) {
					let _g = 0;
					let _g1 = this.dts.nodes.length;
					while(_g < _g1) {
						let i = _g++;
						let node = this.graphNodes[i];
						let shared = this.sharedGraphNodes[i];
						let x = shared.x;
						let y = shared.y;
						let z = shared.z;
						node.x = x;
						node.flags |= 1;
						node.y = y;
						node.flags |= 1;
						node.z = z;
						node.flags |= 1;
						node.flags |= 1;
						let _this = node.qRot;
						let q = shared.qRot;
						_this.x = q.x;
						_this.y = q.y;
						_this.z = q.z;
						_this.w = q.w;
						let v = shared.scaleX;
						node.scaleX = v;
						node.flags |= 1;
						let v1 = shared.scaleY;
						node.scaleY = v1;
						node.flags |= 1;
						let v2 = shared.scaleZ;
						node.scaleZ = v2;
						node.flags |= 1;
					}
				}
			}
			affectedCount = 0;
			let visIterIdx = 0;
			if(vis > 0 && this.animateSubObjectOpacities) {
				while(vis > 0) {
					if(affectedCount >= this.dts.subshapes[0].numNodes) {
						break;
					}
					if((vis & 1) != 0) {
						let v1 = this.dts.objectStates[sequence.baseObjectState + sequence.numKeyFrames * affectedCount + keyframeLow].vis;
						let v2 = this.dts.objectStates[sequence.baseObjectState + sequence.numKeyFrames * affectedCount + keyframeHigh].vis;
						let v = v1 + (v2 - v1) * t;
						this.meshVisibilities[visIterIdx] = v;
						this.updateSubObjectOpacity(visIterIdx);
						++affectedCount;
					} else {
						this.updateSubObjectOpacity(visIterIdx);
						this.meshVisibilities[visIterIdx] = this.dts.objectStates[visIterIdx].vis;
					}
					vis >>= 1;
					++visIterIdx;
				}
			}
		}
		if(this.skinMeshData != null && !this.isInstanced) {
			let info = this.skinMeshData;
			let mesh = this.dts.meshes[info.meshIndex];
			let _g = 0;
			let _g1 = info.vertices.length;
			while(_g < _g1) {
				let i = _g++;
				info.vertices[i] = new h3d_Vector();
				info.normals[i] = new h3d_Vector();
			}
			let boneTransformations = [];
			let _g2 = 0;
			let _g3 = mesh.nodeIndices.length;
			while(_g2 < _g3) {
				let i = _g2++;
				let mat = mesh.initialTransforms[i].clone();
				mat.scale(-1);
				mat.transpose();
				let tform = this.graphNodes[mesh.nodeIndices[i]].getRelPos(this).clone();
				tform.prependScale(-1);
				mat.multiply(mat,tform);
				boneTransformations.push(mat);
			}
			let _g4 = 0;
			let _g5 = mesh.vertexIndices.length;
			while(_g4 < _g5) {
				let i = _g4++;
				let vIndex = mesh.vertexIndices[i];
				let vertex = mesh.vertices[vIndex];
				let normal = mesh.normals[vIndex];
				let vec = new h3d_Vector();
				let vec2 = new h3d_Vector();
				let x = -vertex.x;
				let y = vertex.y;
				let z = vertex.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				vec.x = x;
				vec.y = y;
				vec.z = z;
				vec.w = 1.;
				let x1 = -normal.x;
				let y1 = normal.y;
				let z1 = normal.z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				vec2.x = x1;
				vec2.y = y1;
				vec2.z = z1;
				vec2.w = 1.;
				let mat = boneTransformations[mesh.boneIndices[i]];
				let px = vec.x * mat._11 + vec.y * mat._21 + vec.z * mat._31 + vec.w * mat._41;
				let py = vec.x * mat._12 + vec.y * mat._22 + vec.z * mat._32 + vec.w * mat._42;
				let pz = vec.x * mat._13 + vec.y * mat._23 + vec.z * mat._33 + vec.w * mat._43;
				let pw = vec.x * mat._14 + vec.y * mat._24 + vec.z * mat._34 + vec.w * mat._44;
				vec.x = px;
				vec.y = py;
				vec.z = pz;
				vec.w = pw;
				let v = mesh.weights[i];
				vec = new h3d_Vector(vec.x * v,vec.y * v,vec.z * v,vec.w);
				src_Util.m_matF_x_vectorF(mat,vec2);
				let v1 = mesh.weights[i];
				vec2 = new h3d_Vector(vec2.x * v1,vec2.y * v1,vec2.z * v1,vec2.w);
				let _this = info.vertices[vIndex];
				info.vertices[vIndex] = new h3d_Vector(_this.x + vec.x,_this.y + vec.y,_this.z + vec.z,_this.w + vec.w);
				let _this1 = info.normals[vIndex];
				info.normals[vIndex] = new h3d_Vector(_this1.x + vec2.x,_this1.y + vec2.y,_this1.z + vec2.z,_this1.w + vec2.w);
			}
			let _g6 = 0;
			let _g7 = info.normals.length;
			while(_g6 < _g7) {
				let i = _g6++;
				let norm = info.normals[i];
				let len2 = norm.x * norm.x + norm.y * norm.y + norm.z * norm.z;
				if(len2 > 0.01) {
					let k = norm.x * norm.x + norm.y * norm.y + norm.z * norm.z;
					if(k < 1e-10) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					norm.x *= k;
					norm.y *= k;
					norm.z *= k;
				}
			}
			let meshIndex = 0;
			let mesh1 = info.geometry.children[0];
			let prim = mesh1.primitive;
			if(prim.buffer != null) {
				prim.getDrawBuffer(prim.points.length);
			}
			let pos = 0;
			let _g8 = 0;
			let _g9 = info.indices;
			while(_g8 < _g9.length) {
				let i = _g9[_g8];
				++_g8;
				if(pos >= prim.points.length) {
					++meshIndex;
					mesh1.set_primitive(prim);
					mesh1 = info.geometry.children[meshIndex];
					prim = mesh1.primitive;
					pos = 0;
					if(prim.buffer != null) {
						prim.getDrawBuffer(prim.points.length);
					}
				}
				let vertex = info.vertices[i];
				let normal = info.normals[i];
				prim.points[pos] = new h3d_col_Point(vertex.x,vertex.y,vertex.z);
				prim.normals[pos] = new h3d_col_Point(normal.x,normal.y,normal.z);
				if(prim.buffer != null) {
					prim.dirtyFlags[pos] = true;
				}
				++pos;
			}
			if(prim.buffer != null) {
				prim.flush();
			}
			if(this._regenNormals) {
				this._regenNormals = false;
			}
		}
		if(!this.isInstanced && !this.isTSStatic) {
			let _g = 0;
			let _g1 = this.materials.length;
			while(_g < _g1) {
				let i = _g++;
				let info = this.materialInfos.h[this.materials[i].__id__];
				if(info == null) {
					continue;
				}
				let _this = this.dts.sequences;
				let _g1 = [];
				let _g2 = 0;
				while(_g2 < _this.length) {
					let v = _this[_g2];
					++_g2;
					if(v.iflMatters.length > 0 && v.iflMatters[0] > 0) {
						_g1.push(v);
					}
				}
				if(_g1.length == 0 || !this.showSequences) {
					continue;
				}
				let completion = timeState.timeSinceLoad / _g1[0].duration;
				let keyframe = Math.floor(completion * info.length) % info.length;
				let currentFile = info[keyframe];
				let texture = src_ResourceLoader.getResource(this.directoryPath + "/" + currentFile,src_ResourceLoader.getTexture,this.textureResources);
				let flags = this.dts.matFlags[i];
				if((flags & 1) > 0 || (flags & 2) > 0) {
					texture.set_wrap(h3d_mat_Wrap.Repeat);
				}
				this.materials[i].set_texture(texture);
			}
		}
		if(this.ambientRotate) {
			if(!this.sharedNodeTransforms || this.isSharedGraphNodesRoot) {
				let spinAnimation_x = 0.;
				let spinAnimation_y = 0.;
				let spinAnimation_z = 0.;
				let spinAnimation_w = 1.;
				let a = timeState.timeSinceLoad * this.ambientSpinFactor;
				let sin = Math.sin(a / 2);
				let cos = Math.cos(a / 2);
				spinAnimation_x = 0 * sin;
				spinAnimation_y = 0 * sin;
				spinAnimation_z = -1 * sin;
				spinAnimation_w = cos * Math.sqrt(1);
				let len = spinAnimation_x * spinAnimation_x + spinAnimation_y * spinAnimation_y + spinAnimation_z * spinAnimation_z + spinAnimation_w * spinAnimation_w;
				if(len < 1e-10) {
					spinAnimation_z = 0;
					spinAnimation_y = spinAnimation_z;
					spinAnimation_x = spinAnimation_y;
					spinAnimation_w = 1;
				} else {
					let m = 1. / Math.sqrt(len);
					spinAnimation_x *= m;
					spinAnimation_y *= m;
					spinAnimation_z *= m;
					spinAnimation_w *= m;
				}
				let _this = this.rootObject.getRotationQuat();
				_this.x = spinAnimation_x;
				_this.y = spinAnimation_y;
				_this.z = spinAnimation_z;
				_this.w = spinAnimation_w;
				let _this1 = this.rootObject;
				_this1.flags |= 1;
			}
			if(this.sharedNodeTransforms && !this.isSharedGraphNodesRoot) {
				let node = this.rootObject;
				let shared = this.sharedGraphNodes[this.sharedGraphNodes.length - 1];
				let x = shared.x;
				let y = shared.y;
				let z = shared.z;
				node.x = x;
				node.flags |= 1;
				node.y = y;
				node.flags |= 1;
				node.z = z;
				node.flags |= 1;
				node.flags |= 1;
				let _this = node.qRot;
				let q = shared.qRot;
				_this.x = q.x;
				_this.y = q.y;
				_this.z = q.z;
				_this.w = q.w;
				let v = shared.scaleX;
				node.scaleX = v;
				node.flags |= 1;
				let v1 = shared.scaleY;
				node.scaleY = v1;
				node.flags |= 1;
				let v2 = shared.scaleZ;
				node.scaleZ = v2;
				node.flags |= 1;
			}
		}
		let _g2 = 0;
		let _g3 = this.colliders.length;
		while(_g2 < _g3) {
			let i = _g2++;
			if(this.dirtyTransforms[this.colliders[i].userData]) {
				let absTform = this.graphNodes[this.colliders[i].userData].getAbsPos().clone();
				if(this.colliders[i] != null) {
					this.colliders[i].setTransform(absTform);
					this.collisionWorld.updateTransform(this.colliders[i]);
				}
			}
		}
		let _g4 = 0;
		let _g5 = this.dirtyTransforms.length;
		while(_g4 < _g5) {
			let i = _g4++;
			this.dirtyTransforms[i] = false;
		}
	}
	getMountTransform(mountPoint) {
		if(mountPoint < 32) {
			let ni = this.mountPointNodes[mountPoint];
			if(ni != -1) {
				let mtransform = this.graphNodes[ni].getAbsPos();
				return mtransform;
			}
		}
		return this.getTransform();
	}
	setOpacity(opacity) {
		if(opacity == this.currentOpacity) {
			return;
		}
		this.currentOpacity = opacity;
		if(!this.useInstancing) {
			let _g = 0;
			let _g1 = this.materials;
			while(_g < _g1.length) {
				let material = _g1[_g];
				++_g;
				if(this.currentOpacity != 1) {
					material.set_blendMode(h2d_BlendMode.Alpha);
					if(this.alphaShader == null) {
						this.alphaShader = new h3d_shader_AlphaMult();
					}
					if(material.passes.getShader(h3d_shader_AlphaMult) == null) {
						material.passes.addShader(this.alphaShader);
					}
					this.alphaShader.alpha__ = this.currentOpacity;
				} else if(this.alphaShader != null) {
					material.set_blendMode(h2d_BlendMode.None);
					this.alphaShader.alpha__ = this.currentOpacity;
					material.passes.removeShader(this.alphaShader);
				}
			}
		}
	}
	updateSubObjectOpacity(idx) {
		if(!this.useInstancing) {
			let opacity = this.meshVisibilities[idx];
			let node = this.meshes[idx];
			if(node != null) {
				let _g = 0;
				let _g1 = node.getMeshes();
				while(_g < _g1.length) {
					let ch = _g1[_g];
					++_g;
					let _g2 = 0;
					let _g3 = ch.material.getPasses();
					while(_g2 < _g3.length) {
						let pass = _g3[_g2];
						++_g2;
						let alphashader = pass.getShader(h3d_shader_AlphaMult);
						if(alphashader != null) {
							alphashader.alpha__ = opacity * this.currentOpacity;
						} else {
							alphashader = new h3d_shader_AlphaMult();
							alphashader.alpha__ = opacity * this.currentOpacity;
							pass.addShader(alphashader);
						}
					}
				}
			}
		}
	}
	getSubObjectOpacity(obj) {
		let idx = this.meshToIndex.h[obj.__id__];
		return this.meshVisibilities[idx];
	}
	setHide(hide) {
		if(hide) {
			this.setCollisionEnabled(false);
			this.setOpacity(0);
		} else {
			this.setCollisionEnabled(true);
			this.setOpacity(1);
		}
	}
	setCollisionEnabled(flag) {
		this.isCollideable = flag;
	}
	dispose() {
		super.dispose();
		this.level = null;
		this.boundingCollider = null;
		this.colliders = null;
		this.sharedGraphNodes = null;
		this.dtsResource.release();
	}
	static disposeShared() {
		src_DtsObject.sharedGraphNodesMap = new haxe_ds_StringMap();
	}
}
$hxClasses["src.DtsObject"] = src_DtsObject;
src_DtsObject.__name__ = "src.DtsObject";
src_DtsObject.__super__ = src_GameObject;
Object.assign(src_DtsObject.prototype, {
	__class__: src_DtsObject
	,dtsPath: null
	,sequencePath: null
	,directoryPath: null
	,dts: null
	,dtsResource: null
	,level: null
	,collisionWorld: null
	,materials: null
	,materialInfos: null
	,matNameOverride: null
	,sequenceKeyframeOverride: null
	,lastSequenceKeyframes: null
	,doSequenceOnce: null
	,doSequenceOnceBeginTime: null
	,sharedNodeTransforms: null
	,sharedGraphNodes: null
	,isSharedGraphNodesRoot: null
	,graphNodes: null
	,dirtyTransforms: null
	,meshVisibilities: null
	,meshToIndex: null
	,meshes: null
	,useInstancing: null
	,isTSStatic: null
	,showSequences: null
	,hasNonVisualSequences: null
	,isInstanced: null
	,_regenNormals: null
	,skinMeshData: null
	,rootObject: null
	,colliders: null
	,boundingCollider: null
	,mountPointNodes: null
	,alphaShader: null
	,ambientRotate: null
	,ambientSpinFactor: null
	,idInLevel: null
});
class shapes_AbstractBumper extends src_DtsObject {
	constructor() {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.lastContactTime = -Infinity;
		super._hx_constructor();
		this.enableCollideCallbacks = true;
	}
	update(timeState) {
		let currentCompletion = this.getCurrentCompletion(timeState);
		this.sequenceKeyframeOverride.set(this.dts.sequences[0],currentCompletion * (this.dts.sequences[0].numKeyFrames - 1));
		super.update(timeState);
	}
	getCurrentCompletion(timeState) {
		let elapsed = timeState.timeSinceLoad - this.lastContactTime;
		let value = elapsed / this.dts.sequences[0].duration;
		let completion = value < 0 ? 0 : value > 1 ? 1 : value;
		return completion;
	}
	onMarbleContact(marble,time,contact) {
		super.onMarbleContact(marble,time,contact);
		if(time.timeSinceLoad - this.lastContactTime <= 0) {
			return;
		}
		let currentCompletion = this.getCurrentCompletion(time);
		if(currentCompletion == 0 || currentCompletion == 1) {
			this.lastContactTime = time.timeSinceLoad;
		}
	}
}
$hxClasses["shapes.AbstractBumper"] = shapes_AbstractBumper;
shapes_AbstractBumper.__name__ = "shapes.AbstractBumper";
shapes_AbstractBumper.__super__ = src_DtsObject;
Object.assign(shapes_AbstractBumper.prototype, {
	__class__: shapes_AbstractBumper
	,lastContactTime: null
});
class shapes_PowerUp extends src_DtsObject {
	constructor(element) {
		if(h3d_scene_Object._hx_skip_constructor) {
			super();
			return;
		}
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(element);
	}
	_hx_constructor(element) {
		this.customPickupMessage = null;
		this.pickupTicks = -1;
		this.pickupClient = -1;
		this.autoUse = false;
		this.cooldownDuration = 7;
		this.lastPickUpTime = -1;
		super._hx_constructor();
		this.isBoundingBoxCollideable = true;
		this.isCollideable = false;
		this.ambientRotate = true;
		this.element = element;
	}
	onMarbleInside(marble,timeState) {
		let pickupable = this.lastPickUpTime == -1 || timeState.currentAttemptTime - this.lastPickUpTime >= this.cooldownDuration;
		if(!pickupable) {
			return;
		}
		if(this.pickUp(marble)) {
			if(this.level.isMultiplayer && net_Net.isHost) {
				let b = new net_OutputBitStream();
				b.writeByte(7);
				let pickupPacket = new net_PowerupPickupPacket();
				pickupPacket.clientId = marble.connection != null ? marble.connection.id : 0;
				pickupPacket.serverTicks = timeState.ticks;
				pickupPacket.powerupItemId = this.netIndex;
				b.writeByte(pickupPacket.clientId);
				b.writeUInt16(pickupPacket.serverTicks);
				b.writeInt(pickupPacket.powerupItemId,10);
				net_Net.sendPacketToIngame(b);
				this.pickupClient = pickupPacket.clientId;
				this.pickupTicks = pickupPacket.serverTicks;
			}
			if(this.level.isMultiplayer && net_Net.isClient) {
				this.pickupClient = marble.connection != null ? marble.connection.id : net_Net.clientId;
			}
			this.lastPickUpTime = timeState.currentAttemptTime;
			if(this.autoUse) {
				this.use(marble,timeState);
			}
			if(this.level.marble == marble && !marble.isNetUpdate) {
				if(this.customPickupMessage != null) {
					this.level.displayAlert(this.customPickupMessage);
				} else {
					this.level.displayAlert("You picked up " + this.pickUpName + "!");
				}
				if(this.element.showhelponpickup == "1" && !this.autoUse) {
					this.level.displayHelp("Press <func:bind mousefire> to use the " + this.pickUpName + "!");
				}
				if(this.pickupSound != null && !this.level.rewinding) {
					src_AudioManager.playSound(this.pickupSound);
				}
			}
		}
	}
	update(timeState) {
		super.update(timeState);
		let opacity = 1.0;
		if(this.lastPickUpTime > 0 && this.cooldownDuration > 0) {
			let availableTime = this.lastPickUpTime + this.cooldownDuration;
			let value = timeState.currentAttemptTime - availableTime;
			opacity = value < 0 ? 0 : value > 1 ? 1 : value;
		}
		this.setOpacity(opacity);
	}
	reset() {
		this.lastPickUpTime = -Infinity;
		this.pickupClient = -1;
		this.pickupTicks = -1;
	}
}
$hxClasses["shapes.PowerUp"] = shapes_PowerUp;
shapes_PowerUp.__name__ = "shapes.PowerUp";
shapes_PowerUp.__super__ = src_DtsObject;
Object.assign(shapes_PowerUp.prototype, {
	__class__: shapes_PowerUp
	,lastPickUpTime: null
	,cooldownDuration: null
	,autoUse: null
	,pickUpName: null
	,element: null
	,pickupSound: null
	,netIndex: null
	,pickupClient: null
	,pickupTicks: null
	,customPickupMessage: null
});
class shapes_AntiGravity extends shapes_PowerUp {
	constructor(element,norespawn) {
		if(norespawn == null) {
			norespawn = false;
		}
		super(element);
		this.dtsPath = "data/shapes/items/antigravity.dts";
		this.isCollideable = false;
		this.isTSStatic = false;
		this.identifier = "AntiGravity";
		this.pickUpName = "a Gravity Modifier";
		this.autoUse = true;
		this.useInstancing = true;
		this.animateSubObjectOpacities = true;
		this.sharedNodeTransforms = true;
		if(mis_MisParser.parseBoolean(element.permanent)) {
			norespawn = true;
		}
		if(norespawn) {
			this.cooldownDuration = -Infinity;
		}
	}
	pickUp(marble) {
		let direction_x = 0;
		let direction_y = 0;
		let direction_z = -1;
		let direction_w = 1.;
		let _this = this.getRotationQuat();
		let m = null;
		m = new h3d_Matrix();
		let xx = _this.x * _this.x;
		let xy = _this.x * _this.y;
		let xz = _this.x * _this.z;
		let xw = _this.x * _this.w;
		let yy = _this.y * _this.y;
		let yz = _this.y * _this.z;
		let yw = _this.y * _this.w;
		let zz = _this.z * _this.z;
		let zw = _this.z * _this.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		let m1 = m;
		let px = direction_x * m1._11 + direction_y * m1._21 + direction_z * m1._31 + m1._41;
		let py = direction_x * m1._12 + direction_y * m1._22 + direction_z * m1._32 + m1._42;
		let pz = direction_x * m1._13 + direction_y * m1._23 + direction_z * m1._33 + m1._43;
		let pw = direction_x * m1._14 + direction_y * m1._24 + direction_z * m1._34 + m1._44;
		direction_x = px;
		direction_y = py;
		direction_z = pz;
		direction_w = pw;
		let v = marble.currentUp;
		return !(direction_x == v.x && direction_y == v.y && direction_z == v.z && direction_w == v.w);
	}
	use(marble,timeState) {
		if(!this.level.rewinding) {
			let direction = new h3d_Vector(0,0,-1);
			let _this = this.getRotationQuat();
			let m = null;
			m = new h3d_Matrix();
			let xx = _this.x * _this.x;
			let xy = _this.x * _this.y;
			let xz = _this.x * _this.z;
			let xw = _this.x * _this.w;
			let yy = _this.y * _this.y;
			let yz = _this.y * _this.z;
			let yw = _this.y * _this.w;
			let zz = _this.z * _this.z;
			let zw = _this.z * _this.w;
			m._11 = 1 - 2 * (yy + zz);
			m._12 = 2 * (xy + zw);
			m._13 = 2 * (xz - yw);
			m._14 = 0;
			m._21 = 2 * (xy - zw);
			m._22 = 1 - 2 * (xx + zz);
			m._23 = 2 * (yz + xw);
			m._24 = 0;
			m._31 = 2 * (xz + yw);
			m._32 = 2 * (yz - xw);
			m._33 = 1 - 2 * (xx + yy);
			m._34 = 0;
			m._41 = 0;
			m._42 = 0;
			m._43 = 0;
			m._44 = 1;
			let m1 = m;
			let px = direction.x * m1._11 + direction.y * m1._21 + direction.z * m1._31 + direction.w * m1._41;
			let py = direction.x * m1._12 + direction.y * m1._22 + direction.z * m1._32 + direction.w * m1._42;
			let pz = direction.x * m1._13 + direction.y * m1._23 + direction.z * m1._33 + direction.w * m1._43;
			let pw = direction.x * m1._14 + direction.y * m1._24 + direction.z * m1._34 + direction.w * m1._44;
			direction.x = px;
			direction.y = py;
			direction.z = pz;
			direction.w = pw;
			if(marble == this.level.marble) {
				this.level.setUp(marble,direction,timeState);
			} else {
				marble.netFlags |= 16;
				let _this = marble.currentUp;
				_this.x = direction.x;
				_this.y = direction.y;
				_this.z = direction.z;
				_this.w = direction.w;
			}
		}
	}
	init(level,onFinish) {
		let _gthis = this;
		super.init(level,function() {
			src_ResourceLoader.load("sound/pu_gravity.wav").entry.load(function() {
				_gthis.pickupSound = src_ResourceLoader.getResource("data/sound/pu_gravity.wav",src_ResourceLoader.getAudio,_gthis.soundResources);
				onFinish();
			});
		});
	}
	getPreloadMaterials(dts) {
		let mats = super.getPreloadMaterials(dts);
		mats.push("data/shapes/items/antigrav_bump.png");
		mats.push("data/shapes/items/antigrav_glow.png");
		return mats;
	}
	postProcessMaterial(matName,material) {
		if(matName == "antigrav_skin") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/items/antigrav_skin.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let normalTex = src_ResourceLoader.getTexture("data/shapes/items/antigrav_bump.png").resource;
			normalTex.set_wrap(h3d_mat_Wrap.Repeat);
			normalTex.set_mipMap(h3d_mat_MipMap.None);
			let shader = new shaders_DefaultMaterial(diffuseTex,normalTex,32,new h3d_Vector(0.8,0.8,0.6,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "item_glow") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/items/antigrav_glow.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_enableLights(false);
			material.addPass(glowpass);
			material.passes.setPassName("glowPre");
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			material.passes.set_enableLights(false);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
		}
	}
}
$hxClasses["shapes.AntiGravity"] = shapes_AntiGravity;
shapes_AntiGravity.__name__ = "shapes.AntiGravity";
shapes_AntiGravity.__super__ = shapes_PowerUp;
Object.assign(shapes_AntiGravity.prototype, {
	__class__: shapes_AntiGravity
});
class shapes_Astrolabe extends src_DtsObject {
	constructor() {
		super();
		this.dtsPath = "data/shapes/astrolabe/astrolabe.dts";
		this.sequencePath = "data/shapes/astrolabe/astrolabe_root.dsq";
		this.isCollideable = false;
		this.isTSStatic = false;
		this.identifier = "Astrolabe";
		this.useInstancing = false;
	}
	init(level,onFinish) {
		super.init(level,onFinish);
		let _g = 0;
		let _g1 = this.materials;
		while(_g < _g1.length) {
			let mat = _g1[_g];
			++_g;
			let thisprops = mat.getDefaultProps();
			thisprops.light = false;
			mat.set_props(thisprops);
			mat.set_castShadows(false);
			mat.set_receiveShadows(false);
			mat.set_receiveShadows(false);
			mat.set_blendMode(h2d_BlendMode.Alpha);
			mat.passes.set_depthWrite(false);
			mat.passes.set_culling(h3d_mat_Face.None);
			mat.passes.setPassName("skyshape");
		}
	}
}
$hxClasses["shapes.Astrolabe"] = shapes_Astrolabe;
shapes_Astrolabe.__name__ = "shapes.Astrolabe";
shapes_Astrolabe.__super__ = src_DtsObject;
Object.assign(shapes_Astrolabe.prototype, {
	__class__: shapes_Astrolabe
});
class shapes_Blast extends shapes_PowerUp {
	constructor(element) {
		super(element);
		this.dtsPath = "data/shapes/images/blast.dts";
		this.isCollideable = false;
		this.isTSStatic = false;
		this.showSequences = true;
		this.identifier = "Blast";
		this.pickUpName = "a Blast powerup";
		this.ambientRotate = false;
		this.autoUse = true;
		this.sharedNodeTransforms = true;
	}
	init(level,onFinish) {
		let _gthis = this;
		super.init(level,function() {
			src_ResourceLoader.load("sound/ultrablast.wav").entry.load(function() {
				_gthis.pickupSound = src_ResourceLoader.getResource("data/sound/ultrablast.wav",src_ResourceLoader.getAudio,_gthis.soundResources);
				onFinish();
			});
		});
	}
	pickUp(marble) {
		return true;
	}
	use(marble,timeState) {
		marble.blastAmount = 1.2;
		marble.blastTicks = 1125;
	}
	getPreloadMaterials(dts) {
		let mats = super.getPreloadMaterials(dts);
		mats.push("data/shapes/images/blast_orbit_bump.png");
		mats.push("data/shapes/items/item_glow.png");
		return mats;
	}
	postProcessMaterial(matName,material) {
		if(matName == "blast_orbit_skin") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/images/blast_orbit_skin.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let normalTex = src_ResourceLoader.getTexture("data/shapes/images/blast_orbit_bump.png").resource;
			normalTex.set_wrap(h3d_mat_Wrap.Repeat);
			normalTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultMaterial(diffuseTex,normalTex,32,new h3d_Vector(0.8,0.8,0.6,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "item_glow") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/items/item_glow.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				glowpass.removeShader(dtsshader);
			}
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_enableLights(false);
			material.addPass(glowpass);
			material.passes.setPassName("glowPre");
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				material.passes.removeShader(dtsshader);
			}
			material.passes.set_enableLights(false);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
		}
	}
}
$hxClasses["shapes.Blast"] = shapes_Blast;
shapes_Blast.__name__ = "shapes.Blast";
shapes_Blast.__super__ = shapes_PowerUp;
Object.assign(shapes_Blast.prototype, {
	__class__: shapes_Blast
});
class shapes_BlastWave extends src_DtsObject {
	constructor() {
		super();
		this.dtsPath = "data/shapes/images/distort.dts";
		this.isCollideable = false;
		this.isTSStatic = false;
		this.identifier = "BlastWave";
		this.useInstancing = true;
		this.animateSubObjectOpacities = true;
		this.doSequenceOnce = true;
	}
	init(level,onFinish) {
		super.init(level,onFinish);
	}
	update(timeState) {
		super.update(timeState);
	}
	getPreloadMaterials(dts) {
		let mats = super.getPreloadMaterials(dts);
		mats.push("data/shapes/images/blast_glow.png");
		mats.push("data/shapes/pads/endpad_glow.png");
		return mats;
	}
	postProcessMaterial(matName,material) {
		if(matName == "refract") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/images/blast_glow.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			material.passes.removeShader(material.textureShader);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_depthWrite(false);
			glowpass.set_enableLights(false);
			glowpass.setBlendMode(h2d_BlendMode.Alpha);
			material.addPass(glowpass);
			material.passes.setPassName("glowPreNoRender");
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			material.passes.set_enableLights(false);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.passes.set_depthWrite(false);
		}
		if(matName == "blastwave") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/images/blastwave.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			material.passes.removeShader(material.textureShader);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_depthWrite(false);
			glowpass.set_enableLights(false);
			glowpass.setBlendMode(h2d_BlendMode.Alpha);
			material.addPass(glowpass);
			material.passes.setPassName("glowPreNoRender");
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			material.passes.set_enableLights(false);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.passes.set_depthWrite(false);
		}
		if(matName == "endpad_glow") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/pads/endpad_glow.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			material.passes.removeShader(material.textureShader);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_depthWrite(false);
			glowpass.set_enableLights(false);
			glowpass.setBlendMode(h2d_BlendMode.Alpha);
			material.addPass(glowpass);
			material.passes.setPassName("glowPreNoRender");
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			material.passes.set_enableLights(false);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.passes.set_depthWrite(false);
		}
		if(matName == "corona") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/images/corona.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			material.passes.removeShader(material.textureShader);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_depthWrite(false);
			glowpass.set_enableLights(false);
			glowpass.setBlendMode(h2d_BlendMode.Alpha);
			material.addPass(glowpass);
			material.passes.setPassName("glowPreNoRender");
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			material.passes.set_enableLights(false);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.passes.set_depthWrite(false);
		}
	}
}
$hxClasses["shapes.BlastWave"] = shapes_BlastWave;
shapes_BlastWave.__name__ = "shapes.BlastWave";
shapes_BlastWave.__super__ = src_DtsObject;
Object.assign(shapes_BlastWave.prototype, {
	__class__: shapes_BlastWave
});
class shapes_Checkpoint extends src_DtsObject {
	constructor(element) {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(element);
	}
	_hx_constructor(element) {
		this.lastActivatedTime = Infinity;
		this.disableOOB = false;
		super._hx_constructor();
		this.dtsPath = "data/shapes/pads/checkpad.dts";
		this.isCollideable = true;
		this.isTSStatic = false;
		this.identifier = "Checkpoint";
		this.element = element;
		this.animateSubObjectOpacities = true;
		this.disableOOB = Object.prototype.hasOwnProperty.call(element.fields.h,"disableOob") && mis_MisParser.parseBoolean(element.fields.h["disableOob"][0]);
	}
	init(level,onFinish) {
		super.init(level,function() {
			src_ResourceLoader.load("sound/checkpoint.wav").entry.load(onFinish);
		});
	}
	update(timeState) {
		let currentCompletion = this.getCurrentCompletion(timeState);
		this.sequenceKeyframeOverride.set(this.dts.sequences[0],currentCompletion * (this.dts.sequences[0].numKeyFrames - 1));
		this.sequenceKeyframeOverride.set(this.dts.sequences[1],0);
		super.update(timeState);
	}
	getCurrentCompletion(timeState) {
		let elapsed = timeState.timeSinceLoad - this.lastActivatedTime;
		let value = elapsed / this.dts.sequences[0].duration;
		let completion = value < 0 ? 0 : value > 1 ? 1 : value;
		return completion;
	}
	reset() {
		super.reset();
		this.lastActivatedTime = Infinity;
		this.meshVisibilities = [0,1,0];
	}
	postProcessMaterial(matName,material) {
		if(matName == "sigil") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/pads/sigil.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_enableLights(false);
			glowpass.set_depthWrite(false);
			glowpass.setBlendMode(h2d_BlendMode.Alpha);
			material.addPass(glowpass);
			material.passes.setPassName("glowPre");
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			material.passes.set_enableLights(false);
			material.passes.set_depthWrite(false);
			material.passes.setBlendMode(h2d_BlendMode.Alpha);
		}
		if(matName == "sigiloff") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/pads/sigiloff.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultDiffuseMaterial(diffuseTex);
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
			material.set_blendMode(h2d_BlendMode.Alpha);
		}
		if(matName == "corona") {
			material.set_blendMode(h2d_BlendMode.Alpha);
			material.passes.set_enableLights(false);
		}
	}
}
$hxClasses["shapes.Checkpoint"] = shapes_Checkpoint;
shapes_Checkpoint.__name__ = "shapes.Checkpoint";
shapes_Checkpoint.__super__ = src_DtsObject;
Object.assign(shapes_Checkpoint.prototype, {
	__class__: shapes_Checkpoint
	,disableOOB: null
	,lastActivatedTime: null
	,element: null
});
class src_ForceObject extends src_DtsObject {
	constructor() {
		super();
	}
	getForce(pos) {
		let strength = 0.0;
		let dot = 0.0;
		let posVec = new h3d_Vector();
		let retForce = new h3d_Vector();
		let _g = 0;
		let _g1 = this.forceDatas;
		while(_g < _g1.length) {
			let forceData = _g1[_g];
			++_g;
			if(forceData.forceType == src_ForceType.NoForce) {
				continue;
			}
			let node = this.getMountTransform(forceData.forceNode);
			let nodeVec;
			let _this = forceData.forceVector;
			if(Math.sqrt(_this.x * _this.x + _this.y * _this.y + _this.z * _this.z) == 0) {
				let v = new h3d_Vector(node._21,node._22,node._23);
				let k = v.x * v.x + v.y * v.y + v.z * v.z;
				if(k < 1e-10) {
					k = 0;
				} else {
					k = 1. / Math.sqrt(k);
				}
				v.x *= k;
				v.y *= k;
				v.z *= k;
				nodeVec = v;
			} else {
				nodeVec = forceData.forceVector;
			}
			let v_x = 0.;
			let v_y = 0.;
			let v_z = 0.;
			let v_w = 1.;
			let x = node._41;
			let y = node._42;
			let z = node._43;
			let w = node._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			v_x = x;
			v_y = y;
			v_z = z;
			v_w = w;
			posVec = new h3d_Vector(pos.x - v_x,pos.y - v_y,pos.z - v_z,pos.w - v_w);
			dot = Math.sqrt(posVec.x * posVec.x + posVec.y * posVec.y + posVec.z * posVec.z);
			if(forceData.forceRadius < dot) {
				continue;
			}
			let forceType = forceData.forceType;
			strength = (1 - dot / forceData.forceRadius) * forceData.forceStrength;
			if(forceType == src_ForceType.ForceSpherical) {
				dot = strength / dot;
				let x = posVec.x * dot;
				let y = posVec.y * dot;
				let z = posVec.z * dot;
				let w = posVec.w;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v_x = x;
				let v_y = y;
				let v_z = z;
				let v_w = w;
				retForce = new h3d_Vector(retForce.x + v_x,retForce.y + v_y,retForce.z + v_z,retForce.w + v_w);
			}
			if(forceType == src_ForceType.ForceField) {
				let x = nodeVec.x * strength;
				let y = nodeVec.y * strength;
				let z = nodeVec.z * strength;
				let w = nodeVec.w;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v_x = x;
				let v_y = y;
				let v_z = z;
				let v_w = w;
				retForce = new h3d_Vector(retForce.x + v_x,retForce.y + v_y,retForce.z + v_z,retForce.w + v_w);
			}
			if(forceType == src_ForceType.ForceCone) {
				let v = 1 / dot;
				posVec = new h3d_Vector(posVec.x * v,posVec.y * v,posVec.z * v,posVec.w);
				let newDot = nodeVec.x * posVec.x + nodeVec.y * posVec.y + nodeVec.z * posVec.z;
				let arc = forceData.forceArc;
				if(arc < newDot) {
					let x = posVec.x * strength;
					let y = posVec.y * strength;
					let z = posVec.z * strength;
					let w = posVec.w;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let _this_x = x;
					let _this_y = y;
					let _this_z = z;
					let _this_w = w;
					let v = newDot - arc;
					let x1 = _this_x * v;
					let y1 = _this_y * v;
					let z1 = _this_z * v;
					let w1 = _this_w;
					if(_this_w == null) {
						w1 = 1.;
					}
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let _this_x1 = x1;
					let _this_y1 = y1;
					let _this_z1 = z1;
					let _this_w1 = w1;
					let v1 = 1 / (1 - arc);
					let x2 = _this_x1 * v1;
					let y2 = _this_y1 * v1;
					let z2 = _this_z1 * v1;
					let w2 = _this_w1;
					if(_this_w1 == null) {
						w2 = 1.;
					}
					if(z2 == null) {
						z2 = 0.;
					}
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					let v_x = x2;
					let v_y = y2;
					let v_z = z2;
					let v_w = w2;
					retForce = new h3d_Vector(retForce.x + v_x,retForce.y + v_y,retForce.z + v_z,retForce.w + v_w);
				}
			}
		}
		return retForce;
	}
}
$hxClasses["src.ForceObject"] = src_ForceObject;
src_ForceObject.__name__ = "src.ForceObject";
src_ForceObject.__super__ = src_DtsObject;
Object.assign(src_ForceObject.prototype, {
	__class__: src_ForceObject
	,forceDatas: null
});
class shapes_DuctFan extends src_ForceObject {
	constructor() {
		super();
		this.dtsPath = "data/shapes/hazards/ductfan.dts";
		this.isCollideable = true;
		this.isTSStatic = false;
		this.sharedNodeTransforms = true;
		this.identifier = "DuctFan";
		this.forceDatas = [{ forceType : src_ForceType.ForceCone, forceNode : 0, forceStrength : 40, forceRadius : 10, forceArc : 0.7, forceVector : new h3d_Vector()}];
	}
	init(level,onFinish) {
		let _gthis = this;
		super.init(level,function() {
			src_ResourceLoader.load("sound/fan_loop.wav").entry.load(function() {
				let tmp = src_ResourceLoader.getResource("data/sound/fan_loop.wav",src_ResourceLoader.getAudio,_gthis.soundResources);
				_gthis.soundChannel = src_AudioManager.playSound(tmp,new h3d_Vector(1e8,1e8,1e8),true);
				_gthis.soundChannel.set_pause(true);
				onFinish();
			});
		});
	}
	reset() {
		super.reset();
		let seffect = this.soundChannel.getEffect(hxd_snd_effect_Spatialization);
		let _this = this.getAbsPos();
		let v = new h3d_Vector();
		let x = _this._41;
		let y = _this._42;
		let z = _this._43;
		let w = _this._44;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v.x = x;
		v.y = y;
		v.z = z;
		v.w = w;
		seffect.position = v;
		if(this.soundChannel.pause) {
			this.soundChannel.set_pause(false);
		}
	}
	postProcessMaterial(matName,material) {
		if(matName == "fan") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/hazards/fan.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultNormalMaterial(diffuseTex,12,new h3d_Vector(0.8,0.8,0.6,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
	}
}
$hxClasses["shapes.DuctFan"] = shapes_DuctFan;
shapes_DuctFan.__name__ = "shapes.DuctFan";
shapes_DuctFan.__super__ = src_ForceObject;
Object.assign(shapes_DuctFan.prototype, {
	__class__: shapes_DuctFan
	,soundChannel: null
});
class shapes_EasterEgg extends shapes_PowerUp {
	constructor(element) {
		super(element);
		this.dtsPath = "data/shapes/items/egg.dts";
		this.isCollideable = false;
		this.isTSStatic = false;
		this.identifier = "EasterEgg";
		this.pickUpName = "Easter Egg";
		this.autoUse = true;
		this.sharedNodeTransforms = true;
		this.cooldownDuration = 1e8;
	}
	pickUp(marble) {
		let found = false;
		if(Object.prototype.hasOwnProperty.call(src_Settings.easterEggs.h,this.level.mission.path)) {
			found = true;
		}
		if(!found) {
			src_Settings.easterEggs.h[this.level.mission.path] = this.level.timeState.currentAttemptTime;
			this.pickupSound = src_ResourceLoader.getResource("data/sound/easter_egg.wav",src_ResourceLoader.getAudio,this.soundResources);
			this.customPickupMessage = "You found a new egg! Yeah!";
			gui_AchievementsGui.check();
		} else {
			this.pickupSound = src_ResourceLoader.getResource("data/sound/pu_easter.wav",src_ResourceLoader.getAudio,this.soundResources);
			this.customPickupMessage = "You already found this egg!";
		}
		return true;
	}
	init(level,onFinish) {
		super.init(level,function() {
			src_ResourceLoader.load("sound/easter_egg.wav").entry.load(function() {
				src_ResourceLoader.load("sound/pu_easter.wav").entry.load(onFinish);
			});
		});
	}
	use(marble,timeState) {
	}
	getPreloadMaterials(dts) {
		let mats = super.getPreloadMaterials(dts);
		mats.push("data/skies/gemCubemapUp.png");
		return mats;
	}
	postProcessMaterial(matName,material) {
		if(matName == "egg_skin") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/items/egg_skin.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let cubemapTex = new h3d_mat_Texture(64,64,[h3d_mat_TextureFlags.Cube]);
			let cubemapFace = src_ResourceLoader.getImage("data/skies/gemCubemapUp.png").resource;
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,0);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,1);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,2);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,3);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,4);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,5);
			let shader = new shaders_DefaultCubemapNormalMaterial(diffuseTex,cubemapTex,32,new h3d_Vector(1,1,1,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
	}
}
$hxClasses["shapes.EasterEgg"] = shapes_EasterEgg;
shapes_EasterEgg.__name__ = "shapes.EasterEgg";
shapes_EasterEgg.__super__ = shapes_PowerUp;
Object.assign(shapes_EasterEgg.prototype, {
	__class__: shapes_EasterEgg
});
class shapes_EndPad extends src_DtsObject {
	constructor() {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.inFinish = false;
		super._hx_constructor();
		this.dtsPath = "data/shapes/pads/endarea.dts";
		this.isCollideable = true;
		this.identifier = "EndPad";
		this.useInstancing = false;
	}
	init(level,onFinish) {
		super.init(level,onFinish);
	}
	generateCollider() {
		let vertices = [];
		let _g = 0;
		while(_g < 64) {
			let j = _g++;
			let angle = j / 64 * Math.PI * 2;
			let x = Math.cos(angle);
			let z = Math.sin(angle);
			vertices.push(new h3d_Vector(x * 1.7 * this.scaleX,0,z * 1.7 * this.scaleY));
		}
		let _g1 = 0;
		while(_g1 < 64) {
			let j = _g1++;
			let angle = j / 64 * Math.PI * 2;
			let x = Math.cos(angle);
			let z = Math.sin(angle);
			vertices.push(new h3d_Vector(x * 1.7 * this.scaleX,4.8,z * 1.7 * this.scaleY));
		}
		this.finishCollider = new collision_gjk_ConvexHull(vertices);
		this.finishBounds = new h3d_col_Bounds();
		let _g2 = 0;
		while(_g2 < vertices.length) {
			let vert = vertices[_g2];
			++_g2;
			let _this = this.finishBounds;
			let x = vert.x;
			let y = vert.y;
			let z = vert.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let p_x = x;
			let p_y = y;
			let p_z = z;
			if(p_x < _this.xMin) {
				_this.xMin = p_x;
			}
			if(p_x > _this.xMax) {
				_this.xMax = p_x;
			}
			if(p_y < _this.yMin) {
				_this.yMin = p_y;
			}
			if(p_y > _this.yMax) {
				_this.yMax = p_y;
			}
			if(p_z < _this.zMin) {
				_this.zMin = p_z;
			}
			if(p_z > _this.zMax) {
				_this.zMax = p_z;
			}
		}
		let rotQuat_x = 0.;
		let rotQuat_y = 0.;
		let rotQuat_z = 0.;
		let rotQuat_w = 1.;
		let ay = Math.PI / 2;
		let sinX = Math.sin(0.);
		let cosX = Math.cos(0.);
		let sinY = Math.sin(ay * 0.5);
		let cosY = Math.cos(ay * 0.5);
		let sinZ = Math.sin(0.);
		let cosZ = Math.cos(0.);
		let cosYZ = cosY * cosZ;
		let sinYZ = sinY * sinZ;
		rotQuat_x = sinX * cosYZ - cosX * sinYZ;
		rotQuat_y = cosX * sinY * cosZ + sinX * cosY * sinZ;
		rotQuat_z = cosX * cosY * sinZ - sinX * sinY * cosZ;
		rotQuat_w = cosX * cosYZ + sinX * sinYZ;
		let m = null;
		m = new h3d_Matrix();
		let xx = rotQuat_x * rotQuat_x;
		let xy = rotQuat_x * rotQuat_y;
		let xz = rotQuat_x * rotQuat_z;
		let xw = rotQuat_x * rotQuat_w;
		let yy = rotQuat_y * rotQuat_y;
		let yz = rotQuat_y * rotQuat_z;
		let yw = rotQuat_y * rotQuat_w;
		let zz = rotQuat_z * rotQuat_z;
		let zw = rotQuat_z * rotQuat_w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		let tform = this.getAbsPos().clone();
		tform.prependRotation(Math.PI / 2,0,0);
		this.finishCollider.transform = tform;
		this.finishBounds.transform(tform);
	}
	update(timeState) {
		super.update(timeState);
	}
	postProcessMaterial(matName,material) {
		if(matName == "abyss2") {
			let glowpass = material.passes.clone();
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_enableLights(false);
			material.addPass(glowpass);
			material.passes.setPassName("glowPre");
			material.passes.set_enableLights(false);
			let rotshader = new shaders_UVRotAnim(0.5,0.5,1);
			material.passes.addShader(rotshader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
		}
		if(matName == "ringtex") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/pads/ringtex.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultNormalMaterial(diffuseTex,14,new h3d_Vector(0.3,0.3,0.3,7),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsshader = material.passes.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				material.passes.removeShader(dtsshader);
			}
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "misty") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/pads/misty.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			let scrollShader = new h3d_shader_UVScroll(0,0.25);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			glowpass.addShader(scrollShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				glowpass.removeShader(dtsshader);
			}
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_depthWrite(false);
			glowpass.set_enableLights(false);
			glowpass.set_blendSrc(h3d_mat_Blend.SrcAlpha);
			glowpass.set_blendDst(h3d_mat_Blend.OneMinusSrcAlpha);
			material.addPass(glowpass);
			material.passes.setPassName("glowPreNoRender");
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				material.passes.removeShader(dtsshader);
			}
			material.passes.set_enableLights(false);
		}
	}
}
$hxClasses["shapes.EndPad"] = shapes_EndPad;
shapes_EndPad.__name__ = "shapes.EndPad";
shapes_EndPad.__super__ = src_DtsObject;
Object.assign(shapes_EndPad.prototype, {
	__class__: shapes_EndPad
	,finishCollider: null
	,finishBounds: null
	,inFinish: null
});
class shapes_Gem extends src_DtsObject {
	constructor(element) {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(element);
	}
	_hx_constructor(element) {
		this.pickUpClient = -1;
		super._hx_constructor();
		this.dtsPath = "data/shapes/items/gem.dts";
		this.ambientRotate = true;
		this.isCollideable = false;
		this.isBoundingBoxCollideable = true;
		this.pickedUp = false;
		this.useInstancing = true;
		this.sharedNodeTransforms = true;
		this.showSequences = false;
		let GEM_COLORS = ["red"];
		let color = element.datablock.substring("GemItem".length);
		if(color.length == 0) {
			color = GEM_COLORS[Math.floor(Math.random() * GEM_COLORS.length)];
		}
		this.identifier = "Gem" + color;
		this.matNameOverride.h["base.gem"] = color + ".gem";
		this.gemColor = color + ".gem";
		let tmp;
		switch(color) {
		case "blue":
			tmp = 230;
			break;
		case "yellow":
			tmp = 15138560;
			break;
		default:
			tmp = 15073280;
		}
		this.radarColor = tmp;
	}
	init(level,onFinish) {
		super.init(level,function() {
			let worker = new src_ResourceLoaderWorker(onFinish);
			worker.loadFile("sound/gem_collect.wav");
			worker.run();
		});
	}
	setHide(hide) {
		if(hide) {
			this.pickedUp = true;
			this.setOpacity(0);
		} else {
			this.pickedUp = false;
			this.setOpacity(1);
		}
	}
	onMarbleInside(marble,timeState) {
		super.onMarbleInside(marble,timeState);
		if(this.pickedUp || this.level.rewinding) {
			return;
		}
		this.pickedUp = true;
		this.setOpacity(0);
		this.level.pickUpGem(marble,this);
	}
	reset() {
		this.pickedUp = false;
		this.pickUpClient = -1;
		this.setOpacity(1);
	}
	getPreloadMaterials(dts) {
		let mats = super.getPreloadMaterials(dts);
		switch(this.gemColor) {
		case "blue":
			mats.push("data/shapes/items/blue.gem.png");
			mats.push("data/skies/gemCubemapUp3.png");
			break;
		case "yellow":
			mats.push("data/shapes/items/yellow.gem.png");
			mats.push("data/skies/gemCubemapUp2.png");
			break;
		default:
			mats.push("data/shapes/items/red.gem.png");
			mats.push("data/skies/gemCubemapUp.png");
		}
		return mats;
	}
	postProcessMaterial(matName,material) {
		if(matName == "red.gem") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/items/red.gem.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let cubemapTex = new h3d_mat_Texture(64,64,[h3d_mat_TextureFlags.Cube]);
			let cubemapFace = src_ResourceLoader.getImage("data/skies/gemCubemapUp.png").resource;
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,0);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,1);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,2);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,3);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,4);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,5);
			let shader = new shaders_DefaultCubemapNormalNoSpecMaterial(diffuseTex,1,cubemapTex);
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "yellow.gem") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/items/yellow.gem.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let cubemapTex = new h3d_mat_Texture(64,64,[h3d_mat_TextureFlags.Cube]);
			let cubemapFace = src_ResourceLoader.getImage("data/skies/gemCubemapUp2.png").resource;
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,0);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,1);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,2);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,3);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,4);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,5);
			let shader = new shaders_DefaultCubemapNormalNoSpecMaterial(diffuseTex,1,cubemapTex);
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "blue.gem") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/items/blue.gem.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let cubemapTex = new h3d_mat_Texture(64,64,[h3d_mat_TextureFlags.Cube]);
			let cubemapFace = src_ResourceLoader.getImage("data/skies/gemCubemapUp3.png").resource;
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,0);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,1);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,2);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,3);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,4);
			cubemapTex.uploadPixels(cubemapFace.getPixels(),0,5);
			let shader = new shaders_DefaultCubemapNormalNoSpecMaterial(diffuseTex,1,cubemapTex);
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
	}
}
$hxClasses["shapes.Gem"] = shapes_Gem;
shapes_Gem.__name__ = "shapes.Gem";
shapes_Gem.__super__ = src_DtsObject;
Object.assign(shapes_Gem.prototype, {
	__class__: shapes_Gem
	,pickedUp: null
	,netIndex: null
	,pickUpClient: null
	,gemColor: null
	,radarColor: null
});
class shapes_GemBeam extends src_DtsObject {
	constructor() {
		super();
		this.dtsPath = "data/shapes/items/gembeam.dts";
		this.isCollideable = false;
		this.isTSStatic = false;
		this.identifier = "GemBeam";
		this.useInstancing = true;
		this.sharedNodeTransforms = true;
		this.animateSubObjectOpacities = true;
	}
	init(level,onFinish) {
		super.init(level,onFinish);
	}
	update(timeState) {
		super.update(timeState);
	}
	getPreloadMaterials(dts) {
		let mats = super.getPreloadMaterials(dts);
		mats.push("data/shapes/pads/mistyglow.png");
		return mats;
	}
	postProcessMaterial(matName,material) {
		if(matName == "mistyglow") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/pads/mistyglow.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			material.passes.removeShader(material.textureShader);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_depthWrite(false);
			glowpass.set_enableLights(false);
			glowpass.setBlendMode(h2d_BlendMode.Alpha);
			material.addPass(glowpass);
			material.passes.setPassName("glowPreNoRender");
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			material.passes.set_enableLights(false);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.passes.set_depthWrite(false);
		}
	}
}
$hxClasses["shapes.GemBeam"] = shapes_GemBeam;
shapes_GemBeam.__name__ = "shapes.GemBeam";
shapes_GemBeam.__super__ = src_DtsObject;
Object.assign(shapes_GemBeam.prototype, {
	__class__: shapes_GemBeam
});
class shapes_Glass extends src_DtsObject {
	constructor(element) {
		super();
		let datablockLowercase = element.datablock.toLowerCase();
		switch(datablockLowercase) {
		case "glass_12shape":
			this.dtsPath = "data/shapes/structures/glass_12.dts";
			break;
		case "glass_15shape":
			this.dtsPath = "data/shapes/structures/glass_15.dts";
			break;
		case "glass_18shape":
			this.dtsPath = "data/shapes/structures/glass_18.dts";
			break;
		case "glass_3shape":
			this.dtsPath = "data/shapes/structures/glass_3.dts";
			break;
		case "glass_6shape":
			this.dtsPath = "data/shapes/structures/glass_6.dts";
			break;
		case "glass_9shape":
			this.dtsPath = "data/shapes/structures/glass_9.dts";
			break;
		}
		this.isCollideable = true;
		this.useInstancing = true;
		this.identifier = datablockLowercase;
	}
	getPreloadMaterials(dts) {
		let mats = super.getPreloadMaterials(dts);
		mats.push("data/shapes/structures/glass.png");
		mats.push("data/shapes/structures/glass2.png");
		mats.push("data/shapes/structures/glass.normal.png");
		return mats;
	}
	postProcessMaterial(matName,material) {
		let refractTex = src_ResourceLoader.getTexture("data/shapes/structures/glass.png").resource;
		refractTex.set_wrap(h3d_mat_Wrap.Repeat);
		refractTex.set_mipMap(h3d_mat_MipMap.Nearest);
		let diffuseTex = src_ResourceLoader.getTexture("data/shapes/structures/glass2.png").resource;
		diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
		diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
		let normalTex = src_ResourceLoader.getTexture("data/shapes/structures/glass.normal.png").resource;
		normalTex.set_wrap(h3d_mat_Wrap.Repeat);
		normalTex.set_mipMap(h3d_mat_MipMap.Nearest);
		let trivialShader = new shaders_TrivialMaterial(diffuseTex);
		this.shader = new shaders_RefractMaterial(refractTex,normalTex,12,new h3d_Vector(1,1,1,1),1);
		this.shader.refractMap__ = src_Renderer.sfxBuffer;
		let refractPass = material.passes.clone();
		material.set_texture(diffuseTex);
		let dtsshader = material.passes.getShader(shaders_DtsTexture);
		if(dtsshader != null) {
			material.passes.removeShader(dtsshader);
		}
		material.passes.removeShader(material.textureShader);
		material.passes.addShader(trivialShader);
		material.passes.setBlendMode(h2d_BlendMode.Alpha);
		material.passes.set_enableLights(false);
		material.passes.set_depthWrite(false);
		material.set_castShadows(false);
		material.set_receiveShadows(false);
		material.passes.setPassName("glowPre");
		refractPass.setPassName("refract");
		refractPass.addShader(this.shader);
		dtsshader = refractPass.getShader(shaders_DtsTexture);
		if(dtsshader != null) {
			material.passes.removeShader(dtsshader);
		}
		refractPass.removeShader(material.textureShader);
		refractPass.set_enableLights(false);
		let src = h3d_mat_Blend.One;
		let dst = h3d_mat_Blend.Zero;
		refractPass.set_blendSrc(src);
		refractPass.set_blendAlphaSrc(src);
		refractPass.set_blendDst(dst);
		refractPass.set_blendAlphaDst(dst);
		refractPass.set_depthWrite(true);
		refractPass.set_depthTest(h3d_mat_Compare.LessEqual);
		material.addPass(refractPass);
	}
}
$hxClasses["shapes.Glass"] = shapes_Glass;
shapes_Glass.__name__ = "shapes.Glass";
shapes_Glass.__super__ = src_DtsObject;
Object.assign(shapes_Glass.prototype, {
	__class__: shapes_Glass
	,shader: null
});
class shapes_Helicopter extends shapes_PowerUp {
	constructor(element) {
		super(element);
		this.dtsPath = "data/shapes/images/helicopter.dts";
		this.isCollideable = false;
		this.isTSStatic = false;
		this.showSequences = false;
		this.identifier = "Helicopter";
		this.sharedNodeTransforms = true;
		this.pickUpName = "a Gyrocopter powerup";
	}
	init(level,onFinish) {
		let _gthis = this;
		super.init(level,function() {
			src_ResourceLoader.load("sound/gyrocopter.wav").entry.load(function() {
				_gthis.pickupSound = src_ResourceLoader.getResource("data/sound/gyrocopter.wav",src_ResourceLoader.getAudio,_gthis.soundResources);
				onFinish();
			});
		});
	}
	pickUp(marble) {
		return this.level.pickUpPowerUp(marble,this);
	}
	use(marble,timeState) {
		marble.enableHelicopter(timeState);
		this.level.deselectPowerUp(marble);
	}
	postProcessMaterial(matName,material) {
		if(matName == "copter_skin") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/images/copter_skin.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultNormalMaterial(diffuseTex,32,new h3d_Vector(1,1,1,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
	}
}
$hxClasses["shapes.Helicopter"] = shapes_Helicopter;
shapes_Helicopter.__name__ = "shapes.Helicopter";
shapes_Helicopter.__super__ = shapes_PowerUp;
Object.assign(shapes_Helicopter.prototype, {
	__class__: shapes_Helicopter
});
class shapes_HelicopterImage extends src_DtsObject {
	constructor() {
		super();
		this.dtsPath = "data/shapes/images/helicopter_image.dts";
		this.isCollideable = false;
		this.isTSStatic = false;
		this.identifier = "HelicopterImage";
		this.useInstancing = true;
	}
	init(level,onFinish) {
		super.init(level,onFinish);
	}
	postProcessMaterial(matName,material) {
		if(matName == "copter_skin") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/images/copter_skin.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultNormalMaterial(diffuseTex,32,new h3d_Vector(1,1,1,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
	}
}
$hxClasses["shapes.HelicopterImage"] = shapes_HelicopterImage;
shapes_HelicopterImage.__name__ = "shapes.HelicopterImage";
shapes_HelicopterImage.__super__ = src_DtsObject;
Object.assign(shapes_HelicopterImage.prototype, {
	__class__: shapes_HelicopterImage
});
class shapes_MegaMarble extends shapes_PowerUp {
	constructor(element) {
		super(element);
		this.dtsPath = "data/shapes/images/grow.dts";
		this.isCollideable = false;
		this.isTSStatic = false;
		this.showSequences = true;
		this.identifier = "MegaMarble";
		this.sharedNodeTransforms = true;
		this.pickUpName = "a Mega-Marble powerup";
	}
	init(level,onFinish) {
		let _gthis = this;
		super.init(level,function() {
			src_ResourceLoader.load("sound/mega_marble.wav").entry.load(function() {
				let worker = new src_ResourceLoaderWorker(onFinish);
				worker.loadFile("sound/mega_bouncehard1.wav");
				worker.loadFile("sound/mega_bouncehard2.wav");
				worker.loadFile("sound/mega_bouncehard3.wav");
				worker.loadFile("sound/mega_bouncehard4.wav");
				worker.loadFile("sound/mega_roll.wav");
				worker.loadFile("sound/MegaShrink.wav");
				worker.loadFile("sound/use_mega.wav");
				_gthis.pickupSound = src_ResourceLoader.getResource("data/sound/mega_marble.wav",src_ResourceLoader.getAudio,_gthis.soundResources);
				worker.run();
			});
		});
	}
	pickUp(marble) {
		return this.level.pickUpPowerUp(marble,this);
	}
	use(marble,timeState) {
		marble.enableMegaMarble(timeState);
		let _this = marble.currentUp;
		let v = 5 / marble.getMass();
		let x = _this.x * v;
		let y = _this.y * v;
		let z = _this.z * v;
		let w = _this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let boost_x = x;
		let boost_y = y;
		let boost_z = z;
		let boost_w = w;
		let _this1 = marble.velocity;
		let _this2 = marble.velocity;
		let x1 = _this2.x + boost_x;
		let y1 = _this2.y + boost_y;
		let z1 = _this2.z + boost_z;
		let w1 = _this2.w + boost_w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let v_x = x1;
		let v_y = y1;
		let v_z = z1;
		let v_w = w1;
		_this1.x = v_x;
		_this1.y = v_y;
		_this1.z = v_z;
		_this1.w = v_w;
		this.level.deselectPowerUp(marble);
		if(this.level.marble == marble && !marble.isNetUpdate) {
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/use_mega.wav",src_ResourceLoader.getAudio,this.soundResources));
		}
	}
	getPreloadMaterials(dts) {
		let mats = super.getPreloadMaterials(dts);
		mats.push("data/shapes/images/grow_bump.png");
		mats.push("data/shapes/images/grow_glow.png");
		return mats;
	}
	postProcessMaterial(matName,material) {
		if(matName == "grow") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/images/grow.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let normalTex = src_ResourceLoader.getTexture("data/shapes/images/grow_bump.png").resource;
			normalTex.set_wrap(h3d_mat_Wrap.Repeat);
			normalTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultMaterial(diffuseTex,normalTex,32,new h3d_Vector(0.8,0.8,0.6,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "item_glow") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/images/grow_glow.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				glowpass.removeShader(dtsshader);
			}
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_enableLights(false);
			material.addPass(glowpass);
			material.passes.setPassName("glowPre");
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				material.passes.removeShader(dtsshader);
			}
			material.passes.set_enableLights(false);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
		}
	}
}
$hxClasses["shapes.MegaMarble"] = shapes_MegaMarble;
shapes_MegaMarble.__name__ = "shapes.MegaMarble";
shapes_MegaMarble.__super__ = shapes_PowerUp;
Object.assign(shapes_MegaMarble.prototype, {
	__class__: shapes_MegaMarble
});
class shapes_RoundBumper extends shapes_AbstractBumper {
	constructor() {
		super();
		this.dtsPath = "data/shapes/bumpers/pball_round.dts";
		this.isCollideable = true;
		this.identifier = "RoundBumper";
		this.animateSubObjectOpacities = true;
	}
	getPreloadMaterials(dts) {
		let mats = super.getPreloadMaterials(dts);
		mats.push("data/shapes/items/antigrav_glow.png");
		mats.push("data/shapes/images/blastwave.png");
		return mats;
	}
	postProcessMaterial(matName,material) {
		if(matName == "bumper") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/bumpers/bumper.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultNormalMaterial(diffuseTex,12,new h3d_Vector(0.8,0.8,0.8,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "antigrav_glow") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/items/antigrav_glow.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_enableLights(false);
			material.addPass(glowpass);
			material.passes.setPassName("glowPre");
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				material.passes.removeShader(dtsshader);
			}
			material.passes.set_enableLights(false);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
		}
		if(matName == "blastwave") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/images/blastwave.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			material.passes.removeShader(material.textureShader);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_depthWrite(false);
			glowpass.set_enableLights(false);
			glowpass.setBlendMode(h2d_BlendMode.Alpha);
			material.addPass(glowpass);
			material.passes.setPassName("glowPreNoRender");
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			dtsshader.constModified = true;
			dtsshader.passThrough__ = true;
			material.passes.set_enableLights(false);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.passes.set_depthWrite(false);
		}
	}
}
$hxClasses["shapes.RoundBumper"] = shapes_RoundBumper;
shapes_RoundBumper.__name__ = "shapes.RoundBumper";
shapes_RoundBumper.__super__ = shapes_AbstractBumper;
Object.assign(shapes_RoundBumper.prototype, {
	__class__: shapes_RoundBumper
});
class shapes_SignCaution extends src_DtsObject {
	constructor(element) {
		super();
		this.dtsPath = "data/shapes/signs/cautionsign.dts";
		this.isCollideable = true;
		this.useInstancing = true;
		this.sharedNodeTransforms = true;
		let type = element.datablock.substring("SignCaution".length).toLowerCase();
		switch(type) {
		case "caution":
			this.matNameOverride.h["base.cautionsign"] = "caution.cautionsign";
			break;
		case "danger":
			this.matNameOverride.h["base.cautionsign"] = "danger.cautionsign";
			break;
		}
		this.identifier = "CautionSign" + type;
	}
	postProcessMaterial(matName,material) {
		if(matName == "base.cautionsign") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/signs/base.cautionsign.jpg").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultDiffuseMaterial(diffuseTex);
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "caution.cautionsign") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/signs/caution.cautionsign.jpg").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultDiffuseMaterial(diffuseTex);
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "danger.cautionsign") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/signs/danger.cautionsign.jpg").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultDiffuseMaterial(diffuseTex);
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "cautionsignwood") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/signs/cautionsignwood.jpg").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultDiffuseMaterial(diffuseTex);
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "cautionsign_pole") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/signs/cautionsign_pole.jpg").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultDiffuseMaterial(diffuseTex);
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
	}
}
$hxClasses["shapes.SignCaution"] = shapes_SignCaution;
shapes_SignCaution.__name__ = "shapes.SignCaution";
shapes_SignCaution.__super__ = src_DtsObject;
Object.assign(shapes_SignCaution.prototype, {
	__class__: shapes_SignCaution
});
class shapes_SignPlain extends src_DtsObject {
	constructor(element) {
		super();
		this.isCollideable = true;
		this.useInstancing = true;
		this.sharedNodeTransforms = true;
		let direction = element.datablock.substring("Arrow".length).toLowerCase();
		switch(direction) {
		case "down":
			this.dtsPath = "data/shapes/signs/arrowsign_down.dts";
			break;
		case "side":
			this.dtsPath = "data/shapes/signs/arrowsign_side.dts";
			break;
		case "up":
			this.dtsPath = "data/shapes/signs/arrowsign_up.dts";
			break;
		}
		this.identifier = "SignPlain" + direction;
	}
	getPreloadMaterials(dts) {
		let mats = super.getPreloadMaterials(dts);
		mats.push("data/shapes/signs/arrowsign_post_bump.png");
		return mats;
	}
	postProcessMaterial(matName,material) {
		if(matName == "arrowsign_arrow") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/signs/arrowsign_arrow.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultNormalMaterial(diffuseTex,32,new h3d_Vector(1,1,1,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "arrowsign_arrow_glow") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/signs/arrowsign_arrow.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultNormalMaterial(diffuseTex,32,new h3d_Vector(1,1,1,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let glowpass = material.passes.clone();
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				glowpass.removeShader(dtsshader);
			}
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_enableLights(false);
			material.addPass(glowpass);
			material.passes.setPassName("glowPre");
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				material.passes.removeShader(dtsshader);
			}
			material.passes.set_enableLights(false);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
		}
		if(matName == "ArrowPostUVW") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/signs/arrowpostUVW.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultNormalMaterial(diffuseTex,32,new h3d_Vector(0.8,0.8,0.6,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "arrowsign_chain") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/signs/arrowsign_chain.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				glowpass.removeShader(dtsshader);
			}
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_depthWrite(false);
			glowpass.set_enableLights(false);
			glowpass.set_blendSrc(h3d_mat_Blend.SrcAlpha);
			glowpass.set_blendDst(h3d_mat_Blend.OneMinusSrcAlpha);
			material.addPass(glowpass);
			material.passes.setPassName("glowPreNoRender");
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				material.passes.removeShader(dtsshader);
			}
			material.passes.set_enableLights(false);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_blendMode(h2d_BlendMode.Alpha);
			material.passes.set_depthWrite(false);
			material.passes.set_blendSrc(h3d_mat_Blend.SrcAlpha);
			material.passes.set_blendDst(h3d_mat_Blend.OneMinusSrcAlpha);
		}
		if(matName == "arrowsign_post") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/signs/arrowsign_post.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let normalTex = src_ResourceLoader.getTexture("data/shapes/signs/arrowsign_post_bump.png").resource;
			normalTex.set_wrap(h3d_mat_Wrap.Repeat);
			normalTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultMaterial(diffuseTex,normalTex,12,new h3d_Vector(0.8,0.8,0.6,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
	}
}
$hxClasses["shapes.SignPlain"] = shapes_SignPlain;
shapes_SignPlain.__name__ = "shapes.SignPlain";
shapes_SignPlain.__super__ = src_DtsObject;
Object.assign(shapes_SignPlain.prototype, {
	__class__: shapes_SignPlain
});
class shapes_Sky extends src_DtsObject {
	constructor(type) {
		super();
		if(type == "astrolabecloudsbeginnershape") {
			this.dtsPath = "data/shapes/astrolabe/astrolabe_clouds_beginner.dts";
		}
		if(type == "astrolabecloudsintermediateshape") {
			this.dtsPath = "data/shapes/astrolabe/astrolabe_clouds_intermediate.dts";
		}
		if(type == "astrolabecloudsadvancedshape") {
			this.dtsPath = "data/shapes/astrolabe/astrolabe_clouds_advanced.dts";
		}
		this.isCollideable = false;
		this.useInstancing = false;
		this.identifier = type + "Sky";
	}
	init(level,onFinish) {
		super.init(level,onFinish);
		let _g = 0;
		let _g1 = this.materials;
		while(_g < _g1.length) {
			let mat = _g1[_g];
			++_g;
			let thisprops = mat.getDefaultProps();
			thisprops.light = false;
			mat.set_props(thisprops);
			mat.set_castShadows(false);
			mat.set_receiveShadows(false);
			mat.set_receiveShadows(false);
			mat.set_blendMode(h2d_BlendMode.Alpha);
			mat.passes.set_depthWrite(false);
			mat.passes.set_culling(h3d_mat_Face.None);
			mat.passes.setPassName("skyshape");
		}
	}
}
$hxClasses["shapes.Sky"] = shapes_Sky;
shapes_Sky.__name__ = "shapes.Sky";
shapes_Sky.__super__ = src_DtsObject;
Object.assign(shapes_Sky.prototype, {
	__class__: shapes_Sky
});
class shapes_SmallDuctFan extends src_ForceObject {
	constructor() {
		super();
		this.dtsPath = "data/shapes/hazards/ductfan.dts";
		this.isCollideable = true;
		this.isTSStatic = false;
		this.sharedNodeTransforms = true;
		this.identifier = "DuctFan";
		this.forceDatas = [{ forceType : src_ForceType.ForceCone, forceNode : 0, forceStrength : 10, forceRadius : 5, forceArc : 0.7, forceVector : new h3d_Vector()}];
	}
	init(level,onFinish) {
		let _gthis = this;
		super.init(level,function() {
			src_ResourceLoader.load("sound/fan_loop.wav").entry.load(function() {
				let tmp = src_ResourceLoader.getResource("data/sound/fan_loop.wav",src_ResourceLoader.getAudio,_gthis.soundResources);
				_gthis.soundChannel = src_AudioManager.playSound(tmp,new h3d_Vector(1e8,1e8,1e8),true);
				_gthis.soundChannel.set_pause(true);
				onFinish();
			});
		});
	}
	reset() {
		super.reset();
		let seffect = this.soundChannel.getEffect(hxd_snd_effect_Spatialization);
		let _this = this.getAbsPos();
		let v = new h3d_Vector();
		let x = _this._41;
		let y = _this._42;
		let z = _this._43;
		let w = _this._44;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v.x = x;
		v.y = y;
		v.z = z;
		v.w = w;
		seffect.position = v;
		if(this.soundChannel.pause) {
			this.soundChannel.set_pause(false);
		}
	}
}
$hxClasses["shapes.SmallDuctFan"] = shapes_SmallDuctFan;
shapes_SmallDuctFan.__name__ = "shapes.SmallDuctFan";
shapes_SmallDuctFan.__super__ = src_ForceObject;
Object.assign(shapes_SmallDuctFan.prototype, {
	__class__: shapes_SmallDuctFan
	,soundChannel: null
});
class shapes_StartPad extends src_DtsObject {
	constructor() {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.animStart = Infinity;
		super._hx_constructor();
		this.dtsPath = "data/shapes/pads/startarea.dts";
		this.isCollideable = true;
		this.identifier = "StartPad";
		this.useInstancing = false;
		this.animateSubObjectOpacities = true;
	}
	onLevelStart() {
		this.animStart = this.level.timeState.timeSinceLoad;
	}
	update(timeState) {
		let currentCompletion = this.getCompletion(timeState);
		this.sequenceKeyframeOverride.set(this.dts.sequences[0],currentCompletion * (this.dts.sequences[0].numKeyFrames - 1));
		super.update(timeState);
	}
	reset() {
		super.reset();
		this.animStart = this.level.timeState.timeSinceLoad;
	}
	getCompletion(timeState) {
		let elapsed = timeState.timeSinceLoad - this.animStart - 0.5;
		if(elapsed < 0) {
			return 1.0;
		}
		let value = elapsed / this.dts.sequences[0].duration;
		let completion = value < 0 ? 0 : value > 1 ? 1 : value;
		return completion;
	}
	getPreloadMaterials(dts) {
		let mats = super.getPreloadMaterials(dts);
		mats.push("data/shapes/pads/ringnormal.png");
		return mats;
	}
	postProcessMaterial(matName,material) {
		if(matName == "ringglass") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/pads/ringglass.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let normalTex = src_ResourceLoader.getTexture("data/shapes/pads/ringnormal.png").resource;
			normalTex.set_wrap(h3d_mat_Wrap.Repeat);
			normalTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let cubemapTex = new h3d_mat_Texture(64,64,[h3d_mat_TextureFlags.Cube]);
			let cubemapFace1 = src_ResourceLoader.getImage("data/skies/env_SO.png").resource;
			let cubemapFace2 = src_ResourceLoader.getImage("data/skies/env_NO.png").resource;
			let cubemapFace3 = src_ResourceLoader.getImage("data/skies/env_EA.png").resource;
			let cubemapFace4 = src_ResourceLoader.getImage("data/skies/env_WE.png").resource;
			let cubemapFace5 = src_ResourceLoader.getImage("data/skies/env_UP.png").resource;
			let cubemapFace6 = src_ResourceLoader.getImage("data/skies/env_DN.png").resource;
			cubemapTex.uploadPixels(cubemapFace1.getPixels(),0,0);
			cubemapTex.uploadPixels(cubemapFace2.getPixels(),0,1);
			cubemapTex.uploadPixels(cubemapFace3.getPixels(),0,2);
			cubemapTex.uploadPixels(cubemapFace4.getPixels(),0,3);
			cubemapTex.uploadPixels(cubemapFace5.getPixels(),0,4);
			cubemapTex.uploadPixels(cubemapFace6.getPixels(),0,5);
			let shader = new shaders_DefaultCubemapMaterial(diffuseTex,normalTex,12,new h3d_Vector(0.8,0.8,0.8,1),1,cubemapTex);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsshader = material.passes.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				material.passes.removeShader(dtsshader);
			}
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
			material.set_blendMode(h2d_BlendMode.Alpha);
			material.passes.set_culling(h3d_mat_Face.None);
		}
		if(matName == "ringtex") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/pads/ringtex.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultNormalMaterial(diffuseTex,14,new h3d_Vector(0.3,0.3,0.3,7),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsshader = material.passes.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				material.passes.removeShader(dtsshader);
			}
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "abyss") {
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
			let rotshader = new shaders_UVRotAnim(0.5,0.5,1);
			material.passes.addShader(rotshader);
		}
		if(matName == "abyss2") {
			let glowpass = material.passes.clone();
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_enableLights(false);
			material.addPass(glowpass);
			material.passes.setPassName("glowPre");
			material.passes.set_enableLights(false);
			let rotshader = new shaders_UVRotAnim(0.5,0.5,1);
			material.passes.addShader(rotshader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
		}
		if(matName == "misty") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/pads/misty.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			let scrollShader = new h3d_shader_UVScroll(0,0.5);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			glowpass.addShader(scrollShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				glowpass.removeShader(dtsshader);
			}
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_depthWrite(false);
			glowpass.set_enableLights(false);
			glowpass.set_blendSrc(h3d_mat_Blend.SrcAlpha);
			glowpass.set_blendDst(h3d_mat_Blend.OneMinusSrcAlpha);
			material.addPass(glowpass);
			material.passes.setPassName("glowPreNoRender");
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				material.passes.removeShader(dtsshader);
			}
			material.passes.set_enableLights(false);
		}
	}
}
$hxClasses["shapes.StartPad"] = shapes_StartPad;
shapes_StartPad.__name__ = "shapes.StartPad";
shapes_StartPad.__super__ = src_DtsObject;
Object.assign(shapes_StartPad.prototype, {
	__class__: shapes_StartPad
	,animStart: null
});
class shapes_SuperJump extends shapes_PowerUp {
	constructor(element) {
		super(element);
		this.dtsPath = "data/shapes/items/superjump.dts";
		this.isCollideable = false;
		this.isTSStatic = false;
		this.identifier = "SuperJump";
		this.pickUpName = "a Super Jump powerup";
		this.showSequences = false;
		this.sharedNodeTransforms = true;
		this.sjEmitterParticleData = new src_ParticleData();
		this.sjEmitterParticleData.identifier = "superJumpParticle";
		this.sjEmitterParticleData.texture = src_ResourceLoader.getResource("data/particles/twirl.png",src_ResourceLoader.getTexture,this.textureResources);
	}
	init(level,onFinish) {
		let _gthis = this;
		super.init(level,function() {
			src_ResourceLoader.load("sound/super_jump.wav").entry.load(function() {
				_gthis.pickupSound = src_ResourceLoader.getResource("data/sound/super_jump.wav",src_ResourceLoader.getAudio,_gthis.soundResources);
				src_ResourceLoader.load("sound/use_superjump.wav").entry.load(onFinish);
			});
		});
	}
	pickUp(marble) {
		return this.level.pickUpPowerUp(marble,this);
	}
	use(marble,timeState) {
		let masslessFactor = marble.getMass() * 0.7 + 1 - 0.7;
		let _this = marble.currentUp;
		let v = 20 * masslessFactor / marble.getMass();
		let x = _this.x * v;
		let y = _this.y * v;
		let z = _this.z * v;
		let w = _this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let boost_x = x;
		let boost_y = y;
		let boost_z = z;
		let boost_w = w;
		let _this1 = marble.velocity;
		marble.velocity = new h3d_Vector(_this1.x + boost_x,_this1.y + boost_y,_this1.z + boost_z,_this1.w + boost_w);
		if(!marble.isNetUpdate) {
			this.level.particleManager.createEmitter(shapes_SuperJump_superJumpParticleOptions,this.sjEmitterParticleData,null,function() {
				let _this = marble.getAbsPos();
				let v = new h3d_Vector();
				let x = _this._41;
				let y = _this._42;
				let z = _this._43;
				let w = _this._44;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				v.x = x;
				v.y = y;
				v.z = z;
				v.w = w;
				return v;
			});
		}
		if(this.level.marble == marble && !marble.isNetUpdate) {
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/use_superjump.wav",src_ResourceLoader.getAudio,this.soundResources));
		}
		this.level.deselectPowerUp(marble);
	}
	getPreloadMaterials(dts) {
		let mats = super.getPreloadMaterials(dts);
		mats.push("data/shapes/items/superjump_bump.png");
		return mats;
	}
	postProcessMaterial(matName,material) {
		if(matName == "superJump_skin") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/items/superjump_skin.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let normalTex = src_ResourceLoader.getTexture("data/shapes/items/superjump_bump.png").resource;
			normalTex.set_wrap(h3d_mat_Wrap.Repeat);
			normalTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultMaterial(diffuseTex,normalTex,32,new h3d_Vector(1,1,1,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
	}
}
$hxClasses["shapes.SuperJump"] = shapes_SuperJump;
shapes_SuperJump.__name__ = "shapes.SuperJump";
shapes_SuperJump.__super__ = shapes_PowerUp;
Object.assign(shapes_SuperJump.prototype, {
	__class__: shapes_SuperJump
	,sjEmitterParticleData: null
});
class shapes_SuperSpeed extends shapes_PowerUp {
	constructor(element) {
		super(element);
		this.dtsPath = "data/shapes/items/superspeed.dts";
		this.isCollideable = false;
		this.isTSStatic = false;
		this.identifier = "SuperSpeed";
		this.pickUpName = "a Super Speed powerup";
		this.useInstancing = true;
		this.sharedNodeTransforms = true;
		this.ssEmitterParticleData = new src_ParticleData();
		this.ssEmitterParticleData.identifier = "superSpeedParticle";
		this.ssEmitterParticleData.texture = src_ResourceLoader.getResource("data/particles/smoke.png",src_ResourceLoader.getTexture,this.textureResources);
	}
	init(level,onFinish) {
		let _gthis = this;
		super.init(level,function() {
			src_ResourceLoader.load("sound/super_speed.wav").entry.load(function() {
				_gthis.pickupSound = src_ResourceLoader.getResource("data/sound/super_speed.wav",src_ResourceLoader.getAudio,_gthis.soundResources);
				src_ResourceLoader.load("sound/use_speed.wav").entry.load(onFinish);
			});
		});
	}
	pickUp(marble) {
		return this.level.pickUpPowerUp(marble,this);
	}
	use(marble,timeState) {
		let movementVector = marble.getMarbleAxis()[0];
		let x = movementVector.x;
		let y = movementVector.y;
		let z = movementVector.z;
		let w = movementVector.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let boostVec_x = x;
		let boostVec_y = y;
		let boostVec_z = z;
		let boostVec_w = w;
		let v = marble.lastContactNormal;
		let contactDot = movementVector.x * v.x + movementVector.y * v.y + movementVector.z * v.z;
		let _this = marble.lastContactNormal;
		let x1 = _this.x * contactDot;
		let y1 = _this.y * contactDot;
		let z1 = _this.z * contactDot;
		let w1 = _this.w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let v_x = x1;
		let v_y = y1;
		let v_z = z1;
		let v_w = w1;
		let x2 = boostVec_x - v_x;
		let y2 = boostVec_y - v_y;
		let z2 = boostVec_z - v_z;
		let w2 = boostVec_w - v_w;
		if(w2 == null) {
			w2 = 1.;
		}
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let v_x1 = x2;
		let v_y1 = y2;
		let v_z1 = z2;
		let v_w1 = w2;
		boostVec_x = v_x1;
		boostVec_y = v_y1;
		boostVec_z = v_z1;
		boostVec_w = v_w1;
		if(boostVec_x * boostVec_x + boostVec_y * boostVec_y + boostVec_z * boostVec_z > 0.01) {
			let k = boostVec_x * boostVec_x + boostVec_y * boostVec_y + boostVec_z * boostVec_z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			boostVec_x *= k;
			boostVec_y *= k;
			boostVec_z *= k;
		} else {
			boostVec_x = movementVector.x;
			boostVec_y = movementVector.y;
			boostVec_z = movementVector.z;
			boostVec_w = movementVector.w;
		}
		let masslessFactor = marble.getMass() * 0.7 + 1 - 0.7;
		let _this1 = marble.velocity;
		let v1 = -25 * masslessFactor / marble.getMass();
		let x3 = boostVec_x * v1;
		let y3 = boostVec_y * v1;
		let z3 = boostVec_z * v1;
		let w3 = boostVec_w;
		if(w3 == null) {
			w3 = 1.;
		}
		if(z3 == null) {
			z3 = 0.;
		}
		if(y3 == null) {
			y3 = 0.;
		}
		if(x3 == null) {
			x3 = 0.;
		}
		let v_x2 = x3;
		let v_y2 = y3;
		let v_z2 = z3;
		let v_w2 = w3;
		marble.velocity = new h3d_Vector(_this1.x + v_x2,_this1.y + v_y2,_this1.z + v_z2,_this1.w + v_w2);
		if(this.level.marble == marble && !marble.isNetUpdate) {
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/use_speed.wav",src_ResourceLoader.getAudio,this.soundResources));
		}
		if(!marble.isNetUpdate) {
			this.level.particleManager.createEmitter(shapes_SuperSpeed_superSpeedParticleOptions,this.ssEmitterParticleData,null,function() {
				let _this = marble.getAbsPos();
				let v = new h3d_Vector();
				let x = _this._41;
				let y = _this._42;
				let z = _this._43;
				let w = _this._44;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				v.x = x;
				v.y = y;
				v.z = z;
				v.w = w;
				return v;
			});
		}
		this.level.deselectPowerUp(marble);
	}
	postProcessMaterial(matName,material) {
		if(matName == "superSpeed_skin") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/items/superSpeed_skin.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultNormalMaterial(diffuseTex,32,new h3d_Vector(1,1,1,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "superSpeed_star") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/items/superSpeed_star.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let trivialShader = new shaders_TrivialMaterial(diffuseTex);
			let glowpass = material.passes.clone();
			glowpass.addShader(trivialShader);
			let dtsshader = glowpass.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				glowpass.removeShader(dtsshader);
			}
			glowpass.setPassName("glow");
			glowpass.set_depthTest(h3d_mat_Compare.LessEqual);
			glowpass.set_enableLights(false);
			material.addPass(glowpass);
			material.passes.setPassName("glowPre");
			material.passes.addShader(trivialShader);
			dtsshader = material.passes.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				material.passes.removeShader(dtsshader);
			}
			material.passes.set_enableLights(false);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
		}
	}
}
$hxClasses["shapes.SuperSpeed"] = shapes_SuperSpeed;
shapes_SuperSpeed.__name__ = "shapes.SuperSpeed";
shapes_SuperSpeed.__super__ = shapes_PowerUp;
Object.assign(shapes_SuperSpeed.prototype, {
	__class__: shapes_SuperSpeed
	,ssEmitterParticleData: null
});
class shapes_TimeTravel extends shapes_PowerUp {
	constructor(element) {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(element);
	}
	_hx_constructor(element) {
		this.timeBonus = 5;
		super._hx_constructor(element);
		this.dtsPath = "data/shapes/items/timetravel.dts";
		this.isCollideable = false;
		this.isTSStatic = false;
		this.sharedNodeTransforms = true;
		this.identifier = "TimeTravel";
		if(element.timebonus != null) {
			this.timeBonus = mis_MisParser.parseNumber(element.timebonus) / 1000;
		}
		if(element.timepenalty != null) {
			this.timeBonus = -mis_MisParser.parseNumber(element.timepenalty) / 1000;
		}
		this.pickUpName = "" + this.timeBonus + " seconds of Time Travel " + (this.timeBonus >= 0 ? "bonus" : "Penalty");
		this.cooldownDuration = 1e8;
		this.useInstancing = true;
		this.autoUse = true;
	}
	init(level,onFinish) {
		let _gthis = this;
		super.init(level,function() {
			src_ResourceLoader.load("sound/time_travel.wav").entry.load(function() {
				_gthis.pickupSound = src_ResourceLoader.getResource("data/sound/time_travel.wav",src_ResourceLoader.getAudio,_gthis.soundResources);
				src_ResourceLoader.load("sound/timetravelactive.wav").entry.load(onFinish);
			});
		});
	}
	pickUp(marble) {
		return true;
	}
	use(marble,time) {
		if(!this.level.rewinding) {
			this.level.addBonusTime(this.timeBonus);
		}
	}
	getPreloadMaterials(dts) {
		let mats = super.getPreloadMaterials(dts);
		mats.push("data/shapes/structures/glass.png");
		mats.push("data/shapes/structures/time.normal.jpg");
		return mats;
	}
	postProcessMaterial(matName,material) {
		if(matName == "timeTravel_skin") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/items/timeTravel_skin.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultNormalMaterial(diffuseTex,32,new h3d_Vector(1,1,1,1),1);
			shader.constModified = true;
			shader.doGammaRamp__ = false;
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
		if(matName == "timeTravel_glass") {
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
			material.passes.set_depthWrite(false);
			material.set_blendMode(h2d_BlendMode.Alpha);
			let refractTex = src_ResourceLoader.getTexture("data/shapes/structures/glass.png").resource;
			refractTex.set_wrap(h3d_mat_Wrap.Repeat);
			refractTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let normalTex = src_ResourceLoader.getTexture("data/shapes/structures/time.normal.jpg").resource;
			normalTex.set_wrap(h3d_mat_Wrap.Repeat);
			normalTex.set_mipMap(h3d_mat_MipMap.Nearest);
			this.shader = new shaders_RefractMaterial(refractTex,normalTex,10,new h3d_Vector(1,1,1,1),1);
			this.shader.refractMap__ = src_Renderer.sfxBuffer;
			let dtsshader = material.passes.getShader(shaders_DtsTexture);
			if(dtsshader != null) {
				material.passes.removeShader(dtsshader);
			}
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(this.shader);
			material.passes.setPassName("refract");
		}
	}
}
$hxClasses["shapes.TimeTravel"] = shapes_TimeTravel;
shapes_TimeTravel.__name__ = "shapes.TimeTravel";
shapes_TimeTravel.__super__ = shapes_PowerUp;
Object.assign(shapes_TimeTravel.prototype, {
	__class__: shapes_TimeTravel
	,timeBonus: null
	,shader: null
});
class shapes_Trapdoor extends src_DtsObject {
	constructor() {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.lastCompletion = 0;
		this.timeout = 0.2;
		this.lastContactTime = -1e8;
		super._hx_constructor();
		this.dtsPath = "data/shapes/hazards/trapdoor.dts";
		this.isCollideable = true;
		this.isTSStatic = false;
		this.identifier = "Trapdoor";
		this.hasNonVisualSequences = true;
		this.enableCollideCallbacks = true;
	}
	init(level,onFinish) {
		super.init(level,function() {
			src_ResourceLoader.load("sound/trapdooropen.wav").entry.load(onFinish);
		});
	}
	update(timeState) {
		let currentCompletion = this.getCurrentCompletion(timeState);
		this.sequenceKeyframeOverride.set(this.dts.sequences[0],currentCompletion * (this.dts.sequences[0].numKeyFrames - 1));
		super.update(timeState);
		let diff = currentCompletion - this.lastCompletion;
		let direction = 0;
		if(diff > 0) {
			direction = 1;
		}
		if(diff < 0) {
			direction = -1;
		}
		if(direction != 0 && direction != this.lastDirection) {
			let ch = src_ResourceLoader.getResource("data/sound/trapdooropen.wav",src_ResourceLoader.getAudio,this.soundResources);
			let _this = this.getAbsPos();
			let v = new h3d_Vector();
			let x = _this._41;
			let y = _this._42;
			let z = _this._43;
			let w = _this._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			v.x = x;
			v.y = y;
			v.z = z;
			v.w = w;
			src_AudioManager.playSound(ch,v);
		}
		this.lastCompletion = currentCompletion;
		this.lastDirection = direction;
	}
	getCurrentCompletion(timeState) {
		let elapsed = timeState.timeSinceLoad - this.lastContactTime;
		let value = elapsed / 1.6666676998138428;
		let completion = value < 0 ? 0 : value > 1 ? 1 : value;
		if(elapsed > 5) {
			let value = 1 - (elapsed - 5) / 1.6666676998138428;
			completion = value < 0 ? 0 : value > 1 ? 1 : value;
		}
		return completion;
	}
	onMarbleContact(marble,time,contact) {
		super.onMarbleContact(marble,time,contact);
		if(time.timeSinceLoad - this.lastContactTime <= 0) {
			return;
		}
		let currentCompletion = this.getCurrentCompletion(time);
		this.lastContactTime = time.timeSinceLoad - currentCompletion * 1.6666676998138428;
		if(currentCompletion == 0) {
			this.lastContactTime += this.timeout;
		}
	}
	postProcessMaterial(matName,material) {
		if(matName == "trapdoor") {
			let diffuseTex = src_ResourceLoader.getTexture("data/shapes/hazards/trapdoor.png").resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultDiffuseMaterial(diffuseTex);
			let dtsTex = material.passes.getShader(shaders_DtsTexture);
			dtsTex.constModified = true;
			dtsTex.passThrough__ = true;
			material.passes.removeShader(material.textureShader);
			material.passes.addShader(shader);
			let thisprops = material.getDefaultProps();
			thisprops.light = false;
			material.set_props(thisprops);
			material.set_castShadows(false);
			material.set_receiveShadows(false);
			material.set_receiveShadows(true);
		}
	}
}
$hxClasses["shapes.Trapdoor"] = shapes_Trapdoor;
shapes_Trapdoor.__name__ = "shapes.Trapdoor";
shapes_Trapdoor.__super__ = src_DtsObject;
Object.assign(shapes_Trapdoor.prototype, {
	__class__: shapes_Trapdoor
	,lastContactTime: null
	,timeout: null
	,lastDirection: null
	,lastCompletion: null
});
class src_Analytics {
	static trackSingle(eventName) {
		let p = src_Analytics.payload(eventName,null);
		let json = JSON.stringify(p);
		src_Http.post(src_Analytics.umami,json,function(b) {
		},function(e) {
		});
	}
	static trackLevelPlay(levelName,levelFile) {
		let p = src_Analytics.payload("level-play",{ level : { name : levelName, file : levelFile}});
		let json = JSON.stringify(p);
		src_Http.post(src_Analytics.umami,json,function(b) {
		},function(e) {
		});
	}
	static trackLevelScore(levelName,levelFile,time,oobs,respawns,rewind) {
		let p = src_Analytics.payload("level-score",{ level_play : JSON.stringify({ name : levelName, file : levelFile, time : time, oobs : oobs, respawns : respawns, rewind : rewind})});
		let json = JSON.stringify(p);
		src_Http.post(src_Analytics.umami,json,function(b) {
		},function(e) {
		});
	}
	static trackLevelQuit(levelName,levelFile,time,oobs,respawns,rewind) {
		let p = src_Analytics.payload("level-quit",{ level_quit : JSON.stringify({ name : levelName, file : levelFile, time : time, oobs : oobs, respawns : respawns, rewind : rewind})});
		let json = JSON.stringify(p);
		src_Http.post(src_Analytics.umami,json,function(b) {
		},function(e) {
		});
	}
	static trackPlatformInfo() {
		let p = src_Analytics.payload("device-telemetry",{ platform : $global.navigator.platform, screen : src_Analytics.screen()});
		let json = JSON.stringify(p);
		src_Http.post(src_Analytics.umami,json,function(b) {
		},function(e) {
		});
	}
	static payload(eventName,eventData) {
		let p = { type : "event", payload : { hostname : src_Analytics.hostname(), language : src_Analytics.language(), referrer : src_Analytics.referrer(), screen : src_Analytics.screen(), title : "MBHaxe Ultra", url : "/", website : "359e2bfd-5152-4284-969f-c9f5b56fcb76", name : eventName}};
		if(eventData == null) {
			return p;
		}
		p.payload.data = eventData;
		return p;
	}
	static hostname() {
		return window.location.hostname;
	}
	static language() {
		return window.navigator.language;
	}
	static referrer() {
		return window.document.referrer;
	}
	static screen() {
		return "" + window.screen.width + "x" + window.screen.height;
	}
}
$hxClasses["src.Analytics"] = src_Analytics;
src_Analytics.__name__ = "src.Analytics";
class src_AudioManager {
	static init() {
		src_Console.instance.addEntry("log","Initializing Audio System");
		src_AudioManager.manager = hxd_snd_Manager.get();
		src_AudioManager.soundGroup = new hxd_snd_SoundGroup("sound");
		src_AudioManager.soundGroup.volume = src_Settings.optionsSettings.soundVolume;
		src_AudioManager.musicGroup = new hxd_snd_SoundGroup("music");
		src_AudioManager.musicGroup.volume = src_Settings.optionsSettings.musicVolume;
	}
	static updateVolumes() {
		src_AudioManager.soundGroup.volume = src_Settings.optionsSettings.soundVolume;
		src_AudioManager.musicGroup.volume = src_Settings.optionsSettings.musicVolume;
	}
	static update(scene3d) {
		src_AudioManager.manager.listener.syncCamera(scene3d.camera);
	}
	static playSound(sound,position,loop) {
		if(loop == null) {
			loop = false;
		}
		let ch = src_AudioManager.manager.play(sound,null,src_AudioManager.soundGroup);
		ch.loop = loop;
		if(position != null) {
			let audioSrc = new hxd_snd_effect_Spatialization();
			audioSrc.position = position;
			audioSrc.referenceDistance = 4.5;
			ch.addEffect(audioSrc);
		}
		return ch;
	}
	static playShell() {
		src_AudioManager.manager.stopByName("music");
		let sndres = src_ResourceLoader.getAudio("data/sound/music/Tim Trance.ogg");
		if(sndres == null) {
			return;
		}
		sndres.acquire();
		if(src_AudioManager.currentMusicResource != null) {
			src_AudioManager.currentMusicResource.release();
		}
		src_AudioManager.currentMusicResource = sndres;
		src_AudioManager.currentMusic = src_AudioManager.manager.play(sndres.resource,null,src_AudioManager.musicGroup);
		src_AudioManager.currentMusic.loop = true;
	}
	static stopAllSounds() {
		src_AudioManager.manager.stopByName("sound");
	}
}
$hxClasses["src.AudioManager"] = src_AudioManager;
src_AudioManager.__name__ = "src.AudioManager";
class src_CameraController extends h3d_scene_Object {
	constructor(marble) {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(marble);
	}
	_hx_constructor(marble) {
		this.wasLastGamepadInput = false;
		this.hasYInput = false;
		this.hasXInput = false;
		this._ignoreCursor = false;
		this.finish = false;
		this.oob = false;
		this.CameraDistance = 2.5;
		super._hx_constructor();
		this.marble = marble;
	}
	init(level) {
		this.level = level;
		level.scene.camera.setFovX(src_Settings.optionsSettings.fovX,src_Settings.optionsSettings.screenWidth / src_Settings.optionsSettings.screenHeight);
		this.lockCursor();
	}
	lockCursor() {
		let jsCanvas = hxd_Window.getInstance().canvas;
		jsCanvas.focus();
		let pointercontainer = window.document.querySelector("#pointercontainer");
		pointercontainer.hidden = true;
		this._ignoreCursor = true;
		let _gthis = this;
		if(!src_Util.isTouchDevice()) {
			hxd_Window.getInstance().lockPointer(function(x,y) {
				_gthis.orbit(x,y);
			});
		}
	}
	unlockCursor() {
		if(!src_Util.isTouchDevice()) {
			hxd_Window.getInstance().unlockPointer();
		}
		hxd_Window.getInstance();
		hxd_Window.getInstance().lockCallback = null;
		let pointercontainer = window.document.querySelector("#pointercontainer");
		pointercontainer.hidden = false;
	}
	orbit(mouseX,mouseY,isTouch) {
		if(isTouch == null) {
			isTouch = false;
		}
		if(this._ignoreCursor) {
			this._ignoreCursor = false;
			return;
		}
		let scaleFactor = 1.0 / hxd_Window.getInstance().get_windowToPixelRatio();
		scaleFactor = 1 / window.devicePixelRatio;
		let deltaposX = mouseX * scaleFactor;
		let deltaposY = mouseY * (src_Settings.controlsSettings.invertYAxis ? -1 : 1) * scaleFactor;
		if(deltaposX != 0 || deltaposY != 0) {
			let absX = Math.abs(deltaposX);
			let absY = Math.abs(deltaposY);
			let len = Math.sqrt(deltaposX * deltaposX + deltaposY * deltaposY);
			let max = Math.max(absX,absY);
			if(max > 0.01) {
				deltaposX *= len / max;
				deltaposY *= len / max;
			}
		}
		let factor = isTouch ? 0.04 + 0.026666666666666665 * src_Settings.controlsSettings.cameraSensitivity : 0.0001 + 0.0099 * src_Settings.controlsSettings.cameraSensitivity;
		if(!src_Settings.controlsSettings.alwaysFreeLook && !hxd_Key.isDown(src_Settings.controlsSettings.freelook) && !isTouch) {
			deltaposY = 0;
		}
		this.nextCameraPitch += deltaposY * factor;
		this.nextCameraYaw += deltaposX * factor;
		if(Math.abs(deltaposX) > 0.001) {
			this.hasXInput = true;
		} else {
			this.hasXInput = false;
		}
		if(Math.abs(deltaposY) > 0.001) {
			this.hasYInput = true;
		} else {
			this.hasYInput = false;
		}
		if(src_MarbleGame.instance.touchInput.cameraInput.pressed) {
			this.hasXInput = true;
			this.hasYInput = true;
		}
		if(!isTouch) {
			this.wasLastGamepadInput = false;
		} else {
			this.wasLastGamepadInput = true;
		}
	}
	rescaleDeadZone(value,deadZone) {
		if(deadZone >= value) {
			if(-deadZone <= value) {
				return 0.0;
			} else {
				return (value + deadZone) / (1.0 - deadZone);
			}
		} else {
			return (value - deadZone) / (1.0 - deadZone);
		}
	}
	computePitchSpeedFromDelta(delta) {
		let min = Math.PI / 10;
		let max = Math.PI / 2;
		return (delta < min ? min : delta > max ? max : delta) * 4;
	}
	applyNonlinearScale(value) {
		return Math.pow(Math.abs(value),3.2) * (value >= 0 ? 1 : -1);
	}
	update(currentTime,dt) {
		let camera = this.level.scene.camera;
		this.dt = dt;
		let lerpt = 1 - Math.pow(0.5,dt / 0.016);
		let gamepadX = this.applyNonlinearScale(this.rescaleDeadZone(src_Gamepad.getAxis(src_Settings.gamepadSettings.cameraXAxis),0.25));
		let gamepadY = this.applyNonlinearScale(this.rescaleDeadZone(src_Gamepad.getAxis(src_Settings.gamepadSettings.cameraYAxis),0.25));
		if(gamepadX != 0.0 || gamepadY != 0.0) {
			this.wasLastGamepadInput = true;
		}
		let cameraPitchDelta = (hxd_Key.isDown(src_Settings.controlsSettings.camBackward) ? 1 : 0) - (hxd_Key.isDown(src_Settings.controlsSettings.camForward) ? 1 : 0) + gamepadY;
		if(src_Settings.gamepadSettings.invertYAxis || src_Settings.controlsSettings.invertYAxis) {
			cameraPitchDelta = -cameraPitchDelta;
		}
		let cameraYawDelta = (hxd_Key.isDown(src_Settings.controlsSettings.camRight) ? 1 : 0) - (hxd_Key.isDown(src_Settings.controlsSettings.camLeft) ? 1 : 0) + gamepadX;
		if(src_Settings.gamepadSettings.invertXAxis) {
			cameraYawDelta = -cameraYawDelta;
		}
		if(src_MarbleGame.instance.paused) {
			cameraYawDelta = 0;
			cameraPitchDelta = 0;
		}
		let deltaX = 3.75 * cameraYawDelta * dt * src_Settings.gamepadSettings.cameraSensitivity;
		let deltaY = 3.75 * cameraPitchDelta * dt * src_Settings.gamepadSettings.cameraSensitivity;
		let deltaNew = deltaX;
		if(src_Settings.controlsSettings.controllerVerticalCenter && !(this.hasXInput || this.hasYInput) && deltaY == 0.0 && this.wasLastGamepadInput) {
			let rescaledY = deltaY;
			if(rescaledY <= 0.0) {
				rescaledY = 0.4 - rescaledY * -0.75;
			} else {
				rescaledY = rescaledY * 1.1 + 0.4;
			}
			let movePitchDelta = rescaledY - this.CameraPitch;
			let movePitchSpeed = this.computePitchSpeedFromDelta(Math.abs(movePitchDelta)) * dt * 0.8;
			if(movePitchDelta <= 0.0) {
				movePitchDelta = -movePitchDelta;
				if(movePitchDelta < movePitchSpeed) {
					movePitchSpeed = movePitchDelta;
				}
				movePitchDelta = -movePitchSpeed;
				movePitchSpeed = movePitchDelta;
			} else if(movePitchSpeed > movePitchDelta) {
				movePitchSpeed = movePitchDelta;
			}
			deltaY = movePitchSpeed;
		}
		if(!src_MarbleGame.instance.touchInput.cameraInput.pressed) {
			this.hasXInput = false;
			this.hasYInput = false;
		}
		this.nextCameraYaw += deltaNew;
		this.nextCameraPitch += deltaY;
		this.nextCameraPitch = Math.max(-Math.PI / 2 + Math.PI / 4,Math.min(Math.PI / 2 - 0.0001,this.nextCameraPitch));
		let a = this.CameraYaw;
		this.CameraYaw = a + (this.nextCameraYaw - a) * lerpt;
		let a1 = this.CameraPitch;
		this.CameraPitch = a1 + (this.nextCameraPitch - a1) * lerpt;
		let value = this.CameraPitch;
		this.CameraPitch = value < -0.35 ? -0.35 : value > 1.5 ? 1.5 : value;
		let orientationQuat = this.level.getOrientationQuat(currentTime);
		let cameraDistance = this.CameraDistance;
		if(this.finish) {
			let effectTime = 1.0;
			if(this.marble.finishAnimTime >= 2.0) {
				effectTime = 1.0;
			} else {
				effectTime = this.marble.finishAnimTime * 0.5;
			}
			effectTime *= 0.5 * this.CameraDistance;
			cameraDistance += effectTime;
		}
		if(!this.level.isWatching) {
			if(this.level.isRecording) {
				this.level.replay.recordCameraState(this.CameraPitch,this.CameraYaw);
			}
		} else {
			this.CameraPitch = this.level.replay.currentPlaybackFrame.cameraPitch;
			this.CameraYaw = this.level.replay.currentPlaybackFrame.cameraYaw;
		}
		let marblePosition;
		if(this.finish) {
			let _this = this.level.marble.collider.transform;
			let v = new h3d_Vector();
			let x = _this._41;
			let y = _this._42;
			let z = _this._43;
			let w = _this._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			v.x = x;
			v.y = y;
			v.z = z;
			v.w = w;
			marblePosition = v;
		} else {
			let _this = this.level.marble.getAbsPos();
			let v = new h3d_Vector();
			let x = _this._41;
			let y = _this._42;
			let z = _this._43;
			let w = _this._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			v.x = x;
			v.y = y;
			v.z = z;
			v.w = w;
			marblePosition = v;
		}
		if(this.finish) {
			if(this.level.endPad != null) {
				let padMat = this.level.endPad.getAbsPos();
				let x = padMat._31;
				let y = padMat._32;
				let z = padMat._33;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let offset_x = x;
				let offset_y = y;
				let offset_z = z;
				let k = offset_x * offset_x + offset_y * offset_y + offset_z * offset_z;
				if(k < 1e-10) {
					k = 0;
				} else {
					k = 1. / Math.sqrt(k);
				}
				offset_x *= k;
				offset_y *= k;
				offset_z *= k;
				let padPos_x = 0.;
				let padPos_y = 0.;
				let padPos_z = 0.;
				let padPos_w = 1.;
				let x1 = padMat._41;
				let y1 = padMat._42;
				let z1 = padMat._43;
				let w = padMat._44;
				if(w == null) {
					w = 1.;
				}
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				padPos_x = x1;
				padPos_y = y1;
				padPos_z = z1;
				padPos_w = w;
				let focusPos = new h3d_Vector(padPos_x + offset_x,padPos_y + offset_y,padPos_z + offset_z,padPos_w + 1.);
				focusPos.x *= 0.025;
				focusPos.y *= 0.025;
				focusPos.z *= 0.025;
				let _this = this.lastTargetPos;
				let x2 = _this.x * 0.975;
				let y2 = _this.y * 0.975;
				let z2 = _this.z * 0.975;
				let w1 = _this.w;
				if(w1 == null) {
					w1 = 1.;
				}
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let v_x = x2;
				let v_y = y2;
				let v_z = z2;
				let v_w = w1;
				focusPos = new h3d_Vector(focusPos.x + v_x,focusPos.y + v_y,focusPos.z + v_z,focusPos.w + v_w);
				marblePosition = focusPos;
			}
		}
		let up = new h3d_Vector(0,0,1);
		let m = null;
		m = new h3d_Matrix();
		let xx = orientationQuat.x * orientationQuat.x;
		let xy = orientationQuat.x * orientationQuat.y;
		let xz = orientationQuat.x * orientationQuat.z;
		let xw = orientationQuat.x * orientationQuat.w;
		let yy = orientationQuat.y * orientationQuat.y;
		let yz = orientationQuat.y * orientationQuat.z;
		let yw = orientationQuat.y * orientationQuat.w;
		let zz = orientationQuat.z * orientationQuat.z;
		let zw = orientationQuat.z * orientationQuat.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		let m1 = m;
		let px = up.x * m1._11 + up.y * m1._21 + up.z * m1._31 + up.w * m1._41;
		let py = up.x * m1._12 + up.y * m1._22 + up.z * m1._32 + up.w * m1._42;
		let pz = up.x * m1._13 + up.y * m1._23 + up.z * m1._33 + up.w * m1._43;
		let pw = up.x * m1._14 + up.y * m1._24 + up.z * m1._34 + up.w * m1._44;
		up.x = px;
		up.y = py;
		up.z = pz;
		up.w = pw;
		let directionVector_x = 1;
		let directionVector_y = 0;
		let directionVector_z = 0;
		let directionVector_w = 1.;
		let cameraVerticalTranslation = new h3d_Vector(0,0,0.55);
		let q1_x = 0.;
		let q1_y = 0.;
		let q1_z = 0.;
		let q1_w = 1.;
		let a2 = this.CameraPitch;
		let sin = Math.sin(a2 / 2);
		let cos = Math.cos(a2 / 2);
		q1_x = 0 * sin;
		q1_y = sin;
		q1_z = 0 * sin;
		q1_w = cos * Math.sqrt(1);
		let len = q1_x * q1_x + sin * sin + q1_z * q1_z + q1_w * q1_w;
		if(len < 1e-10) {
			q1_z = 0;
			q1_y = q1_z;
			q1_x = q1_y;
			q1_w = 1;
		} else {
			let m = 1. / Math.sqrt(len);
			q1_x *= m;
			q1_y = sin * m;
			q1_z *= m;
			q1_w *= m;
		}
		let m2 = null;
		m2 = new h3d_Matrix();
		let xx1 = q1_x * q1_x;
		let xy1 = q1_x * q1_y;
		let xz1 = q1_x * q1_z;
		let xw1 = q1_x * q1_w;
		let yy1 = q1_y * q1_y;
		let yz1 = q1_y * q1_z;
		let yw1 = q1_y * q1_w;
		let zz1 = q1_z * q1_z;
		let zw1 = q1_z * q1_w;
		m2._11 = 1 - 2 * (yy1 + zz1);
		m2._12 = 2 * (xy1 + zw1);
		m2._13 = 2 * (xz1 - yw1);
		m2._14 = 0;
		m2._21 = 2 * (xy1 - zw1);
		m2._22 = 1 - 2 * (xx1 + zz1);
		m2._23 = 2 * (yz1 + xw1);
		m2._24 = 0;
		m2._31 = 2 * (xz1 + yw1);
		m2._32 = 2 * (yz1 - xw1);
		m2._33 = 1 - 2 * (xx1 + yy1);
		m2._34 = 0;
		m2._41 = 0;
		m2._42 = 0;
		m2._43 = 0;
		m2._44 = 1;
		let m3 = m2;
		let px1 = directionVector_x * m3._11 + directionVector_y * m3._21 + directionVector_z * m3._31 + m3._41;
		let py1 = directionVector_x * m3._12 + directionVector_y * m3._22 + directionVector_z * m3._32 + m3._42;
		let pz1 = directionVector_x * m3._13 + directionVector_y * m3._23 + directionVector_z * m3._33 + m3._43;
		let pw1 = directionVector_x * m3._14 + directionVector_y * m3._24 + directionVector_z * m3._34 + m3._44;
		directionVector_x = px1;
		directionVector_y = py1;
		directionVector_z = pz1;
		directionVector_w = pw1;
		let a3 = this.CameraYaw;
		let sin1 = Math.sin(a3 / 2);
		let cos1 = Math.cos(a3 / 2);
		q1_x = 0 * sin1;
		q1_y = 0 * sin1;
		q1_z = sin1;
		q1_w = cos1 * Math.sqrt(1);
		let len1 = q1_x * q1_x + q1_y * q1_y + sin1 * sin1 + q1_w * q1_w;
		if(len1 < 1e-10) {
			q1_z = 0;
			q1_y = q1_z;
			q1_x = q1_y;
			q1_w = 1;
		} else {
			let m = 1. / Math.sqrt(len1);
			q1_x *= m;
			q1_y *= m;
			q1_z = sin1 * m;
			q1_w *= m;
		}
		let m4 = null;
		m4 = new h3d_Matrix();
		let xx2 = q1_x * q1_x;
		let xy2 = q1_x * q1_y;
		let xz2 = q1_x * q1_z;
		let xw2 = q1_x * q1_w;
		let yy2 = q1_y * q1_y;
		let yz2 = q1_y * q1_z;
		let yw2 = q1_y * q1_w;
		let zz2 = q1_z * q1_z;
		let zw2 = q1_z * q1_w;
		m4._11 = 1 - 2 * (yy2 + zz2);
		m4._12 = 2 * (xy2 + zw2);
		m4._13 = 2 * (xz2 - yw2);
		m4._14 = 0;
		m4._21 = 2 * (xy2 - zw2);
		m4._22 = 1 - 2 * (xx2 + zz2);
		m4._23 = 2 * (yz2 + xw2);
		m4._24 = 0;
		m4._31 = 2 * (xz2 + yw2);
		m4._32 = 2 * (yz2 - xw2);
		m4._33 = 1 - 2 * (xx2 + yy2);
		m4._34 = 0;
		m4._41 = 0;
		m4._42 = 0;
		m4._43 = 0;
		m4._44 = 1;
		let m5 = m4;
		let px2 = directionVector_x * m5._11 + directionVector_y * m5._21 + directionVector_z * m5._31 + directionVector_w * m5._41;
		let py2 = directionVector_x * m5._12 + directionVector_y * m5._22 + directionVector_z * m5._32 + directionVector_w * m5._42;
		let pz2 = directionVector_x * m5._13 + directionVector_y * m5._23 + directionVector_z * m5._33 + directionVector_w * m5._43;
		let pw2 = directionVector_x * m5._14 + directionVector_y * m5._24 + directionVector_z * m5._34 + directionVector_w * m5._44;
		directionVector_x = px2;
		directionVector_y = py2;
		directionVector_z = pz2;
		directionVector_w = pw2;
		let m6 = null;
		m6 = new h3d_Matrix();
		let xx3 = orientationQuat.x * orientationQuat.x;
		let xy3 = orientationQuat.x * orientationQuat.y;
		let xz3 = orientationQuat.x * orientationQuat.z;
		let xw3 = orientationQuat.x * orientationQuat.w;
		let yy3 = orientationQuat.y * orientationQuat.y;
		let yz3 = orientationQuat.y * orientationQuat.z;
		let yw3 = orientationQuat.y * orientationQuat.w;
		let zz3 = orientationQuat.z * orientationQuat.z;
		let zw3 = orientationQuat.z * orientationQuat.w;
		m6._11 = 1 - 2 * (yy3 + zz3);
		m6._12 = 2 * (xy3 + zw3);
		m6._13 = 2 * (xz3 - yw3);
		m6._14 = 0;
		m6._21 = 2 * (xy3 - zw3);
		m6._22 = 1 - 2 * (xx3 + zz3);
		m6._23 = 2 * (yz3 + xw3);
		m6._24 = 0;
		m6._31 = 2 * (xz3 + yw3);
		m6._32 = 2 * (yz3 - xw3);
		m6._33 = 1 - 2 * (xx3 + yy3);
		m6._34 = 0;
		m6._41 = 0;
		m6._42 = 0;
		m6._43 = 0;
		m6._44 = 1;
		let m7 = m6;
		let px3 = directionVector_x * m7._11 + directionVector_y * m7._21 + directionVector_z * m7._31 + directionVector_w * m7._41;
		let py3 = directionVector_x * m7._12 + directionVector_y * m7._22 + directionVector_z * m7._32 + directionVector_w * m7._42;
		let pz3 = directionVector_x * m7._13 + directionVector_y * m7._23 + directionVector_z * m7._33 + directionVector_w * m7._43;
		let pw3 = directionVector_x * m7._14 + directionVector_y * m7._24 + directionVector_z * m7._34 + directionVector_w * m7._44;
		directionVector_x = px3;
		directionVector_y = py3;
		directionVector_z = pz3;
		directionVector_w = pw3;
		let m8 = null;
		m8 = new h3d_Matrix();
		let xx4 = orientationQuat.x * orientationQuat.x;
		let xy4 = orientationQuat.x * orientationQuat.y;
		let xz4 = orientationQuat.x * orientationQuat.z;
		let xw4 = orientationQuat.x * orientationQuat.w;
		let yy4 = orientationQuat.y * orientationQuat.y;
		let yz4 = orientationQuat.y * orientationQuat.z;
		let yw4 = orientationQuat.y * orientationQuat.w;
		let zz4 = orientationQuat.z * orientationQuat.z;
		let zw4 = orientationQuat.z * orientationQuat.w;
		m8._11 = 1 - 2 * (yy4 + zz4);
		m8._12 = 2 * (xy4 + zw4);
		m8._13 = 2 * (xz4 - yw4);
		m8._14 = 0;
		m8._21 = 2 * (xy4 - zw4);
		m8._22 = 1 - 2 * (xx4 + zz4);
		m8._23 = 2 * (yz4 + xw4);
		m8._24 = 0;
		m8._31 = 2 * (xz4 + yw4);
		m8._32 = 2 * (yz4 - xw4);
		m8._33 = 1 - 2 * (xx4 + yy4);
		m8._34 = 0;
		m8._41 = 0;
		m8._42 = 0;
		m8._43 = 0;
		m8._44 = 1;
		let m9 = m8;
		let px4 = cameraVerticalTranslation.x * m9._11 + cameraVerticalTranslation.y * m9._21 + cameraVerticalTranslation.z * m9._31 + cameraVerticalTranslation.w * m9._41;
		let py4 = cameraVerticalTranslation.x * m9._12 + cameraVerticalTranslation.y * m9._22 + cameraVerticalTranslation.z * m9._32 + cameraVerticalTranslation.w * m9._42;
		let pz4 = cameraVerticalTranslation.x * m9._13 + cameraVerticalTranslation.y * m9._23 + cameraVerticalTranslation.z * m9._33 + cameraVerticalTranslation.w * m9._43;
		let pw4 = cameraVerticalTranslation.x * m9._14 + cameraVerticalTranslation.y * m9._24 + cameraVerticalTranslation.z * m9._34 + cameraVerticalTranslation.w * m9._44;
		cameraVerticalTranslation.x = px4;
		cameraVerticalTranslation.y = py4;
		cameraVerticalTranslation.z = pz4;
		cameraVerticalTranslation.w = pw4;
		camera.up = up;
		let x = directionVector_x * cameraDistance;
		let y = directionVector_y * cameraDistance;
		let z = directionVector_z * cameraDistance;
		let w = directionVector_w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let v_x = x;
		let v_y = y;
		let v_z = z;
		let v_w = w;
		let x1 = marblePosition.x - v_x;
		let y1 = marblePosition.y - v_y;
		let z1 = marblePosition.z - v_z;
		let w1 = marblePosition.w - v_w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let _this_x = x1;
		let _this_y = y1;
		let _this_z = z1;
		let _this_w = w1;
		camera.pos = new h3d_Vector(_this_x + cameraVerticalTranslation.x,_this_y + cameraVerticalTranslation.y,_this_z + cameraVerticalTranslation.z,_this_w + cameraVerticalTranslation.w);
		camera.target = new h3d_Vector(marblePosition.x + cameraVerticalTranslation.x,marblePosition.y + cameraVerticalTranslation.y,marblePosition.z + cameraVerticalTranslation.z,marblePosition.w + cameraVerticalTranslation.w);
		let _this = this.level.marble.currentUp;
		let v = this.marble._radius;
		let x2 = _this.x * v;
		let y2 = _this.y * v;
		let z2 = _this.z * v;
		let w2 = _this.w;
		if(w2 == null) {
			w2 = 1.;
		}
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let v_x1 = x2;
		let v_y1 = y2;
		let v_z1 = z2;
		let v_w1 = w2;
		let x3 = marblePosition.x + v_x1;
		let y3 = marblePosition.y + v_y1;
		let z3 = marblePosition.z + v_z1;
		let w3 = marblePosition.w + v_w1;
		if(w3 == null) {
			w3 = 1.;
		}
		if(z3 == null) {
			z3 = 0.;
		}
		if(y3 == null) {
			y3 = 0.;
		}
		if(x3 == null) {
			x3 = 0.;
		}
		let _this_x1 = x3;
		let _this_y1 = y3;
		let _this_z1 = z3;
		let _this_w1 = w3;
		let rayCastOrigin = new h3d_Vector(_this_x1 + cameraVerticalTranslation.x,_this_y1 + cameraVerticalTranslation.y,_this_z1 + cameraVerticalTranslation.z,_this_w1 + cameraVerticalTranslation.w);
		let _g = 0;
		let _g1 = this.level.pathedInteriors;
		while(_g < _g1.length) {
			let pi = _g1[_g];
			++_g;
			pi.pushTickState();
		}
		let processedShapes = [];
		let _g2 = 0;
		while(_g2 < 3) {
			++_g2;
			let _this = camera.pos;
			let rayCastDirection = new h3d_Vector(_this.x - rayCastOrigin.x,_this.y - rayCastOrigin.y,_this.z - rayCastOrigin.z,_this.w - rayCastOrigin.w);
			let k = rayCastDirection.x * rayCastDirection.x + rayCastDirection.y * rayCastDirection.y + rayCastDirection.z * rayCastDirection.z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			let x = rayCastDirection.x * k;
			let y = rayCastDirection.y * k;
			let z = rayCastDirection.z * k;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let _this_x = x;
			let _this_y = y;
			let _this_z = z;
			let x1 = _this_x * 2;
			let y1 = _this_y * 2;
			let z1 = _this_z * 2;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let v_x = x1;
			let v_y = y1;
			let v_z = z1;
			rayCastDirection = new h3d_Vector(rayCastDirection.x + v_x,rayCastDirection.y + v_y,rayCastDirection.z + v_z,rayCastDirection.w + 1.);
			let rayCastLen = Math.sqrt(rayCastDirection.x * rayCastDirection.x + rayCastDirection.y * rayCastDirection.y + rayCastDirection.z * rayCastDirection.z);
			let k1 = rayCastDirection.x * rayCastDirection.x + rayCastDirection.y * rayCastDirection.y + rayCastDirection.z * rayCastDirection.z;
			if(k1 < 1e-10) {
				k1 = 0;
			} else {
				k1 = 1. / Math.sqrt(k1);
			}
			let results = this.level.collisionWorld.rayCast(rayCastOrigin,new h3d_Vector(rayCastDirection.x * k1,rayCastDirection.y * k1,rayCastDirection.z * k1),rayCastLen);
			let firstHit = null;
			let firstHitDistance = 1e8;
			let _g = 0;
			while(_g < results.length) {
				let result = results[_g];
				++_g;
				let tmp;
				if(!processedShapes.includes(result.object)) {
					if(firstHit != null) {
						let v = result.point;
						let dx = v.x - rayCastOrigin.x;
						let dy = v.y - rayCastOrigin.y;
						let dz = v.z - rayCastOrigin.z;
						tmp = Math.sqrt(dx * dx + dy * dy + dz * dz) < firstHitDistance;
					} else {
						tmp = true;
					}
				} else {
					tmp = false;
				}
				if(tmp) {
					firstHit = result;
					let v = result.point;
					let dx = v.x - rayCastOrigin.x;
					let dy = v.y - rayCastOrigin.y;
					let dz = v.z - rayCastOrigin.z;
					firstHitDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
					processedShapes.push(result.object);
				}
			}
			if(firstHit != null) {
				if(firstHitDistance < cameraDistance) {
					let nx = firstHit.normal.x;
					let ny = firstHit.normal.y;
					let nz = firstHit.normal.z;
					let _this = firstHit.point;
					let v = firstHit.normal;
					let d = _this.x * v.x + _this.y * v.y + _this.z * v.z;
					let _this1 = firstHit.normal;
					let x = _this1.x * -1;
					let y = _this1.y * -1;
					let z = _this1.z * -1;
					let w = _this1.w;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let normal_x = x;
					let normal_y = y;
					let normal_z = z;
					let normal_w = w;
					let _this2 = camera.pos;
					let x1 = _this2.x;
					let y1 = _this2.y;
					let z1 = _this2.z;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let p_x = x1;
					let p_y = y1;
					let p_z = z1;
					let d1 = nx * p_x + ny * p_y + nz * p_z - d;
					let x2 = p_x - d1 * nx;
					let y2 = p_y - d1 * ny;
					let z2 = p_z - d1 * nz;
					if(z2 == null) {
						z2 = 0.;
					}
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					let projected_x = x2;
					let projected_y = y2;
					let projected_z = z2;
					let _this3 = camera.pos;
					let x3 = _this3.x;
					let y3 = _this3.y;
					let z3 = _this3.z;
					if(z3 == null) {
						z3 = 0.;
					}
					if(y3 == null) {
						y3 = 0.;
					}
					if(x3 == null) {
						x3 = 0.;
					}
					let p_x1 = x3;
					let p_y1 = y3;
					let p_z1 = z3;
					let dist = nx * p_x1 + ny * p_y1 + nz * p_z1 - d;
					if(dist >= 0.1) {
						break;
					}
					let x4 = projected_x;
					let y4 = projected_y;
					let z4 = projected_z;
					if(projected_z == null) {
						z4 = 0.;
					}
					if(projected_y == null) {
						y4 = 0.;
					}
					if(projected_x == null) {
						x4 = 0.;
					}
					let _this_x = x4;
					let _this_y = y4;
					let _this_z = z4;
					let x5 = normal_x * -0.1;
					let y5 = normal_y * -0.1;
					let z5 = normal_z * -0.1;
					let w1 = normal_w;
					if(normal_w == null) {
						w1 = 1.;
					}
					if(z5 == null) {
						z5 = 0.;
					}
					if(y5 == null) {
						y5 = 0.;
					}
					if(x5 == null) {
						x5 = 0.;
					}
					let v_x = x5;
					let v_y = y5;
					let v_z = z5;
					let v_w = w1;
					camera.pos = new h3d_Vector(_this_x + v_x,_this_y + v_y,_this_z + v_z,1. + v_w);
					let v1 = camera.pos;
					let x6 = marblePosition.x - v1.x;
					let y6 = marblePosition.y - v1.y;
					let z6 = marblePosition.z - v1.z;
					if(z6 == null) {
						z6 = 0.;
					}
					if(y6 == null) {
						y6 = 0.;
					}
					if(x6 == null) {
						x6 = 0.;
					}
					let _this_x1 = x6;
					let _this_y1 = y6;
					let _this_z1 = z6;
					let k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
					if(k < 1e-10) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					let x7 = _this_x1 * k;
					let y7 = _this_y1 * k;
					let z7 = _this_z1 * k;
					if(z7 == null) {
						z7 = 0.;
					}
					if(y7 == null) {
						y7 = 0.;
					}
					if(x7 == null) {
						x7 = 0.;
					}
					let forwardVec_x = x7;
					let forwardVec_y = y7;
					let forwardVec_z = z7;
					let _this4 = camera.up;
					let x8 = _this4.y * forwardVec_z - _this4.z * forwardVec_y;
					let y8 = _this4.z * forwardVec_x - _this4.x * forwardVec_z;
					let z8 = _this4.x * forwardVec_y - _this4.y * forwardVec_x;
					if(z8 == null) {
						z8 = 0.;
					}
					if(y8 == null) {
						y8 = 0.;
					}
					if(x8 == null) {
						x8 = 0.;
					}
					let _this_x2 = x8;
					let _this_y2 = y8;
					let _this_z2 = z8;
					let k1 = _this_x2 * _this_x2 + _this_y2 * _this_y2 + _this_z2 * _this_z2;
					if(k1 < 1e-10) {
						k1 = 0;
					} else {
						k1 = 1. / Math.sqrt(k1);
					}
					let x9 = _this_x2 * k1;
					let y9 = _this_y2 * k1;
					let z9 = _this_z2 * k1;
					if(z9 == null) {
						z9 = 0.;
					}
					if(y9 == null) {
						y9 = 0.;
					}
					if(x9 == null) {
						x9 = 0.;
					}
					camera.target = new h3d_Vector(marblePosition.x + cameraVerticalTranslation.x,marblePosition.y + cameraVerticalTranslation.y,marblePosition.z + cameraVerticalTranslation.z,marblePosition.w + cameraVerticalTranslation.w);
					continue;
				}
			}
			break;
		}
		let _g3 = 0;
		let _g4 = this.level.pathedInteriors;
		while(_g3 < _g4.length) {
			let pi = _g4[_g3];
			++_g3;
			pi.popTickState();
		}
		if(this.oob) {
			camera.pos = this.lastCamPos;
			let v = this.lastVertTranslation;
			camera.target = new h3d_Vector(marblePosition.x + v.x,marblePosition.y + v.y,marblePosition.z + v.z,marblePosition.w + v.w);
		}
		if(!this.oob) {
			this.lastCamPos = camera.pos;
			this.lastVertTranslation = cameraVerticalTranslation;
			this.lastTargetPos = new h3d_Vector(marblePosition.x,marblePosition.y,marblePosition.z,marblePosition.w);
		}
		let x4 = camera.pos.x;
		let y4 = camera.pos.y;
		let z4 = camera.pos.z;
		this.x = x4;
		this.flags |= 1;
		this.y = y4;
		this.flags |= 1;
		this.z = z4;
		this.flags |= 1;
		this.flags |= 1;
	}
}
$hxClasses["src.CameraController"] = src_CameraController;
src_CameraController.__name__ = "src.CameraController";
src_CameraController.__super__ = h3d_scene_Object;
Object.assign(src_CameraController.prototype, {
	__class__: src_CameraController
	,marble: null
	,level: null
	,CameraDistance: null
	,CameraPitch: null
	,CameraYaw: null
	,nextCameraYaw: null
	,nextCameraPitch: null
	,lastTargetPos: null
	,lastCamPos: null
	,lastVertTranslation: null
	,oob: null
	,finish: null
	,_ignoreCursor: null
	,hasXInput: null
	,hasYInput: null
	,dt: null
	,wasLastGamepadInput: null
});
class src_ConsoleEntry {
	constructor(time,type,text) {
		this.time = time;
		this.type = type;
		this.text = text;
	}
}
$hxClasses["src.ConsoleEntry"] = src_ConsoleEntry;
src_ConsoleEntry.__name__ = "src.ConsoleEntry";
Object.assign(src_ConsoleEntry.prototype, {
	__class__: src_ConsoleEntry
	,time: null
	,type: null
	,text: null
});
class src_Console {
	constructor() {
		if(src_Console.instance == null) {
			src_Console.instance = this;
		}
		this.entries = [];
		this.consumers = [];
		this.timeSinceStart = HxOverrides.now() / 1000;
	}
	addEntry(type,msg) {
		let e = new src_ConsoleEntry(((HxOverrides.now() / 1000 - this.timeSinceStart) * 1000 | 0) / 1000,type,msg);
		this.entries.push(e);
		let _g = 0;
		let _g1 = this.consumers;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			c(e);
		}
	}
	static eval(cmd) {
		let cmdSplit = cmd.split(" ");
		if(cmdSplit.length != 0) {
			let cmdType = cmdSplit[0];
			if(cmdType == "help") {
				src_Console.instance.addEntry("log","Available commands:");
				src_Console.instance.addEntry("log","help");
				src_Console.instance.addEntry("log","timeScale <scale>");
				src_Console.instance.addEntry("log","rewindTimeScale <scale>");
				src_Console.instance.addEntry("log","drawBounds <true/false>");
				src_Console.instance.addEntry("log","wireframe <true/false>");
				src_Console.instance.addEntry("log","fps <true/false>");
			} else if(cmdType == "timeScale") {
				if(cmdSplit.length == 2) {
					let scale = parseFloat(cmdSplit[1]);
					if(isNaN(scale)) {
						scale = 1;
					}
					src_Debug.timeScale = scale;
					src_Console.instance.addEntry("log","Time scale set to " + scale);
				} else {
					src_Console.instance.addEntry("error","Expected one argument, got " + (cmdSplit.length - 1));
				}
			} else if(cmdType == "drawBounds") {
				if(cmdSplit.length == 2) {
					let scale = mis_MisParser.parseBoolean(cmdSplit[1]);
					src_Debug.drawBounds = scale;
					src_Console.instance.addEntry("log","Debug.drawBounds set to " + (scale == null ? "null" : "" + scale));
				} else {
					src_Console.instance.addEntry("error","Expected one argument, got " + (cmdSplit.length - 1));
				}
			} else if(cmdType == "wireframe") {
				if(cmdSplit.length == 2) {
					let scale = mis_MisParser.parseBoolean(cmdSplit[1]);
					src_Debug.wireFrame = scale;
					src_Console.instance.addEntry("log","Debug.wireframe set to " + (scale == null ? "null" : "" + scale));
				} else {
					src_Console.instance.addEntry("error","Expected one argument, got " + (cmdSplit.length - 1));
				}
			} else if(cmdType == "rewindTimeScale") {
				if(cmdSplit.length == 2) {
					let scale = parseFloat(cmdSplit[1]);
					if(isNaN(scale)) {
						scale = 1;
					}
					if(scale <= 0) {
						scale = 1;
					}
					if(src_MarbleGame.instance.world != null) {
						src_MarbleGame.instance.world.rewindManager.timeScale = scale;
						src_Console.instance.addEntry("log","Rewind Time scale set to " + scale);
					}
				} else {
					src_Console.instance.addEntry("error","Expected one argument, got " + (cmdSplit.length - 1));
				}
			} else if(cmdType == "fps") {
				if(cmdSplit.length == 2) {
					let scale = mis_MisParser.parseBoolean(cmdSplit[1]);
					src_ProfilerUI.setEnabled(scale);
					src_Console.instance.addEntry("log","FPS Display set to " + (scale == null ? "null" : "" + scale));
				} else {
					src_Console.instance.addEntry("error","Expected one argument, got " + (cmdSplit.length - 1));
				}
			} else if(cmdType != "dumpMem") {
				if(cmdType != "gcStats") {
					if(cmdType == "rollback") {
						let t = parseFloat(cmdSplit[1]);
						src_MarbleGame.instance.world.rollback(t);
					} else if(cmdType == "addDummy") {
						net_Net.addDummyConnection();
					} else if(cmdType == "setfps") {
						let scale = parseFloat(cmdSplit[1]);
						if(isNaN(scale)) {
							scale = 1;
						}
						src_MarbleGame.instance.fpsLimit = scale;
						src_MarbleGame.instance.limitingFps = true;
						src_Console.instance.addEntry("log","Set FPS to " + scale);
					} else if(cmdType != "reload") {
						if(cmdType == "profile") {
							if(cmdSplit.length == 2) {
								let scale = Std.parseInt(cmdSplit[1]);
								src_ProfilerUI.setDisplayMode(scale);
								src_Console.instance.addEntry("log","FPS Display set to " + scale);
							} else {
								src_Console.instance.addEntry("error","Expected one argument, got " + (cmdSplit.length - 1));
							}
						} else {
							src_Console.instance.addEntry("error","Unknown command");
						}
					}
				}
			}
			return;
		}
		src_Console.instance.addEntry("error","Unknown command");
	}
}
$hxClasses["src.Console"] = src_Console;
src_Console.__name__ = "src.Console";
Object.assign(src_Console.prototype, {
	__class__: src_Console
	,entries: null
	,consumers: null
	,timeSinceStart: null
});
class src_Debug {
	static update(dt) {
		if(src_Debug._triangles.length != 0 && src_Debug.drawBounds) {
			let prim = new h3d_prim_Polygon(src_Debug._triangles.slice());
			if(src_Debug.debugTriangles != null) {
				let _this = src_Debug.debugTriangles;
				if(_this != null && _this.parent != null) {
					_this.parent.removeChild(_this);
				}
			}
			src_Debug.debugTriangles = new h3d_scene_Mesh(prim,h3d_mat_Material.create());
			prim.addUVs();
			prim.addNormals();
			src_MarbleGame.instance.scene.addChild(src_Debug.debugTriangles);
			src_Debug._triangles = [];
		} else if(src_Debug.debugTriangles != null) {
			let _this = src_Debug.debugTriangles;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			src_Debug.debugTriangles = null;
		}
		if(src_Debug._spheres.length != 0 && src_Debug.drawBounds) {
			if(src_Debug.debugSphere == null) {
				let sphprim = new h3d_prim_Sphere();
				sphprim.addUVs();
				sphprim.addNormals();
				src_Debug.debugSphere = new src_MeshBatch(sphprim,h3d_mat_Material.create());
				src_Debug.debugSphere.material.set_castShadows(false);
				src_Debug.debugSphere.material.set_receiveShadows(false);
				src_MarbleGame.instance.scene.addChild(src_Debug.debugSphere);
			}
			src_Debug.debugSphere.begin(src_Debug._spheres.length);
			let toremove = [];
			let _g = 0;
			let _g1 = src_Debug._spheres;
			while(_g < _g1.length) {
				let sph = _g1[_g];
				++_g;
				let _this = src_Debug.debugSphere;
				let x = sph.position.x;
				let y = sph.position.y;
				let z = sph.position.z;
				_this.x = x;
				_this.flags |= 1;
				_this.y = y;
				_this.flags |= 1;
				_this.z = z;
				_this.flags |= 1;
				_this.flags |= 1;
				let _this1 = src_Debug.debugSphere;
				let v = sph.radius;
				_this1.scaleX = v;
				_this1.flags |= 1;
				_this1.scaleY = v;
				_this1.flags |= 1;
				_this1.scaleZ = v;
				_this1.flags |= 1;
				_this1.flags |= 1;
				src_Debug.debugSphere.emitInstance();
				sph.lifetime -= dt;
				if(sph.lifetime < 0) {
					toremove.push(sph);
				}
			}
			let _g2 = 0;
			while(_g2 < toremove.length) {
				let sph = toremove[_g2];
				++_g2;
				HxOverrides.remove(src_Debug._spheres,sph);
			}
		} else if(src_Debug.debugSphere != null) {
			let _this = src_Debug.debugSphere;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			src_Debug.debugSphere = null;
		}
	}
}
$hxClasses["src.Debug"] = src_Debug;
src_Debug.__name__ = "src.Debug";
class src_DifBuilderTriangle {
	constructor() {
	}
}
$hxClasses["src.DifBuilderTriangle"] = src_DifBuilderTriangle;
src_DifBuilderTriangle.__name__ = "src.DifBuilderTriangle";
Object.assign(src_DifBuilderTriangle.prototype, {
	__class__: src_DifBuilderTriangle
	,texture: null
	,normal1: null
	,normal2: null
	,normal3: null
	,p1: null
	,p2: null
	,p3: null
	,uv1: null
	,uv2: null
	,uv3: null
	,t1: null
	,t2: null
	,t3: null
	,b1: null
	,b2: null
	,b3: null
	,n1: null
	,n2: null
	,n3: null
});
class src_TriangleEdge {
	constructor(i1,i2,farPoint,surfaceIndex) {
		if(i2 < i1) {
			this.index1 = i2;
			this.index2 = i1;
		} else {
			this.index1 = i1;
			this.index2 = i2;
		}
		this.farPoint = farPoint;
		this.surfaceIndex = surfaceIndex;
	}
}
$hxClasses["src.TriangleEdge"] = src_TriangleEdge;
src_TriangleEdge.__name__ = "src.TriangleEdge";
Object.assign(src_TriangleEdge.prototype, {
	__class__: src_TriangleEdge
	,index1: null
	,index2: null
	,farPoint: null
	,surfaceIndex: null
});
class src_DifCache {
	constructor() {
	}
}
$hxClasses["src.DifCache"] = src_DifCache;
src_DifCache.__name__ = "src.DifCache";
Object.assign(src_DifCache.prototype, {
	__class__: src_DifCache
	,dif: null
	,difTriangles: null
	,prims: null
});
class src_LRUCache_$src_$DifCache {
	constructor(size) {
		this.curSize = 0;
		this.size = 10;
		this.cacheMap = new haxe_ds_StringMap();
		this.size = size;
	}
	tick() {
		let _g = this.cacheMap.keyValueIterator();
		while(_g.hasNext()) {
			let v = _g.next().value;
			v.age >>= 1;
		}
	}
	get(k) {
		let cv = this.cacheMap.get(k);
		if(cv != null) {
			return cv.value;
		} else {
			return null;
		}
	}
	exists(k) {
		return this.cacheMap.exists(k);
	}
	set(k,v) {
		let cv = this.cacheMap.get(k);
		if(cv != null) {
			cv.value = v;
			cv.age = 65535;
		} else {
			cv = new src_LRUCacheValue_$src_$DifCache();
			cv.value = v;
			cv.age = 65535;
			this.cacheMap.set(k,cv);
			this.curSize += 1;
		}
		this.tick();
		if(this.curSize > this.size) {
			let minAge = 65535;
			let minAgeKey = null;
			let _g = this.cacheMap.keyValueIterator();
			while(_g.hasNext()) {
				let _g1 = _g.next();
				let k = _g1.key;
				let v = _g1.value;
				if(v.age < minAge) {
					minAge = v.age;
					minAgeKey = k;
				}
			}
			if(minAgeKey != null) {
				this.cacheMap.remove(minAgeKey);
				this.curSize -= 1;
			}
		}
	}
}
$hxClasses["src.LRUCache_src_DifCache"] = src_LRUCache_$src_$DifCache;
src_LRUCache_$src_$DifCache.__name__ = "src.LRUCache_src_DifCache";
Object.assign(src_LRUCache_$src_$DifCache.prototype, {
	__class__: src_LRUCache_$src_$DifCache
	,cacheMap: null
	,size: null
	,curSize: null
});
class src_ResourceLoader {
	static init(scene2d,onLoadedFunc) {
		src_Console.instance.addEntry("log","Initializing filesystem");
		hxd_res_Resource.LIVE_UPDATE = false;
		hxd_res_Image.ENABLE_AUTO_WATCH = false;
		hxd_res_Sound.ENABLE_AUTO_WATCH = false;
		haxe_MainLoop.add(function() {
		});
		let mfileSystem = new fs_ManifestFileSystem("data",haxe_io_Bytes.ofString("[{\"original\":\"manifest.json\",\"path\":\"manifest.json\"},{\"original\":\"icon.png\",\"path\":\"icon.png\"},{\"original\":\"filesystem.manifest\",\"path\":\"filesystem.manifest\"},{\"original\":\"englishStrings.inf\",\"path\":\"englishstrings.inf\"},{\"original\":\"ui/logo.png\",\"path\":\"ui/logo.png\"},{\"original\":\"ui/kofi1_n.png\",\"path\":\"ui/kofi1_n.png\"},{\"original\":\"ui/kofi1_i.png\",\"path\":\"ui/kofi1_i.png\"},{\"original\":\"ui/kofi1_h.png\",\"path\":\"ui/kofi1_h.png\"},{\"original\":\"ui/kofi1_d.png\",\"path\":\"ui/kofi1_d.png\"},{\"original\":\"ui/github_n.png\",\"path\":\"ui/github_n.png\"},{\"original\":\"ui/github_i.png\",\"path\":\"ui/github_i.png\"},{\"original\":\"ui/github_h.png\",\"path\":\"ui/github_h.png\"},{\"original\":\"ui/github_d.png\",\"path\":\"ui/github_d.png\"},{\"original\":\"ui/g.png\",\"path\":\"ui/g.png\"},{\"original\":\"ui/PoweredBy.png\",\"path\":\"ui/poweredby.png\"},{\"original\":\"ui/GG_Logo.png\",\"path\":\"ui/gg_logo.png\"},{\"original\":\"ui/EngineSplashBG.jpg\",\"path\":\"ui/enginesplashbg.jpg\"},{\"original\":\"ui/EngineSplash.png\",\"path\":\"ui/enginesplash.png\"},{\"original\":\"ui/xbox/xbox_controller.png\",\"path\":\"ui/xbox/xbox_controller.png\"},{\"original\":\"ui/xbox/void.png\",\"path\":\"ui/xbox/void.png\"},{\"original\":\"ui/xbox/voiceIconSpeak.png\",\"path\":\"ui/xbox/voiceiconspeak.png\"},{\"original\":\"ui/xbox/voiceIconPity.png\",\"path\":\"ui/xbox/voiceiconpity.png\"},{\"original\":\"ui/xbox/voiceIconOff.png\",\"path\":\"ui/xbox/voiceiconoff.png\"},{\"original\":\"ui/xbox/voiceIcon.png\",\"path\":\"ui/xbox/voiceicon.png\"},{\"original\":\"ui/xbox/upsell.png\",\"path\":\"ui/xbox/upsell.png\"},{\"original\":\"ui/xbox/upArrow.png\",\"path\":\"ui/xbox/uparrow.png\"},{\"original\":\"ui/xbox/textAlternatingBitmap.png\",\"path\":\"ui/xbox/textalternatingbitmap.png\"},{\"original\":\"ui/xbox/statIcon.png\",\"path\":\"ui/xbox/staticon.png\"},{\"original\":\"ui/xbox/roundedBG.png\",\"path\":\"ui/xbox/roundedbg.png\"},{\"original\":\"ui/xbox/rewind_ico.png\",\"path\":\"ui/xbox/rewind_ico.png\"},{\"original\":\"ui/xbox/popupGUI.png\",\"path\":\"ui/xbox/popupgui.png\"},{\"original\":\"ui/xbox/platform_web_white.png\",\"path\":\"ui/xbox/platform_web_white.png\"},{\"original\":\"ui/xbox/platform_web.png\",\"path\":\"ui/xbox/platform_web.png\"},{\"original\":\"ui/xbox/platform_unknown_white.png\",\"path\":\"ui/xbox/platform_unknown_white.png\"},{\"original\":\"ui/xbox/platform_unknown.png\",\"path\":\"ui/xbox/platform_unknown.png\"},{\"original\":\"ui/xbox/platform_mac_white.png\",\"path\":\"ui/xbox/platform_mac_white.png\"},{\"original\":\"ui/xbox/platform_mac.png\",\"path\":\"ui/xbox/platform_mac.png\"},{\"original\":\"ui/xbox/platform_desktop_white.png\",\"path\":\"ui/xbox/platform_desktop_white.png\"},{\"original\":\"ui/xbox/platform_desktop.png\",\"path\":\"ui/xbox/platform_desktop.png\"},{\"original\":\"ui/xbox/platform_android_white.png\",\"path\":\"ui/xbox/platform_android_white.png\"},{\"original\":\"ui/xbox/platform_android.png\",\"path\":\"ui/xbox/platform_android.png\"},{\"original\":\"ui/xbox/ping_4.png\",\"path\":\"ui/xbox/ping_4.png\"},{\"original\":\"ui/xbox/ping_3.png\",\"path\":\"ui/xbox/ping_3.png\"},{\"original\":\"ui/xbox/ping_2.png\",\"path\":\"ui/xbox/ping_2.png\"},{\"original\":\"ui/xbox/ping_1.png\",\"path\":\"ui/xbox/ping_1.png\"},{\"original\":\"ui/xbox/pad_trigger_r.english.png\",\"path\":\"ui/xbox/pad_trigger_r.english.png\"},{\"original\":\"ui/xbox/pad_trigger_l.english.png\",\"path\":\"ui/xbox/pad_trigger_l.english.png\"},{\"original\":\"ui/xbox/pad_stick_l_tilt.png\",\"path\":\"ui/xbox/pad_stick_l_tilt.png\"},{\"original\":\"ui/xbox/pad_smalltrigger_r.english.png\",\"path\":\"ui/xbox/pad_smalltrigger_r.english.png\"},{\"original\":\"ui/xbox/pad_smalltrigger_l.english.png\",\"path\":\"ui/xbox/pad_smalltrigger_l.english.png\"},{\"original\":\"ui/xbox/pad_smallstick_r_tilt.png\",\"path\":\"ui/xbox/pad_smallstick_r_tilt.png\"},{\"original\":\"ui/xbox/pad_smallstick_l_tilt.png\",\"path\":\"ui/xbox/pad_smallstick_l_tilt.png\"},{\"original\":\"ui/xbox/pad_smallbutton_y.png\",\"path\":\"ui/xbox/pad_smallbutton_y.png\"},{\"original\":\"ui/xbox/pad_smallbutton_x.png\",\"path\":\"ui/xbox/pad_smallbutton_x.png\"},{\"original\":\"ui/xbox/pad_smallbutton_b.png\",\"path\":\"ui/xbox/pad_smallbutton_b.png\"},{\"original\":\"ui/xbox/pad_smallbutton_a.png\",\"path\":\"ui/xbox/pad_smallbutton_a.png\"},{\"original\":\"ui/xbox/pad_smallbumper_r.english.png\",\"path\":\"ui/xbox/pad_smallbumper_r.english.png\"},{\"original\":\"ui/xbox/pad_smallbumper_l.english.png\",\"path\":\"ui/xbox/pad_smallbumper_l.english.png\"},{\"original\":\"ui/xbox/pad_button_y.png\",\"path\":\"ui/xbox/pad_button_y.png\"},{\"original\":\"ui/xbox/pad_button_x.png\",\"path\":\"ui/xbox/pad_button_x.png\"},{\"original\":\"ui/xbox/pad_button_b.png\",\"path\":\"ui/xbox/pad_button_b.png\"},{\"original\":\"ui/xbox/pad_button_a.png\",\"path\":\"ui/xbox/pad_button_a.png\"},{\"original\":\"ui/xbox/pad_bumper_r.english.png\",\"path\":\"ui/xbox/pad_bumper_r.english.png\"},{\"original\":\"ui/xbox/pad_bumper_l.english.png\",\"path\":\"ui/xbox/pad_bumper_l.english.png\"},{\"original\":\"ui/xbox/optionsCursorArraySmallWide.png\",\"path\":\"ui/xbox/optionscursorarraysmallwide.png\"},{\"original\":\"ui/xbox/optionsCursorArraySmall.png\",\"path\":\"ui/xbox/optionscursorarraysmall.png\"},{\"original\":\"ui/xbox/optionsCursorArray.png\",\"path\":\"ui/xbox/optionscursorarray.png\"},{\"original\":\"ui/xbox/loadingAnimation.png\",\"path\":\"ui/xbox/loadinganimation.png\"},{\"original\":\"ui/xbox/levelPreviewWindow.png\",\"path\":\"ui/xbox/levelpreviewwindow.png\"},{\"original\":\"ui/xbox/helpWindow.png\",\"path\":\"ui/xbox/helpwindow.png\"},{\"original\":\"ui/xbox/fade_black.png\",\"path\":\"ui/xbox/fade_black.png\"},{\"original\":\"ui/xbox/endGameWindow.png\",\"path\":\"ui/xbox/endgamewindow.png\"},{\"original\":\"ui/xbox/eggIcon.png\",\"path\":\"ui/xbox/eggicon.png\"},{\"original\":\"ui/xbox/downArrow.png\",\"path\":\"ui/xbox/downarrow.png\"},{\"original\":\"ui/xbox/demoLock.png\",\"path\":\"ui/xbox/demolock.png\"},{\"original\":\"ui/xbox/cursorButtonArray.png\",\"path\":\"ui/xbox/cursorbuttonarray.png\"},{\"original\":\"ui/xbox/cursorArraySmall.png\",\"path\":\"ui/xbox/cursorarraysmall.png\"},{\"original\":\"ui/xbox/cursorArray.png\",\"path\":\"ui/xbox/cursorarray.png\"},{\"original\":\"ui/xbox/blue.jpg\",\"path\":\"ui/xbox/blue.jpg\"},{\"original\":\"ui/xbox/black.jpg\",\"path\":\"ui/xbox/black.jpg\"},{\"original\":\"ui/xbox/bgShadeCircle.png\",\"path\":\"ui/xbox/bgshadecircle.png\"},{\"original\":\"ui/xbox/bgController.png\",\"path\":\"ui/xbox/bgcontroller.png\"},{\"original\":\"ui/xbox/bgBoxTop.png\",\"path\":\"ui/xbox/bgboxtop.png\"},{\"original\":\"ui/xbox/bgBox.png\",\"path\":\"ui/xbox/bgbox.png\"},{\"original\":\"ui/xbox/achievementWindow.png\",\"path\":\"ui/xbox/achievementwindow.png\"},{\"original\":\"ui/xbox/Ready.png\",\"path\":\"ui/xbox/ready.png\"},{\"original\":\"ui/xbox/NotReady.png\",\"path\":\"ui/xbox/notready.png\"},{\"original\":\"ui/xbox/GreenDot.png\",\"path\":\"ui/xbox/greendot.png\"},{\"original\":\"ui/xbox/EmptyDot.png\",\"path\":\"ui/xbox/emptydot.png\"},{\"original\":\"ui/xbox/DemoOutOfTimeIconMoved.png\",\"path\":\"ui/xbox/demooutoftimeiconmoved.png\"},{\"original\":\"ui/xbox/DemoOutOfTimeIcon.png\",\"path\":\"ui/xbox/demooutoftimeicon.png\"},{\"original\":\"ui/xbox/BG_fadeOutSoftEdge.png\",\"path\":\"ui/xbox/bg_fadeoutsoftedge.png\"},{\"original\":\"ui/xbox/BG_NavBarUnderButtonsLeft.png\",\"path\":\"ui/xbox/bg_navbarunderbuttonsleft.png\"},{\"original\":\"ui/xbox/BG_NavBarUnderButtons.png\",\"path\":\"ui/xbox/bg_navbarunderbuttons.png\"},{\"original\":\"ui/touch/up-arrow.png\",\"path\":\"ui/touch/up-arrow.png\"},{\"original\":\"ui/touch/rewind.png\",\"path\":\"ui/touch/rewind.png\"},{\"original\":\"ui/touch/refresh.png\",\"path\":\"ui/touch/refresh.png\"},{\"original\":\"ui/touch/pause-button.png\",\"path\":\"ui/touch/pause-button.png\"},{\"original\":\"ui/touch/explosion.png\",\"path\":\"ui/touch/explosion.png\"},{\"original\":\"ui/touch/energy.png\",\"path\":\"ui/touch/energy.png\"},{\"original\":\"ui/game/transparency-fps.png\",\"path\":\"ui/game/transparency-fps.png\"},{\"original\":\"ui/game/timebackdrop5.png\",\"path\":\"ui/game/timebackdrop5.png\"},{\"original\":\"ui/game/timebackdrop4.png\",\"path\":\"ui/game/timebackdrop4.png\"},{\"original\":\"ui/game/timebackdrop3.png\",\"path\":\"ui/game/timebackdrop3.png\"},{\"original\":\"ui/game/timebackdrop2.png\",\"path\":\"ui/game/timebackdrop2.png\"},{\"original\":\"ui/game/timebackdrop1.png\",\"path\":\"ui/game/timebackdrop1.png\"},{\"original\":\"ui/game/timebackdrop0.png\",\"path\":\"ui/game/timebackdrop0.png\"},{\"original\":\"ui/game/scoreBackdropPlus.png\",\"path\":\"ui/game/scorebackdropplus.png\"},{\"original\":\"ui/game/scoreBackdropMinus.png\",\"path\":\"ui/game/scorebackdropminus.png\"},{\"original\":\"ui/game/scoreBackdrop.png\",\"path\":\"ui/game/scorebackdrop.png\"},{\"original\":\"ui/game/powerup_speed.png\",\"path\":\"ui/game/powerup_speed.png\"},{\"original\":\"ui/game/powerup_mega.png\",\"path\":\"ui/game/powerup_mega.png\"},{\"original\":\"ui/game/powerup_jump.png\",\"path\":\"ui/game/powerup_jump.png\"},{\"original\":\"ui/game/powerup_copter.png\",\"path\":\"ui/game/powerup_copter.png\"},{\"original\":\"ui/game/powerup.png\",\"path\":\"ui/game/powerup.png\"},{\"original\":\"ui/game/powerbarMaskUltra.png\",\"path\":\"ui/game/powerbarmaskultra.png\"},{\"original\":\"ui/game/powerbarMaskLess.png\",\"path\":\"ui/game/powerbarmaskless.png\"},{\"original\":\"ui/game/powerbarMaskBlast.png\",\"path\":\"ui/game/powerbarmaskblast.png\"},{\"original\":\"ui/game/powerbarMask.png\",\"path\":\"ui/game/powerbarmask.png\"},{\"original\":\"ui/game/powerbarBG.png\",\"path\":\"ui/game/powerbarbg.png\"},{\"original\":\"ui/game/powerbar.png\",\"path\":\"ui/game/powerbar.png\"},{\"original\":\"ui/game/gem.png\",\"path\":\"ui/game/gem.png\"},{\"original\":\"ui/game/CloudBG.jpg\",\"path\":\"ui/game/cloudbg.jpg\"},{\"original\":\"ui/game/pc/powerup_speed.png\",\"path\":\"ui/game/pc/powerup_speed.png\"},{\"original\":\"ui/game/pc/powerup_mega.png\",\"path\":\"ui/game/pc/powerup_mega.png\"},{\"original\":\"ui/game/pc/powerup_jump.png\",\"path\":\"ui/game/pc/powerup_jump.png\"},{\"original\":\"ui/game/pc/powerup_copter.png\",\"path\":\"ui/game/pc/powerup_copter.png\"},{\"original\":\"ui/game/pc/powerup.png\",\"path\":\"ui/game/pc/powerup.png\"},{\"original\":\"ui/game/pc/powerbar.png\",\"path\":\"ui/game/pc/powerbar.png\"},{\"original\":\"ui/game/numbers/slash.png\",\"path\":\"ui/game/numbers/slash.png\"},{\"original\":\"ui/game/numbers/point.png\",\"path\":\"ui/game/numbers/point.png\"},{\"original\":\"ui/game/numbers/dash.png\",\"path\":\"ui/game/numbers/dash.png\"},{\"original\":\"ui/game/numbers/colon.png\",\"path\":\"ui/game/numbers/colon.png\"},{\"original\":\"ui/game/numbers/9.png\",\"path\":\"ui/game/numbers/9.png\"},{\"original\":\"ui/game/numbers/8.png\",\"path\":\"ui/game/numbers/8.png\"},{\"original\":\"ui/game/numbers/7.png\",\"path\":\"ui/game/numbers/7.png\"},{\"original\":\"ui/game/numbers/6.png\",\"path\":\"ui/game/numbers/6.png\"},{\"original\":\"ui/game/numbers/5.png\",\"path\":\"ui/game/numbers/5.png\"},{\"original\":\"ui/game/numbers/4.png\",\"path\":\"ui/game/numbers/4.png\"},{\"original\":\"ui/game/numbers/3.png\",\"path\":\"ui/game/numbers/3.png\"},{\"original\":\"ui/game/numbers/2.png\",\"path\":\"ui/game/numbers/2.png\"},{\"original\":\"ui/game/numbers/1.png\",\"path\":\"ui/game/numbers/1.png\"},{\"original\":\"ui/game/numbers/0.png\",\"path\":\"ui/game/numbers/0.png\"},{\"original\":\"ui/common/osxwindow.png\",\"path\":\"ui/common/osxwindow.png\"},{\"original\":\"ui/common/osxscroll.png\",\"path\":\"ui/common/osxscroll.png\"},{\"original\":\"ui/common/darkwindow.png\",\"path\":\"ui/common/darkwindow.png\"},{\"original\":\"ui/common/darkscroll.png\",\"path\":\"ui/common/darkscroll.png\"},{\"original\":\"ui/common/darkborder.png\",\"path\":\"ui/common/darkborder.png\"},{\"original\":\"ui/common/cur_3darrow.png\",\"path\":\"ui/common/cur_3darrow.png\"},{\"original\":\"ui/achievement/all.png\",\"path\":\"ui/achievement/all.png\"},{\"original\":\"ui/achievement/9.png\",\"path\":\"ui/achievement/9.png\"},{\"original\":\"ui/achievement/8.png\",\"path\":\"ui/achievement/8.png\"},{\"original\":\"ui/achievement/7.png\",\"path\":\"ui/achievement/7.png\"},{\"original\":\"ui/achievement/6.png\",\"path\":\"ui/achievement/6.png\"},{\"original\":\"ui/achievement/5.png\",\"path\":\"ui/achievement/5.png\"},{\"original\":\"ui/achievement/4.png\",\"path\":\"ui/achievement/4.png\"},{\"original\":\"ui/achievement/3.png\",\"path\":\"ui/achievement/3.png\"},{\"original\":\"ui/achievement/2.png\",\"path\":\"ui/achievement/2.png\"},{\"original\":\"ui/achievement/12.png\",\"path\":\"ui/achievement/12.png\"},{\"original\":\"ui/achievement/11.png\",\"path\":\"ui/achievement/11.png\"},{\"original\":\"ui/achievement/10.png\",\"path\":\"ui/achievement/10.png\"},{\"original\":\"ui/achievement/1.png\",\"path\":\"ui/achievement/1.png\"},{\"original\":\"tmp/cache.dat\",\"path\":\"tmp/cache.dat\"},{\"original\":\"tmp/font/arial.bfnt\",\"path\":\"tmp/font/arial.bfnt\"},{\"original\":\"tmp/font/MarkerFelt.bfnt\",\"path\":\"tmp/font/markerfelt.bfnt\"},{\"original\":\"tmp/font/Lucida Console.bfnt\",\"path\":\"tmp/font/lucida console.bfnt\"},{\"original\":\"tmp/font/EXPON.bfnt\",\"path\":\"tmp/font/expon.bfnt\"},{\"original\":\"tmp/font/DomCasualD.bfnt\",\"path\":\"tmp/font/domcasuald.bfnt\"},{\"original\":\"tmp/font/ColiseumRR.bfnt\",\"path\":\"tmp/font/coliseumrr.bfnt\"},{\"original\":\"tmp/font/Arial Bold.bfnt\",\"path\":\"tmp/font/arial bold.bfnt\"},{\"original\":\"tmp/data/font/arial.bfnt\",\"path\":\"tmp/data/font/arial.bfnt\"},{\"original\":\"tmp/data/font/MarkerFelt.bfnt\",\"path\":\"tmp/data/font/markerfelt.bfnt\"},{\"original\":\"tmp/data/font/Lucida Console.bfnt\",\"path\":\"tmp/data/font/lucida console.bfnt\"},{\"original\":\"tmp/data/font/EXPON.bfnt\",\"path\":\"tmp/data/font/expon.bfnt\"},{\"original\":\"tmp/data/font/DomCasualD.bfnt\",\"path\":\"tmp/data/font/domcasuald.bfnt\"},{\"original\":\"tmp/data/font/ColiseumRR.bfnt\",\"path\":\"tmp/data/font/coliseumrr.bfnt\"},{\"original\":\"tmp/data/font/Arial Bold.bfnt\",\"path\":\"tmp/data/font/arial bold.bfnt\"},{\"original\":\"textures/wall_beginner.png\",\"path\":\"textures/wall_beginner.png\"},{\"original\":\"textures/tile_underside.png\",\"path\":\"textures/tile_underside.png\"},{\"original\":\"textures/tile_intermediate.png\",\"path\":\"textures/tile_intermediate.png\"},{\"original\":\"textures/tile_intermediate.normal.png\",\"path\":\"textures/tile_intermediate.normal.png\"},{\"original\":\"textures/tile_beginner.png\",\"path\":\"textures/tile_beginner.png\"},{\"original\":\"textures/tile_advanced.png\",\"path\":\"textures/tile_advanced.png\"},{\"original\":\"textures/stripe_caution.png\",\"path\":\"textures/stripe_caution.png\"},{\"original\":\"textures/plate.randomize.png\",\"path\":\"textures/plate.randomize.png\"},{\"original\":\"textures/plate.normal.png\",\"path\":\"textures/plate.normal.png\"},{\"original\":\"textures/noise_shadow.jpg\",\"path\":\"textures/noise_shadow.jpg\"},{\"original\":\"textures/noise_red_shadow.jpg\",\"path\":\"textures/noise_red_shadow.jpg\"},{\"original\":\"textures/noise_red.jpg\",\"path\":\"textures/noise_red.jpg\"},{\"original\":\"textures/noise_green_shadow.jpg\",\"path\":\"textures/noise_green_shadow.jpg\"},{\"original\":\"textures/noise_green.jpg\",\"path\":\"textures/noise_green.jpg\"},{\"original\":\"textures/noise_blue_shadow.jpg\",\"path\":\"textures/noise_blue_shadow.jpg\"},{\"original\":\"textures/noise_blue.jpg\",\"path\":\"textures/noise_blue.jpg\"},{\"original\":\"textures/noise4.jpg\",\"path\":\"textures/noise4.jpg\"},{\"original\":\"textures/noise.jpg\",\"path\":\"textures/noise.jpg\"},{\"original\":\"textures/friction_low_shadow.png\",\"path\":\"textures/friction_low_shadow.png\"},{\"original\":\"textures/friction_low.png\",\"path\":\"textures/friction_low.png\"},{\"original\":\"textures/friction_low.normal.png\",\"path\":\"textures/friction_low.normal.png\"},{\"original\":\"textures/friction_high_shadow.png\",\"path\":\"textures/friction_high_shadow.png\"},{\"original\":\"textures/friction_high.png\",\"path\":\"textures/friction_high.png\"},{\"original\":\"textures/friction_high.normal.png\",\"path\":\"textures/friction_high.normal.png\"},{\"original\":\"textures/friction_bouncy.png\",\"path\":\"textures/friction_bouncy.png\"},{\"original\":\"textures/edge_white_shadow.png\",\"path\":\"textures/edge_white_shadow.png\"},{\"original\":\"textures/edge_white.png\",\"path\":\"textures/edge_white.png\"},{\"original\":\"textures/edge.normal.png\",\"path\":\"textures/edge.normal.png\"},{\"original\":\"textures/beam_side.png\",\"path\":\"textures/beam_side.png\"},{\"original\":\"textures/beam_side.normal.png\",\"path\":\"textures/beam_side.normal.png\"},{\"original\":\"textures/beam.png\",\"path\":\"textures/beam.png\"},{\"original\":\"textures/beam.normal.png\",\"path\":\"textures/beam.normal.png\"},{\"original\":\"textures/acubezpos2.png\",\"path\":\"textures/acubezpos2.png\"},{\"original\":\"textures/acubezneg2.png\",\"path\":\"textures/acubezneg2.png\"},{\"original\":\"textures/acubeypos2.png\",\"path\":\"textures/acubeypos2.png\"},{\"original\":\"textures/acubeyneg2.png\",\"path\":\"textures/acubeyneg2.png\"},{\"original\":\"textures/acubexpos2.png\",\"path\":\"textures/acubexpos2.png\"},{\"original\":\"textures/acubexneg2.png\",\"path\":\"textures/acubexneg2.png\"},{\"original\":\"textures/DefaultSpec.png\",\"path\":\"textures/defaultspec.png\"},{\"original\":\"textures/DefaultNormal.png\",\"path\":\"textures/defaultnormal.png\"},{\"original\":\"textures/DefaultDiffuse.png\",\"path\":\"textures/defaultdiffuse.png\"},{\"original\":\"sound/whoosh.wav\",\"path\":\"sound/whoosh.wav\"},{\"original\":\"sound/use_superjump_alternate.wav\",\"path\":\"sound/use_superjump_alternate.wav\"},{\"original\":\"sound/use_superjump.wav\",\"path\":\"sound/use_superjump.wav\"},{\"original\":\"sound/use_speed.wav\",\"path\":\"sound/use_speed.wav\"},{\"original\":\"sound/use_mega.wav\",\"path\":\"sound/use_mega.wav\"},{\"original\":\"sound/use_gyrocopter.wav\",\"path\":\"sound/use_gyrocopter.wav\"},{\"original\":\"sound/use_blast_ultra.wav\",\"path\":\"sound/use_blast_ultra.wav\"},{\"original\":\"sound/use_blast.wav\",\"path\":\"sound/use_blast.wav\"},{\"original\":\"sound/ultrablast.wav\",\"path\":\"sound/ultrablast.wav\"},{\"original\":\"sound/trapdooropen.wav\",\"path\":\"sound/trapdooropen.wav\"},{\"original\":\"sound/tornado.wav\",\"path\":\"sound/tornado.wav\"},{\"original\":\"sound/timetravelactive.wav\",\"path\":\"sound/timetravelactive.wav\"},{\"original\":\"sound/time_travel.wav\",\"path\":\"sound/time_travel.wav\"},{\"original\":\"sound/testing.wav\",\"path\":\"sound/testing.wav\"},{\"original\":\"sound/superbounceactive.wav\",\"path\":\"sound/superbounceactive.wav\"},{\"original\":\"sound/super_speed.wav\",\"path\":\"sound/super_speed.wav\"},{\"original\":\"sound/super_jump.wav\",\"path\":\"sound/super_jump.wav\"},{\"original\":\"sound/spawn_alternate2.wav\",\"path\":\"sound/spawn_alternate2.wav\"},{\"original\":\"sound/spawn_alternate.wav\",\"path\":\"sound/spawn_alternate.wav\"},{\"original\":\"sound/spawn.wav\",\"path\":\"sound/spawn.wav\"},{\"original\":\"sound/sliding.wav\",\"path\":\"sound/sliding.wav\"},{\"original\":\"sound/rolling_hard.wav\",\"path\":\"sound/rolling_hard.wav\"},{\"original\":\"sound/ready.wav\",\"path\":\"sound/ready.wav\"},{\"original\":\"sound/publastvoice.wav\",\"path\":\"sound/publastvoice.wav\"},{\"original\":\"sound/pu_timetravel.wav\",\"path\":\"sound/pu_timetravel.wav\"},{\"original\":\"sound/pu_gravity.wav\",\"path\":\"sound/pu_gravity.wav\"},{\"original\":\"sound/pu_easter.wav\",\"path\":\"sound/pu_easter.wav\"},{\"original\":\"sound/player_kicked.wav\",\"path\":\"sound/player_kicked.wav\"},{\"original\":\"sound/player_join.wav\",\"path\":\"sound/player_join.wav\"},{\"original\":\"sound/platformlowering.wav\",\"path\":\"sound/platformlowering.wav\"},{\"original\":\"sound/out_of_bounds.wav\",\"path\":\"sound/out_of_bounds.wav\"},{\"original\":\"sound/opponent_gem_collect.wav\",\"path\":\"sound/opponent_gem_collect.wav\"},{\"original\":\"sound/new_high_score.wav\",\"path\":\"sound/new_high_score.wav\"},{\"original\":\"sound/new_achievement.wav\",\"path\":\"sound/new_achievement.wav\"},{\"original\":\"sound/movingblockloop.wav\",\"path\":\"sound/movingblockloop.wav\"},{\"original\":\"sound/missinggems.wav\",\"path\":\"sound/missinggems.wav\"},{\"original\":\"sound/mega_roll.wav\",\"path\":\"sound/mega_roll.wav\"},{\"original\":\"sound/mega_marble.wav\",\"path\":\"sound/mega_marble.wav\"},{\"original\":\"sound/mega_bouncehard4.wav\",\"path\":\"sound/mega_bouncehard4.wav\"},{\"original\":\"sound/mega_bouncehard3.wav\",\"path\":\"sound/mega_bouncehard3.wav\"},{\"original\":\"sound/mega_bouncehard2.wav\",\"path\":\"sound/mega_bouncehard2.wav\"},{\"original\":\"sound/mega_bouncehard1.wav\",\"path\":\"sound/mega_bouncehard1.wav\"},{\"original\":\"sound/marble_roll_rubber.wav\",\"path\":\"sound/marble_roll_rubber.wav\"},{\"original\":\"sound/marble_blast_ultra.wav\",\"path\":\"sound/marble_blast_ultra.wav\"},{\"original\":\"sound/level_text.wav\",\"path\":\"sound/level_text.wav\"},{\"original\":\"sound/level_platform.wav\",\"path\":\"sound/level_platform.wav\"},{\"original\":\"sound/level_finish.wav\",\"path\":\"sound/level_finish.wav\"},{\"original\":\"sound/level_complete.wav\",\"path\":\"sound/level_complete.wav\"},{\"original\":\"sound/level_checkpoint.wav\",\"path\":\"sound/level_checkpoint.wav\"},{\"original\":\"sound/lb_signout.wav\",\"path\":\"sound/lb_signout.wav\"},{\"original\":\"sound/lb_signin.wav\",\"path\":\"sound/lb_signin.wav\"},{\"original\":\"sound/lb_send.wav\",\"path\":\"sound/lb_send.wav\"},{\"original\":\"sound/lb_recieve.wav\",\"path\":\"sound/lb_recieve.wav\"},{\"original\":\"sound/lb_nudge.wav\",\"path\":\"sound/lb_nudge.wav\"},{\"original\":\"sound/lb_error.wav\",\"path\":\"sound/lb_error.wav\"},{\"original\":\"sound/lb_achievementall.wav\",\"path\":\"sound/lb_achievementall.wav\"},{\"original\":\"sound/lb_achievementall.NOTUSEDwav\",\"path\":\"sound/lb_achievementall.notusedwav\"},{\"original\":\"sound/lb_achievement.wav\",\"path\":\"sound/lb_achievement.wav\"},{\"original\":\"sound/lb_achievement.NOTUSEDwav\",\"path\":\"sound/lb_achievement.notusedwav\"},{\"original\":\"sound/jump.wav\",\"path\":\"sound/jump.wav\"},{\"original\":\"sound/infotutorial.wav\",\"path\":\"sound/infotutorial.wav\"},{\"original\":\"sound/ice_roll.wav\",\"path\":\"sound/ice_roll.wav\"},{\"original\":\"sound/gyrocopter.wav\",\"path\":\"sound/gyrocopter.wav\"},{\"original\":\"sound/gui_next.wav\",\"path\":\"sound/gui_next.wav\"},{\"original\":\"sound/gui_confirm.wav\",\"path\":\"sound/gui_confirm.wav\"},{\"original\":\"sound/gui_back.wav\",\"path\":\"sound/gui_back.wav\"},{\"original\":\"sound/gravitychange.wav\",\"path\":\"sound/gravitychange.wav\"},{\"original\":\"sound/gravity.wav\",\"path\":\"sound/gravity.wav\"},{\"original\":\"sound/go.wav\",\"path\":\"sound/go.wav\"},{\"original\":\"sound/gem_collect.wav\",\"path\":\"sound/gem_collect.wav\"},{\"original\":\"sound/gem_all.wav\",\"path\":\"sound/gem_all.wav\"},{\"original\":\"sound/finish.wav\",\"path\":\"sound/finish.wav\"},{\"original\":\"sound/fan_loop.wav\",\"path\":\"sound/fan_loop.wav\"},{\"original\":\"sound/easter_egg.wav\",\"path\":\"sound/easter_egg.wav\"},{\"original\":\"sound/checkpoint.wav\",\"path\":\"sound/checkpoint.wav\"},{\"original\":\"sound/buttonpress.wav\",\"path\":\"sound/buttonpress.wav\"},{\"original\":\"sound/buttonover.wav\",\"path\":\"sound/buttonover.wav\"},{\"original\":\"sound/bumperding1.wav\",\"path\":\"sound/bumperding1.wav\"},{\"original\":\"sound/bouncehard4.wav\",\"path\":\"sound/bouncehard4.wav\"},{\"original\":\"sound/bouncehard3.wav\",\"path\":\"sound/bouncehard3.wav\"},{\"original\":\"sound/bouncehard2.wav\",\"path\":\"sound/bouncehard2.wav\"},{\"original\":\"sound/bouncehard1.wav\",\"path\":\"sound/bouncehard1.wav\"},{\"original\":\"sound/begin.wav\",\"path\":\"sound/begin.wav\"},{\"original\":\"sound/all_achievement.wav\",\"path\":\"sound/all_achievement.wav\"},{\"original\":\"sound/MegaShrink.wav\",\"path\":\"sound/megashrink.wav\"},{\"original\":\"sound/LBError.NOTUSEDwav\",\"path\":\"sound/lberror.notusedwav\"},{\"original\":\"sound/music/Tim Trance.ogg\",\"path\":\"sound/music/tim trance.ogg\"},{\"original\":\"skies/sky_intermediate.dml\",\"path\":\"skies/sky_intermediate.dml\"},{\"original\":\"skies/sky_beginner.dml\",\"path\":\"skies/sky_beginner.dml\"},{\"original\":\"skies/sky_advanced.dml\",\"path\":\"skies/sky_advanced.dml\"},{\"original\":\"skies/gemCubemapUp3.png\",\"path\":\"skies/gemcubemapup3.png\"},{\"original\":\"skies/gemCubemapUp2.png\",\"path\":\"skies/gemcubemapup2.png\"},{\"original\":\"skies/gemCubemapUp.png\",\"path\":\"skies/gemcubemapup.png\"},{\"original\":\"skies/exp_up.png\",\"path\":\"skies/exp_up.png\"},{\"original\":\"skies/exp_ea.png\",\"path\":\"skies/exp_ea.png\"},{\"original\":\"skies/exp_WE.png\",\"path\":\"skies/exp_we.png\"},{\"original\":\"skies/exp_SO.png\",\"path\":\"skies/exp_so.png\"},{\"original\":\"skies/exp_NO.png\",\"path\":\"skies/exp_no.png\"},{\"original\":\"skies/exp_ENV.png\",\"path\":\"skies/exp_env.png\"},{\"original\":\"skies/exp_DN.png\",\"path\":\"skies/exp_dn.png\"},{\"original\":\"skies/env_WE.png\",\"path\":\"skies/env_we.png\"},{\"original\":\"skies/env_UP.png\",\"path\":\"skies/env_up.png\"},{\"original\":\"skies/env_SO.png\",\"path\":\"skies/env_so.png\"},{\"original\":\"skies/env_NO.png\",\"path\":\"skies/env_no.png\"},{\"original\":\"skies/env_EA.png\",\"path\":\"skies/env_ea.png\"},{\"original\":\"skies/env_DN.png\",\"path\":\"skies/env_dn.png\"},{\"original\":\"skies/beg_WE.png\",\"path\":\"skies/beg_we.png\"},{\"original\":\"skies/beg_UP.png\",\"path\":\"skies/beg_up.png\"},{\"original\":\"skies/beg_SO.png\",\"path\":\"skies/beg_so.png\"},{\"original\":\"skies/beg_NO.png\",\"path\":\"skies/beg_no.png\"},{\"original\":\"skies/beg_ENV.png\",\"path\":\"skies/beg_env.png\"},{\"original\":\"skies/beg_EA.png\",\"path\":\"skies/beg_ea.png\"},{\"original\":\"skies/beg_DN.png\",\"path\":\"skies/beg_dn.png\"},{\"original\":\"skies/adv_wE.png\",\"path\":\"skies/adv_we.png\"},{\"original\":\"skies/adv_eA.png\",\"path\":\"skies/adv_ea.png\"},{\"original\":\"skies/adv_UP.png\",\"path\":\"skies/adv_up.png\"},{\"original\":\"skies/adv_SO.png\",\"path\":\"skies/adv_so.png\"},{\"original\":\"skies/adv_NO.png\",\"path\":\"skies/adv_no.png\"},{\"original\":\"skies/adv_ENV.png\",\"path\":\"skies/adv_env.png\"},{\"original\":\"skies/adv_DN.png\",\"path\":\"skies/adv_dn.png\"},{\"original\":\"shapes/signwood.jpg\",\"path\":\"shapes/signwood.jpg\"},{\"original\":\"shapes/quicksand.dts\",\"path\":\"shapes/quicksand.dts\"},{\"original\":\"shapes/colmesh.dts\",\"path\":\"shapes/colmesh.dts\"},{\"original\":\"shapes/blah.jpg\",\"path\":\"shapes/blah.jpg\"},{\"original\":\"shapes/bitmaptest.png\",\"path\":\"shapes/bitmaptest.png\"},{\"original\":\"shapes/structures/time.normal.jpg\",\"path\":\"shapes/structures/time.normal.jpg\"},{\"original\":\"shapes/structures/glass_flat.dts\",\"path\":\"shapes/structures/glass_flat.dts\"},{\"original\":\"shapes/structures/glass_9.dts\",\"path\":\"shapes/structures/glass_9.dts\"},{\"original\":\"shapes/structures/glass_6.dts\",\"path\":\"shapes/structures/glass_6.dts\"},{\"original\":\"shapes/structures/glass_3.dts\",\"path\":\"shapes/structures/glass_3.dts\"},{\"original\":\"shapes/structures/glass_18.dts\",\"path\":\"shapes/structures/glass_18.dts\"},{\"original\":\"shapes/structures/glass_15.dts\",\"path\":\"shapes/structures/glass_15.dts\"},{\"original\":\"shapes/structures/glass_12.dts\",\"path\":\"shapes/structures/glass_12.dts\"},{\"original\":\"shapes/structures/glass2.png\",\"path\":\"shapes/structures/glass2.png\"},{\"original\":\"shapes/structures/glass.png\",\"path\":\"shapes/structures/glass.png\"},{\"original\":\"shapes/structures/glass.normal.png\",\"path\":\"shapes/structures/glass.normal.png\"},{\"original\":\"shapes/signs/danger.cautionsign.jpg\",\"path\":\"shapes/signs/danger.cautionsign.jpg\"},{\"original\":\"shapes/signs/cautionsignwood.jpg\",\"path\":\"shapes/signs/cautionsignwood.jpg\"},{\"original\":\"shapes/signs/cautionsign_pole.jpg\",\"path\":\"shapes/signs/cautionsign_pole.jpg\"},{\"original\":\"shapes/signs/cautionsign.dts\",\"path\":\"shapes/signs/cautionsign.dts\"},{\"original\":\"shapes/signs/caution.cautionsign.jpg\",\"path\":\"shapes/signs/caution.cautionsign.jpg\"},{\"original\":\"shapes/signs/base.cautionsign.jpg\",\"path\":\"shapes/signs/base.cautionsign.jpg\"},{\"original\":\"shapes/signs/arrowsign_up.dts\",\"path\":\"shapes/signs/arrowsign_up.dts\"},{\"original\":\"shapes/signs/arrowsign_side.dts\",\"path\":\"shapes/signs/arrowsign_side.dts\"},{\"original\":\"shapes/signs/arrowsign_post_bump.png\",\"path\":\"shapes/signs/arrowsign_post_bump.png\"},{\"original\":\"shapes/signs/arrowsign_post.png\",\"path\":\"shapes/signs/arrowsign_post.png\"},{\"original\":\"shapes/signs/arrowsign_down.dts\",\"path\":\"shapes/signs/arrowsign_down.dts\"},{\"original\":\"shapes/signs/arrowsign_chain.png\",\"path\":\"shapes/signs/arrowsign_chain.png\"},{\"original\":\"shapes/signs/arrowsign_arrow_glow.png\",\"path\":\"shapes/signs/arrowsign_arrow_glow.png\"},{\"original\":\"shapes/signs/arrowsign_arrow.png\",\"path\":\"shapes/signs/arrowsign_arrow.png\"},{\"original\":\"shapes/signs/ArrowPostUVW.png\",\"path\":\"shapes/signs/arrowpostuvw.png\"},{\"original\":\"shapes/pads/startarea.dts\",\"path\":\"shapes/pads/startarea.dts\"},{\"original\":\"shapes/pads/sigiloff.png\",\"path\":\"shapes/pads/sigiloff.png\"},{\"original\":\"shapes/pads/sigil.png\",\"path\":\"shapes/pads/sigil.png\"},{\"original\":\"shapes/pads/ringtex.png\",\"path\":\"shapes/pads/ringtex.png\"},{\"original\":\"shapes/pads/ringnormal.png\",\"path\":\"shapes/pads/ringnormal.png\"},{\"original\":\"shapes/pads/ringglass.png\",\"path\":\"shapes/pads/ringglass.png\"},{\"original\":\"shapes/pads/refract.png\",\"path\":\"shapes/pads/refract.png\"},{\"original\":\"shapes/pads/mistyglow.png\",\"path\":\"shapes/pads/mistyglow.png\"},{\"original\":\"shapes/pads/misty.png\",\"path\":\"shapes/pads/misty.png\"},{\"original\":\"shapes/pads/endpad_glow.png\",\"path\":\"shapes/pads/endpad_glow.png\"},{\"original\":\"shapes/pads/endarea.dts\",\"path\":\"shapes/pads/endarea.dts\"},{\"original\":\"shapes/pads/checkpad.dts\",\"path\":\"shapes/pads/checkpad.dts\"},{\"original\":\"shapes/pads/abyss2.png\",\"path\":\"shapes/pads/abyss2.png\"},{\"original\":\"shapes/pads/abyss.png\",\"path\":\"shapes/pads/abyss.png\"},{\"original\":\"shapes/markers/octahedron.dts\",\"path\":\"shapes/markers/octahedron.dts\"},{\"original\":\"shapes/items/yellow.gem.png\",\"path\":\"shapes/items/yellow.gem.png\"},{\"original\":\"shapes/items/timetravelitem_sand.jpg\",\"path\":\"shapes/items/timetravelitem_sand.jpg\"},{\"original\":\"shapes/items/timetravelitem_glass.png\",\"path\":\"shapes/items/timetravelitem_glass.png\"},{\"original\":\"shapes/items/timetravel.dts\",\"path\":\"shapes/items/timetravel.dts\"},{\"original\":\"shapes/items/timeTravel_skin.png\",\"path\":\"shapes/items/timetravel_skin.png\"},{\"original\":\"shapes/items/timeTravel_glass.png\",\"path\":\"shapes/items/timetravel_glass.png\"},{\"original\":\"shapes/items/superspeed.dts\",\"path\":\"shapes/items/superspeed.dts\"},{\"original\":\"shapes/items/superjump.dts\",\"path\":\"shapes/items/superjump.dts\"},{\"original\":\"shapes/items/superSpeed_star.png\",\"path\":\"shapes/items/superspeed_star.png\"},{\"original\":\"shapes/items/superSpeed_skin.png\",\"path\":\"shapes/items/superspeed_skin.png\"},{\"original\":\"shapes/items/superJump_skin.png\",\"path\":\"shapes/items/superjump_skin.png\"},{\"original\":\"shapes/items/superJump_bump.png\",\"path\":\"shapes/items/superjump_bump.png\"},{\"original\":\"shapes/items/star.png\",\"path\":\"shapes/items/star.png\"},{\"original\":\"shapes/items/red.gem.png\",\"path\":\"shapes/items/red.gem.png\"},{\"original\":\"shapes/items/itemarrow.jpg\",\"path\":\"shapes/items/itemarrow.jpg\"},{\"original\":\"shapes/items/item_glow.png\",\"path\":\"shapes/items/item_glow.png\"},{\"original\":\"shapes/items/gemshine.png\",\"path\":\"shapes/items/gemshine.png\"},{\"original\":\"shapes/items/gembeam.png\",\"path\":\"shapes/items/gembeam.png\"},{\"original\":\"shapes/items/gembeam.dts\",\"path\":\"shapes/items/gembeam.dts\"},{\"original\":\"shapes/items/gem.dts\",\"path\":\"shapes/items/gem.dts\"},{\"original\":\"shapes/items/enviro1.jpg\",\"path\":\"shapes/items/enviro1.jpg\"},{\"original\":\"shapes/items/egg_skin.png\",\"path\":\"shapes/items/egg_skin.png\"},{\"original\":\"shapes/items/egg.dts\",\"path\":\"shapes/items/egg.dts\"},{\"original\":\"shapes/items/blue.gem.png\",\"path\":\"shapes/items/blue.gem.png\"},{\"original\":\"shapes/items/antigravity.dts\",\"path\":\"shapes/items/antigravity.dts\"},{\"original\":\"shapes/items/antigrav_skin.png\",\"path\":\"shapes/items/antigrav_skin.png\"},{\"original\":\"shapes/items/antigrav_glow.png\",\"path\":\"shapes/items/antigrav_glow.png\"},{\"original\":\"shapes/items/antigrav_bump.png\",\"path\":\"shapes/items/antigrav_bump.png\"},{\"original\":\"shapes/images/orbit.png\",\"path\":\"shapes/images/orbit.png\"},{\"original\":\"shapes/images/helicopter_image.dts\",\"path\":\"shapes/images/helicopter_image.dts\"},{\"original\":\"shapes/images/helicopter.jpg\",\"path\":\"shapes/images/helicopter.jpg\"},{\"original\":\"shapes/images/helicopter.dts\",\"path\":\"shapes/images/helicopter.dts\"},{\"original\":\"shapes/images/grow_glow.png\",\"path\":\"shapes/images/grow_glow.png\"},{\"original\":\"shapes/images/grow_bump.png\",\"path\":\"shapes/images/grow_bump.png\"},{\"original\":\"shapes/images/grow.png\",\"path\":\"shapes/images/grow.png\"},{\"original\":\"shapes/images/grow.dts\",\"path\":\"shapes/images/grow.dts\"},{\"original\":\"shapes/images/glow_bounce.png\",\"path\":\"shapes/images/glow_bounce.png\"},{\"original\":\"shapes/images/glow_bounce.dts\",\"path\":\"shapes/images/glow_bounce.dts\"},{\"original\":\"shapes/images/distort.dts\",\"path\":\"shapes/images/distort.dts\"},{\"original\":\"shapes/images/corona.png\",\"path\":\"shapes/images/corona.png\"},{\"original\":\"shapes/images/copter_skin.png\",\"path\":\"shapes/images/copter_skin.png\"},{\"original\":\"shapes/images/blastwave.png\",\"path\":\"shapes/images/blastwave.png\"},{\"original\":\"shapes/images/blast_orbit_skin.png\",\"path\":\"shapes/images/blast_orbit_skin.png\"},{\"original\":\"shapes/images/blast_orbit_bump.png\",\"path\":\"shapes/images/blast_orbit_bump.png\"},{\"original\":\"shapes/images/blast_glow.png\",\"path\":\"shapes/images/blast_glow.png\"},{\"original\":\"shapes/images/blast.dts\",\"path\":\"shapes/images/blast.dts\"},{\"original\":\"shapes/hazards/trapdoor.png\",\"path\":\"shapes/hazards/trapdoor.png\"},{\"original\":\"shapes/hazards/trapdoor.dts\",\"path\":\"shapes/hazards/trapdoor.dts\"},{\"original\":\"shapes/hazards/null.png\",\"path\":\"shapes/hazards/null.png\"},{\"original\":\"shapes/hazards/fan.png\",\"path\":\"shapes/hazards/fan.png\"},{\"original\":\"shapes/hazards/ductfan.dts\",\"path\":\"shapes/hazards/ductfan.dts\"},{\"original\":\"shapes/hazards/base.slick.jpg\",\"path\":\"shapes/hazards/base.slick.jpg\"},{\"original\":\"shapes/bumpers/pball_round.dts\",\"path\":\"shapes/bumpers/pball_round.dts\"},{\"original\":\"shapes/bumpers/bumper.png\",\"path\":\"shapes/bumpers/bumper.png\"},{\"original\":\"shapes/balls/marblefx.normal.png\",\"path\":\"shapes/balls/marblefx.normal.png\"},{\"original\":\"shapes/balls/marble35.skin.png\",\"path\":\"shapes/balls/marble35.skin.png\"},{\"original\":\"shapes/balls/marble35.dts\",\"path\":\"shapes/balls/marble35.dts\"},{\"original\":\"shapes/balls/marble34.skin.png\",\"path\":\"shapes/balls/marble34.skin.png\"},{\"original\":\"shapes/balls/marble34.dts\",\"path\":\"shapes/balls/marble34.dts\"},{\"original\":\"shapes/balls/marble33.skin.png\",\"path\":\"shapes/balls/marble33.skin.png\"},{\"original\":\"shapes/balls/marble33.dts\",\"path\":\"shapes/balls/marble33.dts\"},{\"original\":\"shapes/balls/marble32.skin.png\",\"path\":\"shapes/balls/marble32.skin.png\"},{\"original\":\"shapes/balls/marble32.dts\",\"path\":\"shapes/balls/marble32.dts\"},{\"original\":\"shapes/balls/marble31.skin.png\",\"path\":\"shapes/balls/marble31.skin.png\"},{\"original\":\"shapes/balls/marble31.dts\",\"path\":\"shapes/balls/marble31.dts\"},{\"original\":\"shapes/balls/marble30.skin.png\",\"path\":\"shapes/balls/marble30.skin.png\"},{\"original\":\"shapes/balls/marble30.dts\",\"path\":\"shapes/balls/marble30.dts\"},{\"original\":\"shapes/balls/marble29.skin.png\",\"path\":\"shapes/balls/marble29.skin.png\"},{\"original\":\"shapes/balls/marble29.dts\",\"path\":\"shapes/balls/marble29.dts\"},{\"original\":\"shapes/balls/marble28.skin.png\",\"path\":\"shapes/balls/marble28.skin.png\"},{\"original\":\"shapes/balls/marble28.dts\",\"path\":\"shapes/balls/marble28.dts\"},{\"original\":\"shapes/balls/marble27.skin.png\",\"path\":\"shapes/balls/marble27.skin.png\"},{\"original\":\"shapes/balls/marble27.dts\",\"path\":\"shapes/balls/marble27.dts\"},{\"original\":\"shapes/balls/marble26.skin.png\",\"path\":\"shapes/balls/marble26.skin.png\"},{\"original\":\"shapes/balls/marble26.dts\",\"path\":\"shapes/balls/marble26.dts\"},{\"original\":\"shapes/balls/marble25.skin.png\",\"path\":\"shapes/balls/marble25.skin.png\"},{\"original\":\"shapes/balls/marble25.dts\",\"path\":\"shapes/balls/marble25.dts\"},{\"original\":\"shapes/balls/marble24.skin.png\",\"path\":\"shapes/balls/marble24.skin.png\"},{\"original\":\"shapes/balls/marble24.dts\",\"path\":\"shapes/balls/marble24.dts\"},{\"original\":\"shapes/balls/marble23.skin.png\",\"path\":\"shapes/balls/marble23.skin.png\"},{\"original\":\"shapes/balls/marble23.dts\",\"path\":\"shapes/balls/marble23.dts\"},{\"original\":\"shapes/balls/marble22.skin.png\",\"path\":\"shapes/balls/marble22.skin.png\"},{\"original\":\"shapes/balls/marble22.dts\",\"path\":\"shapes/balls/marble22.dts\"},{\"original\":\"shapes/balls/marble21.skin.png\",\"path\":\"shapes/balls/marble21.skin.png\"},{\"original\":\"shapes/balls/marble21.dts\",\"path\":\"shapes/balls/marble21.dts\"},{\"original\":\"shapes/balls/marble20.skin.png\",\"path\":\"shapes/balls/marble20.skin.png\"},{\"original\":\"shapes/balls/marble20.normal.png\",\"path\":\"shapes/balls/marble20.normal.png\"},{\"original\":\"shapes/balls/marble20.dts\",\"path\":\"shapes/balls/marble20.dts\"},{\"original\":\"shapes/balls/marble19.skin.png\",\"path\":\"shapes/balls/marble19.skin.png\"},{\"original\":\"shapes/balls/marble19.dts\",\"path\":\"shapes/balls/marble19.dts\"},{\"original\":\"shapes/balls/marble18.skin.png\",\"path\":\"shapes/balls/marble18.skin.png\"},{\"original\":\"shapes/balls/marble18.normal.png\",\"path\":\"shapes/balls/marble18.normal.png\"},{\"original\":\"shapes/balls/marble18.dts\",\"path\":\"shapes/balls/marble18.dts\"},{\"original\":\"shapes/balls/marble17.skin.png\",\"path\":\"shapes/balls/marble17.skin.png\"},{\"original\":\"shapes/balls/marble17.dts\",\"path\":\"shapes/balls/marble17.dts\"},{\"original\":\"shapes/balls/marble16.skin.png\",\"path\":\"shapes/balls/marble16.skin.png\"},{\"original\":\"shapes/balls/marble16.dts\",\"path\":\"shapes/balls/marble16.dts\"},{\"original\":\"shapes/balls/marble15.skin.png\",\"path\":\"shapes/balls/marble15.skin.png\"},{\"original\":\"shapes/balls/marble15.dts\",\"path\":\"shapes/balls/marble15.dts\"},{\"original\":\"shapes/balls/marble14.skin.png\",\"path\":\"shapes/balls/marble14.skin.png\"},{\"original\":\"shapes/balls/marble14.dts\",\"path\":\"shapes/balls/marble14.dts\"},{\"original\":\"shapes/balls/marble13.skin.png\",\"path\":\"shapes/balls/marble13.skin.png\"},{\"original\":\"shapes/balls/marble13.dts\",\"path\":\"shapes/balls/marble13.dts\"},{\"original\":\"shapes/balls/marble12.skin.png\",\"path\":\"shapes/balls/marble12.skin.png\"},{\"original\":\"shapes/balls/marble12.dts\",\"path\":\"shapes/balls/marble12.dts\"},{\"original\":\"shapes/balls/marble11.skin.png\",\"path\":\"shapes/balls/marble11.skin.png\"},{\"original\":\"shapes/balls/marble11.dts\",\"path\":\"shapes/balls/marble11.dts\"},{\"original\":\"shapes/balls/marble10.skin.png\",\"path\":\"shapes/balls/marble10.skin.png\"},{\"original\":\"shapes/balls/marble10.dts\",\"path\":\"shapes/balls/marble10.dts\"},{\"original\":\"shapes/balls/marble09.skin.png\",\"path\":\"shapes/balls/marble09.skin.png\"},{\"original\":\"shapes/balls/marble09.dts\",\"path\":\"shapes/balls/marble09.dts\"},{\"original\":\"shapes/balls/marble08.skin.png\",\"path\":\"shapes/balls/marble08.skin.png\"},{\"original\":\"shapes/balls/marble08.dts\",\"path\":\"shapes/balls/marble08.dts\"},{\"original\":\"shapes/balls/marble07.skin.png\",\"path\":\"shapes/balls/marble07.skin.png\"},{\"original\":\"shapes/balls/marble07.dts\",\"path\":\"shapes/balls/marble07.dts\"},{\"original\":\"shapes/balls/marble06.skin.png\",\"path\":\"shapes/balls/marble06.skin.png\"},{\"original\":\"shapes/balls/marble06.dts\",\"path\":\"shapes/balls/marble06.dts\"},{\"original\":\"shapes/balls/marble05.skin.png\",\"path\":\"shapes/balls/marble05.skin.png\"},{\"original\":\"shapes/balls/marble05.dts\",\"path\":\"shapes/balls/marble05.dts\"},{\"original\":\"shapes/balls/marble04.skin.png\",\"path\":\"shapes/balls/marble04.skin.png\"},{\"original\":\"shapes/balls/marble04.dts\",\"path\":\"shapes/balls/marble04.dts\"},{\"original\":\"shapes/balls/marble03.skin.png\",\"path\":\"shapes/balls/marble03.skin.png\"},{\"original\":\"shapes/balls/marble03.dts\",\"path\":\"shapes/balls/marble03.dts\"},{\"original\":\"shapes/balls/marble02.skin.png\",\"path\":\"shapes/balls/marble02.skin.png\"},{\"original\":\"shapes/balls/marble02.normal.png\",\"path\":\"shapes/balls/marble02.normal.png\"},{\"original\":\"shapes/balls/marble02.dts\",\"path\":\"shapes/balls/marble02.dts\"},{\"original\":\"shapes/balls/marble01.skin.png\",\"path\":\"shapes/balls/marble01.skin.png\"},{\"original\":\"shapes/balls/marble01.normal.png\",\"path\":\"shapes/balls/marble01.normal.png\"},{\"original\":\"shapes/balls/marble01.dts\",\"path\":\"shapes/balls/marble01.dts\"},{\"original\":\"shapes/astrolabe/clouds_intermediate.png\",\"path\":\"shapes/astrolabe/clouds_intermediate.png\"},{\"original\":\"shapes/astrolabe/clouds_beginner.png\",\"path\":\"shapes/astrolabe/clouds_beginner.png\"},{\"original\":\"shapes/astrolabe/clouds_advanced.png\",\"path\":\"shapes/astrolabe/clouds_advanced.png\"},{\"original\":\"shapes/astrolabe/astrolabe_solid_glow.png\",\"path\":\"shapes/astrolabe/astrolabe_solid_glow.png\"},{\"original\":\"shapes/astrolabe/astrolabe_root.dsq\",\"path\":\"shapes/astrolabe/astrolabe_root.dsq\"},{\"original\":\"shapes/astrolabe/astrolabe_glow.png\",\"path\":\"shapes/astrolabe/astrolabe_glow.png\"},{\"original\":\"shapes/astrolabe/astrolabe_clouds_intermediate.dts\",\"path\":\"shapes/astrolabe/astrolabe_clouds_intermediate.dts\"},{\"original\":\"shapes/astrolabe/astrolabe_clouds_beginner.dts\",\"path\":\"shapes/astrolabe/astrolabe_clouds_beginner.dts\"},{\"original\":\"shapes/astrolabe/astrolabe_clouds_advanced.dts\",\"path\":\"shapes/astrolabe/astrolabe_clouds_advanced.dts\"},{\"original\":\"shapes/astrolabe/astrolabe.dts\",\"path\":\"shapes/astrolabe/astrolabe.dts\"},{\"original\":\"particles/twirl.png\",\"path\":\"particles/twirl.png\"},{\"original\":\"particles/star.png\",\"path\":\"particles/star.png\"},{\"original\":\"particles/spark.png\",\"path\":\"particles/spark.png\"},{\"original\":\"particles/smoke.png\",\"path\":\"particles/smoke.png\"},{\"original\":\"particles/saturn.png\",\"path\":\"particles/saturn.png\"},{\"original\":\"particles/fleck.png\",\"path\":\"particles/fleck.png\"},{\"original\":\"particles/burst.png\",\"path\":\"particles/burst.png\"},{\"original\":\"particles/bubble.png\",\"path\":\"particles/bubble.png\"},{\"original\":\"missions/megaMission.mis\",\"path\":\"missions/megamission.mis\"},{\"original\":\"missions/special/marblepicker.mis\",\"path\":\"missions/special/marblepicker.mis\"},{\"original\":\"missions/special/marblepicker.dif\",\"path\":\"missions/special/marblepicker.dif\"},{\"original\":\"missions/parts/vertical_support.dif\",\"path\":\"missions/parts/vertical_support.dif\"},{\"original\":\"missions/parts/royale_pipe.dif\",\"path\":\"missions/parts/royale_pipe.dif\"},{\"original\":\"missions/parts/royale_corner2.dif\",\"path\":\"missions/parts/royale_corner2.dif\"},{\"original\":\"missions/parts/royale_corner1.dif\",\"path\":\"missions/parts/royale_corner1.dif\"},{\"original\":\"missions/parts/royale_climb.dif\",\"path\":\"missions/parts/royale_climb.dif\"},{\"original\":\"missions/parts/intermediate_wide_curve.dif\",\"path\":\"missions/parts/intermediate_wide_curve.dif\"},{\"original\":\"missions/parts/intermediate_tight_curve.dif\",\"path\":\"missions/parts/intermediate_tight_curve.dif\"},{\"original\":\"missions/parts/intermediate_gentleslope.dif\",\"path\":\"missions/parts/intermediate_gentleslope.dif\"},{\"original\":\"missions/parts/arch_8_normal.dif\",\"path\":\"missions/parts/arch_8_normal.dif\"},{\"original\":\"missions/parts/arch_8_corner.dif\",\"path\":\"missions/parts/arch_8_corner.dif\"},{\"original\":\"missions/parts/arch_4_normal.dif\",\"path\":\"missions/parts/arch_4_normal.dif\"},{\"original\":\"missions/parts/arch_4_corner.dif\",\"path\":\"missions/parts/arch_4_corner.dif\"},{\"original\":\"missions/parts/arch_3_normal.dif\",\"path\":\"missions/parts/arch_3_normal.dif\"},{\"original\":\"missions/parts/arch_3_corner.dif\",\"path\":\"missions/parts/arch_3_corner.dif\"},{\"original\":\"missions/parts/arch_2_normal.dif\",\"path\":\"missions/parts/arch_2_normal.dif\"},{\"original\":\"missions/parts/arch_2_corner.dif\",\"path\":\"missions/parts/arch_2_corner.dif\"},{\"original\":\"missions/multiplayer/royale/royale.mis\",\"path\":\"missions/multiplayer/royale/royale.mis\"},{\"original\":\"missions/multiplayer/royale/royale.dif\",\"path\":\"missions/multiplayer/royale/royale.dif\"},{\"original\":\"missions/multiplayer/Ziggurat/ziggurat.mis\",\"path\":\"missions/multiplayer/ziggurat/ziggurat.mis\"},{\"original\":\"missions/multiplayer/Ziggurat/ziggurat.dif\",\"path\":\"missions/multiplayer/ziggurat/ziggurat.dif\"},{\"original\":\"missions/multiplayer/Zenith/zenith.mis\",\"path\":\"missions/multiplayer/zenith/zenith.mis\"},{\"original\":\"missions/multiplayer/Zenith/zenith.dif\",\"path\":\"missions/multiplayer/zenith/zenith.dif\"},{\"original\":\"missions/multiplayer/Walled Sprawl/sprawl_walled.mis\",\"path\":\"missions/multiplayer/walled sprawl/sprawl_walled.mis\"},{\"original\":\"missions/multiplayer/Walled Sprawl/sprawl_walled.dif\",\"path\":\"missions/multiplayer/walled sprawl/sprawl_walled.dif\"},{\"original\":\"missions/multiplayer/Vortex/vortexeffect.mis\",\"path\":\"missions/multiplayer/vortex/vortexeffect.mis\"},{\"original\":\"missions/multiplayer/Vortex/vortexeffect.dif\",\"path\":\"missions/multiplayer/vortex/vortexeffect.dif\"},{\"original\":\"missions/multiplayer/Triumvirate/triumvirate.mis\",\"path\":\"missions/multiplayer/triumvirate/triumvirate.mis\"},{\"original\":\"missions/multiplayer/Triumvirate/triumvirate.dif\",\"path\":\"missions/multiplayer/triumvirate/triumvirate.dif\"},{\"original\":\"missions/multiplayer/Spires/spires.mis\",\"path\":\"missions/multiplayer/spires/spires.mis\"},{\"original\":\"missions/multiplayer/Spires/spires.dif\",\"path\":\"missions/multiplayer/spires/spires.dif\"},{\"original\":\"missions/multiplayer/Promontory/promontory.mis\",\"path\":\"missions/multiplayer/promontory/promontory.mis\"},{\"original\":\"missions/multiplayer/Promontory/promontory.dif\",\"path\":\"missions/multiplayer/promontory/promontory.dif\"},{\"original\":\"missions/multiplayer/Playground/playground.mis\",\"path\":\"missions/multiplayer/playground/playground.mis\"},{\"original\":\"missions/multiplayer/Playground/playground.dif\",\"path\":\"missions/multiplayer/playground/playground.dif\"},{\"original\":\"missions/multiplayer/Open Sprawl/sprawl_open.mis\",\"path\":\"missions/multiplayer/open sprawl/sprawl_open.mis\"},{\"original\":\"missions/multiplayer/Open Sprawl/sprawl_open.dif\",\"path\":\"missions/multiplayer/open sprawl/sprawl_open.dif\"},{\"original\":\"missions/multiplayer/Marbleitup/marbleitup.mis\",\"path\":\"missions/multiplayer/marbleitup/marbleitup.mis\"},{\"original\":\"missions/multiplayer/Marbleitup/marbleitup.dif\",\"path\":\"missions/multiplayer/marbleitup/marbleitup.dif\"},{\"original\":\"missions/multiplayer/Marble City 2/marblecity2.mis\",\"path\":\"missions/multiplayer/marble city 2/marblecity2.mis\"},{\"original\":\"missions/multiplayer/Marble City 2/marblecity2.dif\",\"path\":\"missions/multiplayer/marble city 2/marblecity2.dif\"},{\"original\":\"missions/multiplayer/KingOfTheMarble/king.mis\",\"path\":\"missions/multiplayer/kingofthemarble/king.mis\"},{\"original\":\"missions/multiplayer/KingOfTheMarble/king.dif\",\"path\":\"missions/multiplayer/kingofthemarble/king.dif\"},{\"original\":\"missions/multiplayer/ForkHunt/fork_hunt.mis\",\"path\":\"missions/multiplayer/forkhunt/fork_hunt.mis\"},{\"original\":\"missions/multiplayer/Epicenter/epicenter.mis\",\"path\":\"missions/multiplayer/epicenter/epicenter.mis\"},{\"original\":\"missions/multiplayer/Epicenter/epicenter.dif\",\"path\":\"missions/multiplayer/epicenter/epicenter.dif\"},{\"original\":\"missions/multiplayer/Core/core.mis\",\"path\":\"missions/multiplayer/core/core.mis\"},{\"original\":\"missions/multiplayer/Core/core.dif\",\"path\":\"missions/multiplayer/core/core.dif\"},{\"original\":\"missions/multiplayer/Concentric/concentric_holes.dif\",\"path\":\"missions/multiplayer/concentric/concentric_holes.dif\"},{\"original\":\"missions/multiplayer/Concentric/concentric.mis\",\"path\":\"missions/multiplayer/concentric/concentric.mis\"},{\"original\":\"missions/multiplayer/Bowl/bowl.mis\",\"path\":\"missions/multiplayer/bowl/bowl.mis\"},{\"original\":\"missions/multiplayer/Bowl/bowl.dif\",\"path\":\"missions/multiplayer/bowl/bowl.dif\"},{\"original\":\"missions/multiplayer/Blastclub/blastclub.mis\",\"path\":\"missions/multiplayer/blastclub/blastclub.mis\"},{\"original\":\"missions/multiplayer/Blastclub/blastclub.dif\",\"path\":\"missions/multiplayer/blastclub/blastclub.dif\"},{\"original\":\"missions/multiplayer/BattleCube/battle_cube_scrum.mis\",\"path\":\"missions/multiplayer/battlecube/battle_cube_scrum.mis\"},{\"original\":\"missions/multiplayer/BattleCube/battle_cube_scrum.dif\",\"path\":\"missions/multiplayer/battlecube/battle_cube_scrum.dif\"},{\"original\":\"missions/multiplayer/AllAngles/allangles.dif\",\"path\":\"missions/multiplayer/allangles/allangles.dif\"},{\"original\":\"missions/multiplayer/AllAngles/AllAngles.mis\",\"path\":\"missions/multiplayer/allangles/allangles.mis\"},{\"original\":\"missions/intermediate/plumbing/plumbing.mis\",\"path\":\"missions/intermediate/plumbing/plumbing.mis\"},{\"original\":\"missions/intermediate/plumbing/plumbing.dif\",\"path\":\"missions/intermediate/plumbing/plumbing.dif\"},{\"original\":\"missions/intermediate/Whirl/whirl.mis\",\"path\":\"missions/intermediate/whirl/whirl.mis\"},{\"original\":\"missions/intermediate/Whirl/whirl.dif\",\"path\":\"missions/intermediate/whirl/whirl.dif\"},{\"original\":\"missions/intermediate/Urban Jungle/urban.mis\",\"path\":\"missions/intermediate/urban jungle/urban.mis\"},{\"original\":\"missions/intermediate/Urban Jungle/urban.dif\",\"path\":\"missions/intermediate/urban jungle/urban.dif\"},{\"original\":\"missions/intermediate/Tree House/treehouse.dif\",\"path\":\"missions/intermediate/tree house/treehouse.dif\"},{\"original\":\"missions/intermediate/Tree House/treeHouse.mis\",\"path\":\"missions/intermediate/tree house/treehouse.mis\"},{\"original\":\"missions/intermediate/Timely Ascent/ascend.mis\",\"path\":\"missions/intermediate/timely ascent/ascend.mis\"},{\"original\":\"missions/intermediate/Timely Ascent/ascend.dif\",\"path\":\"missions/intermediate/timely ascent/ascend.dif\"},{\"original\":\"missions/intermediate/Spork in the Road/sporkintheroad.mis\",\"path\":\"missions/intermediate/spork in the road/sporkintheroad.mis\"},{\"original\":\"missions/intermediate/Spork in the Road/sporkintheroad.dif\",\"path\":\"missions/intermediate/spork in the road/sporkintheroad.dif\"},{\"original\":\"missions/intermediate/Skyscraper/skyscraper.mis\",\"path\":\"missions/intermediate/skyscraper/skyscraper.mis\"},{\"original\":\"missions/intermediate/Skyscraper/skyscraper.dif\",\"path\":\"missions/intermediate/skyscraper/skyscraper.dif\"},{\"original\":\"missions/intermediate/Skate to the top/skate.mis\",\"path\":\"missions/intermediate/skate to the top/skate.mis\"},{\"original\":\"missions/intermediate/Skate to the top/skate.dif\",\"path\":\"missions/intermediate/skate to the top/skate.dif\"},{\"original\":\"missions/intermediate/Road less travelled/lesstravel.mis\",\"path\":\"missions/intermediate/road less travelled/lesstravel.mis\"},{\"original\":\"missions/intermediate/Road less travelled/lesstravel.dif\",\"path\":\"missions/intermediate/road less travelled/lesstravel.dif\"},{\"original\":\"missions/intermediate/Points of the Compass/compasspoints.mis\",\"path\":\"missions/intermediate/points of the compass/compasspoints.mis\"},{\"original\":\"missions/intermediate/Points of the Compass/compasspoints.dif\",\"path\":\"missions/intermediate/points of the compass/compasspoints.dif\"},{\"original\":\"missions/intermediate/Obstacle Course/obstacle.mis\",\"path\":\"missions/intermediate/obstacle course/obstacle.mis\"},{\"original\":\"missions/intermediate/Obstacle Course/obstacle.dif\",\"path\":\"missions/intermediate/obstacle course/obstacle.dif\"},{\"original\":\"missions/intermediate/Mudslide/mudslide.mis\",\"path\":\"missions/intermediate/mudslide/mudslide.mis\"},{\"original\":\"missions/intermediate/Mudslide/mudslide.dif\",\"path\":\"missions/intermediate/mudslide/mudslide.dif\"},{\"original\":\"missions/intermediate/Mountaintop Retreat/mountaintop.mis\",\"path\":\"missions/intermediate/mountaintop retreat/mountaintop.mis\"},{\"original\":\"missions/intermediate/Mountaintop Retreat/mountaintop.dif\",\"path\":\"missions/intermediate/mountaintop retreat/mountaintop.dif\"},{\"original\":\"missions/intermediate/Hop Skip and Jump/hopskipjump.mis\",\"path\":\"missions/intermediate/hop skip and jump/hopskipjump.mis\"},{\"original\":\"missions/intermediate/Hop Skip and Jump/hopskipjump.dif\",\"path\":\"missions/intermediate/hop skip and jump/hopskipjump.dif\"},{\"original\":\"missions/intermediate/Great Divide/greatdivide2.dif\",\"path\":\"missions/intermediate/great divide/greatdivide2.dif\"},{\"original\":\"missions/intermediate/Great Divide/greatdivide.mis\",\"path\":\"missions/intermediate/great divide/greatdivide.mis\"},{\"original\":\"missions/intermediate/Gauntlet/gauntlet.mis\",\"path\":\"missions/intermediate/gauntlet/gauntlet.mis\"},{\"original\":\"missions/intermediate/Gauntlet/gauntlet.dif\",\"path\":\"missions/intermediate/gauntlet/gauntlet.dif\"},{\"original\":\"missions/intermediate/Duality/duality.mis\",\"path\":\"missions/intermediate/duality/duality.mis\"},{\"original\":\"missions/intermediate/Duality/duality.dif\",\"path\":\"missions/intermediate/duality/duality.dif\"},{\"original\":\"missions/intermediate/Black Diamond/blackdiamondc.dif\",\"path\":\"missions/intermediate/black diamond/blackdiamondc.dif\"},{\"original\":\"missions/intermediate/Black Diamond/blackdiamondb.dif\",\"path\":\"missions/intermediate/black diamond/blackdiamondb.dif\"},{\"original\":\"missions/intermediate/Black Diamond/blackdiamonda.dif\",\"path\":\"missions/intermediate/black diamond/blackdiamonda.dif\"},{\"original\":\"missions/intermediate/Black Diamond/blackdiamond.mis\",\"path\":\"missions/intermediate/black diamond/blackdiamond.mis\"},{\"original\":\"missions/intermediate/Around the world in 30 Seconds/aroundtheworld.mis\",\"path\":\"missions/intermediate/around the world in 30 seconds/aroundtheworld.mis\"},{\"original\":\"missions/intermediate/Around the world in 30 Seconds/aroundtheworld.dif\",\"path\":\"missions/intermediate/around the world in 30 seconds/aroundtheworld.dif\"},{\"original\":\"missions/intermediate/Aim High/aimhigh.mis\",\"path\":\"missions/intermediate/aim high/aimhigh.mis\"},{\"original\":\"missions/intermediate/Aim High/aimhigh.dif\",\"path\":\"missions/intermediate/aim high/aimhigh.dif\"},{\"original\":\"missions/custom/_\",\"path\":\"missions/custom/_\"},{\"original\":\"missions/beginner/Winding Road/windingroad.mis\",\"path\":\"missions/beginner/winding road/windingroad.mis\"},{\"original\":\"missions/beginner/Winding Road/windingroad.dif\",\"path\":\"missions/beginner/winding road/windingroad.dif\"},{\"original\":\"missions/beginner/Upward Spiral/upward.mis\",\"path\":\"missions/beginner/upward spiral/upward.mis\"},{\"original\":\"missions/beginner/Upward Spiral/upward.dif\",\"path\":\"missions/beginner/upward spiral/upward.dif\"},{\"original\":\"missions/beginner/Skate park/skatepark.dif\",\"path\":\"missions/beginner/skate park/skatepark.dif\"},{\"original\":\"missions/beginner/Skate park/skatePark.mis\",\"path\":\"missions/beginner/skate park/skatepark.mis\"},{\"original\":\"missions/beginner/Ramp Matrix/rampmatrix.mis\",\"path\":\"missions/beginner/ramp matrix/rampmatrix.mis\"},{\"original\":\"missions/beginner/Ramp Matrix/rampmatrix.dif\",\"path\":\"missions/beginner/ramp matrix/rampmatrix.dif\"},{\"original\":\"missions/beginner/Platform Party/platformparty.mis\",\"path\":\"missions/beginner/platform party/platformparty.mis\"},{\"original\":\"missions/beginner/Platform Party/platformparty.dif\",\"path\":\"missions/beginner/platform party/platformparty.dif\"},{\"original\":\"missions/beginner/Pitfalls/pitfall.mis\",\"path\":\"missions/beginner/pitfalls/pitfall.mis\"},{\"original\":\"missions/beginner/Pitfalls/pitfall.dif\",\"path\":\"missions/beginner/pitfalls/pitfall.dif\"},{\"original\":\"missions/beginner/MP Train/multiplayer_training.dif\",\"path\":\"missions/beginner/mp train/multiplayer_training.dif\"},{\"original\":\"missions/beginner/MP Train/mptrain.mis\",\"path\":\"missions/beginner/mp train/mptrain.mis\"},{\"original\":\"missions/beginner/Level Two/leveltwo.mis\",\"path\":\"missions/beginner/level two/leveltwo.mis\"},{\"original\":\"missions/beginner/Level Two/level_two.dif\",\"path\":\"missions/beginner/level two/level_two.dif\"},{\"original\":\"missions/beginner/Level Three/level_three.mis\",\"path\":\"missions/beginner/level three/level_three.mis\"},{\"original\":\"missions/beginner/Level Three/level_three.dif\",\"path\":\"missions/beginner/level three/level_three.dif\"},{\"original\":\"missions/beginner/Level Six/level_six.mis\",\"path\":\"missions/beginner/level six/level_six.mis\"},{\"original\":\"missions/beginner/Level Six/level_six.dif\",\"path\":\"missions/beginner/level six/level_six.dif\"},{\"original\":\"missions/beginner/Level One/levelone.mis\",\"path\":\"missions/beginner/level one/levelone.mis\"},{\"original\":\"missions/beginner/Level One/level_one.dif\",\"path\":\"missions/beginner/level one/level_one.dif\"},{\"original\":\"missions/beginner/Level Four/level_four.mis\",\"path\":\"missions/beginner/level four/level_four.mis\"},{\"original\":\"missions/beginner/Level Four/level_four.dif\",\"path\":\"missions/beginner/level four/level_four.dif\"},{\"original\":\"missions/beginner/Level Five/level_five.mis\",\"path\":\"missions/beginner/level five/level_five.mis\"},{\"original\":\"missions/beginner/Level Five/level_five.dif\",\"path\":\"missions/beginner/level five/level_five.dif\"},{\"original\":\"missions/beginner/Jump/jumpjumpjump.mis\",\"path\":\"missions/beginner/jump/jumpjumpjump.mis\"},{\"original\":\"missions/beginner/Jump/jumpjumpjump.dif\",\"path\":\"missions/beginner/jump/jumpjumpjump.dif\"},{\"original\":\"missions/beginner/Hazards/hazards.mis\",\"path\":\"missions/beginner/hazards/hazards.mis\"},{\"original\":\"missions/beginner/Hazards/hazards.dif\",\"path\":\"missions/beginner/hazards/hazards.dif\"},{\"original\":\"missions/beginner/Half Pipe/halfpipe.mis\",\"path\":\"missions/beginner/half pipe/halfpipe.mis\"},{\"original\":\"missions/beginner/Half Pipe/halfpipe.dif\",\"path\":\"missions/beginner/half pipe/halfpipe.dif\"},{\"original\":\"missions/beginner/Gyro Training/gyro_train.mis\",\"path\":\"missions/beginner/gyro training/gyro_train.mis\"},{\"original\":\"missions/beginner/Gyro Training/gyro_train.dif\",\"path\":\"missions/beginner/gyro training/gyro_train.dif\"},{\"original\":\"missions/beginner/Gravity Helix/gravity.mis\",\"path\":\"missions/beginner/gravity helix/gravity.mis\"},{\"original\":\"missions/beginner/Gravity Helix/gravity.dif\",\"path\":\"missions/beginner/gravity helix/gravity.dif\"},{\"original\":\"missions/beginner/Friction/friction.mis\",\"path\":\"missions/beginner/friction/friction.mis\"},{\"original\":\"missions/beginner/Friction/friction.dif\",\"path\":\"missions/beginner/friction/friction.dif\"},{\"original\":\"missions/beginner/Early Frost/earlyfrost.mis\",\"path\":\"missions/beginner/early frost/earlyfrost.mis\"},{\"original\":\"missions/beginner/Early Frost/earlyfrost.dif\",\"path\":\"missions/beginner/early frost/earlyfrost.dif\"},{\"original\":\"missions/advanced/WilloWisp/willowisp.mis\",\"path\":\"missions/advanced/willowisp/willowisp.mis\"},{\"original\":\"missions/advanced/WilloWisp/willowisp.dif\",\"path\":\"missions/advanced/willowisp/willowisp.dif\"},{\"original\":\"missions/advanced/Under Construction/construction.mis\",\"path\":\"missions/advanced/under construction/construction.mis\"},{\"original\":\"missions/advanced/Under Construction/construction.dif\",\"path\":\"missions/advanced/under construction/construction.dif\"},{\"original\":\"missions/advanced/Threefold Race/threefoldrace.mis\",\"path\":\"missions/advanced/threefold race/threefoldrace.mis\"},{\"original\":\"missions/advanced/Threefold Race/3foldrace.dif\",\"path\":\"missions/advanced/threefold race/3foldrace.dif\"},{\"original\":\"missions/advanced/Threefold Maze/threefoldmaze.mis\",\"path\":\"missions/advanced/threefold maze/threefoldmaze.mis\"},{\"original\":\"missions/advanced/Threefold Maze/3foldmaze.dif\",\"path\":\"missions/advanced/threefold maze/3foldmaze.dif\"},{\"original\":\"missions/advanced/Survival of the Fittest/survival.mis\",\"path\":\"missions/advanced/survival of the fittest/survival.mis\"},{\"original\":\"missions/advanced/Survival of the Fittest/survival.dif\",\"path\":\"missions/advanced/survival of the fittest/survival.dif\"},{\"original\":\"missions/advanced/Slick Slide/slickslide.mis\",\"path\":\"missions/advanced/slick slide/slickslide.mis\"},{\"original\":\"missions/advanced/Slick Slide/slickslide.dif\",\"path\":\"missions/advanced/slick slide/slickslide.dif\"},{\"original\":\"missions/advanced/Schadenfreude/schadenfreude.mis\",\"path\":\"missions/advanced/schadenfreude/schadenfreude.mis\"},{\"original\":\"missions/advanced/Schadenfreude/schadenfreude.dif\",\"path\":\"missions/advanced/schadenfreude/schadenfreude.dif\"},{\"original\":\"missions/advanced/Scaffold/scaffold.mis\",\"path\":\"missions/advanced/scaffold/scaffold.mis\"},{\"original\":\"missions/advanced/Scaffold/scaffold.dif\",\"path\":\"missions/advanced/scaffold/scaffold.dif\"},{\"original\":\"missions/advanced/Ramps Reloaded/reloaded.mis\",\"path\":\"missions/advanced/ramps reloaded/reloaded.mis\"},{\"original\":\"missions/advanced/Ramps Reloaded/reloaded.dif\",\"path\":\"missions/advanced/ramps reloaded/reloaded.dif\"},{\"original\":\"missions/advanced/Ordeal/ordeal.mis\",\"path\":\"missions/advanced/ordeal/ordeal.mis\"},{\"original\":\"missions/advanced/Ordeal/ordeal.dif\",\"path\":\"missions/advanced/ordeal/ordeal.dif\"},{\"original\":\"missions/advanced/Natural Selection/selection.mis\",\"path\":\"missions/advanced/natural selection/selection.mis\"},{\"original\":\"missions/advanced/Natural Selection/natural_selection.dif\",\"path\":\"missions/advanced/natural selection/natural_selection.dif\"},{\"original\":\"missions/advanced/King of the Mountain/kingofthemountain.mis\",\"path\":\"missions/advanced/king of the mountain/kingofthemountain.mis\"},{\"original\":\"missions/advanced/King of the Mountain/kingofthemountain.dif\",\"path\":\"missions/advanced/king of the mountain/kingofthemountain.dif\"},{\"original\":\"missions/advanced/Half Pipe Elite/halfpipe_elite.dif\",\"path\":\"missions/advanced/half pipe elite/halfpipe_elite.dif\"},{\"original\":\"missions/advanced/Half Pipe Elite/halfpipe2.mis\",\"path\":\"missions/advanced/half pipe elite/halfpipe2.mis\"},{\"original\":\"missions/advanced/Extreme Skiing/ski.mis\",\"path\":\"missions/advanced/extreme skiing/ski.mis\"},{\"original\":\"missions/advanced/Extreme Skiing/ski.dif\",\"path\":\"missions/advanced/extreme skiing/ski.dif\"},{\"original\":\"missions/advanced/Endurance/endurance.mis\",\"path\":\"missions/advanced/endurance/endurance.mis\"},{\"original\":\"missions/advanced/Endurance/endurance.dif\",\"path\":\"missions/advanced/endurance/endurance.dif\"},{\"original\":\"missions/advanced/Divergence/divergence.mis\",\"path\":\"missions/advanced/divergence/divergence.mis\"},{\"original\":\"missions/advanced/Divergence/divergence.dif\",\"path\":\"missions/advanced/divergence/divergence.dif\"},{\"original\":\"missions/advanced/Daedalus/daedalus.mis\",\"path\":\"missions/advanced/daedalus/daedalus.mis\"},{\"original\":\"missions/advanced/Daedalus/daedalus.dif\",\"path\":\"missions/advanced/daedalus/daedalus.dif\"},{\"original\":\"missions/advanced/Cube Root/cube.mis\",\"path\":\"missions/advanced/cube root/cube.mis\"},{\"original\":\"missions/advanced/Cube Root/cube.dif\",\"path\":\"missions/advanced/cube root/cube.dif\"},{\"original\":\"missions/advanced/Battlements/battlements.mis\",\"path\":\"missions/advanced/battlements/battlements.mis\"},{\"original\":\"missions/advanced/Battlements/battlements.dif\",\"path\":\"missions/advanced/battlements/battlements.dif\"},{\"original\":\"missions/advanced/Acrobat/acrobat.mis\",\"path\":\"missions/advanced/acrobat/acrobat.mis\"},{\"original\":\"missions/advanced/Acrobat/acrobat.dif\",\"path\":\"missions/advanced/acrobat/acrobat.dif\"},{\"original\":\"icons/icon-96.png\",\"path\":\"icons/icon-96.png\"},{\"original\":\"icons/icon-64.png\",\"path\":\"icons/icon-64.png\"},{\"original\":\"icons/icon-512.png\",\"path\":\"icons/icon-512.png\"},{\"original\":\"icons/icon-48.png\",\"path\":\"icons/icon-48.png\"},{\"original\":\"icons/icon-32.png\",\"path\":\"icons/icon-32.png\"},{\"original\":\"icons/icon-256.png\",\"path\":\"icons/icon-256.png\"},{\"original\":\"icons/icon-192.png\",\"path\":\"icons/icon-192.png\"},{\"original\":\"icons/icon-180.png\",\"path\":\"icons/icon-180.png\"},{\"original\":\"icons/icon-144.png\",\"path\":\"icons/icon-144.png\"},{\"original\":\"icons/icon-128.png\",\"path\":\"icons/icon-128.png\"},{\"original\":\"font/charset.txt\",\"path\":\"font/charset.txt\"},{\"original\":\"font/arial.fnt\",\"path\":\"tmp/font/arial.bfnt\"},{\"original\":\"font/MarkerFelt.png\",\"path\":\"font/markerfelt.png\"},{\"original\":\"font/MarkerFelt.fnt\",\"path\":\"tmp/font/markerfelt.bfnt\"},{\"original\":\"font/LucidaConsole.png\",\"path\":\"font/lucidaconsole.png\"},{\"original\":\"font/Lucida Console.fnt\",\"path\":\"tmp/font/lucida console.bfnt\"},{\"original\":\"font/ExpoSDF.png\",\"path\":\"font/exposdf.png\"},{\"original\":\"font/EXPON.fnt\",\"path\":\"tmp/font/expon.bfnt\"},{\"original\":\"font/EXPON.TTF\",\"path\":\"font/expon.ttf\"},{\"original\":\"font/DomCasualRegular.otf\",\"path\":\"font/domcasualregular.otf\"},{\"original\":\"font/DomCasualDSDF.png\",\"path\":\"font/domcasualdsdf.png\"},{\"original\":\"font/DomCasualD.ttf\",\"path\":\"font/domcasuald.ttf\"},{\"original\":\"font/DomCasualD.fnt\",\"path\":\"tmp/font/domcasuald.bfnt\"},{\"original\":\"font/ColiseumRR.fnt\",\"path\":\"tmp/font/coliseumrr.bfnt\"},{\"original\":\"font/ColiseumRR Medium.ttf\",\"path\":\"font/coliseumrr medium.ttf\"},{\"original\":\"font/Coliseum.png\",\"path\":\"font/coliseum.png\"},{\"original\":\"font/ArialSDF.png\",\"path\":\"font/arialsdf.png\"},{\"original\":\"font/ArialBold.png\",\"path\":\"font/arialbold.png\"},{\"original\":\"font/Arial Bold.ttf\",\"path\":\"font/arial bold.ttf\"},{\"original\":\"font/Arial Bold.fnt\",\"path\":\"tmp/font/arial bold.bfnt\"}]"));
		let mloader = new fs_ManifestLoader(mfileSystem);
		new fs_ManifestProgress(mloader,null,function() {
			src_ResourceLoader.loader = mloader;
			src_ResourceLoader.fileSystem = mfileSystem;
			src_ResourceLoader.initialized = true;
			onLoadedFunc();
		},scene2d);
		src_ResourceLoader.loader = mloader;
		src_ResourceLoader.fileSystem = mfileSystem;
		let loadg = new h2d_Text(hxd_res_DefaultFont.get());
		loadg.set_textAlign(h2d_Align.Center);
		loadg.set_textColor(16777215);
		let v = scene2d.height / 2;
		loadg.posChanged = true;
		loadg.y = v;
		let v1 = scene2d.width / 2;
		loadg.posChanged = true;
		loadg.x = v1;
		let v2 = loadg.scaleX * 2.5;
		loadg.posChanged = true;
		loadg.scaleX = v2;
		let v3 = loadg.scaleY * 2.5;
		loadg.posChanged = true;
		loadg.scaleY = v3;
		scene2d.addChild(loadg);
		let worker = new src_ResourceLoaderWorker(onLoadedFunc);
		worker.addTask(function(fwd) {
			loadg.set_text("Loading UI..");
			fwd();
		});
		worker.addTask(function(fwd) {
			src_ResourceLoader.preloadUI(fwd);
		});
		worker.addTask(function(fwd) {
			loadg.set_text("Loading Textures..");
			fwd();
		});
		worker.addTask(function(fwd) {
			src_ResourceLoader.preloadTextures(fwd);
		});
		worker.addTask(function(fwd) {
			loadg.set_text("Loading Missions..");
			fwd();
		});
		worker.addTask(function(fwd) {
			src_ResourceLoader.preloadMisFiles(fwd);
		});
		worker.addTask(function(fwd) {
			loadg.set_text("Loading Music..");
			fwd();
		});
		worker.addTask(function(fwd) {
			src_ResourceLoader.preloadMusic(fwd);
		});
		worker.addTask(function(fwd) {
			loadg.set_text("Loading Sounds..");
			fwd();
		});
		worker.addTask(function(fwd) {
			src_ResourceLoader.preloadUISounds(fwd);
		});
		worker.addTask(function(fwd) {
			loadg.set_text("Loading Shapes..");
			fwd();
		});
		worker.addTask(function(fwd) {
			src_ResourceLoader.preloadShapes(fwd);
		});
		worker.addTask(function(fwd) {
			scene2d.removeChild(loadg);
			src_ResourceLoader.initialized = true;
			fwd();
		});
		worker.run();
	}
	static preloadUI(onFinish) {
		let toloadfiles = [];
		let toloaddirs = [];
		let filestats = src_ResourceLoader.fileSystem.dir("font").concat(src_ResourceLoader.fileSystem.dir("ui"));
		let _g = 0;
		while(_g < filestats.length) {
			let file = filestats[_g];
			++_g;
			if(file.get_isDirectory()) {
				toloaddirs.push(file);
			} else {
				toloadfiles.push(file);
			}
		}
		while(toloaddirs.length > 0) {
			let nextdir = toloaddirs.pop();
			let _g = 0;
			let _g1 = src_ResourceLoader.fileSystem.dir(nextdir.get_path().substring(2));
			while(_g < _g1.length) {
				let file = _g1[_g];
				++_g;
				if(file.get_isDirectory()) {
					toloaddirs.push(file);
				} else {
					toloadfiles.push(file);
				}
			}
		}
		let worker = new src_ResourceLoaderWorker(onFinish);
		let _g1 = 0;
		while(_g1 < toloadfiles.length) {
			let file = toloadfiles[_g1];
			++_g1;
			worker.addTaskParallel(function(fwd) {
				file.load(fwd);
			});
		}
		worker.run();
	}
	static preloadMisFiles(onFinish) {
		let toloadfiles = [];
		let toloaddirs = [];
		let filestats = src_ResourceLoader.fileSystem.dir("missions");
		let _g = 0;
		while(_g < filestats.length) {
			let file = filestats[_g];
			++_g;
			if(file.get_isDirectory()) {
				toloaddirs.push(file);
			} else {
				toloadfiles.push(file);
			}
		}
		while(toloaddirs.length > 0) {
			let nextdir = toloaddirs.pop();
			let _g = 0;
			let _g1 = src_ResourceLoader.fileSystem.dir(nextdir.get_path().substring(2));
			while(_g < _g1.length) {
				let file = _g1[_g];
				++_g;
				if(file.get_isDirectory()) {
					toloaddirs.push(file);
				} else if(file.get_extension() == "mis") {
					toloadfiles.push(file);
				}
			}
		}
		let worker = new src_ResourceLoaderWorker(onFinish);
		worker.loadFile("englishStrings.inf");
		let _g1 = 0;
		while(_g1 < toloadfiles.length) {
			let file = toloadfiles[_g1];
			++_g1;
			worker.addTaskParallel(function(fwd) {
				file.load(fwd);
			});
		}
		worker.run();
	}
	static preloadMusic(onFinish) {
		let worker = new src_ResourceLoaderWorker(onFinish);
		worker.loadFile("sound/music/Tim Trance.ogg");
		worker.run();
	}
	static preloadUISounds(onFinish) {
		let worker = new src_ResourceLoaderWorker(onFinish);
		worker.loadFile("sound/testing.wav");
		worker.loadFile("sound/buttonover.wav");
		worker.loadFile("sound/buttonpress.wav");
		worker.run();
	}
	static preloadTextures(onFinish) {
		let toloadfiles = [];
		let filestats = src_ResourceLoader.fileSystem.dir("textures");
		let _g = 0;
		while(_g < filestats.length) {
			let file = filestats[_g];
			++_g;
			toloadfiles.push(file);
		}
		filestats = src_ResourceLoader.fileSystem.dir("shapes/structures");
		let _g1 = 0;
		while(_g1 < filestats.length) {
			let file = filestats[_g1];
			++_g1;
			toloadfiles.push(file);
		}
		filestats = src_ResourceLoader.fileSystem.dir("shapes/astrolabe");
		let _g2 = 0;
		while(_g2 < filestats.length) {
			let file = filestats[_g2];
			++_g2;
			toloadfiles.push(file);
		}
		filestats = src_ResourceLoader.fileSystem.dir("skies");
		let _g3 = 0;
		while(_g3 < filestats.length) {
			let file = filestats[_g3];
			++_g3;
			toloadfiles.push(file);
		}
		let worker = new src_ResourceLoaderWorker(onFinish);
		let _g4 = 0;
		while(_g4 < toloadfiles.length) {
			let file = toloadfiles[_g4];
			++_g4;
			worker.addTaskParallel(function(fwd) {
				file.load(fwd);
			});
		}
		worker.run();
	}
	static preloadShapes(onFinish) {
		let toloadfiles = [StringTools.replace(src_Settings.optionsSettings.marbleModel,"data/",""),"particles/star.png","particles/smoke.png","particles/burst.png","sound/rolling_hard.wav","sound/sliding.wav","sound/use_gyrocopter.wav","sound/bouncehard1.wav","sound/bouncehard2.wav","sound/bouncehard3.wav","sound/bouncehard4.wav","sound/mega_roll.wav","shapes/balls/marble20.normal.png","shapes/balls/marble18.normal.png","shapes/balls/marble01.normal.png","shapes/balls/marble02.normal.png"];
		let worker = new src_ResourceLoaderWorker(onFinish);
		let _g = 0;
		while(_g < toloadfiles.length) {
			let file = toloadfiles[_g];
			++_g;
			worker.loadFile(file);
		}
		worker.run();
	}
	static getProperFilepath(rawElementPath) {
		let fname = rawElementPath.substring(rawElementPath.lastIndexOf("/") + 1);
		rawElementPath = rawElementPath.toLowerCase();
		let path = StringTools.replace(rawElementPath.substring(rawElementPath.indexOf("data/")),"\"","");
		if(path.includes("interiors_mbg/")) {
			path = StringTools.replace(path,"interiors_mbg/","interiors/");
		}
		let dirpath = path.substring(0,path.lastIndexOf("/") + 1);
		path = StringTools.replace(path,"data/","");
		if(src_ResourceLoader.exists(path)) {
			return path;
		}
		if(src_ResourceLoader.exists(dirpath + fname)) {
			return dirpath + fname;
		}
		return "";
	}
	static load(path) {
		path = StringTools.replace(path,"data/","");
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.zipFilesystem.h,path.toLowerCase())) {
			return new hxd_res_Any(src_ResourceLoader.loader,src_ResourceLoader.zipFilesystem.h[path.toLowerCase()]);
		}
		src_ResourceLoader.loadedFiles.h[path] = true;
		return src_ResourceLoader.loader.load(path);
	}
	static loadInterior(path) {
		path = StringTools.replace(path,"data/","");
		let itr;
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.zipFilesystem.h,path.toLowerCase())) {
			itr = dif_Dif.LoadFromBuffer(src_ResourceLoader.zipFilesystem.h[path.toLowerCase()].getBytes());
		} else {
			itr = dif_Dif.LoadFromBuffer(src_ResourceLoader.fileSystem.get(path).getBytes());
		}
		let itrresource = new src_Resource(itr,path,src_ResourceLoader.interiorResources,function(dif) {
		});
		src_ResourceLoader.interiorResources.h[path] = itrresource;
		return itrresource;
	}
	static loadDts(path) {
		path = src_ResourceLoader.getProperFilepath(path);
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.dtsResources.h,path)) {
			return src_ResourceLoader.dtsResources.h[path];
		} else {
			let dts = new dts_DtsFile();
			dts.read(path);
			let dtsresource = new src_Resource(dts,path,src_ResourceLoader.dtsResources,function(dtsFile) {
			});
			src_ResourceLoader.dtsResources.h[path] = dtsresource;
			return dtsresource;
		}
	}
	static getTexture(path) {
		path = src_ResourceLoader.getProperFilepath(path);
		return src_ResourceLoader.getTextureRealpath(path);
	}
	static getTextureRealpath(path) {
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.zipFilesystem.h,path.toLowerCase())) {
			if(path.toLowerCase().endsWith(".bmp")) {
				let bmpContents = src_ResourceLoader.zipFilesystem.h[path.toLowerCase()];
				let bmpreader = new format_bmp_Reader(new haxe_io_BytesInput(bmpContents.getBytes()));
				let bmpdata = bmpreader.read();
				let bbuf = new haxe_io_BytesBuffer();
				let i = 0;
				while(i < bmpdata.pixels.length) {
					bbuf.addByte(bmpdata.pixels.b[i]);
					bbuf.addByte(bmpdata.pixels.b[i + 1]);
					bbuf.addByte(bmpdata.pixels.b[i + 2]);
					bbuf.addByte(1);
					i += 3;
				}
				let pixs = new hxd_Pixels(bmpdata.header.width,bmpdata.header.height,bbuf.getBytes(),hxd_PixelFormat.BGRA);
				let tex = h3d_mat_Texture.fromPixels(pixs);
				tex.set_mipMap(h3d_mat_MipMap.Nearest);
				tex.flags |= 4;
				let textureresource = new src_Resource(tex,path,src_ResourceLoader.textureCache,function(tex) {
					tex.dispose();
				});
				src_ResourceLoader.textureCache.h[path] = textureresource;
				return textureresource;
			} else {
				let img = new hxd_res_Image(src_ResourceLoader.zipFilesystem.h[path.toLowerCase()]);
				hxd_res_Image.setupTextureFlags = function(texObj) {
					texObj.flags |= 4;
				};
				let tex = img.toTexture();
				tex.set_mipMap(h3d_mat_MipMap.Nearest);
				let textureresource = new src_Resource(tex,path,src_ResourceLoader.textureCache,function(tex) {
					tex.dispose();
				});
				src_ResourceLoader.textureCache.h[path] = textureresource;
				return textureresource;
			}
		}
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.textureCache.h,path)) {
			return src_ResourceLoader.textureCache.h[path];
		}
		if(src_ResourceLoader.fileSystem.exists(path)) {
			if(path.toLowerCase().endsWith(".bmp")) {
				let bmpContents = src_ResourceLoader.zipFilesystem.h[path.toLowerCase()];
				let bmpreader = new format_bmp_Reader(new haxe_io_BytesInput(bmpContents.getBytes()));
				let bmpdata = bmpreader.read();
				let bbuf = new haxe_io_BytesBuffer();
				let i = 0;
				while(i < bmpdata.pixels.length) {
					bbuf.addByte(bmpdata.pixels.b[i]);
					bbuf.addByte(bmpdata.pixels.b[i + 1]);
					bbuf.addByte(bmpdata.pixels.b[i + 2]);
					bbuf.addByte(1);
					i += 3;
				}
				let pixs = new hxd_Pixels(bmpdata.header.width,bmpdata.header.height,bbuf.getBytes(),hxd_PixelFormat.BGRA);
				pixs.setFlip(true);
				let tex = h3d_mat_Texture.fromPixels(pixs);
				tex.set_mipMap(h3d_mat_MipMap.Nearest);
				tex.flags |= 4;
				let textureresource = new src_Resource(tex,path,src_ResourceLoader.textureCache,function(tex) {
					tex.dispose();
				});
				src_ResourceLoader.textureCache.h[path] = textureresource;
				return textureresource;
			} else {
				let img = src_ResourceLoader.loader.load(path).toImage();
				hxd_res_Image.setupTextureFlags = function(texObj) {
					texObj.flags |= 4;
				};
				let tex = img.toTexture();
				tex.set_mipMap(h3d_mat_MipMap.Nearest);
				let textureresource = new src_Resource(tex,path,src_ResourceLoader.textureCache,function(tex) {
					tex.dispose();
				});
				src_ResourceLoader.textureCache.h[path] = textureresource;
				return textureresource;
			}
		}
		return null;
	}
	static getImagePixels(path) {
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.zipFilesystem.h,path.toLowerCase())) {
			if(path.toLowerCase().endsWith(".bmp")) {
				let bmpContents = src_ResourceLoader.zipFilesystem.h[path.toLowerCase()];
				let bmpreader = new format_bmp_Reader(new haxe_io_BytesInput(bmpContents.getBytes()));
				let bmpdata = bmpreader.read();
				let bbuf = new haxe_io_BytesBuffer();
				let i = 0;
				while(i < bmpdata.pixels.length) {
					bbuf.addByte(bmpdata.pixels.b[i]);
					bbuf.addByte(bmpdata.pixels.b[i + 1]);
					bbuf.addByte(bmpdata.pixels.b[i + 2]);
					bbuf.addByte(1);
					i += 3;
				}
				let pixs = new hxd_Pixels(bmpdata.header.width,bmpdata.header.height,bbuf.getBytes(),hxd_PixelFormat.BGRA);
				return pixs;
			} else {
				let img = new hxd_res_Image(src_ResourceLoader.zipFilesystem.h[path.toLowerCase()]);
				return img.getPixels();
			}
		}
		if(src_ResourceLoader.fileSystem.exists(path)) {
			if(path.toLowerCase().endsWith(".bmp")) {
				let bmpContents = src_ResourceLoader.zipFilesystem.h[path.toLowerCase()];
				let bmpreader = new format_bmp_Reader(new haxe_io_BytesInput(bmpContents.getBytes()));
				let bmpdata = bmpreader.read();
				let bbuf = new haxe_io_BytesBuffer();
				let i = 0;
				while(i < bmpdata.pixels.length) {
					bbuf.addByte(bmpdata.pixels.b[i]);
					bbuf.addByte(bmpdata.pixels.b[i + 1]);
					bbuf.addByte(bmpdata.pixels.b[i + 2]);
					bbuf.addByte(1);
					i += 3;
				}
				let pixs = new hxd_Pixels(bmpdata.header.width,bmpdata.header.height,bbuf.getBytes(),hxd_PixelFormat.BGRA);
				return pixs;
			} else {
				let img = src_ResourceLoader.loader.load(path).toImage();
				return img.getPixels();
			}
		}
		return null;
	}
	static getImage(path) {
		path = StringTools.replace(path,"data/","");
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.zipFilesystem.h,path.toLowerCase())) {
			let fentry = new hxd_res_Image(src_ResourceLoader.zipFilesystem.h[path.toLowerCase()]);
			let imageresource = new src_Resource(fentry,path,src_ResourceLoader.imageCache,function(img) {
			});
			src_ResourceLoader.imageCache.h[path] = imageresource;
			return imageresource;
		}
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.imageCache.h,path)) {
			return src_ResourceLoader.imageCache.h[path];
		}
		if(src_ResourceLoader.fileSystem.exists(path)) {
			let tex = src_ResourceLoader.loader.load(path).toImage();
			let imageresource = new src_Resource(tex,path,src_ResourceLoader.imageCache,function(img) {
			});
			src_ResourceLoader.imageCache.h[path] = imageresource;
			return imageresource;
		}
		return null;
	}
	static getAudio(path) {
		path = StringTools.replace(path,"data/","");
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.audioCache.h,path)) {
			return src_ResourceLoader.audioCache.h[path];
		}
		if(src_ResourceLoader.fileSystem.exists(path)) {
			let snd = src_ResourceLoader.loader.load(path).toSound();
			let audioresource = new src_Resource(snd,path,src_ResourceLoader.audioCache,function(snd) {
				snd.dispose();
			});
			src_ResourceLoader.audioCache.h[path] = audioresource;
			return audioresource;
		}
		return null;
	}
	static getResource(path,resourceAcquirerer,resourceCollector) {
		let res = resourceAcquirerer(path);
		if(res != null) {
			if(!resourceCollector.includes(res)) {
				res.acquire();
				resourceCollector.push(res);
			}
			return res.resource;
		}
		return null;
	}
	static getFileEntry(path) {
		path = StringTools.replace(path,"data/","");
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.zipFilesystem.h,path.toLowerCase())) {
			let fentry = src_ResourceLoader.zipFilesystem.h[path.toLowerCase()];
			return new hxd_res_Any(src_ResourceLoader.loader,fentry);
		}
		let file = src_ResourceLoader.loader.load(path);
		return file;
	}
	static exists(path) {
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.zipFilesystem.h,path.toLowerCase())) {
			return true;
		}
		return src_ResourceLoader.fileSystem.exists(path);
	}
	static getFullNamesOf(path) {
		path = StringTools.replace(path,"data/","");
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.zipFilesystem.h,path.toLowerCase() + ".jpg")) {
			return [path + ".jpg"];
		}
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.zipFilesystem.h,path.toLowerCase() + ".png")) {
			return [path + ".png"];
		}
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.zipFilesystem.h,path.toLowerCase() + ".bmp")) {
			return [path + ".bmp"];
		}
		let files = src_ResourceLoader.fileSystem.dir(haxe_io_Path.directory(path));
		let names = [];
		let fname = haxe_io_Path.withoutDirectory(path).toLowerCase();
		let _g = 0;
		while(_g < files.length) {
			let file = files[_g];
			++_g;
			let fname2 = file.name;
			if(haxe_io_Path.withoutExtension(fname2).toLowerCase() == fname || fname2.toLowerCase() == fname) {
				names.push(file.get_path());
			}
		}
		return names;
	}
	static loadZip(entries,prefix) {
		src_ResourceLoader.zipFilesystem.h = Object.create(null);
		let _g = 0;
		while(_g < entries.length) {
			let entry = entries[_g];
			++_g;
			let fname = prefix + entry.fileName.toLowerCase();
			fname = StringTools.replace(fname,"lbinteriors","interiors");
			if(src_ResourceLoader.exists(fname)) {
				continue;
			}
			src_Console.instance.addEntry("log","Loaded zip entry: " + fname);
			let zdata = entry.data;
			let zfe = new hxd_fs_BytesFileEntry(fname,zdata);
			src_ResourceLoader.zipFilesystem.h[fname] = zfe;
		}
	}
}
$hxClasses["src.ResourceLoader"] = src_ResourceLoader;
src_ResourceLoader.__name__ = "src.ResourceLoader";
class src_Resource {
	constructor(resource,identifier,resList,disposeFunc) {
		this.referenceCount = 0;
		this.resource = resource;
		this.resourceMap = resList;
		this.disposeFunc = disposeFunc;
		this.identifier = identifier;
	}
	acquire() {
		this.referenceCount++;
	}
	release() {
		this.referenceCount--;
		if(this.referenceCount == 0) {
			this.disposeFunc(this.resource);
			let key = this.identifier;
			let _this = this.resourceMap;
			if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
				delete(_this.h[key]);
			}
		}
	}
}
$hxClasses["src.Resource"] = src_Resource;
src_Resource.__name__ = "src.Resource";
Object.assign(src_Resource.prototype, {
	__class__: src_Resource
	,resource: null
	,identifier: null
	,referenceCount: null
	,resourceMap: null
	,disposeFunc: null
});
class src_ResourceLoaderWorker {
	constructor(onFinish) {
		this.parallelstarted = false;
		this.paralleltasks = [];
		this.tasks = [];
		this.onFinish = onFinish;
	}
	addTask(task) {
		this.tasks.push(task);
	}
	addTaskParallel(task) {
		this.paralleltasks.push(task);
	}
	run() {
		let _gthis = this;
		if(!this.parallelstarted && this.paralleltasks.length > 0) {
			this.parallelstarted = true;
			let taskcount = this.paralleltasks.length;
			let tasksdone = 0;
			let _g = 0;
			let _g1 = this.paralleltasks;
			while(_g < _g1.length) {
				let task = _g1[_g];
				++_g;
				task(function() {
					tasksdone += 1;
					if(tasksdone == taskcount) {
						_gthis.run();
					}
				});
			}
			return;
		}
		if(this.tasks.length > 0) {
			let task = this.tasks.shift();
			task(function() {
				if(_gthis.tasks.length > 0) {
					_gthis.run();
				} else {
					_gthis.onFinish();
				}
			});
		} else {
			this.onFinish();
		}
	}
	loadFile(path) {
		if(Object.prototype.hasOwnProperty.call(src_ResourceLoader.loadedFiles.h,path)) {
			return;
		}
		this.paralleltasks.push(function(fwd) {
			src_ResourceLoader.load(path).entry.load(fwd);
		});
	}
}
$hxClasses["src.ResourceLoaderWorker"] = src_ResourceLoaderWorker;
src_ResourceLoaderWorker.__name__ = "src.ResourceLoaderWorker";
Object.assign(src_ResourceLoaderWorker.prototype, {
	__class__: src_ResourceLoaderWorker
	,tasks: null
	,paralleltasks: null
	,onFinish: null
	,parallelstarted: null
});
class src_DifBuilder {
	static createDefaultMaterial(onFinish,baseTexture,normalTexture,shininess,specularColor,uvScaleFactor,half) {
		if(half == null) {
			half = false;
		}
		if(uvScaleFactor == null) {
			uvScaleFactor = 1;
		}
		let worker = new src_ResourceLoaderWorker(function() {
			let diffuseTex = src_ResourceLoader.getTexture(baseTexture).resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let normalTex = src_ResourceLoader.getTexture(normalTexture).resource;
			normalTex.set_wrap(h3d_mat_Wrap.Repeat);
			normalTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let shader = new shaders_DefaultMaterial(diffuseTex,normalTex,shininess,specularColor,uvScaleFactor,half);
			onFinish(shader);
		});
		worker.loadFile(baseTexture);
		worker.loadFile(normalTexture);
		worker.run();
	}
	static createDefaultCubemapMaterial(onFinish,baseTexture,normalTexture,shininess,specularColor,uvScaleFactor) {
		if(uvScaleFactor == null) {
			uvScaleFactor = 1;
		}
		let worker = new src_ResourceLoaderWorker(function() {
			let diffuseTex = src_ResourceLoader.getTexture(baseTexture).resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Linear);
			diffuseTex.set_filter(h3d_mat_Filter.Linear);
			let normalTex = src_ResourceLoader.getTexture(normalTexture).resource;
			normalTex.set_wrap(h3d_mat_Wrap.Repeat);
			normalTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let cubemapTex = new h3d_mat_Texture(128,128,[h3d_mat_TextureFlags.Cube]);
			let cubemapFace1 = src_ResourceLoader.getImage("data/textures/acubexpos2.png").resource;
			let cubemapFace2 = src_ResourceLoader.getImage("data/textures/acubexneg2.png").resource;
			let cubemapFace3 = src_ResourceLoader.getImage("data/textures/acubezneg2.png").resource;
			let cubemapFace4 = src_ResourceLoader.getImage("data/textures/acubezpos2.png").resource;
			let cubemapFace5 = src_ResourceLoader.getImage("data/textures/acubeypos2.png").resource;
			let cubemapFace6 = src_ResourceLoader.getImage("data/textures/acubeyneg2.png").resource;
			cubemapTex.uploadPixels(cubemapFace1.getPixels(),0,0);
			cubemapTex.uploadPixels(cubemapFace2.getPixels(),0,1);
			cubemapTex.uploadPixels(cubemapFace3.getPixels(),0,2);
			cubemapTex.uploadPixels(cubemapFace4.getPixels(),0,3);
			cubemapTex.uploadPixels(cubemapFace5.getPixels(),0,4);
			cubemapTex.uploadPixels(cubemapFace6.getPixels(),0,5);
			let shader = new shaders_DefaultCubemapMaterial(diffuseTex,normalTex,shininess,specularColor,uvScaleFactor,cubemapTex);
			onFinish(shader);
		});
		worker.loadFile(baseTexture);
		worker.loadFile(normalTexture);
		worker.run();
	}
	static createDefaultNormalMaterial(onFinish,baseTexture,shininess,specularColor,uvScaleFactor) {
		if(uvScaleFactor == null) {
			uvScaleFactor = 1;
		}
		let worker = new src_ResourceLoaderWorker(function() {
			let diffuseTex = src_ResourceLoader.getTexture(baseTexture).resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Linear);
			diffuseTex.set_filter(h3d_mat_Filter.Linear);
			let shader = new shaders_DefaultNormalMaterial(diffuseTex,shininess,specularColor,uvScaleFactor);
			onFinish(shader);
		});
		worker.loadFile(baseTexture);
		worker.run();
	}
	static createNoiseTileMaterial(onFinish,baseTexture,noiseSuffix,shininess,specular,uvScale) {
		if(uvScale == null) {
			uvScale = 1.0;
		}
		let worker = new src_ResourceLoaderWorker(function() {
			let diffuseTex = src_ResourceLoader.getTexture("data/textures/" + baseTexture).resource;
			diffuseTex.set_wrap(h3d_mat_Wrap.Repeat);
			diffuseTex.set_mipMap(h3d_mat_MipMap.Linear);
			diffuseTex.set_filter(h3d_mat_Filter.Linear);
			let normalTex = src_ResourceLoader.getTexture("data/textures/tile_intermediate.normal.png").resource;
			normalTex.set_wrap(h3d_mat_Wrap.Repeat);
			normalTex.set_mipMap(h3d_mat_MipMap.Nearest);
			let noiseTex = src_ResourceLoader.getTexture("data/textures/noise" + noiseSuffix + ".jpg").resource;
			noiseTex.set_wrap(h3d_mat_Wrap.Repeat);
			noiseTex.set_mipMap(h3d_mat_MipMap.None);
			let shader = new shaders_NoiseTileMaterial(diffuseTex,normalTex,noiseTex,shininess,specular,uvScale);
			onFinish(shader);
		});
		worker.loadFile("textures/" + baseTexture);
		worker.loadFile("textures/noise" + noiseSuffix + ".jpg");
		worker.loadFile("textures/tile_intermediate.normal.png");
		worker.run();
	}
	static setCustomMaterialDefinitions(materials) {
		src_DifBuilder.customMaterialDict = materials;
	}
	static loadDif(path,itr,onFinish,so,makeCollideable) {
		if(makeCollideable == null) {
			makeCollideable = true;
		}
		if(so == null) {
			so = -1;
		}
		path = StringTools.replace(path,"data/","");
		let stripTexName = function(tex) {
			let dotpos = tex.lastIndexOf(".");
			let slashpos = tex.lastIndexOf("/") + 1;
			if(dotpos == -1) {
				dotpos = tex.length;
			}
			if(slashpos == -1) {
				slashpos = 0;
			}
			return tex.substring(slashpos,dotpos);
		};
		src_ResourceLoader.load(path).entry.load(function() {
			let dif = null;
			let cache = null;
			let cachePath = "" + path + so;
			if(src_DifBuilder.difCache.exists(cachePath)) {
				cache = src_DifBuilder.difCache.get(cachePath);
				dif = cache.dif;
			} else {
				let difresource = src_ResourceLoader.loadInterior(path);
				difresource.acquire();
				dif = difresource.resource;
				src_DifBuilder.dumbDownDif(dif);
			}
			let geo = so == -1 ? dif.interiors[0] : dif.subObjects[so];
			let triangles = [];
			let textures = [];
			let collider = new collision_CollisionEntity(itr);
			let vertexBuckets = new haxe_ds_ObjectMap();
			let edges = [];
			let colliderSurfaces = [];
			let mats = new haxe_ds_StringMap();
			let difEdges = new haxe_ds_IntMap();
			if(cache != null) {
				mats = cache.difTriangles;
			}
			if(cache == null || makeCollideable) {
				mats = new haxe_ds_StringMap();
				colliderSurfaces = [];
				difEdges = new haxe_ds_IntMap();
				let _g = 0;
				let _g1 = geo.surfaces.length;
				while(_g < _g1) {
					let i = _g++;
					let surface = geo.surfaces[i];
					if(surface == null) {
						continue;
					}
					let planeindex = surface.planeIndex;
					let planeFlipped = (planeindex & 32768) == 32768;
					if(planeFlipped) {
						planeindex &= -32769;
					}
					let plane = geo.planes[planeindex];
					let normal = geo.normals[plane.normalIndex];
					if(planeFlipped) {
						normal = normal.scalar(-1);
					}
					let texture = geo.materialList[surface.textureIndex];
					if(!textures.includes(texture)) {
						textures.push(texture);
					}
					let points = geo.points;
					let colliderSurface = new collision_CollisionSurface();
					colliderSurface.points = [];
					colliderSurface.normals = [];
					colliderSurface.indices = [];
					colliderSurface.transformKeys = [];
					colliderSurface.originalIndices = [];
					colliderSurface.originalSurfaceIndex = i;
					let texPlanes = geo.texGenEQs[surface.texGenIndex];
					let startIdx = 0;
					while(true) {
						let pc0 = geo.points[geo.windings[surface.windingStart + startIdx + 1]];
						let pc1 = geo.points[geo.windings[surface.windingStart + startIdx]];
						let pc2 = geo.points[geo.windings[surface.windingStart + startIdx + 2]];
						let x = texPlanes.planeX.x * pc0.x + texPlanes.planeX.y * pc0.y + texPlanes.planeX.z * pc0.z + texPlanes.planeX.d;
						let y = texPlanes.planeY.x * pc0.x + texPlanes.planeY.y * pc0.y + texPlanes.planeY.z * pc0.z + texPlanes.planeY.d;
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let tc0_x = x;
						let tc0_y = y;
						let x1 = texPlanes.planeX.x * pc1.x + texPlanes.planeX.y * pc1.y + texPlanes.planeX.z * pc1.z + texPlanes.planeX.d;
						let y1 = texPlanes.planeY.x * pc1.x + texPlanes.planeY.y * pc1.y + texPlanes.planeY.z * pc1.z + texPlanes.planeY.d;
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let tc1_x = x1;
						let tc1_y = y1;
						let x2 = texPlanes.planeX.x * pc2.x + texPlanes.planeX.y * pc2.y + texPlanes.planeX.z * pc2.z + texPlanes.planeX.d;
						let y2 = texPlanes.planeY.x * pc2.x + texPlanes.planeY.y * pc2.y + texPlanes.planeY.z * pc2.z + texPlanes.planeY.d;
						if(y2 == null) {
							y2 = 0.;
						}
						if(x2 == null) {
							x2 = 0.;
						}
						let tc2_x = x2;
						let tc2_y = y2;
						let x3 = pc1.x - pc0.x;
						let y3 = tc1_x - tc0_x;
						let z = tc1_y - tc0_y;
						if(z == null) {
							z = 0.;
						}
						if(y3 == null) {
							y3 = 0.;
						}
						if(x3 == null) {
							x3 = 0.;
						}
						let edge1_x = x3;
						let edge1_y = y3;
						let edge1_z = z;
						let x4 = pc2.x - pc0.x;
						let y4 = tc2_x - tc0_x;
						let z1 = tc2_y - tc0_y;
						if(z1 == null) {
							z1 = 0.;
						}
						if(y4 == null) {
							y4 = 0.;
						}
						if(x4 == null) {
							x4 = 0.;
						}
						let edge2_x = x4;
						let edge2_y = y4;
						let edge2_z = z1;
						let x5 = edge1_y * edge2_z - edge1_z * edge2_y;
						let y5 = edge1_z * edge2_x - edge1_x * edge2_z;
						let z2 = edge1_x * edge2_y - edge1_y * edge2_x;
						if(z2 == null) {
							z2 = 0.;
						}
						if(y5 == null) {
							y5 = 0.;
						}
						if(x5 == null) {
							x5 = 0.;
						}
						let cp_x = x5;
						let cp_y = y5;
						let cp_z = z2;
						if(cp_x * cp_x + cp_y * cp_y + cp_z * cp_z > 1e-12) {
							break;
						}
						startIdx += 3;
						if(startIdx >= surface.windingCount) {
							startIdx = 0;
							break;
						}
					}
					let pc0 = geo.points[geo.windings[surface.windingStart + startIdx + 1]];
					let pc1 = geo.points[geo.windings[surface.windingStart + startIdx]];
					let pc2 = geo.points[geo.windings[surface.windingStart + startIdx + 2]];
					let x = texPlanes.planeX.x * pc0.x + texPlanes.planeX.y * pc0.y + texPlanes.planeX.z * pc0.z + texPlanes.planeX.d;
					let y = texPlanes.planeY.x * pc0.x + texPlanes.planeY.y * pc0.y + texPlanes.planeY.z * pc0.z + texPlanes.planeY.d;
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let tc0_x = x;
					let tc0_y = y;
					let x1 = texPlanes.planeX.x * pc1.x + texPlanes.planeX.y * pc1.y + texPlanes.planeX.z * pc1.z + texPlanes.planeX.d;
					let y1 = texPlanes.planeY.x * pc1.x + texPlanes.planeY.y * pc1.y + texPlanes.planeY.z * pc1.z + texPlanes.planeY.d;
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let tc1_x = x1;
					let tc1_y = y1;
					let x2 = texPlanes.planeX.x * pc2.x + texPlanes.planeX.y * pc2.y + texPlanes.planeX.z * pc2.z + texPlanes.planeX.d;
					let y2 = texPlanes.planeY.x * pc2.x + texPlanes.planeY.y * pc2.y + texPlanes.planeY.z * pc2.z + texPlanes.planeY.d;
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					let tc2_x = x2;
					let tc2_y = y2;
					let x3 = pc1.x - pc0.x;
					let y3 = tc1_x - tc0_x;
					let z = tc1_y - tc0_y;
					if(z == null) {
						z = 0.;
					}
					if(y3 == null) {
						y3 = 0.;
					}
					if(x3 == null) {
						x3 = 0.;
					}
					let edge1_x = x3;
					let edge1_y = y3;
					let edge1_z = z;
					let x4 = pc2.x - pc0.x;
					let y4 = tc2_x - tc0_x;
					let z1 = tc2_y - tc0_y;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y4 == null) {
						y4 = 0.;
					}
					if(x4 == null) {
						x4 = 0.;
					}
					let edge2_x = x4;
					let edge2_y = y4;
					let edge2_z = z1;
					let x5 = edge1_y * edge2_z - edge1_z * edge2_y;
					let y5 = edge1_z * edge2_x - edge1_x * edge2_z;
					let z2 = edge1_x * edge2_y - edge1_y * edge2_x;
					if(z2 == null) {
						z2 = 0.;
					}
					if(y5 == null) {
						y5 = 0.;
					}
					if(x5 == null) {
						x5 = 0.;
					}
					let cp_x = x5;
					let cp_y = y5;
					let cp_z = z2;
					let s_x = 0.;
					let s_y = 0.;
					let s_z = 0.;
					let t_x = 0.;
					let t_y = 0.;
					let t_z = 0.;
					if(Math.abs(cp_x) > 1e-12) {
						s_x = -cp_y / cp_x;
						t_x = -cp_z / cp_x;
					}
					let x6 = pc1.y - pc0.y;
					let y6 = tc1_x - tc0_x;
					let z3 = tc1_y - tc0_y;
					if(z3 == null) {
						z3 = 0.;
					}
					if(y6 == null) {
						y6 = 0.;
					}
					if(x6 == null) {
						x6 = 0.;
					}
					edge1_x = x6;
					edge1_y = y6;
					edge1_z = z3;
					let x7 = pc2.y - pc0.y;
					let y7 = tc2_x - tc0_x;
					let z4 = tc2_y - tc0_y;
					if(z4 == null) {
						z4 = 0.;
					}
					if(y7 == null) {
						y7 = 0.;
					}
					if(x7 == null) {
						x7 = 0.;
					}
					edge2_x = x7;
					edge2_y = y7;
					edge2_z = z4;
					let x8 = edge1_y * edge2_z - edge1_z * edge2_y;
					let y8 = edge1_z * edge2_x - edge1_x * edge2_z;
					let z5 = edge1_x * edge2_y - edge1_y * edge2_x;
					if(z5 == null) {
						z5 = 0.;
					}
					if(y8 == null) {
						y8 = 0.;
					}
					if(x8 == null) {
						x8 = 0.;
					}
					let v_x = x8;
					let v_y = y8;
					let v_z = z5;
					cp_x = v_x;
					cp_y = v_y;
					cp_z = v_z;
					if(Math.abs(cp_x) > 1e-12) {
						s_y = -cp_y / cp_x;
						t_y = -cp_z / cp_x;
					}
					let x9 = pc1.z - pc0.z;
					let y9 = tc1_x - tc0_x;
					let z6 = tc1_y - tc0_y;
					if(z6 == null) {
						z6 = 0.;
					}
					if(y9 == null) {
						y9 = 0.;
					}
					if(x9 == null) {
						x9 = 0.;
					}
					edge1_x = x9;
					edge1_y = y9;
					edge1_z = z6;
					let x10 = pc2.z - pc0.z;
					let y10 = tc2_x - tc0_x;
					let z7 = tc2_y - tc0_y;
					if(z7 == null) {
						z7 = 0.;
					}
					if(y10 == null) {
						y10 = 0.;
					}
					if(x10 == null) {
						x10 = 0.;
					}
					edge2_x = x10;
					edge2_y = y10;
					edge2_z = z7;
					let x11 = edge1_y * edge2_z - edge1_z * edge2_y;
					let y11 = edge1_z * edge2_x - edge1_x * edge2_z;
					let z8 = edge1_x * edge2_y - edge1_y * edge2_x;
					if(z8 == null) {
						z8 = 0.;
					}
					if(y11 == null) {
						y11 = 0.;
					}
					if(x11 == null) {
						x11 = 0.;
					}
					let v_x1 = x11;
					let v_y1 = y11;
					let v_z1 = z8;
					cp_x = v_x1;
					cp_y = v_y1;
					cp_z = v_z1;
					if(Math.abs(cp_x) > 1e-12) {
						s_z = -cp_y / cp_x;
						t_z = -cp_z / cp_x;
					}
					let k = s_x * s_x + s_y * s_y + s_z * s_z;
					if(k < 1e-10) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					s_x *= k;
					s_y *= k;
					s_z *= k;
					let k1 = t_x * t_x + t_y * t_y + t_z * t_z;
					if(k1 < 1e-10) {
						k1 = 0;
					} else {
						k1 = 1. / Math.sqrt(k1);
					}
					t_x *= k1;
					t_y *= k1;
					t_z *= k1;
					let x12 = s_y * t_z - s_z * t_y;
					let y12 = s_z * t_x - s_x * t_z;
					let z9 = s_x * t_y - s_y * t_x;
					if(z9 == null) {
						z9 = 0.;
					}
					if(y12 == null) {
						y12 = 0.;
					}
					if(x12 == null) {
						x12 = 0.;
					}
					let st_x = x12;
					let st_y = y12;
					let st_z = z9;
					if(st_x * normal.x + st_y * normal.y + st_z * normal.z < 0) {
						st_x *= -1;
						st_y *= -1;
						st_z *= -1;
					}
					let _g1 = surface.windingStart + 2;
					let _g2 = surface.windingStart + surface.windingCount;
					while(_g1 < _g2) {
						let k = _g1++;
						let p1;
						let p2;
						let p3;
						if((k - (surface.windingStart + 2)) % 2 == 0) {
							p1 = points[geo.windings[k]];
							p2 = points[geo.windings[k - 1]];
							p3 = points[geo.windings[k - 2]];
							if(makeCollideable) {
								colliderSurface.originalIndices.push(geo.windings[k]);
								colliderSurface.originalIndices.push(geo.windings[k - 1]);
								colliderSurface.originalIndices.push(geo.windings[k - 2]);
							}
						} else {
							p1 = points[geo.windings[k - 2]];
							p2 = points[geo.windings[k - 1]];
							p3 = points[geo.windings[k]];
							if(makeCollideable) {
								colliderSurface.originalIndices.push(geo.windings[k - 2]);
								colliderSurface.originalIndices.push(geo.windings[k - 1]);
								colliderSurface.originalIndices.push(geo.windings[k]);
							}
						}
						let e1 = new src_TriangleEdge(geo.windings[k],geo.windings[k - 1],geo.windings[k - 2],i);
						let e2 = new src_TriangleEdge(geo.windings[k - 1],geo.windings[k - 2],geo.windings[k],i);
						let e3 = new src_TriangleEdge(geo.windings[k],geo.windings[k - 2],geo.windings[k - 1],i);
						edges.push(e1);
						edges.push(e2);
						edges.push(e3);
						let texgen = geo.texGenEQs[surface.texGenIndex];
						let uv1 = new dif_math_Point2F(p1.x * texgen.planeX.x + p1.y * texgen.planeX.y + p1.z * texgen.planeX.z + texgen.planeX.d,p1.x * texgen.planeY.x + p1.y * texgen.planeY.y + p1.z * texgen.planeY.z + texgen.planeY.d);
						let uv2 = new dif_math_Point2F(p2.x * texgen.planeX.x + p2.y * texgen.planeX.y + p2.z * texgen.planeX.z + texgen.planeX.d,p2.x * texgen.planeY.x + p2.y * texgen.planeY.y + p2.z * texgen.planeY.z + texgen.planeY.d);
						let uv3 = new dif_math_Point2F(p3.x * texgen.planeX.x + p3.y * texgen.planeX.y + p3.z * texgen.planeX.z + texgen.planeX.d,p3.x * texgen.planeY.x + p3.y * texgen.planeY.y + p3.z * texgen.planeY.z + texgen.planeY.d);
						let tri = new src_DifBuilderTriangle();
						tri.texture = texture;
						tri.normal1 = normal;
						tri.normal2 = normal;
						tri.normal3 = normal;
						tri.p1 = p1;
						tri.p2 = p2;
						tri.p3 = p3;
						tri.uv1 = uv1;
						tri.uv2 = uv2;
						tri.uv3 = uv3;
						tri.t1 = new dif_math_Point3F(s_x,s_y,s_z);
						tri.n1 = new dif_math_Point3F(st_x,st_y,st_z);
						tri.b1 = new dif_math_Point3F(t_x,t_y,t_z);
						tri.t2 = new dif_math_Point3F(s_x,s_y,s_z);
						tri.n2 = new dif_math_Point3F(st_x,st_y,st_z);
						tri.b2 = new dif_math_Point3F(t_x,t_y,t_z);
						tri.t3 = new dif_math_Point3F(s_x,s_y,s_z);
						tri.n3 = new dif_math_Point3F(st_x,st_y,st_z);
						tri.b3 = new dif_math_Point3F(t_x,t_y,t_z);
						triangles.push(tri);
						let materialName = stripTexName(texture).toLowerCase();
						if(makeCollideable) {
							let hasCustomMaterialInfo = Object.prototype.hasOwnProperty.call(src_DifBuilder.customMaterialDict.h,materialName);
							if(hasCustomMaterialInfo) {
								let minfo = src_DifBuilder.customMaterialDict.h[materialName];
								colliderSurface.friction = minfo.friction;
								colliderSurface.restitution = minfo.restitution;
								colliderSurface.force = minfo.force != null ? minfo.force : 0;
							} else {
								let hasMaterialInfo = Object.prototype.hasOwnProperty.call(src_DifBuilder.materialDict.h,materialName);
								if(hasMaterialInfo) {
									let minfo = src_DifBuilder.materialDict.h[materialName];
									colliderSurface.friction = minfo.friction;
									colliderSurface.restitution = minfo.restitution;
									colliderSurface.force = minfo.force != null ? minfo.force : 0;
								}
							}
							let y = p1.y;
							let z = p1.z;
							colliderSurface.points.push(-p1.x);
							colliderSurface.points.push(y);
							colliderSurface.points.push(z);
							let y1 = p2.y;
							let z1 = p2.z;
							colliderSurface.points.push(-p2.x);
							colliderSurface.points.push(y1);
							colliderSurface.points.push(z1);
							let y2 = p3.y;
							let z2 = p3.z;
							colliderSurface.points.push(-p3.x);
							colliderSurface.points.push(y2);
							colliderSurface.points.push(z2);
							let y3 = normal.y;
							let z3 = normal.z;
							colliderSurface.normals.push(-normal.x);
							colliderSurface.normals.push(y3);
							colliderSurface.normals.push(z3);
							let y4 = normal.y;
							let z4 = normal.z;
							colliderSurface.normals.push(-normal.x);
							colliderSurface.normals.push(y4);
							colliderSurface.normals.push(z4);
							let y5 = normal.y;
							let z5 = normal.z;
							colliderSurface.normals.push(-normal.x);
							colliderSurface.normals.push(y5);
							colliderSurface.normals.push(z5);
							colliderSurface.indices.push(colliderSurface.indices.length);
							colliderSurface.indices.push(colliderSurface.indices.length);
							colliderSurface.indices.push(colliderSurface.indices.length);
							colliderSurface.transformKeys.push(0);
							colliderSurface.transformKeys.push(0);
							colliderSurface.transformKeys.push(0);
						}
						let _g = 0;
						let _g2 = [p1,p2,p3];
						while(_g < _g2.length) {
							let v = _g2[_g];
							++_g;
							let buckets = vertexBuckets.h[v.__id__];
							if(buckets == null) {
								buckets = [];
								vertexBuckets.set(v,buckets);
							}
							let bucket = null;
							let _g1 = 0;
							let _g3 = buckets.length;
							while(_g1 < _g3) {
								let j = _g1++;
								bucket = buckets[j];
								if(normal.dot(bucket.referenceNormal) > Math.cos(Math.PI / 12)) {
									break;
								}
								bucket = null;
							}
							if(bucket == null) {
								bucket = { referenceNormal : normal, triangleIndices : [], normals : []};
								buckets.push(bucket);
							}
							bucket.triangleIndices.push(triangles.length - 1);
							bucket.normals.push(normal);
						}
					}
					if(makeCollideable) {
						colliderSurface.generateBoundingBox();
						collider.addSurface(colliderSurface);
						colliderSurfaces.push(colliderSurface);
					}
				}
				let edgeMap = new haxe_ds_IntMap();
				let internalEdges_h = { };
				let _g2 = 0;
				while(_g2 < edges.length) {
					let edge = edges[_g2];
					++_g2;
					let edgeHash = edge.index1 >= edge.index2 ? edge.index1 * edge.index1 + edge.index1 + edge.index2 : edge.index1 + edge.index2 * edge.index2;
					if(internalEdges_h.hasOwnProperty(edgeHash)) {
						continue;
					}
					if(edgeMap.h.hasOwnProperty(edgeHash)) {
						if(edgeMap.h[edgeHash].surfaceIndex == edge.surfaceIndex) {
							internalEdges_h[edgeHash] = true;
							edgeMap.remove(edgeHash);
						} else {
							let difEdge = new dif_Edge(edge.index1,edge.index2,edge.surfaceIndex,edgeMap.h[edgeHash].surfaceIndex);
							difEdge.farPoint0 = edge.farPoint;
							difEdge.farPoint1 = edgeMap.h[edgeHash].farPoint;
							difEdges.h[edgeHash] = difEdge;
						}
					} else {
						edgeMap.h[edgeHash] = edge;
					}
				}
				let time = HxOverrides.now() / 1000;
				let map = vertexBuckets;
				let _g_keys = map.keys();
				while(_g_keys.hasNext()) {
					let key = _g_keys.next();
					let _g_value = map.get(key);
					let _g = 0;
					let _g1 = _g_value.length;
					while(_g < _g1) {
						let i = _g++;
						let bucket = _g_value[i];
						let avgNormal = new dif_math_Point3F();
						let _g1 = 0;
						let _g2 = bucket.normals;
						while(_g1 < _g2.length) {
							let normal = _g2[_g1];
							++_g1;
							avgNormal = avgNormal.add(normal);
						}
						avgNormal = avgNormal.scalarDiv(bucket.normals.length);
						let _g3 = 0;
						let _g4 = bucket.triangleIndices.length;
						while(_g3 < _g4) {
							let j = _g3++;
							let index = bucket.triangleIndices[j];
							let tri = triangles[index];
							if(tri.p1 == key) {
								tri.normal1 = avgNormal;
								tri.n1 = avgNormal;
								tri.t1 = tri.t1.sub(avgNormal.scalar(avgNormal.dot(tri.t1))).normalized();
								tri.b1 = tri.b1.sub(avgNormal.scalar(avgNormal.dot(tri.b1))).normalized();
							}
							if(tri.p2 == key) {
								tri.normal2 = avgNormal;
								tri.n2 = avgNormal;
								tri.t2 = tri.t2.sub(avgNormal.scalar(avgNormal.dot(tri.t2))).normalized();
								tri.b2 = tri.b2.sub(avgNormal.scalar(avgNormal.dot(tri.b2))).normalized();
							}
							if(tri.p3 == key) {
								tri.normal3 = avgNormal;
								tri.n3 = avgNormal;
								tri.t3 = tri.t3.sub(avgNormal.scalar(avgNormal.dot(tri.t3))).normalized();
								tri.b3 = tri.b3.sub(avgNormal.scalar(avgNormal.dot(tri.b3))).normalized();
							}
						}
					}
				}
				let _g_current = 0;
				while(_g_current < triangles.length) {
					let _g_value = triangles[_g_current];
					++_g_current;
					if(Object.prototype.hasOwnProperty.call(mats.h,_g_value.texture)) {
						mats.h[_g_value.texture].push(_g_value);
					} else {
						mats.h[_g_value.texture] = [_g_value];
					}
				}
				let interval = HxOverrides.now() / 1000 - time;
				src_Console.instance.addEntry("log","Normal smoothing build time: " + interval);
			}
			if(makeCollideable) {
				collider.finalize();
				itr.collider = collider;
			}
			let buildNewCache = false;
			if(cache == null) {
				cache = new src_DifCache();
				cache.difTriangles = mats;
				cache.dif = dif;
				cache.prims = new haxe_ds_StringMap();
				buildNewCache = true;
				src_DifBuilder.difCache.set(cachePath,cache);
			}
			let canFindTex = function(tex) {
				if(["NULL"].includes(tex)) {
					return false;
				}
				if(tex.indexOf("/") != -1) {
					tex = tex.split("/")[1];
				}
				path = StringTools.replace(path,"data/","");
				if(src_ResourceLoader.exists("data/textures/" + tex + ".jpg")) {
					return true;
				}
				if(src_ResourceLoader.exists("data/textures/" + tex + ".png")) {
					return true;
				}
				return false;
			};
			let tex = function(tex) {
				if(tex.indexOf("/") != -1) {
					tex = tex.split("/")[1];
				}
				if(src_ResourceLoader.exists("data/textures/" + tex + ".jpg")) {
					return "data/textures/" + tex + ".jpg";
				}
				if(src_ResourceLoader.exists("data/textures/" + tex + ".png")) {
					return "data/textures/" + tex + ".png";
				}
				return null;
			};
			let loadtexs = [];
			let h = mats.h;
			let _g_keys = Object.keys(h);
			let _g_length = _g_keys.length;
			let _g_current = 0;
			while(_g_current < _g_length) {
				let key = _g_keys[_g_current++];
				if(canFindTex(key)) {
					loadtexs.push(tex(key));
				}
			}
			let worker = new src_ResourceLoaderWorker(function() {
				let shaderWorker = new src_ResourceLoaderWorker(function() {
					onFinish();
				});
				let time = HxOverrides.now() / 1000;
				let h = mats.h;
				let _g_keys = Object.keys(h);
				let _g_length = _g_keys.length;
				let _g_current = 0;
				while(_g_current < _g_length) {
					let key = _g_keys[_g_current++];
					let _g_value = h[key];
					let prim = null;
					if(!buildNewCache && cache != null) {
						prim = cache.prims.h[key];
					} else {
						let points = [];
						let normals = [];
						let uvs = [];
						let t = [];
						let b = [];
						let n = [];
						let _g = 0;
						while(_g < _g_value.length) {
							let tri = _g_value[_g];
							++_g;
							let p1 = new h3d_col_Point(-tri.p1.x,tri.p1.y,tri.p1.z);
							let p2 = new h3d_col_Point(-tri.p2.x,tri.p2.y,tri.p2.z);
							let p3 = new h3d_col_Point(-tri.p3.x,tri.p3.y,tri.p3.z);
							let n1 = new h3d_col_Point(-tri.normal1.x,tri.normal1.y,tri.normal1.z);
							let n2 = new h3d_col_Point(-tri.normal2.x,tri.normal2.y,tri.normal2.z);
							let n3 = new h3d_col_Point(-tri.normal3.x,tri.normal3.y,tri.normal3.z);
							let uv1 = new h3d_prim_UV(tri.uv1.x,tri.uv1.y);
							let uv2 = new h3d_prim_UV(tri.uv2.x,tri.uv2.y);
							let uv3 = new h3d_prim_UV(tri.uv3.x,tri.uv3.y);
							points.push(p3);
							points.push(p2);
							points.push(p1);
							normals.push(n3);
							normals.push(n2);
							normals.push(n1);
							uvs.push(uv3);
							uvs.push(uv2);
							uvs.push(uv1);
							t.push(new h3d_col_Point(-tri.t3.x,tri.t3.y,tri.t3.z));
							t.push(new h3d_col_Point(-tri.t2.x,tri.t2.y,tri.t2.z));
							t.push(new h3d_col_Point(-tri.t1.x,tri.t1.y,tri.t1.z));
							b.push(new h3d_col_Point(-tri.b3.x,tri.b3.y,tri.b3.z));
							b.push(new h3d_col_Point(-tri.b2.x,tri.b2.y,tri.b2.z));
							b.push(new h3d_col_Point(-tri.b1.x,tri.b1.y,tri.b1.z));
							n.push(new h3d_col_Point(-tri.n3.x,tri.n3.y,tri.n3.z));
							n.push(new h3d_col_Point(-tri.n2.x,tri.n2.y,tri.n2.z));
							n.push(new h3d_col_Point(-tri.n1.x,tri.n1.y,tri.n1.z));
						}
						prim = new mesh_Polygon(points);
						prim.uvs = uvs;
						prim.normals = normals;
						prim.tangents = t;
						prim.bitangents = b;
						prim.texMatNormals = n;
						if(buildNewCache) {
							cache.prims.h[key] = prim;
						}
					}
					let texture;
					let material;
					let exactName = stripTexName(StringTools.replace(key.toLowerCase(),"textures/",""));
					if(canFindTex(key) || Object.prototype.hasOwnProperty.call(src_DifBuilder.shaderMaterialDict.h,exactName)) {
						material = h3d_mat_Material.create();
						if(Object.prototype.hasOwnProperty.call(src_DifBuilder.shaderMaterialDict.h,exactName)) {
							let retrievefunc = src_DifBuilder.shaderMaterialDict.h[exactName];
							shaderWorker.addTask(function(fwd) {
								retrievefunc(function(shad) {
									let zPass = material.passes.clone();
									zPass.removeShader(material.textureShader);
									let tx = zPass.getShader(h3d_shader_Texture);
									zPass.removeShader(tx);
									zPass.setColorMask(false,false,false,false);
									zPass.set_depthWrite(true);
									zPass.setPassName("zPass");
									material.addPass(zPass);
									material.passes.set_depthTest(h3d_mat_Compare.LessEqual);
									material.passes.removeShader(material.textureShader);
									material.passes.addShader(shad);
									let thisprops = material.getDefaultProps();
									thisprops.light = false;
									material.set_props(thisprops);
									material.set_castShadows(false);
									material.set_receiveShadows(false);
									material.set_receiveShadows(true);
									material.passes.setPassName("interior");
									fwd();
								});
							});
						} else {
							texture = src_ResourceLoader.getTextureRealpath(tex(key)).resource;
							texture.set_wrap(h3d_mat_Wrap.Repeat);
							texture.set_mipMap(h3d_mat_MipMap.Linear);
							material.set_texture(texture);
							material.set_castShadows(false);
							material.set_receiveShadows(false);
							material.set_receiveShadows(true);
						}
					} else {
						src_Console.instance.addEntry("warn","Unable to load " + key + " texture for dif " + path);
						material = h3d_mat_Material.create();
						material.set_castShadows(false);
						material.set_receiveShadows(false);
						material.set_receiveShadows(true);
					}
					if(src_Debug.wireFrame) {
						material.passes.set_wireframe(true);
					}
					new h3d_scene_Mesh(prim,material,itr);
				}
				let interval = HxOverrides.now() / 1000 - time;
				src_Console.instance.addEntry("log","Geometry build time " + interval);
				time = HxOverrides.now() / 1000;
				shaderWorker.run();
				interval = HxOverrides.now() / 1000 - time;
				src_Console.instance.addEntry("log","Shader building time " + interval);
			});
			let _g = 0;
			while(_g < loadtexs.length) {
				let f = loadtexs[_g];
				++_g;
				worker.loadFile(f);
			}
			worker.run();
		});
	}
	static dumbDownDif(dif) {
		dif.aiSpecialNodes = null;
		dif.forceFields = null;
		dif.triggers = null;
		dif.gameEntities = null;
		dif.interiorPathfollowers = null;
		dif.triggers = null;
		dif.vehicleCollision = null;
		let _g = 0;
		let _g1 = dif.interiors.concat(dif.subObjects);
		while(_g < _g1.length) {
			let itr = _g1[_g];
			++_g;
			itr.alarmAmbientColor = null;
			itr.alarmLMapIndices = null;
			itr.animatedLights = null;
			itr.baseAmbientColor = null;
			itr.bspNodes = null;
			itr.bspSolidLeaves = null;
			itr.convexHullEmitStrings = null;
			itr.convexHulls = null;
			itr.coordBinIndices = null;
			itr.boundingSphere = null;
			itr.coordBins = null;
			itr.edges = null;
			itr.edges2 = null;
			itr.hullEmitStringIndices = null;
			itr.hullIndices = null;
			itr.hullPlaneIndices = null;
			itr.hullSurfaceIndices = null;
			itr.lightMaps = null;
			itr.lightStates = null;
			itr.nameBuffer = null;
			itr.normalIndices = null;
			itr.normalLMapIndices = null;
			itr.nullSurfaces = null;
			itr.pointVisibilities = null;
			itr.polyListPlanes = null;
			itr.polyListPoints = null;
			itr.polyListStrings = null;
			itr.portals = null;
			itr.solidLeafSurfaces = null;
			itr.stateDataBuffers = null;
			itr.zones = null;
			itr.zoneSurfaces = null;
			itr.zoneStaticMeshes = null;
			itr.windingIndices = null;
			itr.texNormals = null;
			itr.texMatrices = null;
			itr.texMatIndices = null;
			itr.stateDatas = null;
		}
	}
}
$hxClasses["src.DifBuilder"] = src_DifBuilder;
src_DifBuilder.__name__ = "src.DifBuilder";
class src_DynamicPolygon extends h3d_prim_MeshPrimitive {
	constructor(points,idx) {
		super();
		this.points = points;
		this.idx = idx;
	}
	getBounds() {
		let b = new h3d_col_Bounds();
		let _g = 0;
		let _g1 = this.points;
		while(_g < _g1.length) {
			let p = _g1[_g];
			++_g;
			if(p.x < b.xMin) {
				b.xMin = p.x;
			}
			if(p.x > b.xMax) {
				b.xMax = p.x;
			}
			if(p.y < b.yMin) {
				b.yMin = p.y;
			}
			if(p.y > b.yMax) {
				b.yMax = p.y;
			}
			if(p.z < b.zMin) {
				b.zMin = p.z;
			}
			if(p.z > b.zMax) {
				b.zMax = p.z;
			}
		}
		return b;
	}
	flush() {
		let alloc = hxd_impl_Allocator.get();
		let vsize = this.points.length;
		if(vsize == 0) {
			if(this.buffer != null) {
				alloc.disposeBuffer(this.buffer);
				this.buffer = null;
			}
			if(this.indexes != null) {
				alloc.disposeIndexBuffer(this.indexes);
				this.indexes = null;
			}
			return;
		}
		let tmp;
		if(this.buffer != null) {
			let _this = this.buffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null || this.buffer.vertices < vsize;
		} else {
			tmp = false;
		}
		if(tmp) {
			alloc.disposeBuffer(this.buffer);
			this.buffer = null;
		}
		if(this.buffer == null) {
			this.buffer = alloc.allocBuffer(0 < vsize ? vsize : 0,8,0);
		}
		let off = 0;
		let _g = 0;
		let _g1 = this.points.length;
		while(_g < _g1) {
			let k = _g++;
			if(this.dirtyFlags[k]) {
				let p = this.points[k];
				this.vbuf.array[off++] = p.x;
				this.vbuf.array[off++] = p.y;
				this.vbuf.array[off++] = p.z;
				if(this.normals != null) {
					let n = this.normals[k];
					this.vbuf.array[off++] = n.x;
					this.vbuf.array[off++] = n.y;
					this.vbuf.array[off++] = n.z;
				}
				if(this.uvs != null) {
					let uv = this.uvs[k];
					this.vbuf.array[off++] = uv.u;
					this.vbuf.array[off++] = uv.v;
				}
				this.dirtyFlags[k] = false;
			} else {
				off += 3;
				if(this.normals != null) {
					off += 3;
				}
				if(this.uvs != null) {
					off += 2;
				}
			}
		}
		this.buffer.uploadVector(this.vbuf,0,vsize);
		if(this.idx != null) {
			this.indexes = h3d_Indexes.alloc(this.idx);
		}
	}
	alloc(engine) {
		this.dispose();
		let allocator = hxd_impl_Allocator.get();
		this.dirtyFlags = [];
		let size = 3;
		let names = ["position"];
		let positions = [0];
		if(this.normals != null) {
			names.push("normal");
			positions.push(3);
			size = 6;
		}
		if(this.uvs != null) {
			names.push("uv");
			positions.push(size);
		}
		this.vbuf = hxd__$FloatBuffer_Float32Expand._new(0);
		let _g = 0;
		let _g1 = this.points.length;
		while(_g < _g1) {
			let k = _g++;
			let p = this.points[k];
			let this1 = this.vbuf;
			let v = p.x;
			if(this1.pos == this1.array.length) {
				let newSize = this1.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this1.array);
				this1.array = newArray;
			}
			this1.array[this1.pos++] = v;
			let this2 = this.vbuf;
			let v1 = p.y;
			if(this2.pos == this2.array.length) {
				let newSize = this2.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this2.array);
				this2.array = newArray;
			}
			this2.array[this2.pos++] = v1;
			let this3 = this.vbuf;
			let v2 = p.z;
			if(this3.pos == this3.array.length) {
				let newSize = this3.array.length << 1;
				if(newSize < 128) {
					newSize = 128;
				}
				let newArray = new Float32Array(newSize);
				newArray.set(this3.array);
				this3.array = newArray;
			}
			this3.array[this3.pos++] = v2;
			if(this.normals != null) {
				let n = this.normals[k];
				let this1 = this.vbuf;
				let v = n.x;
				if(this1.pos == this1.array.length) {
					let newSize = this1.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this1.array);
					this1.array = newArray;
				}
				this1.array[this1.pos++] = v;
				let this2 = this.vbuf;
				let v1 = n.y;
				if(this2.pos == this2.array.length) {
					let newSize = this2.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this2.array);
					this2.array = newArray;
				}
				this2.array[this2.pos++] = v1;
				let this3 = this.vbuf;
				let v2 = n.z;
				if(this3.pos == this3.array.length) {
					let newSize = this3.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this3.array);
					this3.array = newArray;
				}
				this3.array[this3.pos++] = v2;
			}
			if(this.uvs != null) {
				let t = this.uvs[k];
				let this1 = this.vbuf;
				let v = t.u;
				if(this1.pos == this1.array.length) {
					let newSize = this1.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this1.array);
					this1.array = newArray;
				}
				this1.array[this1.pos++] = v;
				let this2 = this.vbuf;
				let v1 = t.v;
				if(this2.pos == this2.array.length) {
					let newSize = this2.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this2.array);
					this2.array = newArray;
				}
				this2.array[this2.pos++] = v1;
			}
			this.dirtyFlags.push(false);
		}
		let flags = [];
		if(this.idx == null) {
			flags.push(h3d_BufferFlag.Triangles);
		}
		if(this.normals == null) {
			flags.push(h3d_BufferFlag.RawFormat);
		}
		flags.push(h3d_BufferFlag.Dynamic);
		let b = this.vertexCount();
		this.buffer = allocator.allocBuffer(0 < b ? b : 0,8,0);
		this.buffer.uploadVector(this.vbuf,0,this.points.length);
		let _g2 = 0;
		let _g3 = names.length;
		while(_g2 < _g3) {
			let i = _g2++;
			this.addBuffer(names[i],this.buffer,positions[i]);
		}
		if(this.idx != null) {
			this.indexes = h3d_Indexes.alloc(this.idx);
		}
	}
	getDrawBuffer(vertices) {
		if(this.vbuf == null) {
			this.vbuf = hxd_impl_Allocator.get().allocFloats(vertices * 8);
		} else {
			let this1 = this.vbuf;
			let _g = this1.pos;
			let _g1 = vertices * 8;
			while(_g < _g1) {
				++_g;
				if(this1.pos == this1.array.length) {
					let newSize = this1.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this1.array);
					this1.array = newArray;
				}
				this1.array[this1.pos++] = 0.;
			}
		}
		return this.vbuf;
	}
	triCount() {
		let n = super.triCount();
		if(n != 0) {
			return n;
		}
		return (this.idx == null ? this.points.length : this.idx.length) / 3 | 0;
	}
	vertexCount() {
		return this.points.length;
	}
	render(engine) {
		let tmp;
		if(this.buffer != null) {
			let _this = this.buffer;
			tmp = _this.buffer == null || _this.buffer.vbuf == null;
		} else {
			tmp = true;
		}
		if(tmp) {
			this.alloc(engine);
		}
		let bufs = this.getBuffers(engine);
		if(this.indexes != null) {
			engine.renderMultiBuffers(bufs,this.indexes);
		} else if((this.buffer.flags & 4) != 0) {
			engine.renderMultiBuffers(bufs,engine.mem.quadIndexes,0,this.triCount());
		} else {
			engine.renderMultiBuffers(bufs,engine.mem.triIndexes,0,this.triCount());
		}
	}
}
$hxClasses["src.DynamicPolygon"] = src_DynamicPolygon;
src_DynamicPolygon.__name__ = "src.DynamicPolygon";
src_DynamicPolygon.__super__ = h3d_prim_MeshPrimitive;
Object.assign(src_DynamicPolygon.prototype, {
	__class__: src_DynamicPolygon
	,points: null
	,normals: null
	,uvs: null
	,idx: null
	,dirtyFlags: null
	,vbuf: null
});
var src_ForceType = $hxEnums["src.ForceType"] = { __ename__:true,__constructs__:null
	,NoForce: {_hx_name:"NoForce",_hx_index:0,__enum__:"src.ForceType",toString:$estr}
	,ForceSpherical: {_hx_name:"ForceSpherical",_hx_index:1,__enum__:"src.ForceType",toString:$estr}
	,ForceField: {_hx_name:"ForceField",_hx_index:2,__enum__:"src.ForceType",toString:$estr}
	,ForceCone: {_hx_name:"ForceCone",_hx_index:3,__enum__:"src.ForceType",toString:$estr}
};
src_ForceType.__constructs__ = [src_ForceType.NoForce,src_ForceType.ForceSpherical,src_ForceType.ForceField,src_ForceType.ForceCone];
src_ForceType.__empty_constructs__ = [src_ForceType.NoForce,src_ForceType.ForceSpherical,src_ForceType.ForceField,src_ForceType.ForceCone];
class src_Gamepad {
	static init() {
		hxd_Pad.wait(src_Gamepad.onPad);
	}
	static onPad(pad) {
		src_Console.instance.addEntry("log","Gamepad found");
		pad.axisDeadZone = src_Settings.gamepadSettings.axisDeadzone;
		pad.onDisconnect = function() {
			src_Console.instance.addEntry("log","Gamepad disconnected");
			src_Gamepad.gamepad = hxd_Pad.createDummy();
		};
		src_Gamepad.gamepad = pad;
	}
	static getId(name) {
		switch(name) {
		case "A":
			return src_Gamepad.gamepad.config.A;
		case "B":
			return src_Gamepad.gamepad.config.B;
		case "LB":
			return src_Gamepad.gamepad.config.LB;
		case "LT":
			return src_Gamepad.gamepad.config.LT;
		case "RB":
			return src_Gamepad.gamepad.config.RB;
		case "RT":
			return src_Gamepad.gamepad.config.RT;
		case "X":
			return src_Gamepad.gamepad.config.X;
		case "Y":
			return src_Gamepad.gamepad.config.Y;
		case "analogClick":
			return src_Gamepad.gamepad.config.analogClick;
		case "analogX":
			return src_Gamepad.gamepad.config.analogX;
		case "analogY":
			return src_Gamepad.gamepad.config.analogY;
		case "back":
			return src_Gamepad.gamepad.config.back;
		case "dpadDown":
			return src_Gamepad.gamepad.config.dpadDown;
		case "dpadLeft":
			return src_Gamepad.gamepad.config.dpadLeft;
		case "dpadRight":
			return src_Gamepad.gamepad.config.dpadRight;
		case "dpadUp":
			return src_Gamepad.gamepad.config.dpadUp;
		case "ranalogClick":
			return src_Gamepad.gamepad.config.ranalogClick;
		case "ranalogX":
			return src_Gamepad.gamepad.config.ranalogX;
		case "ranalogY":
			return src_Gamepad.gamepad.config.ranalogY;
		case "start":
			return src_Gamepad.gamepad.config.start;
		}
		return -1;
	}
	static isDown(buttons) {
		let _g = 0;
		while(_g < buttons.length) {
			let button = buttons[_g];
			++_g;
			let buttonId = src_Gamepad.getId(button);
			if(buttonId < 0 || buttonId > src_Gamepad.gamepad.buttons.length) {
				continue;
			}
			if(src_Gamepad.gamepad.isDown(buttonId)) {
				return true;
			}
		}
		return false;
	}
	static isPressed(buttons) {
		let _g = 0;
		while(_g < buttons.length) {
			let button = buttons[_g];
			++_g;
			let buttonId = src_Gamepad.getId(button);
			if(buttonId < 0 || buttonId > src_Gamepad.gamepad.buttons.length) {
				continue;
			}
			if(src_Gamepad.gamepad.isPressed(buttonId)) {
				return true;
			}
		}
		return false;
	}
	static isReleased(buttons) {
		let _g = 0;
		while(_g < buttons.length) {
			let button = buttons[_g];
			++_g;
			let buttonId = src_Gamepad.getId(button);
			if(buttonId < 0 || buttonId > src_Gamepad.gamepad.buttons.length) {
				continue;
			}
			if(src_Gamepad.gamepad.isReleased(buttonId)) {
				return true;
			}
		}
		return false;
	}
	static getAxis(axis) {
		switch(axis) {
		case "analogX":
			return src_Gamepad.gamepad.get_xAxis();
		case "analogY":
			return src_Gamepad.gamepad.get_yAxis();
		case "ranalogX":
			return src_Gamepad.gamepad.get_rxAxis();
		case "ranalogY":
			return src_Gamepad.gamepad.get_ryAxis();
		}
		return 0.0;
	}
}
$hxClasses["src.Gamepad"] = src_Gamepad;
src_Gamepad.__name__ = "src.Gamepad";
class src_Http {
	static get(url,callback,errCallback) {
		return window.setTimeout(function() {
			return window.fetch(url).then(function(r) {
				return r.arrayBuffer().then(function(b) {
					callback(haxe_io_Bytes.ofData(b));
				});
			},function(e) {
				errCallback(e.toString());
			});
		},75);
	}
	static post(url,postData,callback,errCallback) {
		return window.setTimeout(function() {
			return window.fetch(url,{ method : "POST", headers : { "User-Agent" : window.navigator.userAgent, "Content-Type" : "application/json"}, body : postData}).then(function(r) {
				return r.arrayBuffer().then(function(b) {
					callback(haxe_io_Bytes.ofData(b));
				});
			},function(e) {
				errCallback(e.toString());
			});
		},75);
	}
	static uploadFile(url,data,callback,errCallback) {
		return window.setTimeout(function() {
			return window.fetch(url,{ method : "POST", headers : { "User-Agent" : window.navigator.userAgent, "Content-Type" : "application/octet-stream"}, body : data.b.bufferValue}).then(function(r) {
				return r.arrayBuffer().then(function(b) {
					callback(haxe_io_Bytes.ofData(b));
				});
			},function(e) {
				errCallback(e.toString());
			});
		},75);
	}
}
$hxClasses["src.Http"] = src_Http;
src_Http.__name__ = "src.Http";
class src_MeshBatchInfo {
	constructor() {
	}
}
$hxClasses["src.MeshBatchInfo"] = src_MeshBatchInfo;
src_MeshBatchInfo.__name__ = "src.MeshBatchInfo";
Object.assign(src_MeshBatchInfo.prototype, {
	__class__: src_MeshBatchInfo
	,instances: null
	,meshbatch: null
	,transparencymeshbatch: null
	,mesh: null
	,dtsShader: null
	,glowPassDtsShader: null
	,baseBounds: null
});
class src_MeshInstance {
	constructor(eo,go) {
		this.emptyObj = eo;
		this.gameObject = go;
	}
}
$hxClasses["src.MeshInstance"] = src_MeshInstance;
src_MeshInstance.__name__ = "src.MeshInstance";
Object.assign(src_MeshInstance.prototype, {
	__class__: src_MeshInstance
	,emptyObj: null
	,gameObject: null
});
class src_InstanceManager {
	constructor(scene) {
		this.transparentinstances = new src_ReusableList_$src_$MeshInstance();
		this.opaqueinstances = new src_ReusableList_$src_$MeshInstance();
		this.objectMap = new haxe_ds_StringMap();
		this.objects = [];
		this.scene = scene;
	}
	render() {
		let renderFrustum = this.scene.camera.frustum;
		let doFrustumCheck = true;
		doFrustumCheck = src_MarbleGame.instance.world != null && src_Settings.optionsSettings.reflectionDetail >= 3;
		let cameraFrustrums = doFrustumCheck ? src_MarbleGame.instance.world.marble.cubemapRenderer.getCameraFrustums() : null;
		let _g = 0;
		let _g1 = this.objects;
		while(_g < _g1.length) {
			let meshes = _g1[_g];
			++_g;
			let _g2 = 0;
			while(_g2 < meshes.length) {
				let minfo = meshes[_g2];
				++_g2;
				this.opaqueinstances.length = 0;
				this.transparentinstances.length = 0;
				if(minfo.meshbatch != null || minfo.transparencymeshbatch != null) {
					let _g = 0;
					let _g1 = minfo.instances;
					while(_g < _g1.length) {
						let inst = _g1[_g];
						++_g;
						src_InstanceManager.render_tmpBounds.load(minfo.baseBounds);
						src_InstanceManager.render_tmpBounds.transform(inst.emptyObj.getAbsPos());
						if(cameraFrustrums == null && !renderFrustum.hasBounds(src_InstanceManager.render_tmpBounds)) {
							continue;
						}
						if(cameraFrustrums != null) {
							let found = false;
							let _g = 0;
							while(_g < cameraFrustrums.length) {
								let frustrum = cameraFrustrums[_g];
								++_g;
								if(frustrum.hasBounds(src_InstanceManager.render_tmpBounds)) {
									found = true;
									break;
								}
							}
							if(!found) {
								continue;
							}
						}
						if(inst.gameObject.currentOpacity == 1) {
							let _this = this.opaqueinstances;
							if(_this.array.length == _this.length) {
								_this.array.push(inst);
								_this.length += 1;
							} else {
								_this.array[_this.length] = inst;
								_this.length += 1;
							}
						} else if(inst.gameObject.currentOpacity != 0) {
							let _this = this.transparentinstances;
							if(_this.array.length == _this.length) {
								_this.array.push(inst);
								_this.length += 1;
							} else {
								_this.array[_this.length] = inst;
								_this.length += 1;
							}
						}
					}
				}
				if(minfo.meshbatch != null) {
					minfo.meshbatch.begin(this.opaqueinstances.length);
					let _g = new src_ReusableListIterator_$src_$MeshInstance(this.opaqueinstances);
					while(_g.i != _g.l.length) {
						let ret = _g.l.array[_g.i];
						_g.i += 1;
						let dtsShader = minfo.dtsShader;
						let subOpacity = 1.0;
						if(dtsShader != null) {
							if(ret.gameObject.animateSubObjectOpacities) {
								subOpacity = ret.gameObject.getSubObjectOpacity(ret.emptyObj);
								if(subOpacity == 0) {
									continue;
								}
							}
							dtsShader.currentOpacity__ = ret.gameObject.currentOpacity * subOpacity;
						}
						let transform = ret.emptyObj.getAbsPos();
						minfo.meshbatch.material.passes.set_depthWrite(minfo.mesh.material.passes.depthWrite);
						minfo.meshbatch.material.passes.set_depthTest(minfo.mesh.material.passes.depthTest);
						minfo.meshbatch.material.passes.setPassName(minfo.mesh.material.passes.name);
						minfo.meshbatch.material.passes.set_enableLights(minfo.mesh.material.passes.enableLights);
						minfo.meshbatch.worldPosition = transform;
						minfo.meshbatch.material.passes.set_culling(minfo.mesh.material.passes.culling);
						minfo.meshbatch.material.passes.set_blendSrc(minfo.mesh.material.passes.blendSrc);
						minfo.meshbatch.material.passes.set_blendDst(minfo.mesh.material.passes.blendDst);
						minfo.meshbatch.material.passes.set_blendOp(minfo.mesh.material.passes.blendOp);
						minfo.meshbatch.material.passes.set_blendAlphaSrc(minfo.mesh.material.passes.blendAlphaSrc);
						minfo.meshbatch.material.passes.set_blendAlphaDst(minfo.mesh.material.passes.blendAlphaDst);
						minfo.meshbatch.material.passes.set_blendAlphaOp(minfo.mesh.material.passes.blendAlphaOp);
						let glowPass = minfo.meshbatch.material.getPass("glow");
						if(glowPass != null) {
							dtsShader = minfo.glowPassDtsShader;
							if(dtsShader != null) {
								dtsShader.currentOpacity__ = ret.gameObject.currentOpacity * subOpacity;
							}
						}
						minfo.meshbatch.emitInstance();
					}
				}
				if(minfo.transparencymeshbatch != null) {
					minfo.transparencymeshbatch.begin(this.transparentinstances.length);
					let _g = new src_ReusableListIterator_$src_$MeshInstance(this.transparentinstances);
					while(_g.i != _g.l.length) {
						let ret = _g.l.array[_g.i];
						_g.i += 1;
						let dtsShader = minfo.dtsShader;
						if(dtsShader != null) {
							dtsShader.currentOpacity__ = ret.gameObject.currentOpacity;
						}
						minfo.transparencymeshbatch.material.set_blendMode(h2d_BlendMode.Alpha);
						minfo.transparencymeshbatch.material.passes.set_enableLights(minfo.mesh.material.passes.enableLights);
						let transform = ret.emptyObj.getAbsPos();
						minfo.transparencymeshbatch.worldPosition = transform;
						minfo.transparencymeshbatch.emitInstance();
					}
				}
			}
		}
	}
	addObject(object) {
		let getAllChildren = null;
		getAllChildren = function(object) {
			let ret = [object];
			let _g = 0;
			let _g1 = object.children.length;
			while(_g < _g1) {
				let i = _g++;
				ret = ret.concat(getAllChildren(object.children[i]));
			}
			return ret;
		};
		if(this.isInstanced(object)) {
			let objs = getAllChildren(object);
			let minfos = this.objects[this.objectMap.h[object.identifier]];
			let _g = 0;
			let _g1 = objs.length;
			while(_g < _g1) {
				let i = _g++;
				minfos[i].instances.push(new src_MeshInstance(objs[i],object));
			}
		} else {
			let objs = getAllChildren(object);
			let minfos = [];
			let _g = 0;
			while(_g < objs.length) {
				let obj = objs[_g];
				++_g;
				let isMesh = ((obj) instanceof h3d_scene_Mesh);
				let minfo = new src_MeshBatchInfo();
				minfo.instances = [new src_MeshInstance(obj,object)];
				minfo.meshbatch = isMesh ? new src_MeshBatch((js_Boot.__cast(obj , h3d_scene_Mesh)).primitive,(js_Boot.__cast(obj , h3d_scene_Mesh)).material.clone(),this.scene) : null;
				minfo.mesh = isMesh ? obj : null;
				minfo.baseBounds = isMesh ? (js_Boot.__cast(minfo.meshbatch.primitive , h3d_prim_Instanced)).baseBounds : null;
				if(isMesh) {
					let mat = (js_Boot.__cast(obj , h3d_scene_Mesh)).material;
					let minfoshaders = [];
					let _this = minfo.meshbatch.material.passes;
					let s = _this.parentShaders;
					let _g_l = _this.shaders;
					while(_g_l != s) {
						let s = _g_l.s;
						_g_l = _g_l.next;
						minfoshaders.push(s);
					}
					let _g = 0;
					while(_g < minfoshaders.length) {
						let shader = minfoshaders[_g];
						++_g;
						minfo.meshbatch.material.passes.removeShader(shader);
					}
					let addshaders = [];
					let _this1 = mat.passes;
					let s1 = _this1.parentShaders;
					let _g_l1 = _this1.shaders;
					while(_g_l1 != s1) {
						let s = _g_l1.s;
						_g_l1 = _g_l1.next;
						addshaders.push(s);
					}
					let _g1 = 0;
					while(_g1 < addshaders.length) {
						let shader = addshaders[_g1];
						++_g1;
						minfo.meshbatch.material.passes.addShader(shader);
					}
					let glowPass = mat.getPass("glow");
					if(glowPass != null) {
						let gpass = glowPass.clone();
						gpass.set_enableLights(false);
						gpass.set_depthTest(glowPass.depthTest);
						gpass.set_blendSrc(glowPass.blendSrc);
						gpass.set_blendDst(glowPass.blendDst);
						gpass.set_blendOp(glowPass.blendOp);
						gpass.set_blendAlphaSrc(glowPass.blendAlphaSrc);
						gpass.set_blendAlphaDst(glowPass.blendAlphaDst);
						gpass.set_blendAlphaOp(glowPass.blendAlphaOp);
						if(glowPass.culling == h3d_mat_Face.None) {
							gpass.set_culling(glowPass.culling);
						}
						minfoshaders = [];
						let s = gpass.parentShaders;
						let _g_l = gpass.shaders;
						while(_g_l != s) {
							let s = _g_l.s;
							_g_l = _g_l.next;
							minfoshaders.push(s);
						}
						let _g = 0;
						while(_g < minfoshaders.length) {
							let shader = minfoshaders[_g];
							++_g;
							gpass.removeShader(shader);
						}
						let addshaders = [];
						let s1 = glowPass.parentShaders;
						let _g_l1 = glowPass.shaders;
						while(_g_l1 != s1) {
							let s = _g_l1.s;
							_g_l1 = _g_l1.next;
							addshaders.push(s);
						}
						let _g1 = 0;
						while(_g1 < addshaders.length) {
							let shader = addshaders[_g1];
							++_g1;
							gpass.addShader(shader);
						}
						minfo.glowPassDtsShader = gpass.getShader(shaders_DtsTexture);
						minfo.meshbatch.material.addPass(gpass);
					}
					let refractPass = mat.getPass("refract");
					if(refractPass != null) {
						let gpass = refractPass.clone();
						gpass.set_enableLights(false);
						gpass.set_depthTest(refractPass.depthTest);
						gpass.set_blendSrc(refractPass.blendSrc);
						gpass.set_blendDst(refractPass.blendDst);
						gpass.set_blendOp(refractPass.blendOp);
						gpass.set_blendAlphaSrc(refractPass.blendAlphaSrc);
						gpass.set_blendAlphaDst(refractPass.blendAlphaDst);
						gpass.set_blendAlphaOp(refractPass.blendAlphaOp);
						if(refractPass.culling == h3d_mat_Face.None) {
							gpass.set_culling(refractPass.culling);
						}
						minfoshaders = [];
						let s = gpass.parentShaders;
						let _g_l = gpass.shaders;
						while(_g_l != s) {
							let s = _g_l.s;
							_g_l = _g_l.next;
							minfoshaders.push(s);
						}
						let _g = 0;
						while(_g < minfoshaders.length) {
							let shader = minfoshaders[_g];
							++_g;
							gpass.removeShader(shader);
						}
						let addshaders = [];
						let s1 = refractPass.parentShaders;
						let _g_l1 = refractPass.shaders;
						while(_g_l1 != s1) {
							let s = _g_l1.s;
							_g_l1 = _g_l1.next;
							addshaders.push(s);
						}
						let _g1 = 0;
						while(_g1 < addshaders.length) {
							let shader = addshaders[_g1];
							++_g1;
							gpass.addShader(shader);
						}
						minfo.meshbatch.material.addPass(gpass);
					}
					let zPass = mat.getPass("zPass");
					if(zPass != null) {
						let gpass = zPass.clone();
						gpass.set_enableLights(false);
						gpass.set_depthTest(zPass.depthTest);
						gpass.set_blendSrc(zPass.blendSrc);
						gpass.set_blendDst(zPass.blendDst);
						gpass.set_blendOp(zPass.blendOp);
						gpass.set_blendAlphaSrc(zPass.blendAlphaSrc);
						gpass.set_blendAlphaDst(zPass.blendAlphaDst);
						gpass.set_blendAlphaOp(zPass.blendAlphaOp);
						gpass.colorMask = zPass.colorMask;
						minfoshaders = [];
						let s = gpass.parentShaders;
						let _g_l = gpass.shaders;
						while(_g_l != s) {
							let s = _g_l.s;
							_g_l = _g_l.next;
							minfoshaders.push(s);
						}
						let _g = 0;
						while(_g < minfoshaders.length) {
							let shader = minfoshaders[_g];
							++_g;
							gpass.removeShader(shader);
						}
						let addshaders = [];
						let s1 = zPass.parentShaders;
						let _g_l1 = zPass.shaders;
						while(_g_l1 != s1) {
							let s = _g_l1.s;
							_g_l1 = _g_l1.next;
							addshaders.push(s);
						}
						let _g1 = 0;
						while(_g1 < addshaders.length) {
							let shader = addshaders[_g1];
							++_g1;
							gpass.addShader(shader);
						}
						minfo.meshbatch.material.addPass(gpass);
					}
					minfo.dtsShader = minfo.meshbatch.material.passes.getShader(shaders_DtsTexture);
					minfo.transparencymeshbatch = new src_MeshBatch((js_Boot.__cast(obj , h3d_scene_Mesh)).primitive,(js_Boot.__cast(obj , h3d_scene_Mesh)).material.clone(),this.scene);
					minfoshaders = [];
					let _this2 = minfo.transparencymeshbatch.material.passes;
					let s2 = _this2.parentShaders;
					let _g_l2 = _this2.shaders;
					while(_g_l2 != s2) {
						let s = _g_l2.s;
						_g_l2 = _g_l2.next;
						minfoshaders.push(s);
					}
					let _g2 = 0;
					while(_g2 < minfoshaders.length) {
						let shader = minfoshaders[_g2];
						++_g2;
						minfo.transparencymeshbatch.material.passes.removeShader(shader);
					}
					minfo.transparencymeshbatch.material.passes.removeShader(minfo.meshbatch.material.textureShader);
					let _this3 = mat.passes;
					let s3 = _this3.parentShaders;
					let _g_l3 = _this3.shaders;
					while(_g_l3 != s3) {
						let s = _g_l3.s;
						_g_l3 = _g_l3.next;
						minfo.transparencymeshbatch.material.passes.addShader(s);
					}
				}
				minfos.push(minfo);
			}
			let curidx = this.objects.length;
			this.objects.push(minfos);
			this.objectMap.h[object.identifier] = curidx;
		}
	}
	isInstanced(object) {
		if(Object.prototype.hasOwnProperty.call(this.objectMap.h,object.identifier)) {
			return true;
		}
		return false;
	}
}
$hxClasses["src.InstanceManager"] = src_InstanceManager;
src_InstanceManager.__name__ = "src.InstanceManager";
Object.assign(src_InstanceManager.prototype, {
	__class__: src_InstanceManager
	,objects: null
	,objectMap: null
	,scene: null
	,opaqueinstances: null
	,transparentinstances: null
});
class src_InteriorObject extends src_GameObject {
	constructor() {
		if(h3d_scene_Object._hx_skip_constructor) {
			super();
			return;
		}
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.useInstancing = true;
		super._hx_constructor();
		this.isCollideable = true;
	}
	init(level,onFinish) {
		this.identifier = this.interiorFile;
		this.level = level;
		if(this.level != null) {
			this.collisionWorld = this.level.collisionWorld;
		}
		if(!src_Util.isIOSInstancingSupported()) {
			this.useInstancing = false;
		}
		src_DifBuilder.loadDif(this.interiorFile,this,onFinish,-1,this.isCollideable);
	}
	setTransform(transform) {
		super.setTransform(transform);
		if(this.isCollideable) {
			this.collider.setTransform(transform);
			this.collisionWorld.updateTransform(this.collider);
		}
	}
}
$hxClasses["src.InteriorObject"] = src_InteriorObject;
src_InteriorObject.__name__ = "src.InteriorObject";
src_InteriorObject.__super__ = src_GameObject;
Object.assign(src_InteriorObject.prototype, {
	__class__: src_InteriorObject
	,collider: null
	,interiorFile: null
	,useInstancing: null
	,level: null
	,collisionWorld: null
});
class src_JSPlatform {
	static initFullscreenEnforcer() {
		let dislikesFullscreen = false;
		let fullscreenEnforcer = window.document.querySelector("#fullscreen-enforcer");
		fullscreenEnforcer.addEventListener("click",function() {
			return window.document.documentElement.requestFullscreen();
		});
		let enterFullscreenButton = window.document.querySelector("#enter-fullscreen");
		enterFullscreenButton.addEventListener("click",function() {
			window.document.documentElement.requestFullscreen();
			dislikesFullscreen = false;
			return dislikesFullscreen;
		});
		let fullscreenButtonVisibility = true;
		let setEnterFullscreenButtonVisibility = function(state) {
			fullscreenButtonVisibility = state;
			let setEnterFullscreenButtonVisibility;
			if(state && src_Util.isTouchDevice()) {
				let reg = new EReg("^((?!chrome|android).)*safari","");
				setEnterFullscreenButtonVisibility = !reg.match($global.navigator.userAgent);
			} else {
				setEnterFullscreenButtonVisibility = false;
			}
			if(setEnterFullscreenButtonVisibility && !(window.innerHeight == window.screen.height || (window.screen.orientation.type == "portrait-primary" || window.screen.orientation.type == "portrait-secondary") && window.innerHeight == window.screen.width || window.document.fullscreenElement != null)) {
				enterFullscreenButton.classList.remove("hidden");
			} else {
				enterFullscreenButton.classList.add("hidden");
			}
		};
		let lastImmunityTime = -Infinity;
		let reg = new EReg("iPad|iPhone|iPod","gm");
		let t1 = reg.match($global.navigator.userAgent);
		let tmp;
		if(!t1) {
			let reg2 = new EReg("Mac","gm");
			tmp = reg2.match($global.navigator.userAgent) && $global.navigator.maxTouchPoints != null && $global.navigator.maxTouchPoints > 2;
		} else {
			tmp = true;
		}
		if(!tmp) {
			window.setInterval(function() {
				if(window.document.activeElement != null) {
					let tmp;
					if(src_Util.isTouchDevice()) {
						let reg = new EReg("^((?!chrome|android).)*safari","");
						tmp = !reg.match($global.navigator.userAgent);
					} else {
						tmp = false;
					}
					if(tmp) {
						if(window.innerHeight == window.screen.height || (window.screen.orientation.type == "portrait-primary" || window.screen.orientation.type == "portrait-secondary") && window.innerHeight == window.screen.width || window.document.fullscreenElement != null) {
							fullscreenEnforcer.classList.add("hidden");
						} else if(!dislikesFullscreen && window.performance.now() - lastImmunityTime > 666) {
							fullscreenEnforcer.classList.remove("hidden");
						}
					}
					setEnterFullscreenButtonVisibility(fullscreenButtonVisibility);
				}
			},250);
		}
	}
}
$hxClasses["src.JSPlatform"] = src_JSPlatform;
src_JSPlatform.__name__ = "src.JSPlatform";
class src_LRUCacheValue_$src_$DifCache {
	constructor() {
	}
}
$hxClasses["src.LRUCacheValue_src_DifCache"] = src_LRUCacheValue_$src_$DifCache;
src_LRUCacheValue_$src_$DifCache.__name__ = "src.LRUCacheValue_src_DifCache";
Object.assign(src_LRUCacheValue_$src_$DifCache.prototype, {
	__class__: src_LRUCacheValue_$src_$DifCache
	,value: null
	,age: null
});
class src_Leaderboards {
	static submitScore(mission,score,rewindUsed,needsReplayCb) {
		if(!mission.startsWith("data/")) {
			mission = "data/" + mission;
		}
		src_Http.post("" + src_Leaderboards.host + "/api/submit",JSON.stringify({ mission : mission, score : score, game : src_Leaderboards.game, name : src_Settings.highscoreName, uid : src_Settings.userId, rewind : rewindUsed ? 1 : 0, platform : 3}),function(b) {
			let s = b.toString();
			let jd = JSON.parse(s);
			let status = jd.status;
			src_Console.instance.addEntry("log","Score submitted");
			needsReplayCb(status == "new_record",status == "new_record" ? jd.rowid : 0);
		},function(e) {
			src_Console.instance.addEntry("log","Score submission failed: " + e);
		});
	}
	static getScores(mission,kind,cb) {
		if(!mission.startsWith("data/")) {
			mission = "data/" + mission;
		}
		return src_Http.get("" + src_Leaderboards.host + "/api/scores?mission=" + encodeURIComponent(mission) + "&game=" + src_Leaderboards.game + "&view=" + kind + "&count=10",function(b) {
			let s = b.toString();
			let scores = JSON.parse(s).scores;
			cb(scores);
		},function(e) {
			src_Console.instance.addEntry("log","Failed to get scores: " + e);
			cb([]);
		});
	}
	static submitReplay(ref,replay) {
		return src_Http.uploadFile("" + src_Leaderboards.host + "/api/record?ref=" + ref,replay,function(b) {
			src_Console.instance.addEntry("log","Replay submitted");
		},function(e) {
			src_Console.instance.addEntry("log","Replay submission failed: " + e);
		});
	}
	static watchTopReplay(mission,kind,cb) {
		if(!mission.startsWith("data/")) {
			mission = "data/" + mission;
		}
		return src_Http.get("" + src_Leaderboards.host + "/api/replay?mission=" + encodeURIComponent(mission) + "&game=" + src_Leaderboards.game + "&view=" + kind,function(b) {
			cb(b);
		},function(e) {
			src_Console.instance.addEntry("log","Failed to get replay: " + e);
			cb(null);
		});
	}
}
$hxClasses["src.Leaderboards"] = src_Leaderboards;
src_Leaderboards.__name__ = "src.Leaderboards";
var src_Mode = $hxEnums["src.Mode"] = { __ename__:true,__constructs__:null
	,Start: {_hx_name:"Start",_hx_index:0,__enum__:"src.Mode",toString:$estr}
	,Play: {_hx_name:"Play",_hx_index:1,__enum__:"src.Mode",toString:$estr}
	,Finish: {_hx_name:"Finish",_hx_index:2,__enum__:"src.Mode",toString:$estr}
};
src_Mode.__constructs__ = [src_Mode.Start,src_Mode.Play,src_Mode.Finish];
src_Mode.__empty_constructs__ = [src_Mode.Start,src_Mode.Play,src_Mode.Finish];
class src_MarbleTestMoveFoundContact {
	constructor(v,n) {
		this.v = v;
		this.n = n;
	}
}
$hxClasses["src.MarbleTestMoveFoundContact"] = src_MarbleTestMoveFoundContact;
src_MarbleTestMoveFoundContact.__name__ = "src.MarbleTestMoveFoundContact";
Object.assign(src_MarbleTestMoveFoundContact.prototype, {
	__class__: src_MarbleTestMoveFoundContact
	,v: null
	,n: null
});
class src_MarbleTestMoveResult {
	constructor(position,t,found,foundContacts,lastContactPos,lastContactNormal,foundMarbles) {
		this.position = position;
		this.t = t;
		this.found = found;
		this.foundContacts = foundContacts;
		this.lastContactPos = lastContactPos;
		this.lastContactNormal = lastContactNormal;
		this.foundMarbles = foundMarbles;
	}
}
$hxClasses["src.MarbleTestMoveResult"] = src_MarbleTestMoveResult;
src_MarbleTestMoveResult.__name__ = "src.MarbleTestMoveResult";
Object.assign(src_MarbleTestMoveResult.prototype, {
	__class__: src_MarbleTestMoveResult
	,position: null
	,t: null
	,found: null
	,foundContacts: null
	,lastContactPos: null
	,lastContactNormal: null
	,foundMarbles: null
});
class src_Marble extends src_GameObject {
	constructor() {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.netFlags = 0;
		this.isNetUpdate = false;
		this._firstTick = true;
		this.isUltra = false;
		this.mode = src_Mode.Play;
		this.finishAnimTime = 0;
		this.playedSounds = [];
		this.bounceEmitDelay = 0;
		this.blastPerc = 0.0;
		this.blastUseTick = 0;
		this.blastTicks = 0;
		this.blastAmount = 0;
		this.megaMarbleUseTick = 0;
		this.helicopterUseTick = 0;
		this.blastUseTime = -1e8;
		this.megaMarbleEnableTime = -1e8;
		this.helicopterEnableTime = -1e8;
		this.outOfBounds = false;
		this.currentUp = new h3d_Vector(0,0,1);
		this.appliedImpulses = [];
		this.queuedContacts = [];
		this.contactEntities = [];
		this.contacts = [];
		this.physicsAccumulator = 0;
		this._bounceRestitution = 0.5;
		this.blastRepulseDist = 10.0;
		this.maxBlastRepulse = 60.0;
		this.bounceMinGain = 0.2;
		this.minVelocityBounceSoft = 2.5;
		this._bounceKineticFriction = 0.2;
		this._minTrailVel = 10;
		this._minBounceSpeed = 3;
		this._minBounceVel = 0.1;
		this._maxDotSlide = 0.5;
		this._airAccel = 5;
		this._gravity = 20;
		this._brakingAcceleration = 30;
		this._staticFriction = 1.1;
		this._kineticFriction = 0.7;
		this._jumpImpulse = 7.5;
		this._angularAcceleration = 75;
		this._maxRollVelocity = 15;
		this._defaultScale = 1;
		this._marbleScale = 1;
		this._renderScale = 1;
		this._radius = 0.2;
		this.controllable = false;
		super._hx_constructor();
		this.velocity = new h3d_Vector();
		this.omega = new h3d_Vector();
		this.camera = new src_CameraController(this);
		this.isCollideable = true;
		this.bounceEmitterData = new src_ParticleData();
		this.bounceEmitterData.identifier = "MarbleBounceParticle";
		this.bounceEmitterData.texture = src_ResourceLoader.getResource("data/particles/burst.png",src_ResourceLoader.getTexture,this.textureResources);
		this.trailEmitterData = new src_ParticleData();
		this.trailEmitterData.identifier = "MarbleTrailParticle";
		this.trailEmitterData.texture = src_ResourceLoader.getResource("data/particles/smoke.png",src_ResourceLoader.getTexture,this.textureResources);
		this.blastEmitterData = new src_ParticleData();
		this.blastEmitterData.identifier = "MarbleBlastParticle";
		this.blastEmitterData.texture = src_ResourceLoader.getResource("data/particles/smoke.png",src_ResourceLoader.getTexture,this.textureResources);
		this.blastMaxEmitterData = new src_ParticleData();
		this.blastMaxEmitterData.identifier = "MarbleBlastMaxParticle";
		this.blastMaxEmitterData.texture = src_ResourceLoader.getResource("data/particles/smoke.png",src_ResourceLoader.getTexture,this.textureResources);
		let tmp = src_ResourceLoader.getResource("data/sound/rolling_hard.wav",src_ResourceLoader.getAudio,this.soundResources);
		let _this = this.getAbsPos();
		let v = new h3d_Vector();
		let x = _this._41;
		let y = _this._42;
		let z = _this._43;
		let w = _this._44;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v.x = x;
		v.y = y;
		v.z = z;
		v.w = w;
		this.rollSound = src_AudioManager.playSound(tmp,v,true);
		let tmp1 = src_ResourceLoader.getResource("data/sound/sliding.wav",src_ResourceLoader.getAudio,this.soundResources);
		let _this1 = this.getAbsPos();
		let v1 = new h3d_Vector();
		let x1 = _this1._41;
		let y1 = _this1._42;
		let z1 = _this1._43;
		let w1 = _this1._44;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		v1.x = x1;
		v1.y = y1;
		v1.z = z1;
		v1.w = w1;
		this.slipSound = src_AudioManager.playSound(tmp1,v1,true);
		this.rollSound.set_volume(0);
		this.slipSound.set_volume(0);
		this.helicopterSound = src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/use_gyrocopter.wav",src_ResourceLoader.getAudio,this.soundResources),null,true);
		this.helicopterSound.set_pause(true);
	}
	init(level,connection,onFinish) {
		this.level = level;
		this.connection = connection;
		if(this.level != null) {
			this.collisionWorld = this.level.collisionWorld;
		}
		let isUltra = true;
		this.posStore = new h3d_Vector();
		this.lastRenderPos = new h3d_Vector();
		this.netSmoothOffset = new h3d_Vector();
		this.netCorrected = false;
		let marbleDts = new src_DtsObject();
		let marbleShader = "";
		marbleDts.identifier = "Marble";
		if(connection == null) {
			src_Console.instance.addEntry("log","Marble: " + src_Settings.optionsSettings.marbleModel + " (" + src_Settings.optionsSettings.marbleSkin + ")");
			marbleDts.dtsPath = src_Settings.optionsSettings.marbleModel;
			marbleDts.matNameOverride.h["base.marble"] = src_Settings.optionsSettings.marbleSkin + ".marble";
			marbleShader = src_Settings.optionsSettings.marbleShader;
		} else {
			let marbleData = gui_MarblePickerGui.marbleData[connection.marbleId];
			src_Console.instance.addEntry("log","Marble: " + marbleData.dts + " (" + marbleData.skin + ")");
			marbleDts.dtsPath = marbleData.dts;
			marbleDts.matNameOverride.h["base.marble"] = marbleData.skin + ".marble";
			marbleShader = marbleData.shader;
		}
		marbleDts.showSequences = false;
		marbleDts.useInstancing = false;
		let dtsFile = src_ResourceLoader.loadDts(marbleDts.dtsPath).resource;
		let marbleMats = marbleDts.getPreloadMaterials(dtsFile);
		let _gthis = this;
		let matWorker = new src_ResourceLoaderWorker(function() {
			marbleDts.init(null,function() {
			});
			let _g = 0;
			let _g1 = marbleDts.materials;
			while(_g < _g1.length) {
				let mat = _g1[_g];
				++_g;
				mat.set_castShadows(false);
				mat.set_castShadows(false);
				mat.set_receiveShadows(false);
				mat.set_receiveShadows(false);
				mat.passes.setPassName("marble");
				if(src_Settings.optionsSettings.reflectionDetail > 0) {
					let csky = level != null ? level.sky : src_MarbleGame.instance.previewWorld.sky;
					_gthis.cubemapRenderer = new shaders_CubemapRenderer(src_MarbleGame.instance.scene,csky,!_gthis.controllable && level != null);
					if(marbleShader == null || marbleShader == "Default" || marbleShader == "" || !isUltra) {
						mat.passes.addShader(new shaders_MarbleReflection(_gthis.cubemapRenderer.cubemap));
					} else {
						let _g = 0;
						let _g1 = marbleDts.graphNodes;
						while(_g < _g1.length) {
							let node = _g1[_g];
							++_g;
							let _g2 = 0;
							let _g3 = node.getMeshes();
							while(_g2 < _g3.length) {
								let chmesh = _g3[_g2];
								++_g2;
								let chpoly = js_Boot.__cast(chmesh.primitive , mesh_Polygon);
								chpoly.addTangents();
							}
						}
						mat.passes.removeShader(mat.textureShader);
						if(marbleShader == "ClassicGlassPureSphere") {
							let marbleNormal = src_ResourceLoader.getTexture("data/shapes/balls/marble01.normal.png").resource;
							let classicGlassShader = new shaders_marble_ClassicGlassPureSphere(mat.get_texture(),marbleNormal,_gthis.cubemapRenderer.cubemap,12,new h3d_Vector(0.6,0.6,0.6,0.6),1);
							mat.passes.addShader(classicGlassShader);
						}
						if(marbleShader == "ClassicMarb") {
							let classicMarb = new shaders_marble_ClassicMarb(mat.get_texture(),_gthis.cubemapRenderer.cubemap,12,new h3d_Vector(0.6,0.6,0.6,0.6),1);
							mat.passes.addShader(classicMarb);
						}
						if(marbleShader == "ClassicMarb2") {
							let classicMarb2 = new shaders_marble_ClassicMarb2(mat.get_texture(),_gthis.cubemapRenderer.cubemap,12,new h3d_Vector(0.6,0.6,0.6,0.6),1);
							mat.passes.addShader(classicMarb2);
						}
						if(marbleShader == "ClassicMarb3") {
							let marbSpecColor = new h3d_Vector(0.6,0.6,0.6,0.6);
							let marbSpec = 12.0;
							if(marbleDts.dtsPath == "data/shapes/balls/marble16.dts") {
								marbSpec = 6;
								marbSpecColor.x = 0.2;
								marbSpecColor.y = 0.2;
								marbSpecColor.z = 0.2;
								marbSpecColor.w = 0.2;
							}
							if(marbleDts.dtsPath == "data/shapes/balls/marble31.dts") {
								marbSpec = 24;
								marbSpecColor.x = 0.3;
								marbSpecColor.y = 0.3;
								marbSpecColor.z = 0.3;
								marbSpecColor.w = 0.3;
							}
							let classicMarb3 = new shaders_marble_ClassicMarb3(mat.get_texture(),_gthis.cubemapRenderer.cubemap,marbSpec,marbSpecColor,1);
							mat.passes.addShader(classicMarb3);
						}
						if(marbleShader == "ClassicMetal") {
							let marbleNormal = src_ResourceLoader.getTexture("data/shapes/balls/marble18.normal.png").resource;
							marbleNormal.set_wrap(h3d_mat_Wrap.Repeat);
							let classicMetalShader = new shaders_marble_ClassicMetal(mat.get_texture(),marbleNormal,_gthis.cubemapRenderer.cubemap,12,new h3d_Vector(0.6,0.6,0.6,0.6),1);
							mat.passes.addShader(classicMetalShader);
						}
						if(marbleShader == "ClassicMarbGlass20") {
							let marbleNormal = src_ResourceLoader.getTexture("data/shapes/balls/marble20.normal.png").resource;
							marbleNormal.set_wrap(h3d_mat_Wrap.Repeat);
							let classicGlassShader = new shaders_marble_ClassicGlass(mat.get_texture(),marbleNormal,_gthis.cubemapRenderer.cubemap,12,new h3d_Vector(0.6,0.6,0.6,0.6),1);
							mat.passes.addShader(classicGlassShader);
						}
						if(marbleShader == "ClassicMarbGlass18") {
							let marbleNormal = src_ResourceLoader.getTexture("data/shapes/balls/marble18.normal.png").resource;
							marbleNormal.set_wrap(h3d_mat_Wrap.Repeat);
							let classicGlassShader = new shaders_marble_ClassicGlass(mat.get_texture(),marbleNormal,_gthis.cubemapRenderer.cubemap,12,new h3d_Vector(0.6,0.6,0.6,0.6),1);
							mat.passes.addShader(classicGlassShader);
						}
						if(marbleShader == "CrystalMarb") {
							let marbleNormal = src_ResourceLoader.getTexture("data/shapes/balls/marble02.normal.png").resource;
							marbleNormal.set_wrap(h3d_mat_Wrap.Repeat);
							let classicGlassShader = new shaders_marble_CrystalMarb(mat.get_texture(),marbleNormal,_gthis.cubemapRenderer.cubemap,1);
							mat.passes.addShader(classicGlassShader);
						}
						let thisprops = mat.getDefaultProps();
						thisprops.light = false;
						mat.set_props(thisprops);
						mat.set_castShadows(true);
						mat.set_castShadows(true);
						mat.set_receiveShadows(true);
						mat.set_receiveShadows(false);
						mat.passes.setPassName("marble");
					}
				}
			}
			let b = marbleDts.getBounds();
			let avgRadius = (b.xMax - b.xMin + (b.yMax - b.yMin) + (b.zMax - b.zMin)) / 6;
			if(isUltra) {
				_gthis._radius = 0.3;
				_gthis._renderScale = 0.3 / avgRadius;
				_gthis._marbleScale = _gthis._renderScale;
				_gthis._defaultScale = _gthis._marbleScale;
				let v = 0.3 / avgRadius;
				let v1 = marbleDts.scaleX * v;
				marbleDts.scaleX = v1;
				marbleDts.flags |= 1;
				let v2 = marbleDts.scaleY * v;
				marbleDts.scaleY = v2;
				marbleDts.flags |= 1;
				let v3 = marbleDts.scaleZ * v;
				marbleDts.scaleZ = v3;
				marbleDts.flags |= 1;
				marbleDts.flags |= 1;
			} else {
				_gthis._radius = avgRadius;
			}
			_gthis._prevRadius = _gthis._radius;
			if(isUltra) {
				let matWorker = src_ResourceLoader.getResource("data/sound/mega_roll.wav",src_ResourceLoader.getAudio,_gthis.soundResources);
				let _this = _gthis.getAbsPos();
				let v = new h3d_Vector();
				let x = _this._41;
				let y = _this._42;
				let z = _this._43;
				let w = _this._44;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				v.x = x;
				v.y = y;
				v.z = z;
				v.w = w;
				_gthis.rollMegaSound = src_AudioManager.playSound(matWorker,v,true);
				_gthis.rollMegaSound.set_volume(0);
			}
			_gthis.isUltra = isUltra;
			_gthis.collider = new collision_SphereCollisionEntity(_gthis);
			_gthis.collider.setTransform(_gthis.getAbsPos());
			_gthis.addChild(marbleDts);
			_gthis.buildShadowVolume();
			if(level != null) {
				level.scene.addChild(_gthis.shadowVolume);
			}
			_gthis.blastWave = new shapes_BlastWave();
			let _this = _gthis.blastWave;
			_this.x = 1e8;
			_this.flags |= 1;
			let _this1 = _gthis.blastWave;
			_this1.y = 1e8;
			_this1.flags |= 1;
			let _this2 = _gthis.blastWave;
			_this2.z = 1e8;
			_this2.flags |= 1;
			_gthis.blastWave.isBoundingBoxCollideable = false;
			_gthis.helicopter = new shapes_HelicopterImage();
			_gthis.helicopter.isBoundingBoxCollideable = false;
			let _this3 = _gthis.helicopter;
			_this3.x = 1e8;
			_this3.flags |= 1;
			let _this4 = _gthis.helicopter;
			_this4.y = 1e8;
			_this4.flags |= 1;
			let _this5 = _gthis.helicopter;
			_this5.z = 1e8;
			_this5.flags |= 1;
			let _this6 = _gthis.helicopter;
			let v = _this6.scaleX * 1.4999999999999998;
			_this6.scaleX = v;
			_this6.flags |= 1;
			let v1 = _this6.scaleY * 1.4999999999999998;
			_this6.scaleY = v1;
			_this6.flags |= 1;
			let v2 = _this6.scaleZ * 1.4999999999999998;
			_this6.scaleZ = v2;
			_this6.flags |= 1;
			_this6.flags |= 1;
			_gthis.loadMarbleAttributes();
			if(_gthis.controllable || _gthis.connection != null) {
				let worker = new src_ResourceLoaderWorker(onFinish);
				worker.addTask(function(fwd) {
					level.addDtsObject(_gthis.helicopter,fwd);
				});
				worker.addTask(function(fwd) {
					level.addDtsObject(_gthis.blastWave,fwd);
				});
				worker.run();
			} else {
				onFinish();
			}
		});
		let _g = 0;
		while(_g < marbleMats.length) {
			let texPath = marbleMats[_g];
			++_g;
			matWorker.loadFile(texPath);
		}
		matWorker.run();
	}
	buildShadowVolume() {
		let idx = new Array(0);
		let _g = 1;
		while(_g < 32) {
			let i = _g++;
			idx.push(0);
			idx.push(i + 1);
			idx.push(i);
		}
		idx.push(0);
		idx.push(1);
		idx.push(32);
		let _g1 = 1;
		while(_g1 < 31) {
			let i = _g1++;
			idx.push(1);
			idx.push(i + 1);
			idx.push(i + 2);
		}
		let pts = [];
		pts.push(new h3d_col_Point(0,0,-7.0));
		let _g2 = 0;
		while(_g2 < 32) {
			let i = _g2++;
			let x = i / 31 * (2 * Math.PI);
			pts.push(new h3d_col_Point(Math.cos(x) * 0.2,-Math.sin(x) * 0.2,0.0));
		}
		let shadowPoly = new h3d_prim_Polygon(pts,idx);
		shadowPoly.addUVs();
		shadowPoly.addNormals();
		this.shadowVolume = new h3d_scene_Mesh(shadowPoly,h3d_mat_Material.create());
		this.shadowVolume.material.set_castShadows(false);
		this.shadowVolume.material.set_receiveShadows(false);
		let _this = this.shadowVolume.material;
		_this.set_castShadows(false);
		_this.set_receiveShadows(false);
		let colShader = new h3d_shader_FixedColor(38,0.35);
		let shadowPass1 = this.shadowVolume.material.passes.clone();
		shadowPass1.setPassName("shadowPass1");
		shadowPass1.stencil = new h3d_mat_Stencil();
		shadowPass1.stencil.setFunc(h3d_mat_Compare.Always,1,255,255);
		shadowPass1.depth(false,h3d_mat_Compare.Less);
		shadowPass1.setColorMask(false,false,false,false);
		shadowPass1.set_culling(h3d_mat_Face.Back);
		shadowPass1.stencil.setOp(h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Increment,h3d_mat_StencilOp.Keep);
		shadowPass1.addShader(colShader);
		let shadowPass2 = this.shadowVolume.material.passes.clone();
		shadowPass2.setPassName("shadowPass2");
		shadowPass2.stencil = new h3d_mat_Stencil();
		shadowPass2.stencil.setFunc(h3d_mat_Compare.Always,1,255,255);
		shadowPass2.depth(false,h3d_mat_Compare.Less);
		shadowPass2.setColorMask(false,false,false,false);
		shadowPass2.set_culling(h3d_mat_Face.Front);
		shadowPass2.stencil.setOp(h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Decrement,h3d_mat_StencilOp.Keep);
		shadowPass2.addShader(colShader);
		let shadowPass3 = this.shadowVolume.material.passes.clone();
		shadowPass3.setPassName("shadowPass3");
		shadowPass3.stencil = new h3d_mat_Stencil();
		shadowPass3.stencil.setFunc(h3d_mat_Compare.LessEqual,1,255,255);
		shadowPass3.depth(false,h3d_mat_Compare.Less);
		shadowPass3.set_culling(h3d_mat_Face.Front);
		shadowPass3.stencil.setOp(h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep,h3d_mat_StencilOp.Keep);
		let src = h3d_mat_Blend.SrcAlpha;
		let dst = h3d_mat_Blend.OneMinusSrcAlpha;
		shadowPass3.set_blendSrc(src);
		shadowPass3.set_blendAlphaSrc(src);
		shadowPass3.set_blendDst(dst);
		shadowPass3.set_blendAlphaDst(dst);
		shadowPass3.addShader(colShader);
		this.shadowVolume.material.addPass(shadowPass1);
		this.shadowVolume.material.addPass(shadowPass2);
		this.shadowVolume.material.addPass(shadowPass3);
		this.shadowVolume.material.removePass(this.shadowVolume.material.passes);
	}
	loadMarbleAttributes() {
		if(this.level == null || this.level.mission == null) {
			return;
		}
		let attribs = this.level.mission.marbleAttributes;
		if(Object.prototype.hasOwnProperty.call(attribs.h,"maxrollvelocity")) {
			this._maxRollVelocity = mis_MisParser.parseNumber(attribs.h["maxrollvelocity"]);
		}
		if(Object.prototype.hasOwnProperty.call(attribs.h,"angularacceleration")) {
			this._angularAcceleration = mis_MisParser.parseNumber(attribs.h["angularacceleration"]);
		}
		if(Object.prototype.hasOwnProperty.call(attribs.h,"jumpimpulse")) {
			this._jumpImpulse = mis_MisParser.parseNumber(attribs.h["jumpimpulse"]);
		}
		if(Object.prototype.hasOwnProperty.call(attribs.h,"kineticfriction")) {
			this._kineticFriction = mis_MisParser.parseNumber(attribs.h["kineticfriction"]);
		}
		if(Object.prototype.hasOwnProperty.call(attribs.h,"staticfriction")) {
			this._staticFriction = mis_MisParser.parseNumber(attribs.h["staticfriction"]);
		}
		if(Object.prototype.hasOwnProperty.call(attribs.h,"brakingacceleration")) {
			this._brakingAcceleration = mis_MisParser.parseNumber(attribs.h["brakingacceleration"]);
		}
		if(Object.prototype.hasOwnProperty.call(attribs.h,"gravity")) {
			this._gravity = mis_MisParser.parseNumber(attribs.h["gravity"]);
		}
		if(Object.prototype.hasOwnProperty.call(attribs.h,"airaccel")) {
			this._airAccel = mis_MisParser.parseNumber(attribs.h["airaccel"]);
		}
		if(Object.prototype.hasOwnProperty.call(attribs.h,"maxdotslide")) {
			this._maxDotSlide = mis_MisParser.parseNumber(attribs.h["maxdotslide"]);
		}
		if(Object.prototype.hasOwnProperty.call(attribs.h,"minbouncevel")) {
			this._minBounceVel = mis_MisParser.parseNumber(attribs.h["minbouncevel"]);
		}
		if(Object.prototype.hasOwnProperty.call(attribs.h,"minbouncespeed")) {
			this._minBounceSpeed = mis_MisParser.parseNumber(attribs.h["minbouncespeed"]);
		}
		if(Object.prototype.hasOwnProperty.call(attribs.h,"mintrailvel")) {
			this._minTrailVel = mis_MisParser.parseNumber(attribs.h["mintrailvel"]);
		}
		if(Object.prototype.hasOwnProperty.call(attribs.h,"bouncekineticfriction")) {
			this._bounceKineticFriction = mis_MisParser.parseNumber(attribs.h["bouncekineticfriction"]);
		}
	}
	findContacts(collisionWorld,timeState) {
		this.contacts = this.queuedContacts;
		collision_CollisionPool.clear();
		let c = collisionWorld.sphereIntersection(this.collider,timeState);
		this.contactEntities = c.foundEntities;
		this.contacts = this.contacts.concat(c.contacts);
	}
	getMarbleAxis() {
		let motiondir = new h3d_Vector(0,-1,0);
		if(this.controllable && !this.isNetUpdate) {
			let m = h3d_Matrix.R(0,0,this.camera.CameraYaw);
			let px = motiondir.x * m._11 + motiondir.y * m._21 + motiondir.z * m._31 + motiondir.w * m._41;
			let py = motiondir.x * m._12 + motiondir.y * m._22 + motiondir.z * m._32 + motiondir.w * m._42;
			let pz = motiondir.x * m._13 + motiondir.y * m._23 + motiondir.z * m._33 + motiondir.w * m._43;
			let pw = motiondir.x * m._14 + motiondir.y * m._24 + motiondir.z * m._34 + motiondir.w * m._44;
			motiondir.x = px;
			motiondir.y = py;
			motiondir.z = pz;
			motiondir.w = pw;
			let _this = this.level.newOrientationQuat;
			let m1 = null;
			m1 = new h3d_Matrix();
			let xx = _this.x * _this.x;
			let xy = _this.x * _this.y;
			let xz = _this.x * _this.z;
			let xw = _this.x * _this.w;
			let yy = _this.y * _this.y;
			let yz = _this.y * _this.z;
			let yw = _this.y * _this.w;
			let zz = _this.z * _this.z;
			let zw = _this.z * _this.w;
			m1._11 = 1 - 2 * (yy + zz);
			m1._12 = 2 * (xy + zw);
			m1._13 = 2 * (xz - yw);
			m1._14 = 0;
			m1._21 = 2 * (xy - zw);
			m1._22 = 1 - 2 * (xx + zz);
			m1._23 = 2 * (yz + xw);
			m1._24 = 0;
			m1._31 = 2 * (xz + yw);
			m1._32 = 2 * (yz - xw);
			m1._33 = 1 - 2 * (xx + yy);
			m1._34 = 0;
			m1._41 = 0;
			m1._42 = 0;
			m1._43 = 0;
			m1._44 = 1;
			let m2 = m1;
			let px1 = motiondir.x * m2._11 + motiondir.y * m2._21 + motiondir.z * m2._31 + motiondir.w * m2._41;
			let py1 = motiondir.x * m2._12 + motiondir.y * m2._22 + motiondir.z * m2._32 + motiondir.w * m2._42;
			let pz1 = motiondir.x * m2._13 + motiondir.y * m2._23 + motiondir.z * m2._33 + motiondir.w * m2._43;
			let pw1 = motiondir.x * m2._14 + motiondir.y * m2._24 + motiondir.z * m2._34 + motiondir.w * m2._44;
			motiondir.x = px1;
			motiondir.y = py1;
			motiondir.z = pz1;
			motiondir.w = pw1;
			let updir = this.currentUp;
			let sidedir = new h3d_Vector(motiondir.y * updir.z - motiondir.z * updir.y,motiondir.z * updir.x - motiondir.x * updir.z,motiondir.x * updir.y - motiondir.y * updir.x,1);
			let k = sidedir.x * sidedir.x + sidedir.y * sidedir.y + sidedir.z * sidedir.z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			sidedir.x *= k;
			sidedir.y *= k;
			sidedir.z *= k;
			motiondir = new h3d_Vector(updir.y * sidedir.z - updir.z * sidedir.y,updir.z * sidedir.x - updir.x * sidedir.z,updir.x * sidedir.y - updir.y * sidedir.x,1);
			return [sidedir,motiondir,updir];
		} else {
			if(this.moveMotionDir != null) {
				motiondir = this.moveMotionDir;
			}
			let updir = this.currentUp;
			let sidedir = new h3d_Vector(motiondir.y * updir.z - motiondir.z * updir.y,motiondir.z * updir.x - motiondir.x * updir.z,motiondir.x * updir.y - motiondir.y * updir.x,1);
			return [sidedir,motiondir,updir];
		}
	}
	getExternalForces(timeState,m) {
		if(this.mode == src_Mode.Finish) {
			let _this = this.velocity;
			return new h3d_Vector(_this.x * -16,_this.y * -16,_this.z * -16,_this.w);
		}
		let _this = this.currentUp;
		let x = _this.x * -1;
		let y = _this.y * -1;
		let z = _this.z * -1;
		let w = _this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let gWorkGravityDir_x = x;
		let gWorkGravityDir_y = y;
		let gWorkGravityDir_z = z;
		let gWorkGravityDir_w = w;
		let A = new h3d_Vector();
		let v = this._gravity;
		A = new h3d_Vector(gWorkGravityDir_x * v,gWorkGravityDir_y * v,gWorkGravityDir_z * v,gWorkGravityDir_w);
		let helicopter = this.level == null ? false : !this.level.isMultiplayer ? timeState.currentAttemptTime - this.helicopterEnableTime < 5 : net_Net.isHost ? this.helicopterUseTick > 0 && this.level.timeState.ticks - this.helicopterUseTick <= 156 : this.helicopterUseTick > 0 && this.serverTicks - this.helicopterUseTick <= 156;
		if(helicopter) {
			A = new h3d_Vector(A.x * 0.25,A.y * 0.25,A.z * 0.25,A.w);
		}
		if(this.level != null) {
			let mass = this.getMass();
			let _g = 0;
			let _g1 = this.level.forceObjects;
			while(_g < _g1.length) {
				let obj = _g1[_g];
				++_g;
				let _this = this.collider.transform;
				let v = new h3d_Vector();
				let x = _this._41;
				let y = _this._42;
				let z = _this._43;
				let w = _this._44;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				v.x = x;
				v.y = y;
				v.z = z;
				v.w = w;
				let force = (js_Boot.__cast(obj , src_ForceObject)).getForce(v);
				let v1 = 1 / mass;
				let x1 = force.x * v1;
				let y1 = force.y * v1;
				let z1 = force.z * v1;
				let w1 = force.w;
				if(w1 == null) {
					w1 = 1.;
				}
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let v_x = x1;
				let v_y = y1;
				let v_z = z1;
				let v_w = w1;
				A = new h3d_Vector(A.x + v_x,A.y + v_y,A.z + v_z,A.w + v_w);
			}
			let _g2 = 0;
			let _g3 = this.level.marbles;
			while(_g2 < _g3.length) {
				let marble = _g3[_g2];
				++_g2;
				if(marble != this && !marble._firstTick) {
					let _this = this.collider.transform;
					let v = new h3d_Vector();
					let x = _this._41;
					let y = _this._42;
					let z = _this._43;
					let w = _this._44;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					v.x = x;
					v.y = y;
					v.z = z;
					v.w = w;
					let force = marble.getForce(v,net_Net.isHost ? timeState.ticks : this.serverTicks);
					let v1 = 1 / mass;
					let x1 = force.x * v1;
					let y1 = force.y * v1;
					let z1 = force.z * v1;
					let w1 = force.w;
					if(w1 == null) {
						w1 = 1.;
					}
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let v_x = x1;
					let v_y = y1;
					let v_z = z1;
					let v_w = w1;
					A = new h3d_Vector(A.x + v_x,A.y + v_y,A.z + v_z,A.w + v_w);
				}
			}
		}
		if(this.contacts.length != 0 && this.mode != src_Mode.Start) {
			let contactForce = 0.0;
			let contactNormal_x = 0.;
			let contactNormal_y = 0.;
			let contactNormal_z = 0.;
			let contactNormal_w = 1.;
			let forceObjectCount = 0;
			let forceObjects = [];
			let _g = 0;
			let _g1 = this.contacts;
			while(_g < _g1.length) {
				let contact = _g1[_g];
				++_g;
				if(contact.force != 0 && !forceObjects.includes(contact.otherObject)) {
					if(((contact.otherObject) instanceof shapes_RoundBumper)) {
						if(!this.level.isReplayingMovement && !this.playedSounds.includes("data/sound/bumperding1.wav") && !this.isNetUpdate) {
							if(this.level.marble == this) {
								src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/bumperding1.wav",src_ResourceLoader.getAudio,this.soundResources));
							} else {
								let tmp = src_ResourceLoader.getResource("data/sound/bumperding1.wav",src_ResourceLoader.getAudio,this.soundResources);
								let _this = this.getAbsPos();
								let v = new h3d_Vector();
								let x = _this._41;
								let y = _this._42;
								let z = _this._43;
								let w = _this._44;
								if(w == null) {
									w = 1.;
								}
								if(z == null) {
									z = 0.;
								}
								if(y == null) {
									y = 0.;
								}
								if(x == null) {
									x = 0.;
								}
								v.x = x;
								v.y = y;
								v.z = z;
								v.w = w;
								src_AudioManager.playSound(tmp,v);
							}
							this.playedSounds.push("data/sound/bumperding1.wav");
						}
					}
					++forceObjectCount;
					let v = contact.normal;
					let x = contactNormal_x + v.x;
					let y = contactNormal_y + v.y;
					let z = contactNormal_z + v.z;
					let w = contactNormal_w + v.w;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let v_x = x;
					let v_y = y;
					let v_z = z;
					let v_w = w;
					contactNormal_x = v_x;
					contactNormal_y = v_y;
					contactNormal_z = v_z;
					contactNormal_w = v_w;
					contactForce += contact.force;
					forceObjects.push(contact.otherObject);
				}
			}
			if(forceObjectCount != 0) {
				let k = contactNormal_x * contactNormal_x + contactNormal_y * contactNormal_y + contactNormal_z * contactNormal_z;
				if(k < 1e-10) {
					k = 0;
				} else {
					k = 1. / Math.sqrt(k);
				}
				contactNormal_x *= k;
				contactNormal_y *= k;
				contactNormal_z *= k;
				let a = contactForce / this.getMass();
				let _this = this.velocity;
				let dot = _this.x * contactNormal_x + _this.y * contactNormal_y + _this.z * contactNormal_z;
				if(a > dot) {
					if(dot > 0) {
						a -= dot;
					}
					let v = a / timeState.dt;
					let x = contactNormal_x * v;
					let y = contactNormal_y * v;
					let z = contactNormal_z * v;
					let w = contactNormal_w;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let v_x = x;
					let v_y = y;
					let v_z = z;
					let v_w = w;
					let x1 = A.x + v_x;
					let y1 = A.y + v_y;
					let z1 = A.z + v_z;
					let w1 = A.w + v_w;
					if(w1 == null) {
						w1 = 1.;
					}
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let v_x1 = x1;
					let v_y1 = y1;
					let v_z1 = z1;
					let v_w1 = w1;
					A.x = v_x1;
					A.y = v_y1;
					A.z = v_z1;
					A.w = v_w1;
				}
			}
		}
		if(this.contacts.length == 0 && this.mode != src_Mode.Start) {
			let axes = this.getMarbleAxis();
			let sideDir = axes[0];
			let motionDir = axes[1];
			let airAccel = this._airAccel;
			if(helicopter) {
				airAccel *= 2;
			}
			let v = m.d.x;
			let x = sideDir.x * v;
			let y = sideDir.y * v;
			let z = sideDir.z * v;
			let w = sideDir.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let _this_x = x;
			let _this_y = y;
			let _this_z = z;
			let _this_w = w;
			let v1 = m.d.y;
			let x1 = motionDir.x * v1;
			let y1 = motionDir.y * v1;
			let z1 = motionDir.z * v1;
			let w1 = motionDir.w;
			if(w1 == null) {
				w1 = 1.;
			}
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let v_x = x1;
			let v_y = y1;
			let v_z = z1;
			let v_w = w1;
			let x2 = _this_x + v_x;
			let y2 = _this_y + v_y;
			let z2 = _this_z + v_z;
			let w2 = _this_w + v_w;
			if(w2 == null) {
				w2 = 1.;
			}
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let _this_x1 = x2;
			let _this_y1 = y2;
			let _this_z1 = z2;
			let _this_w1 = w2;
			let x3 = _this_x1 * airAccel;
			let y3 = _this_y1 * airAccel;
			let z3 = _this_z1 * airAccel;
			let w3 = _this_w1;
			if(_this_w1 == null) {
				w3 = 1.;
			}
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			let v_x1 = x3;
			let v_y1 = y3;
			let v_z1 = z3;
			let v_w1 = w3;
			let x4 = A.x + v_x1;
			let y4 = A.y + v_y1;
			let z4 = A.z + v_z1;
			let w4 = A.w + v_w1;
			if(w4 == null) {
				w4 = 1.;
			}
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			let v_x2 = x4;
			let v_y2 = y4;
			let v_z2 = z4;
			let v_w2 = w4;
			A.x = v_x2;
			A.y = v_y2;
			A.z = v_z2;
			A.w = v_w2;
		}
		return A;
	}
	computeMoveForces(m,aControl,desiredOmega) {
		if(this.currentUp == null) {
			this.currentUp = new h3d_Vector(0,0,1);
		}
		let _this = this.currentUp;
		let v = this._radius;
		let x = _this.x * v;
		let y = _this.y * v;
		let z = _this.z * v;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let R_x = x;
		let R_y = y;
		let R_z = z;
		let _this1 = this.omega;
		let x1 = _this1.y * R_z - _this1.z * R_y;
		let y1 = _this1.z * R_x - _this1.x * R_z;
		let z1 = _this1.x * R_y - _this1.y * R_x;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let rollVelocity_x = x1;
		let rollVelocity_y = y1;
		let rollVelocity_z = z1;
		let axes = this.getMarbleAxis();
		let sideDir = axes[0];
		let motionDir = axes[1];
		let currentYVelocity = rollVelocity_x * motionDir.x + rollVelocity_y * motionDir.y + rollVelocity_z * motionDir.z;
		let currentXVelocity = rollVelocity_x * sideDir.x + rollVelocity_y * sideDir.y + rollVelocity_z * sideDir.z;
		let mv = m.d;
		mv = new h3d_Vector(mv.x * 1.538461565971375,mv.y * 1.538461565971375,mv.z * 1.538461565971375,mv.w);
		let mvlen = Math.sqrt(mv.x * mv.x + mv.y * mv.y);
		if(mvlen > 1) {
			let f = 1 / mvlen;
			mv.x *= f;
			mv.y *= f;
			mv.z *= f;
		}
		let desiredYVelocity = this._maxRollVelocity * mv.y;
		let desiredXVelocity = this._maxRollVelocity * mv.x;
		if(desiredYVelocity != 0 || desiredXVelocity != 0) {
			if(currentYVelocity > desiredYVelocity && desiredYVelocity > 0) {
				desiredYVelocity = currentYVelocity;
			} else if(currentYVelocity < desiredYVelocity && desiredYVelocity < 0) {
				desiredYVelocity = currentYVelocity;
			}
			if(currentXVelocity > desiredXVelocity && desiredXVelocity > 0) {
				desiredXVelocity = currentXVelocity;
			} else if(currentXVelocity < desiredXVelocity && desiredXVelocity < 0) {
				desiredXVelocity = currentXVelocity;
			}
			let rsq = R_x * R_x + R_y * R_y + R_z * R_z;
			let x = motionDir.x * desiredYVelocity;
			let y = motionDir.y * desiredYVelocity;
			let z = motionDir.z * desiredYVelocity;
			let w = motionDir.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let _this_x = x;
			let _this_y = y;
			let _this_z = z;
			let x1 = sideDir.x * desiredXVelocity;
			let y1 = sideDir.y * desiredXVelocity;
			let z1 = sideDir.z * desiredXVelocity;
			let w1 = sideDir.w;
			if(w1 == null) {
				w1 = 1.;
			}
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let v_x = x1;
			let v_y = y1;
			let v_z = z1;
			let x2 = _this_x + v_x;
			let y2 = _this_y + v_y;
			let z2 = _this_z + v_z;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let v_x1 = x2;
			let v_y1 = y2;
			let v_z1 = z2;
			let x3 = R_y * v_z1 - R_z * v_y1;
			let y3 = R_z * v_x1 - R_x * v_z1;
			let z3 = R_x * v_y1 - R_y * v_x1;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			let _this_x1 = x3;
			let _this_y1 = y3;
			let _this_z1 = z3;
			let _this_w = 1;
			let v = 1 / rsq;
			let x4 = _this_x1 * v;
			let y4 = _this_y1 * v;
			let z4 = _this_z1 * v;
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			let crossP_x = x4;
			let crossP_y = y4;
			let crossP_z = z4;
			let crossP_w = _this_w;
			desiredOmega.x = crossP_x;
			desiredOmega.y = crossP_y;
			desiredOmega.z = crossP_z;
			desiredOmega.w = crossP_w;
			let v1 = this.omega;
			let x5 = desiredOmega.x - v1.x;
			let y5 = desiredOmega.y - v1.y;
			let z5 = desiredOmega.z - v1.z;
			let w2 = desiredOmega.w - v1.w;
			if(w2 == null) {
				w2 = 1.;
			}
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			let v_x2 = x5;
			let v_y2 = y5;
			let v_z2 = z5;
			let v_w = w2;
			aControl.x = v_x2;
			aControl.y = v_y2;
			aControl.z = v_z2;
			aControl.w = v_w;
			let aScalar = Math.sqrt(aControl.x * aControl.x + aControl.y * aControl.y + aControl.z * aControl.z);
			if(aScalar > this._angularAcceleration) {
				let f = this._angularAcceleration / aScalar;
				aControl.x *= f;
				aControl.y *= f;
				aControl.z *= f;
			}
			return false;
		}
		return true;
	}
	velocityCancel(currentTime,dt,surfaceSlide,noBounce,stoppedPaths,pi) {
		let looped = false;
		let itersIn = 0;
		let done;
		do {
			done = true;
			++itersIn;
			let _g = 0;
			let _g1 = this.contacts.length;
			while(_g < _g1) {
				let i = _g++;
				let _this = this.velocity;
				let v = this.contacts[i].velocity;
				let x = _this.x - v.x;
				let y = _this.y - v.y;
				let z = _this.z - v.z;
				let w = _this.w - v.w;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let sVel_x = x;
				let sVel_y = y;
				let sVel_z = z;
				let sVel_w = w;
				let _this1 = this.contacts[i].normal;
				let surfaceDot = _this1.x * sVel_x + _this1.y * sVel_y + _this1.z * sVel_z;
				if(!looped && surfaceDot < 0.0 || surfaceDot < -0.0001) {
					let _this = this.velocity;
					let velLen = Math.sqrt(_this.x * _this.x + _this.y * _this.y + _this.z * _this.z);
					let _this1 = this.contacts[i].normal;
					let x = _this1.x * surfaceDot;
					let y = _this1.y * surfaceDot;
					let z = _this1.z * surfaceDot;
					let w = _this1.w;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let surfaceVel_x = x;
					let surfaceVel_y = y;
					let surfaceVel_z = z;
					let surfaceVel_w = w;
					if(!this._bounceYet) {
						this._bounceYet = true;
						this.playBoundSound(currentTime,-surfaceDot);
					}
					if(noBounce) {
						let _this = this.velocity;
						let _this1 = this.velocity;
						let x = _this1.x - surfaceVel_x;
						let y = _this1.y - surfaceVel_y;
						let z = _this1.z - surfaceVel_z;
						let w = _this1.w - surfaceVel_w;
						if(w == null) {
							w = 1.;
						}
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let v_x = x;
						let v_y = y;
						let v_z = z;
						let v_w = w;
						_this.x = v_x;
						_this.y = v_y;
						_this.z = v_z;
						_this.w = v_w;
					} else if(this.contacts[i].collider != null) {
						let otherMarble = this.contacts[i].collider.go;
						let ourMass = this.getMass();
						let theirMass = otherMarble.getMass();
						let bounce = Math.max(this._bounceRestitution,otherMarble._bounceRestitution);
						let _this = this.velocity;
						let x = _this.x * ourMass;
						let y = _this.y * ourMass;
						let z = _this.z * ourMass;
						let w = _this.w;
						if(w == null) {
							w = 1.;
						}
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let _this_x = x;
						let _this_y = y;
						let _this_z = z;
						let _this1 = otherMarble.velocity;
						let x1 = _this1.x * theirMass;
						let y1 = _this1.y * theirMass;
						let z1 = _this1.z * theirMass;
						let w1 = _this1.w;
						if(w1 == null) {
							w1 = 1.;
						}
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let v_x = x1;
						let v_y = y1;
						let v_z = z1;
						let x2 = _this_x - v_x;
						let y2 = _this_y - v_y;
						let z2 = _this_z - v_z;
						if(z2 == null) {
							z2 = 0.;
						}
						if(y2 == null) {
							y2 = 0.;
						}
						if(x2 == null) {
							x2 = 0.;
						}
						let dp_x = x2;
						let dp_y = y2;
						let dp_z = z2;
						let _this2 = this.contacts[i].normal;
						let v = this.contacts[i].normal;
						let v1 = dp_x * v.x + dp_y * v.y + dp_z * v.z;
						let x3 = _this2.x * v1;
						let y3 = _this2.y * v1;
						let z3 = _this2.z * v1;
						let w2 = _this2.w;
						if(w2 == null) {
							w2 = 1.;
						}
						if(z3 == null) {
							z3 = 0.;
						}
						if(y3 == null) {
							y3 = 0.;
						}
						if(x3 == null) {
							x3 = 0.;
						}
						let normP_x = x3;
						let normP_y = y3;
						let normP_z = z3;
						let normP_w = w2;
						let f = 1 + bounce;
						normP_x *= f;
						normP_y *= f;
						normP_z *= f;
						let _this3 = this.velocity;
						let _this4 = this.velocity;
						let v2 = 1 / ourMass;
						let x4 = normP_x * v2;
						let y4 = normP_y * v2;
						let z4 = normP_z * v2;
						let w3 = normP_w;
						if(normP_w == null) {
							w3 = 1.;
						}
						if(z4 == null) {
							z4 = 0.;
						}
						if(y4 == null) {
							y4 = 0.;
						}
						if(x4 == null) {
							x4 = 0.;
						}
						let v_x1 = x4;
						let v_y1 = y4;
						let v_z1 = z4;
						let v_w = w3;
						let x5 = _this4.x - v_x1;
						let y5 = _this4.y - v_y1;
						let z5 = _this4.z - v_z1;
						let w4 = _this4.w - v_w;
						if(w4 == null) {
							w4 = 1.;
						}
						if(z5 == null) {
							z5 = 0.;
						}
						if(y5 == null) {
							y5 = 0.;
						}
						if(x5 == null) {
							x5 = 0.;
						}
						let v_x2 = x5;
						let v_y2 = y5;
						let v_z2 = z5;
						let v_w1 = w4;
						_this3.x = v_x2;
						_this3.y = v_y2;
						_this3.z = v_z2;
						_this3.w = v_w1;
						let _this5 = this.velocity;
						let f1 = _this5.x * _this5.x + _this5.y * _this5.y + _this5.z * _this5.z;
						if(isNaN(f1)) {
							let _this = this.velocity;
							_this.x = 0;
							_this.y = 0;
							_this.z = 0;
							_this.w = 1.;
						}
						let _this6 = otherMarble.velocity;
						let _this7 = otherMarble.velocity;
						let v3 = 1 / theirMass;
						let x6 = normP_x * v3;
						let y6 = normP_y * v3;
						let z6 = normP_z * v3;
						let w5 = normP_w;
						if(normP_w == null) {
							w5 = 1.;
						}
						if(z6 == null) {
							z6 = 0.;
						}
						if(y6 == null) {
							y6 = 0.;
						}
						if(x6 == null) {
							x6 = 0.;
						}
						let v_x3 = x6;
						let v_y3 = y6;
						let v_z3 = z6;
						let v_w2 = w5;
						let x7 = _this7.x + v_x3;
						let y7 = _this7.y + v_y3;
						let z7 = _this7.z + v_z3;
						let w6 = _this7.w + v_w2;
						if(w6 == null) {
							w6 = 1.;
						}
						if(z7 == null) {
							z7 = 0.;
						}
						if(y7 == null) {
							y7 = 0.;
						}
						if(x7 == null) {
							x7 = 0.;
						}
						let v_x4 = x7;
						let v_y4 = y7;
						let v_z4 = z7;
						let v_w3 = w6;
						_this6.x = v_x4;
						_this6.y = v_y4;
						_this6.z = v_z4;
						_this6.w = v_w3;
						let _this8 = otherMarble.velocity;
						let f2 = _this8.x * _this8.x + _this8.y * _this8.y + _this8.z * _this8.z;
						if(isNaN(f2)) {
							let _this = otherMarble.velocity;
							_this.x = 0;
							_this.y = 0;
							_this.z = 0;
							_this.w = 1.;
						}
						let _this9 = this.contacts[i].velocity;
						let v4 = otherMarble.velocity;
						_this9.x = v4.x;
						_this9.y = v4.y;
						_this9.z = v4.z;
						_this9.w = v4.w;
					} else {
						let _this = this.contacts[i].velocity;
						if(Math.sqrt(_this.x * _this.x + _this.y * _this.y + _this.z * _this.z) == 0.0 && !surfaceSlide && surfaceDot > -this._maxDotSlide * velLen) {
							let _this = this.velocity;
							let _this1 = this.velocity;
							let x = _this1.x - surfaceVel_x;
							let y = _this1.y - surfaceVel_y;
							let z = _this1.z - surfaceVel_z;
							let w = _this1.w - surfaceVel_w;
							if(w == null) {
								w = 1.;
							}
							if(z == null) {
								z = 0.;
							}
							if(y == null) {
								y = 0.;
							}
							if(x == null) {
								x = 0.;
							}
							let v_x = x;
							let v_y = y;
							let v_z = z;
							let v_w = w;
							_this.x = v_x;
							_this.y = v_y;
							_this.z = v_z;
							_this.w = v_w;
							let _this2 = this.velocity;
							let k = _this2.x * _this2.x + _this2.y * _this2.y + _this2.z * _this2.z;
							if(k < 1e-10) {
								k = 0;
							} else {
								k = 1. / Math.sqrt(k);
							}
							_this2.x *= k;
							_this2.y *= k;
							_this2.z *= k;
							let _this3 = this.velocity;
							_this3.x *= velLen;
							_this3.y *= velLen;
							_this3.z *= velLen;
							surfaceSlide = true;
						} else if(surfaceDot >= -this._minBounceVel) {
							let _this = this.velocity;
							let _this1 = this.velocity;
							let x = _this1.x - surfaceVel_x;
							let y = _this1.y - surfaceVel_y;
							let z = _this1.z - surfaceVel_z;
							let w = _this1.w - surfaceVel_w;
							if(w == null) {
								w = 1.;
							}
							if(z == null) {
								z = 0.;
							}
							if(y == null) {
								y = 0.;
							}
							if(x == null) {
								x = 0.;
							}
							let v_x = x;
							let v_y = y;
							let v_z = z;
							let v_w = w;
							_this.x = v_x;
							_this.y = v_y;
							_this.z = v_z;
							_this.w = v_w;
						} else {
							let restitution = this._bounceRestitution;
							restitution *= this.contacts[i].restitution;
							let v = -(1 + restitution);
							let x = surfaceVel_x * v;
							let y = surfaceVel_y * v;
							let z = surfaceVel_z * v;
							let w = surfaceVel_w;
							if(surfaceVel_w == null) {
								w = 1.;
							}
							if(z == null) {
								z = 0.;
							}
							if(y == null) {
								y = 0.;
							}
							if(x == null) {
								x = 0.;
							}
							let velocityAdd_x = x;
							let velocityAdd_y = y;
							let velocityAdd_z = z;
							let velocityAdd_w = w;
							let _this = this.omega;
							let _this1 = this.contacts[i].normal;
							let v1 = -this._radius;
							let x1 = _this1.x * v1;
							let y1 = _this1.y * v1;
							let z1 = _this1.z * v1;
							if(z1 == null) {
								z1 = 0.;
							}
							if(y1 == null) {
								y1 = 0.;
							}
							if(x1 == null) {
								x1 = 0.;
							}
							let v_x = x1;
							let v_y = y1;
							let v_z = z1;
							let x2 = _this.y * v_z - _this.z * v_y;
							let y2 = _this.z * v_x - _this.x * v_z;
							let z2 = _this.x * v_y - _this.y * v_x;
							if(z2 == null) {
								z2 = 0.;
							}
							if(y2 == null) {
								y2 = 0.;
							}
							if(x2 == null) {
								x2 = 0.;
							}
							let v_x1 = x2;
							let v_y1 = y2;
							let v_z1 = z2;
							let v_w = 1;
							let x3 = sVel_x + v_x1;
							let y3 = sVel_y + v_y1;
							let z3 = sVel_z + v_z1;
							let w1 = sVel_w + v_w;
							if(w1 == null) {
								w1 = 1.;
							}
							if(z3 == null) {
								z3 = 0.;
							}
							if(y3 == null) {
								y3 = 0.;
							}
							if(x3 == null) {
								x3 = 0.;
							}
							let vAtC_x = x3;
							let vAtC_y = y3;
							let vAtC_z = z3;
							let vAtC_w = w1;
							let _this2 = this.contacts[i].normal;
							let normalVel = -(_this2.x * sVel_x + _this2.y * sVel_y + _this2.z * sVel_z);
							this.bounceEmitter(Math.sqrt(sVel_x * sVel_x + sVel_y * sVel_y + sVel_z * sVel_z) * restitution,this.contacts[i].normal);
							let _this3 = this.contacts[i].normal;
							let _this4 = this.contacts[i].normal;
							let v2 = _this4.x * sVel_x + _this4.y * sVel_y + _this4.z * sVel_z;
							let x4 = _this3.x * v2;
							let y4 = _this3.y * v2;
							let z4 = _this3.z * v2;
							let w2 = _this3.w;
							if(w2 == null) {
								w2 = 1.;
							}
							if(z4 == null) {
								z4 = 0.;
							}
							if(y4 == null) {
								y4 = 0.;
							}
							if(x4 == null) {
								x4 = 0.;
							}
							let v_x2 = x4;
							let v_y2 = y4;
							let v_z2 = z4;
							let v_w1 = w2;
							let x5 = vAtC_x - v_x2;
							let y5 = vAtC_y - v_y2;
							let z5 = vAtC_z - v_z2;
							let w3 = vAtC_w - v_w1;
							if(w3 == null) {
								w3 = 1.;
							}
							if(z5 == null) {
								z5 = 0.;
							}
							if(y5 == null) {
								y5 = 0.;
							}
							if(x5 == null) {
								x5 = 0.;
							}
							let v_x3 = x5;
							let v_y3 = y5;
							let v_z3 = z5;
							let v_w2 = w3;
							vAtC_x = v_x3;
							vAtC_y = v_y3;
							vAtC_z = v_z3;
							vAtC_w = v_w2;
							let vAtCMag = Math.sqrt(vAtC_x * vAtC_x + vAtC_y * vAtC_y + vAtC_z * vAtC_z);
							if(vAtCMag != 0.0) {
								let friction = this._bounceKineticFriction * this.contacts[i].friction;
								let angVMagnitude = friction * 5 * normalVel / (2 * this._radius);
								if(vAtCMag / this._radius < angVMagnitude) {
									angVMagnitude = vAtCMag / this._radius;
								}
								let v = 1 / vAtCMag;
								let x = vAtC_x * v;
								let y = vAtC_y * v;
								let z = vAtC_z * v;
								if(z == null) {
									z = 0.;
								}
								if(y == null) {
									y = 0.;
								}
								if(x == null) {
									x = 0.;
								}
								let vAtCDir_x = x;
								let vAtCDir_y = y;
								let vAtCDir_z = z;
								let _this = this.contacts[i].normal;
								let x1 = _this.y * vAtCDir_z - _this.z * vAtCDir_y;
								let y1 = _this.z * vAtCDir_x - _this.x * vAtCDir_z;
								let z1 = _this.x * vAtCDir_y - _this.y * vAtCDir_x;
								if(z1 == null) {
									z1 = 0.;
								}
								if(y1 == null) {
									y1 = 0.;
								}
								if(x1 == null) {
									x1 = 0.;
								}
								let _this_x = x1;
								let _this_y = y1;
								let _this_z = z1;
								let _this_w = 1;
								let x2 = _this_x * angVMagnitude;
								let y2 = _this_y * angVMagnitude;
								let z2 = _this_z * angVMagnitude;
								if(z2 == null) {
									z2 = 0.;
								}
								if(y2 == null) {
									y2 = 0.;
								}
								if(x2 == null) {
									x2 = 0.;
								}
								let deltaOmega_x = x2;
								let deltaOmega_y = y2;
								let deltaOmega_z = z2;
								let deltaOmega_w = _this_w;
								let _this1 = this.omega;
								let _this2 = this.omega;
								let x3 = _this2.x + deltaOmega_x;
								let y3 = _this2.y + deltaOmega_y;
								let z3 = _this2.z + deltaOmega_z;
								let w = _this2.w + deltaOmega_w;
								if(w == null) {
									w = 1.;
								}
								if(z3 == null) {
									z3 = 0.;
								}
								if(y3 == null) {
									y3 = 0.;
								}
								if(x3 == null) {
									x3 = 0.;
								}
								let v_x = x3;
								let v_y = y3;
								let v_z = z3;
								let v_w = w;
								_this1.x = v_x;
								_this1.y = v_y;
								_this1.z = v_z;
								_this1.w = v_w;
								let _this3 = this.velocity;
								let _this4 = this.velocity;
								let _this5 = this.contacts[i].normal;
								let v1 = this._radius;
								let x4 = _this5.x * v1;
								let y4 = _this5.y * v1;
								let z4 = _this5.z * v1;
								if(z4 == null) {
									z4 = 0.;
								}
								if(y4 == null) {
									y4 = 0.;
								}
								if(x4 == null) {
									x4 = 0.;
								}
								let v_x1 = x4;
								let v_y1 = y4;
								let v_z1 = z4;
								let x5 = deltaOmega_y * v_z1 - deltaOmega_z * v_y1;
								let y5 = deltaOmega_z * v_x1 - deltaOmega_x * v_z1;
								let z5 = deltaOmega_x * v_y1 - deltaOmega_y * v_x1;
								if(z5 == null) {
									z5 = 0.;
								}
								if(y5 == null) {
									y5 = 0.;
								}
								if(x5 == null) {
									x5 = 0.;
								}
								let v_x2 = x5;
								let v_y2 = y5;
								let v_z2 = z5;
								let v_w1 = 1;
								let x6 = _this4.x - v_x2;
								let y6 = _this4.y - v_y2;
								let z6 = _this4.z - v_z2;
								let w1 = _this4.w - v_w1;
								if(w1 == null) {
									w1 = 1.;
								}
								if(z6 == null) {
									z6 = 0.;
								}
								if(y6 == null) {
									y6 = 0.;
								}
								if(x6 == null) {
									x6 = 0.;
								}
								let v_x3 = x6;
								let v_y3 = y6;
								let v_z3 = z6;
								let v_w2 = w1;
								_this3.x = v_x3;
								_this3.y = v_y3;
								_this3.z = v_z3;
								_this3.w = v_w2;
							}
							let _this5 = this.velocity;
							let _this6 = this.velocity;
							let x6 = _this6.x + velocityAdd_x;
							let y6 = _this6.y + velocityAdd_y;
							let z6 = _this6.z + velocityAdd_z;
							let w4 = _this6.w + velocityAdd_w;
							if(w4 == null) {
								w4 = 1.;
							}
							if(z6 == null) {
								z6 = 0.;
							}
							if(y6 == null) {
								y6 = 0.;
							}
							if(x6 == null) {
								x6 = 0.;
							}
							let v_x4 = x6;
							let v_y4 = y6;
							let v_z4 = z6;
							let v_w3 = w4;
							_this5.x = v_x4;
							_this5.y = v_y4;
							_this5.z = v_z4;
							_this5.w = v_w3;
						}
					}
					done = false;
				}
			}
			looped = true;
			if(itersIn > 6 && !stoppedPaths) {
				stoppedPaths = true;
				if(noBounce) {
					done = true;
				}
				let _g = 0;
				let _g1 = this.contacts;
				while(_g < _g1.length) {
					let contact = _g1[_g];
					++_g;
					let _this = contact.velocity;
					_this.x = 0;
					_this.y = 0;
					_this.z = 0;
					_this.w = 1.;
				}
				let _g2 = 0;
				while(_g2 < pi.length) {
					let interior = pi[_g2];
					++_g2;
					interior.setStopped();
				}
			}
		} while(!done && itersIn < 20);
		let _this = this.velocity;
		if(_this.x * _this.x + _this.y * _this.y + _this.z * _this.z < 625.0) {
			let gotOne = false;
			let dir = new h3d_Vector(0,0,0);
			let _g = 0;
			let _g1 = this.contacts.length;
			while(_g < _g1) {
				let j = _g++;
				let v = this.contacts[j].normal;
				let dir2 = new h3d_Vector(dir.x + v.x,dir.y + v.y,dir.z + v.z,dir.w + v.w);
				if(dir2.x * dir2.x + dir2.y * dir2.y + dir2.z * dir2.z < 0.01) {
					let v = this.contacts[j].normal;
					dir2 = new h3d_Vector(dir2.x + v.x,dir2.y + v.y,dir2.z + v.z,dir2.w + v.w);
				}
				dir = dir2;
				let k = dir.x * dir.x + dir.y * dir.y + dir.z * dir.z;
				if(k < 1e-10) {
					k = 0;
				} else {
					k = 1. / Math.sqrt(k);
				}
				dir.x *= k;
				dir.y *= k;
				dir.z *= k;
				gotOne = true;
			}
			if(gotOne) {
				let k = dir.x * dir.x + dir.y * dir.y + dir.z * dir.z;
				if(k < 1e-10) {
					k = 0;
				} else {
					k = 1. / Math.sqrt(k);
				}
				dir.x *= k;
				dir.y *= k;
				dir.z *= k;
				let soFar = 0.0;
				let _g = 0;
				let _g1 = this.contacts.length;
				while(_g < _g1) {
					let k = _g++;
					let dist = this._radius - this.contacts[k].contactDistance;
					let _this = this.velocity;
					let v = this.contacts[k].velocity;
					let x = _this.x - v.x;
					let y = _this.y - v.y;
					let z = _this.z - v.z;
					let w = _this.w - v.w;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let vel_x = x;
					let vel_y = y;
					let vel_z = z;
					let x1 = dir.x * soFar;
					let y1 = dir.y * soFar;
					let z1 = dir.z * soFar;
					let w1 = dir.w;
					if(w1 == null) {
						w1 = 1.;
					}
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let v_x = x1;
					let v_y = y1;
					let v_z = z1;
					let x2 = vel_x + v_x;
					let y2 = vel_y + v_y;
					let z2 = vel_z + v_z;
					if(z2 == null) {
						z2 = 0.;
					}
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					let _this_x = x2;
					let _this_y = y2;
					let _this_z = z2;
					let v1 = this.contacts[k].normal;
					let outVel = _this_x * v1.x + _this_y * v1.y + _this_z * v1.z;
					if(dist > 0.1 * outVel) {
						let _this = this.contacts[k].normal;
						soFar += (dist - outVel * 0.1) / 0.1 / (_this.x * dir.x + _this.y * dir.y + _this.z * dir.z);
					}
				}
				if(soFar < -25.0) {
					soFar = -25.0;
				}
				if(soFar > 25.0) {
					soFar = 25.0;
				}
				let _this = this.velocity;
				let _this1 = this.velocity;
				let x = dir.x * soFar;
				let y = dir.y * soFar;
				let z = dir.z * soFar;
				let w = dir.w;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v_x = x;
				let v_y = y;
				let v_z = z;
				let v_w = w;
				let x1 = _this1.x + v_x;
				let y1 = _this1.y + v_y;
				let z1 = _this1.z + v_z;
				let w1 = _this1.w + v_w;
				if(w1 == null) {
					w1 = 1.;
				}
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let v_x1 = x1;
				let v_y1 = y1;
				let v_z1 = z1;
				let v_w1 = w1;
				_this.x = v_x1;
				_this.y = v_y1;
				_this.z = v_z1;
				_this.w = v_w1;
			}
		}
		return stoppedPaths;
	}
	applyContactForces(dt,m,isCentered,aControl,desiredOmega,A) {
		let a = new h3d_Vector();
		this._slipAmount = 0;
		let _this = this.currentUp;
		let x = _this.x * -1;
		let y = _this.y * -1;
		let z = _this.z * -1;
		let w = _this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let gWorkGravityDir_x = x;
		let gWorkGravityDir_y = y;
		let gWorkGravityDir_z = z;
		let bestSurface = -1;
		let bestNormalForce = 0.0;
		let _g = 0;
		let _g1 = this.contacts.length;
		while(_g < _g1) {
			let i = _g++;
			if(this.contacts[i].collider == null) {
				let _this = this.contacts[i].normal;
				this.contacts[i].normalForce = -(_this.x * A.x + _this.y * A.y + _this.z * A.z);
				if(this.contacts[i].normalForce > bestNormalForce) {
					bestNormalForce = this.contacts[i].normalForce;
					bestSurface = i;
				}
			}
		}
		this.bestContact = bestSurface != -1 ? this.contacts[bestSurface] : null;
		let canJump = bestSurface != -1;
		if(canJump && m.jump) {
			let _this = this.velocity;
			let v = this.bestContact.velocity;
			let x = _this.x - v.x;
			let y = _this.y - v.y;
			let z = _this.z - v.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let velDifference_x = x;
			let velDifference_y = y;
			let velDifference_z = z;
			let _this1 = this.bestContact.normal;
			let sv = _this1.x * velDifference_x + _this1.y * velDifference_y + _this1.z * velDifference_z;
			if(sv < 0) {
				sv = 0;
			}
			if(sv < this._jumpImpulse) {
				let _this = this.velocity;
				let _this1 = this.velocity;
				let _this2 = this.bestContact.normal;
				let v = this._jumpImpulse - sv;
				let x = _this2.x * v;
				let y = _this2.y * v;
				let z = _this2.z * v;
				let w = _this2.w;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v_x = x;
				let v_y = y;
				let v_z = z;
				let v_w = w;
				let x1 = _this1.x + v_x;
				let y1 = _this1.y + v_y;
				let z1 = _this1.z + v_z;
				let w1 = _this1.w + v_w;
				if(w1 == null) {
					w1 = 1.;
				}
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let v_x1 = x1;
				let v_y1 = y1;
				let v_z1 = z1;
				let v_w1 = w1;
				_this.x = v_x1;
				_this.y = v_y1;
				_this.z = v_z1;
				_this.w = v_w1;
				if(!this.level.isReplayingMovement && !this.playedSounds.includes("data/sound/jump.wav") && !this.isNetUpdate && this.controllable) {
					src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/jump.wav",src_ResourceLoader.getAudio,this.soundResources));
					this.playedSounds.push("data/sound/jump.wav");
				}
			}
		}
		let _g2 = 0;
		let _g3 = this.contacts.length;
		while(_g2 < _g3) {
			let j = _g2++;
			let _this = this.contacts[j].normal;
			let normalForce2 = -(_this.x * A.x + _this.y * A.y + _this.z * A.z);
			let tmp;
			if(normalForce2 > 0) {
				let _this = this.contacts[j].normal;
				let _this1 = this.velocity;
				let v = this.contacts[j].velocity;
				let x = _this1.x - v.x;
				let y = _this1.y - v.y;
				let z = _this1.z - v.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v_x = x;
				let v_y = y;
				let v_z = z;
				tmp = _this.x * v_x + _this.y * v_y + _this.z * v_z <= 0.0001;
			} else {
				tmp = false;
			}
			if(tmp) {
				let x = A.x + this.contacts[j].normal.x * normalForce2;
				let y = A.y + this.contacts[j].normal.y * normalForce2;
				let z = A.z + this.contacts[j].normal.z * normalForce2;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				A.x = x;
				A.y = y;
				A.z = z;
				A.w = 1.;
			}
		}
		if(bestSurface != -1 && this.mode != src_Mode.Finish) {
			let _this = this.velocity;
			let _this1 = this.omega;
			let _this2 = this.bestContact.normal;
			let v = -this._radius;
			let x = _this2.x * v;
			let y = _this2.y * v;
			let z = _this2.z * v;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let v_x = x;
			let v_y = y;
			let v_z = z;
			let x1 = _this1.y * v_z - _this1.z * v_y;
			let y1 = _this1.z * v_x - _this1.x * v_z;
			let z1 = _this1.x * v_y - _this1.y * v_x;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let v_x1 = x1;
			let v_y1 = y1;
			let v_z1 = z1;
			let v_w = 1;
			let x2 = _this.x + v_x1;
			let y2 = _this.y + v_y1;
			let z2 = _this.z + v_z1;
			let w = _this.w + v_w;
			if(w == null) {
				w = 1.;
			}
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let _this_x = x2;
			let _this_y = y2;
			let _this_z = z2;
			let _this_w = w;
			let v1 = this.bestContact.velocity;
			let x3 = _this_x - v1.x;
			let y3 = _this_y - v1.y;
			let z3 = _this_z - v1.z;
			let w1 = _this_w - v1.w;
			if(w1 == null) {
				w1 = 1.;
			}
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			let vAtC_x = x3;
			let vAtC_y = y3;
			let vAtC_z = z3;
			let vAtC_w = w1;
			let vAtCMag = Math.sqrt(vAtC_x * vAtC_x + vAtC_y * vAtC_y + vAtC_z * vAtC_z);
			let slipping = false;
			let aFriction = new h3d_Vector(0,0,0);
			let AFriction = new h3d_Vector(0,0,0);
			if(vAtCMag != 0) {
				slipping = true;
				let friction = 0.0;
				if(this.mode != src_Mode.Start) {
					friction = this._kineticFriction * this.bestContact.friction;
				}
				let angAMagnitude = 5 * friction * bestNormalForce / (2 * this._radius);
				let AMagnitude = bestNormalForce * friction;
				let totalDeltaV = (angAMagnitude * this._radius + AMagnitude) * dt;
				if(totalDeltaV > vAtCMag) {
					let fraction = vAtCMag / totalDeltaV;
					angAMagnitude *= fraction;
					AMagnitude *= fraction;
					slipping = false;
				}
				let v = 1 / vAtCMag;
				let x = vAtC_x * v;
				let y = vAtC_y * v;
				let z = vAtC_z * v;
				let w = vAtC_w;
				if(vAtC_w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let vAtCDir_x = x;
				let vAtCDir_y = y;
				let vAtCDir_z = z;
				let vAtCDir_w = w;
				let _this = this.bestContact.normal;
				let x1 = _this.y * vAtCDir_z - _this.z * vAtCDir_y;
				let y1 = _this.z * vAtCDir_x - _this.x * vAtCDir_z;
				let z1 = _this.x * vAtCDir_y - _this.y * vAtCDir_x;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let _this_x = x1;
				let _this_y = y1;
				let _this_z = z1;
				let _this_w = 1;
				aFriction = new h3d_Vector(_this_x * angAMagnitude,_this_y * angAMagnitude,_this_z * angAMagnitude,_this_w);
				let v1 = -AMagnitude;
				AFriction = new h3d_Vector(vAtCDir_x * v1,vAtCDir_y * v1,vAtCDir_z * v1,vAtCDir_w);
				this._slipAmount = vAtCMag - totalDeltaV;
			}
			if(!slipping) {
				let v = -this._radius;
				let x = gWorkGravityDir_x * v;
				let y = gWorkGravityDir_y * v;
				let z = gWorkGravityDir_z * v;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let R_x = x;
				let R_y = y;
				let R_z = z;
				let x1 = R_y * A.z - R_z * A.y;
				let y1 = R_z * A.x - R_x * A.z;
				let z1 = R_x * A.y - R_y * A.x;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let _this_x = x1;
				let _this_y = y1;
				let _this_z = z1;
				let _this_w = 1;
				let v1 = 1 / (R_x * R_x + R_y * R_y + R_z * R_z);
				let x2 = _this_x * v1;
				let y2 = _this_y * v1;
				let z2 = _this_z * v1;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let aadd_x = x2;
				let aadd_y = y2;
				let aadd_z = z2;
				let aadd_w = _this_w;
				if(isCentered) {
					let _this = this.omega;
					let x = a.x * dt;
					let y = a.y * dt;
					let z = a.z * dt;
					let w = a.w;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let v_x = x;
					let v_y = y;
					let v_z = z;
					let v_w = w;
					let x1 = _this.x + v_x;
					let y1 = _this.y + v_y;
					let z1 = _this.z + v_z;
					let w1 = _this.w + v_w;
					if(w1 == null) {
						w1 = 1.;
					}
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let nextOmega_x = x1;
					let nextOmega_y = y1;
					let nextOmega_z = z1;
					let nextOmega_w = w1;
					aControl = new h3d_Vector(desiredOmega.x - nextOmega_x,desiredOmega.y - nextOmega_y,desiredOmega.z - nextOmega_z,desiredOmega.w - nextOmega_w);
					let aScalar = Math.sqrt(aControl.x * aControl.x + aControl.y * aControl.y + aControl.z * aControl.z);
					if(aScalar > this._brakingAcceleration) {
						let v = this._brakingAcceleration / aScalar;
						aControl = new h3d_Vector(aControl.x * v,aControl.y * v,aControl.z * v,aControl.w);
					}
				}
				let _this = this.bestContact.normal;
				let v2 = -this._radius;
				let x3 = _this.x * v2;
				let y3 = _this.y * v2;
				let z3 = _this.z * v2;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				let v_x = x3;
				let v_y = y3;
				let v_z = z3;
				let x4 = aControl.y * v_z - aControl.z * v_y;
				let y4 = aControl.z * v_x - aControl.x * v_z;
				let z4 = aControl.x * v_y - aControl.y * v_x;
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				let _this_x1 = x4;
				let _this_y1 = y4;
				let _this_z1 = z4;
				let _this_w1 = 1;
				let x5 = _this_x1 * -1;
				let y5 = _this_y1 * -1;
				let z5 = _this_z1 * -1;
				if(z5 == null) {
					z5 = 0.;
				}
				if(y5 == null) {
					y5 = 0.;
				}
				if(x5 == null) {
					x5 = 0.;
				}
				let Aadd_x = x5;
				let Aadd_y = y5;
				let Aadd_z = z5;
				let Aadd_w = _this_w1;
				let _this1 = this.bestContact.normal;
				let v3 = -this._radius;
				let x6 = _this1.x * v3;
				let y6 = _this1.y * v3;
				let z6 = _this1.z * v3;
				if(z6 == null) {
					z6 = 0.;
				}
				if(y6 == null) {
					y6 = 0.;
				}
				if(x6 == null) {
					x6 = 0.;
				}
				let v_x1 = x6;
				let v_y1 = y6;
				let v_z1 = z6;
				let x7 = aadd_y * v_z1 - aadd_z * v_y1;
				let y7 = aadd_z * v_x1 - aadd_x * v_z1;
				let z7 = aadd_x * v_y1 - aadd_y * v_x1;
				if(z7 == null) {
					z7 = 0.;
				}
				if(y7 == null) {
					y7 = 0.;
				}
				if(x7 == null) {
					x7 = 0.;
				}
				let _this_x2 = x7;
				let _this_y2 = y7;
				let _this_z2 = z7;
				let x8 = _this_x2 + Aadd_x;
				let y8 = _this_y2 + Aadd_y;
				let z8 = _this_z2 + Aadd_z;
				if(z8 == null) {
					z8 = 0.;
				}
				if(y8 == null) {
					y8 = 0.;
				}
				if(x8 == null) {
					x8 = 0.;
				}
				let _this_x3 = x8;
				let _this_y3 = y8;
				let _this_z3 = z8;
				let aAtCMag = Math.sqrt(_this_x3 * _this_x3 + _this_y3 * _this_y3 + _this_z3 * _this_z3);
				let friction2 = 0.0;
				if(this.mode != src_Mode.Start) {
					friction2 = this._staticFriction * this.bestContact.friction;
				}
				if(aAtCMag > friction2 * bestNormalForce) {
					friction2 = 0;
					if(this.mode != src_Mode.Start) {
						friction2 = this._kineticFriction * this.bestContact.friction;
					}
					let v = friction2 * bestNormalForce / aAtCMag;
					let x = Aadd_x * v;
					let y = Aadd_y * v;
					let z = Aadd_z * v;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let v_x = x;
					let v_y = y;
					let v_z = z;
					let v_w = Aadd_w;
					Aadd_x = v_x;
					Aadd_y = v_y;
					Aadd_z = v_z;
					Aadd_w = v_w;
				}
				let x9 = A.x + Aadd_x;
				let y9 = A.y + Aadd_y;
				let z9 = A.z + Aadd_z;
				let w = A.w + Aadd_w;
				if(w == null) {
					w = 1.;
				}
				if(z9 == null) {
					z9 = 0.;
				}
				if(y9 == null) {
					y9 = 0.;
				}
				if(x9 == null) {
					x9 = 0.;
				}
				let v_x2 = x9;
				let v_y2 = y9;
				let v_z2 = z9;
				let v_w = w;
				A.x = v_x2;
				A.y = v_y2;
				A.z = v_z2;
				A.w = v_w;
				let x10 = a.x + aadd_x;
				let y10 = a.y + aadd_y;
				let z10 = a.z + aadd_z;
				let w1 = a.w + aadd_w;
				if(w1 == null) {
					w1 = 1.;
				}
				if(z10 == null) {
					z10 = 0.;
				}
				if(y10 == null) {
					y10 = 0.;
				}
				if(x10 == null) {
					x10 = 0.;
				}
				let v_x3 = x10;
				let v_y3 = y10;
				let v_z3 = z10;
				let v_w1 = w1;
				a.x = v_x3;
				a.y = v_y3;
				a.z = v_z3;
				a.w = v_w1;
			}
			let x4 = A.x + AFriction.x;
			let y4 = A.y + AFriction.y;
			let z4 = A.z + AFriction.z;
			let w2 = A.w + AFriction.w;
			if(w2 == null) {
				w2 = 1.;
			}
			if(z4 == null) {
				z4 = 0.;
			}
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			let v_x2 = x4;
			let v_y2 = y4;
			let v_z2 = z4;
			let v_w1 = w2;
			A.x = v_x2;
			A.y = v_y2;
			A.z = v_z2;
			A.w = v_w1;
			let x5 = a.x + aFriction.x;
			let y5 = a.y + aFriction.y;
			let z5 = a.z + aFriction.z;
			let w3 = a.w + aFriction.w;
			if(w3 == null) {
				w3 = 1.;
			}
			if(z5 == null) {
				z5 = 0.;
			}
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			let v_x3 = x5;
			let v_y3 = y5;
			let v_z3 = z5;
			let v_w2 = w3;
			a.x = v_x3;
			a.y = v_y3;
			a.z = v_z3;
			a.w = v_w2;
			this.lastContactNormal = this.bestContact.normal;
			let _this3 = this.getAbsPos();
			let v2 = new h3d_Vector();
			let x6 = _this3._41;
			let y6 = _this3._42;
			let z6 = _this3._43;
			let w4 = _this3._44;
			if(w4 == null) {
				w4 = 1.;
			}
			if(z6 == null) {
				z6 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			v2.x = x6;
			v2.y = y6;
			v2.z = z6;
			v2.w = w4;
			this.lastContactPosition = v2;
		}
		let x1 = a.x + aControl.x;
		let y1 = a.y + aControl.y;
		let z1 = a.z + aControl.z;
		let w1 = a.w + aControl.w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let v_x = x1;
		let v_y = y1;
		let v_z = z1;
		let v_w = w1;
		a.x = v_x;
		a.y = v_y;
		a.z = v_z;
		a.w = v_w;
		if(this.mode == src_Mode.Finish) {
			a.x = 0.;
			a.y = 0.;
			a.z = 0.;
			a.w = 1.;
		}
		return a;
	}
	bounceEmitter(speed,normal) {
		if(!this.controllable || this.isNetUpdate) {
			return;
		}
		if(this.bounceEmitDelay == 0 && this._minBounceSpeed <= speed) {
			let _this = this.collider.transform;
			let _this_x = 0.;
			let _this_y = 0.;
			let _this_z = 0.;
			let _this_w = 1.;
			let x = _this._41;
			let y = _this._42;
			let z = _this._43;
			let w = _this._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this_x = x;
			_this_y = y;
			_this_z = z;
			_this_w = w;
			let v = this._radius;
			let x1 = normal.x * v;
			let y1 = normal.y * v;
			let z1 = normal.z * v;
			let w1 = normal.w;
			if(w1 == null) {
				w1 = 1.;
			}
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let v_x = x1;
			let v_y = y1;
			let v_z = z1;
			let v_w = w1;
			let _this_x1 = 1;
			let _this_y1 = 1;
			let _this_z1 = 1;
			let x2 = normal.x * -0.8;
			let y2 = normal.y * -0.8;
			let z2 = normal.z * -0.8;
			let w2 = normal.w;
			if(w2 == null) {
				w2 = 1.;
			}
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let v_x1 = x2;
			let v_y1 = y2;
			let v_z1 = z2;
			let v_w1 = w2;
			this.level.particleManager.createEmitter(src_Marble_bounceParticleOptions,this.bounceEmitterData,new h3d_Vector(_this_x - v_x,_this_y - v_y,_this_z - v_z,_this_w - v_w),null,new h3d_Vector(_this_x1 + v_x1,_this_y1 + v_y1,_this_z1 + v_z1,1. + v_w1));
			this.bounceEmitDelay = 0.3;
		}
	}
	trailEmitter() {
	}
	playBoundSound(time,contactVel) {
		if(this.isNetUpdate) {
			return;
		}
		if(this.minVelocityBounceSoft <= contactVel) {
			let bounceSoundNum = Math.floor(Math.random() * 4);
			let sndList = time - this.megaMarbleEnableTime < 10 || this.megaMarbleUseTick > 0 && (net_Net.isHost && this.level.timeState.ticks - this.megaMarbleUseTick <= 312 || net_Net.isClient && this.serverTicks - this.megaMarbleUseTick <= 312) ? ["data/sound/mega_bouncehard1.wav","data/sound/mega_bouncehard2.wav","data/sound/mega_bouncehard3.wav","data/sound/mega_bouncehard4.wav"] : ["data/sound/bouncehard1.wav","data/sound/bouncehard2.wav","data/sound/bouncehard3.wav","data/sound/bouncehard4.wav"];
			let snd = src_ResourceLoader.getResource(sndList[bounceSoundNum],src_ResourceLoader.getAudio,this.soundResources);
			let gain = this.bounceMinGain;
			let value = Math.pow(contactVel / 12,1.5);
			gain = value < 0 ? 0 : value > 1 ? 1 : value;
			if(!this.controllable) {
				let _this = this.getAbsPos();
				let v = new h3d_Vector();
				let x = _this._41;
				let y = _this._42;
				let z = _this._43;
				let w = _this._44;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				v.x = x;
				v.y = y;
				v.z = z;
				v.w = w;
				src_AudioManager.playSound(snd,v);
			} else {
				snd.play(false,src_Settings.optionsSettings.soundVolume * gain);
			}
		}
	}
	updateRollSound(time,contactPct,slipAmount) {
		let rSpat = this.rollSound.getEffect(hxd_snd_effect_Spatialization);
		let _this = this.collider.transform;
		let v = new h3d_Vector();
		let x = _this._41;
		let y = _this._42;
		let z = _this._43;
		let w = _this._44;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v.x = x;
		v.y = y;
		v.z = z;
		v.w = w;
		rSpat.position = v;
		if(this.rollMegaSound != null) {
			let rmspat = this.rollMegaSound.getEffect(hxd_snd_effect_Spatialization);
			let _this = this.collider.transform;
			let v = new h3d_Vector();
			let x = _this._41;
			let y = _this._42;
			let z = _this._43;
			let w = _this._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			v.x = x;
			v.y = y;
			v.z = z;
			v.w = w;
			rmspat.position = v;
		}
		let sSpat = this.slipSound.getEffect(hxd_snd_effect_Spatialization);
		let _this1 = this.collider.transform;
		let v1 = new h3d_Vector();
		let x1 = _this1._41;
		let y1 = _this1._42;
		let z1 = _this1._43;
		let w1 = _this1._44;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		v1.x = x1;
		v1.y = y1;
		v1.z = z1;
		v1.w = w1;
		sSpat.position = v1;
		let rollVel;
		if(this.bestContact != null) {
			let _this = this.velocity;
			let v = this.bestContact.velocity;
			rollVel = new h3d_Vector(_this.x - v.x,_this.y - v.y,_this.z - v.z,_this.w - v.w);
		} else {
			rollVel = this.velocity;
		}
		let scale = Math.sqrt(rollVel.x * rollVel.x + rollVel.y * rollVel.y + rollVel.z * rollVel.z);
		scale /= this._maxRollVelocity;
		let rollVolume = 2 * scale;
		if(rollVolume > 1) {
			rollVolume = 1;
		}
		if(contactPct < 0.05) {
			rollVolume = this.rollSound.volume / 5;
		}
		let slipVolume = 0.0;
		if(slipAmount > 1e-4) {
			slipVolume = slipAmount / 5;
			if(slipVolume > 1) {
				slipVolume = 1;
			}
			rollVolume = (1 - slipVolume) * rollVolume;
		}
		if(rollVolume < 0) {
			rollVolume = 0;
		}
		if(time.currentAttemptTime - this.megaMarbleEnableTime < 10 || this.megaMarbleUseTick > 0 && (net_Net.isHost && this.level.timeState.ticks - this.megaMarbleUseTick <= 312 || net_Net.isClient && this.serverTicks - this.megaMarbleUseTick <= 312)) {
			if(this.rollMegaSound != null) {
				this.rollMegaSound.set_volume(rollVolume);
				this.rollSound.set_volume(0);
			}
		} else {
			this.rollSound.set_volume(rollVolume);
			if(this.rollMegaSound != null) {
				this.rollMegaSound.set_volume(0);
			}
		}
		if(this.rollSound.getEffect(hxd_snd_effect_Pitch) == null) {
			this.rollSound.addEffect(new hxd_snd_effect_Pitch());
		}
		if(this.rollMegaSound != null) {
			if(this.rollMegaSound.getEffect(hxd_snd_effect_Pitch) == null) {
				this.rollMegaSound.addEffect(new hxd_snd_effect_Pitch());
			}
		}
		let value = Math.sqrt(rollVel.x * rollVel.x + rollVel.y * rollVel.y + rollVel.z * rollVel.z) / this._maxRollVelocity;
		let pitch = (value < 0 ? 0 : value > 1 ? 1 : value) * 0.75 + 0.75;
		let rPitch = this.rollSound.getEffect(hxd_snd_effect_Pitch);
		rPitch.value = pitch;
		if(this.rollMegaSound != null) {
			let rPitch = this.rollMegaSound.getEffect(hxd_snd_effect_Pitch);
			rPitch.value = pitch;
		}
	}
	testMove(velocity,position,deltaT,radius,testPIs) {
		if(Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y + velocity.z * velocity.z) < 0.001) {
			return new src_MarbleTestMoveResult(position,deltaT,false,[],null,null,[]);
		}
		let searchbox = new h3d_col_Bounds();
		let x = position.x;
		let y = position.y;
		let z = position.z;
		let r = this._radius;
		if(x - r < searchbox.xMin) {
			searchbox.xMin = x - r;
		}
		if(x + r > searchbox.xMax) {
			searchbox.xMax = x + r;
		}
		if(y - r < searchbox.yMin) {
			searchbox.yMin = y - r;
		}
		if(y + r > searchbox.yMax) {
			searchbox.yMax = y + r;
		}
		if(z - r < searchbox.zMin) {
			searchbox.zMin = z - r;
		}
		if(z + r > searchbox.zMax) {
			searchbox.zMax = z + r;
		}
		let x1 = position.x + velocity.x * deltaT;
		let y1 = position.y + velocity.y * deltaT;
		let z1 = position.z + velocity.z * deltaT;
		let r1 = this._radius;
		if(x1 - r1 < searchbox.xMin) {
			searchbox.xMin = x1 - r1;
		}
		if(x1 + r1 > searchbox.xMax) {
			searchbox.xMax = x1 + r1;
		}
		if(y1 - r1 < searchbox.yMin) {
			searchbox.yMin = y1 - r1;
		}
		if(y1 + r1 > searchbox.yMax) {
			searchbox.yMax = y1 + r1;
		}
		if(z1 - r1 < searchbox.zMin) {
			searchbox.zMin = z1 - r1;
		}
		if(z1 + r1 > searchbox.zMax) {
			searchbox.zMax = z1 + r1;
		}
		let foundObjs = this.collisionWorld.boundingSearch(searchbox);
		let finalT = deltaT;
		let found = false;
		let lastContactPos = new h3d_Vector();
		let testTriangles = [];
		let foundMarbles = [];
		let x2 = velocity.x * deltaT;
		let y2 = velocity.y * deltaT;
		let z2 = velocity.z * deltaT;
		let w = velocity.w;
		if(w == null) {
			w = 1.;
		}
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let v_x = x2;
		let v_y = y2;
		let v_z = z2;
		let v_w = w;
		let nextPos = new h3d_Vector(position.x + v_x,position.y + v_y,position.z + v_z,position.w + v_w);
		let _g = 0;
		let _g1 = this.collisionWorld.marbleEntities;
		while(_g < _g1.length) {
			let marble = _g1[_g];
			++_g;
			if(marble == this.collider) {
				continue;
			}
			let _this = marble.transform;
			let v = new h3d_Vector();
			let x = _this._41;
			let y = _this._42;
			let z = _this._43;
			let w = _this._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			v.x = x;
			v.y = y;
			v.z = z;
			v.w = w;
			let isec = collision_Collision.capsuleSphereNearestOverlap(position,nextPos,this._radius,v,marble.radius);
			if(isec.result) {
				foundMarbles.push(marble);
				isec.t *= deltaT;
				if(isec.t >= finalT) {
					let x = velocity.x * finalT;
					let y = velocity.y * finalT;
					let z = velocity.z * finalT;
					let w = velocity.w;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let v_x = x;
					let v_y = y;
					let v_z = z;
					let v_w = w;
					let x1 = position.x + v_x;
					let y1 = position.y + v_y;
					let z1 = position.z + v_z;
					let w1 = position.w + v_w;
					if(w1 == null) {
						w1 = 1.;
					}
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let _this_x = x1;
					let _this_y = y1;
					let _this_z = z1;
					let x2 = _this_x - v.x;
					let y2 = _this_y - v.y;
					let z2 = _this_z - v.z;
					if(z2 == null) {
						z2 = 0.;
					}
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					let vel_x = x2;
					let vel_y = y2;
					let vel_z = z2;
					let k = vel_x * vel_x + vel_y * vel_y + vel_z * vel_z;
					if(k < 1e-10) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					vel_x *= k;
					vel_y *= k;
					vel_z *= k;
					let _this = this.velocity;
					let v1 = marble.velocity;
					let x3 = _this.x - v1.x;
					let y3 = _this.y - v1.y;
					let z3 = _this.z - v1.z;
					if(z3 == null) {
						z3 = 0.;
					}
					if(y3 == null) {
						y3 = 0.;
					}
					if(x3 == null) {
						x3 = 0.;
					}
					let _this_x1 = x3;
					let _this_y1 = y3;
					let _this_z1 = z3;
					let newVelLen = _this_x1 * vel_x + _this_y1 * vel_y + _this_z1 * vel_z;
					if(newVelLen < 0.0) {
						finalT = isec.t;
						let x = nextPos.x - position.x;
						let y = nextPos.y - position.y;
						let z = nextPos.z - position.z;
						let w = nextPos.w - position.w;
						if(w == null) {
							w = 1.;
						}
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let _this_x = x;
						let _this_y = y;
						let _this_z = z;
						let _this_w = w;
						let v1 = isec.t;
						let x1 = _this_x * v1;
						let y1 = _this_y * v1;
						let z1 = _this_z * v1;
						let w1 = _this_w;
						if(_this_w == null) {
							w1 = 1.;
						}
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let posDiff_x = x1;
						let posDiff_y = y1;
						let posDiff_z = z1;
						let posDiff_w = w1;
						let x2 = posDiff_x + position.x;
						let y2 = posDiff_y + position.y;
						let z2 = posDiff_z + position.z;
						let w2 = posDiff_w + position.w;
						if(w2 == null) {
							w2 = 1.;
						}
						if(z2 == null) {
							z2 = 0.;
						}
						if(y2 == null) {
							y2 = 0.;
						}
						if(x2 == null) {
							x2 = 0.;
						}
						let p_x = x2;
						let p_y = y2;
						let p_z = z2;
						let p_w = w2;
						this.lastContactNormal = new h3d_Vector(p_x - v.x,p_y - v.y,p_z - v.z,p_w - v.w);
						let _this = this.lastContactNormal;
						let k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
						if(k < 1e-10) {
							k = 0;
						} else {
							k = 1. / Math.sqrt(k);
						}
						_this.x *= k;
						_this.y *= k;
						_this.z *= k;
						let _this1 = this.lastContactNormal;
						let v2 = this._radius;
						let x3 = _this1.x * v2;
						let y3 = _this1.y * v2;
						let z3 = _this1.z * v2;
						let w3 = _this1.w;
						if(w3 == null) {
							w3 = 1.;
						}
						if(z3 == null) {
							z3 = 0.;
						}
						if(y3 == null) {
							y3 = 0.;
						}
						if(x3 == null) {
							x3 = 0.;
						}
						let v_x = x3;
						let v_y = y3;
						let v_z = z3;
						let v_w = w3;
						lastContactPos = new h3d_Vector(p_x - v_x,p_y - v_y,p_z - v_z,p_w - v_w);
					}
				}
			}
		}
		let _g2 = 0;
		while(_g2 < foundObjs.length) {
			let obj = foundObjs[_g2];
			++_g2;
			if(obj.go != null && !obj.go.isCollideable) {
				continue;
			}
			let invMatrix = obj.invTransform;
			if(((obj.go) instanceof src_PathedInterior)) {
				invMatrix = obj.transform.getInverse();
			}
			let invTform = invMatrix.clone();
			invTform.transpose();
			let x = position.x;
			let y = position.y;
			let z = position.z;
			let w = position.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let localpos_x = x;
			let localpos_y = y;
			let localpos_z = z;
			let localpos_w = w;
			let px = localpos_x * invMatrix._11 + localpos_y * invMatrix._21 + localpos_z * invMatrix._31 + localpos_w * invMatrix._41;
			let py = localpos_x * invMatrix._12 + localpos_y * invMatrix._22 + localpos_z * invMatrix._32 + localpos_w * invMatrix._42;
			let pz = localpos_x * invMatrix._13 + localpos_y * invMatrix._23 + localpos_z * invMatrix._33 + localpos_w * invMatrix._43;
			localpos_x = px;
			localpos_y = py;
			localpos_z = pz;
			let v = obj.velocity;
			let x1 = velocity.x - v.x;
			let y1 = velocity.y - v.y;
			let z1 = velocity.z - v.z;
			let w1 = velocity.w - v.w;
			if(w1 == null) {
				w1 = 1.;
			}
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let relVel_x = x1;
			let relVel_y = y1;
			let relVel_z = z1;
			let relVel_w = w1;
			let px1 = relVel_x * invMatrix._11 + relVel_y * invMatrix._21 + relVel_z * invMatrix._31;
			let py1 = relVel_x * invMatrix._12 + relVel_y * invMatrix._22 + relVel_z * invMatrix._32;
			let pz1 = relVel_x * invMatrix._13 + relVel_y * invMatrix._23 + relVel_z * invMatrix._33;
			let x2 = px1;
			let y2 = py1;
			let z2 = pz1;
			if(pz1 == null) {
				z2 = 0.;
			}
			if(py1 == null) {
				y2 = 0.;
			}
			if(px1 == null) {
				x2 = 0.;
			}
			let relLocalVel_x = x2;
			let relLocalVel_y = y2;
			let relLocalVel_z = z2;
			let invScale_x = 0.;
			let invScale_y = 0.;
			let invScale_z = 0.;
			invScale_x = Math.sqrt(invMatrix._11 * invMatrix._11 + invMatrix._12 * invMatrix._12 + invMatrix._13 * invMatrix._13);
			invScale_y = Math.sqrt(invMatrix._21 * invMatrix._21 + invMatrix._22 * invMatrix._22 + invMatrix._23 * invMatrix._23);
			invScale_z = Math.sqrt(invMatrix._31 * invMatrix._31 + invMatrix._32 * invMatrix._32 + invMatrix._33 * invMatrix._33);
			if(invMatrix._11 * (invMatrix._22 * invMatrix._33 - invMatrix._23 * invMatrix._32) + invMatrix._12 * (invMatrix._23 * invMatrix._31 - invMatrix._21 * invMatrix._33) + invMatrix._13 * (invMatrix._21 * invMatrix._32 - invMatrix._22 * invMatrix._31) < 0) {
				invScale_x *= -1;
				invScale_y *= -1;
				invScale_z *= -1;
			}
			let x3 = radius * invScale_x;
			let y3 = radius * invScale_y;
			let z3 = radius * invScale_z;
			if(z3 == null) {
				z3 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			let sphereRadius_x = x3;
			let sphereRadius_y = y3;
			let sphereRadius_z = z3;
			let boundThing = new h3d_col_Bounds();
			let x4 = localpos_x;
			let y4 = localpos_y;
			let z4 = localpos_z;
			let r = radius * 2;
			if(x4 - r < boundThing.xMin) {
				boundThing.xMin = x4 - r;
			}
			if(x4 + r > boundThing.xMax) {
				boundThing.xMax = x4 + r;
			}
			if(y4 - r < boundThing.yMin) {
				boundThing.yMin = y4 - r;
			}
			if(y4 + r > boundThing.yMax) {
				boundThing.yMax = y4 + r;
			}
			if(z4 - r < boundThing.zMin) {
				boundThing.zMin = z4 - r;
			}
			if(z4 + r > boundThing.zMax) {
				boundThing.zMax = z4 + r;
			}
			let x5 = localpos_x + relLocalVel_x * deltaT * 5;
			let y5 = localpos_y + relLocalVel_y * deltaT * 5;
			let z5 = localpos_z + relLocalVel_z * deltaT * 5;
			let r1 = Math.max(Math.max(sphereRadius_x,sphereRadius_y),sphereRadius_z) * 2;
			if(x5 - r1 < boundThing.xMin) {
				boundThing.xMin = x5 - r1;
			}
			if(x5 + r1 > boundThing.xMax) {
				boundThing.xMax = x5 + r1;
			}
			if(y5 - r1 < boundThing.yMin) {
				boundThing.yMin = y5 - r1;
			}
			if(y5 + r1 > boundThing.yMax) {
				boundThing.yMax = y5 + r1;
			}
			if(z5 - r1 < boundThing.zMin) {
				boundThing.zMin = z5 - r1;
			}
			if(z5 + r1 > boundThing.zMax) {
				boundThing.zMax = z5 + r1;
			}
			let x6 = relVel_x * finalT;
			let y6 = relVel_y * finalT;
			let z6 = relVel_z * finalT;
			let w2 = relVel_w;
			if(relVel_w == null) {
				w2 = 1.;
			}
			if(z6 == null) {
				z6 = 0.;
			}
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			let v_x = x6;
			let v_y = y6;
			let v_z = z6;
			let v_w = w2;
			let currentFinalPos = new h3d_Vector(position.x + v_x,position.y + v_y,position.z + v_z,position.w + v_w);
			let surfaces;
			if(obj.grid != null) {
				surfaces = obj.grid.boundingSearch(boundThing);
			} else if(obj.bvh == null) {
				let _this = obj.octree.boundingSearch(boundThing);
				let result = new Array(_this.length);
				let _g = 0;
				let _g1 = _this.length;
				while(_g < _g1) {
					let i = _g++;
					result[i] = _this[i];
				}
				surfaces = result;
			} else {
				surfaces = obj.bvh.boundingSearch(boundThing);
			}
			let _g = 0;
			while(_g < surfaces.length) {
				let surf = surfaces[_g];
				++_g;
				let x = relVel_x * finalT;
				let y = relVel_y * finalT;
				let z = relVel_z * finalT;
				let w = relVel_w;
				if(relVel_w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v_x = x;
				let v_y = y;
				let v_z = z;
				let v_w = w;
				currentFinalPos = new h3d_Vector(position.x + v_x,position.y + v_y,position.z + v_z,position.w + v_w);
				let i = 0;
				while(i < surf.indices.length) {
					let tform = obj.transform;
					let key = obj._transformKey;
					if(surf._transformedPoints == null) {
						surf._transformedPoints = surf.points.slice();
					}
					if(surf._transformedNormals == null) {
						surf._transformedNormals = surf.normals.slice();
					}
					let p1 = surf.indices[i];
					let p2 = surf.indices[i + 1];
					let p3 = surf.indices[i + 2];
					if(surf.transformKeys[p1] != key) {
						let x = surf.points[p1 * 3];
						let y = surf.points[p1 * 3 + 1];
						let z = surf.points[p1 * 3 + 2];
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let _this_x = x;
						let _this_y = y;
						let _this_z = z;
						let px = _this_x * tform._11 + _this_y * tform._21 + _this_z * tform._31 + tform._41;
						let py = _this_x * tform._12 + _this_y * tform._22 + _this_z * tform._32 + tform._42;
						let pz = _this_x * tform._13 + _this_y * tform._23 + _this_z * tform._33 + tform._43;
						let x1 = px;
						let y1 = py;
						let z1 = pz;
						if(pz == null) {
							z1 = 0.;
						}
						if(py == null) {
							y1 = 0.;
						}
						if(px == null) {
							x1 = 0.;
						}
						let pt_x = x1;
						let pt_y = y1;
						let pt_z = z1;
						surf._transformedPoints[p1 * 3] = pt_x;
						surf._transformedPoints[p1 * 3 + 1] = pt_y;
						surf._transformedPoints[p1 * 3 + 2] = pt_z;
						let x2 = surf.normals[p1 * 3];
						let y2 = surf.normals[p1 * 3 + 1];
						let z2 = surf.normals[p1 * 3 + 2];
						if(z2 == null) {
							z2 = 0.;
						}
						if(y2 == null) {
							y2 = 0.;
						}
						if(x2 == null) {
							x2 = 0.;
						}
						let _this_x1 = x2;
						let _this_y1 = y2;
						let _this_z1 = z2;
						let px1 = _this_x1 * invTform._11 + _this_y1 * invTform._21 + _this_z1 * invTform._31;
						let py1 = _this_x1 * invTform._12 + _this_y1 * invTform._22 + _this_z1 * invTform._32;
						let pz1 = _this_x1 * invTform._13 + _this_y1 * invTform._23 + _this_z1 * invTform._33;
						let x3 = px1;
						let y3 = py1;
						let z3 = pz1;
						if(pz1 == null) {
							z3 = 0.;
						}
						if(py1 == null) {
							y3 = 0.;
						}
						if(px1 == null) {
							x3 = 0.;
						}
						let _this_x2 = x3;
						let _this_y2 = y3;
						let _this_z2 = z3;
						let k = _this_x2 * _this_x2 + _this_y2 * _this_y2 + _this_z2 * _this_z2;
						if(k < 1e-10) {
							k = 0;
						} else {
							k = 1. / Math.sqrt(k);
						}
						let x4 = _this_x2 * k;
						let y4 = _this_y2 * k;
						let z4 = _this_z2 * k;
						if(z4 == null) {
							z4 = 0.;
						}
						if(y4 == null) {
							y4 = 0.;
						}
						if(x4 == null) {
							x4 = 0.;
						}
						let pn_x = x4;
						let pn_y = y4;
						let pn_z = z4;
						surf._transformedNormals[p1 * 3] = pn_x;
						surf._transformedNormals[p1 * 3 + 1] = pn_y;
						surf._transformedNormals[p1 * 3 + 2] = pn_z;
						surf.transformKeys[p1] = key;
					}
					if(surf.transformKeys[p2] != key) {
						let x = surf.points[p2 * 3];
						let y = surf.points[p2 * 3 + 1];
						let z = surf.points[p2 * 3 + 2];
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let _this_x = x;
						let _this_y = y;
						let _this_z = z;
						let px = _this_x * tform._11 + _this_y * tform._21 + _this_z * tform._31 + tform._41;
						let py = _this_x * tform._12 + _this_y * tform._22 + _this_z * tform._32 + tform._42;
						let pz = _this_x * tform._13 + _this_y * tform._23 + _this_z * tform._33 + tform._43;
						let x1 = px;
						let y1 = py;
						let z1 = pz;
						if(pz == null) {
							z1 = 0.;
						}
						if(py == null) {
							y1 = 0.;
						}
						if(px == null) {
							x1 = 0.;
						}
						let pt_x = x1;
						let pt_y = y1;
						let pt_z = z1;
						surf._transformedPoints[p2 * 3] = pt_x;
						surf._transformedPoints[p2 * 3 + 1] = pt_y;
						surf._transformedPoints[p2 * 3 + 2] = pt_z;
						surf.transformKeys[p2] = key;
					}
					if(surf.transformKeys[p3] != key) {
						let x = surf.points[p3 * 3];
						let y = surf.points[p3 * 3 + 1];
						let z = surf.points[p3 * 3 + 2];
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let _this_x = x;
						let _this_y = y;
						let _this_z = z;
						let px = _this_x * tform._11 + _this_y * tform._21 + _this_z * tform._31 + tform._41;
						let py = _this_x * tform._12 + _this_y * tform._22 + _this_z * tform._32 + tform._42;
						let pz = _this_x * tform._13 + _this_y * tform._23 + _this_z * tform._33 + tform._43;
						let x1 = px;
						let y1 = py;
						let z1 = pz;
						if(pz == null) {
							z1 = 0.;
						}
						if(py == null) {
							y1 = 0.;
						}
						if(px == null) {
							x1 = 0.;
						}
						let pt_x = x1;
						let pt_y = y1;
						let pt_z = z1;
						surf._transformedPoints[p3 * 3] = pt_x;
						surf._transformedPoints[p3 * 3 + 1] = pt_y;
						surf._transformedPoints[p3 * 3 + 2] = pt_z;
						surf.transformKeys[p3] = key;
					}
					let x = surf._transformedPoints[p1 * 3];
					let y = surf._transformedPoints[p1 * 3 + 1];
					let z = surf._transformedPoints[p1 * 3 + 2];
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let v1_x = x;
					let v1_y = y;
					let v1_z = z;
					let x1 = surf._transformedPoints[p2 * 3];
					let y1 = surf._transformedPoints[p2 * 3 + 1];
					let z1 = surf._transformedPoints[p2 * 3 + 2];
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let v2_x = x1;
					let v2_y = y1;
					let v2_z = z1;
					let x2 = surf._transformedPoints[p3 * 3];
					let y2 = surf._transformedPoints[p3 * 3 + 1];
					let z2 = surf._transformedPoints[p3 * 3 + 2];
					if(z2 == null) {
						z2 = 0.;
					}
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					let v3_x = x2;
					let v3_y = y2;
					let v3_z = z2;
					let x3 = surf._transformedNormals[p1 * 3];
					let y3 = surf._transformedNormals[p1 * 3 + 1];
					let z3 = surf._transformedNormals[p1 * 3 + 2];
					if(z3 == null) {
						z3 = 0.;
					}
					if(y3 == null) {
						y3 = 0.;
					}
					if(x3 == null) {
						x3 = 0.;
					}
					let n_x = x3;
					let n_y = y3;
					let n_z = z3;
					let x4 = v1_x;
					let y4 = v1_y;
					let z4 = v1_z;
					if(v1_z == null) {
						z4 = 0.;
					}
					if(v1_y == null) {
						y4 = 0.;
					}
					if(v1_x == null) {
						x4 = 0.;
					}
					let v0_x = x4;
					let v0_y = y4;
					let v0_z = z4;
					let x5 = v2_x;
					let y5 = v2_y;
					let z5 = v2_z;
					if(v2_z == null) {
						z5 = 0.;
					}
					if(v2_y == null) {
						y5 = 0.;
					}
					if(v2_x == null) {
						x5 = 0.;
					}
					let v_x = x5;
					let v_y = y5;
					let v_z = z5;
					let x6 = v3_x;
					let y6 = v3_y;
					let z6 = v3_z;
					if(v3_z == null) {
						z6 = 0.;
					}
					if(v3_y == null) {
						y6 = 0.;
					}
					if(v3_x == null) {
						x6 = 0.;
					}
					let v2_x1 = x6;
					let v2_y1 = y6;
					let v2_z1 = z6;
					let x7 = n_x;
					let y7 = n_y;
					let z7 = n_z;
					if(n_z == null) {
						z7 = 0.;
					}
					if(n_y == null) {
						y7 = 0.;
					}
					if(n_x == null) {
						x7 = 0.;
					}
					let surfaceNormal_x = x7;
					let surfaceNormal_y = y7;
					let surfaceNormal_z = z7;
					if(obj.correctNormals) {
						let x = v_x - v0_x;
						let y = v_y - v0_y;
						let z = v_z - v0_z;
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let _this_x = x;
						let _this_y = y;
						let _this_z = z;
						let x1 = v2_x1 - v0_x;
						let y1 = v2_y1 - v0_y;
						let z1 = v2_z1 - v0_z;
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let v_x1 = x1;
						let v_y1 = y1;
						let v_z1 = z1;
						let x2 = _this_y * v_z1 - _this_z * v_y1;
						let y2 = _this_z * v_x1 - _this_x * v_z1;
						let z2 = _this_x * v_y1 - _this_y * v_x1;
						if(z2 == null) {
							z2 = 0.;
						}
						if(y2 == null) {
							y2 = 0.;
						}
						if(x2 == null) {
							x2 = 0.;
						}
						let _this_x1 = x2;
						let _this_y1 = y2;
						let _this_z1 = z2;
						let k = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
						if(k < 1e-10) {
							k = 0;
						} else {
							k = 1. / Math.sqrt(k);
						}
						let x3 = _this_x1 * k;
						let y3 = _this_y1 * k;
						let z3 = _this_z1 * k;
						if(z3 == null) {
							z3 = 0.;
						}
						if(y3 == null) {
							y3 = 0.;
						}
						if(x3 == null) {
							x3 = 0.;
						}
						let _this_x2 = x3;
						let _this_y2 = y3;
						let _this_z2 = z3;
						let x4 = _this_x2 * -1;
						let y4 = _this_y2 * -1;
						let z4 = _this_z2 * -1;
						if(z4 == null) {
							z4 = 0.;
						}
						if(y4 == null) {
							y4 = 0.;
						}
						if(x4 == null) {
							x4 = 0.;
						}
						let v_x2 = x4;
						let v_y2 = y4;
						let v_z2 = z4;
						surfaceNormal_x = v_x2;
						surfaceNormal_y = v_y2;
						surfaceNormal_z = v_z2;
					}
					let surfaceD = -(surfaceNormal_x * v0_x + surfaceNormal_y * v0_y + surfaceNormal_z * v0_z);
					if(surfaceNormal_x * relVel_x + surfaceNormal_y * relVel_y + surfaceNormal_z * relVel_z > -0.001 || surfaceNormal_x * currentFinalPos.x + surfaceNormal_y * currentFinalPos.y + surfaceNormal_z * currentFinalPos.z + surfaceD > radius) {
						i += 3;
						continue;
					}
					testTriangles.push(new src_MarbleTestMoveFoundContact([new h3d_Vector(v0_x,v0_y,v0_z,1.),new h3d_Vector(v_x,v_y,v_z,1.),new h3d_Vector(v2_x1,v2_y1,v2_z1,1.)],new h3d_Vector(surfaceNormal_x,surfaceNormal_y,surfaceNormal_z,1.)));
					let collisionTime = (radius - (position.x * surfaceNormal_x + position.y * surfaceNormal_y + position.z * surfaceNormal_z) - surfaceD) / (surfaceNormal_x * relVel_x + surfaceNormal_y * relVel_y + surfaceNormal_z * relVel_z);
					if(collisionTime >= 0.000001 && finalT >= collisionTime) {
						let x = relVel_x * collisionTime;
						let y = relVel_y * collisionTime;
						let z = relVel_z * collisionTime;
						let w = relVel_w;
						if(relVel_w == null) {
							w = 1.;
						}
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let v_x1 = x;
						let v_y1 = y;
						let v_z1 = z;
						let v_w = w;
						let x1 = position.x + v_x1;
						let y1 = position.y + v_y1;
						let z1 = position.z + v_z1;
						let w1 = position.w + v_w;
						if(w1 == null) {
							w1 = 1.;
						}
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let collisionPoint_x = x1;
						let collisionPoint_y = y1;
						let collisionPoint_z = z1;
						let x2 = v_x - v0_x;
						let y2 = v_y - v0_y;
						let z2 = v_z - v0_z;
						if(z2 == null) {
							z2 = 0.;
						}
						if(y2 == null) {
							y2 = 0.;
						}
						if(x2 == null) {
							x2 = 0.;
						}
						let u_x = x2;
						let u_y = y2;
						let u_z = z2;
						let x3 = v2_x1 - v0_x;
						let y3 = v2_y1 - v0_y;
						let z3 = v2_z1 - v0_z;
						if(z3 == null) {
							z3 = 0.;
						}
						if(y3 == null) {
							y3 = 0.;
						}
						if(x3 == null) {
							x3 = 0.;
						}
						let v_x2 = x3;
						let v_y2 = y3;
						let v_z2 = z3;
						let x4 = collisionPoint_x - v0_x;
						let y4 = collisionPoint_y - v0_y;
						let z4 = collisionPoint_z - v0_z;
						if(z4 == null) {
							z4 = 0.;
						}
						if(y4 == null) {
							y4 = 0.;
						}
						if(x4 == null) {
							x4 = 0.;
						}
						let w_x = x4;
						let w_y = y4;
						let w_z = z4;
						let x5 = v_y2 * w_z - v_z2 * w_y;
						let y5 = v_z2 * w_x - v_x2 * w_z;
						let z5 = v_x2 * w_y - v_y2 * w_x;
						if(z5 == null) {
							z5 = 0.;
						}
						if(y5 == null) {
							y5 = 0.;
						}
						if(x5 == null) {
							x5 = 0.;
						}
						let vw_x = x5;
						let vw_y = y5;
						let vw_z = z5;
						let x6 = v_y2 * u_z - v_z2 * u_y;
						let y6 = v_z2 * u_x - v_x2 * u_z;
						let z6 = v_x2 * u_y - v_y2 * u_x;
						if(z6 == null) {
							z6 = 0.;
						}
						if(y6 == null) {
							y6 = 0.;
						}
						if(x6 == null) {
							x6 = 0.;
						}
						let vu_x = x6;
						let vu_y = y6;
						let vu_z = z6;
						let tmp;
						if(vw_x * vu_x + vw_y * vu_y + vw_z * vu_z < 0.0) {
							tmp = false;
						} else {
							let x = u_y * w_z - u_z * w_y;
							let y = u_z * w_x - u_x * w_z;
							let z = u_x * w_y - u_y * w_x;
							if(z == null) {
								z = 0.;
							}
							if(y == null) {
								y = 0.;
							}
							if(x == null) {
								x = 0.;
							}
							let uw_x = x;
							let uw_y = y;
							let uw_z = z;
							let x1 = u_y * v_z2 - u_z * v_y2;
							let y1 = u_z * v_x2 - u_x * v_z2;
							let z1 = u_x * v_y2 - u_y * v_x2;
							if(z1 == null) {
								z1 = 0.;
							}
							if(y1 == null) {
								y1 = 0.;
							}
							if(x1 == null) {
								x1 = 0.;
							}
							let uv_x = x1;
							let uv_y = y1;
							let uv_z = z1;
							if(uw_x * uv_x + uw_y * uv_y + uw_z * uv_z < 0.0) {
								tmp = false;
							} else {
								let d = Math.sqrt(uv_x * uv_x + uv_y * uv_y + uv_z * uv_z);
								let r = Math.sqrt(vw_x * vw_x + vw_y * vw_y + vw_z * vw_z) / d;
								let t = Math.sqrt(uw_x * uw_x + uw_y * uw_y + uw_z * uw_z) / d;
								tmp = r + t <= 1;
							}
						}
						if(tmp) {
							finalT = collisionTime;
							let x = relVel_x * collisionTime;
							let y = relVel_y * collisionTime;
							let z = relVel_z * collisionTime;
							let w = relVel_w;
							if(relVel_w == null) {
								w = 1.;
							}
							if(z == null) {
								z = 0.;
							}
							if(y == null) {
								y = 0.;
							}
							if(x == null) {
								x = 0.;
							}
							let v_x = x;
							let v_y = y;
							let v_z = z;
							let v_w = w;
							currentFinalPos = new h3d_Vector(position.x + v_x,position.y + v_y,position.z + v_z,position.w + v_w);
							found = true;
							lastContactPos = new h3d_Vector(currentFinalPos.x,currentFinalPos.y,currentFinalPos.z,currentFinalPos.w);
							i += 3;
							continue;
						}
					}
					let triangleVerts = [new h3d_Vector(v0_x,v0_y,v0_z,1.),new h3d_Vector(v_x,v_y,v_z,1.),new h3d_Vector(v2_x1,v2_y1,v2_z1,1.)];
					let lastVert = new h3d_Vector(v2_x1,v2_y1,v2_z1,1.);
					let radSq = radius * radius;
					let _g = 0;
					while(_g < 3) {
						let iter = _g++;
						let thisVert = triangleVerts[iter];
						let x = lastVert.x - thisVert.x;
						let y = lastVert.y - thisVert.y;
						let z = lastVert.z - thisVert.z;
						let w = lastVert.w - thisVert.w;
						if(w == null) {
							w = 1.;
						}
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let vertDiff_x = x;
						let vertDiff_y = y;
						let vertDiff_z = z;
						let vertDiff_w = w;
						let x1 = position.x - thisVert.x;
						let y1 = position.y - thisVert.y;
						let z1 = position.z - thisVert.z;
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let posDiff_x = x1;
						let posDiff_y = y1;
						let posDiff_z = z1;
						let x2 = vertDiff_y * relVel_z - vertDiff_z * relVel_y;
						let y2 = vertDiff_z * relVel_x - vertDiff_x * relVel_z;
						let z2 = vertDiff_x * relVel_y - vertDiff_y * relVel_x;
						if(z2 == null) {
							z2 = 0.;
						}
						if(y2 == null) {
							y2 = 0.;
						}
						if(x2 == null) {
							x2 = 0.;
						}
						let velRejection_x = x2;
						let velRejection_y = y2;
						let velRejection_z = z2;
						let x3 = vertDiff_y * posDiff_z - vertDiff_z * posDiff_y;
						let y3 = vertDiff_z * posDiff_x - vertDiff_x * posDiff_z;
						let z3 = vertDiff_x * posDiff_y - vertDiff_y * posDiff_x;
						if(z3 == null) {
							z3 = 0.;
						}
						if(y3 == null) {
							y3 = 0.;
						}
						if(x3 == null) {
							x3 = 0.;
						}
						let posRejection_x = x3;
						let posRejection_y = y3;
						let posRejection_z = z3;
						let a = velRejection_x * velRejection_x + velRejection_y * velRejection_y + velRejection_z * velRejection_z;
						let b = 2 * (posRejection_x * velRejection_x + posRejection_y * velRejection_y + posRejection_z * velRejection_z);
						let c = posRejection_x * posRejection_x + posRejection_y * posRejection_y + posRejection_z * posRejection_z - (vertDiff_x * vertDiff_x + vertDiff_y * vertDiff_y + vertDiff_z * vertDiff_z) * radSq;
						let discriminant = b * b - 4 * a * c;
						if(a == 0.0 || discriminant < 0.0) {
							lastVert.x = thisVert.x;
							lastVert.y = thisVert.y;
							lastVert.z = thisVert.z;
							lastVert.w = thisVert.w;
							continue;
						}
						let oneOverTwoA = 0.5 / a;
						let discriminantSqrt = Math.sqrt(discriminant);
						let edgeCollisionTime = (-b + discriminantSqrt) * oneOverTwoA;
						let edgeCollisionTime2 = (-b - discriminantSqrt) * oneOverTwoA;
						if(edgeCollisionTime2 < edgeCollisionTime) {
							let temp = edgeCollisionTime2;
							edgeCollisionTime2 = edgeCollisionTime;
							edgeCollisionTime = temp;
						}
						if(edgeCollisionTime2 <= 0.0001 || finalT <= edgeCollisionTime) {
							lastVert.x = thisVert.x;
							lastVert.y = thisVert.y;
							lastVert.z = thisVert.z;
							lastVert.w = thisVert.w;
							continue;
						}
						if(edgeCollisionTime >= 0.000001) {
							let edgeLen = Math.sqrt(vertDiff_x * vertDiff_x + vertDiff_y * vertDiff_y + vertDiff_z * vertDiff_z);
							let x = relVel_x * edgeCollisionTime;
							let y = relVel_y * edgeCollisionTime;
							let z = relVel_z * edgeCollisionTime;
							let w = relVel_w;
							if(relVel_w == null) {
								w = 1.;
							}
							if(z == null) {
								z = 0.;
							}
							if(y == null) {
								y = 0.;
							}
							if(x == null) {
								x = 0.;
							}
							let v_x = x;
							let v_y = y;
							let v_z = z;
							let v_w = w;
							let x1 = position.x + v_x;
							let y1 = position.y + v_y;
							let z1 = position.z + v_z;
							let w1 = position.w + v_w;
							if(w1 == null) {
								w1 = 1.;
							}
							if(z1 == null) {
								z1 = 0.;
							}
							if(y1 == null) {
								y1 = 0.;
							}
							if(x1 == null) {
								x1 = 0.;
							}
							let _this_x = x1;
							let _this_y = y1;
							let _this_z = z1;
							let x2 = _this_x - thisVert.x;
							let y2 = _this_y - thisVert.y;
							let z2 = _this_z - thisVert.z;
							if(z2 == null) {
								z2 = 0.;
							}
							if(y2 == null) {
								y2 = 0.;
							}
							if(x2 == null) {
								x2 = 0.;
							}
							let relativeCollisionPos_x = x2;
							let relativeCollisionPos_y = y2;
							let relativeCollisionPos_z = z2;
							let distanceAlongEdge = (relativeCollisionPos_x * vertDiff_x + relativeCollisionPos_y * vertDiff_y + relativeCollisionPos_z * vertDiff_z) / edgeLen;
							if(-radius > distanceAlongEdge || edgeLen + radius < distanceAlongEdge) {
								lastVert.x = thisVert.x;
								lastVert.y = thisVert.y;
								lastVert.z = thisVert.z;
								lastVert.w = thisVert.w;
								continue;
							}
							if(distanceAlongEdge >= 0.0 && distanceAlongEdge <= edgeLen) {
								finalT = edgeCollisionTime;
								let x = relVel_x * finalT;
								let y = relVel_y * finalT;
								let z = relVel_z * finalT;
								let w = relVel_w;
								if(relVel_w == null) {
									w = 1.;
								}
								if(z == null) {
									z = 0.;
								}
								if(y == null) {
									y = 0.;
								}
								if(x == null) {
									x = 0.;
								}
								let v_x = x;
								let v_y = y;
								let v_z = z;
								let v_w = w;
								currentFinalPos = new h3d_Vector(position.x + v_x,position.y + v_y,position.z + v_z,position.w + v_w);
								let v = distanceAlongEdge / edgeLen;
								let x1 = vertDiff_x * v;
								let y1 = vertDiff_y * v;
								let z1 = vertDiff_z * v;
								let w1 = vertDiff_w;
								if(vertDiff_w == null) {
									w1 = 1.;
								}
								if(z1 == null) {
									z1 = 0.;
								}
								if(y1 == null) {
									y1 = 0.;
								}
								if(x1 == null) {
									x1 = 0.;
								}
								let _this_x = x1;
								let _this_y = y1;
								let _this_z = z1;
								let _this_w = w1;
								lastContactPos = new h3d_Vector(_this_x + thisVert.x,_this_y + thisVert.y,_this_z + thisVert.z,_this_w + thisVert.w);
								lastVert = thisVert;
								found = true;
								continue;
							}
						}
						a = relVel_x * relVel_x + relVel_y * relVel_y + relVel_z * relVel_z;
						let x4 = position.x - thisVert.x;
						let y4 = position.y - thisVert.y;
						let z4 = position.z - thisVert.z;
						if(z4 == null) {
							z4 = 0.;
						}
						if(y4 == null) {
							y4 = 0.;
						}
						if(x4 == null) {
							x4 = 0.;
						}
						let posVertDiff_x = x4;
						let posVertDiff_y = y4;
						let posVertDiff_z = z4;
						b = 2 * (posVertDiff_x * relVel_x + posVertDiff_y * relVel_y + posVertDiff_z * relVel_z);
						c = posVertDiff_x * posVertDiff_x + posVertDiff_y * posVertDiff_y + posVertDiff_z * posVertDiff_z - radSq;
						discriminant = b * b - 4 * a * c;
						if(a != 0.0 && discriminant >= 0.0) {
							oneOverTwoA = 0.5 / a;
							discriminantSqrt = Math.sqrt(discriminant);
							edgeCollisionTime = (-b + discriminantSqrt) * oneOverTwoA;
							edgeCollisionTime2 = (-b - discriminantSqrt) * oneOverTwoA;
							if(edgeCollisionTime2 < edgeCollisionTime) {
								let temp = edgeCollisionTime2;
								edgeCollisionTime2 = edgeCollisionTime;
								edgeCollisionTime = temp;
							}
							if(edgeCollisionTime2 > 0.0001 && finalT > edgeCollisionTime) {
								if(edgeCollisionTime <= 0.0 && edgeCollisionTime > -0.0001) {
									edgeCollisionTime = 0.0;
								}
								if(edgeCollisionTime >= 0.000001) {
									finalT = edgeCollisionTime;
									let x = relVel_x * finalT;
									let y = relVel_y * finalT;
									let z = relVel_z * finalT;
									let w = relVel_w;
									if(relVel_w == null) {
										w = 1.;
									}
									if(z == null) {
										z = 0.;
									}
									if(y == null) {
										y = 0.;
									}
									if(x == null) {
										x = 0.;
									}
									let v_x = x;
									let v_y = y;
									let v_z = z;
									let v_w = w;
									currentFinalPos = new h3d_Vector(position.x + v_x,position.y + v_y,position.z + v_z,position.w + v_w);
									lastContactPos = thisVert;
									found = true;
								}
							}
						}
						let x5 = position.x - lastVert.x;
						let y5 = position.y - lastVert.y;
						let z5 = position.z - lastVert.z;
						if(z5 == null) {
							z5 = 0.;
						}
						if(y5 == null) {
							y5 = 0.;
						}
						if(x5 == null) {
							x5 = 0.;
						}
						let posVertDiff_x1 = x5;
						let posVertDiff_y1 = y5;
						let posVertDiff_z1 = z5;
						b = 2 * (posVertDiff_x1 * relVel_x + posVertDiff_y1 * relVel_y + posVertDiff_z1 * relVel_z);
						c = posVertDiff_x1 * posVertDiff_x1 + posVertDiff_y1 * posVertDiff_y1 + posVertDiff_z1 * posVertDiff_z1 - radSq;
						discriminant = b * b - 4 * a * c;
						if(a == 0.0 || discriminant < 0.0) {
							lastVert.x = thisVert.x;
							lastVert.y = thisVert.y;
							lastVert.z = thisVert.z;
							lastVert.w = thisVert.w;
							continue;
						}
						oneOverTwoA = 0.5 / a;
						discriminantSqrt = Math.sqrt(discriminant);
						edgeCollisionTime = (-b + discriminantSqrt) * oneOverTwoA;
						edgeCollisionTime2 = (-b - discriminantSqrt) * oneOverTwoA;
						if(edgeCollisionTime2 < edgeCollisionTime) {
							let temp = edgeCollisionTime2;
							edgeCollisionTime2 = edgeCollisionTime;
							edgeCollisionTime = temp;
						}
						if(edgeCollisionTime2 <= 0.0001 || finalT <= edgeCollisionTime) {
							lastVert.x = thisVert.x;
							lastVert.y = thisVert.y;
							lastVert.z = thisVert.z;
							lastVert.w = thisVert.w;
							continue;
						}
						if(edgeCollisionTime <= 0.0 && edgeCollisionTime > -0.0001) {
							edgeCollisionTime = 0;
						}
						if(edgeCollisionTime < 0.000001) {
							lastVert.x = thisVert.x;
							lastVert.y = thisVert.y;
							lastVert.z = thisVert.z;
							lastVert.w = thisVert.w;
							continue;
						}
						finalT = edgeCollisionTime;
						let x6 = relVel_x * finalT;
						let y6 = relVel_y * finalT;
						let z6 = relVel_z * finalT;
						let w1 = relVel_w;
						if(relVel_w == null) {
							w1 = 1.;
						}
						if(z6 == null) {
							z6 = 0.;
						}
						if(y6 == null) {
							y6 = 0.;
						}
						if(x6 == null) {
							x6 = 0.;
						}
						let v_x = x6;
						let v_y = y6;
						let v_z = z6;
						let v_w = w1;
						currentFinalPos = new h3d_Vector(position.x + v_x,position.y + v_y,position.z + v_z,position.w + v_w);
						lastVert.x = thisVert.x;
						lastVert.y = thisVert.y;
						lastVert.z = thisVert.z;
						lastVert.w = thisVert.w;
						found = true;
					}
					i += 3;
				}
			}
		}
		let x3 = velocity.x * finalT;
		let y3 = velocity.y * finalT;
		let z3 = velocity.z * finalT;
		let w1 = velocity.w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z3 == null) {
			z3 = 0.;
		}
		if(y3 == null) {
			y3 = 0.;
		}
		if(x3 == null) {
			x3 = 0.;
		}
		let deltaPosition_x = x3;
		let deltaPosition_y = y3;
		let deltaPosition_z = z3;
		let deltaPosition_w = w1;
		let finalPosition = new h3d_Vector(position.x + deltaPosition_x,position.y + deltaPosition_y,position.z + deltaPosition_z,position.w + deltaPosition_w);
		let x4 = finalPosition.x - lastContactPos.x;
		let y4 = finalPosition.y - lastContactPos.y;
		let z4 = finalPosition.z - lastContactPos.z;
		if(z4 == null) {
			z4 = 0.;
		}
		if(y4 == null) {
			y4 = 0.;
		}
		if(x4 == null) {
			x4 = 0.;
		}
		let _this_x = x4;
		let _this_y = y4;
		let _this_z = z4;
		let k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		return new src_MarbleTestMoveResult(finalPosition,finalT,found,testTriangles,lastContactPos,new h3d_Vector(_this_x * k,_this_y * k,_this_z * k),foundMarbles);
	}
	nudgeToContacts(position,radius,foundContacts,foundMarbles) {
		if(net_Net.isMP) {
			return position;
		}
		let it = 0;
		let prevResolved = 0;
		while(true) {
			let resolved = 0;
			let _g = 0;
			while(_g < foundContacts.length) {
				let testTri = foundContacts[_g];
				++_g;
				let _this = testTri.n;
				let _this1 = testTri.n;
				let v = testTri.v[0];
				if(_this.x * position.x + _this.y * position.y + _this.z * position.z - (_this1.x * v.x + _this1.y * v.y + _this1.z * v.z) < 0) {
					continue;
				}
				let _this2 = testTri.v[1];
				let v1 = testTri.v[0];
				let x = _this2.x - v1.x;
				let y = _this2.y - v1.y;
				let z = _this2.z - v1.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let t1_x = x;
				let t1_y = y;
				let t1_z = z;
				let _this3 = testTri.v[2];
				let v2 = testTri.v[0];
				let x1 = _this3.x - v2.x;
				let y1 = _this3.y - v2.y;
				let z1 = _this3.z - v2.z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let t2_x = x1;
				let t2_y = y1;
				let t2_z = z1;
				let x2 = t1_y * t2_z - t1_z * t2_y;
				let y2 = t1_z * t2_x - t1_x * t2_z;
				let z2 = t1_x * t2_y - t1_y * t2_x;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let _this_x = x2;
				let _this_y = y2;
				let _this_z = z2;
				let tarea = Math.abs(Math.sqrt(_this_x * _this_x + _this_y * _this_y + _this_z * _this_z)) / 2.0;
				if(tarea < 0.001) {
					continue;
				}
				let _this4 = testTri.v[0];
				let x3 = _this4.x - position.x;
				let y3 = _this4.y - position.y;
				let z3 = _this4.z - position.z;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				let _this_x1 = x3;
				let _this_y1 = y3;
				let _this_z1 = z3;
				let v3 = testTri.n;
				let _this5 = testTri.n;
				let t = (_this_x1 * v3.x + _this_y1 * v3.y + _this_z1 * v3.z) / (_this5.x * _this5.x + _this5.y * _this5.y + _this5.z * _this5.z);
				let _this6 = testTri.n;
				let x4 = _this6.x * t;
				let y4 = _this6.y * t;
				let z4 = _this6.z * t;
				let w = _this6.w;
				if(w == null) {
					w = 1.;
				}
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				let v_x = x4;
				let v_y = y4;
				let v_z = z4;
				let v_w = w;
				let x5 = position.x + v_x;
				let y5 = position.y + v_y;
				let z5 = position.z + v_z;
				let w1 = position.w + v_w;
				if(w1 == null) {
					w1 = 1.;
				}
				if(z5 == null) {
					z5 = 0.;
				}
				if(y5 == null) {
					y5 = 0.;
				}
				if(x5 == null) {
					x5 = 0.;
				}
				let intersect_x = x5;
				let intersect_y = y5;
				let intersect_z = z5;
				let v0 = testTri.v[0];
				let v11 = testTri.v[1];
				let v21 = testTri.v[2];
				let x6 = v11.x - v0.x;
				let y6 = v11.y - v0.y;
				let z6 = v11.z - v0.z;
				if(z6 == null) {
					z6 = 0.;
				}
				if(y6 == null) {
					y6 = 0.;
				}
				if(x6 == null) {
					x6 = 0.;
				}
				let u_x = x6;
				let u_y = y6;
				let u_z = z6;
				let x7 = v21.x - v0.x;
				let y7 = v21.y - v0.y;
				let z7 = v21.z - v0.z;
				if(z7 == null) {
					z7 = 0.;
				}
				if(y7 == null) {
					y7 = 0.;
				}
				if(x7 == null) {
					x7 = 0.;
				}
				let v_x1 = x7;
				let v_y1 = y7;
				let v_z1 = z7;
				let x8 = intersect_x - v0.x;
				let y8 = intersect_y - v0.y;
				let z8 = intersect_z - v0.z;
				if(z8 == null) {
					z8 = 0.;
				}
				if(y8 == null) {
					y8 = 0.;
				}
				if(x8 == null) {
					x8 = 0.;
				}
				let w_x = x8;
				let w_y = y8;
				let w_z = z8;
				let x9 = v_y1 * w_z - v_z1 * w_y;
				let y9 = v_z1 * w_x - v_x1 * w_z;
				let z9 = v_x1 * w_y - v_y1 * w_x;
				if(z9 == null) {
					z9 = 0.;
				}
				if(y9 == null) {
					y9 = 0.;
				}
				if(x9 == null) {
					x9 = 0.;
				}
				let vw_x = x9;
				let vw_y = y9;
				let vw_z = z9;
				let x10 = v_y1 * u_z - v_z1 * u_y;
				let y10 = v_z1 * u_x - v_x1 * u_z;
				let z10 = v_x1 * u_y - v_y1 * u_x;
				if(z10 == null) {
					z10 = 0.;
				}
				if(y10 == null) {
					y10 = 0.;
				}
				if(x10 == null) {
					x10 = 0.;
				}
				let vu_x = x10;
				let vu_y = y10;
				let vu_z = z10;
				let tsi;
				if(vw_x * vu_x + vw_y * vu_y + vw_z * vu_z < 0.0) {
					tsi = false;
				} else {
					let x = u_y * w_z - u_z * w_y;
					let y = u_z * w_x - u_x * w_z;
					let z = u_x * w_y - u_y * w_x;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let uw_x = x;
					let uw_y = y;
					let uw_z = z;
					let x1 = u_y * v_z1 - u_z * v_y1;
					let y1 = u_z * v_x1 - u_x * v_z1;
					let z1 = u_x * v_y1 - u_y * v_x1;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let uv_x = x1;
					let uv_y = y1;
					let uv_z = z1;
					if(uw_x * uv_x + uw_y * uv_y + uw_z * uv_z < 0.0) {
						tsi = false;
					} else {
						let d = Math.sqrt(uv_x * uv_x + uv_y * uv_y + uv_z * uv_z);
						let r = Math.sqrt(vw_x * vw_x + vw_y * vw_y + vw_z * vw_z) / d;
						let t = Math.sqrt(uw_x * uw_x + uw_y * uw_y + uw_z * uw_z) / d;
						tsi = r + t <= 1;
					}
				}
				if(tsi) {
					let x = position.x - intersect_x;
					let y = position.y - intersect_y;
					let z = position.z - intersect_z;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let _this_x = x;
					let _this_y = y;
					let _this_z = z;
					let k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
					if(k < 1e-10) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					let x1 = _this_x * k;
					let y1 = _this_y * k;
					let z1 = _this_z * k;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let separatingDistance_x = x1;
					let separatingDistance_y = y1;
					let separatingDistance_z = z1;
					let dx = position.x - intersect_x;
					let dy = position.y - intersect_y;
					let dz = position.z - intersect_z;
					let distToContactPlane = Math.sqrt(dx * dx + dy * dy + dz * dz);
					if(radius - 0.005 - distToContactPlane > 0.0001) {
						let p1 = testTri.v[0];
						let p2 = testTri.v[1];
						let p3 = testTri.v[2];
						if(src_Debug.drawBounds) {
							src_Debug._triangles.push(new h3d_col_Point(p3.x,p3.y,p3.z));
							src_Debug._triangles.push(new h3d_col_Point(p2.x,p2.y,p2.z));
							src_Debug._triangles.push(new h3d_col_Point(p1.x,p1.y,p1.z));
						}
						if(src_Debug.drawBounds) {
							src_Debug._spheres.push({ position : new h3d_Vector(position.x,position.y,position.z,position.w), radius : radius, lifetime : 0.032});
						}
						let v = radius - distToContactPlane - 0.005;
						let x = separatingDistance_x * v;
						let y = separatingDistance_y * v;
						let z = separatingDistance_z * v;
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let v_x = x;
						let v_y = y;
						let v_z = z;
						let x1 = position.x + v_x;
						let y1 = position.y + v_y;
						let z1 = position.z + v_z;
						let w = position.w + 1.;
						if(w == null) {
							w = 1.;
						}
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let v_x1 = x1;
						let v_y1 = y1;
						let v_z1 = z1;
						let v_w = w;
						position.x = v_x1;
						position.y = v_y1;
						position.z = v_z1;
						position.w = v_w;
						++resolved;
					}
				}
			}
			if(resolved == 0 && prevResolved == 0) {
				break;
			}
			prevResolved = resolved;
			++it;
			if(!(it < 10)) {
				break;
			}
		}
		let _g = 0;
		while(_g < foundMarbles.length) {
			let marble = foundMarbles[_g];
			++_g;
			let _this = marble.transform;
			let marblePosition_x = 0.;
			let marblePosition_y = 0.;
			let marblePosition_z = 0.;
			let marblePosition_w = 1.;
			let x = _this._41;
			let y = _this._42;
			let z = _this._43;
			let w = _this._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			marblePosition_x = x;
			marblePosition_y = y;
			marblePosition_z = z;
			marblePosition_w = w;
			let dx = position.x - marblePosition_x;
			let dy = position.y - marblePosition_y;
			let dz = position.z - marblePosition_z;
			let dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
			if(dist < radius + marble.radius + 0.001) {
				let x = position.x - marblePosition_x;
				let y = position.y - marblePosition_y;
				let z = position.z - marblePosition_z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let _this_x = x;
				let _this_y = y;
				let _this_z = z;
				let k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
				if(k < 1e-10) {
					k = 0;
				} else {
					k = 1. / Math.sqrt(k);
				}
				let x1 = _this_x * k;
				let y1 = _this_y * k;
				let z1 = _this_z * k;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let separatingDistance_x = x1;
				let separatingDistance_y = y1;
				let separatingDistance_z = z1;
				let v = radius + marble.radius + 0.001 - dist;
				let x2 = separatingDistance_x * v;
				let y2 = separatingDistance_y * v;
				let z2 = separatingDistance_z * v;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let v_x = x2;
				let v_y = y2;
				let v_z = z2;
				let x3 = position.x + v_x;
				let y3 = position.y + v_y;
				let z3 = position.z + v_z;
				let w = position.w + 1.;
				if(w == null) {
					w = 1.;
				}
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				let v_x1 = x3;
				let v_y1 = y3;
				let v_z1 = z3;
				let v_w = w;
				position.x = v_x1;
				position.y = v_y1;
				position.z = v_z1;
				position.w = v_w;
			}
		}
		return position;
	}
	advancePhysics(timeState,m,collisionWorld,pathedInteriors) {
		let timeRemaining = timeState.dt;
		if(this.isNetUpdate) {
			this.lastMove = m;
		}
		if(m == null) {
			m = new net_Move();
			m.d = new h3d_Vector();
		}
		if(this.blastTicks < 937) {
			this.blastTicks += 1;
		}
		if(net_Net.isClient) {
			this.serverTicks++;
		}
		this._bounceYet = false;
		let contactTime = 0.0;
		let it = 0;
		let passedTime = timeState.currentAttemptTime;
		let _this = this.collider.transform;
		let v = new h3d_Vector();
		let x = _this._41;
		let y = _this._42;
		let z = _this._43;
		let w = _this._44;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v.x = x;
		v.y = y;
		v.z = z;
		v.w = w;
		this.oldPos = v;
		let _this1 = this.getRotationQuat();
		this.prevRot = new h3d_Quat(_this1.x,_this1.y,_this1.z,_this1.w);
		if(this.controllable) {
			let _g = 0;
			while(_g < pathedInteriors.length) {
				let interior = pathedInteriors[_g];
				++_g;
				interior.computeNextPathStep(timeRemaining);
			}
		}
		if(m != null && m.blast) {
			this.useBlast(timeState);
			if(this.level.isRecording) {
				this.level.replay.recordMarbleStateFlags(false,false,false,true);
			}
		}
		while(!(timeRemaining <= 0)) {
			let timeStep = 0.00800000037997961;
			if(timeRemaining < 0.00800000037997961) {
				timeStep = timeRemaining;
			}
			passedTime += timeStep;
			let stoppedPaths = false;
			let tempState = timeState.clone();
			tempState.dt = timeStep;
			++it;
			this.findContacts(collisionWorld,tempState);
			if(this._firstTick) {
				this.contacts = [];
				this._firstTick = false;
			}
			let aControl = new h3d_Vector();
			let desiredOmega = new h3d_Vector();
			let isCentered = this.computeMoveForces(m,aControl,desiredOmega);
			stoppedPaths = this.velocityCancel(timeState.currentAttemptTime,timeStep,isCentered,false,false,pathedInteriors);
			let A = this.getExternalForces(tempState,m);
			let a = this.applyContactForces(timeStep,m,isCentered,aControl,desiredOmega,A);
			let f = A.x * A.x + A.y * A.y + A.z * A.z;
			if(isNaN(f)) {
				A.x = 0;
				A.y = 0;
				A.z = 0;
				A.w = 1.;
			}
			let f1 = a.x * a.x + a.y * a.y + a.z * a.z;
			if(isNaN(f1)) {
				a.x = 0;
				a.y = 0;
				a.z = 0;
				a.w = 1.;
			}
			let _this = this.velocity;
			let x = this.velocity.x + A.x * timeStep;
			let y = this.velocity.y + A.y * timeStep;
			let z = this.velocity.z + A.z * timeStep;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this.x = x;
			_this.y = y;
			_this.z = z;
			_this.w = 1.;
			let _this1 = this.omega;
			let x1 = this.omega.x + a.x * timeStep;
			let y1 = this.omega.y + a.y * timeStep;
			let z1 = this.omega.z + a.z * timeStep;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			_this1.x = x1;
			_this1.y = y1;
			_this1.z = z1;
			_this1.w = 1.;
			if(this.mode == src_Mode.Start) {
				let _this = this.velocity;
				_this.x = 0;
				_this.y = 0;
				_this.z = 0;
				_this.w = 1.;
			}
			this.velocityCancel(timeState.currentAttemptTime,timeStep,isCentered,true,stoppedPaths,pathedInteriors);
			this._totalTime += timeStep;
			if(this.contacts.length != 0) {
				this._contactTime += timeStep;
			}
			let _g = 0;
			let _g1 = this.appliedImpulses;
			while(_g < _g1.length) {
				let impulse = _g1[_g];
				++_g;
				let _this = this.velocity;
				let v = impulse.impulse;
				this.velocity = new h3d_Vector(_this.x + v.x,_this.y + v.y,_this.z + v.z,_this.w + v.w);
				if(m.jump && impulse.contactImpulse) {
					let _this = this.velocity;
					let _this1 = impulse.impulse;
					let k = _this1.x * _this1.x + _this1.y * _this1.y + _this1.z * _this1.z;
					if(k < 1e-10) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					let x = _this1.x * k;
					let y = _this1.y * k;
					let z = _this1.z * k;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let _this_x = x;
					let _this_y = y;
					let _this_z = z;
					let v = this._jumpImpulse;
					let x1 = _this_x * v;
					let y1 = _this_y * v;
					let z1 = _this_z * v;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let v_x = x1;
					let v_y = y1;
					let v_z = z1;
					this.velocity = new h3d_Vector(_this.x + v_x,_this.y + v_y,_this.z + v_z,_this.w + 1.);
				}
			}
			this.appliedImpulses = [];
			this.velocity.w = 0;
			let _this2 = this.collider.transform;
			let v = new h3d_Vector();
			let x2 = _this2._41;
			let y2 = _this2._42;
			let z2 = _this2._43;
			let w = _this2._44;
			if(w == null) {
				w = 1.;
			}
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			v.x = x2;
			v.y = y2;
			v.z = z2;
			v.w = w;
			this.prevPos = new h3d_Vector(v.x,v.y,v.z,v.w);
			let finalPosData = this.testMove(this.velocity,v,timeStep,this._radius,true);
			if(finalPosData.found) {
				let diff = timeStep - finalPosData.t;
				let _this = this.velocity;
				let x = A.x * diff;
				let y = A.y * diff;
				let z = A.z * diff;
				let w = A.w;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v_x = x;
				let v_y = y;
				let v_z = z;
				let v_w = w;
				this.velocity = new h3d_Vector(_this.x - v_x,_this.y - v_y,_this.z - v_z,_this.w - v_w);
				let _this1 = this.omega;
				let x1 = a.x * diff;
				let y1 = a.y * diff;
				let z1 = a.z * diff;
				let w1 = a.w;
				if(w1 == null) {
					w1 = 1.;
				}
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let v_x1 = x1;
				let v_y1 = y1;
				let v_z1 = z1;
				let v_w1 = w1;
				this.omega = new h3d_Vector(_this1.x - v_x1,_this1.y - v_y1,_this1.z - v_z1,_this1.w - v_w1);
				timeStep = finalPosData.t;
			}
			let expectedPos = finalPosData.position;
			let newPos = this.nudgeToContacts(expectedPos,this._radius,finalPosData.foundContacts,finalPosData.foundMarbles);
			let _this3 = this.velocity;
			if(_this3.x * _this3.x + _this3.y * _this3.y + _this3.z * _this3.z > 1e-8) {
				let x = newPos.x - expectedPos.x;
				let y = newPos.y - expectedPos.y;
				let z = newPos.z - expectedPos.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let posDiff_x = x;
				let posDiff_y = y;
				let posDiff_z = z;
				if(posDiff_x * posDiff_x + posDiff_y * posDiff_y + posDiff_z * posDiff_z > 1e-8) {
					let _this = this.velocity;
					let v1 = this.velocity;
					let _this1 = this.velocity;
					let v2 = (posDiff_x * v1.x + posDiff_y * v1.y + posDiff_z * v1.z) / (_this1.x * _this1.x + _this1.y * _this1.y + _this1.z * _this1.z);
					let x = _this.x * v2;
					let y = _this.y * v2;
					let z = _this.z * v2;
					let w = _this.w;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let velDiffProj_x = x;
					let velDiffProj_y = y;
					let velDiffProj_z = z;
					let velDiffProj_w = w;
					let x1 = expectedPos.x + velDiffProj_x;
					let y1 = expectedPos.y + velDiffProj_y;
					let z1 = expectedPos.z + velDiffProj_z;
					let w1 = expectedPos.w + velDiffProj_w;
					if(w1 == null) {
						w1 = 1.;
					}
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let expectedProjPos_x = x1;
					let expectedProjPos_y = y1;
					let expectedProjPos_z = z1;
					let x2 = expectedProjPos_x - v.x;
					let y2 = expectedProjPos_y - v.y;
					let z2 = expectedProjPos_z - v.z;
					if(z2 == null) {
						z2 = 0.;
					}
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					let _this_x = x2;
					let _this_y = y2;
					let _this_z = z2;
					let _this2 = this.velocity;
					let updatedTimestep = Math.sqrt(_this_x * _this_x + _this_y * _this_y + _this_z * _this_z) / Math.sqrt(_this2.x * _this2.x + _this2.y * _this2.y + _this2.z * _this2.z);
					let tDiff = updatedTimestep - timeStep;
					if(tDiff > 0) {
						let _this = this.velocity;
						let x = A.x * tDiff;
						let y = A.y * tDiff;
						let z = A.z * tDiff;
						let w = A.w;
						if(w == null) {
							w = 1.;
						}
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let v_x = x;
						let v_y = y;
						let v_z = z;
						let v_w = w;
						this.velocity = new h3d_Vector(_this.x - v_x,_this.y - v_y,_this.z - v_z,_this.w - v_w);
						let _this1 = this.omega;
						let x1 = a.x * tDiff;
						let y1 = a.y * tDiff;
						let z1 = a.z * tDiff;
						let w1 = a.w;
						if(w1 == null) {
							w1 = 1.;
						}
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let v_x1 = x1;
						let v_y1 = y1;
						let v_z1 = z1;
						let v_w1 = w1;
						this.omega = new h3d_Vector(_this1.x - v_x1,_this1.y - v_y1,_this1.z - v_z1,_this1.w - v_w1);
						timeStep = updatedTimestep;
					}
				}
			}
			let rot = this.getRotationQuat();
			let quat_x = 0.;
			let quat_y = 0.;
			let quat_z = 0.;
			let quat_w = 1.;
			let ax = this.omega.x * timeStep;
			let ay = this.omega.y * timeStep;
			let az = this.omega.z * timeStep;
			let sinX = Math.sin(ax * 0.5);
			let cosX = Math.cos(ax * 0.5);
			let sinY = Math.sin(ay * 0.5);
			let cosY = Math.cos(ay * 0.5);
			let sinZ = Math.sin(az * 0.5);
			let cosZ = Math.cos(az * 0.5);
			let cosYZ = cosY * cosZ;
			let sinYZ = sinY * sinZ;
			quat_x = sinX * cosYZ - cosX * sinYZ;
			quat_y = cosX * sinY * cosZ + sinX * cosY * sinZ;
			quat_z = cosX * cosY * sinZ - sinX * sinY * cosZ;
			quat_w = cosX * cosYZ + sinX * sinYZ;
			let x21 = quat_x * rot.w + quat_w * rot.x + quat_y * rot.z - quat_z * rot.y;
			let y21 = quat_w * rot.y - quat_x * rot.z + quat_y * rot.w + quat_z * rot.x;
			let z21 = quat_w * rot.z + quat_x * rot.y - quat_y * rot.x + quat_z * rot.w;
			let w2 = quat_w * rot.w - quat_x * rot.x - quat_y * rot.y - quat_z * rot.z;
			quat_x = x21;
			quat_y = y21;
			quat_z = z21;
			quat_w = w2;
			let m1 = null;
			m1 = new h3d_Matrix();
			let xx = quat_x * quat_x;
			let xy = quat_x * quat_y;
			let xz = quat_x * quat_z;
			let xw = quat_x * quat_w;
			let yy = quat_y * quat_y;
			let yz = quat_y * quat_z;
			let yw = quat_y * quat_w;
			let zz = quat_z * quat_z;
			let zw = quat_z * quat_w;
			m1._11 = 1 - 2 * (yy + zz);
			m1._12 = 2 * (xy + zw);
			m1._13 = 2 * (xz - yw);
			m1._14 = 0;
			m1._21 = 2 * (xy - zw);
			m1._22 = 1 - 2 * (xx + zz);
			m1._23 = 2 * (yz + xw);
			m1._24 = 0;
			m1._31 = 2 * (xz + yw);
			m1._32 = 2 * (yz - xw);
			m1._33 = 1 - 2 * (xx + yy);
			m1._34 = 0;
			m1._41 = 0;
			m1._42 = 0;
			m1._43 = 0;
			m1._44 = 1;
			let totMatrix = m1;
			newPos.w = 1;
			totMatrix._41 = newPos.x;
			totMatrix._42 = newPos.y;
			totMatrix._43 = newPos.z;
			totMatrix._44 = newPos.w;
			this.collider.setTransform(totMatrix);
			this.collisionWorld.updateTransform(this.collider);
			this.collider.velocity = this.velocity;
			if(this.heldPowerup != null && (m.powerup || net_Net.isClient && this.serverUsePowerup && !this.controllable) && !this.outOfBounds) {
				let pTime = timeState.clone();
				pTime.dt = timeStep;
				pTime.currentAttemptTime = passedTime;
				let netUpdate = this.isNetUpdate;
				if(this.serverUsePowerup) {
					this.isNetUpdate = false;
				}
				this.heldPowerup.use(this,pTime);
				this.isNetUpdate = netUpdate;
				this.heldPowerup = null;
				this.serverUsePowerup = false;
				if(!this.isNetUpdate) {
					this.netFlags |= 40;
				}
				if(this.level.isRecording) {
					this.level.replay.recordPowerupPickup(null);
				}
			}
			if(this.contacts.length != 0) {
				contactTime += timeStep;
			}
			timeRemaining -= timeStep;
			if(this.controllable) {
				let _g = 0;
				while(_g < pathedInteriors.length) {
					let interior = pathedInteriors[_g];
					++_g;
					interior.advance(timeStep);
				}
			}
			if(!(it <= 10)) {
				break;
			}
		}
		if(timeRemaining > 0) {
			if(this.controllable) {
				let _g = 0;
				while(_g < pathedInteriors.length) {
					let interior = pathedInteriors[_g];
					++_g;
					interior.advance(timeRemaining);
				}
			}
		}
		this.queuedContacts = [];
		let _this2 = this.collider.transform;
		let v1 = new h3d_Vector();
		let x1 = _this2._41;
		let y1 = _this2._42;
		let z1 = _this2._43;
		let w1 = _this2._44;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		v1.x = x1;
		v1.y = y1;
		v1.z = z1;
		v1.w = w1;
		this.newPos = v1;
		if(this.prevPos != null && this.level != null) {
			let tempTimeState = timeState.clone();
			tempTimeState.currentAttemptTime = passedTime;
			this.level.callCollisionHandlers(this,tempTimeState,this.oldPos,this.newPos);
		}
		this.updateRollSound(timeState,contactTime / timeState.dt,this._slipAmount);
		if(this.megaMarbleUseTick > 0) {
			if(net_Net.isHost) {
				if(timeState.ticks - this.megaMarbleUseTick <= 312 && this.megaMarbleUseTick > 0) {
					this._radius = 0.675;
					this.collider.radius = 0.675;
				} else if(timeState.ticks - this.megaMarbleUseTick > 312) {
					this.collider.radius = this._radius = 0.3;
					if(!this.isNetUpdate && this.controllable) {
						src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/MegaShrink.wav",src_ResourceLoader.getAudio,this.soundResources),null,false);
					}
					this.megaMarbleUseTick = 0;
					this.netFlags |= 4;
				}
			}
			if(net_Net.isClient) {
				if(this.serverTicks - this.megaMarbleUseTick <= 312 && this.megaMarbleUseTick > 0) {
					this._radius = 0.675;
					this.collider.radius = 0.675;
				} else {
					this.collider.radius = this._radius = 0.3;
					if(!this.isNetUpdate && this.controllable) {
						src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/MegaShrink.wav",src_ResourceLoader.getAudio,this.soundResources),null,false);
					}
					this.megaMarbleUseTick = 0;
				}
			}
		}
		if(net_Net.isClient && this.megaMarbleUseTick == 0) {
			this.collider.radius = this._radius = 0.3;
		}
		if(net_Net.isMP) {
			if(m.jump && this.outOfBounds) {
				this.level.cancel(this.oobSchedule);
				this.level.restart(this);
			}
		}
	}
	packUpdate(move,timeState) {
		let b = new net_OutputBitStream();
		b.writeByte(5);
		let marbleUpdate = new net_MarbleUpdatePacket();
		marbleUpdate.clientId = this.connection != null ? this.connection.id : 0;
		marbleUpdate.serverTicks = timeState.ticks;
		marbleUpdate.position = this.newPos;
		marbleUpdate.velocity = this.velocity;
		marbleUpdate.omega = this.omega;
		marbleUpdate.lastContactNormal = this.lastContactNormal;
		marbleUpdate.move = move;
		marbleUpdate.moveQueueSize = this.connection != null ? this.connection.moveManager.queuedMoves.length : 255;
		marbleUpdate.blastAmount = this.blastTicks;
		marbleUpdate.blastTick = this.blastUseTick;
		marbleUpdate.heliTick = this.helicopterUseTick;
		marbleUpdate.megaTick = this.megaMarbleUseTick;
		marbleUpdate.oob = this.outOfBounds;
		marbleUpdate.powerUpId = this.heldPowerup != null ? this.heldPowerup.netIndex : 511;
		marbleUpdate.netFlags = this.netFlags;
		marbleUpdate.gravityDirection = this.currentUp;
		b.writeByte(marbleUpdate.clientId);
		let m = marbleUpdate.move;
		b.writeUInt16(m.id);
		b.writeByte(m.move.d.x * 16 + 16 | 0);
		b.writeByte(m.move.d.y * 16 + 16 | 0);
		b.writeFlag(m.move.jump);
		b.writeFlag(m.move.powerup);
		b.writeFlag(m.move.blast);
		b.writeFloat(m.motionDir.x);
		b.writeFloat(m.motionDir.y);
		b.writeFloat(m.motionDir.z);
		b.writeUInt16(marbleUpdate.serverTicks);
		b.writeByte(marbleUpdate.moveQueueSize);
		b.writeFloat(marbleUpdate.position.x);
		b.writeFloat(marbleUpdate.position.y);
		b.writeFloat(marbleUpdate.position.z);
		b.writeFloat(marbleUpdate.velocity.x);
		b.writeFloat(marbleUpdate.velocity.y);
		b.writeFloat(marbleUpdate.velocity.z);
		b.writeFloat(marbleUpdate.omega.x);
		b.writeFloat(marbleUpdate.omega.y);
		b.writeFloat(marbleUpdate.omega.z);
		b.writeFloat(marbleUpdate.lastContactNormal.x);
		b.writeFloat(marbleUpdate.lastContactNormal.y);
		b.writeFloat(marbleUpdate.lastContactNormal.z);
		b.writeInt(marbleUpdate.blastAmount,11);
		if((marbleUpdate.netFlags & 1) > 0) {
			b.writeFlag(true);
			b.writeUInt16(marbleUpdate.blastTick);
		} else {
			b.writeFlag(false);
		}
		if((marbleUpdate.netFlags & 2) > 0) {
			b.writeFlag(true);
			b.writeUInt16(marbleUpdate.heliTick);
		} else {
			b.writeFlag(false);
		}
		if((marbleUpdate.netFlags & 4) > 0) {
			b.writeFlag(true);
			b.writeUInt16(marbleUpdate.megaTick);
		} else {
			b.writeFlag(false);
		}
		b.writeFlag(marbleUpdate.oob);
		if((marbleUpdate.netFlags & 32) > 0) {
			b.writeFlag(true);
		} else {
			b.writeFlag(false);
		}
		if((marbleUpdate.netFlags & 8) > 0) {
			b.writeFlag(true);
			b.writeInt(marbleUpdate.powerUpId,9);
		} else {
			b.writeFlag(false);
		}
		if((marbleUpdate.netFlags & 16) > 0) {
			b.writeFlag(true);
			b.writeFloat(marbleUpdate.gravityDirection.x);
			b.writeFloat(marbleUpdate.gravityDirection.y);
			b.writeFloat(marbleUpdate.gravityDirection.z);
		} else {
			b.writeFlag(false);
		}
		return b.getBytes();
	}
	unpackUpdate(p) {
		this.serverTicks = p.serverTicks;
		this.recvServerTick = p.serverTicks;
		let _this = this.collider.transform;
		let v = p.position;
		_this._41 = v.x;
		_this._42 = v.y;
		_this._43 = v.z;
		_this._44 = v.w;
		this.velocity = p.velocity;
		this.omega = p.omega;
		this.lastContactNormal = p.lastContactNormal;
		this.blastTicks = p.blastAmount;
		this.blastUseTick = p.blastTick;
		this.helicopterUseTick = p.heliTick;
		this.megaMarbleUseTick = p.megaTick;
		this.serverUsePowerup = (p.netFlags & 32) > 0;
		this.level.setUp(this,p.gravityDirection,this.level.timeState);
		if(this.outOfBounds && !p.oob && this.controllable) {
			this.level.playGui.setCenterText("");
		}
		this.outOfBounds = p.oob;
		this.camera.oob = p.oob;
		if(p.powerUpId == 511) {
			if(!this.serverUsePowerup) {
				this.level.deselectPowerUp(this);
			} else {
				src_Console.instance.addEntry("log","Using powerup");
			}
		} else {
			this.level.pickUpPowerUp(this,this.level.powerUps[p.powerUpId]);
		}
		if(p.moveQueueSize == 0 && this.connection != null) {
			let _this = this.connection.moveManager;
			if(_this.queuedMoves.length != 0) {
				_this.queuedMoves.splice(0,0,_this.queuedMoves[0]);
			}
		}
		if(net_Net.isClient && !this.controllable && this.serverTicks - this.blastUseTick < 12) {
			let ticksSince = this.serverTicks - this.blastUseTick;
			if(ticksSince >= 0) {
				this.blastWave.doSequenceOnceBeginTime = this.level.timeState.timeSinceLoad - ticksSince * 0.032;
				this.blastUseTime = this.level.timeState.currentAttemptTime - ticksSince * 0.032;
			}
		}
		return true;
	}
	calculateNetSmooth() {
		if(this.netCorrected) {
			this.netCorrected = false;
			let _this = this.netSmoothOffset;
			let _this1 = this.lastRenderPos;
			let v = this.oldPos;
			let x = _this1.x - v.x;
			let y = _this1.y - v.y;
			let z = _this1.z - v.z;
			let w = _this1.w - v.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let v_x = x;
			let v_y = y;
			let v_z = z;
			let v_w = w;
			_this.x = v_x;
			_this.y = v_y;
			_this.z = v_z;
			_this.w = v_w;
		}
	}
	updateServer(timeState,collisionWorld,pathedInteriors) {
		let move = null;
		if(this.controllable && this.mode != src_Mode.Finish) {
			if(net_Net.isClient) {
				let axis = this.getMarbleAxis()[1];
				move = net_Net.clientConnection.recordMove(this,axis,timeState,this.recvServerTick);
			} else if(net_Net.isHost) {
				let axis = this.getMarbleAxis()[1];
				let innerMove = this.recordMove();
				if(src_MarbleGame.instance.paused) {
					innerMove.d.x = 0;
					innerMove.d.y = 0;
					innerMove.blast = innerMove.jump = innerMove.powerup = false;
				} else {
					let qx = innerMove.d.x * 16 + 16 | 0;
					let qy = innerMove.d.y * 16 + 16 | 0;
					innerMove.d.x = (qx - 16) / 16.0;
					innerMove.d.y = (qy - 16) / 16.0;
				}
				move = new net_NetMove(innerMove,axis,timeState,this.recvServerTick,65535);
			}
		}
		if(!this.controllable && this.connection != null && net_Net.isHost) {
			let nextMove = this.connection.getNextMove();
			if(nextMove == null) {
				let axis = this.moveMotionDir != null ? this.moveMotionDir : this.getMarbleAxis()[1];
				let innerMove = this.lastMove;
				if(innerMove == null) {
					innerMove = new net_Move();
					innerMove.d = new h3d_Vector(0,0);
				}
				move = new net_NetMove(innerMove,axis,timeState,this.recvServerTick,65535);
			} else {
				move = nextMove;
				this.moveMotionDir = nextMove.motionDir;
				this.lastMove = nextMove.move;
			}
		}
		if(move == null && !this.controllable) {
			let axis = this.moveMotionDir != null ? this.moveMotionDir : new h3d_Vector(0,-1,0);
			let innerMove = this.lastMove;
			if(innerMove == null) {
				innerMove = new net_Move();
				innerMove.d = new h3d_Vector(0,0);
			}
			move = new net_NetMove(innerMove,axis,timeState,this.recvServerTick,65535);
		}
		if(move != null) {
			this.playedSounds = [];
			this.advancePhysics(timeState,move.move,collisionWorld,pathedInteriors);
			this.physicsAccumulator = 0;
		} else {
			this.physicsAccumulator = 0;
			let _this = this.newPos;
			let v = this.oldPos;
			_this.x = v.x;
			_this.y = v.y;
			_this.z = v.z;
			_this.w = v.w;
		}
		return move;
	}
	updateClient(timeState,pathedInteriors) {
		this.calculateNetSmooth();
		this.level.updateBlast(this,timeState);
		let newDt = 2.3 * (timeState.dt / 0.4);
		let smooth = 1.0 / (newDt * (newDt * 0.235 * newDt) + newDt + 1.0 + 0.48 * newDt * newDt);
		let _this = this.netSmoothOffset;
		_this.x *= smooth;
		_this.y *= smooth;
		_this.z *= smooth;
		let _this1 = this.netSmoothOffset;
		let smoothScale = _this1.x * _this1.x + _this1.y * _this1.y + _this1.z * _this1.z;
		if(smoothScale < 0.01 || smoothScale > 20.0) {
			let _this = this.netSmoothOffset;
			_this.x = 0;
			_this.y = 0;
			_this.z = 0;
			_this.w = 1.;
		}
		if(this.oldPos != null && this.newPos != null) {
			let deltaT = this.physicsAccumulator / 0.032;
			let v1 = this.oldPos;
			let v2 = this.newPos;
			let a = v1.x;
			let x = a + (v2.x - a) * deltaT;
			let a1 = v1.y;
			let y = a1 + (v2.y - a1) * deltaT;
			let a2 = v1.z;
			let z = a2 + (v2.z - a2) * deltaT;
			let a3 = v1.w;
			let w = a3 + (v2.w - a3) * deltaT;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let renderPos_x = x;
			let renderPos_y = y;
			let renderPos_z = z;
			let renderPos_w = w;
			if(net_Net.isClient) {
				let v = this.netSmoothOffset;
				let x = renderPos_x + v.x;
				let y = renderPos_y + v.y;
				let z = renderPos_z + v.z;
				let w = renderPos_w + v.w;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v_x = x;
				let v_y = y;
				let v_z = z;
				let v_w = w;
				renderPos_x = v_x;
				renderPos_y = v_y;
				renderPos_z = v_z;
				renderPos_w = v_w;
			}
			let x1 = renderPos_x;
			let y1 = renderPos_y;
			let z1 = renderPos_z;
			this.x = x1;
			this.flags |= 1;
			this.y = y1;
			this.flags |= 1;
			this.z = z1;
			this.flags |= 1;
			this.flags |= 1;
			let _this = this.lastRenderPos;
			_this.x = renderPos_x;
			_this.y = renderPos_y;
			_this.z = renderPos_z;
			_this.w = renderPos_w;
			let rot = this.getRotationQuat();
			let quat = new h3d_Quat();
			let ax = this.omega.x * timeState.dt;
			let ay = this.omega.y * timeState.dt;
			let az = this.omega.z * timeState.dt;
			let sinX = Math.sin(ax * 0.5);
			let cosX = Math.cos(ax * 0.5);
			let sinY = Math.sin(ay * 0.5);
			let cosY = Math.cos(ay * 0.5);
			let sinZ = Math.sin(az * 0.5);
			let cosZ = Math.cos(az * 0.5);
			let cosYZ = cosY * cosZ;
			let sinYZ = sinY * sinZ;
			quat.x = sinX * cosYZ - cosX * sinYZ;
			quat.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
			quat.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
			quat.w = cosX * cosYZ + sinX * sinYZ;
			let x2 = quat.x * rot.w + quat.w * rot.x + quat.y * rot.z - quat.z * rot.y;
			let y2 = quat.w * rot.y - quat.x * rot.z + quat.y * rot.w + quat.z * rot.x;
			let z2 = quat.w * rot.z + quat.x * rot.y - quat.y * rot.x + quat.z * rot.w;
			let w2 = quat.w * rot.w - quat.x * rot.x - quat.y * rot.y - quat.z * rot.z;
			quat.x = x2;
			quat.y = y2;
			quat.z = z2;
			quat.w = w2;
			this.setRotationQuat(quat);
			let adt = timeState.clone();
			adt.dt = this.physicsAccumulator;
			let _g = 0;
			while(_g < pathedInteriors.length) {
				let pi = pathedInteriors[_g];
				++_g;
				pi.update(adt);
			}
		}
		this.physicsAccumulator += timeState.dt;
		if(this.controllable && this.level != null && !this.level.rewinding) {
			this.camera.update(timeState.currentAttemptTime,timeState.dt);
		}
		this.updatePowerupStates(timeState);
		if(this.level == null ? false : !this.level.isMultiplayer ? timeState.currentAttemptTime - this.megaMarbleEnableTime < 10 : net_Net.isHost ? this.megaMarbleUseTick > 0 && this.level.timeState.ticks - this.megaMarbleUseTick <= 312 : this.megaMarbleUseTick > 0 && this.serverTicks - this.megaMarbleUseTick <= 312) {
			this._marbleScale = this._defaultScale * 2.25;
		} else {
			this._marbleScale = this._defaultScale;
		}
		let s = this._renderScale * this._renderScale;
		if(s <= this._marbleScale * this._marbleScale) {
			s = 0.1;
		} else {
			s = 0.4;
		}
		s = timeState.dt / s * 2.302585124969482;
		s = 1.0 / (s * (s * 0.235 * s) + s + 1.0 + 0.48 * s * s);
		this._renderScale *= s;
		s = 1 - s;
		this._renderScale += s * this._marbleScale;
		let marbledts = js_Boot.__cast(this.children[0] , src_DtsObject);
		let v = this._renderScale;
		marbledts.scaleX = v;
		marbledts.flags |= 1;
		marbledts.scaleY = v;
		marbledts.flags |= 1;
		marbledts.scaleZ = v;
		marbledts.flags |= 1;
		marbledts.flags |= 1;
		this.updateFinishAnimation(timeState.dt);
		if(this.mode == src_Mode.Finish) {
			let x = this.finishAnimPosition.x;
			let y = this.finishAnimPosition.y;
			let z = this.finishAnimPosition.z;
			this.x = x;
			this.flags |= 1;
			this.y = y;
			this.flags |= 1;
			this.z = z;
			this.flags |= 1;
			this.flags |= 1;
			this.updatePowerupStates(timeState);
		}
		this.trailEmitter();
		if(this.bounceEmitDelay > 0) {
			this.bounceEmitDelay -= timeState.dt;
		}
		if(this.bounceEmitDelay < 0) {
			this.bounceEmitDelay = 0;
		}
	}
	recordMove() {
		let move = new net_Move();
		move.d = new h3d_Vector();
		move.d.x = src_Gamepad.getAxis(src_Settings.gamepadSettings.moveYAxis);
		move.d.y = -src_Gamepad.getAxis(src_Settings.gamepadSettings.moveXAxis);
		if(src_Settings.controlsSettings.moddedController) {
			let moveLen = Math.sqrt(move.d.x * move.d.x + move.d.y * move.d.y);
			if(moveLen > 0.00001) {
				let normalizedX = move.d.x / moveLen;
				let normalizedY = move.d.y / moveLen;
				let scaleFactor = Math.max(Math.abs(normalizedX),Math.abs(normalizedY));
				if(scaleFactor > 0) {
					move.d.x = normalizedX / scaleFactor * moveLen;
					move.d.y = normalizedY / scaleFactor * moveLen;
				}
			}
		}
		let tmp = src_MarbleGame.instance.world.playGui.chatCtrl;
		if(!(tmp != null ? tmp.chatFocused : null)) {
			if(hxd_Key.isDown(src_Settings.controlsSettings.forward)) {
				move.d.x -= 1;
			}
			if(hxd_Key.isDown(src_Settings.controlsSettings.backward)) {
				move.d.x += 1;
			}
			if(hxd_Key.isDown(src_Settings.controlsSettings.left)) {
				move.d.y += 1;
			}
			if(hxd_Key.isDown(src_Settings.controlsSettings.right)) {
				move.d.y -= 1;
			}
			let value = move.d.x;
			move.d.x = value < -1 ? -1 : value > 1 ? 1 : value;
			let value1 = move.d.y;
			move.d.y = value1 < -1 ? -1 : value1 > 1 ? 1 : value1;
			if(hxd_Key.isDown(src_Settings.controlsSettings.jump) || src_MarbleGame.instance.touchInput.jumpButton.pressed || src_Gamepad.isDown(src_Settings.gamepadSettings.jump)) {
				move.jump = true;
			}
			if(!src_Util.isTouchDevice() && hxd_Key.isDown(src_Settings.controlsSettings.powerup) || src_Util.isTouchDevice() && src_MarbleGame.instance.touchInput.powerupButton.pressed || src_Gamepad.isDown(src_Settings.gamepadSettings.powerup)) {
				move.powerup = true;
			}
			if(hxd_Key.isDown(src_Settings.controlsSettings.blast) || src_MarbleGame.instance.touchInput.blastbutton.pressed || src_Gamepad.isDown(src_Settings.gamepadSettings.blast)) {
				move.blast = true;
			}
			if(src_MarbleGame.instance.touchInput.movementInput.pressed) {
				move.d.y = -src_MarbleGame.instance.touchInput.movementInput.value.x;
				move.d.x = src_MarbleGame.instance.touchInput.movementInput.value.y;
			}
		}
		return move;
	}
	update(timeState,collisionWorld,pathedInteriors) {
		let move = null;
		if(this.controllable && !this.level.isWatching && !this.level.isReplayingMovement) {
			move = this.recordMove();
		}
		if(this.controllable && this.level.isWatching) {
			move = new net_Move();
			move.d = new h3d_Vector(0,0);
			if((this.level.replay.currentPlaybackFrame.marbleStateFlags & 2) != 0) {
				move.jump = true;
			}
			if((this.level.replay.currentPlaybackFrame.marbleStateFlags & 1) != 0) {
				move.powerup = true;
			}
			move.d = new h3d_Vector(this.level.replay.currentPlaybackFrame.marbleX,this.level.replay.currentPlaybackFrame.marbleY,0);
		} else if(this.controllable && this.level.isRecording) {
			this.level.replay.recordMarbleStateFlags(move.jump,move.powerup,false,false);
			this.level.replay.recordMarbleInput(move.d.x,move.d.y);
		}
		if(!this.controllable && (this.connection != null || this.level == null)) {
			move = new net_Move();
			move.d = new h3d_Vector(0,0);
		}
		this.physicsAccumulator += timeState.dt;
		this.playedSounds = [];
		while(this.physicsAccumulator > 0.032) {
			let adt = timeState.clone();
			adt.dt = 0.032;
			this.advancePhysics(adt,move,collisionWorld,pathedInteriors);
			this.physicsAccumulator -= 0.032;
		}
		if(this.oldPos != null && this.newPos != null) {
			let deltaT = this.physicsAccumulator / 0.032;
			let v1 = this.oldPos;
			let v2 = this.newPos;
			let a = v1.x;
			let x = a + (v2.x - a) * deltaT;
			let a1 = v1.y;
			let y = a1 + (v2.y - a1) * deltaT;
			let a2 = v1.z;
			let z = a2 + (v2.z - a2) * deltaT;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let renderPos_x = x;
			let renderPos_y = y;
			let renderPos_z = z;
			this.x = renderPos_x;
			this.flags |= 1;
			this.y = renderPos_y;
			this.flags |= 1;
			this.z = renderPos_z;
			this.flags |= 1;
			this.flags |= 1;
			let rot = this.getRotationQuat();
			let quat = new h3d_Quat();
			let ax = this.omega.x * timeState.dt;
			let ay = this.omega.y * timeState.dt;
			let az = this.omega.z * timeState.dt;
			let sinX = Math.sin(ax * 0.5);
			let cosX = Math.cos(ax * 0.5);
			let sinY = Math.sin(ay * 0.5);
			let cosY = Math.cos(ay * 0.5);
			let sinZ = Math.sin(az * 0.5);
			let cosZ = Math.cos(az * 0.5);
			let cosYZ = cosY * cosZ;
			let sinYZ = sinY * sinZ;
			quat.x = sinX * cosYZ - cosX * sinYZ;
			quat.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
			quat.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
			quat.w = cosX * cosYZ + sinX * sinYZ;
			let x2 = quat.x * rot.w + quat.w * rot.x + quat.y * rot.z - quat.z * rot.y;
			let y2 = quat.w * rot.y - quat.x * rot.z + quat.y * rot.w + quat.z * rot.x;
			let z2 = quat.w * rot.z + quat.x * rot.y - quat.y * rot.x + quat.z * rot.w;
			let w2 = quat.w * rot.w - quat.x * rot.x - quat.y * rot.y - quat.z * rot.z;
			quat.x = x2;
			quat.y = y2;
			quat.z = z2;
			quat.w = w2;
			this.setRotationQuat(quat);
			let adt = timeState.clone();
			adt.dt = this.physicsAccumulator;
			let _g = 0;
			while(_g < pathedInteriors.length) {
				let pi = pathedInteriors[_g];
				++_g;
				pi.update(adt);
			}
		}
		if(this.controllable) {
			if(!this.level.isWatching) {
				if(this.level.isRecording) {
					let tmp = this.level.replay;
					let _this = this.getAbsPos();
					let v = new h3d_Vector();
					let x = _this._41;
					let y = _this._42;
					let z = _this._43;
					let w = _this._44;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					v.x = x;
					v.y = y;
					v.z = z;
					v.w = w;
					tmp.recordMarbleState(v,this.velocity,this.getRotationQuat(),this.omega);
				}
			} else {
				let _this = this.level.replay.currentPlaybackFrame.marblePosition;
				let x = _this.x;
				let y = _this.y;
				let z = _this.z;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let expectedPos_x = x;
				let expectedPos_y = y;
				let expectedPos_z = z;
				let _this1 = this.level.replay.currentPlaybackFrame.marbleVelocity;
				let expectedVel = new h3d_Vector(_this1.x,_this1.y,_this1.z,_this1.w);
				let _this2 = this.level.replay.currentPlaybackFrame.marbleAngularVelocity;
				let expectedOmega = new h3d_Vector(_this2.x,_this2.y,_this2.z,_this2.w);
				this.x = expectedPos_x;
				this.flags |= 1;
				this.y = expectedPos_y;
				this.flags |= 1;
				this.z = expectedPos_z;
				this.flags |= 1;
				this.flags |= 1;
				let _this3 = this.level.replay.currentPlaybackFrame.marbleOrientation;
				let m = null;
				m = new h3d_Matrix();
				let xx = _this3.x * _this3.x;
				let xy = _this3.x * _this3.y;
				let xz = _this3.x * _this3.z;
				let xw = _this3.x * _this3.w;
				let yy = _this3.y * _this3.y;
				let yz = _this3.y * _this3.z;
				let yw = _this3.y * _this3.w;
				let zz = _this3.z * _this3.z;
				let zw = _this3.z * _this3.w;
				m._11 = 1 - 2 * (yy + zz);
				m._12 = 2 * (xy + zw);
				m._13 = 2 * (xz - yw);
				m._14 = 0;
				m._21 = 2 * (xy - zw);
				m._22 = 1 - 2 * (xx + zz);
				m._23 = 2 * (yz + xw);
				m._24 = 0;
				m._31 = 2 * (xz + yw);
				m._32 = 2 * (yz - xw);
				m._33 = 1 - 2 * (xx + yy);
				m._34 = 0;
				m._41 = 0;
				m._42 = 0;
				m._43 = 0;
				m._44 = 1;
				let tform = m;
				let x1 = expectedPos_x;
				let y1 = expectedPos_y;
				let z1 = expectedPos_z;
				if(expectedPos_z == null) {
					z1 = 0.;
				}
				if(expectedPos_y == null) {
					y1 = 0.;
				}
				if(expectedPos_x == null) {
					x1 = 0.;
				}
				let v_x = x1;
				let v_y = y1;
				let v_z = z1;
				tform._41 = v_x;
				tform._42 = v_y;
				tform._43 = v_z;
				tform._44 = 1.;
				this.collider.setTransform(tform);
				this.velocity = expectedVel;
				let _this4 = this.level.replay.currentPlaybackFrame.marbleOrientation;
				let rQuat = new h3d_Quat(_this4.x,_this4.y,_this4.z,_this4.w);
				this.setRotationQuat(rQuat);
				this.omega = expectedOmega;
			}
		}
		if(this.controllable && this.level != null && !this.level.rewinding) {
			this.camera.update(timeState.currentAttemptTime,timeState.dt);
		}
		this.updatePowerupStates(timeState);
		let s = this._renderScale * this._renderScale;
		if(s <= this._marbleScale * this._marbleScale) {
			s = 0.1;
		} else {
			s = 0.4;
		}
		s = timeState.dt / s * 2.302585124969482;
		s = 1.0 / (s * (s * 0.2349999994039536 * s) + s + 1.0 + 0.4799999892711639 * s * s);
		this._renderScale *= s;
		s = 1 - s;
		this._renderScale += s * this._marbleScale;
		let marbledts = js_Boot.__cast(this.children[0] , src_DtsObject);
		let v = this._renderScale;
		marbledts.scaleX = v;
		marbledts.flags |= 1;
		marbledts.scaleY = v;
		marbledts.flags |= 1;
		marbledts.scaleZ = v;
		marbledts.flags |= 1;
		marbledts.flags |= 1;
		if(this._radius != 0.675 && timeState.currentAttemptTime - this.megaMarbleEnableTime < 10) {
			this._prevRadius = this._radius;
			this._radius = 0.675;
			this.collider.radius = 0.675;
			this._marbleScale *= 2.25;
			let _this = this.currentUp;
			let x = _this.x * 5;
			let y = _this.y * 5;
			let z = _this.z * 5;
			let w = _this.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let boost_x = x;
			let boost_y = y;
			let boost_z = z;
			let boost_w = w;
			let _this1 = this.velocity;
			this.velocity = new h3d_Vector(_this1.x + boost_x,_this1.y + boost_y,_this1.z + boost_z,_this1.w + boost_w);
		} else if(timeState.currentAttemptTime - this.megaMarbleEnableTime > 10) {
			if(this._radius != this._prevRadius) {
				this._radius = this._prevRadius;
				this.collider.radius = this._radius;
				this._marbleScale = this._defaultScale;
				if(this.controllable) {
					src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/MegaShrink.wav",src_ResourceLoader.getAudio,this.soundResources),null,false);
				}
			}
		}
		this.updateFinishAnimation(timeState.dt);
		if(this.mode == src_Mode.Finish) {
			let x = this.finishAnimPosition.x;
			let y = this.finishAnimPosition.y;
			let z = this.finishAnimPosition.z;
			this.x = x;
			this.flags |= 1;
			this.y = y;
			this.flags |= 1;
			this.z = z;
			this.flags |= 1;
			this.flags |= 1;
			this.updatePowerupStates(timeState);
		}
		this.trailEmitter();
		if(this.bounceEmitDelay > 0) {
			this.bounceEmitDelay -= timeState.dt;
		}
		if(this.bounceEmitDelay < 0) {
			this.bounceEmitDelay = 0;
		}
	}
	updateFinishAnimation(dt) {
		if(this.mode == src_Mode.Finish) {
			let trans = this.level.endPad.getAbsPos();
			let v = new h3d_Vector();
			let x = trans._41;
			let y = trans._42;
			let z = trans._43;
			let w = trans._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			v.x = x;
			v.y = y;
			v.z = z;
			v.w = w;
			let around = v;
			let x1 = trans._31;
			let y1 = trans._32;
			let z1 = trans._33;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let forceEffect_x = x1;
			let forceEffect_y = y1;
			let forceEffect_z = z1;
			let k = forceEffect_x * forceEffect_x + forceEffect_y * forceEffect_y + forceEffect_z * forceEffect_z;
			if(k < 1e-10) {
				k = 0;
			} else {
				k = 1. / Math.sqrt(k);
			}
			forceEffect_x *= k;
			forceEffect_y *= k;
			forceEffect_z *= k;
			around = new h3d_Vector(v.x + forceEffect_x,v.y + forceEffect_y,v.z + forceEffect_z,v.w + 1.);
			let _this = this.finishAnimPosition;
			let x2 = _this.x - around.x;
			let y2 = _this.y - around.y;
			let z2 = _this.z - around.z;
			let w1 = _this.w - around.w;
			if(w1 == null) {
				w1 = 1.;
			}
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let offset_x = x2;
			let offset_y = y2;
			let offset_z = z2;
			let offset_w = w1;
			src_Marble.updateFinishAnimation_animTimeAccumulator += dt;
			while(src_Marble.updateFinishAnimation_animTimeAccumulator >= 0.016666666666666666) {
				src_Marble.updateFinishAnimation_animTimeAccumulator -= 0.016666666666666666;
				let _this = this.finishAnimVelocity;
				_this.x *= 0.95;
				_this.y *= 0.95;
				_this.z *= 0.95;
				let _this1 = this.finishAnimVelocity;
				let x = forceEffect_x * 0.2;
				let y = forceEffect_y * 0.2;
				let z = forceEffect_z * 0.2;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v_x = x;
				let v_y = y;
				let v_z = z;
				this.finishAnimVelocity = new h3d_Vector(_this1.x + v_x,_this1.y + v_y,_this1.z + v_z,_this1.w + 1.);
				let dist = Math.sqrt(offset_x * offset_x + offset_y * offset_y + offset_z * offset_z);
				let _this2 = this.finishAnimVelocity;
				let x1 = offset_x * 0.35;
				let y1 = offset_y * 0.35;
				let z1 = offset_z * 0.35;
				let w = offset_w;
				if(offset_w == null) {
					w = 1.;
				}
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let v_x1 = x1;
				let v_y1 = y1;
				let v_z1 = z1;
				let v_w = w;
				this.finishAnimVelocity = new h3d_Vector(_this2.x - v_x1,_this2.y - v_y1,_this2.z - v_z1,_this2.w - v_w);
				if(dist > 1.5) {
					let v = 1 / dist;
					let x = offset_x * v;
					let y = offset_y * v;
					let z = offset_z * v;
					let w = offset_w;
					if(offset_w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let outward_x = x;
					let outward_y = y;
					let outward_z = z;
					let outward_w = w;
					let v1 = this.finishAnimVelocity;
					let outforce = outward_x * v1.x + outward_y * v1.y + outward_z * v1.z;
					if(outforce > 0) {
						let _this = this.finishAnimVelocity;
						let v = outforce * 0.75;
						let x = outward_x * v;
						let y = outward_y * v;
						let z = outward_z * v;
						let w = outward_w;
						if(outward_w == null) {
							w = 1.;
						}
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let v_x = x;
						let v_y = y;
						let v_z = z;
						let v_w = w;
						this.finishAnimVelocity = new h3d_Vector(_this.x - v_x,_this.y - v_y,_this.z - v_z,_this.w - v_w);
						let v1 = outforce * 0.5;
						let noodles = new h3d_Vector(offset_x * v1,offset_y * v1,offset_z * v1,offset_w);
						let _this1 = this.finishAnimVelocity;
						noodles = new h3d_Vector(_this1.x - noodles.x,_this1.y - noodles.y,_this1.z - noodles.z,_this1.w - noodles.w);
						if(noodles.x * noodles.x + noodles.y * noodles.y + noodles.z * noodles.z <= 0.1) {
							let x = outward_y * forceEffect_z - outward_z * forceEffect_y;
							let y = outward_z * forceEffect_x - outward_x * forceEffect_z;
							let z = outward_x * forceEffect_y - outward_y * forceEffect_x;
							if(z == null) {
								z = 0.;
							}
							if(y == null) {
								y = 0.;
							}
							if(x == null) {
								x = 0.;
							}
							let cross_x = x;
							let cross_y = y;
							let cross_z = z;
							if(cross_x * cross_x + cross_y * cross_y + cross_z * cross_z <= 0.1) {
								let x = trans._11;
								let y = trans._12;
								let z = trans._13;
								if(z == null) {
									z = 0.;
								}
								if(y == null) {
									y = 0.;
								}
								if(x == null) {
									x = 0.;
								}
								let _this_x = x;
								let _this_y = y;
								let _this_z = z;
								let k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
								if(k < 1e-10) {
									k = 0;
								} else {
									k = 1. / Math.sqrt(k);
								}
								_this_x *= k;
								_this_y *= k;
								_this_z *= k;
								noodles = new h3d_Vector(_this_x,_this_y,_this_z,1.);
							} else {
								let k = cross_x * cross_x + cross_y * cross_y + cross_z * cross_z;
								if(k < 1e-10) {
									k = 0;
								} else {
									k = 1. / Math.sqrt(k);
								}
								noodles = new h3d_Vector(cross_x * k,cross_y * k,cross_z * k);
							}
						} else {
							let k = noodles.x * noodles.x + noodles.y * noodles.y + noodles.z * noodles.z;
							if(k < 1e-10) {
								k = 0;
							} else {
								k = 1. / Math.sqrt(k);
							}
							noodles.x *= k;
							noodles.y *= k;
							noodles.z *= k;
						}
						let _this2 = this.finishAnimVelocity;
						let v2 = outforce * 0.25;
						let x1 = noodles.x * v2;
						let y1 = noodles.y * v2;
						let z1 = noodles.z * v2;
						let w1 = noodles.w;
						if(w1 == null) {
							w1 = 1.;
						}
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let v_x1 = x1;
						let v_y1 = y1;
						let v_z1 = z1;
						let v_w1 = w1;
						this.finishAnimVelocity = new h3d_Vector(_this2.x + v_x1,_this2.y + v_y1,_this2.z + v_z1,_this2.w + v_w1);
					}
				}
				let x2 = Math.sin(this.finishAnimTime * 3);
				let y2 = Math.sin(this.finishAnimTime * 3 + 2.45);
				let z2 = Math.sin(this.finishAnimTime * 1.5 + 1.2);
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let addVel_x = x2;
				let addVel_y = y2;
				let addVel_z = z2;
				let _this3 = this.finishAnimVelocity;
				let x3 = addVel_x * 0.041666666666666664;
				let y3 = addVel_y * 0.041666666666666664;
				let z3 = addVel_z * 0.041666666666666664;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				let v_x2 = x3;
				let v_y2 = y3;
				let v_z2 = z3;
				this.finishAnimVelocity = new h3d_Vector(_this3.x + v_x2,_this3.y + v_y2,_this3.z + v_z2,_this3.w + 1.);
				let _this4 = this.finishAnimPosition;
				let _this5 = this.finishAnimVelocity;
				let x4 = _this5.x * 0.016666666666666666;
				let y4 = _this5.y * 0.016666666666666666;
				let z4 = _this5.z * 0.016666666666666666;
				let w1 = _this5.w;
				if(w1 == null) {
					w1 = 1.;
				}
				if(z4 == null) {
					z4 = 0.;
				}
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				let v_x3 = x4;
				let v_y3 = y4;
				let v_z3 = z4;
				let v_w1 = w1;
				let pos = new h3d_Vector(_this4.x + v_x3,_this4.y + v_y3,_this4.z + v_z3,_this4.w + v_w1);
				let _this6 = this.finishAnimPosition;
				let position = new h3d_Vector(_this6.x,_this6.y,_this6.z,_this6.w);
				let v = this.finishAnimPosition;
				let velocity = new h3d_Vector(pos.x - v.x,pos.y - v.y,pos.z - v.z,pos.w - v.w);
				let time = 1.0;
				let i = 0;
				let totalTime = 1.0;
				while(!(totalTime <= 1e-8)) {
					let tm = this.testMove(velocity,position,time,this._radius,true);
					if(!tm.found) {
						break;
					}
					++i;
					totalTime -= tm.t;
					time = totalTime;
					pos = tm.position;
					let norm = tm.lastContactNormal;
					let x = norm.x * 1.5;
					let y = norm.y * 1.5;
					let z = norm.z * 1.5;
					let w = norm.w;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let newAround_x = x;
					let newAround_y = y;
					let newAround_z = z;
					let newAround_w = w;
					let _this = this.finishAnimVelocity;
					let f = _this.x * norm.x + _this.y * norm.y + _this.z * norm.z;
					newAround_x *= f;
					newAround_y *= f;
					newAround_z *= f;
					let _this1 = this.finishAnimVelocity;
					this.finishAnimVelocity = new h3d_Vector(_this1.x - newAround_x,_this1.y - newAround_y,_this1.z - newAround_z,_this1.w - newAround_w);
					if(!(i < 4)) {
						break;
					}
				}
				this.finishAnimPosition = pos;
				this.finishAnimTime += 0.016666666666666666;
			}
		}
	}
	updatePowerupStates(timeState) {
		let _this = this.shadowVolume;
		let x = this.x;
		let y = this.y;
		let z = this.z;
		_this.x = x;
		_this.flags |= 1;
		_this.y = y;
		_this.flags |= 1;
		_this.z = z;
		_this.flags |= 1;
		_this.flags |= 1;
		let _this1 = this.shadowVolume;
		let v = this._renderScale;
		_this1.scaleX = v;
		_this1.flags |= 1;
		_this1.scaleY = v;
		_this1.flags |= 1;
		_this1.scaleZ = v;
		_this1.flags |= 1;
		_this1.flags |= 1;
		if(this.level == null) {
			return;
		}
		this.shadowVolume.setRotationQuat(this.level.getOrientationQuat(timeState.currentAttemptTime));
		if(!this.controllable && this.connection == null) {
			return;
		}
		if(this.level == null ? false : !this.level.isMultiplayer ? timeState.currentAttemptTime - this.helicopterEnableTime < 5 : net_Net.isHost ? this.helicopterUseTick > 0 && this.level.timeState.ticks - this.helicopterUseTick <= 156 : this.helicopterUseTick > 0 && this.serverTicks - this.helicopterUseTick <= 156) {
			let _this = this.helicopter;
			let x = this.x;
			let y = this.y;
			let z = this.z;
			_this.x = x;
			_this.flags |= 1;
			_this.y = y;
			_this.flags |= 1;
			_this.z = z;
			_this.flags |= 1;
			_this.flags |= 1;
			this.helicopter.setRotationQuat(this.level.getOrientationQuat(timeState.currentAttemptTime));
			if(this.controllable) {
				this.helicopterSound.set_pause(false);
			}
			let _this1 = this.helicopter;
			let v = this._renderScale;
			_this1.scaleX = v;
			_this1.flags |= 1;
			_this1.scaleY = v;
			_this1.flags |= 1;
			_this1.scaleZ = v;
			_this1.flags |= 1;
			_this1.flags |= 1;
		} else {
			let _this = this.helicopter;
			_this.x = 1e8;
			_this.flags |= 1;
			_this.y = 1e8;
			_this.flags |= 1;
			_this.z = 1e8;
			_this.flags |= 1;
			_this.flags |= 1;
			if(this.controllable) {
				this.helicopterSound.set_pause(true);
			}
		}
		if(this.blastUseTime > timeState.currentAttemptTime) {
			this.blastUseTime = Infinity;
			this.blastWave.doSequenceOnceBeginTime = 0;
		}
		if(timeState.currentAttemptTime - this.blastUseTime < this.blastWave.dts.sequences[0].duration) {
			let _this = this.blastWave;
			let x = this.x;
			let y = this.y;
			let z = this.z;
			_this.x = x;
			_this.flags |= 1;
			_this.y = y;
			_this.flags |= 1;
			_this.z = z;
			_this.flags |= 1;
			_this.flags |= 1;
			this.blastWave.setRotationQuat(this.level.getOrientationQuat(timeState.currentAttemptTime));
			let _this1 = this.blastWave;
			let v = this._renderScale;
			_this1.scaleX = v;
			_this1.flags |= 1;
			_this1.scaleY = v;
			_this1.flags |= 1;
			_this1.scaleZ = v;
			_this1.flags |= 1;
			_this1.flags |= 1;
		} else {
			let _this = this.blastWave;
			_this.x = 1e8;
			_this.flags |= 1;
			_this.y = 1e8;
			_this.flags |= 1;
			_this.z = 1e8;
			_this.flags |= 1;
			_this.flags |= 1;
		}
	}
	getMass() {
		if(this.level == null) {
			return 1;
		}
		if(this.level.timeState.currentAttemptTime - this.megaMarbleEnableTime < 10 || net_Net.isHost && this.megaMarbleUseTick > 0 && this.level.timeState.ticks - this.megaMarbleUseTick < 312 || net_Net.isClient && this.megaMarbleUseTick > 0 && this.serverTicks - this.megaMarbleUseTick < 312) {
			return 5;
		} else {
			return 1;
		}
	}
	useBlast(timeState) {
		if(this.level.isMultiplayer) {
			if(this.blastTicks < 234) {
				return false;
			}
			this.blastUseTick = net_Net.isHost ? timeState.ticks : this.serverTicks;
			if(!this.isNetUpdate) {
				this.netFlags |= 1;
			}
			let amount = this.blastTicks / 937;
			this.blastPerc = amount;
			let _this = this.currentUp;
			let v = amount * 8;
			let x = _this.x * v;
			let y = _this.y * v;
			let z = _this.z * v;
			let w = _this.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let _this_x = x;
			let _this_y = y;
			let _this_z = z;
			let _this_w = w;
			let v1 = 1 / this.getMass();
			let impulse = new h3d_Vector(_this_x * v1,_this_y * v1,_this_z * v1,_this_w);
			this.applyImpulse(impulse);
			if(!this.isNetUpdate) {
				if(this.controllable) {
					src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/use_blast.wav",src_ResourceLoader.getAudio,this.soundResources));
				}
				this.blastWave.doSequenceOnceBeginTime = this.level.timeState.timeSinceLoad;
				this.blastUseTime = this.level.timeState.currentAttemptTime;
			}
			this.blastTicks = 0;
			return true;
		} else {
			if(this.blastAmount < 0.25) {
				return false;
			}
			let _this = this.currentUp;
			let v = this.blastAmount * 8;
			let x = _this.x * v;
			let y = _this.y * v;
			let z = _this.z * v;
			let w = _this.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let _this_x = x;
			let _this_y = y;
			let _this_z = z;
			let _this_w = w;
			let v1 = 1 / this.getMass();
			let impulse = new h3d_Vector(_this_x * v1,_this_y * v1,_this_z * v1,_this_w);
			this.applyImpulse(impulse);
			if(this.controllable) {
				src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/use_blast.wav",src_ResourceLoader.getAudio,this.soundResources));
			}
			this.blastWave.doSequenceOnceBeginTime = this.level.timeState.timeSinceLoad;
			this.blastUseTime = this.level.timeState.currentAttemptTime;
			this.blastAmount = 0;
			return true;
		}
	}
	getForce(position,tick) {
		let retForce = new h3d_Vector();
		if(tick - this.blastUseTick >= 12) {
			return retForce;
		}
		let v = this.newPos;
		let x = position.x - v.x;
		let y = position.y - v.y;
		let z = position.z - v.z;
		let w = position.w - v.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let delta_x = x;
		let delta_y = y;
		let delta_z = z;
		let delta_w = w;
		let deltaLen = Math.sqrt(delta_x * delta_x + delta_y * delta_y + delta_z * delta_z);
		let maxDist = Math.max(this.blastRepulseDist,this.blastRepulseDist * this.blastPerc);
		let maxRepulse = this.maxBlastRepulse * this.blastPerc;
		if(deltaLen > maxDist) {
			return retForce;
		}
		if(deltaLen >= 0.05) {
			let dist = 0.0;
			if(deltaLen >= 1.0) {
				dist = (1.0 / deltaLen - 1.0 / maxDist) * maxRepulse;
			} else {
				dist = maxRepulse / deltaLen;
			}
			let x = delta_x * dist;
			let y = delta_y * dist;
			let z = delta_z * dist;
			let w = delta_w;
			if(delta_w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let v_x = x;
			let v_y = y;
			let v_z = z;
			let v_w = w;
			let x1 = retForce.x + v_x;
			let y1 = retForce.y + v_y;
			let z1 = retForce.z + v_z;
			let w1 = retForce.w + v_w;
			if(w1 == null) {
				w1 = 1.;
			}
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let v_x1 = x1;
			let v_y1 = y1;
			let v_z1 = z1;
			let v_w1 = w1;
			retForce.x = v_x1;
			retForce.y = v_y1;
			retForce.z = v_z1;
			retForce.w = v_w1;
		} else {
			let _this = this.currentUp;
			let x = _this.x * maxRepulse;
			let y = _this.y * maxRepulse;
			let z = _this.z * maxRepulse;
			let w = _this.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let v_x = x;
			let v_y = y;
			let v_z = z;
			let v_w = w;
			let x1 = retForce.x + v_x;
			let y1 = retForce.y + v_y;
			let z1 = retForce.z + v_z;
			let w1 = retForce.w + v_w;
			if(w1 == null) {
				w1 = 1.;
			}
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let v_x1 = x1;
			let v_y1 = y1;
			let v_z1 = z1;
			let v_w1 = w1;
			retForce.x = v_x1;
			retForce.y = v_y1;
			retForce.z = v_z1;
			retForce.w = v_w1;
		}
		return retForce;
	}
	applyImpulse(impulse,contactImpulse) {
		if(contactImpulse == null) {
			contactImpulse = false;
		}
		this.appliedImpulses.push({ impulse : impulse, contactImpulse : contactImpulse});
	}
	enableHelicopter(timeState) {
		if(this.level.isMultiplayer) {
			this.helicopterUseTick = net_Net.isHost ? timeState.ticks : this.serverTicks;
			if(!this.isNetUpdate) {
				this.netFlags |= 2;
			}
		} else {
			this.helicopterEnableTime = timeState.currentAttemptTime;
		}
	}
	enableMegaMarble(timeState) {
		if(this.level.isMultiplayer) {
			this.megaMarbleUseTick = net_Net.isHost ? timeState.ticks : this.serverTicks;
			if(!this.isNetUpdate) {
				this.netFlags |= 4;
			}
		} else {
			this.megaMarbleEnableTime = timeState.currentAttemptTime;
		}
	}
	setMode(mode) {
		this.mode = mode;
		if(mode == src_Mode.Finish) {
			let _this = this.collider.transform;
			let _this_x = 0.;
			let _this_y = 0.;
			let _this_z = 0.;
			let _this_w = 1.;
			let x = _this._41;
			let y = _this._42;
			let z = _this._43;
			let w = _this._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this_x = x;
			_this_y = y;
			_this_z = z;
			_this_w = w;
			this.finishAnimPosition = new h3d_Vector(_this_x,_this_y,_this_z,_this_w);
			let _this1 = this.velocity;
			this.finishAnimVelocity = new h3d_Vector(_this1.x,_this1.y,_this1.z,_this1.w);
			this.finishAnimTime = 0;
		}
	}
	setMarblePosition(x,y,z) {
		let _this = this.collider.transform;
		let x1 = x;
		let y1 = y;
		let z1 = z;
		if(z == null) {
			z1 = 0.;
		}
		if(y == null) {
			y1 = 0.;
		}
		if(x == null) {
			x1 = 0.;
		}
		let v_x = x1;
		let v_y = y1;
		let v_z = z1;
		_this._41 = v_x;
		_this._42 = v_y;
		_this._43 = v_z;
		_this._44 = 1.;
		this.x = x;
		this.flags |= 1;
		this.y = y;
		this.flags |= 1;
		this.z = z;
		this.flags |= 1;
		this.flags |= 1;
	}
	reset() {
		this.velocity = new h3d_Vector();
		this.collider.velocity = new h3d_Vector();
		this.omega = new h3d_Vector();
		this.helicopterEnableTime = -Infinity;
		this.megaMarbleEnableTime = -Infinity;
		this.blastUseTime = -Infinity;
		this.blastUseTick = 0;
		this.blastTicks = 0;
		this.helicopterUseTick = 0;
		this.megaMarbleUseTick = 0;
		this.netFlags = 31 | 32;
		this.lastContactNormal = new h3d_Vector(0,0,1);
		this.contactEntities = [];
		this._firstTick = true;
		this.finishAnimTime = 0;
		this.physicsAccumulator = 0;
		let _this = this.getRotationQuat();
		this.prevRot = new h3d_Quat(_this.x,_this.y,_this.z,_this.w);
		let _this1 = this.getAbsPos();
		let v = new h3d_Vector();
		let x = _this1._41;
		let y = _this1._42;
		let z = _this1._43;
		let w = _this1._44;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v.x = x;
		v.y = y;
		v.z = z;
		v.w = w;
		this.oldPos = v;
		let _this2 = this.getAbsPos();
		let v1 = new h3d_Vector();
		let x1 = _this2._41;
		let y1 = _this2._42;
		let z1 = _this2._43;
		let w1 = _this2._44;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		v1.x = x1;
		v1.y = y1;
		v1.z = z1;
		v1.w = w1;
		this.newPos = v1;
		this.posStore = new h3d_Vector();
		this.netSmoothOffset = new h3d_Vector();
		this.lastRenderPos = new h3d_Vector();
		this.netCorrected = false;
		this.serverUsePowerup = false;
		if(this._radius != this._prevRadius) {
			this._radius = this._prevRadius;
			this._marbleScale = this._renderScale = this._defaultScale;
			this.collider.radius = this._radius;
			let marbledts = js_Boot.__cast(this.children[0] , src_DtsObject);
			let v = this._prevRadius / 0.675;
			let v1 = marbledts.scaleX * v;
			marbledts.scaleX = v1;
			marbledts.flags |= 1;
			let v2 = marbledts.scaleY * v;
			marbledts.scaleY = v2;
			marbledts.flags |= 1;
			let v3 = marbledts.scaleZ * v;
			marbledts.scaleZ = v3;
			marbledts.flags |= 1;
			marbledts.flags |= 1;
		}
	}
	dispose() {
		if(this.rollSound != null) {
			this.rollSound.stop();
		}
		if(this.rollMegaSound != null) {
			this.rollMegaSound.stop();
		}
		if(this.slipSound != null) {
			this.slipSound.stop();
		}
		if(this.helicopterSound != null) {
			this.helicopterSound.stop();
		}
		let _this = this.shadowVolume;
		if(_this != null && _this.parent != null) {
			_this.parent.removeChild(_this);
		}
		let _this1 = this.helicopter;
		if(_this1 != null && _this1.parent != null) {
			_this1.parent.removeChild(_this1);
		}
		let _this2 = this.blastWave;
		if(_this2 != null && _this2.parent != null) {
			_this2.parent.removeChild(_this2);
		}
		super.dispose();
		this.removeChildren();
		this.camera = null;
		this.collider = null;
	}
}
$hxClasses["src.Marble"] = src_Marble;
src_Marble.__name__ = "src.Marble";
src_Marble.__super__ = src_GameObject;
Object.assign(src_Marble.prototype, {
	__class__: src_Marble
	,camera: null
	,controllable: null
	,collider: null
	,velocity: null
	,omega: null
	,level: null
	,collisionWorld: null
	,_radius: null
	,_prevRadius: null
	,_renderScale: null
	,_marbleScale: null
	,_defaultScale: null
	,_maxRollVelocity: null
	,_angularAcceleration: null
	,_jumpImpulse: null
	,_kineticFriction: null
	,_staticFriction: null
	,_brakingAcceleration: null
	,_gravity: null
	,_airAccel: null
	,_maxDotSlide: null
	,_minBounceVel: null
	,_minBounceSpeed: null
	,_minTrailVel: null
	,_bounceKineticFriction: null
	,minVelocityBounceSoft: null
	,bounceMinGain: null
	,maxBlastRepulse: null
	,blastRepulseDist: null
	,_bounceRestitution: null
	,_bounceYet: null
	,_slipAmount: null
	,_contactTime: null
	,_totalTime: null
	,physicsAccumulator: null
	,oldPos: null
	,newPos: null
	,prevRot: null
	,posStore: null
	,lastRenderPos: null
	,netSmoothOffset: null
	,netCorrected: null
	,contacts: null
	,bestContact: null
	,contactEntities: null
	,queuedContacts: null
	,appliedImpulses: null
	,heldPowerup: null
	,lastContactNormal: null
	,lastContactPosition: null
	,currentUp: null
	,outOfBounds: null
	,outOfBoundsTime: null
	,oobSchedule: null
	,helicopter: null
	,blastWave: null
	,helicopterEnableTime: null
	,megaMarbleEnableTime: null
	,blastUseTime: null
	,helicopterUseTick: null
	,megaMarbleUseTick: null
	,blastAmount: null
	,blastTicks: null
	,blastUseTick: null
	,blastPerc: null
	,bounceEmitDelay: null
	,bounceEmitterData: null
	,trailEmitterData: null
	,blastEmitterData: null
	,blastMaxEmitterData: null
	,rollSound: null
	,rollMegaSound: null
	,slipSound: null
	,helicopterSound: null
	,playedSounds: null
	,finishAnimVelocity: null
	,finishAnimPosition: null
	,finishAnimTime: null
	,mode: null
	,prevPos: null
	,isUltra: null
	,_firstTick: null
	,cubemapRenderer: null
	,shadowVolume: null
	,connection: null
	,moveMotionDir: null
	,lastMove: null
	,isNetUpdate: null
	,netFlags: null
	,serverTicks: null
	,recvServerTick: null
	,serverUsePowerup: null
});
class src_MarbleGame {
	constructor(scene2d,scene) {
		this.fpsLimitAccum = 0.0;
		this.limitingFps = false;
		this.fpsLimit = 60;
		this._exitingToMenu = false;
		this.consoleShown = false;
		this.toRecord = false;
		src_Console.instance.addEntry("log","Initializing the game...");
		src_MarbleGame.canvas = new gui_Canvas(scene2d,this);
		this.scene = scene;
		this.scene2d = scene2d;
		src_MarbleGame.instance = this;
		this.touchInput = new touch_TouchInput();
		if(src_Util.isTouchDevice()) {
			this.touchInput.registerTouchInput();
		}
		let _gthis = this;
		window.document.addEventListener("pointerlockchange",function() {
			if(!_gthis.paused && _gthis.world != null) {
				let tmp;
				if(_gthis.world.finishTime == null && _gthis.world._ready) {
					let tmp1 = _gthis.world.playGui.chatCtrl;
					tmp = !(tmp1 != null ? tmp1.chatFocused : null);
				} else {
					tmp = false;
				}
				if(tmp) {
					if(window.document.pointerLockElement != hxd_Window.getInstance().canvas) {
						_gthis.handlePauseGame();
						let jsCanvas = hxd_Window.getInstance().canvas;
						hxd_Window.getInstance().lockCallback = null;
						jsCanvas.focus();
					}
				}
			}
		});
		window.addEventListener("resize",function() {
			let canvasElement = window.document.getElementById("webgl");
			canvasElement.style.width = "100%";
			return canvasElement.style.height = "100%";
		});
		let canvas = window.document.getElementById("webgl");
		let pointercontainer = window.document.querySelector("#pointercontainer");
		pointercontainer.addEventListener("mousedown",function(e) {
			let buttonCode;
			let _g = e.button;
			switch(_g) {
			case 1:
				buttonCode = 2;
				break;
			case 2:
				buttonCode = 1;
				break;
			default:
				buttonCode = _g;
			}
			hxd_Key.keyPressed[buttonCode] = hxd_Timer.frameCount + 2;
			hxd_Window.getInstance().onMouseDown(e);
		});
		pointercontainer.addEventListener("mouseup",function(e) {
			let buttonCode;
			let _g = e.button;
			switch(_g) {
			case 1:
				buttonCode = 2;
				break;
			case 2:
				buttonCode = 1;
				break;
			default:
				buttonCode = _g;
			}
			hxd_Key.keyPressed[buttonCode] = -(hxd_Timer.frameCount + 2);
			hxd_Window.getInstance().onMouseUp(e);
		});
		canvas.addEventListener("mousedown",function(e) {
			let buttonCode;
			let _g = e.button;
			switch(_g) {
			case 1:
				buttonCode = 2;
				break;
			case 2:
				buttonCode = 1;
				break;
			default:
				buttonCode = _g;
			}
			return hxd_Key.keyPressed[buttonCode] = hxd_Timer.frameCount + 2;
		});
		canvas.addEventListener("mouseup",function(e) {
			let buttonCode;
			let _g = e.button;
			switch(_g) {
			case 1:
				buttonCode = 2;
				break;
			case 2:
				buttonCode = 1;
				break;
			default:
				buttonCode = _g;
			}
			return hxd_Key.keyPressed[buttonCode] = -(hxd_Timer.frameCount + 2);
		});
		pointercontainer.addEventListener("keypress",function(e) {
			hxd_Window.getInstance().onKeyPress(e);
		});
		pointercontainer.addEventListener("keydown",function(e) {
			let buttonCode = e.keyCode;
			hxd_Key.keyPressed[buttonCode] = hxd_Timer.frameCount + 2;
			hxd_Window.getInstance().onKeyDown(e);
		});
		pointercontainer.addEventListener("keyup",function(e) {
			let buttonCode = e.keyCode;
			hxd_Key.keyPressed[buttonCode] = -(hxd_Timer.frameCount + 2);
			hxd_Window.getInstance().onKeyUp(e);
		});
		window.addEventListener("keydown",function(e) {
			let buttonCode = e.keyCode;
			hxd_Key.keyPressed[buttonCode] = hxd_Timer.frameCount + 2;
			let tmp;
			if(_gthis.world != null) {
				let tmp1 = _gthis.world.playGui.chatCtrl;
				tmp = tmp1 != null ? tmp1.chatFocused : null;
			} else {
				tmp = false;
			}
			if(tmp) {
				hxd_Window.getInstance().onKeyDown(e);
			}
		});
		window.addEventListener("keyup",function(e) {
			let buttonCode = e.keyCode;
			hxd_Key.keyPressed[buttonCode] = -(hxd_Timer.frameCount + 2);
			let tmp;
			if(_gthis.world != null) {
				let tmp1 = _gthis.world.playGui.chatCtrl;
				tmp = tmp1 != null ? tmp1.chatFocused : null;
			} else {
				tmp = false;
			}
			if(tmp) {
				hxd_Window.getInstance().onKeyUp(e);
			}
		});
		window.addEventListener("keypress",function(e) {
			let tmp;
			if(_gthis.world != null) {
				let tmp1 = _gthis.world.playGui.chatCtrl;
				tmp = tmp1 != null ? tmp1.chatFocused : null;
			} else {
				tmp = false;
			}
			if(tmp) {
				hxd_Window.getInstance().onKeyPress(e);
			}
		});
		pointercontainer.addEventListener("touchstart",function(e) {
			hxd_Key.keyPressed[0] = hxd_Timer.frameCount + 2;
			scene2d.window.curMouseX = e.touches[0].clientX;
			return scene2d.window.curMouseY = e.touches[0].clientY;
		});
		pointercontainer.addEventListener("touchend",function(e) {
			return;
		});
		pointercontainer.addEventListener("touchmove",function(e) {
			scene2d.window.curMouseX = e.touches[0].clientX;
			return scene2d.window.curMouseY = e.touches[0].clientY;
		});
		window.addEventListener("contextmenu",function(e) {
			return e.preventDefault();
		});
		window.addEventListener("beforeunload",function(e) {
			if(_gthis.world != null) {
				e.preventDefault();
				e.returnValue = "";
			}
		});
		src_JSPlatform.initFullscreenEnforcer();
		hxd_Window.getInstance().removeEventTarget(hxd_Key.onEvent);
		scene2d.addEventListener(function(e) {
			_gthis._mouseWheelDelta = e.wheelDelta;
		});
		src_Analytics.trackSingle("game-start");
		src_Analytics.trackPlatformInfo();
	}
	update(dt) {
		net_Net.checkPacketTimeout(dt);
		if(this.limitingFps) {
			if((this.fpsLimitAccum += dt) < 1.0 / this.fpsLimit) {
				return;
			}
			this.fpsLimitAccum -= 1.0 / this.fpsLimit;
			dt = 1.0 / this.fpsLimit;
		}
		if(this.world != null) {
			if(this.world._disposed) {
				this.world = null;
				return;
			}
			src_Debug.update(dt);
			if(src_Util.isTouchDevice()) {
				this.touchInput.update();
			}
			if(!this.paused || this.world.isMultiplayer) {
				this.world.update(dt * src_Debug.timeScale);
			}
			if((hxd_Key.isPressed(27) && this.paused || src_Gamepad.isPressed(["start"])) && this.world.finishTime == null && this.world._ready) {
				this.handlePauseGame();
			}
		}
		if(this.world == null && this.previewWorld != null) {
			this.previewWorld.update(dt * src_Debug.timeScale);
		}
		if(src_MarbleGame.canvas != null) {
			if(hxd_Key.isPressed(192)) {
				this.consoleShown = !this.consoleShown;
				if(this.consoleShown) {
					if(this.console == null || this.console._disposed) {
						this.console = new gui_ConsoleDlg();
					}
					this.console.isShowing = true;
					src_MarbleGame.canvas.pushDialog(this.console);
				} else {
					this.console.isShowing = false;
					this.console.unfocus();
					src_MarbleGame.canvas.popDialog(this.console,false);
				}
			}
			let mouseState = { position : new h3d_Vector(src_MarbleGame.canvas.scene2d.get_mouseX(),src_MarbleGame.canvas.scene2d.get_mouseY()), wheel : this._mouseWheelDelta, handled : false};
			src_ProfilerUI.measure("canvasUpdate",1);
			src_MarbleGame.canvas.update(dt,mouseState);
		}
	}
	showPauseUI() {
		let _gthis = this;
		this.exitGameDlg = new gui_ExitGameDlg(function(sender) {
			src_MarbleGame.canvas.popDialog(_gthis.exitGameDlg);
			_gthis.getWorld();
			if(src_MarbleGame.instance.toRecord) {
				src_MarbleGame.canvas.pushDialog(new gui_ReplayNameDlg(function() {
					_gthis.quitMission();
				}));
			} else {
				_gthis.quitMission(net_Net.isClient);
				if(net_Net.isMP && net_Net.isClient) {
					net_Net.disconnect();
				}
			}
		},function(sender) {
			_gthis.world.playGui.setGuiVisibility(true);
			src_MarbleGame.canvas.popDialog(_gthis.exitGameDlg);
			_gthis.paused = !_gthis.paused;
			let w = _gthis.getWorld();
			w.setCursorLock(true);
		},function(sender) {
			_gthis.world.playGui.setGuiVisibility(true);
			src_MarbleGame.canvas.popDialog(_gthis.exitGameDlg);
			let w = _gthis.getWorld();
			w.restart(w.marble,true);
			_gthis.paused = !_gthis.paused;
		});
		src_MarbleGame.canvas.pushDialog(this.exitGameDlg);
	}
	handlePauseGame() {
		if(!this.paused && this.world._ready) {
			this.paused = true;
			src_Console.instance.addEntry("log","Game paused");
			this.world.setCursorLock(false);
			this.world.playGui.setGuiVisibility(false);
			src_AudioManager.playSound(src_ResourceLoader.getAudio("data/sound/level_text.wav").resource);
			this.showPauseUI();
		} else if(this.world._ready) {
			if(((src_MarbleGame.canvas.children[0]) instanceof gui_ExitGameDlg)) {
				this.paused = false;
				src_Console.instance.addEntry("log","Game unpaused");
				if(this.exitGameDlg != null) {
					src_MarbleGame.canvas.popDialog(this.exitGameDlg);
					this.world.playGui.setGuiVisibility(true);
				}
				this.world.setCursorLock(true);
			}
		}
	}
	getWorld() {
		return this.world;
	}
	quitMission(weDisconnecting) {
		if(weDisconnecting == null) {
			weDisconnecting = false;
		}
		src_Console.instance.addEntry("log","Quitting mission");
		if(net_Net.isMP) {
			if(net_Net.isHost) {
				net_NetCommands.endGame();
			}
		}
		let watching = this.world.isWatching;
		let lastMis = haxe_io_Path.withoutExtension(haxe_io_Path.withoutDirectory(this.world.mission.path));
		this.world.setCursorLock(false);
		if(!Object.prototype.hasOwnProperty.call(src_Settings.levelStatistics.h,this.world.mission.path)) {
			src_Settings.levelStatistics.h[this.world.mission.path] = { oobs : 0, respawns : 0, totalTime : 0, totalMPScore : 0};
		}
		let stats = src_Settings.levelStatistics.h[this.world.mission.path];
		src_Analytics.trackLevelQuit(this.world.mission.title,this.world.mission.path,this.world.timeState.timeSinceLoad * 1000 | 0,stats.oobs,stats.respawns,src_Settings.optionsSettings.rewindEnabled);
		this.world.dispose();
		this.world = null;
		this.paused = false;
		if(watching) {
			src_MarbleGame.canvas.setContent(Type.createInstance(this.replayExitGui,[]));
		} else if(net_Net.isMP) {
			if(weDisconnecting) {
				src_MarbleGame.instance.setPreviewMission(lastMis,function() {
					src_MarbleGame.canvas.setContent(new gui_MultiplayerGui());
				});
			} else {
				let lobby = new gui_MultiplayerLevelSelectGui(net_Net.isHost);
				src_MarbleGame.canvas.setContent(lobby);
			}
		} else {
			let pmg = new gui_LevelSelectGui(gui_LevelSelectGui.currentDifficultyStatic);
			if(this._exitingToMenu) {
				this._exitingToMenu = false;
				src_MarbleGame.canvas.setContent(new gui_MainMenuGui());
			} else {
				src_MarbleGame.canvas.setContent(pmg);
			}
		}
		src_Settings.save();
	}
	playMission(mission,multiplayer) {
		if(multiplayer == null) {
			multiplayer = false;
		}
		src_MarbleGame.canvas.clearContent();
		this.destroyPreviewWorld();
		if(this.world != null) {
			this.world.dispose();
		}
		src_Analytics.trackLevelPlay(mission.title,mission.path);
		this.world = new src_MarbleWorld(this.scene,this.scene2d,mission,!multiplayer,multiplayer);
		this.world.init();
	}
	watchMissionReplay(mission,replay,replayExitGui) {
		src_MarbleGame.canvas.clearContent();
		this.destroyPreviewWorld();
		src_Analytics.trackSingle("replay-watch");
		this.world = new src_MarbleWorld(this.scene,this.scene2d,mission);
		this.world.replay = replay;
		this.world.isWatching = true;
		this.world.init();
		this.replayExitGui = replayExitGui;
	}
	startPreviewWorld(onFinish) {
		this.previewWorld = new src_PreviewWorld(this.scene);
		this.previewWorld.init(onFinish);
	}
	destroyPreviewWorld() {
		this.previewWorld.destroyAllObjects();
	}
	setPreviewMission(misname,onFinish,physics) {
		if(physics == null) {
			physics = false;
		}
		src_Console.instance.addEntry("log","Setting preview mission " + misname);
		this.previewWorld.loadMission(misname,onFinish,physics);
	}
	render(e) {
		if(this.world != null && !this.world._disposed) {
			this.world.render(e);
		}
		if(this.previewWorld != null && this.world == null) {
			this.previewWorld.render(e);
		}
		src_MarbleGame.canvas.renderEngine(e);
	}
}
$hxClasses["src.MarbleGame"] = src_MarbleGame;
src_MarbleGame.__name__ = "src.MarbleGame";
Object.assign(src_MarbleGame.prototype, {
	__class__: src_MarbleGame
	,world: null
	,previewWorld: null
	,scene2d: null
	,scene: null
	,paused: null
	,toRecord: null
	,recordingName: null
	,exitGameDlg: null
	,touchInput: null
	,consoleShown: null
	,console: null
	,_mouseWheelDelta: null
	,_exitingToMenu: null
	,fpsLimit: null
	,limitingFps: null
	,fpsLimitAccum: null
	,replayExitGui: null
});
class src_Scheduler {
	constructor() {
		if(src_Scheduler._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
		this.scheduled = [];
	}
	tickSchedule(time) {
		let _g = 0;
		let _g1 = this.scheduled;
		while(_g < _g1.length) {
			let item = _g1[_g];
			++_g;
			if(time >= item.time) {
				HxOverrides.remove(this.scheduled,item);
				item.callBack();
			}
		}
	}
	schedule(time,callback,stringId) {
		let id = Math.random();
		this.scheduled.push({ id : id, stringId : "" + id, time : time, callBack : callback});
		return id;
	}
	cancel(id) {
		let _this = this.scheduled;
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this.length) {
			let v = _this[_g1];
			++_g1;
			if(v.id == id) {
				_g.push(v);
			}
		}
		if(_g.length == 0) {
			return;
		}
		HxOverrides.remove(this.scheduled,_g[0]);
	}
	clearSchedule() {
		this.scheduled = [];
	}
}
$hxClasses["src.Scheduler"] = src_Scheduler;
src_Scheduler.__name__ = "src.Scheduler";
Object.assign(src_Scheduler.prototype, {
	__class__: src_Scheduler
	,scheduled: null
});
class src_MarbleWorld extends src_Scheduler {
	constructor(scene,scene2d,mission,record,multiplayer) {
		src_Scheduler._hx_skip_constructor = true;
		super();
		src_Scheduler._hx_skip_constructor = false;
		this._hx_constructor(scene,scene2d,mission,record,multiplayer);
	}
	_hx_constructor(scene,scene2d,mission,record,multiplayer) {
		if(multiplayer == null) {
			multiplayer = false;
		}
		if(record == null) {
			record = false;
		}
		this.postInited = false;
		this.lock = false;
		this._instancesNeedsUpdate = false;
		this.soundResources = [];
		this.textureResources = [];
		this._resourcesLoaded = 0;
		this._loadingLength = 0;
		this._loadBegin = false;
		this._ready = false;
		this._disposed = false;
		this.resourceLoadFuncs = [];
		this.clientMarbles = new haxe_ds_ObjectMap();
		this.tickAccumulator = 0.0;
		this.multiplayerStarted = false;
		this.startTime = 1e8;
		this.isReplayingMovement = false;
		this.rewindUsed = false;
		this.rewinding = false;
		this.isRecording = false;
		this.isWatching = false;
		this.checkpointSequence = 0;
		this.cheeckpointBlast = 0;
		this.checkpointHeldPowerup = null;
		this.checkpointCollectedGems = new haxe_ds_ObjectMap();
		this.currentCheckpointTrigger = null;
		this.currentCheckpoint = null;
		this.newOrientationQuat = new h3d_Quat();
		this.oldOrientationQuat = new h3d_Quat();
		this.orientationChangeTime = -1e8;
		this.respawnPressedTime = -1e8;
		this.alertTextTimeState = -1e8;
		this.helpTextTimeState = -1e8;
		this.cursorLock = true;
		this.renderBlastAmount = 0;
		this.skipStartBugPauseTime = 0.0;
		this.gemCount = 0;
		this.totalGems = 0;
		this.bonusTime = 0;
		this.timeState = new src_TimeState();
		this.shapeOrTriggerInside = [];
		this.shapeImmunity = [];
		this.simGroups = new haxe_ds_ObjectMap();
		this.namedObjects = new haxe_ds_StringMap();
		this.gems = [];
		this.triggers = [];
		this.forceObjects = [];
		this.powerUps = [];
		this.dtsObjects = [];
		this.marbles = [];
		this.pathedInteriors = [];
		this.interiors = [];
		super._hx_constructor();
		this.scene = scene;
		this.scene2d = scene2d;
		this.mission = mission;
		this.game = mission.game.toLowerCase();
		this.gameMode = modes_GameModeFactory.getGameMode(this,mission.missionInfo.gamemode);
		this.replay = new src_Replay(mission.path,mission.isClaMission ? mission.id : 0);
		this.isRecording = record;
		this.rewindManager = new rewind_RewindManager(this);
		this.inputRecorder = new rewind_InputRecorder(this);
		this.isMultiplayer = multiplayer;
		if(this.isMultiplayer) {
			this.isRecording = false;
			this.isWatching = false;
			this.lastMoves = new net_MarbleUpdateQueue();
			this.predictions = new net_MarblePredictionStore();
			this.powerupPredictions = new net_PowerupPredictionStore();
			this.gemPredictions = new net_GemPredictionStore();
		}
		if(this.isMultiplayer && ((this.gameMode) instanceof modes_HuntMode) && net_Net.isHost) {
			let hunt = this.gameMode;
			let rng = Math.random() * 10000;
			net_NetCommands.setNetworkRNG(rng);
			hunt.rng.setSeed(rng);
			hunt.rng2.setSeed(rng);
		}
	}
	init() {
		this.initLoading();
	}
	initLoading() {
		src_Console.instance.addEntry("log","*** LOADING MISSION: " + this.mission.path);
		this.loadingGui = new gui_LoadingGui(this.mission.title,this.mission.game);
		src_MarbleGame.canvas.setContent(this.loadingGui);
		let _gthis = this;
		if(this.mission.isClaMission) {
			this.mission.download(function() {
				_gthis.loadBegin();
			});
		} else {
			this.loadBegin();
		}
	}
	loadBegin() {
		this._loadBegin = true;
		let scanMission = null;
		let _gthis = this;
		scanMission = function(simGroup) {
			let _g = 0;
			let _g1 = simGroup.elements;
			while(_g < _g1.length) {
				let element = _g1[_g];
				++_g;
				if([mis_MissionElementType.InteriorInstance,mis_MissionElementType.Item,mis_MissionElementType.PathedInterior,mis_MissionElementType.StaticShape,mis_MissionElementType.TSStatic,mis_MissionElementType.Sky].includes(element._type)) {
					if(element._type == mis_MissionElementType.StaticShape) {
						let so = element;
						if(so.datablock.toLowerCase() == "endpad") {
							_gthis.endPadElement = so;
						}
					}
					if(element._type == mis_MissionElementType.Sky) {
						_gthis.skyElement = element;
					}
				} else if(element._type == mis_MissionElementType.SimGroup) {
					scanMission(element);
				}
			}
		};
		this.mission.load();
		scanMission(this.mission.root);
		this.gameMode.missionScan(this.mission);
		this.resourceLoadFuncs.push(function(fwd) {
			_gthis.initScene(fwd);
		});
		if(this.isMultiplayer) {
			let client = net_Net.clientIdMap.iterator();
			while(client.hasNext()) {
				let client1 = client.next();
				this.resourceLoadFuncs.push(function(fwd) {
					_gthis.initMarble(client1,fwd);
				});
			}
		}
		this.resourceLoadFuncs.push(function(fwd) {
			_gthis.initMarble(null,fwd);
		});
		this.resourceLoadFuncs.push(function(fwd) {
			_gthis.addSimGroup(_gthis.mission.root);
			_gthis._loadingLength = _gthis.resourceLoadFuncs.length;
			fwd();
		});
		this._loadingLength = this.resourceLoadFuncs.length;
	}
	postInit() {
		this.collisionWorld.finalizeStaticGeometry();
		let _gthis = this;
		this.playGui.init(this.scene2d,this.mission.game.toLowerCase(),function() {
			_gthis.scene.addChild(_gthis.sky);
			if(_gthis.isMultiplayer) {
				if(net_Net.isHost) {
					_gthis.playGui.addPlayer(0,HxOverrides.substr(src_Settings.highscoreName,0,15),true);
				} else {
					_gthis.playGui.addPlayer(net_Net.clientId,HxOverrides.substr(src_Settings.highscoreName,0,15),true);
				}
				let client = net_Net.clientIdMap.iterator();
				while(client.hasNext()) {
					let client1 = client.next();
					_gthis.playGui.addPlayer(client1.id,HxOverrides.substr(client1.name,0,15),false);
				}
			}
			_gthis._ready = true;
			src_MarbleGame.canvas.clearContent();
			if(_gthis.endPad != null) {
				_gthis.endPad.generateCollider();
			}
			_gthis.playGui.formatGemCounter(_gthis.gemCount,_gthis.totalGems);
			src_Console.instance.addEntry("log","MISSION LOADED");
			_gthis.start();
		});
	}
	initScene(onFinish) {
		src_Console.instance.addEntry("log","Starting scene");
		this.collisionWorld = new collision_CollisionWorld();
		this.playGui = new gui_PlayGui();
		this.instanceManager = new src_InstanceManager(this.scene);
		this.particleManager = new src_ParticleManager(this);
		this.radar = new src_Radar(this,this.scene2d);
		this.radar.init();
		let _gthis = this;
		let worker = new src_ResourceLoaderWorker(function() {
			js_Boot.__cast(_gthis.scene.renderer , src_Renderer);
			let _g = 0;
			let _g1 = _gthis.mission.root.elements;
			while(_g < _g1.length) {
				let element = _g1[_g];
				++_g;
				if(element._type != mis_MissionElementType.Sun) {
					continue;
				}
				let sunElement = element;
				let directionalColor = mis_MisParser.parseVector4(sunElement.color);
				let ambientColor = mis_MisParser.parseVector4(sunElement.ambient);
				if(_gthis.game == "ultra") {
					ambientColor.x *= 1.18;
					ambientColor.y *= 1.06;
					ambientColor.z *= 0.95;
				}
				let sunDirection = mis_MisParser.parseVector3(sunElement.direction);
				sunDirection.x = -sunDirection.x;
				let ls = js_Boot.__cast(_gthis.scene.lightSystem , h3d_scene_fwd_LightSystem);
				let _this = ls.ambientLight;
				_this.x = ambientColor.x;
				_this.y = ambientColor.y;
				_this.z = ambientColor.z;
				_this.w = ambientColor.w;
				_gthis.ambient = ambientColor;
				let sunlight = new shaders_DirLight(sunDirection,_gthis.scene);
				sunlight.set_color(directionalColor);
				_gthis.dirLight = directionalColor;
				_gthis.dirLightDir = sunDirection;
			}
			onFinish();
		});
		let filestoload = ["particles/bubble.png","particles/saturn.png","particles/smoke.png","particles/spark.png","particles/star.png","particles/twirl.png"];
		let _g = 0;
		while(_g < filestoload.length) {
			let file = filestoload[_g];
			++_g;
			worker.loadFile(file);
		}
		let tmp = parseFloat(this.skyElement.visibledistance);
		this.scene.camera.zFar = tmp;
		this.sky = new src_Sky();
		this.sky.dmlPath = src_ResourceLoader.getProperFilepath(this.skyElement.materiallist);
		worker.addTask(function(fwd) {
			_gthis.sky.init(_gthis,fwd,_gthis.skyElement);
		});
		worker.run();
	}
	initMarble(client,onFinish) {
		src_Console.instance.addEntry("log","Initializing marble");
		let worker = new src_ResourceLoaderWorker(onFinish);
		let marblefiles = ["particles/star.png","particles/smoke.png","particles/burst.png","sound/rolling_hard.wav","sound/sliding.wav","sound/use_gyrocopter.wav","sound/bumperding1.wav","sound/jump.wav","sound/mega_roll.wav","sound/bouncehard1.wav","sound/bouncehard2.wav","sound/bouncehard3.wav","sound/bouncehard4.wav","sound/spawn_alternate.wav","sound/missinggems.wav","sound/level_text.wav","sound/level_finish.wav","sound/finish.wav","shapes/images/helicopter.dts","shapes/images/helicopter.jpg","shapes/items/gem.dts","shapes/items/gemshine.png","shapes/items/enviro1.jpg","shapes/hazards/null.png"];
		if(this.game == "ultra") {
			marblefiles.push("shapes/balls/marble20.normal.png");
			marblefiles.push("shapes/balls/marble18.normal.png");
			marblefiles.push("shapes/balls/marble01.normal.png");
			marblefiles.push("shapes/balls/marble02.normal.png");
			marblefiles.push("sound/use_blast.wav");
		}
		if(client == null) {
			marblefiles.push(StringTools.replace(src_Settings.optionsSettings.marbleModel,"data/",""));
		} else {
			let marbleDts = gui_MarblePickerGui.marbleData[client.marbleId].dts;
			marblefiles.push(StringTools.replace(marbleDts,"data/",""));
		}
		let gameModeFiles = this.gameMode.getPreloadFiles();
		let _g = 0;
		while(_g < marblefiles.length) {
			let file = marblefiles[_g];
			++_g;
			worker.loadFile(file);
		}
		let _g1 = 0;
		while(_g1 < gameModeFiles.length) {
			let file = gameModeFiles[_g1];
			++_g1;
			worker.loadFile(file);
		}
		let _gthis = this;
		worker.addTask(function(fwd) {
			let marble = new src_Marble();
			if(client == null) {
				marble.controllable = true;
			}
			_gthis.addMarble(marble,client,fwd);
		});
		worker.run();
	}
	start() {
		src_Console.instance.addEntry("log","LEVEL START");
		this.restart(this.marble,true);
		let _g = 0;
		let _g1 = this.interiors;
		while(_g < _g1.length) {
			let interior = _g1[_g];
			++_g;
			interior.onLevelStart();
		}
		let _g2 = 0;
		let _g3 = this.dtsObjects;
		while(_g2 < _g3.length) {
			let shape = _g3[_g2];
			++_g2;
			shape.onLevelStart();
		}
		if(this.isMultiplayer && net_Net.isClient) {
			net_NetCommands.clientIsReady(net_Net.clientId);
		}
		if(this.isMultiplayer && net_Net.isHost) {
			net_NetCommands.clientIsReady(-1);
			this.marbles.sort(function(a,b) {
				let aId = a.connection != null ? a.connection.id : 0;
				let bId = b.connection != null ? b.connection.id : 0;
				if(aId > bId) {
					return 1;
				} else if(aId < bId) {
					return -1;
				} else {
					return 0;
				}
			});
		}
		let cc = 0;
		let client = net_Net.clients.iterator();
		while(client.hasNext()) {
			client.next();
			++cc;
		}
		if(net_Net.isHost && cc == 0) {
			this.allClientsReady();
			net_Net.serverInfo.state = "PLAYING";
			net_MasterServerClient.instance.sendServerInfo(net_Net.serverInfo);
		}
	}
	addJoiningClient(cc,onAdded) {
		let _gthis = this;
		this.initMarble(cc,function() {
			let addedMarble = _gthis.clientMarbles.h[cc.__id__];
			_gthis.restart(addedMarble);
			_gthis.playGui.addPlayer(cc.id,cc.name,false);
			_gthis.playGui.redrawPlayerList();
			_gthis.marbles.sort(function(a,b) {
				let aId = a.connection == null ? net_Net.isHost ? 0 : net_Net.clientId : a.connection.id;
				let bId = b.connection == null ? net_Net.isHost ? 0 : net_Net.clientId : b.connection.id;
				if(aId > bId) {
					return 1;
				} else if(aId < bId) {
					return -1;
				} else {
					return 0;
				}
			});
			onAdded();
		});
	}
	addJoiningClientGhost(cc,onAdded) {
		let _gthis = this;
		this.initMarble(cc,function() {
			let addedMarble = _gthis.clientMarbles.h[cc.__id__];
			_gthis.restart(addedMarble);
			_gthis.playGui.addPlayer(cc.id,cc.name,false);
			_gthis.playGui.redrawPlayerList();
			_gthis.marbles.sort(function(a,b) {
				let aId = a.connection == null ? net_Net.isHost ? 0 : net_Net.clientId : a.connection.id;
				let bId = b.connection == null ? net_Net.isHost ? 0 : net_Net.clientId : b.connection.id;
				if(aId > bId) {
					return 1;
				} else if(aId < bId) {
					return -1;
				} else {
					return 0;
				}
			});
			onAdded();
		});
	}
	restartMultiplayerState() {
		if(this.isMultiplayer) {
			this.serverStartTicks = 0;
			this.startTime = 1e8;
			this.lastMoves = new net_MarbleUpdateQueue();
			this.predictions = new net_MarblePredictionStore();
			this.powerupPredictions = new net_PowerupPredictionStore();
			this.gemPredictions = new net_GemPredictionStore();
		}
	}
	restart(marble,full) {
		if(full == null) {
			full = false;
		}
		src_Console.instance.addEntry("log","LEVEL RESTART");
		if(!full && this.currentCheckpoint != null) {
			this.loadCheckpointState();
			return 0;
		}
		if(!full) {
			let respawnT = this.gameMode.getRespawnTransform(marble);
			if(respawnT != null) {
				this.respawn(marble,respawnT.position,respawnT.orientation,respawnT.up);
				return 0;
			}
		}
		if(!this.isWatching) {
			this.replay.clear();
		} else {
			this.replay.rewind();
		}
		this.rewindManager.clear();
		this.rewindUsed = false;
		this.timeState.currentAttemptTime = 0;
		this.timeState.gameplayClock = this.gameMode.getStartTime();
		this.timeState.ticks = 0;
		this.bonusTime = 0;
		this.marble.outOfBounds = false;
		this.marble.blastAmount = 0;
		this.renderBlastAmount = 0;
		this.marble.outOfBoundsTime = null;
		this.finishTime = null;
		this.skipStartBugPauseTime = 0.0;
		this.currentCheckpoint = null;
		this.currentCheckpointTrigger = null;
		this.checkpointCollectedGems.h = { __keys__ : { }};
		this.checkpointHeldPowerup = null;
		this.cheeckpointBlast = 0;
		this.checkpointSequence = 0;
		if(this.endPad != null) {
			this.endPad.inFinish = false;
		}
		if(this.totalGems > 0) {
			this.gemCount = 0;
			this.playGui.formatGemCounter(this.gemCount,this.totalGems);
		}
		this.radar.reset();
		if(full) {
			let tidx = 0;
			let _g = 0;
			let _g1 = this.dtsObjects;
			while(_g < _g1.length) {
				let dtss = _g1[_g];
				++_g;
				if(((dtss) instanceof shapes_Trapdoor)) {
					let trapdoor = dtss;
					if(!this.isWatching) {
						this.replay.recordTrapdoorState(trapdoor.lastContactTime - this.timeState.timeSinceLoad,trapdoor.lastDirection,trapdoor.lastCompletion);
					} else {
						let state = this.replay.getTrapdoorState(tidx);
						trapdoor.lastContactTime = state.lastContactTime + this.timeState.timeSinceLoad;
						trapdoor.lastDirection = state.lastDirection;
						trapdoor.lastCompletion = state.lastCompletion;
					}
					++tidx;
				}
			}
		}
		this.cancel(this.oobSchedule);
		this.cancel(this.marble.oobSchedule);
		let startquat = this.gameMode.getSpawnTransform();
		this.marble.setMarblePosition(startquat.position.x,startquat.position.y,startquat.position.z);
		this.marble.reset();
		let _this = startquat.orientation;
		let m = null;
		m = new h3d_Matrix();
		let xx = _this.x * _this.x;
		let xy = _this.x * _this.y;
		let xz = _this.x * _this.z;
		let xw = _this.x * _this.w;
		let yy = _this.y * _this.y;
		let yz = _this.y * _this.z;
		let yw = _this.y * _this.w;
		let zz = _this.z * _this.z;
		let zw = _this.z * _this.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		let euler = m.getEulerAngles();
		this.marble.camera.init(this);
		this.marble.camera.CameraYaw = euler.z + Math.PI / 2;
		this.marble.camera.CameraPitch = 0.45;
		this.marble.camera.nextCameraPitch = 0.45;
		this.marble.camera.nextCameraYaw = euler.z + Math.PI / 2;
		this.marble.camera.oob = false;
		this.marble.camera.finish = false;
		this.marble.setMode(src_Mode.Start);
		this.sky.set_follow(marble.camera);
		if(this.isMultiplayer) {
			let this1 = this.clientMarbles;
			let _g_keys = this1.keys();
			while(_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = this1.get(key);
				this.cancel(_g_value.oobSchedule);
				let marbleStartQuat = this.gameMode.getSpawnTransform();
				_g_value.setMarblePosition(marbleStartQuat.position.x,marbleStartQuat.position.y,marbleStartQuat.position.z);
				_g_value.reset();
				_g_value.setMode(src_Mode.Start);
			}
			this.playGui.resetPlayerScores();
		}
		let _this1 = this.mission.root.elements;
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this1.length) {
			let v = _this1[_g1];
			++_g1;
			if(v._type == mis_MissionElementType.ScriptObject && v._name == "MissionInfo") {
				_g.push(v);
			}
		}
		let missionInfo = _g[0];
		if(missionInfo.starthelptext != null) {
			this.displayHelp(missionInfo.starthelptext);
		}
		let _g2 = 0;
		let _g3 = this.dtsObjects;
		while(_g2 < _g3.length) {
			let shape = _g3[_g2];
			++_g2;
			shape.reset();
		}
		let _g4 = 0;
		let _g5 = this.interiors;
		while(_g4 < _g5.length) {
			let interior = _g5[_g4];
			++_g4;
			interior.reset();
		}
		this.setUp(this.marble,startquat.up,this.timeState,true);
		this.deselectPowerUp(this.marble);
		this.playGui.setCenterText("");
		if(marble == this.marble) {
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/spawn_alternate.wav",src_ResourceLoader.getAudio,this.soundResources));
		}
		if(!this.isMultiplayer) {
			this.gameMode.onRestart();
		}
		if(net_Net.isClient) {
			this.gameMode.onClientRestart();
		}
		return 0;
	}
	respawn(marble,respawnPos,respawnQuat,respawnUp) {
		marble.setMarblePosition(respawnPos.x,respawnPos.y,respawnPos.z);
		let _this = marble.velocity;
		_this.x = 0;
		_this.y = 0;
		_this.z = 0;
		_this.w = 1.;
		let _this1 = marble.omega;
		_this1.x = 0;
		_this1.y = 0;
		_this1.z = 0;
		_this1.w = 1.;
		src_Console.instance.addEntry("log","Respawn:");
		src_Console.instance.addEntry("log","Marble Position: " + respawnPos.x + " " + respawnPos.y + " " + respawnPos.z);
		src_Console.instance.addEntry("log","Marble Velocity: " + marble.velocity.x + " " + marble.velocity.y + " " + marble.velocity.z);
		src_Console.instance.addEntry("log","Marble Angular: " + marble.omega.x + " " + marble.omega.y + " " + marble.omega.z);
		let m = null;
		m = new h3d_Matrix();
		let xx = respawnQuat.x * respawnQuat.x;
		let xy = respawnQuat.x * respawnQuat.y;
		let xz = respawnQuat.x * respawnQuat.z;
		let xw = respawnQuat.x * respawnQuat.w;
		let yy = respawnQuat.y * respawnQuat.y;
		let yz = respawnQuat.y * respawnQuat.z;
		let yw = respawnQuat.y * respawnQuat.w;
		let zz = respawnQuat.z * respawnQuat.z;
		let zw = respawnQuat.z * respawnQuat.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		let euler = m.getEulerAngles();
		marble.camera.CameraYaw = euler.z + Math.PI / 2;
		marble.camera.CameraPitch = 0.45;
		marble.camera.nextCameraYaw = marble.camera.CameraYaw;
		marble.camera.nextCameraPitch = marble.camera.CameraPitch;
		marble.camera.oob = false;
		if(this.isMultiplayer) {
			marble.megaMarbleUseTick = 0;
			marble.helicopterUseTick = 0;
			marble.collider.radius = marble._radius = 0.3;
			marble.netFlags |= 22;
		} else {
			marble.helicopterEnableTime = -1e8;
			marble.megaMarbleEnableTime = -1e8;
			if(src_Settings.controlsSettings.oobRespawnKeyByPowerup) {
				let store = marble.heldPowerup;
				marble.heldPowerup = null;
				haxe_Timer.delay(function() {
					if(marble.heldPowerup == null) {
						marble.heldPowerup = store;
					}
				},500);
			}
		}
		if(this.isRecording) {
			this.replay.recordCameraState(marble.camera.CameraYaw,marble.camera.CameraPitch);
			this.replay.recordMarbleInput(0,0);
			this.replay.recordMarbleState(respawnPos,marble.velocity,marble.getRotationQuat(),marble.omega);
			this.replay.recordMarbleStateFlags(false,false,true,false);
		}
		let up = new h3d_Vector(0,0,1);
		let m1 = null;
		m1 = new h3d_Matrix();
		let xx1 = respawnQuat.x * respawnQuat.x;
		let xy1 = respawnQuat.x * respawnQuat.y;
		let xz1 = respawnQuat.x * respawnQuat.z;
		let xw1 = respawnQuat.x * respawnQuat.w;
		let yy1 = respawnQuat.y * respawnQuat.y;
		let yz1 = respawnQuat.y * respawnQuat.z;
		let yw1 = respawnQuat.y * respawnQuat.w;
		let zz1 = respawnQuat.z * respawnQuat.z;
		let zw1 = respawnQuat.z * respawnQuat.w;
		m1._11 = 1 - 2 * (yy1 + zz1);
		m1._12 = 2 * (xy1 + zw1);
		m1._13 = 2 * (xz1 - yw1);
		m1._14 = 0;
		m1._21 = 2 * (xy1 - zw1);
		m1._22 = 1 - 2 * (xx1 + zz1);
		m1._23 = 2 * (yz1 + xw1);
		m1._24 = 0;
		m1._31 = 2 * (xz1 + yw1);
		m1._32 = 2 * (yz1 - xw1);
		m1._33 = 1 - 2 * (xx1 + yy1);
		m1._34 = 0;
		m1._41 = 0;
		m1._42 = 0;
		m1._43 = 0;
		m1._44 = 1;
		let m2 = m1;
		let px = up.x * m2._11 + up.y * m2._21 + up.z * m2._31 + up.w * m2._41;
		let py = up.x * m2._12 + up.y * m2._22 + up.z * m2._32 + up.w * m2._42;
		let pz = up.x * m2._13 + up.y * m2._23 + up.z * m2._33 + up.w * m2._43;
		let pw = up.x * m2._14 + up.y * m2._24 + up.z * m2._34 + up.w * m2._44;
		up.x = px;
		up.y = py;
		up.z = pz;
		up.w = pw;
		this.setUp(marble,up,this.timeState,true);
		if(marble == this.marble) {
			this.playGui.setCenterText("");
		}
		if(!this.isMultiplayer) {
			this.clearSchedule();
		}
		marble.outOfBounds = false;
		this.gameMode.onRespawn(marble);
		if(marble == this.marble && !marble.isNetUpdate) {
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/spawn_alternate.wav",src_ResourceLoader.getAudio,this.soundResources));
		}
	}
	allClientsReady() {
		net_NetCommands.setStartTicks(this.timeState.ticks);
		this.gameMode.onRestart();
	}
	updateGameState() {
		if(this.marble.outOfBounds) {
			return;
		}
		if(!this.isMultiplayer) {
			if(this.timeState.currentAttemptTime < 0.5) {
				this.marble.setMode(src_Mode.Start);
			}
			if(this.timeState.currentAttemptTime >= 0.5 && this.timeState.currentAttemptTime < 3.5) {
				this.marble.setMode(src_Mode.Start);
			}
			if(this.timeState.currentAttemptTime + this.skipStartBugPauseTime >= 3.5 && this.finishTime == null) {
				this.marble.setMode(src_Mode.Play);
			}
		} else if(!this.multiplayerStarted && this.finishTime == null) {
			if(net_Net.isHost && this.timeState.timeSinceLoad >= this.startTime || net_Net.isClient && this.serverStartTicks != 0 && this.marble.serverTicks >= this.serverStartTicks + 109) {
				this.multiplayerStarted = true;
				this.marble.setMode(src_Mode.Play);
				let this1 = this.clientMarbles;
				let _g_keys = this1.keys();
				while(_g_keys.hasNext()) {
					let key = _g_keys.next();
					let _g_value = this1.get(key);
					_g_value.setMode(src_Mode.Play);
				}
				let huntMode = js_Boot.__cast(this.gameMode , modes_HuntMode);
				huntMode.freeSpawns();
			}
		}
	}
	addToSimgroup(obj,simGroup) {
		if(simGroup == null) {
			return;
		}
		if(this.simGroups.h.__keys__[simGroup.__id__] == null) {
			let v = [obj];
			this.simGroups.set(simGroup,v);
		} else {
			this.simGroups.h[simGroup.__id__].push(obj);
		}
	}
	addSimGroup(simGroup) {
		let _gthis = this;
		let _this = simGroup.elements;
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this.length) {
			let v = _this[_g1];
			++_g1;
			if(v._type == mis_MissionElementType.PathedInterior) {
				_g.push(v);
			}
		}
		if(_g.length != 0) {
			this.resourceLoadFuncs.push(function(fwd) {
				src_PathedInterior.createFromSimGroup(simGroup,_gthis,function(pathedInterior) {
					_gthis.addPathedInterior(pathedInterior,function() {
						if(pathedInterior == null) {
							fwd();
							src_Console.instance.addEntry("error","Unable to load pathed interior");
							return;
						}
						let _g = 0;
						let _g1 = pathedInterior.triggers;
						while(_g < _g1.length) {
							let trigger = _g1[_g];
							++_g;
							_gthis.triggers.push(trigger);
							_gthis.collisionWorld.addEntity(trigger.collider);
						}
						fwd();
					});
				});
			});
			return;
		}
		let _g2 = 0;
		let _g3 = simGroup.elements;
		while(_g2 < _g3.length) {
			let element = _g3[_g2];
			++_g2;
			switch(element._type._hx_index) {
			case 0:
				this.addSimGroup(element);
				break;
			case 5:
				this.resourceLoadFuncs.push(function(fwd) {
					_gthis.addInteriorFromMis(element,simGroup,fwd);
				});
				break;
			case 6:
				this.resourceLoadFuncs.push(function(fwd) {
					_gthis.addStaticShape(element,simGroup,fwd);
				});
				break;
			case 8:
				this.resourceLoadFuncs.push(function(fwd) {
					_gthis.addItem(element,simGroup,fwd);
				});
				break;
			case 12:
				this.resourceLoadFuncs.push(function(fwd) {
					_gthis.addTrigger(element,simGroup,fwd);
				});
				break;
			case 15:
				this.resourceLoadFuncs.push(function(fwd) {
					_gthis.addTSStatic(element,simGroup,fwd);
				});
				break;
			case 16:
				this.resourceLoadFuncs.push(function(fwd) {
					_gthis.addParticleEmitterNode(element);
					fwd();
				});
				break;
			default:
			}
		}
	}
	addInteriorFromMis(element,simGroup,onFinish) {
		let difPath = this.mission.getDifPath(element.interiorfile);
		if(difPath == "") {
			onFinish();
			return;
		}
		let interior = new src_InteriorObject();
		interior.interiorFile = difPath;
		let _gthis = this;
		this.addInterior(interior,function() {
			_gthis.addToSimgroup(interior,simGroup);
			let interiorPosition = mis_MisParser.parseVector3(element.position);
			interiorPosition.x = -interiorPosition.x;
			let interiorRotation = mis_MisParser.parseRotation(element.rotation);
			interiorRotation.x = -interiorRotation.x;
			interiorRotation.w = -interiorRotation.w;
			let interiorScale = mis_MisParser.parseVector3(element.scale);
			let hasCollision = interiorScale.x * interiorScale.y * interiorScale.z != 0;
			if(interiorScale.x == 0) {
				interiorScale.x = 0.0001;
			}
			if(interiorScale.y == 0) {
				interiorScale.y = 0.0001;
			}
			if(interiorScale.z == 0) {
				interiorScale.z = 0.0001;
			}
			let mat = h3d_Matrix.S(interiorScale.x,interiorScale.y,interiorScale.z);
			let tmp = new h3d_Matrix();
			let m = tmp;
			if(tmp == null) {
				m = new h3d_Matrix();
			}
			let xx = interiorRotation.x * interiorRotation.x;
			let xy = interiorRotation.x * interiorRotation.y;
			let xz = interiorRotation.x * interiorRotation.z;
			let xw = interiorRotation.x * interiorRotation.w;
			let yy = interiorRotation.y * interiorRotation.y;
			let yz = interiorRotation.y * interiorRotation.z;
			let yw = interiorRotation.y * interiorRotation.w;
			let zz = interiorRotation.z * interiorRotation.z;
			let zw = interiorRotation.z * interiorRotation.w;
			m._11 = 1 - 2 * (yy + zz);
			m._12 = 2 * (xy + zw);
			m._13 = 2 * (xz - yw);
			m._14 = 0;
			m._21 = 2 * (xy - zw);
			m._22 = 1 - 2 * (xx + zz);
			m._23 = 2 * (yz + xw);
			m._24 = 0;
			m._31 = 2 * (xz + yw);
			m._32 = 2 * (yz - xw);
			m._33 = 1 - 2 * (xx + yy);
			m._34 = 0;
			m._41 = 0;
			m._42 = 0;
			m._43 = 0;
			m._44 = 1;
			mat.multiply3x4(mat,tmp);
			let tmat = h3d_Matrix.T(interiorPosition.x,interiorPosition.y,interiorPosition.z);
			mat.multiply(mat,tmat);
			interior.isCollideable = hasCollision;
			interior.setTransform(mat);
			onFinish();
		});
	}
	addStaticShape(element,simGroup,onFinish) {
		let _gthis = this;
		let shape = null;
		let dataBlockLowerCase = element.datablock.toLowerCase();
		if(dataBlockLowerCase != "") {
			if(dataBlockLowerCase == "startpad") {
				shape = new shapes_StartPad();
			} else if(dataBlockLowerCase == "endpad") {
				shape = new shapes_EndPad();
				if(((element) instanceof mis_MissionElementStaticShape) && js_Boot.__cast(element , mis_MissionElementStaticShape) == this.endPadElement) {
					this.endPad = shape;
				}
			} else if(dataBlockLowerCase.startsWith("arrow")) {
				shape = new shapes_SignPlain(element);
			} else if(dataBlockLowerCase.startsWith("gemitem")) {
				shape = new shapes_Gem(element);
				this.totalGems++;
				this.gems.push(shape);
			} else if(dataBlockLowerCase == "superjumpitem") {
				shape = new shapes_SuperJump(element);
			} else if(dataBlockLowerCase.startsWith("signcaution")) {
				shape = new shapes_SignCaution(element);
			} else if(dataBlockLowerCase == "roundbumper") {
				shape = new shapes_RoundBumper();
			} else if(dataBlockLowerCase == "helicopteritem") {
				shape = new shapes_Helicopter(element);
			} else if(dataBlockLowerCase == "eastereggitem") {
				shape = new shapes_EasterEgg(element);
			} else if(dataBlockLowerCase == "checkpointshape") {
				shape = new shapes_Checkpoint(element);
			} else if(dataBlockLowerCase == "ductfan") {
				shape = new shapes_DuctFan();
			} else if(dataBlockLowerCase == "smallductfan") {
				shape = new shapes_SmallDuctFan();
			} else if(dataBlockLowerCase == "antigravityitem") {
				shape = new shapes_AntiGravity(element);
			} else if(dataBlockLowerCase == "norespawnantigravityitem") {
				shape = new shapes_AntiGravity(element,true);
			} else if(dataBlockLowerCase == "superspeeditem") {
				shape = new shapes_SuperSpeed(element);
			} else if(dataBlockLowerCase == "timetravelitem" || dataBlockLowerCase == "timepenaltyitem") {
				shape = new shapes_TimeTravel(element);
			} else if(dataBlockLowerCase == "blastitem") {
				shape = new shapes_Blast(element);
			} else if(dataBlockLowerCase == "megamarbleitem") {
				shape = new shapes_MegaMarble(element);
			} else if(dataBlockLowerCase == "trapdoor") {
				shape = new shapes_Trapdoor();
			} else if(["glass_3shape","glass_6shape","glass_9shape","glass_12shape","glass_15shape","glass_18shape"].includes(dataBlockLowerCase)) {
				shape = new shapes_Glass(element);
			} else if(["astrolabecloudsbeginnershape","astrolabecloudsintermediateshape","astrolabecloudsadvancedshape"].includes(dataBlockLowerCase)) {
				shape = new shapes_Sky(dataBlockLowerCase);
			} else if(dataBlockLowerCase == "astrolabeshape") {
				shape = new shapes_Astrolabe();
			} else {
				src_Console.instance.addEntry("error","Unknown item: " + element.datablock);
				onFinish();
				return;
			}
		}
		if(element._name != null && element._name != "") {
			this.namedObjects.h[element._name] = { obj : shape, elem : element};
		}
		let shapePosition = mis_MisParser.parseVector3(element.position);
		shapePosition.x = -shapePosition.x;
		let shapeRotation = mis_MisParser.parseRotation(element.rotation);
		shapeRotation.x = -shapeRotation.x;
		shapeRotation.w = -shapeRotation.w;
		let shapeScale = mis_MisParser.parseVector3(element.scale);
		if(shapeScale.x == 0) {
			shapeScale.x = 0.0001;
		}
		if(shapeScale.y == 0) {
			shapeScale.y = 0.0001;
		}
		if(shapeScale.z == 0) {
			shapeScale.z = 0.0001;
		}
		let mat = h3d_Matrix.S(shapeScale.x,shapeScale.y,shapeScale.z);
		let tmp = new h3d_Matrix();
		let m = tmp;
		if(tmp == null) {
			m = new h3d_Matrix();
		}
		let xx = shapeRotation.x * shapeRotation.x;
		let xy = shapeRotation.x * shapeRotation.y;
		let xz = shapeRotation.x * shapeRotation.z;
		let xw = shapeRotation.x * shapeRotation.w;
		let yy = shapeRotation.y * shapeRotation.y;
		let yz = shapeRotation.y * shapeRotation.z;
		let yw = shapeRotation.y * shapeRotation.w;
		let zz = shapeRotation.z * shapeRotation.z;
		let zw = shapeRotation.z * shapeRotation.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		mat.multiply3x4(mat,tmp);
		mat._41 = shapePosition.x;
		mat._42 = shapePosition.y;
		mat._43 = shapePosition.z;
		mat._44 = shapePosition.w;
		this.addDtsObject(shape,function() {
			_gthis.addToSimgroup(shape,simGroup);
			shape.setTransform(mat);
			onFinish();
		});
	}
	addItem(element,simGroup,onFinish) {
		let _gthis = this;
		let shape = null;
		let dataBlockLowerCase = element.datablock.toLowerCase();
		if(dataBlockLowerCase != "") {
			if(dataBlockLowerCase == "startpad") {
				shape = new shapes_StartPad();
			} else if(dataBlockLowerCase == "endpad") {
				shape = new shapes_EndPad();
				if(((element) instanceof mis_MissionElementStaticShape) && js_Boot.__cast(element , mis_MissionElementStaticShape) == this.endPadElement) {
					this.endPad = shape;
				}
			} else if(dataBlockLowerCase.startsWith("arrow")) {
				shape = new shapes_SignPlain(element);
			} else if(dataBlockLowerCase.startsWith("gemitem")) {
				shape = new shapes_Gem(element);
				this.totalGems++;
				this.gems.push(shape);
			} else if(dataBlockLowerCase == "superjumpitem") {
				shape = new shapes_SuperJump(element);
			} else if(dataBlockLowerCase.startsWith("signcaution")) {
				shape = new shapes_SignCaution(element);
			} else if(dataBlockLowerCase == "roundbumper") {
				shape = new shapes_RoundBumper();
			} else if(dataBlockLowerCase == "helicopteritem") {
				shape = new shapes_Helicopter(element);
			} else if(dataBlockLowerCase == "eastereggitem") {
				shape = new shapes_EasterEgg(element);
			} else if(dataBlockLowerCase == "checkpointshape") {
				shape = new shapes_Checkpoint(element);
			} else if(dataBlockLowerCase == "ductfan") {
				shape = new shapes_DuctFan();
			} else if(dataBlockLowerCase == "smallductfan") {
				shape = new shapes_SmallDuctFan();
			} else if(dataBlockLowerCase == "antigravityitem") {
				shape = new shapes_AntiGravity(element);
			} else if(dataBlockLowerCase == "norespawnantigravityitem") {
				shape = new shapes_AntiGravity(element,true);
			} else if(dataBlockLowerCase == "superspeeditem") {
				shape = new shapes_SuperSpeed(element);
			} else if(dataBlockLowerCase == "timetravelitem" || dataBlockLowerCase == "timepenaltyitem") {
				shape = new shapes_TimeTravel(element);
			} else if(dataBlockLowerCase == "blastitem") {
				shape = new shapes_Blast(element);
			} else if(dataBlockLowerCase == "megamarbleitem") {
				shape = new shapes_MegaMarble(element);
			} else if(dataBlockLowerCase == "trapdoor") {
				shape = new shapes_Trapdoor();
			} else if(["glass_3shape","glass_6shape","glass_9shape","glass_12shape","glass_15shape","glass_18shape"].includes(dataBlockLowerCase)) {
				shape = new shapes_Glass(element);
			} else if(["astrolabecloudsbeginnershape","astrolabecloudsintermediateshape","astrolabecloudsadvancedshape"].includes(dataBlockLowerCase)) {
				shape = new shapes_Sky(dataBlockLowerCase);
			} else if(dataBlockLowerCase == "astrolabeshape") {
				shape = new shapes_Astrolabe();
			} else {
				src_Console.instance.addEntry("error","Unknown item: " + element.datablock);
				onFinish();
				return;
			}
		}
		if(element._name != null && element._name != "") {
			this.namedObjects.h[element._name] = { obj : shape, elem : element};
		}
		let shapePosition = mis_MisParser.parseVector3(element.position);
		shapePosition.x = -shapePosition.x;
		let shapeRotation = mis_MisParser.parseRotation(element.rotation);
		shapeRotation.x = -shapeRotation.x;
		shapeRotation.w = -shapeRotation.w;
		let shapeScale = mis_MisParser.parseVector3(element.scale);
		if(shapeScale.x == 0) {
			shapeScale.x = 0.0001;
		}
		if(shapeScale.y == 0) {
			shapeScale.y = 0.0001;
		}
		if(shapeScale.z == 0) {
			shapeScale.z = 0.0001;
		}
		let mat = h3d_Matrix.S(shapeScale.x,shapeScale.y,shapeScale.z);
		let tmp = new h3d_Matrix();
		let m = tmp;
		if(tmp == null) {
			m = new h3d_Matrix();
		}
		let xx = shapeRotation.x * shapeRotation.x;
		let xy = shapeRotation.x * shapeRotation.y;
		let xz = shapeRotation.x * shapeRotation.z;
		let xw = shapeRotation.x * shapeRotation.w;
		let yy = shapeRotation.y * shapeRotation.y;
		let yz = shapeRotation.y * shapeRotation.z;
		let yw = shapeRotation.y * shapeRotation.w;
		let zz = shapeRotation.z * shapeRotation.z;
		let zw = shapeRotation.z * shapeRotation.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		mat.multiply3x4(mat,tmp);
		mat._41 = shapePosition.x;
		mat._42 = shapePosition.y;
		mat._43 = shapePosition.z;
		mat._44 = shapePosition.w;
		this.addDtsObject(shape,function() {
			_gthis.addToSimgroup(shape,simGroup);
			shape.setTransform(mat);
			onFinish();
		});
	}
	addTrigger(element,simGroup,onFinish) {
		let trigger = null;
		let datablockLowercase = element.datablock.toLowerCase();
		if(datablockLowercase == "outofboundstrigger") {
			trigger = new triggers_OutOfBoundsTrigger(element,this);
		} else if(datablockLowercase == "inboundstrigger") {
			trigger = new triggers_InBoundsTrigger(element,this);
		} else if(datablockLowercase == "helptrigger") {
			trigger = new triggers_HelpTrigger(element,this);
		} else if(datablockLowercase == "checkpointtrigger") {
			let chk = new triggers_CheckpointTrigger(element,this);
			trigger = chk;
			chk.simGroup = simGroup;
		} else {
			src_Console.instance.addEntry("error","Unknown trigger: " + element.datablock);
			onFinish();
			return;
		}
		let _gthis = this;
		trigger.init(function() {
			_gthis.triggers.push(trigger);
			_gthis.addToSimgroup(trigger,simGroup);
			_gthis.collisionWorld.addEntity(trigger.collider);
			onFinish();
		});
	}
	addTSStatic(element,simGroup,onFinish) {
		let shapeName = element.shapename;
		let index = shapeName.indexOf("data/");
		if(index == -1) {
			src_Console.instance.addEntry("error","Unable to parse shape path: " + shapeName);
			onFinish();
			return;
		}
		let dtsPath = "data/" + shapeName.substring(index + "data/".length);
		if(src_ResourceLoader.getProperFilepath(dtsPath) == "") {
			src_Console.instance.addEntry("error","DTS path does not exist: " + dtsPath);
			onFinish();
			return;
		}
		let tsShape = new src_DtsObject();
		tsShape.useInstancing = true;
		tsShape.dtsPath = dtsPath;
		tsShape.identifier = shapeName;
		tsShape.isCollideable = true;
		tsShape.showSequences = false;
		if(element._name != null && element._name != "") {
			this.namedObjects.h[element._name] = { obj : tsShape, elem : element};
		}
		let shapePosition = mis_MisParser.parseVector3(element.position);
		shapePosition.x = -shapePosition.x;
		let shapeRotation = mis_MisParser.parseRotation(element.rotation);
		shapeRotation.x = -shapeRotation.x;
		shapeRotation.w = -shapeRotation.w;
		let shapeScale = mis_MisParser.parseVector3(element.scale);
		if(shapeScale.x == 0) {
			shapeScale.x = 0.0001;
		}
		if(shapeScale.y == 0) {
			shapeScale.y = 0.0001;
		}
		if(shapeScale.z == 0) {
			shapeScale.z = 0.0001;
		}
		let mat = h3d_Matrix.S(shapeScale.x,shapeScale.y,shapeScale.z);
		let tmp = new h3d_Matrix();
		let m = tmp;
		if(tmp == null) {
			m = new h3d_Matrix();
		}
		let xx = shapeRotation.x * shapeRotation.x;
		let xy = shapeRotation.x * shapeRotation.y;
		let xz = shapeRotation.x * shapeRotation.z;
		let xw = shapeRotation.x * shapeRotation.w;
		let yy = shapeRotation.y * shapeRotation.y;
		let yz = shapeRotation.y * shapeRotation.z;
		let yw = shapeRotation.y * shapeRotation.w;
		let zz = shapeRotation.z * shapeRotation.z;
		let zw = shapeRotation.z * shapeRotation.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		mat.multiply3x4(mat,tmp);
		mat._41 = shapePosition.x;
		mat._42 = shapePosition.y;
		mat._43 = shapePosition.z;
		mat._44 = shapePosition.w;
		let _gthis = this;
		this.addDtsObject(tsShape,function() {
			_gthis.addToSimgroup(tsShape,simGroup);
			tsShape.setTransform(mat);
			onFinish();
		},true);
	}
	addParticleEmitterNode(element) {
		src_Console.instance.addEntry("warn","Unimplemented method addParticleEmitterNode");
	}
	addInterior(obj,onFinish) {
		this.interiors.push(obj);
		let _gthis = this;
		obj.init(this,function() {
			_gthis.collisionWorld.addEntity(obj.collider);
			if(obj.useInstancing) {
				_gthis.instanceManager.addObject(obj);
			} else {
				_gthis.scene.addChild(obj);
			}
			onFinish();
		});
	}
	addPathedInterior(obj,onFinish) {
		this.pathedInteriors.push(obj);
		let _gthis = this;
		obj.init(this,function() {
			_gthis.collisionWorld.addMovingEntity(obj.collider);
			if(obj.useInstancing) {
				_gthis.instanceManager.addObject(obj);
			} else {
				_gthis.scene.addChild(obj);
			}
			onFinish();
		});
	}
	addDtsObject(obj,onFinish,isTsStatic) {
		if(isTsStatic == null) {
			isTsStatic = false;
		}
		let _gthis = this;
		src_ResourceLoader.load(obj.dtsPath).entry.load(function() {
			let dtsFile = src_ResourceLoader.loadDts(obj.dtsPath);
			let texToLoad = obj.getPreloadMaterials(dtsFile.resource);
			let worker = new src_ResourceLoaderWorker(function() {
				obj.idInLevel = _gthis.dtsObjects.length;
				_gthis.dtsObjects.push(obj);
				if(((obj) instanceof shapes_PowerUp)) {
					let pw = obj;
					pw.netIndex = _gthis.powerUps.length;
					_gthis.powerUps.push(obj);
					if(net_Net.isClient) {
						_gthis.powerupPredictions.predictions.push(-Infinity);
					}
				}
				if(((obj) instanceof src_ForceObject)) {
					_gthis.forceObjects.push(obj);
				}
				obj.isTSStatic = isTsStatic;
				obj.init(_gthis,function() {
					obj.update(_gthis.timeState);
					if(obj.useInstancing) {
						_gthis.instanceManager.addObject(obj);
					} else {
						_gthis.scene.addChild(obj);
					}
					let _g = 0;
					let _g1 = obj.colliders;
					while(_g < _g1.length) {
						let collider = _g1[_g];
						++_g;
						if(collider != null) {
							_gthis.collisionWorld.addEntity(collider);
						}
					}
					if(obj.isBoundingBoxCollideable) {
						_gthis.collisionWorld.addEntity(obj.boundingCollider);
					}
					onFinish();
				});
			});
			let _g = 0;
			while(_g < texToLoad.length) {
				let texPath = texToLoad[_g];
				++_g;
				worker.loadFile(texPath);
			}
			worker.run();
		});
	}
	addMarble(marble,client,onFinish) {
		marble.level = this;
		let _gthis = this;
		if(marble.controllable) {
			marble.init(this,client,function() {
				_gthis.marbles.push(marble);
				_gthis.scene.addChild(marble.camera);
				_gthis.marble = marble;
				_gthis.sky.set_follow(marble.camera);
				_gthis.collisionWorld.addMovingEntity(marble.collider);
				_gthis.collisionWorld.addMarbleEntity(marble.collider);
				_gthis.scene.addChild(marble);
				onFinish();
			});
		} else {
			marble.init(this,client,function() {
				_gthis.marbles.push(marble);
				marble.collisionWorld = _gthis.collisionWorld;
				_gthis.collisionWorld.addMovingEntity(marble.collider);
				_gthis.collisionWorld.addMarbleEntity(marble.collider);
				_gthis.scene.addChild(marble);
				if(client != null) {
					_gthis.clientMarbles.set(client,marble);
				}
				onFinish();
			});
		}
	}
	performRestart() {
		this.respawnPressedTime = this.timeState.timeSinceLoad;
		this.restart(this.marble);
		if(!this.isWatching) {
			src_Settings.playStatistics.respawns++;
			if(!Object.prototype.hasOwnProperty.call(src_Settings.levelStatistics.h,this.mission.path)) {
				src_Settings.levelStatistics.h[this.mission.path] = { oobs : 0, respawns : 1, totalTime : 0, totalMPScore : 0};
			} else {
				let fh = src_Settings.levelStatistics.h[this.mission.path];
				fh.respawns++;
			}
		}
	}
	getWorldStateForClientJoin() {
		let packets = [];
		let bs = new net_OutputBitStream();
		bs.writeByte(8);
		let packet = new net_GemSpawnPacket();
		let hunt = js_Boot.__cast(this.gameMode , modes_HuntMode);
		if(hunt.activeGemSpawnGroup != null) {
			let activeGemIds = [];
			let _g = 0;
			let _g1 = hunt.activeGemSpawnGroup;
			while(_g < _g1.length) {
				let gemId = _g1[_g];
				++_g;
				if(hunt.gemSpawnPoints[gemId].gem != null && !hunt.gemSpawnPoints[gemId].gem.pickedUp) {
					activeGemIds.push(gemId);
				}
			}
			packet.gemIds = activeGemIds;
			packet.serialize(bs);
			packets.push(bs.getBytes());
		}
		let _g = 0;
		let _g1 = this.marbles;
		while(_g < _g1.length) {
			let marb = _g1[_g];
			++_g;
			let oldFlags = marb.netFlags;
			marb.netFlags = 31 | 32;
			let innerMove = marb.lastMove;
			if(innerMove == null) {
				innerMove = new net_Move();
				innerMove.d = new h3d_Vector(0,0);
			}
			let motionDir = marb.moveMotionDir;
			if(motionDir == null) {
				motionDir = marb.getMarbleAxis()[1];
			}
			let move = new net_NetMove(innerMove,motionDir,this.timeState,this.timeState.ticks,65535);
			packets.push(marb.packUpdate(move,this.timeState));
			marb.netFlags = oldFlags;
		}
		let _g2 = 0;
		let _g3 = this.powerUps;
		while(_g2 < _g3.length) {
			let powerup = _g3[_g2];
			++_g2;
			if(powerup.currentOpacity != 1.0) {
				if(powerup.pickupClient != -1) {
					let b = new net_OutputBitStream();
					b.writeByte(7);
					let pickupPacket = new net_PowerupPickupPacket();
					pickupPacket.clientId = powerup.pickupClient;
					pickupPacket.serverTicks = powerup.pickupTicks;
					pickupPacket.powerupItemId = powerup.netIndex;
					b.writeByte(pickupPacket.clientId);
					b.writeUInt16(pickupPacket.serverTicks);
					b.writeInt(pickupPacket.powerupItemId,10);
					packets.push(b.getBytes());
				}
			}
		}
		let b = new net_OutputBitStream();
		b.writeByte(11);
		let sbPacket = new net_ScoreboardPacket();
		let _g4 = 0;
		let _g5 = this.playGui.playerList;
		while(_g4 < _g5.length) {
			let player = _g5[_g4];
			++_g4;
			sbPacket.scoreBoard.h[player.id] = player.score;
		}
		let keycount = 0;
		let this1 = sbPacket.scoreBoard;
		let _g_keys = this1.keys();
		while(_g_keys.hasNext()) {
			let key = _g_keys.next();
			this1.get(key);
			++keycount;
		}
		b.writeInt(keycount,4);
		let this2 = sbPacket.scoreBoard;
		let _g_keys1 = this2.keys();
		while(_g_keys1.hasNext()) {
			let key = _g_keys1.next();
			let _g_value = this2.get(key);
			b.writeInt(key,6);
			b.writeInt(_g_value,10);
		}
		packets.push(b.getBytes());
		return packets;
	}
	applyReceivedMoves() {
		let needsPrediction = 0;
		if(!this.lastMoves.ourMoveApplied) {
			let ourMove = this.lastMoves.myMarbleUpdate;
			if(ourMove != null) {
				let ourMoveStruct = net_Net.clientConnection.moveManager.acknowledgeMove(ourMove.move,this.timeState);
				this.lastMoves.ourMoveApplied = true;
				let this1 = this.lastMoves.otherMarbleUpdates;
				let _g_keys = this1.keys();
				while(_g_keys.hasNext()) {
					let key = _g_keys.next();
					let _g_value = this1.get(key);
					let lastMove = null;
					while(_g_value.packets.length > 0) {
						let p = _g_value.packets[0];
						if(p.serverTicks <= ourMove.serverTicks) {
							lastMove = _g_value.packets.shift();
						} else {
							break;
						}
					}
					if(lastMove != null) {
						let clientMarble = this.clientMarbles.h[net_Net.clientIdMap.h[key].__id__];
						if(clientMarble != null) {
							if(ourMove.serverTicks == lastMove.serverTicks) {
								if(ourMoveStruct != null) {
									let otherPred = this.predictions.retrieveState(clientMarble,ourMoveStruct.timeState.ticks);
									if(otherPred != null) {
										let _this = otherPred.position;
										let v = lastMove.position;
										let x = _this.x - v.x;
										let y = _this.y - v.y;
										let z = _this.z - v.z;
										if(z == null) {
											z = 0.;
										}
										if(y == null) {
											y = 0.;
										}
										if(x == null) {
											x = 0.;
										}
										let _this_x = x;
										let _this_y = y;
										let _this_z = z;
										let subs = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
										if(lastMove.netFlags != 0) {
											++subs;
										}
										if(subs > 0.01) {
											clientMarble.unpackUpdate(lastMove);
											needsPrediction |= 1 << key;
											_g_value.packets.splice(0,0,lastMove);
											this.predictions.clearStatesAfterTick(this.clientMarbles.h[net_Net.clientIdMap.h[key].__id__],ourMoveStruct.timeState.ticks);
										}
									} else {
										clientMarble.unpackUpdate(lastMove);
										needsPrediction |= 1 << key;
										_g_value.packets.splice(0,0,lastMove);
										this.predictions.clearStatesAfterTick(clientMarble,ourMoveStruct.timeState.ticks);
									}
								} else {
									clientMarble.unpackUpdate(lastMove);
									needsPrediction |= 1 << key;
									_g_value.packets.splice(0,0,lastMove);
								}
							}
						}
					}
				}
				if(ourMoveStruct != null) {
					let ourPred = this.predictions.retrieveState(this.marble,ourMoveStruct.timeState.ticks);
					if(ourPred != null) {
						let _this = ourPred.position;
						let v = ourMove.position;
						let x = _this.x - v.x;
						let y = _this.y - v.y;
						let z = _this.z - v.z;
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let _this_x = x;
						let _this_y = y;
						let _this_z = z;
						let subs = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
						if(ourMove.netFlags != 0) {
							++subs;
						}
						if(subs > 0.01) {
							this.marble.unpackUpdate(ourMove);
							needsPrediction |= 1 << net_Net.clientId;
							this.predictions.clearStatesAfterTick(this.marble,ourMoveStruct.timeState.ticks);
						}
					} else {
						this.marble.unpackUpdate(ourMove);
						needsPrediction |= 1 << net_Net.clientId;
						this.predictions.clearStatesAfterTick(this.marble,ourMoveStruct.timeState.ticks);
					}
				} else {
					this.marble.unpackUpdate(ourMove);
					needsPrediction |= 1 << net_Net.clientId;
				}
			}
		}
		return needsPrediction;
	}
	applyClientPrediction(marbleNeedsPrediction) {
		let ourLastMove = this.lastMoves.myMarbleUpdate;
		if(ourLastMove == null || marbleNeedsPrediction == 0) {
			return -1;
		}
		let ourLastMoveTime = ourLastMove.serverTicks;
		let ourQueuedMoves = net_Net.clientConnection.moveManager.queuedMoves.slice();
		let qm = ourQueuedMoves[0];
		let advanceTimeState = qm != null ? qm.timeState.clone() : this.timeState.clone();
		advanceTimeState.dt = 0.032;
		advanceTimeState.ticks = ourLastMoveTime;
		let _g = 0;
		let _g1 = this.marble.level.powerUps;
		while(_g < _g1.length) {
			let pw = _g1[_g];
			++_g;
			if(pw.pickupClient != -1 && (marbleNeedsPrediction & 1 << pw.pickupClient) > 0) {
				pw.lastPickUpTime = this.powerupPredictions.predictions[pw.netIndex];
			}
		}
		let huntMode = this.gameMode;
		if(huntMode.activeGemSpawnGroup != null) {
			let _g = 0;
			let _g1 = huntMode.activeGemSpawnGroup;
			while(_g < _g1.length) {
				let activeGem = _g1[_g];
				++_g;
				let g = huntMode.gemSpawnPoints[activeGem].gem;
				if(g != null && g.pickUpClient != -1 && (marbleNeedsPrediction & 1 << g.pickUpClient) > 0) {
					let status = this.gemPredictions.predictions[activeGem];
					let gemSpawn = huntMode.gemSpawnPoints[activeGem];
					if(gemSpawn.gem != null) {
						gemSpawn.gem.pickedUp = status;
						gemSpawn.gem.setHide(status);
						gemSpawn.gemBeam.setHide(status);
						if(status) {
							huntMode.activeGems.push(gemSpawn.gem);
						} else {
							HxOverrides.remove(huntMode.activeGems,gemSpawn.gem);
						}
					} else {
						throw new haxe_Exception("Setting gem status for non existent gem!");
					}
				}
			}
		}
		this.marble.isNetUpdate = true;
		let marblesToTick = new haxe_ds_IntMap();
		let this1 = this.lastMoves.otherMarbleUpdates;
		let _g_keys = this1.keys();
		while(_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = this1.get(key);
			if((marbleNeedsPrediction & 1 << key) > 0 && _g_value.packets.length > 0) {
				let m = _g_value.packets[0];
				let marbleToUpdate = this.clientMarbles.h[net_Net.clientIdMap.h[key].__id__];
				if(marbleToUpdate.newPos == null) {
					continue;
				}
				m.calculationTicks = ourQueuedMoves.length;
				let _this = marbleToUpdate.posStore;
				let v = marbleToUpdate.newPos;
				_this.x = v.x;
				_this.y = v.y;
				_this.z = v.z;
				_this.w = v.w;
				marbleToUpdate.netCorrected = true;
				marblesToTick.h[key] = m;
				_g_value.packets.shift();
			}
		}
		let centre = this.marble.newPos;
		if(src_Debug.drawBounds) {
			src_Debug._spheres.push({ position : new h3d_Vector(centre.x,centre.y,centre.z,centre.w), radius : this.marble._radius, lifetime : 0.032});
		}
		let _this = this.marble.posStore;
		let v = this.marble.newPos;
		_this.x = v.x;
		_this.y = v.y;
		_this.z = v.z;
		_this.w = v.w;
		this.marble.netCorrected = true;
		let _g2 = 0;
		while(_g2 < ourQueuedMoves.length) {
			let move = ourQueuedMoves[_g2];
			++_g2;
			let m = move.move;
			let centre = this.marble.newPos;
			if(src_Debug.drawBounds) {
				src_Debug._spheres.push({ position : new h3d_Vector(centre.x,centre.y,centre.z,centre.w), radius : this.marble._radius, lifetime : 0.032});
			}
			if((marbleNeedsPrediction & 1 << net_Net.clientId) > 0) {
				this.marble.moveMotionDir = move.motionDir;
				this.marble.advancePhysics(advanceTimeState,m,this.collisionWorld,this.pathedInteriors);
				this.predictions.storeState(this.marble,move.timeState.ticks);
			}
			let map = marblesToTick;
			let _g_keys = map.keys();
			while(_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = map.get(key);
				if(_g_value.calculationTicks > 0) {
					let marbleToUpdate = this.clientMarbles.h[net_Net.clientIdMap.h[key].__id__];
					let centre = marbleToUpdate.newPos;
					if(src_Debug.drawBounds) {
						src_Debug._spheres.push({ position : new h3d_Vector(centre.x,centre.y,centre.z,centre.w), radius : marbleToUpdate._radius, lifetime : 0.032});
					}
					let mv = _g_value.move.move;
					marbleToUpdate.isNetUpdate = true;
					marbleToUpdate.moveMotionDir = _g_value.move.motionDir;
					marbleToUpdate.advancePhysics(advanceTimeState,mv,this.collisionWorld,this.pathedInteriors);
					this.predictions.storeState(marbleToUpdate,move.timeState.ticks);
					marbleToUpdate.isNetUpdate = false;
					_g_value.calculationTicks--;
				}
			}
			advanceTimeState.currentAttemptTime += 0.032;
			advanceTimeState.ticks++;
		}
		this.lastMoves.ourMoveApplied = true;
		this.marble.isNetUpdate = false;
		return advanceTimeState.ticks;
	}
	spawnHuntGemsClientSide(gemIds) {
		if(this.isMultiplayer && net_Net.isClient) {
			let huntMode = this.gameMode;
			huntMode.setActiveSpawnSphere(gemIds);
			this.radar.blink();
		}
	}
	removePlayer(cc) {
		let otherMarble = this.clientMarbles.h[cc.__id__];
		if(otherMarble != null) {
			this.cancel(otherMarble.oobSchedule);
			this.predictions.removeMarbleFromPrediction(otherMarble);
			this.scene.removeChild(otherMarble);
			this.collisionWorld.removeMarbleEntity(otherMarble.collider);
			this.collisionWorld.removeMovingEntity(otherMarble.collider);
			this.playGui.removePlayer(cc.id);
			this.clientMarbles.remove(cc);
			otherMarble.dispose();
			HxOverrides.remove(this.marbles,otherMarble);
		}
	}
	rollback(t) {
		let rewindFrame = this.rewindManager.getNextRewindFrame(this.timeState.currentAttemptTime - t);
		this.rewindManager.applyFrame(rewindFrame);
		this.isReplayingMovement = true;
		this.currentInputMoves = this.inputRecorder.getMovesFrom(this.timeState.currentAttemptTime);
	}
	advanceWorld(dt) {
		src_ProfilerUI.measure("updateTimer",1);
		this.updateTimer(dt);
		this.tickSchedule(this.timeState.currentAttemptTime);
		if(hxd_Key.isDown(src_Settings.controlsSettings.blast) || src_MarbleGame.instance.touchInput.blastbutton.pressed || src_Gamepad.isDown(src_Settings.gamepadSettings.blast) && !this.isWatching && this.game == "ultra") {
			this.marble.useBlast(this.timeState);
		}
		this.updateGameState();
		this.updateBlast(this.marble,this.timeState);
		src_ProfilerUI.measure("updateDTS",1);
		let _g = 0;
		let _g1 = this.dtsObjects;
		while(_g < _g1.length) {
			let obj = _g1[_g];
			++_g;
			obj.update(this.timeState);
		}
		let _g2 = 0;
		let _g3 = this.triggers;
		while(_g2 < _g3.length) {
			let obj = _g3[_g2];
			++_g2;
			obj.update(this.timeState);
		}
		src_ProfilerUI.measure("updateMarbles",1);
		this.marble.update(this.timeState,this.collisionWorld,this.pathedInteriors);
		let this1 = this.clientMarbles;
		let _g_keys = this1.keys();
		while(_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = this1.get(key);
			_g_value.update(this.timeState,this.collisionWorld,this.pathedInteriors);
		}
	}
	update(dt) {
		if(!this._ready) {
			return;
		}
		let realDt = dt;
		if((hxd_Key.isDown(src_Settings.controlsSettings.rewind) || src_MarbleGame.instance.touchInput.rewindButton.pressed || src_Gamepad.isDown(src_Settings.gamepadSettings.rewind)) && src_Settings.optionsSettings.rewindEnabled && !this.isMultiplayer && !this.isWatching && this.finishTime == null) {
			this.rewinding = true;
		} else {
			if((hxd_Key.isReleased(src_Settings.controlsSettings.rewind) || !src_MarbleGame.instance.touchInput.rewindButton.pressed || src_Gamepad.isReleased(src_Settings.gamepadSettings.rewind)) && this.rewinding && !this.isMultiplayer) {
				if(this.isRecording) {
					this.replay.spliceReplay(this.timeState.currentAttemptTime);
				}
			}
			this.rewinding = false;
		}
		if(!this.isWatching) {
			if(this.isRecording && !this.rewinding) {
				this.replay.startFrame();
			}
		} else if(!this.replay.advance(dt)) {
			if(src_Util.isTouchDevice()) {
				src_MarbleGame.instance.touchInput.hideControls(this.playGui.playGuiCtrl);
			}
			this.setCursorLock(false);
			let misFile = haxe_io_Path.withoutExtension(haxe_io_Path.withoutDirectory(this.mission.path));
			this.dispose();
			src_MarbleGame.instance.setPreviewMission(misFile,function() {
				src_MarbleGame.canvas.setContent(new gui_MainMenuGui());
				let pointercontainer = window.document.querySelector("#pointercontainer");
				pointercontainer.hidden = false;
			});
			return;
		}
		if(this.rewinding && !this.isWatching) {
			let rframe = this.rewindManager.getNextRewindFrame(this.timeState.currentAttemptTime - dt * this.rewindManager.timeScale);
			if(rframe != null) {
				let actualDt = this.timeState.currentAttemptTime - rframe.timeState.currentAttemptTime - dt * this.rewindManager.timeScale;
				dt = actualDt;
				this.rewindManager.applyFrame(rframe);
				this.rewindUsed = true;
			}
		}
		if(dt < 0) {
			return;
		}
		if(this.isReplayingMovement) {
			while(this.currentInputMoves.length > 1) {
				while(this.currentInputMoves[1].time <= this.timeState.currentAttemptTime) {
					this.currentInputMoves = this.currentInputMoves.slice(1);
					if(this.currentInputMoves.length == 1) {
						break;
					}
				}
				if(this.currentInputMoves.length > 1) {
					dt = this.currentInputMoves[1].time - this.currentInputMoves[0].time;
				}
				if(this.isReplayingMovement) {
					if(this.timeState.currentAttemptTime != this.currentInputMoves[0].time) {
						haxe_Log.trace("fucked",{ fileName : "src/MarbleWorld.hx", lineNumber : 1585, className : "src.MarbleWorld", methodName : "update"});
					}
				}
				if(this.currentInputMoves.length > 1) {
					this.advanceWorld(dt);
				}
			}
			this.isReplayingMovement = false;
		}
		src_ProfilerUI.measure("updateTimer",1);
		this.updateTimer(dt);
		this.tickSchedule(this.timeState.currentAttemptTime);
		if(this._disposed) {
			return;
		}
		if(this.isWatching && (this.replay.currentPlaybackFrame.marbleStateFlags & 8) != 0) {
			this.marble.useBlast(this.timeState);
		}
		if(this.isWatching) {
			if(this.replay.currentPlaybackFrame.gravityChange) {
				this.setUp(this.marble,this.replay.currentPlaybackFrame.gravity,this.timeState,this.replay.currentPlaybackFrame.gravityInstant);
			}
			if(this.replay.currentPlaybackFrame.powerupPickup != null) {
				this.pickUpPowerUpReplay(this.replay.currentPlaybackFrame.powerupPickup);
			}
		}
		this.radar.update(dt);
		this.updateGameState();
		if(!this.isMultiplayer) {
			this.updateBlast(this.marble,this.timeState);
		}
		src_ProfilerUI.measure("updateDTS",1);
		let _g = 0;
		let _g1 = this.dtsObjects;
		while(_g < _g1.length) {
			let obj = _g1[_g];
			++_g;
			obj.update(this.timeState);
		}
		let _g2 = 0;
		let _g3 = this.triggers;
		while(_g2 < _g3.length) {
			let obj = _g3[_g2];
			++_g2;
			obj.update(this.timeState);
		}
		src_ProfilerUI.measure("updateMarbles",1);
		if(this.isMultiplayer) {
			this.tickAccumulator += this.timeState.dt;
			while(this.tickAccumulator >= 0.032) {
				if(net_Net.isClient) {
					let marbleNeedsTicking = this.applyReceivedMoves();
					this.applyClientPrediction(marbleNeedsTicking);
				}
				let fixedDt = this.timeState.clone();
				fixedDt.dt = 0.032;
				this.tickAccumulator -= 0.032;
				let packets = [];
				let otherMoves = [];
				let myMove = null;
				let _g = 0;
				let _g1 = this.marbles;
				while(_g < _g1.length) {
					let marble = _g1[_g];
					++_g;
					let move = marble.updateServer(fixedDt,this.collisionWorld,this.pathedInteriors);
					if(marble == this.marble) {
						myMove = move;
					} else {
						otherMoves.push(move);
					}
				}
				if(myMove != null && net_Net.isClient) {
					this.predictions.storeState(this.marble,myMove.timeState.ticks);
					let this1 = this.clientMarbles;
					let _g_keys = this1.keys();
					while(_g_keys.hasNext()) {
						let key = _g_keys.next();
						let _g_value = this1.get(key);
						this.predictions.storeState(_g_value,myMove.timeState.ticks);
					}
				}
				if(net_Net.isHost) {
					packets.push(this.marble.packUpdate(myMove,fixedDt));
					let _g = 0;
					let _g1 = this.marbles;
					while(_g < _g1.length) {
						let othermarble = _g1[_g];
						++_g;
						if(othermarble != this.marble) {
							let mv = otherMoves.shift();
							packets.push(othermarble.packUpdate(mv,fixedDt));
						}
					}
					let allRecv = true;
					let this1 = this.clientMarbles;
					let _g_keys = this1.keys();
					while(_g_keys.hasNext()) {
						let key = _g_keys.next();
						let _g_value = this1.get(key);
						if(key.state != 2) {
							allRecv = false;
							continue;
						}
						_g_value.netFlags = 0;
						let _g = 0;
						while(_g < packets.length) {
							let packet = packets[_g];
							++_g;
							key.sendBytes(packet);
						}
					}
					if(allRecv) {
						this.marble.netFlags = 0;
					}
				}
				this.timeState.ticks++;
			}
			this.timeState.subframe = this.tickAccumulator / 0.032;
			this.marble.updateClient(this.timeState,this.pathedInteriors);
			let this1 = this.clientMarbles;
			let _g_keys = this1.keys();
			while(_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = this1.get(key);
				_g_value.updateClient(this.timeState,this.pathedInteriors);
			}
		} else {
			this.marble.update(this.timeState,this.collisionWorld,this.pathedInteriors);
			let this1 = this.clientMarbles;
			let _g_keys = this1.keys();
			while(_g_keys.hasNext()) {
				let key = _g_keys.next();
				let _g_value = this1.get(key);
				_g_value.update(this.timeState,this.collisionWorld,this.pathedInteriors);
			}
		}
		this._instancesNeedsUpdate = true;
		src_Renderer.dirtyBuffers = true;
		if(this.rewinding) {
			this.marble.camera.update(this.timeState.currentAttemptTime,realDt);
		}
		src_ProfilerUI.measure("updateParticles",1);
		if(this.rewinding) {
			this.particleManager.update(1000 * this.timeState.timeSinceLoad,-realDt * this.rewindManager.timeScale);
		} else {
			this.particleManager.update(1000 * this.timeState.timeSinceLoad,dt);
		}
		src_ProfilerUI.measure("updatePlayGui",1);
		this.playGui.update(this.timeState);
		src_ProfilerUI.measure("updateAudio",1);
		src_AudioManager.update(this.scene);
		if(!this.isMultiplayer) {
			if(this.marble.outOfBounds && this.finishTime == null && (!src_Settings.controlsSettings.oobRespawnKeyByPowerup && (hxd_Key.isDown(src_Settings.controlsSettings.jump) || src_Gamepad.isDown(src_Settings.gamepadSettings.jump)) || src_Settings.controlsSettings.oobRespawnKeyByPowerup && (hxd_Key.isDown(src_Settings.controlsSettings.powerup) || src_Gamepad.isDown(src_Settings.gamepadSettings.powerup))) && !this.isWatching) {
				this.restart(this.marble);
				return;
			}
		}
		if(!this.isWatching) {
			if(this.isRecording && !this.rewinding) {
				this.replay.endFrame();
			}
		}
		if(!this.rewinding && src_Settings.optionsSettings.rewindEnabled && !this.isMultiplayer) {
			this.rewindManager.recordFrame();
		}
		this.updateTexts();
	}
	render(e) {
		if(!this._ready) {
			this.asyncLoadResources();
		}
		if(this.playGui != null && this._ready) {
			this.playGui.render(e);
		}
		if(this._instancesNeedsUpdate) {
			if(this.radar != null) {
				this.radar.render();
			}
			src_ProfilerUI.measure("updateInstances",0);
			this.instanceManager.render();
			if(this.marble != null && this.marble.cubemapRenderer != null) {
				src_ProfilerUI.measure("renderCubemap",0);
				let _this = this.marble.cubemapRenderer.position;
				let _this1 = this.marble.getAbsPos();
				let v_x = 0.;
				let v_y = 0.;
				let v_z = 0.;
				let v_w = 1.;
				let x = _this1._41;
				let y = _this1._42;
				let z = _this1._43;
				let w = _this1._44;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				v_x = x;
				v_y = y;
				v_z = z;
				v_w = w;
				_this.x = v_x;
				_this.y = v_y;
				_this.z = v_z;
				_this.w = v_w;
				this.marble.cubemapRenderer.render(e);
			}
			this._instancesNeedsUpdate = false;
		}
	}
	asyncLoadResources() {
		let _gthis = this;
		if(this.resourceLoadFuncs.length != 0) {
			if(this.lock) {
				return;
			}
			this.lock = true;
			let func = this.resourceLoadFuncs.shift();
			let consumeFn = function() {
				_gthis._resourcesLoaded++;
				if(_gthis.resourceLoadFuncs.length != 0) {
					let fn = _gthis.resourceLoadFuncs.shift();
					fn(consumeFn);
				} else {
					_gthis.lock = false;
				}
			};
			func(consumeFn);
		} else {
			if(!this._loadBegin || this.lock) {
				return;
			}
			if(!this._ready && !this.postInited) {
				this.postInited = true;
				src_Console.instance.addEntry("log","Finished loading, starting mission");
				haxe_Timer.delay(function() {
					_gthis.postInit();
				},15);
			}
		}
	}
	updateTimer(dt) {
		this.timeState.dt = dt;
		let timeMultiplier = this.gameMode.timeMultiplier();
		if(!this.isWatching) {
			if(this.bonusTime != 0 && this.timeState.currentAttemptTime + this.skipStartBugPauseTime >= 3.5) {
				this.bonusTime -= dt;
				if(this.bonusTime < 0) {
					this.timeState.gameplayClock -= this.bonusTime * timeMultiplier;
					this.bonusTime = 0;
				}
				if(this.timeTravelSound == null) {
					let ttsnd = src_ResourceLoader.getResource("data/sound/timetravelactive.wav",src_ResourceLoader.getAudio,this.soundResources);
					this.timeTravelSound = src_AudioManager.playSound(ttsnd,null,true);
				}
			} else {
				if(this.timeTravelSound != null) {
					this.timeTravelSound.stop();
					this.timeTravelSound = null;
				}
				if(!this.isMultiplayer) {
					if(this.timeState.currentAttemptTime + this.skipStartBugPauseTime >= 3.5) {
						this.timeState.gameplayClock += dt * timeMultiplier;
					} else if(this.timeState.currentAttemptTime + dt >= 3.5) {
						this.timeState.gameplayClock += (this.timeState.currentAttemptTime + dt - 3.5) * timeMultiplier;
					}
				} else if(this.multiplayerStarted) {
					if(net_Net.isClient) {
						let ticksSinceTimerStart = this.marble.serverTicks - (this.serverStartTicks + 109);
						let ourStartTime = this.gameMode.getStartTime();
						let gameplayHigh = ourStartTime - ticksSinceTimerStart * 0.032;
						let gameplayLow = ourStartTime - (ticksSinceTimerStart + 1) * 0.032;
						if(gameplayHigh < this.timeState.gameplayClock || gameplayLow > this.timeState.gameplayClock) {
							let clockTicks = Math.floor((ourStartTime - this.timeState.gameplayClock) / 0.032);
							let clockTickTime = ourStartTime - clockTicks * 0.032;
							let delta = clockTickTime - this.timeState.gameplayClock;
							this.timeState.gameplayClock = gameplayHigh - delta;
						}
					}
					this.timeState.gameplayClock += dt * timeMultiplier;
				}
				if(this.timeState.gameplayClock < 0 && !net_Net.isClient) {
					this.gameMode.onTimeExpire();
				}
			}
			if(!this.isMultiplayer || this.multiplayerStarted) {
				this.timeState.currentAttemptTime += dt;
			}
		} else {
			this.timeState.currentAttemptTime = this.replay.currentPlaybackFrame.time;
			this.timeState.gameplayClock = this.replay.currentPlaybackFrame.clockTime;
			this.bonusTime = this.replay.currentPlaybackFrame.bonusTime;
			if(this.bonusTime != 0 && this.timeState.currentAttemptTime + this.skipStartBugPauseTime >= 3.5) {
				if(this.timeTravelSound == null) {
					let ttsnd = src_ResourceLoader.getResource("data/sound/timetravelactive.wav",src_ResourceLoader.getAudio,this.soundResources);
					this.timeTravelSound = src_AudioManager.playSound(ttsnd,null,true);
				}
			} else if(this.timeTravelSound != null) {
				this.timeTravelSound.stop();
				this.timeTravelSound = null;
			}
		}
		this.timeState.timeSinceLoad += dt;
		if(this.finishTime != null) {
			this.timeState.gameplayClock = this.finishTime.gameplayClock;
		}
		this.playGui.formatTimer(this.timeState.gameplayClock);
		if(!this.isWatching && this.isRecording) {
			this.replay.recordTimeState(this.timeState.currentAttemptTime,this.timeState.gameplayClock,this.bonusTime);
		}
	}
	updateBlast(marble,timestate) {
		if(this.isMultiplayer) {
			if(marble == this.marble) {
				if(marble.blastTicks < 1125) {
					this.renderBlastAmount = (marble.blastTicks + timestate.subframe) / 937;
				} else {
					this.renderBlastAmount = Math.min(marble.blastTicks / 937,timestate.dt * 0.75 + this.renderBlastAmount);
				}
				this.playGui.setBlastValue(this.renderBlastAmount);
			}
		} else {
			if(marble.blastAmount < 1) {
				let value = marble.blastAmount + this.timeState.dt / 30;
				marble.blastAmount = value < 0 ? 0 : value > 1 ? 1 : value;
				if(marble == this.marble) {
					this.renderBlastAmount = marble.blastAmount;
				}
			} else if(marble == this.marble) {
				this.renderBlastAmount = Math.min(marble.blastAmount,timestate.dt * 0.75 + this.renderBlastAmount);
			}
			if(marble == this.marble) {
				this.playGui.setBlastValue(this.renderBlastAmount);
			}
		}
	}
	updateTexts() {
		let helpTextTime = this.helpTextTimeState;
		let alertTextTime = this.alertTextTimeState;
		let value = this.timeState.timeSinceLoad - helpTextTime - 3;
		let helpTextCompletion = Math.pow(value < 0 ? 0 : value > 1 ? 1 : value,2);
		let value1 = this.timeState.timeSinceLoad - alertTextTime - 3;
		let alertTextCompletion = Math.pow(value1 < 0 ? 0 : value1 > 1 ? 1 : value1,2);
		this.playGui.setHelpTextOpacity(1 - helpTextCompletion);
		this.playGui.setAlertTextOpacity(1 - alertTextCompletion);
	}
	displayAlert(text) {
		this.playGui.setAlertText(text);
		this.alertTextTimeState = this.timeState.timeSinceLoad;
	}
	displayHelp(text) {
		let start = 0;
		let pos = text.indexOf("<func:",0);
		while(pos != -1) {
			let end = text.indexOf(">",start + 5);
			if(end == -1) {
				break;
			}
			let pre = HxOverrides.substr(text,0,pos);
			let post = HxOverrides.substr(text,end + 1,null);
			let func = HxOverrides.substr(text,pos + 6,end - (pos + 6));
			let _this = func.split(" ");
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				result[i] = _this[i].toLowerCase();
			}
			let val = "";
			if(result[0] == "bind") {
				if(result[1] == "moveforward") {
					let keyName = hxd_Key.getKeyName(src_Settings.controlsSettings.forward);
					if(keyName == "MouseLeft") {
						keyName = "the Left Mouse Button";
					}
					if(keyName == "MouseRight") {
						keyName = "the Right Mouse Button";
					}
					if(keyName == "MouseMiddle") {
						keyName = "the Middle Mouse Button";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					val = keyName;
				}
				if(result[1] == "movebackward") {
					let keyName = hxd_Key.getKeyName(src_Settings.controlsSettings.backward);
					if(keyName == "MouseLeft") {
						keyName = "the Left Mouse Button";
					}
					if(keyName == "MouseRight") {
						keyName = "the Right Mouse Button";
					}
					if(keyName == "MouseMiddle") {
						keyName = "the Middle Mouse Button";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					val = keyName;
				}
				if(result[1] == "moveleft") {
					let keyName = hxd_Key.getKeyName(src_Settings.controlsSettings.left);
					if(keyName == "MouseLeft") {
						keyName = "the Left Mouse Button";
					}
					if(keyName == "MouseRight") {
						keyName = "the Right Mouse Button";
					}
					if(keyName == "MouseMiddle") {
						keyName = "the Middle Mouse Button";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					val = keyName;
				}
				if(result[1] == "moveright") {
					let keyName = hxd_Key.getKeyName(src_Settings.controlsSettings.right);
					if(keyName == "MouseLeft") {
						keyName = "the Left Mouse Button";
					}
					if(keyName == "MouseRight") {
						keyName = "the Right Mouse Button";
					}
					if(keyName == "MouseMiddle") {
						keyName = "the Middle Mouse Button";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					val = keyName;
				}
				if(result[1] == "panup") {
					let keyName = hxd_Key.getKeyName(src_Settings.controlsSettings.camForward);
					if(keyName == "MouseLeft") {
						keyName = "the Left Mouse Button";
					}
					if(keyName == "MouseRight") {
						keyName = "the Right Mouse Button";
					}
					if(keyName == "MouseMiddle") {
						keyName = "the Middle Mouse Button";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					val = keyName;
				}
				if(result[1] == "pandown") {
					let keyName = hxd_Key.getKeyName(src_Settings.controlsSettings.camBackward);
					if(keyName == "MouseLeft") {
						keyName = "the Left Mouse Button";
					}
					if(keyName == "MouseRight") {
						keyName = "the Right Mouse Button";
					}
					if(keyName == "MouseMiddle") {
						keyName = "the Middle Mouse Button";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					val = keyName;
				}
				if(result[1] == "turnleft") {
					let keyName = hxd_Key.getKeyName(src_Settings.controlsSettings.camLeft);
					if(keyName == "MouseLeft") {
						keyName = "the Left Mouse Button";
					}
					if(keyName == "MouseRight") {
						keyName = "the Right Mouse Button";
					}
					if(keyName == "MouseMiddle") {
						keyName = "the Middle Mouse Button";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					val = keyName;
				}
				if(result[1] == "turnright") {
					let keyName = hxd_Key.getKeyName(src_Settings.controlsSettings.camRight);
					if(keyName == "MouseLeft") {
						keyName = "the Left Mouse Button";
					}
					if(keyName == "MouseRight") {
						keyName = "the Right Mouse Button";
					}
					if(keyName == "MouseMiddle") {
						keyName = "the Middle Mouse Button";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					val = keyName;
				}
				if(result[1] == "jump") {
					let keyName = hxd_Key.getKeyName(src_Settings.controlsSettings.jump);
					if(keyName == "MouseLeft") {
						keyName = "the Left Mouse Button";
					}
					if(keyName == "MouseRight") {
						keyName = "the Right Mouse Button";
					}
					if(keyName == "MouseMiddle") {
						keyName = "the Middle Mouse Button";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					val = keyName;
				}
				if(result[1] == "mousefire") {
					let keyName = hxd_Key.getKeyName(src_Settings.controlsSettings.powerup);
					if(keyName == "MouseLeft") {
						keyName = "the Left Mouse Button";
					}
					if(keyName == "MouseRight") {
						keyName = "the Right Mouse Button";
					}
					if(keyName == "MouseMiddle") {
						keyName = "the Middle Mouse Button";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					val = keyName;
				}
				if(result[1] == "freelook") {
					let keyName = hxd_Key.getKeyName(src_Settings.controlsSettings.freelook);
					if(keyName == "MouseLeft") {
						keyName = "the Left Mouse Button";
					}
					if(keyName == "MouseRight") {
						keyName = "the Right Mouse Button";
					}
					if(keyName == "MouseMiddle") {
						keyName = "the Middle Mouse Button";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					val = keyName;
				}
				if(result[1] == "useblast") {
					let keyName = hxd_Key.getKeyName(src_Settings.controlsSettings.blast);
					if(keyName == "MouseLeft") {
						keyName = "the Left Mouse Button";
					}
					if(keyName == "MouseRight") {
						keyName = "the Right Mouse Button";
					}
					if(keyName == "MouseMiddle") {
						keyName = "the Middle Mouse Button";
					}
					if(keyName == "Space") {
						keyName = "Space Bar";
					}
					val = keyName;
				}
			}
			start = val.length + pos;
			text = pre + val + post;
			pos = text.indexOf("<func:",start);
		}
		this.playGui.setHelpText(text);
		this.helpTextTimeState = this.timeState.timeSinceLoad;
	}
	pickUpGem(marble,gem) {
		this.gameMode.onGemPickup(marble,gem);
	}
	callCollisionHandlers(marble,timeState,start,end) {
		let expansion = marble._radius + 0.2;
		let x = Math.min(start.x,end.x) - expansion;
		let y = Math.min(start.y,end.y) - expansion;
		let z = Math.min(start.z,end.z) - expansion;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let minP_x = x;
		let minP_y = y;
		let minP_z = z;
		let x1 = Math.max(start.x,end.x) + expansion;
		let y1 = Math.max(start.y,end.y) + expansion;
		let z1 = Math.max(start.z,end.z) + expansion;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let maxP_x = x1;
		let maxP_y = y1;
		let maxP_z = z1;
		let x2 = minP_x;
		let y2 = minP_y;
		let z2 = minP_z;
		if(minP_z == null) {
			z2 = 0.;
		}
		if(minP_y == null) {
			y2 = 0.;
		}
		if(minP_x == null) {
			x2 = 0.;
		}
		let min_x = x2;
		let min_y = y2;
		let min_z = z2;
		let x3 = maxP_x;
		let y3 = maxP_y;
		let z3 = maxP_z;
		if(maxP_z == null) {
			z3 = 0.;
		}
		if(maxP_y == null) {
			y3 = 0.;
		}
		if(maxP_x == null) {
			x3 = 0.;
		}
		let max_x = x3;
		let max_y = y3;
		let max_z = z3;
		let b = new h3d_col_Bounds();
		b.xMin = min_x;
		b.yMin = min_y;
		b.zMin = min_z;
		b.xMax = max_x;
		b.yMax = max_y;
		b.zMax = max_z;
		let contacts = this.collisionWorld.boundingSearch(b);
		let inside = [];
		let _g = 0;
		while(_g < contacts.length) {
			let contact = contacts[_g];
			++_g;
			if(contact.go != marble) {
				if(((contact.go) instanceof src_DtsObject)) {
					let shape = contact.go;
					let _this = contact.boundingBox;
					if(!(_this.xMin > b.xMax || _this.yMin > b.yMax || _this.zMin > b.zMax || _this.xMax < b.xMin || _this.yMax < b.yMin || _this.zMax < b.zMin)) {
						shape.onMarbleInside(marble,timeState);
						if(!this.shapeOrTriggerInside.includes(contact.go)) {
							this.shapeOrTriggerInside.push(contact.go);
							shape.onMarbleEnter(marble,timeState);
						}
						inside.push(contact.go);
					}
				}
				if(((contact.go) instanceof triggers_Trigger)) {
					let trigger = contact.go;
					let triggeraabb = trigger.collider.boundingBox;
					if(trigger.accountForGravity) {
						let up = marble.currentUp;
						let x = (triggeraabb.xMin + triggeraabb.xMax) * 0.5;
						let y = (triggeraabb.yMin + triggeraabb.yMax) * 0.5;
						let z = (triggeraabb.zMin + triggeraabb.zMax) * 0.5;
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let extents_x = x;
						let extents_y = y;
						let extents_z = z;
						let x1 = (b.xMin + b.xMax) * 0.5;
						let y1 = (b.yMin + b.yMax) * 0.5;
						let z1 = (b.zMin + b.zMax) * 0.5;
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let enterExtents_x = x1;
						let enterExtents_y = y1;
						let enterExtents_z = z1;
						let x2 = enterExtents_x - extents_x;
						let y2 = enterExtents_y - extents_y;
						let z2 = enterExtents_z - extents_z;
						if(z2 == null) {
							z2 = 0.;
						}
						if(y2 == null) {
							y2 = 0.;
						}
						if(x2 == null) {
							x2 = 0.;
						}
						let diffExtents_x = x2;
						let diffExtents_y = y2;
						let diffExtents_z = z2;
						let x3 = diffExtents_x;
						let y3 = diffExtents_y;
						let z3 = diffExtents_z;
						if(diffExtents_z == null) {
							z3 = 0.;
						}
						if(diffExtents_y == null) {
							y3 = 0.;
						}
						if(diffExtents_x == null) {
							x3 = 0.;
						}
						let v_x = x3;
						let v_y = y3;
						let v_z = z3;
						let upAmount = up.x * v_x + up.y * v_y + up.z * v_z;
						if(upAmount > 0) {
							let boxC_xMin = 1e20;
							let boxC_xMax = -1e20;
							let boxC_yMin = 1e20;
							let boxC_yMax = -1e20;
							let boxC_zMin = 1e20;
							let boxC_zMax = -1e20;
							boxC_xMin = b.xMin;
							boxC_xMax = b.xMax;
							boxC_yMin = b.yMin;
							boxC_yMax = b.yMax;
							boxC_zMin = b.zMin;
							boxC_zMax = b.zMax;
							boxC_xMin -= up.x * upAmount;
							boxC_yMin -= up.y * upAmount;
							boxC_zMin -= up.z * upAmount;
							boxC_xMax -= up.x * upAmount;
							boxC_yMax -= up.y * upAmount;
							boxC_zMax -= up.z * upAmount;
							if(!(triggeraabb.xMin > boxC_xMax || triggeraabb.yMin > boxC_yMax || triggeraabb.zMin > boxC_zMax || triggeraabb.xMax < boxC_xMin || triggeraabb.yMax < boxC_yMin || triggeraabb.zMax < boxC_zMin)) {
								trigger.onMarbleInside(marble,timeState);
								if(!this.shapeOrTriggerInside.includes(contact.go)) {
									this.shapeOrTriggerInside.push(contact.go);
									trigger.onMarbleEnter(marble,timeState);
								}
								inside.push(contact.go);
							}
						} else if(!(triggeraabb.xMin > b.xMax || triggeraabb.yMin > b.yMax || triggeraabb.zMin > b.zMax || triggeraabb.xMax < b.xMin || triggeraabb.yMax < b.yMin || triggeraabb.zMax < b.zMin)) {
							trigger.onMarbleInside(marble,timeState);
							if(!this.shapeOrTriggerInside.includes(contact.go)) {
								this.shapeOrTriggerInside.push(contact.go);
								trigger.onMarbleEnter(marble,timeState);
							}
							inside.push(contact.go);
						}
					} else if(!(triggeraabb.xMin > b.xMax || triggeraabb.yMin > b.yMax || triggeraabb.zMin > b.zMax || triggeraabb.xMax < b.xMin || triggeraabb.yMax < b.yMin || triggeraabb.zMax < b.zMin)) {
						trigger.onMarbleInside(marble,timeState);
						if(!this.shapeOrTriggerInside.includes(contact.go)) {
							this.shapeOrTriggerInside.push(contact.go);
							trigger.onMarbleEnter(marble,timeState);
						}
						inside.push(contact.go);
					}
				}
			}
		}
		let _g1 = 0;
		let _g2 = this.shapeOrTriggerInside;
		while(_g1 < _g2.length) {
			let object = _g2[_g1];
			++_g1;
			if(((object) instanceof triggers_Trigger)) {
				let trigger = object;
				let triggeraabb = trigger.collider.boundingBox;
				if(trigger.accountForGravity) {
					let up = marble.currentUp;
					let x = (triggeraabb.xMin + triggeraabb.xMax) * 0.5;
					let y = (triggeraabb.yMin + triggeraabb.yMax) * 0.5;
					let z = (triggeraabb.zMin + triggeraabb.zMax) * 0.5;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let extents_x = x;
					let extents_y = y;
					let extents_z = z;
					let x1 = (b.xMin + b.xMax) * 0.5;
					let y1 = (b.yMin + b.yMax) * 0.5;
					let z1 = (b.zMin + b.zMax) * 0.5;
					if(z1 == null) {
						z1 = 0.;
					}
					if(y1 == null) {
						y1 = 0.;
					}
					if(x1 == null) {
						x1 = 0.;
					}
					let enterExtents_x = x1;
					let enterExtents_y = y1;
					let enterExtents_z = z1;
					let x2 = enterExtents_x - extents_x;
					let y2 = enterExtents_y - extents_y;
					let z2 = enterExtents_z - extents_z;
					if(z2 == null) {
						z2 = 0.;
					}
					if(y2 == null) {
						y2 = 0.;
					}
					if(x2 == null) {
						x2 = 0.;
					}
					let diffExtents_x = x2;
					let diffExtents_y = y2;
					let diffExtents_z = z2;
					let x3 = diffExtents_x;
					let y3 = diffExtents_y;
					let z3 = diffExtents_z;
					if(diffExtents_z == null) {
						z3 = 0.;
					}
					if(diffExtents_y == null) {
						y3 = 0.;
					}
					if(diffExtents_x == null) {
						x3 = 0.;
					}
					let v_x = x3;
					let v_y = y3;
					let v_z = z3;
					let upAmount = up.x * v_x + up.y * v_y + up.z * v_z;
					if(upAmount > 0) {
						let boxC_xMin = 1e20;
						let boxC_xMax = -1e20;
						let boxC_yMin = 1e20;
						let boxC_yMax = -1e20;
						let boxC_zMin = 1e20;
						let boxC_zMax = -1e20;
						boxC_xMin = b.xMin;
						boxC_xMax = b.xMax;
						boxC_yMin = b.yMin;
						boxC_yMax = b.yMax;
						boxC_zMin = b.zMin;
						boxC_zMax = b.zMax;
						boxC_xMin -= up.x * upAmount;
						boxC_yMin -= up.y * upAmount;
						boxC_zMin -= up.z * upAmount;
						boxC_xMax -= up.x * upAmount;
						boxC_yMax -= up.y * upAmount;
						boxC_zMax -= up.z * upAmount;
						if(!(triggeraabb.xMin > boxC_xMax || triggeraabb.yMin > boxC_yMax || triggeraabb.zMin > boxC_zMax || triggeraabb.xMax < boxC_xMin || triggeraabb.yMax < boxC_yMin || triggeraabb.zMax < boxC_zMin)) {
							trigger.onMarbleInside(marble,timeState);
							if(!this.shapeOrTriggerInside.includes(object)) {
								this.shapeOrTriggerInside.push(object);
								trigger.onMarbleEnter(marble,timeState);
							}
							inside.push(object);
						}
					} else if(!(triggeraabb.xMin > b.xMax || triggeraabb.yMin > b.yMax || triggeraabb.zMin > b.zMax || triggeraabb.xMax < b.xMin || triggeraabb.yMax < b.yMin || triggeraabb.zMax < b.zMin)) {
						trigger.onMarbleInside(marble,timeState);
						if(!this.shapeOrTriggerInside.includes(object)) {
							this.shapeOrTriggerInside.push(object);
							trigger.onMarbleEnter(marble,timeState);
						}
						inside.push(object);
					}
				}
			}
			if(!inside.includes(object)) {
				HxOverrides.remove(this.shapeOrTriggerInside,object);
				object.onMarbleLeave(marble,timeState);
			}
		}
		if(this.finishTime == null && this.endPad != null) {
			let b1 = this.endPad.finishBounds;
			if(!(b.xMin > b1.xMax || b.yMin > b1.yMax || b.zMin > b1.zMax || b.xMax < b1.xMin || b.yMax < b1.yMin || b.zMax < b1.zMin)) {
				let _this = this.endPad.getAbsPos();
				let v = new h3d_Vector(_this._31,_this._32,_this._33);
				let k = v.x * v.x + v.y * v.y + v.z * v.z;
				if(k < 1e-10) {
					k = 0;
				} else {
					k = 1. / Math.sqrt(k);
				}
				v.x *= k;
				v.y *= k;
				v.z *= k;
				let padUp = v;
				padUp = new h3d_Vector(v.x * 10,v.y * 10,v.z * 10,v.w);
				let checkBounds_xMin = 1e20;
				let checkBounds_xMax = -1e20;
				let checkBounds_yMin = 1e20;
				let checkBounds_yMax = -1e20;
				let checkBounds_zMin = 1e20;
				let checkBounds_zMax = -1e20;
				checkBounds_xMin = b.xMin;
				checkBounds_xMax = b.xMax;
				checkBounds_yMin = b.yMin;
				checkBounds_yMax = b.yMax;
				checkBounds_zMin = b.zMin;
				checkBounds_zMax = b.zMax;
				checkBounds_zMin -= 10;
				checkBounds_zMax += 10;
				let x = (checkBounds_xMin + checkBounds_xMax) * 0.5;
				let y = (checkBounds_yMin + checkBounds_yMax) * 0.5;
				let z = (checkBounds_zMin + checkBounds_zMax) * 0.5;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let checkBoundsCenter_x = x;
				let checkBoundsCenter_y = y;
				let checkBoundsCenter_z = z;
				let x1 = checkBounds_xMax;
				let y1 = checkBounds_yMax;
				let z1 = checkBounds_zMax;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let _this_x = x1;
				let _this_y = y1;
				let _this_z = z1;
				let x2 = _this_x - checkBoundsCenter_x;
				let y2 = _this_y - checkBoundsCenter_y;
				let z2 = _this_z - checkBoundsCenter_z;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let _this_x1 = x2;
				let _this_y1 = y2;
				let _this_z1 = z2;
				let checkSphereRadius = Math.sqrt(_this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1);
				let checkSphere = new h3d_col_Bounds();
				if(checkBoundsCenter_x - checkSphereRadius < checkSphere.xMin) {
					checkSphere.xMin = checkBoundsCenter_x - checkSphereRadius;
				}
				if(checkBoundsCenter_x + checkSphereRadius > checkSphere.xMax) {
					checkSphere.xMax = checkBoundsCenter_x + checkSphereRadius;
				}
				if(checkBoundsCenter_y - checkSphereRadius < checkSphere.yMin) {
					checkSphere.yMin = checkBoundsCenter_y - checkSphereRadius;
				}
				if(checkBoundsCenter_y + checkSphereRadius > checkSphere.yMax) {
					checkSphere.yMax = checkBoundsCenter_y + checkSphereRadius;
				}
				if(checkBoundsCenter_z - checkSphereRadius < checkSphere.zMin) {
					checkSphere.zMin = checkBoundsCenter_z - checkSphereRadius;
				}
				if(checkBoundsCenter_z + checkSphereRadius > checkSphere.zMax) {
					checkSphere.zMax = checkBoundsCenter_z + checkSphereRadius;
				}
				let endpadBB = this.collisionWorld.boundingSearch(checkSphere,false);
				let found = false;
				let _g = 0;
				while(_g < endpadBB.length) {
					let collider = endpadBB[_g];
					++_g;
					if(collider.go == this.endPad) {
						let chull = js_Boot.__cast(collider , collision_CollisionEntity);
						let chullinvT = chull.invTransform.clone();
						chullinvT.clone();
						chullinvT.transpose();
						let _g = 0;
						let _g1 = chull.surfaces;
						while(_g < _g1.length) {
							let surface = _g1[_g];
							++_g;
							let i = 0;
							while(i < surface.indices.length) {
								let idx = surface.indices[i];
								let x = surface.normals[idx * 3];
								let y = surface.normals[idx * 3 + 1];
								let z = surface.normals[idx * 3 + 2];
								if(z == null) {
									z = 0.;
								}
								if(y == null) {
									y = 0.;
								}
								if(x == null) {
									x = 0.;
								}
								let _this_x = x;
								let _this_y = y;
								let _this_z = z;
								let px = _this_x * chullinvT._11 + _this_y * chullinvT._21 + _this_z * chullinvT._31;
								let py = _this_x * chullinvT._12 + _this_y * chullinvT._22 + _this_z * chullinvT._32;
								let pz = _this_x * chullinvT._13 + _this_y * chullinvT._23 + _this_z * chullinvT._33;
								let x1 = px;
								let y1 = py;
								let z1 = pz;
								if(pz == null) {
									z1 = 0.;
								}
								if(py == null) {
									y1 = 0.;
								}
								if(px == null) {
									x1 = 0.;
								}
								let surfaceN_x = x1;
								let surfaceN_y = y1;
								let surfaceN_z = z1;
								let idx1 = surface.indices[i];
								let x2 = surface.points[idx1 * 3];
								let y2 = surface.points[idx1 * 3 + 1];
								let z2 = surface.points[idx1 * 3 + 2];
								if(z2 == null) {
									z2 = 0.;
								}
								if(y2 == null) {
									y2 = 0.;
								}
								if(x2 == null) {
									x2 = 0.;
								}
								let _this_x1 = x2;
								let _this_y1 = y2;
								let _this_z1 = z2;
								let m = chull.transform;
								let px1 = _this_x1 * m._11 + _this_y1 * m._21 + _this_z1 * m._31 + m._41;
								let py1 = _this_x1 * m._12 + _this_y1 * m._22 + _this_z1 * m._32 + m._42;
								let pz1 = _this_x1 * m._13 + _this_y1 * m._23 + _this_z1 * m._33 + m._43;
								let pw = _this_x1 * m._14 + _this_y1 * m._24 + _this_z1 * m._34 + m._44;
								let x3 = px1;
								let y3 = py1;
								let z3 = pz1;
								let w = pw;
								if(pw == null) {
									w = 1.;
								}
								if(pz1 == null) {
									z3 = 0.;
								}
								if(py1 == null) {
									y3 = 0.;
								}
								if(px1 == null) {
									x3 = 0.;
								}
								let v1_x = x3;
								let v1_y = y3;
								let v1_z = z3;
								let surfaceD = -(surfaceN_x * v1_x + surfaceN_y * v1_y + surfaceN_z * v1_z);
								let x4 = padUp.x * -10;
								let y4 = padUp.y * -10;
								let z4 = padUp.z * -10;
								if(z4 == null) {
									z4 = 0.;
								}
								if(y4 == null) {
									y4 = 0.;
								}
								if(x4 == null) {
									x4 = 0.;
								}
								let v_x = x4;
								let v_y = y4;
								let v_z = z4;
								if(surfaceN_x * v_x + surfaceN_y * v_y + surfaceN_z * v_z < 0) {
									let x = checkBoundsCenter_x;
									let y = checkBoundsCenter_y;
									let z = checkBoundsCenter_z;
									if(checkBoundsCenter_z == null) {
										z = 0.;
									}
									if(checkBoundsCenter_y == null) {
										y = 0.;
									}
									if(checkBoundsCenter_x == null) {
										x = 0.;
									}
									let v_x = x;
									let v_y = y;
									let v_z = z;
									let dist = surfaceN_x * v_x + surfaceN_y * v_y + surfaceN_z * v_z + surfaceD;
									if(dist >= 0 && dist < 5) {
										let x = surfaceN_x;
										let y = surfaceN_y;
										let z = surfaceN_z;
										if(surfaceN_z == null) {
											z = 0.;
										}
										if(surfaceN_y == null) {
											y = 0.;
										}
										if(surfaceN_x == null) {
											x = 0.;
										}
										let p_x = x;
										let p_y = y;
										let p_z = z;
										let intersectT = -(checkBoundsCenter_x * p_x + checkBoundsCenter_y * p_y + checkBoundsCenter_z * p_z + surfaceD) / (padUp.x * surfaceN_x + padUp.y * surfaceN_y + padUp.z * surfaceN_z);
										let x1 = padUp.x * intersectT;
										let y1 = padUp.y * intersectT;
										let z1 = padUp.z * intersectT;
										if(z1 == null) {
											z1 = 0.;
										}
										if(y1 == null) {
											y1 = 0.;
										}
										if(x1 == null) {
											x1 = 0.;
										}
										let _this_x = x1;
										let _this_y = y1;
										let _this_z = z1;
										let x2 = _this_x;
										let y2 = _this_y;
										let z2 = _this_z;
										if(_this_z == null) {
											z2 = 0.;
										}
										if(_this_y == null) {
											y2 = 0.;
										}
										if(_this_x == null) {
											x2 = 0.;
										}
										let p_x1 = x2;
										let p_y1 = y2;
										let p_z1 = z2;
										let x3 = checkBoundsCenter_x + p_x1;
										let y3 = checkBoundsCenter_y + p_y1;
										let z3 = checkBoundsCenter_z + p_z1;
										if(z3 == null) {
											z3 = 0.;
										}
										if(y3 == null) {
											y3 = 0.;
										}
										if(x3 == null) {
											x3 = 0.;
										}
										let _this_x1 = x3;
										let _this_y1 = y3;
										let _this_z1 = z3;
										let x4 = _this_x1;
										let y4 = _this_y1;
										let z4 = _this_z1;
										if(_this_z1 == null) {
											z4 = 0.;
										}
										if(_this_y1 == null) {
											y4 = 0.;
										}
										if(_this_x1 == null) {
											x4 = 0.;
										}
										let intersectP_x = x4;
										let intersectP_y = y4;
										let intersectP_z = z4;
										let idx = surface.indices[i + 1];
										let x5 = surface.points[idx * 3];
										let y5 = surface.points[idx * 3 + 1];
										let z5 = surface.points[idx * 3 + 2];
										if(z5 == null) {
											z5 = 0.;
										}
										if(y5 == null) {
											y5 = 0.;
										}
										if(x5 == null) {
											x5 = 0.;
										}
										let _this_x2 = x5;
										let _this_y2 = y5;
										let _this_z2 = z5;
										let m = chull.transform;
										let px = _this_x2 * m._11 + _this_y2 * m._21 + _this_z2 * m._31 + m._41;
										let py = _this_x2 * m._12 + _this_y2 * m._22 + _this_z2 * m._32 + m._42;
										let pz = _this_x2 * m._13 + _this_y2 * m._23 + _this_z2 * m._33 + m._43;
										let pw = _this_x2 * m._14 + _this_y2 * m._24 + _this_z2 * m._34 + m._44;
										let x6 = px;
										let y6 = py;
										let z6 = pz;
										let w = pw;
										if(pw == null) {
											w = 1.;
										}
										if(pz == null) {
											z6 = 0.;
										}
										if(py == null) {
											y6 = 0.;
										}
										if(px == null) {
											x6 = 0.;
										}
										let v1_x1 = x6;
										let v1_y1 = y6;
										let v1_z1 = z6;
										let idx1 = surface.indices[i + 2];
										let x7 = surface.points[idx1 * 3];
										let y7 = surface.points[idx1 * 3 + 1];
										let z7 = surface.points[idx1 * 3 + 2];
										if(z7 == null) {
											z7 = 0.;
										}
										if(y7 == null) {
											y7 = 0.;
										}
										if(x7 == null) {
											x7 = 0.;
										}
										let _this_x3 = x7;
										let _this_y3 = y7;
										let _this_z3 = z7;
										let m1 = chull.transform;
										let px1 = _this_x3 * m1._11 + _this_y3 * m1._21 + _this_z3 * m1._31 + m1._41;
										let py1 = _this_x3 * m1._12 + _this_y3 * m1._22 + _this_z3 * m1._32 + m1._42;
										let pz1 = _this_x3 * m1._13 + _this_y3 * m1._23 + _this_z3 * m1._33 + m1._43;
										let pw1 = _this_x3 * m1._14 + _this_y3 * m1._24 + _this_z3 * m1._34 + m1._44;
										let x8 = px1;
										let y8 = py1;
										let z8 = pz1;
										let w1 = pw1;
										if(pw1 == null) {
											w1 = 1.;
										}
										if(pz1 == null) {
											z8 = 0.;
										}
										if(py1 == null) {
											y8 = 0.;
										}
										if(px1 == null) {
											x8 = 0.;
										}
										let v2_x = x8;
										let v2_y = y8;
										let v2_z = z8;
										let x9 = v1_x1 - v1_x;
										let y9 = v1_y1 - v1_y;
										let z9 = v1_z1 - v1_z;
										if(z9 == null) {
											z9 = 0.;
										}
										if(y9 == null) {
											y9 = 0.;
										}
										if(x9 == null) {
											x9 = 0.;
										}
										let u_x = x9;
										let u_y = y9;
										let u_z = z9;
										let x10 = v2_x - v1_x;
										let y10 = v2_y - v1_y;
										let z10 = v2_z - v1_z;
										if(z10 == null) {
											z10 = 0.;
										}
										if(y10 == null) {
											y10 = 0.;
										}
										if(x10 == null) {
											x10 = 0.;
										}
										let v_x = x10;
										let v_y = y10;
										let v_z = z10;
										let x11 = intersectP_x - v1_x;
										let y11 = intersectP_y - v1_y;
										let z11 = intersectP_z - v1_z;
										if(z11 == null) {
											z11 = 0.;
										}
										if(y11 == null) {
											y11 = 0.;
										}
										if(x11 == null) {
											x11 = 0.;
										}
										let w_x = x11;
										let w_y = y11;
										let w_z = z11;
										let x12 = v_y * w_z - v_z * w_y;
										let y12 = v_z * w_x - v_x * w_z;
										let z12 = v_x * w_y - v_y * w_x;
										if(z12 == null) {
											z12 = 0.;
										}
										if(y12 == null) {
											y12 = 0.;
										}
										if(x12 == null) {
											x12 = 0.;
										}
										let vw_x = x12;
										let vw_y = y12;
										let vw_z = z12;
										let x13 = v_y * u_z - v_z * u_y;
										let y13 = v_z * u_x - v_x * u_z;
										let z13 = v_x * u_y - v_y * u_x;
										if(z13 == null) {
											z13 = 0.;
										}
										if(y13 == null) {
											y13 = 0.;
										}
										if(x13 == null) {
											x13 = 0.;
										}
										let vu_x = x13;
										let vu_y = y13;
										let vu_z = z13;
										let tmp;
										if(vw_x * vu_x + vw_y * vu_y + vw_z * vu_z < 0.0) {
											tmp = false;
										} else {
											let x = u_y * w_z - u_z * w_y;
											let y = u_z * w_x - u_x * w_z;
											let z = u_x * w_y - u_y * w_x;
											if(z == null) {
												z = 0.;
											}
											if(y == null) {
												y = 0.;
											}
											if(x == null) {
												x = 0.;
											}
											let uw_x = x;
											let uw_y = y;
											let uw_z = z;
											let x1 = u_y * v_z - u_z * v_y;
											let y1 = u_z * v_x - u_x * v_z;
											let z1 = u_x * v_y - u_y * v_x;
											if(z1 == null) {
												z1 = 0.;
											}
											if(y1 == null) {
												y1 = 0.;
											}
											if(x1 == null) {
												x1 = 0.;
											}
											let uv_x = x1;
											let uv_y = y1;
											let uv_z = z1;
											if(uw_x * uv_x + uw_y * uv_y + uw_z * uv_z < 0.0) {
												tmp = false;
											} else {
												let d = Math.sqrt(uv_x * uv_x + uv_y * uv_y + uv_z * uv_z);
												let r = Math.sqrt(vw_x * vw_x + vw_y * vw_y + vw_z * vw_z) / d;
												let t = Math.sqrt(uw_x * uw_x + uw_y * uw_y + uw_z * uw_z) / d;
												tmp = r + t <= 1;
											}
										}
										if(tmp) {
											found = true;
											break;
										}
									}
								}
								i += 3;
							}
							if(found) {
								break;
							}
						}
						if(found) {
							break;
						}
					}
				}
				if(found) {
					if(!this.endPad.inFinish) {
						this.touchFinish();
						this.endPad.inFinish = true;
					}
				} else if(this.endPad.inFinish) {
					this.endPad.inFinish = false;
				}
			} else if(this.endPad.inFinish) {
				this.endPad.inFinish = false;
			}
		}
	}
	touchFinish() {
		if(this.finishTime != null || this.marble.outOfBounds && this.timeState.currentAttemptTime - this.marble.outOfBoundsTime.currentAttemptTime >= 0.5) {
			return;
		}
		let _gthis = this;
		if(this.gemCount < this.totalGems) {
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/missinggems.wav",src_ResourceLoader.getAudio,this.soundResources));
			this.displayAlert("You can't finish without all the gems!");
		} else {
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/finish.wav",src_ResourceLoader.getAudio,this.soundResources));
			this.finishTime = this.timeState.clone();
			this.marble.setMode(src_Mode.Finish);
			this.marble.camera.finish = true;
			this.finishYaw = this.marble.camera.CameraYaw;
			this.finishPitch = this.marble.camera.CameraPitch;
			this.displayAlert("Congratulations! You've finished!");
			if(!Object.prototype.hasOwnProperty.call(src_Settings.levelStatistics.h,this.mission.path)) {
				src_Settings.levelStatistics.h[this.mission.path] = { oobs : 0, respawns : 0, totalTime : 0, totalMPScore : 0};
			}
			src_Analytics.trackLevelScore(this.mission.title,this.mission.path,this.gameMode.getScoreType() == modes_ScoreType.Time ? 1000 * this.gameMode.getFinishScore() | 0 : this.gameMode.getFinishScore() | 0,src_Settings.levelStatistics.h[this.mission.path].oobs,src_Settings.levelStatistics.h[this.mission.path].respawns,src_Settings.optionsSettings.rewindEnabled);
			if(!this.isWatching) {
				let myScore = { name : "Player", time : this.gameMode.getFinishScore()};
				src_Settings.saveScore(this.mission.path,myScore,this.gameMode.getScoreType());
				let notifies = gui_AchievementsGui.check();
				let achDelay = 0.0;
				if((notifies & 1) > 0) {
					achDelay = 3.;
				}
				if((notifies & 2) > 0) {
					achDelay += 3;
				}
				if((notifies & 4) > 0) {
					achDelay += 3;
				}
				if((notifies & 8) > 0) {
					achDelay += 3;
				}
				if((notifies & 16) > 0) {
					achDelay += 3;
				}
				if((notifies & 32) > 0) {
					achDelay += 3;
				}
				if((notifies & 64) > 0) {
					achDelay += 3;
				}
				if((notifies & 128) > 0) {
					achDelay += 3;
				}
				if((notifies & 256) > 0) {
					achDelay += 3;
				}
				if(notifies > 0) {
					achDelay += 0.5;
				}
				this.schedule(this.timeState.currentAttemptTime + Math.max(5.0,achDelay),function() {
					return _gthis.showFinishScreen();
				});
			}
			if(this.timeTravelSound != null) {
				this.timeTravelSound.stop();
				this.timeTravelSound = null;
			}
		}
	}
	mpFinish() {
		this.playGui.setGuiVisibility(false);
		src_Console.instance.addEntry("log","State End");
		let pointercontainer = window.document.querySelector("#pointercontainer");
		pointercontainer.hidden = false;
		if(src_Util.isTouchDevice()) {
			src_MarbleGame.instance.touchInput.setControlsEnabled(false);
		}
		this.setCursorLock(false);
		if(net_Net.isHost) {
			src_MarbleGame.instance.quitMission();
		}
		return 0;
	}
	showFinishScreen() {
		if(this.isWatching) {
			return 0;
		}
		this.playGui.setGuiVisibility(false);
		src_Console.instance.addEntry("log","State End");
		let egg = null;
		let pointercontainer = window.document.querySelector("#pointercontainer");
		pointercontainer.hidden = false;
		let _gthis = this;
		this.schedule(this.timeState.currentAttemptTime + 3,function() {
			return _gthis.isRecording = false;
		},"stopRecordingTimeout");
		if(src_Util.isTouchDevice()) {
			src_MarbleGame.instance.touchInput.setControlsEnabled(false);
		}
		egg = new gui_EndGameGui(function(sender) {
			if(src_Util.isTouchDevice()) {
				src_MarbleGame.instance.touchInput.hideControls(_gthis.playGui.playGuiCtrl);
			}
			let endGameCode = function() {
				if(_gthis.isMultiplayer) {
					if(net_Net.isHost) {
						net_NetCommands.endGame();
						_gthis.dispose();
						gui_MultiplayerLevelSelectGui.currentSelectionStatic = _gthis.mission.index + 1;
						let pmg = new gui_MultiplayerLevelSelectGui(true);
						src_MarbleGame.canvas.setContent(pmg);
					}
					if(net_Net.isClient) {
						net_Net.disconnect();
						src_MarbleGame.instance.quitMission();
					}
				} else {
					_gthis.dispose();
					gui_LevelSelectGui.currentSelectionStatic = _gthis.mission.index + 1;
					let pmg = new gui_LevelSelectGui(["beginner","intermediate","advanced","multiplayer"][_gthis.mission.difficultyIndex]);
					src_MarbleGame.canvas.setContent(pmg);
				}
				return pointercontainer.hidden = false;
			};
			if(src_MarbleGame.instance.toRecord) {
				src_MarbleGame.canvas.pushDialog(new gui_ReplayNameDlg(endGameCode));
			} else {
				endGameCode();
			}
		},function(sender) {
			let restartGameCode = function() {
				src_MarbleGame.canvas.popDialog(egg);
				_gthis.playGui.setGuiVisibility(true);
				_gthis.restart(_gthis.marble,true);
				pointercontainer.hidden = true;
				if(src_Util.isTouchDevice()) {
					src_MarbleGame.instance.touchInput.setControlsEnabled(true);
				}
				if(_gthis.isMultiplayer) {
					net_NetCommands.restartGame();
				}
			};
			if(src_MarbleGame.instance.toRecord) {
				src_MarbleGame.canvas.pushDialog(new gui_ReplayNameDlg(function() {
					_gthis.isRecording = true;
					restartGameCode();
				}));
			} else {
				restartGameCode();
			}
		},function(sender) {
			let nextLevelCode = function() {
				let nextMission = _gthis.mission.getNextMission();
				if(nextMission != null) {
					src_MarbleGame.instance.playMission(nextMission);
				}
			};
			if(src_MarbleGame.instance.toRecord) {
				src_MarbleGame.canvas.pushDialog(new gui_ReplayNameDlg(nextLevelCode));
			} else {
				nextLevelCode();
			}
		},this.mission,this.gameMode.getFinishScore(),this.gameMode.getScoreType(),this.replay.write());
		src_MarbleGame.canvas.pushDialog(egg);
		this.setCursorLock(false);
		return 0;
	}
	pickUpPowerUpReplay(powerupIdent) {
		if(powerupIdent == null) {
			return false;
		}
		if(this.marble.heldPowerup != null) {
			if(this.marble.heldPowerup.identifier == powerupIdent) {
				return false;
			}
		}
		this.playGui.setPowerupImage(powerupIdent);
		return true;
	}
	pickUpPowerUp(marble,powerUp) {
		if(powerUp == null) {
			return false;
		}
		if(marble.heldPowerup != null) {
			if(marble.heldPowerup.identifier == powerUp.identifier) {
				return false;
			}
		}
		src_Console.instance.addEntry("log","PowerUp pickup: " + powerUp.identifier);
		marble.heldPowerup = powerUp;
		if(!marble.isNetUpdate) {
			marble.netFlags |= 8;
		}
		if(this.marble == marble) {
			this.playGui.setPowerupImage(powerUp.identifier);
			src_MarbleGame.instance.touchInput.powerupButton.setEnabled(true);
		}
		if(this.isRecording) {
			this.replay.recordPowerupPickup(powerUp);
		}
		return true;
	}
	deselectPowerUp(marble) {
		marble.heldPowerup = null;
		marble.netFlags |= 8;
		if(this.marble == marble) {
			this.playGui.setPowerupImage("");
			src_MarbleGame.instance.touchInput.powerupButton.setEnabled(false);
		}
	}
	addBonusTime(t) {
		this.bonusTime += t;
	}
	getOrientationQuat(time) {
		if(time < this.orientationChangeTime) {
			return this.oldOrientationQuat;
		}
		if(time > this.orientationChangeTime + 1.25) {
			return this.newOrientationQuat;
		}
		let value = (time - this.orientationChangeTime) / 0.8;
		let completion = value < 0 ? 0 : value > 1 ? 1 : value;
		let newDt = completion / 0.15;
		let smooth = 1.0 / (newDt * (newDt * 0.235 * newDt) + newDt + 1.0 + 0.48 * newDt * newDt);
		if(completion > 0.9) {
			smooth = 0.013326226012793176 + -0.013326226012793176 * ((completion - 0.9) * 10);
		}
		let _this = this.oldOrientationQuat;
		let q = new h3d_Quat(_this.x,_this.y,_this.z,_this.w);
		let q2 = this.newOrientationQuat;
		let v = 1 - smooth;
		let cosHalfTheta = q.x * q2.x + q.y * q2.y + q.z * q2.z + q.w * q2.w;
		if((cosHalfTheta < 0 ? -cosHalfTheta : cosHalfTheta) >= 1) {
			q.x = q.x;
			q.y = q.y;
			q.z = q.z;
			q.w = q.w;
		} else {
			let halfTheta = Math.acos(cosHalfTheta);
			let invSinHalfTheta = 1. / Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
			if((invSinHalfTheta < 0 ? -invSinHalfTheta : invSinHalfTheta) > 1e3) {
				let v = 0.5;
				if(q.x * q2.x + q.y * q2.y + q.z * q2.z + q.w * q2.w < 0) {
					v = -0.5;
				}
				let x = q.x * 0.5 + q2.x * v;
				let y = q.y * 0.5 + q2.y * v;
				let z = q.z * 0.5 + q2.z * v;
				let w = q.w * 0.5 + q2.w * v;
				q.x = x;
				q.y = y;
				q.z = z;
				q.w = w;
			} else {
				let a = Math.sin((1 - v) * halfTheta) * invSinHalfTheta;
				let b = Math.sin(v * halfTheta) * invSinHalfTheta * (cosHalfTheta < 0 ? -1 : 1);
				q.x = q.x * a + q2.x * b;
				q.y = q.y * a + q2.y * b;
				q.z = q.z * a + q2.z * b;
				q.w = q.w * a + q2.w * b;
			}
		}
		return q;
	}
	setUp(marble,vec,timeState,instant) {
		if(instant == null) {
			instant = false;
		}
		if(marble.currentUp == vec) {
			return;
		}
		if(this.isMultiplayer && net_Net.isHost) {
			marble.netFlags |= 16;
		}
		marble.currentUp = vec;
		if(marble == this.marble) {
			let currentQuat = this.getOrientationQuat(timeState.currentAttemptTime);
			let oldUp = new h3d_Vector(0,0,1);
			let m = null;
			m = new h3d_Matrix();
			let xx = currentQuat.x * currentQuat.x;
			let xy = currentQuat.x * currentQuat.y;
			let xz = currentQuat.x * currentQuat.z;
			let xw = currentQuat.x * currentQuat.w;
			let yy = currentQuat.y * currentQuat.y;
			let yz = currentQuat.y * currentQuat.z;
			let yw = currentQuat.y * currentQuat.w;
			let zz = currentQuat.z * currentQuat.z;
			let zw = currentQuat.z * currentQuat.w;
			m._11 = 1 - 2 * (yy + zz);
			m._12 = 2 * (xy + zw);
			m._13 = 2 * (xz - yw);
			m._14 = 0;
			m._21 = 2 * (xy - zw);
			m._22 = 1 - 2 * (xx + zz);
			m._23 = 2 * (yz + xw);
			m._24 = 0;
			m._31 = 2 * (xz + yw);
			m._32 = 2 * (yz - xw);
			m._33 = 1 - 2 * (xx + yy);
			m._34 = 0;
			m._41 = 0;
			m._42 = 0;
			m._43 = 0;
			m._44 = 1;
			let m1 = m;
			let px = oldUp.x * m1._11 + oldUp.y * m1._21 + oldUp.z * m1._31 + oldUp.w * m1._41;
			let py = oldUp.x * m1._12 + oldUp.y * m1._22 + oldUp.z * m1._32 + oldUp.w * m1._42;
			let pz = oldUp.x * m1._13 + oldUp.y * m1._23 + oldUp.z * m1._33 + oldUp.w * m1._43;
			let pw = oldUp.x * m1._14 + oldUp.y * m1._24 + oldUp.z * m1._34 + oldUp.w * m1._44;
			oldUp.x = px;
			oldUp.y = py;
			oldUp.z = pz;
			oldUp.w = pw;
			let getRotQuat = function(v1,v2) {
				let orthogonal = function(v) {
					let x = Math.abs(v.x);
					let y = Math.abs(v.y);
					let z = Math.abs(v.z);
					let other = x < y ? x < z ? new h3d_Vector(1,0,0) : new h3d_Vector(0,0,1) : y < z ? new h3d_Vector(0,1,0) : new h3d_Vector(0,0,1);
					return new h3d_Vector(v.y * other.z - v.z * other.y,v.z * other.x - v.x * other.z,v.x * other.y - v.y * other.x,1);
				};
				let k = v1.x * v1.x + v1.y * v1.y + v1.z * v1.z;
				if(k < 1e-10) {
					k = 0;
				} else {
					k = 1. / Math.sqrt(k);
				}
				let u = new h3d_Vector(v1.x * k,v1.y * k,v1.z * k);
				let k1 = v2.x * v2.x + v2.y * v2.y + v2.z * v2.z;
				if(k1 < 1e-10) {
					k1 = 0;
				} else {
					k1 = 1. / Math.sqrt(k1);
				}
				let x = v2.x * k1;
				let y = v2.y * k1;
				let z = v2.z * k1;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v_x = x;
				let v_y = y;
				let v_z = z;
				if(Math.abs(u.x * v_x + u.y * v_y + u.z * v_z + 1) < 1e-10) {
					let q = new h3d_Quat();
					let _this = orthogonal(u);
					let k = _this.x * _this.x + _this.y * _this.y + _this.z * _this.z;
					if(k < 1e-10) {
						k = 0;
					} else {
						k = 1. / Math.sqrt(k);
					}
					let x = _this.x * k;
					let y = _this.y * k;
					let z = _this.z * k;
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let o_x = x;
					let o_y = y;
					let o_z = z;
					q.x = o_x;
					q.y = o_y;
					q.z = o_z;
					q.w = 0;
					return q;
				}
				let x1 = u.x + v_x;
				let y1 = u.y + v_y;
				let z1 = u.z + v_z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let _this_x = x1;
				let _this_y = y1;
				let _this_z = z1;
				let k2 = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
				if(k2 < 1e-10) {
					k2 = 0;
				} else {
					k2 = 1. / Math.sqrt(k2);
				}
				let x2 = _this_x * k2;
				let y2 = _this_y * k2;
				let z2 = _this_z * k2;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let half_x = x2;
				let half_y = y2;
				let half_z = z2;
				let q = new h3d_Quat();
				q.w = u.x * half_x + u.y * half_y + u.z * half_z;
				let x3 = u.y * half_z - u.z * half_y;
				let y3 = u.z * half_x - u.x * half_z;
				let z3 = u.x * half_y - u.y * half_x;
				if(z3 == null) {
					z3 = 0.;
				}
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				let vr_x = x3;
				let vr_y = y3;
				let vr_z = z3;
				q.x = vr_x;
				q.y = vr_y;
				q.z = vr_z;
				return q;
			};
			let quatChange = getRotQuat(oldUp,vec);
			let x2 = quatChange.x * currentQuat.w + quatChange.w * currentQuat.x + quatChange.y * currentQuat.z - quatChange.z * currentQuat.y;
			let y2 = quatChange.w * currentQuat.y - quatChange.x * currentQuat.z + quatChange.y * currentQuat.w + quatChange.z * currentQuat.x;
			let z2 = quatChange.w * currentQuat.z + quatChange.x * currentQuat.y - quatChange.y * currentQuat.x + quatChange.z * currentQuat.w;
			let w2 = quatChange.w * currentQuat.w - quatChange.x * currentQuat.x - quatChange.y * currentQuat.y - quatChange.z * currentQuat.z;
			quatChange.x = x2;
			quatChange.y = y2;
			quatChange.z = z2;
			quatChange.w = w2;
			if(this.isRecording) {
				this.replay.recordGravity(vec,instant);
			}
			this.newOrientationQuat = quatChange;
			this.oldOrientationQuat = currentQuat;
			this.orientationChangeTime = instant ? -1e8 : timeState.currentAttemptTime;
		}
	}
	goOutOfBounds(marble) {
		if(marble.outOfBounds || this.finishTime != null) {
			return;
		}
		marble.outOfBounds = true;
		marble.outOfBoundsTime = this.timeState.clone();
		marble.camera.oob = true;
		if(!this.isWatching && !this.isMultiplayer) {
			src_Settings.playStatistics.oobs++;
			if(!Object.prototype.hasOwnProperty.call(src_Settings.levelStatistics.h,this.mission.path)) {
				src_Settings.levelStatistics.h[this.mission.path] = { oobs : 1, respawns : 0, totalTime : 0, totalMPScore : 0};
			} else {
				let fh = src_Settings.levelStatistics.h[this.mission.path];
				fh.oobs++;
			}
		}
		let _gthis = this;
		if(marble == this.marble) {
			this.playGui.setCenterText("Out of Bounds");
			this.oobSchedule = this.schedule(this.timeState.currentAttemptTime + 2,function() {
				_gthis.playGui.setCenterText("");
				return null;
			});
		}
		if(!this.isMultiplayer || net_Net.isHost) {
			marble.oobSchedule = this.schedule(this.timeState.currentAttemptTime + 2.5,function() {
				_gthis.restart(marble);
				return null;
			});
		}
	}
	saveCheckpointState(shape,trigger) {
		let disableOob = false;
		let isSame = this.currentCheckpoint == shape;
		if(trigger != null) {
			disableOob = trigger.disableOOB;
			if(this.checkpointSequence > trigger.seqNum) {
				return false;
			}
		}
		this.checkpointSequence = trigger.seqNum;
		if(disableOob && this.marble.outOfBounds) {
			return false;
		}
		this.currentCheckpoint = shape;
		this.currentCheckpointTrigger = trigger;
		this.checkpointCollectedGems.h = { __keys__ : { }};
		this.cheeckpointBlast = this.marble.blastAmount;
		let _g = 0;
		let _g1 = this.gems;
		while(_g < _g1.length) {
			let gem = _g1[_g];
			++_g;
			if(gem.pickedUp) {
				this.checkpointCollectedGems.set(gem,true);
			}
		}
		this.checkpointHeldPowerup = this.marble.heldPowerup;
		if(!isSame) {
			src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/checkpoint.wav",src_ResourceLoader.getAudio,this.soundResources));
		}
		return true;
	}
	loadCheckpointState() {
		let marble = this.marble;
		let offset_x = 0;
		let offset_y = 0;
		let offset_z = 0.727843;
		let offset_w = 1.;
		let _this = this.currentCheckpoint.getRotationQuat();
		let m = null;
		m = new h3d_Matrix();
		let xx = _this.x * _this.x;
		let xy = _this.x * _this.y;
		let xz = _this.x * _this.z;
		let xw = _this.x * _this.w;
		let yy = _this.y * _this.y;
		let yz = _this.y * _this.z;
		let yw = _this.y * _this.w;
		let zz = _this.z * _this.z;
		let zw = _this.z * _this.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		let m1 = m;
		let px = offset_x * m1._11 + offset_y * m1._21 + 0.727843 * m1._31 + m1._41;
		let py = offset_x * m1._12 + offset_y * m1._22 + 0.727843 * m1._32 + m1._42;
		let pz = offset_x * m1._13 + offset_y * m1._23 + 0.727843 * m1._33 + m1._43;
		let pw = offset_x * m1._14 + offset_y * m1._24 + 0.727843 * m1._34 + m1._44;
		offset_x = px;
		offset_y = py;
		offset_z = pz;
		offset_w = pw;
		let _this1 = this.currentCheckpoint.getAbsPos();
		let _this_x = 0.;
		let _this_y = 0.;
		let _this_z = 0.;
		let _this_w = 1.;
		let x = _this1._41;
		let y = _this1._42;
		let z = _this1._43;
		let w = _this1._44;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		_this_x = x;
		_this_y = y;
		_this_z = z;
		_this_w = w;
		let mpos = new h3d_Vector(_this_x + offset_x,_this_y + offset_y,_this_z + offset_z,_this_w + offset_w);
		this.marble.setMarblePosition(mpos.x,mpos.y,mpos.z);
		let _this2 = marble.velocity;
		let v_x = 0;
		let v_y = 0;
		let v_z = 0;
		_this2.x = v_x;
		_this2.y = v_y;
		_this2.z = v_z;
		_this2.w = 1.;
		let _this3 = marble.omega;
		let v_x1 = 0;
		let v_y1 = 0;
		let v_z1 = 0;
		_this3.x = v_x1;
		_this3.y = v_y1;
		_this3.z = v_z1;
		_this3.w = 1.;
		src_Console.instance.addEntry("log","Respawn:");
		src_Console.instance.addEntry("log","Marble Position: " + mpos.x + " " + mpos.y + " " + mpos.z);
		src_Console.instance.addEntry("log","Marble Velocity: " + marble.velocity.x + " " + marble.velocity.y + " " + marble.velocity.z);
		src_Console.instance.addEntry("log","Marble Angular: " + marble.omega.x + " " + marble.omega.y + " " + marble.omega.z);
		let _this4 = this.currentCheckpoint.getRotationQuat();
		let m2 = null;
		m2 = new h3d_Matrix();
		let xx1 = _this4.x * _this4.x;
		let xy1 = _this4.x * _this4.y;
		let xz1 = _this4.x * _this4.z;
		let xw1 = _this4.x * _this4.w;
		let yy1 = _this4.y * _this4.y;
		let yz1 = _this4.y * _this4.z;
		let yw1 = _this4.y * _this4.w;
		let zz1 = _this4.z * _this4.z;
		let zw1 = _this4.z * _this4.w;
		m2._11 = 1 - 2 * (yy1 + zz1);
		m2._12 = 2 * (xy1 + zw1);
		m2._13 = 2 * (xz1 - yw1);
		m2._14 = 0;
		m2._21 = 2 * (xy1 - zw1);
		m2._22 = 1 - 2 * (xx1 + zz1);
		m2._23 = 2 * (yz1 + xw1);
		m2._24 = 0;
		m2._31 = 2 * (xz1 + yw1);
		m2._32 = 2 * (yz1 - xw1);
		m2._33 = 1 - 2 * (xx1 + yy1);
		m2._34 = 0;
		m2._41 = 0;
		m2._42 = 0;
		m2._43 = 0;
		m2._44 = 1;
		let euler = m2.getEulerAngles();
		this.marble.camera.CameraYaw = euler.z + Math.PI / 2;
		this.marble.camera.CameraPitch = 0.45;
		this.marble.camera.nextCameraYaw = this.marble.camera.CameraYaw;
		this.marble.camera.nextCameraPitch = this.marble.camera.CameraPitch;
		this.marble.camera.oob = false;
		this.marble.helicopterEnableTime = -1e8;
		this.marble.megaMarbleEnableTime = -1e8;
		this.marble.blastAmount = this.cheeckpointBlast;
		if(this.isRecording) {
			this.replay.recordCameraState(this.marble.camera.CameraYaw,this.marble.camera.CameraPitch);
			this.replay.recordMarbleInput(0,0);
			this.replay.recordMarbleState(mpos,marble.velocity,marble.getRotationQuat(),marble.omega);
			this.replay.recordMarbleStateFlags(false,false,true,false);
		}
		if(this.currentCheckpointTrigger != null) {
			Object.prototype.hasOwnProperty.call(this.currentCheckpointTrigger.element.fields.h,"gravity");
		}
		let up = new h3d_Vector(0,0,1);
		let _this5 = this.currentCheckpoint.getRotationQuat();
		let m3 = null;
		m3 = new h3d_Matrix();
		let xx2 = _this5.x * _this5.x;
		let xy2 = _this5.x * _this5.y;
		let xz2 = _this5.x * _this5.z;
		let xw2 = _this5.x * _this5.w;
		let yy2 = _this5.y * _this5.y;
		let yz2 = _this5.y * _this5.z;
		let yw2 = _this5.y * _this5.w;
		let zz2 = _this5.z * _this5.z;
		let zw2 = _this5.z * _this5.w;
		m3._11 = 1 - 2 * (yy2 + zz2);
		m3._12 = 2 * (xy2 + zw2);
		m3._13 = 2 * (xz2 - yw2);
		m3._14 = 0;
		m3._21 = 2 * (xy2 - zw2);
		m3._22 = 1 - 2 * (xx2 + zz2);
		m3._23 = 2 * (yz2 + xw2);
		m3._24 = 0;
		m3._31 = 2 * (xz2 + yw2);
		m3._32 = 2 * (yz2 - xw2);
		m3._33 = 1 - 2 * (xx2 + yy2);
		m3._34 = 0;
		m3._41 = 0;
		m3._42 = 0;
		m3._43 = 0;
		m3._44 = 1;
		let m4 = m3;
		let px1 = up.x * m4._11 + up.y * m4._21 + up.z * m4._31 + up.w * m4._41;
		let py1 = up.x * m4._12 + up.y * m4._22 + up.z * m4._32 + up.w * m4._42;
		let pz1 = up.x * m4._13 + up.y * m4._23 + up.z * m4._33 + up.w * m4._43;
		let pw1 = up.x * m4._14 + up.y * m4._24 + up.z * m4._34 + up.w * m4._44;
		up.x = px1;
		up.y = py1;
		up.z = pz1;
		up.w = pw1;
		this.setUp(marble,up,this.timeState,true);
		let _g = 0;
		let _g1 = this.gems;
		while(_g < _g1.length) {
			let gem = _g1[_g];
			++_g;
			if(gem.pickedUp && this.checkpointCollectedGems.h.__keys__[gem.__id__] == null) {
				gem.reset();
				this.gemCount--;
			}
		}
		this.playGui.formatGemCounter(this.gemCount,this.totalGems);
		this.playGui.setCenterText("");
		this.clearSchedule();
		this.marble.outOfBounds = false;
		this.deselectPowerUp(this.marble);
		if(this.checkpointHeldPowerup != null) {
			let powerup = this.checkpointHeldPowerup;
			this.pickUpPowerUp(this.marble,powerup);
		}
		src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/spawn_alternate.wav",src_ResourceLoader.getAudio,this.soundResources));
	}
	setCursorLock(enabled) {
		this.cursorLock = enabled;
		if(enabled) {
			if(this.marble != null) {
				this.marble.camera.lockCursor();
			}
		} else if(this.marble != null) {
			this.marble.camera.unlockCursor();
		}
	}
	saveReplay() {
		this.replay.name = src_MarbleGame.instance.recordingName;
		let replayBytes = this.replay.write();
		let blob = new Blob([replayBytes.b.bufferValue],{ type : "application/octet-stream"});
		let url = URL.createObjectURL(blob);
		let fname = "" + this.replay.name + ".mbr";
		let element = window.document.createElement("a");
		element.setAttribute("href",url);
		element.setAttribute("download",fname);
		element.style.display = "none";
		window.document.body.appendChild(element);
		element.click();
		window.document.body.removeChild(element);
		URL.revokeObjectURL(url);
	}
	dispose() {
		if(!this.isWatching) {
			src_Settings.playStatistics.totalTime += this.timeState.timeSinceLoad;
			if(!Object.prototype.hasOwnProperty.call(src_Settings.levelStatistics.h,this.mission.path)) {
				src_Settings.levelStatistics.h[this.mission.path] = { oobs : 0, respawns : 0, totalTime : this.timeState.timeSinceLoad, totalMPScore : 0};
			} else {
				src_Settings.levelStatistics.h[this.mission.path].totalTime += this.timeState.timeSinceLoad;
			}
		}
		collision_CollisionPool.freeMemory();
		this.radar.dispose();
		if(this.playGui != null) {
			this.playGui.dispose();
		}
		this.scene.removeChildren();
		let _g = 0;
		let _g1 = this.interiors;
		while(_g < _g1.length) {
			let interior = _g1[_g];
			++_g;
			interior.dispose();
		}
		this.interiors = null;
		let _g2 = 0;
		let _g3 = this.pathedInteriors;
		while(_g2 < _g3.length) {
			let pathedInteriors = _g3[_g2];
			++_g2;
			pathedInteriors.dispose();
		}
		this.pathedInteriors = null;
		let _g4 = 0;
		let _g5 = this.marbles;
		while(_g4 < _g5.length) {
			let marble = _g5[_g4];
			++_g4;
			marble.dispose();
		}
		this.clientMarbles = null;
		let _g6 = 0;
		let _g7 = this.dtsObjects;
		while(_g6 < _g7.length) {
			let dtsObject = _g7[_g6];
			++_g6;
			dtsObject.dispose();
		}
		this.dtsObjects = null;
		src_DtsObject.disposeShared();
		this.powerUps = [];
		let _g8 = 0;
		let _g9 = this.triggers;
		while(_g8 < _g9.length) {
			let trigger = _g9[_g8];
			++_g8;
			trigger.dispose();
		}
		this.triggers = null;
		let _g10 = 0;
		let _g11 = this.soundResources;
		while(_g10 < _g11.length) {
			let soundResource = _g11[_g10];
			++_g10;
			soundResource.release();
		}
		let _g12 = 0;
		let _g13 = this.textureResources;
		while(_g12 < _g13.length) {
			let textureResource = _g13[_g12];
			++_g12;
			textureResource.release();
		}
		this.gems = null;
		if(this.sky != null) {
			this.sky.dispose();
		}
		this.sky = null;
		this.instanceManager = null;
		this.collisionWorld.dispose();
		this.collisionWorld = null;
		this.particleManager = null;
		this.namedObjects = null;
		this.shapeOrTriggerInside = null;
		this.shapeImmunity = null;
		this.currentCheckpoint = null;
		this.checkpointCollectedGems = null;
		this.marble = null;
		this._disposed = true;
		src_AudioManager.stopAllSounds();
	}
}
$hxClasses["src.MarbleWorld"] = src_MarbleWorld;
src_MarbleWorld.__name__ = "src.MarbleWorld";
src_MarbleWorld.__super__ = src_Scheduler;
Object.assign(src_MarbleWorld.prototype, {
	__class__: src_MarbleWorld
	,collisionWorld: null
	,instanceManager: null
	,particleManager: null
	,playGui: null
	,loadingGui: null
	,radar: null
	,interiors: null
	,pathedInteriors: null
	,marbles: null
	,dtsObjects: null
	,powerUps: null
	,forceObjects: null
	,triggers: null
	,gems: null
	,namedObjects: null
	,simGroups: null
	,shapeImmunity: null
	,shapeOrTriggerInside: null
	,timeState: null
	,bonusTime: null
	,sky: null
	,endPadElement: null
	,endPad: null
	,skyElement: null
	,gameMode: null
	,ambient: null
	,dirLight: null
	,dirLightDir: null
	,scene: null
	,scene2d: null
	,mission: null
	,game: null
	,marble: null
	,finishTime: null
	,finishPitch: null
	,finishYaw: null
	,totalGems: null
	,gemCount: null
	,skipStartBugPauseTime: null
	,renderBlastAmount: null
	,cursorLock: null
	,timeTravelSound: null
	,helpTextTimeState: null
	,alertTextTimeState: null
	,respawnPressedTime: null
	,orientationChangeTime: null
	,oldOrientationQuat: null
	,newOrientationQuat: null
	,currentCheckpoint: null
	,currentCheckpointTrigger: null
	,checkpointCollectedGems: null
	,checkpointHeldPowerup: null
	,cheeckpointBlast: null
	,checkpointSequence: null
	,replay: null
	,isWatching: null
	,isRecording: null
	,rewindManager: null
	,rewinding: null
	,rewindUsed: null
	,inputRecorder: null
	,isReplayingMovement: null
	,currentInputMoves: null
	,isMultiplayer: null
	,serverStartTicks: null
	,startTime: null
	,multiplayerStarted: null
	,tickAccumulator: null
	,clientMarbles: null
	,predictions: null
	,powerupPredictions: null
	,gemPredictions: null
	,lastMoves: null
	,resourceLoadFuncs: null
	,_disposed: null
	,_ready: null
	,_loadBegin: null
	,_loadingLength: null
	,_resourcesLoaded: null
	,textureResources: null
	,soundResources: null
	,oobSchedule: null
	,_instancesNeedsUpdate: null
	,lock: null
	,postInited: null
});
class src_Marbleland {
	static download(id,cb) {
		src_Http.get("https://marbleland.vaniverse.io/api/level/" + id + "/zip?assuming=none",function(zipData) {
			let reader = new haxe_zip_Reader(new haxe_io_BytesInput(zipData));
			let entries = null;
			try {
				let _g = [];
				let _g_head = reader.read().h;
				while(_g_head != null) {
					let val = _g_head.item;
					_g_head = _g_head.next;
					_g.push(val);
				}
				entries = _g;
			} catch( _g ) {
			}
			cb(entries);
		},function(e) {
			cb(null);
		});
	}
}
$hxClasses["src.Marbleland"] = src_Marbleland;
src_Marbleland.__name__ = "src.Marbleland";
class src__$MeshBatch_BatchData {
	constructor() {
		this.buffers = [];
	}
}
$hxClasses["src._MeshBatch.BatchData"] = src__$MeshBatch_BatchData;
src__$MeshBatch_BatchData.__name__ = "src._MeshBatch.BatchData";
Object.assign(src__$MeshBatch_BatchData.prototype, {
	__class__: src__$MeshBatch_BatchData
	,paramsCount: null
	,maxInstance: null
	,matIndex: null
	,indexCount: null
	,indexStart: null
	,instanceBuffers: null
	,buffers: null
	,data: null
	,params: null
	,shader: null
	,shaders: null
	,pass: null
	,next: null
});
class src_MeshBatchPart {
	constructor() {
	}
}
$hxClasses["src.MeshBatchPart"] = src_MeshBatchPart;
src_MeshBatchPart.__name__ = "src.MeshBatchPart";
Object.assign(src_MeshBatchPart.prototype, {
	__class__: src_MeshBatchPart
	,indexStart: null
	,indexCount: null
	,baseVertex: null
});
class src_MeshBatch extends h3d_scene_MultiMaterial {
	constructor(primitive,material,parent) {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(primitive,material,parent);
	}
	_hx_constructor(primitive,material,parent) {
		this.calcBounds = true;
		this.instanceCount = 0;
		this.shadersChanged = true;
		this.needUpload = false;
		this.instanced = new h3d_prim_Instanced();
		this.instanced.commands = new h3d_impl_InstanceBuffer();
		this.instanced.setMesh(primitive);
		super._hx_constructor(this.instanced,material == null ? null : [material],parent);
		let _g = 0;
		let _g1 = this.material.getPasses();
		while(_g < _g1.length) {
			let p = _g1[_g];
			++_g;
			p.set_batchMode(true);
		}
	}
	onRemove() {
		super.onRemove();
		this.cleanPasses();
	}
	cleanPasses() {
		let alloc = hxd_impl_Allocator.get();
		while(this.dataPasses != null) {
			this.dataPasses.pass.removeShader(this.dataPasses.shader);
			let _g = 0;
			let _g1 = this.dataPasses.buffers;
			while(_g < _g1.length) {
				let b = _g1[_g];
				++_g;
				alloc.disposeBuffer(b);
			}
			if(this.dataPasses.instanceBuffers != null) {
				let _g = 0;
				let _g1 = this.dataPasses.instanceBuffers;
				while(_g < _g1.length) {
					let b = _g1[_g];
					++_g;
					b.dispose();
				}
			}
			alloc.disposeFloats(this.dataPasses.data);
			this.dataPasses = this.dataPasses.next;
		}
		if(this.instanced.commands != null) {
			this.instanced.commands.dispose();
		}
		this.shadersChanged = true;
	}
	initShadersMapping() {
		let scene = this.getScene();
		if(scene == null) {
			return;
		}
		this.cleanPasses();
		let _g = 0;
		let _g1 = this.materials.length;
		while(_g < _g1) {
			let index = _g++;
			let mat = this.materials[index];
			if(mat == null) {
				continue;
			}
			let matInfo = this.instanced.primitive.getMaterialIndexes(index);
			let _g1 = 0;
			let _g2 = mat.getPasses();
			while(_g1 < _g2.length) {
				let p = _g2[_g1];
				++_g1;
				let ctx = scene.renderer.getPassByName(p.name);
				if(ctx == null) {
					throw haxe_Exception.thrown("Could't find renderer pass " + p.name);
				}
				let manager = (js_Boot.__cast(ctx , shaders_RendererDefaultPass)).manager;
				let shaders = p.getShadersRec();
				let rt = manager.compileShaders(shaders,false);
				let shader = manager.shaderCache.makeBatchShader(rt,shaders,this.instancedParams);
				let b = new src__$MeshBatch_BatchData();
				b.indexCount = matInfo.count;
				b.indexStart = matInfo.start;
				b.paramsCount = shader.paramsSize;
				b.maxInstance = src_MeshBatch.MAX_BUFFER_ELEMENTS / b.paramsCount | 0;
				if(b.maxInstance <= 0) {
					throw haxe_Exception.thrown("Mesh batch shaders needs at least one perInstance parameter");
				}
				b.params = shader.params;
				b.shader = shader;
				b.pass = p;
				b.matIndex = index;
				b.shaders = [null];
				p.set_dynamicParameters(true);
				p.set_batchMode(true);
				b.next = this.dataPasses;
				this.dataPasses = b;
				let sl = shaders;
				while(sl != null) {
					b.shaders.push(sl.s);
					sl = sl.next;
				}
				shader.constModified = true;
				shader.Batch_Count__ = b.maxInstance * b.paramsCount;
				shader.constModified = true;
				shader.Batch_HasOffset__ = this.primitiveSubPart != null;
				shader.constBits = shader.Batch_Count__ << 1 | (shader.Batch_HasOffset__ ? 1 : 0);
				shader.updateConstants(null);
			}
		}
		let p = this.dataPasses;
		while(p != null) {
			p.pass.addSelfShader(p.shader);
			p = p.next;
		}
	}
	begin(emitCountTip,resizeDown) {
		if(resizeDown == null) {
			resizeDown = false;
		}
		if(emitCountTip == null) {
			emitCountTip = -1;
		}
		this.instanceCount = 0;
		this.instanced.initBounds();
		if(this.shadersChanged) {
			this.initShadersMapping();
			this.shadersChanged = false;
		}
		if(emitCountTip < 0) {
			emitCountTip = 128;
		}
		let p = this.dataPasses;
		let alloc = hxd_impl_Allocator.get();
		while(p != null) {
			let size = emitCountTip * p.paramsCount * 4;
			if(p.data == null || p.data.pos < size || resizeDown && p.data.pos > size << 1) {
				if(p.data != null) {
					alloc.disposeFloats(p.data);
				}
				p.data = alloc.allocFloats(size);
			}
			p = p.next;
		}
	}
	syncData(batch) {
		let startPos = batch.paramsCount * this.instanceCount << 2;
		if(startPos + (batch.paramsCount << 2) > batch.data.pos) {
			let this1 = batch.data;
			let v = batch.data.pos << 1;
			let _g = this1.pos;
			while(_g < v) {
				++_g;
				if(this1.pos == this1.array.length) {
					let newSize = this1.array.length << 1;
					if(newSize < 128) {
						newSize = 128;
					}
					let newArray = new Float32Array(newSize);
					newArray.set(this1.array);
					this1.array = newArray;
				}
				this1.array[this1.pos++] = 0.;
			}
		}
		let p = batch.params;
		let buf = batch.data;
		let shaders = batch.shaders;
		let calcInv = false;
		while(p != null) {
			let pos = startPos + p.pos;
			if(p.perObjectGlobal != null) {
				if(p.perObjectGlobal.gid == src_MeshBatch.modelViewID) {
					let m = this.worldPosition != null ? this.worldPosition : this.absPos;
					buf.array[pos++] = m._11;
					buf.array[pos++] = m._21;
					buf.array[pos++] = m._31;
					buf.array[pos++] = m._41;
					buf.array[pos++] = m._12;
					buf.array[pos++] = m._22;
					buf.array[pos++] = m._32;
					buf.array[pos++] = m._42;
					buf.array[pos++] = m._13;
					buf.array[pos++] = m._23;
					buf.array[pos++] = m._33;
					buf.array[pos++] = m._43;
					buf.array[pos++] = m._14;
					buf.array[pos++] = m._24;
					buf.array[pos++] = m._34;
					buf.array[pos++] = m._44;
				} else if(p.perObjectGlobal.gid == src_MeshBatch.modelViewInverseID) {
					if(this.worldPosition == null) {
						let m = this.getInvPos();
						buf.array[pos++] = m._11;
						buf.array[pos++] = m._21;
						buf.array[pos++] = m._31;
						buf.array[pos++] = m._41;
						buf.array[pos++] = m._12;
						buf.array[pos++] = m._22;
						buf.array[pos++] = m._32;
						buf.array[pos++] = m._42;
						buf.array[pos++] = m._13;
						buf.array[pos++] = m._23;
						buf.array[pos++] = m._33;
						buf.array[pos++] = m._43;
						buf.array[pos++] = m._14;
						buf.array[pos++] = m._24;
						buf.array[pos++] = m._34;
						buf.array[pos++] = m._44;
					} else {
						if(!calcInv) {
							calcInv = true;
							if(this.invWorldPosition == null) {
								this.invWorldPosition = new h3d_Matrix();
							}
							this.invWorldPosition.initInverse(this.worldPosition);
						}
						let m = this.invWorldPosition;
						buf.array[pos++] = m._11;
						buf.array[pos++] = m._21;
						buf.array[pos++] = m._31;
						buf.array[pos++] = m._41;
						buf.array[pos++] = m._12;
						buf.array[pos++] = m._22;
						buf.array[pos++] = m._32;
						buf.array[pos++] = m._42;
						buf.array[pos++] = m._13;
						buf.array[pos++] = m._23;
						buf.array[pos++] = m._33;
						buf.array[pos++] = m._43;
						buf.array[pos++] = m._14;
						buf.array[pos++] = m._24;
						buf.array[pos++] = m._34;
						buf.array[pos++] = m._44;
					}
				} else if(p.perObjectGlobal.gid == src_MeshBatch.modelViewTransposeID) {
					let m = this.worldPosition != null ? this.worldPosition : this.absPos;
					m.transpose();
					buf.array[pos++] = m._11;
					buf.array[pos++] = m._21;
					buf.array[pos++] = m._31;
					buf.array[pos++] = m._41;
					buf.array[pos++] = m._12;
					buf.array[pos++] = m._22;
					buf.array[pos++] = m._32;
					buf.array[pos++] = m._42;
					buf.array[pos++] = m._13;
					buf.array[pos++] = m._23;
					buf.array[pos++] = m._33;
					buf.array[pos++] = m._43;
					buf.array[pos++] = m._14;
					buf.array[pos++] = m._24;
					buf.array[pos++] = m._34;
					buf.array[pos++] = m._44;
					m.transpose();
				} else {
					throw haxe_Exception.thrown("Unsupported global param " + p.perObjectGlobal.path);
				}
				p = p.next;
				continue;
			}
			let curShader = shaders[p.instance];
			let _g = p.type;
			switch(_g._hx_index) {
			case 3:
				let value = curShader.getParamFloatValue(p.index);
				buf.array[pos++] = value;
				break;
			case 5:
				let v = curShader.getParamValue(p.index);
				switch(_g.size) {
				case 2:
					buf.array[pos++] = v.x;
					buf.array[pos++] = v.y;
					break;
				case 3:
					buf.array[pos++] = v.x;
					buf.array[pos++] = v.y;
					buf.array[pos++] = v.z;
					break;
				default:
					buf.array[pos++] = v.x;
					buf.array[pos++] = v.y;
					buf.array[pos++] = v.z;
					buf.array[pos++] = v.w;
				}
				break;
			case 7:
				let m = curShader.getParamValue(p.index);
				buf.array[pos++] = m._11;
				buf.array[pos++] = m._21;
				buf.array[pos++] = m._31;
				buf.array[pos++] = m._41;
				buf.array[pos++] = m._12;
				buf.array[pos++] = m._22;
				buf.array[pos++] = m._32;
				buf.array[pos++] = m._42;
				buf.array[pos++] = m._13;
				buf.array[pos++] = m._23;
				buf.array[pos++] = m._33;
				buf.array[pos++] = m._43;
				buf.array[pos++] = m._14;
				buf.array[pos++] = m._24;
				buf.array[pos++] = m._34;
				buf.array[pos++] = m._44;
				break;
			default:
				throw haxe_Exception.thrown("Unsupported batch type " + Std.string(p.type));
			}
			p = p.next;
		}
		this.needUpload = true;
	}
	addBoundsRec(b,relativeTo) {
		let old = this.primitive;
		this.set_primitive(null);
		super.addBoundsRec(b,relativeTo);
		this.set_primitive(old);
		if(this.primitive == null || (this.flags & 512) != 0) {
			return;
		}
		let bounds = this.primitive.getBounds();
		if(relativeTo == null) {
			if(bounds.xMin < b.xMin) {
				b.xMin = bounds.xMin;
			}
			if(bounds.xMax > b.xMax) {
				b.xMax = bounds.xMax;
			}
			if(bounds.yMin < b.yMin) {
				b.yMin = bounds.yMin;
			}
			if(bounds.yMax > b.yMax) {
				b.yMax = bounds.yMax;
			}
			if(bounds.zMin < b.zMin) {
				b.zMin = bounds.zMin;
			}
			if(bounds.zMax > b.zMax) {
				b.zMax = bounds.zMax;
			}
		} else {
			let b1 = new h3d_col_Bounds();
			b1.xMin = bounds.xMin;
			b1.xMax = bounds.xMax;
			b1.yMin = bounds.yMin;
			b1.yMax = bounds.yMax;
			b1.zMin = bounds.zMin;
			b1.zMax = bounds.zMax;
			b1.transform(relativeTo);
			if(b1.xMin < b.xMin) {
				b.xMin = b1.xMin;
			}
			if(b1.xMax > b.xMax) {
				b.xMax = b1.xMax;
			}
			if(b1.yMin < b.yMin) {
				b.yMin = b1.yMin;
			}
			if(b1.yMax > b.yMax) {
				b.yMax = b1.yMax;
			}
			if(b1.zMin < b.zMin) {
				b.zMin = b1.zMin;
			}
			if(b1.zMax > b.zMax) {
				b.zMax = b1.zMax;
			}
		}
	}
	emitInstance() {
		if(this.worldPosition == null) {
			this.syncPos();
		}
		let ps = this.primitiveSubPart;
		if(ps != null) {
			if(this.primitiveSubBytes == null) {
				this.primitiveSubBytes = new haxe_io_Bytes(new ArrayBuffer(128));
				this.instanced.commands = null;
			}
			if(this.primitiveSubBytes.length < (this.instanceCount + 1) * 20) {
				let next = new haxe_io_Bytes(new ArrayBuffer(this.primitiveSubBytes.length * 3 / 2 | 0));
				next.blit(0,this.primitiveSubBytes,0,this.instanceCount * 20);
				this.primitiveSubBytes = next;
			}
			let p = this.instanceCount * 20;
			this.primitiveSubBytes.setInt32(p,ps.indexCount);
			this.primitiveSubBytes.setInt32(p + 4,1);
			this.primitiveSubBytes.setInt32(p + 8,ps.indexStart);
			this.primitiveSubBytes.setInt32(p + 12,ps.baseVertex);
			this.primitiveSubBytes.setInt32(p + 16,0);
		} else if(this.calcBounds) {
			let _this = this.instanced;
			let absPos = this.worldPosition == null ? this.absPos : this.worldPosition;
			_this.tmpBounds.load(_this.baseBounds);
			_this.tmpBounds.transform(absPos);
			let _this1 = _this.bounds;
			let b = _this.tmpBounds;
			if(b.xMin < _this1.xMin) {
				_this1.xMin = b.xMin;
			}
			if(b.xMax > _this1.xMax) {
				_this1.xMax = b.xMax;
			}
			if(b.yMin < _this1.yMin) {
				_this1.yMin = b.yMin;
			}
			if(b.yMax > _this1.yMax) {
				_this1.yMax = b.yMax;
			}
			if(b.zMin < _this1.zMin) {
				_this1.zMin = b.zMin;
			}
			if(b.zMax > _this1.zMax) {
				_this1.zMax = b.zMax;
			}
		}
		let p = this.dataPasses;
		while(p != null) {
			this.syncData(p);
			p = p.next;
		}
		this.instanceCount++;
	}
	sync(ctx) {
		super.sync(ctx);
		if(this.instanceCount == 0) {
			return;
		}
		let p = this.dataPasses;
		let alloc = hxd_impl_Allocator.get();
		let psBytes = this.primitiveSubBytes;
		while(p != null) {
			let index = 0;
			let start = 0;
			while(start < this.instanceCount) {
				let upload = this.needUpload;
				let buf = p.buffers[index];
				let count = this.instanceCount - start;
				if(count > p.maxInstance) {
					count = p.maxInstance;
				}
				if(buf == null || (buf.buffer == null || buf.buffer.vbuf == null)) {
					buf = alloc.allocBuffer(src_MeshBatch.MAX_BUFFER_ELEMENTS,4,1);
					p.buffers[index] = buf;
					upload = true;
				}
				if(upload) {
					buf.uploadVector(p.data,start * p.paramsCount * 4,count * p.paramsCount);
				}
				if(psBytes != null) {
					if(p.instanceBuffers == null) {
						p.instanceBuffers = [];
					}
					let buf = p.instanceBuffers[index];
					if(buf == null) {
						buf = new h3d_impl_InstanceBuffer();
						let sub = psBytes.sub(start * 20,count * 20);
						let _g = 0;
						let _g1 = count;
						while(_g < _g1) {
							let i = _g++;
							sub.setInt32(i * 20 + 16,i);
						}
						buf.setBuffer(count,sub);
						p.instanceBuffers[index] = buf;
					}
				}
				start += count;
				++index;
			}
			while(p.buffers.length > index) alloc.disposeBuffer(p.buffers.pop());
			p = p.next;
		}
		if(psBytes != null) {
			let prim = js_Boot.__cast(this.primitive , h3d_prim_MeshPrimitive);
			let offsets = prim.getBuffer("Batch_Start");
			if(offsets == null || offsets.vertices < this.instanceCount || (offsets.buffer == null || offsets.buffer.vbuf == null)) {
				if(offsets != null) {
					offsets.dispose();
				}
				let tmp = new haxe_io_Bytes(new ArrayBuffer(4 * this.instanceCount));
				let _g = 0;
				let _g1 = this.instanceCount;
				while(_g < _g1) {
					let i = _g++;
					tmp.setFloat(i << 2,i);
				}
				offsets = new h3d_Buffer(this.instanceCount,1);
				offsets.uploadBytes(tmp,0,this.instanceCount);
				prim.addBuffer("Batch_Start",offsets);
			}
		}
		this.needUpload = false;
	}
	draw(ctx) {
		let p = this.dataPasses;
		while(true) {
			if(p.pass == ctx.drawPass.pass) {
				let bufferIndex = ctx.drawPass.index & 65535;
				p.shader.Batch_Buffer__ = p.buffers[bufferIndex];
				if(p.instanceBuffers == null) {
					let count = this.instanceCount - p.maxInstance * bufferIndex;
					this.instanced.commands.setCommand(count,p.indexCount,p.indexStart);
				} else {
					this.instanced.commands = p.instanceBuffers[bufferIndex];
				}
				break;
			}
			p = p.next;
		}
		ctx.uploadParams();
		let prev = ctx.drawPass.index;
		ctx.drawPass.index >>= 16;
		super.draw(ctx);
		ctx.drawPass.index = prev;
	}
	emit(ctx) {
		if(this.instanceCount == 0) {
			return;
		}
		let p = this.dataPasses;
		while(p != null) {
			let pass = p.pass;
			let material = this.materials[p.matIndex];
			if(material != null && material.getPass(pass.name) != null) {
				let _g = 0;
				let _g1 = p.buffers.length;
				while(_g < _g1) {
					let i = _g++;
					let tmp = p.matIndex << 16;
					ctx.emitPass(pass,this).index = i | tmp;
				}
			}
			p = p.next;
		}
	}
}
$hxClasses["src.MeshBatch"] = src_MeshBatch;
src_MeshBatch.__name__ = "src.MeshBatch";
src_MeshBatch.__super__ = h3d_scene_MultiMaterial;
Object.assign(src_MeshBatch.prototype, {
	__class__: src_MeshBatch
	,instanced: null
	,dataPasses: null
	,needUpload: null
	,shadersChanged: null
	,instanceCount: null
	,worldPosition: null
	,invWorldPosition: null
	,primitiveSubPart: null
	,primitiveSubBytes: null
	,calcBounds: null
	,instancedParams: null
});
class src_Mission {
	constructor() {
		this.ultimateTime = 0;
		this.goldTime = 0;
		this.qualifyTime = Infinity;
	}
	load() {
		let entry = src_ResourceLoader.getFileEntry(this.path).entry;
		let bytes = entry.getBytes();
		let totBytes = new haxe_io_BytesBuffer();
		let _g = 0;
		let _g1 = bytes.length;
		while(_g < _g1) {
			let i = _g++;
			let code = bytes.b[i];
			let utfbytes = haxe_io_Bytes.ofString(String.fromCodePoint(code));
			totBytes.add(utfbytes);
		}
		let misText = totBytes.getBytes().toString();
		let misParser = new mis_MisParser(misText);
		let contents = misParser.parse();
		this.root = contents.root;
		this.marbleAttributes = contents.marbleAttributes;
		let scanMission = null;
		let _gthis = this;
		scanMission = function(simGroup) {
			let _g = 0;
			let _g1 = simGroup.elements;
			while(_g < _g1.length) {
				let element = _g1[_g];
				++_g;
				if(_gthis.hasEgg) {
					break;
				}
				if(element._type == mis_MissionElementType.Item) {
					let so = element;
					if(so.datablock.toLowerCase() == "easteregg") {
						_gthis.hasEgg = true;
					}
				} else if(element._type == mis_MissionElementType.SimGroup && !_gthis.hasEgg) {
					scanMission(element);
				}
				if(element._name == "MissionInfo") {
					_gthis.missionInfo = element;
				}
			}
		};
		scanMission(this.root);
	}
	getNextMission() {
		return this.next;
	}
	getDifPath(rawElementPath) {
		if(rawElementPath.includes("$usermods")) {
			let _this = rawElementPath.split("@").slice(1);
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				let a = StringTools.trim(_this[i]);
				a = src_Util.unescape(HxOverrides.substr(a,1,a.length - 2));
				result[i] = a;
			}
			rawElementPath = result.join("");
		}
		let fname = rawElementPath.substring(rawElementPath.lastIndexOf("/") + 1);
		rawElementPath = rawElementPath.toLowerCase();
		if(rawElementPath.startsWith("./")) {
			rawElementPath = rawElementPath.substring(2);
			rawElementPath = haxe_io_Path.directory(this.path) + "/" + rawElementPath;
		}
		let path = StringTools.replace(rawElementPath.substring(rawElementPath.indexOf("data/")),"\"","");
		path = StringTools.replace(path,"data/","");
		if(!path.endsWith(".dif")) {
			path += ".dif";
		}
		if(src_ResourceLoader.exists(path)) {
			return path;
		}
		if(path.includes("interiors_mbg/")) {
			path = StringTools.replace(path,"interiors_mbg/","interiors/");
		}
		let dirpath = path.substring(0,path.lastIndexOf("/") + 1);
		if(src_ResourceLoader.exists(path)) {
			return path;
		}
		if(src_ResourceLoader.exists(dirpath + fname)) {
			return dirpath + fname;
		}
		if(this.game == "gold") {
			path = StringTools.replace(path,"interiors/","interiors_mbg/");
			if(src_ResourceLoader.exists(path)) {
				return path;
			}
		}
		path = StringTools.replace(path,"lbinteriors","interiors");
		if(src_ResourceLoader.exists(path)) {
			return path;
		}
		src_Console.instance.addEntry("error","Interior resource not found: " + rawElementPath);
		return "";
	}
	download(onFinish) {
		let _gthis = this;
		if(this.isClaMission) {
			src_Marbleland.download(this.id,function(zipEntries) {
				if(zipEntries != null) {
					src_ResourceLoader.loadZip(zipEntries,_gthis.game);
					onFinish();
				} else {
					src_MarbleGame.canvas.pushDialog(new gui_MessageBoxOkDlg("Failed to download mission"));
				}
			});
		}
	}
	static fromMissionInfo(path,mInfo) {
		let mission = new src_Mission();
		mission.path = path;
		mission.missionInfo = mInfo;
		mission.title = mInfo.name;
		mission.artist = mInfo.artist == null ? "" : mInfo.artist;
		mission.description = mInfo.desc == null ? "" : mInfo.desc;
		if(mInfo.time != null && mInfo.time != "0") {
			mission.qualifyTime = mis_MisParser.parseNumber(mInfo.time) / 1000;
		}
		if(mInfo.goldtime != null) {
			mission.goldTime = mis_MisParser.parseNumber(mInfo.goldtime) / 1000;
		}
		if(mInfo.ultimatetime != null) {
			mission.ultimateTime = mis_MisParser.parseNumber(mInfo.ultimatetime) / 1000;
		}
		mission.type = mInfo.type.toLowerCase();
		mission.missionInfo = mInfo;
		return mission;
	}
}
$hxClasses["src.Mission"] = src_Mission;
src_Mission.__name__ = "src.Mission";
Object.assign(src_Mission.prototype, {
	__class__: src_Mission
	,root: null
	,title: null
	,artist: null
	,description: null
	,qualifyTime: null
	,goldTime: null
	,ultimateTime: null
	,type: null
	,path: null
	,missionInfo: null
	,index: null
	,difficultyIndex: null
	,id: null
	,isClaMission: null
	,game: null
	,hasEgg: null
	,isCustom: null
	,marbleAttributes: null
	,next: null
});
class src_MissionList {
	static buildMissionList() {
		if(src_MissionList._build) {
			return;
		}
		src_MissionList.missions = new haxe_ds_StringMap();
		src_MissionList.missionsFilenameLookup = new haxe_ds_StringMap();
		src_MissionList.missionList = new haxe_ds_StringMap();
		let parseDifficulty = function(game,mispath,difficulty,difficultyIndex) {
			let difficultyFiles = src_ResourceLoader.fileSystem.dir("" + mispath + "/" + difficulty);
			let difficultyMissions = [];
			let _g = 0;
			while(_g < difficultyFiles.length) {
				let file = difficultyFiles[_g];
				++_g;
				if(file.get_isDirectory()) {
					let _g = file.iterator();
					while(_g.i < _g.l) {
						let sfile = _g.a[_g.i++];
						if(sfile.get_extension() == "mis") {
							let misParser = new mis_MisParser(sfile.getText());
							let mInfo = misParser.parseMissionInfo();
							let mission = src_Mission.fromMissionInfo(sfile.get_path(),mInfo);
							if(game != "custom") {
								mission.game = game;
							} else if(mInfo.game != null && mInfo.game != "") {
								mission.game = mInfo.game.toLowerCase();
							} else {
								mission.game = game;
							}
							if(game == "custom") {
								mission.isCustom = true;
							}
							if(sfile.getText().toLowerCase().includes("datablock = \"easteregg\"")) {
								mission.hasEgg = true;
							}
							mission.difficultyIndex = difficultyIndex;
							let this1 = src_MissionList.missions;
							let key = sfile.get_path();
							this1.h[key] = mission;
							src_MissionList.missionsFilenameLookup.h[sfile.name.toLowerCase()] = mission;
							difficultyMissions.push(mission);
						}
					}
				}
			}
			difficultyMissions.sort(function(a,b) {
				return Std.parseInt(a.missionInfo.level) - Std.parseInt(b.missionInfo.level);
			});
			let _g1 = 0;
			let _g2 = difficultyMissions.length;
			while(_g1 < _g2) {
				let i = _g1++;
				difficultyMissions[i].index = i;
			}
			let _g3 = 0;
			let _g4 = difficultyMissions.length - 1;
			while(_g3 < _g4) {
				let i = _g3++;
				difficultyMissions[i].next = difficultyMissions[i + 1];
			}
			return difficultyMissions;
		};
		let ultraMissions = new haxe_ds_StringMap();
		let value = parseDifficulty("ultra","missions","beginner",0);
		ultraMissions.h["beginner"] = value;
		let value1 = parseDifficulty("ultra","missions","intermediate",1);
		ultraMissions.h["intermediate"] = value1;
		let value2 = parseDifficulty("ultra","missions","advanced",2);
		ultraMissions.h["advanced"] = value2;
		let value3 = parseDifficulty("ultra","missions","multiplayer",3);
		ultraMissions.h["multiplayer"] = value3;
		ultraMissions.h["beginner"][ultraMissions.h["beginner"].length - 1].next = ultraMissions.h["intermediate"][0];
		ultraMissions.h["intermediate"][ultraMissions.h["intermediate"].length - 1].next = ultraMissions.h["advanced"][0];
		ultraMissions.h["advanced"][ultraMissions.h["advanced"].length - 1].next = ultraMissions.h["beginner"][0];
		ultraMissions.h["multiplayer"][ultraMissions.h["multiplayer"].length - 1].next = ultraMissions.h["multiplayer"][0];
		src_MissionList.missionList.h["ultra"] = ultraMissions;
		src_MissionList._build = true;
	}
	static parseMisHeader(conts,path) {
		let misParser = new mis_MisParser(conts);
		let mInfo = misParser.parseMissionInfo();
		let mission = src_Mission.fromMissionInfo(path,mInfo);
		mission.game = "ultra";
		if(conts.toLowerCase().includes("datablock = \"easteregg\"")) {
			mission.hasEgg = true;
		}
		return mission;
	}
}
$hxClasses["src.MissionList"] = src_MissionList;
src_MissionList.__name__ = "src.MissionList";
class src_ParticleData {
	constructor() {
	}
}
$hxClasses["src.ParticleData"] = src_ParticleData;
src_ParticleData.__name__ = "src.ParticleData";
Object.assign(src_ParticleData.prototype, {
	__class__: src_ParticleData
	,texture: null
	,identifier: null
});
class src_Particle {
	constructor(options,manager,data,spawnTime,pos,vel) {
		this.acc = new h3d_Vector();
		this.currentAge = 0;
		this.o = options;
		this.manager = manager;
		this.data = data;
		this.spawnTime = spawnTime;
		this.position = pos;
		this.vel = vel;
		let _this = this.vel;
		let v = options.acceleration;
		this.acc = new h3d_Vector(_this.x * v,_this.y * v,_this.z * v,_this.w);
		this.lifeTime = this.o.lifetime + this.o.lifetimeVariance * (Math.random() * 2 - 1);
		let a = this.o.spinRandomMin;
		this.initialSpin = a + (this.o.spinRandomMax - a) * Math.random();
		this.part = new src_ParticleElement();
	}
	update(time,dt) {
		let a = this.acc;
		let _this = this.vel;
		let v = this.o.dragCoefficient;
		let x = _this.x * v;
		let y = _this.y * v;
		let z = _this.z * v;
		let w = _this.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let v_x = x;
		let v_y = y;
		let v_z = z;
		let v_w = w;
		let x1 = a.x - v_x;
		let y1 = a.y - v_y;
		let z1 = a.z - v_z;
		let w1 = a.w - v_w;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let v_x1 = x1;
		let v_y1 = y1;
		let v_z1 = z1;
		let v_w1 = w1;
		a.x = v_x1;
		a.y = v_y1;
		a.z = v_z1;
		a.w = v_w1;
		let _this1 = this.vel;
		let _this2 = this.vel;
		let x2 = a.x * dt;
		let y2 = a.y * dt;
		let z2 = a.z * dt;
		let w2 = a.w;
		if(w2 == null) {
			w2 = 1.;
		}
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let v_x2 = x2;
		let v_y2 = y2;
		let v_z2 = z2;
		let v_w2 = w2;
		let x3 = _this2.x + v_x2;
		let y3 = _this2.y + v_y2;
		let z3 = _this2.z + v_z2;
		let w3 = _this2.w + v_w2;
		if(w3 == null) {
			w3 = 1.;
		}
		if(z3 == null) {
			z3 = 0.;
		}
		if(y3 == null) {
			y3 = 0.;
		}
		if(x3 == null) {
			x3 = 0.;
		}
		let v_x3 = x3;
		let v_y3 = y3;
		let v_z3 = z3;
		let v_w3 = w3;
		_this1.x = v_x3;
		_this1.y = v_y3;
		_this1.z = v_z3;
		_this1.w = v_w3;
		let _this3 = this.position;
		let _this4 = this.position;
		let _this5 = this.vel;
		let x4 = _this5.x * dt;
		let y4 = _this5.y * dt;
		let z4 = _this5.z * dt;
		let w4 = _this5.w;
		if(w4 == null) {
			w4 = 1.;
		}
		if(z4 == null) {
			z4 = 0.;
		}
		if(y4 == null) {
			y4 = 0.;
		}
		if(x4 == null) {
			x4 = 0.;
		}
		let v_x4 = x4;
		let v_y4 = y4;
		let v_z4 = z4;
		let v_w4 = w4;
		let x5 = _this4.x + v_x4;
		let y5 = _this4.y + v_y4;
		let z5 = _this4.z + v_z4;
		let w5 = _this4.w + v_w4;
		if(w5 == null) {
			w5 = 1.;
		}
		if(z5 == null) {
			z5 = 0.;
		}
		if(y5 == null) {
			y5 = 0.;
		}
		if(x5 == null) {
			x5 = 0.;
		}
		let v_x5 = x5;
		let v_y5 = y5;
		let v_z5 = z5;
		let v_w5 = w5;
		_this3.x = v_x5;
		_this3.y = v_y5;
		_this3.z = v_z5;
		_this3.w = v_w5;
		this.currentAge += dt;
		let elapsed = time - this.spawnTime;
		let value = elapsed / this.lifeTime;
		let completion = value < 0 ? 0 : value > 1 ? 1 : value;
		if(this.currentAge > this.lifeTime || this.currentAge < 0) {
			this.manager.removeParticle(this.data,this);
			return;
		}
		if(completion == 1 || completion < 0) {
			this.manager.removeParticle(this.data,this);
			return;
		}
		this.rotation = (this.initialSpin + this.o.spinSpeed * elapsed / 1000) * Math.PI / 180;
		let indexLow = 0;
		let indexHigh = 1;
		let _g = 2;
		let _g1 = this.o.times.length;
		while(_g < _g1) {
			let i = _g++;
			if(this.o.times[indexHigh] >= completion) {
				break;
			}
			indexLow = indexHigh;
			indexHigh = i;
		}
		if(this.o.times.length == 1) {
			indexHigh = indexLow;
		}
		let t = (completion - this.o.times[indexLow]) / (this.o.times[indexHigh] - this.o.times[indexLow]);
		let v1 = this.o.colors[indexLow];
		let v2 = this.o.colors[indexHigh];
		let a1 = v1.x;
		let a2 = v1.y;
		let a3 = v1.z;
		let a4 = v1.w;
		this.color = new h3d_Vector(a1 + (v2.x - a1) * t,a2 + (v2.y - a2) * t,a3 + (v2.z - a3) * t,a4 + (v2.w - a4) * t);
		let a5 = this.o.sizes[indexLow];
		this.scale = a5 + (this.o.sizes[indexHigh] - a5) * t;
		this.part.x = this.position.x;
		this.part.y = this.position.y;
		this.part.z = this.position.z;
		this.part.r = this.color.x;
		this.part.g = this.color.y;
		this.part.b = this.color.z;
		this.part.a = this.color.w;
		this.part.ratio = 1;
		this.part.size = this.scale / 2;
	}
}
$hxClasses["src.Particle"] = src_Particle;
src_Particle.__name__ = "src.Particle";
Object.assign(src_Particle.prototype, {
	__class__: src_Particle
	,part: null
	,data: null
	,manager: null
	,o: null
	,position: null
	,vel: null
	,rotation: null
	,color: null
	,scale: null
	,lifeTime: null
	,initialSpin: null
	,spawnTime: null
	,currentAge: null
	,acc: null
});
class src_ParticleEmitter {
	constructor(options,data,manager,getPos,spawnSphereSquish) {
		this.vel = new h3d_Vector();
		this.o = options;
		this.manager = manager;
		this.getPos = getPos;
		this.data = data;
		this.spawnSphereSquish = spawnSphereSquish != null ? spawnSphereSquish : new h3d_Vector(1,1,1);
	}
	spawn(time) {
		this.spawnTime = time;
		this.emit(time);
	}
	tick(time,dt) {
		if(time - this.lastEmitTime >= 1000) {
			this.lastEmitTime = time - 1000;
		}
		while(this.lastEmitTime + this.currentWaitPeriod <= time) {
			this.emit(this.lastEmitTime + this.currentWaitPeriod);
			let value = (this.lastEmitTime - this.spawnTime) / this.o.emitterLifetime;
			let completion = value < 0 ? 0 : value > 1 ? 1 : value;
			if(completion == 1) {
				this.manager.removeEmitter(this);
				return;
			}
		}
	}
	emit(time) {
		this.lastEmitTime = time;
		this.currentWaitPeriod = this.o.ejectionPeriod;
		let _this = this.getPosAtTime(time);
		let pos = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
		if(this.o.spawnOffset != null) {
			let v = this.o.spawnOffset();
			let x = pos.x + v.x;
			let y = pos.y + v.y;
			let z = pos.z + v.z;
			let w = pos.w + v.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let v_x = x;
			let v_y = y;
			let v_z = z;
			let v_w = w;
			pos.x = v_x;
			pos.y = v_y;
			pos.z = v_z;
			pos.w = v_w;
		}
		let x = Math.random() * 2 - 1;
		let y = Math.random() * 2 - 1;
		let z = Math.random() * 2 - 1;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let _this_x = x;
		let _this_y = y;
		let _this_z = z;
		let k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		let x1 = _this_x * k;
		let y1 = _this_y * k;
		let z1 = _this_z * k;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let randomPointOnSphere_x = x1;
		let randomPointOnSphere_y = y1;
		let randomPointOnSphere_z = z1;
		randomPointOnSphere_x *= this.spawnSphereSquish.x;
		randomPointOnSphere_y *= this.spawnSphereSquish.y;
		randomPointOnSphere_z *= this.spawnSphereSquish.z;
		let initialVel = this.o.ejectionVelocity;
		initialVel += this.o.velocityVariance * 2 * Math.random() - this.o.velocityVariance;
		let _this1 = this.vel;
		let v = this.o.inheritedVelFactor;
		let x2 = _this1.x * v;
		let y2 = _this1.y * v;
		let z2 = _this1.z * v;
		let w = _this1.w;
		if(w == null) {
			w = 1.;
		}
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let _this_x1 = x2;
		let _this_y1 = y2;
		let _this_z1 = z2;
		let _this_w = w;
		let x3 = randomPointOnSphere_x * initialVel;
		let y3 = randomPointOnSphere_y * initialVel;
		let z3 = randomPointOnSphere_z * initialVel;
		if(z3 == null) {
			z3 = 0.;
		}
		if(y3 == null) {
			y3 = 0.;
		}
		if(x3 == null) {
			x3 = 0.;
		}
		let v_x = x3;
		let v_y = y3;
		let v_z = z3;
		let x4 = _this_x1 + v_x;
		let y4 = _this_y1 + v_y;
		let z4 = _this_z1 + v_z;
		let w1 = _this_w + 1.;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z4 == null) {
			z4 = 0.;
		}
		if(y4 == null) {
			y4 = 0.;
		}
		if(x4 == null) {
			x4 = 0.;
		}
		let _this_x2 = x4;
		let _this_y2 = y4;
		let _this_z2 = z4;
		let _this_w1 = w1;
		let v1 = this.o.ambientVelocity;
		let vel = new h3d_Vector(_this_x2 + v1.x,_this_y2 + v1.y,_this_z2 + v1.z,_this_w1 + v1.w);
		let particle = new src_Particle(this.o.particleOptions,this.manager,this.data,time,pos,vel);
		this.manager.addParticle(this.data,particle);
	}
	getPosAtTime(time) {
		if(this.lastPos == null) {
			return this.currPos;
		}
		let value = (time - this.lastPosTime) / (this.currPosTime - this.lastPosTime);
		let completion = value < 0 ? 0 : value > 1 ? 1 : value;
		let v1 = this.lastPos;
		let v2 = this.currPos;
		let a = v1.x;
		let a1 = v1.y;
		let a2 = v1.z;
		let a3 = v1.w;
		return new h3d_Vector(a + (v2.x - a) * completion,a1 + (v2.y - a1) * completion,a2 + (v2.z - a2) * completion,a3 + (v2.w - a3) * completion);
	}
	setPos(pos,time) {
		this.lastPos = this.currPos;
		this.lastPosTime = this.currPosTime;
		this.currPos = new h3d_Vector(pos.x,pos.y,pos.z,pos.w);
		this.currPosTime = time;
		let _this = this.currPos;
		let v = this.lastPos;
		let x = _this.x - v.x;
		let y = _this.y - v.y;
		let z = _this.z - v.z;
		let w = _this.w - v.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let _this_x = x;
		let _this_y = y;
		let _this_z = z;
		let _this_w = w;
		let v1 = 1000 / (this.currPosTime - this.lastPosTime);
		this.vel = new h3d_Vector(_this_x * v1,_this_y * v1,_this_z * v1,_this_w);
	}
}
$hxClasses["src.ParticleEmitter"] = src_ParticleEmitter;
src_ParticleEmitter.__name__ = "src.ParticleEmitter";
Object.assign(src_ParticleEmitter.prototype, {
	__class__: src_ParticleEmitter
	,o: null
	,data: null
	,manager: null
	,spawnTime: null
	,lastEmitTime: null
	,currentWaitPeriod: null
	,lastPos: null
	,lastPosTime: null
	,currPos: null
	,currPosTime: null
	,creationTime: null
	,vel: null
	,getPos: null
	,spawnSphereSquish: null
});
class src_ParticleManager {
	constructor(level) {
		this.emitters = [];
		this.particles = [];
		this.particleGroups = new haxe_ds_StringMap();
		src_Console.instance.addEntry("log","Initializing Particle Manager");
		this.level = level;
		this.scene = level.scene;
	}
	update(currentTime,dt) {
		this.currentTime = currentTime;
		let _g = 0;
		let _g1 = this.particles;
		while(_g < _g1.length) {
			let particle = _g1[_g];
			++_g;
			particle.update(currentTime,dt);
		}
		this.tick(dt);
	}
	addParticle(particleData,particle) {
		if(Object.prototype.hasOwnProperty.call(this.particleGroups.h,particleData.identifier)) {
			this.particleGroups.h[particleData.identifier].add(particle.part);
		} else {
			let pGroup = new src_ParticlesMesh(particle.data.texture,this.scene);
			pGroup.set_hasColor(true);
			pGroup.material.setDefaultProps("ui");
			pGroup.material.set_blendMode(particle.o.blending);
			pGroup.material.passes.set_depthWrite(false);
			pGroup.add(particle.part);
			this.particleGroups.h[particleData.identifier] = pGroup;
		}
		this.particles.push(particle);
	}
	removeParticle(particleData,particle) {
		if(Object.prototype.hasOwnProperty.call(this.particleGroups.h,particleData.identifier)) {
			this.particleGroups.h[particleData.identifier].kill(particle.part);
		}
		HxOverrides.remove(this.particles,particle);
	}
	getTime() {
		return this.currentTime;
	}
	createEmitter(options,data,initialPos,getPos,spawnSphereSquish) {
		let emitter = new src_ParticleEmitter(options,data,this,getPos,spawnSphereSquish);
		emitter.currPos = getPos != null ? getPos() : new h3d_Vector(initialPos.x,initialPos.y,initialPos.z,initialPos.w);
		if(emitter.currPos == null) {
			emitter.currPos = new h3d_Vector(initialPos.x,initialPos.y,initialPos.z,initialPos.w);
		}
		emitter.currPosTime = this.getTime();
		emitter.creationTime = this.getTime();
		emitter.spawn(this.getTime());
		this.emitters.push(emitter);
		return emitter;
	}
	removeEmitter(emitter) {
		HxOverrides.remove(this.emitters,emitter);
	}
	tick(dt) {
		let time = this.getTime();
		let _g = 0;
		let _g1 = this.emitters;
		while(_g < _g1.length) {
			let emitter = _g1[_g];
			++_g;
			if(emitter.getPos != null) {
				emitter.setPos(emitter.getPos(),time);
			}
			emitter.tick(time,dt);
			if(emitter.creationTime > time) {
				this.removeEmitter(emitter);
			}
		}
	}
}
$hxClasses["src.ParticleManager"] = src_ParticleManager;
src_ParticleManager.__name__ = "src.ParticleManager";
Object.assign(src_ParticleManager.prototype, {
	__class__: src_ParticleManager
	,level: null
	,scene: null
	,currentTime: null
	,particleGroups: null
	,particles: null
	,emitters: null
});
var src_SortMode = $hxEnums["src.SortMode"] = { __ename__:true,__constructs__:null
	,Front: {_hx_name:"Front",_hx_index:0,__enum__:"src.SortMode",toString:$estr}
	,Back: {_hx_name:"Back",_hx_index:1,__enum__:"src.SortMode",toString:$estr}
	,Sort: {_hx_name:"Sort",_hx_index:2,__enum__:"src.SortMode",toString:$estr}
	,InvSort: {_hx_name:"InvSort",_hx_index:3,__enum__:"src.SortMode",toString:$estr}
};
src_SortMode.__constructs__ = [src_SortMode.Front,src_SortMode.Back,src_SortMode.Sort,src_SortMode.InvSort];
src_SortMode.__empty_constructs__ = [src_SortMode.Front,src_SortMode.Back,src_SortMode.Sort,src_SortMode.InvSort];
class src_ParticleElement {
	constructor() {
		this.r = 1;
		this.g = 1;
		this.b = 1;
		this.a = 1;
		this.frame = 0;
	}
}
$hxClasses["src.ParticleElement"] = src_ParticleElement;
src_ParticleElement.__name__ = "src.ParticleElement";
Object.assign(src_ParticleElement.prototype, {
	__class__: src_ParticleElement
	,x: null
	,y: null
	,z: null
	,w: null
	,r: null
	,g: null
	,b: null
	,a: null
	,frame: null
	,size: null
	,ratio: null
	,rotation: null
	,prev: null
	,next: null
});
class src_ParticlesMesh extends h3d_scene_Mesh {
	constructor(texture,parent) {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(texture,parent);
	}
	_hx_constructor(texture,parent) {
		this.bufferSize = 0;
		this.globalSize = 1;
		this.count = 0;
		super._hx_constructor(null,null,parent);
		this.material.set_props(this.material.getDefaultProps("particles3D"));
		this.sortMode = src_SortMode.Back;
		this.pshader = new h3d_shader_ParticleShader();
		let _this = this.pshader;
		_this.constModified = true;
		_this.isAbsolute__ = true;
		this.material.passes.addShader(this.pshader);
		this.material.passes.set_dynamicParameters(true);
		this.material.set_texture(texture);
		this.tmp = new h3d_Vector();
	}
	set_hasColor(b) {
		let c = this.material.passes.getShader(h3d_shader_VertexColorAlpha);
		if(b) {
			if(c == null) {
				this.material.passes.addShader(new h3d_shader_VertexColorAlpha());
			}
		} else if(c != null) {
			this.material.passes.removeShader(c);
		}
		return this.hasColor = b;
	}
	add(p) {
		this.emitParticle(p);
		return p;
	}
	emitParticle(p) {
		if(p == null) {
			if(this.pool == null) {
				p = new src_ParticleElement();
			} else {
				p = this.pool;
				this.pool = p.next;
			}
		}
		this.count++;
		switch(this.sortMode._hx_index) {
		case 1:
			if(this.head == null) {
				p.next = null;
				this.head = this.tail = p;
			} else {
				this.tail.next = p;
				p.prev = this.tail;
				p.next = null;
				this.tail = p;
			}
			break;
		case 0:case 2:case 3:
			if(this.head == null) {
				p.next = null;
				this.head = this.tail = p;
			} else {
				this.head.prev = p;
				p.next = this.head;
				this.head = p;
			}
			break;
		}
		return p;
	}
	kill(p) {
		if(p.prev == null) {
			this.head = p.next;
		} else {
			p.prev.next = p.next;
		}
		if(p.next == null) {
			this.tail = p.prev;
		} else {
			p.next.prev = p.prev;
		}
		p.prev = null;
		p.next = this.pool;
		this.pool = p;
		this.count--;
	}
	sort(list) {
		let list1 = list;
		if(list == null) {
			return null;
		} else {
			let insize = 1;
			let nmerges;
			let psize = 0;
			let qsize = 0;
			let p;
			let q;
			let e;
			let tail = null;
			while(true) {
				p = list1;
				list1 = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					let _g = 0;
					let _g1 = insize;
					while(_g < _g1) {
						++_g;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || (p.w < q.w ? 1 : -1) <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list1 = e;
						}
						e.prev = tail;
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			list1.prev = tail;
			return list1;
		}
	}
	sortInv(list) {
		let list1 = list;
		if(list == null) {
			return null;
		} else {
			let insize = 1;
			let nmerges;
			let psize = 0;
			let qsize = 0;
			let p;
			let q;
			let e;
			let tail = null;
			while(true) {
				p = list1;
				list1 = null;
				tail = null;
				nmerges = 0;
				while(p != null) {
					++nmerges;
					q = p;
					psize = 0;
					let _g = 0;
					let _g1 = insize;
					while(_g < _g1) {
						++_g;
						++psize;
						q = q.next;
						if(q == null) {
							break;
						}
					}
					qsize = insize;
					while(psize > 0 || qsize > 0 && q != null) {
						if(psize == 0) {
							e = q;
							q = q.next;
							--qsize;
						} else if(qsize == 0 || q == null || (p.w < q.w ? -1 : 1) <= 0) {
							e = p;
							p = p.next;
							--psize;
						} else {
							e = q;
							q = q.next;
							--qsize;
						}
						if(tail != null) {
							tail.next = e;
						} else {
							list1 = e;
						}
						e.prev = tail;
						tail = e;
					}
					p = q;
				}
				tail.next = null;
				if(nmerges <= 1) {
					break;
				}
				insize *= 2;
			}
			list1.prev = tail;
			return list1;
		}
	}
	draw(ctx) {
		if(this.head == null) {
			return;
		}
		switch(this.sortMode._hx_index) {
		case 2:case 3:
			let p = this.head;
			let m = ctx.camera.m;
			while(p != null) {
				p.w = (p.x * m._13 + p.y * m._23 + p.z * m._33 + m._43) / (p.x * m._14 + p.y * m._24 + p.z * m._34 + m._44);
				p = p.next;
			}
			this.head = this.sortMode == src_SortMode.Sort ? this.sort(this.head) : this.sortInv(this.head);
			this.tail = this.head.prev;
			this.head.prev = null;
			break;
		default:
		}
		if(this.tmpBuf == null) {
			this.tmpBuf = hxd__$FloatBuffer_Float32Expand._new(0);
		}
		let pos = 0;
		let p1 = this.head;
		let tmp = this.tmpBuf;
		if(this.frames == null || this.frames.length == 0) {
			let t = this.material.get_texture() == null ? h2d_Tile.fromColor(16711935) : h2d_Tile.fromTexture(this.material.get_texture());
			this.frames = [t];
		}
		this.material.set_texture(this.frames[0].innerTex);
		while(p1 != null) {
			let f = this.frames[p1.frame];
			if(f == null) {
				f = this.frames[0];
			}
			let ratio = p1.size * p1.ratio * (f.height / f.width);
			if(pos >= tmp.pos) {
				let v = tmp.pos + 40 + (this.hasColor ? 16 : 0);
				let _g = tmp.pos;
				while(_g < v) {
					++_g;
					if(tmp.pos == tmp.array.length) {
						let newSize = tmp.array.length << 1;
						if(newSize < 128) {
							newSize = 128;
						}
						let newArray = new Float32Array(newSize);
						newArray.set(tmp.array);
						tmp.array = newArray;
					}
					tmp.array[tmp.pos++] = 0.;
				}
			}
			tmp.array[pos++] = p1.x;
			tmp.array[pos++] = p1.y;
			tmp.array[pos++] = p1.z;
			tmp.array[pos++] = p1.size;
			tmp.array[pos++] = ratio;
			tmp.array[pos++] = p1.rotation;
			tmp.array[pos++] = -0.5;
			tmp.array[pos++] = -0.5;
			tmp.array[pos++] = f.u;
			tmp.array[pos++] = f.v2;
			if(this.hasColor) {
				tmp.array[pos++] = p1.r;
				tmp.array[pos++] = p1.g;
				tmp.array[pos++] = p1.b;
				tmp.array[pos++] = p1.a;
			}
			tmp.array[pos++] = p1.x;
			tmp.array[pos++] = p1.y;
			tmp.array[pos++] = p1.z;
			tmp.array[pos++] = p1.size;
			tmp.array[pos++] = ratio;
			tmp.array[pos++] = p1.rotation;
			tmp.array[pos++] = -0.5;
			tmp.array[pos++] = 0.5;
			tmp.array[pos++] = f.u;
			tmp.array[pos++] = f.v;
			if(this.hasColor) {
				tmp.array[pos++] = p1.r;
				tmp.array[pos++] = p1.g;
				tmp.array[pos++] = p1.b;
				tmp.array[pos++] = p1.a;
			}
			tmp.array[pos++] = p1.x;
			tmp.array[pos++] = p1.y;
			tmp.array[pos++] = p1.z;
			tmp.array[pos++] = p1.size;
			tmp.array[pos++] = ratio;
			tmp.array[pos++] = p1.rotation;
			tmp.array[pos++] = 0.5;
			tmp.array[pos++] = -0.5;
			tmp.array[pos++] = f.u2;
			tmp.array[pos++] = f.v2;
			if(this.hasColor) {
				tmp.array[pos++] = p1.r;
				tmp.array[pos++] = p1.g;
				tmp.array[pos++] = p1.b;
				tmp.array[pos++] = p1.a;
			}
			tmp.array[pos++] = p1.x;
			tmp.array[pos++] = p1.y;
			tmp.array[pos++] = p1.z;
			tmp.array[pos++] = p1.size;
			tmp.array[pos++] = ratio;
			tmp.array[pos++] = p1.rotation;
			tmp.array[pos++] = 0.5;
			tmp.array[pos++] = 0.5;
			tmp.array[pos++] = f.u2;
			tmp.array[pos++] = f.v;
			if(this.hasColor) {
				tmp.array[pos++] = p1.r;
				tmp.array[pos++] = p1.g;
				tmp.array[pos++] = p1.b;
				tmp.array[pos++] = p1.a;
			}
			p1 = p1.next;
		}
		if(pos != 0) {
			let stride = 10;
			if(this.hasColor) {
				stride = 14;
			}
			if(this.buffer == null) {
				this.buffer = h3d_Buffer.ofSubFloats(tmp,stride,pos / stride | 0,[h3d_BufferFlag.Quads,h3d_BufferFlag.Dynamic,h3d_BufferFlag.RawFormat]);
				this.bufferSize = pos / stride | 0;
			} else {
				let len = pos / stride | 0;
				if(this.bufferSize < len) {
					this.buffer.dispose();
					this.buffer = h3d_Buffer.ofSubFloats(tmp,stride,pos / stride | 0,[h3d_BufferFlag.Quads,h3d_BufferFlag.Dynamic,h3d_BufferFlag.RawFormat]);
					this.bufferSize = pos / stride | 0;
				} else {
					this.buffer.uploadVector(tmp,0,len);
				}
			}
			if(this.pshader.is3D__) {
				let _this = this.pshader.size__;
				let x = this.globalSize;
				let y = this.globalSize;
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				_this.x = x;
				_this.y = y;
				_this.z = 0.;
				_this.w = 1.;
			} else {
				let _this = this.pshader.size__;
				let x = this.globalSize * ctx.engine.height / ctx.engine.width * 4;
				let y = this.globalSize * 4;
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				_this.x = x;
				_this.y = y;
				_this.z = 0.;
				_this.w = 1.;
			}
			ctx.uploadParams();
			let verts = pos / stride | 0;
			let _this = ctx.engine;
			let max = verts >> 1;
			if(max == null) {
				max = -1;
			}
			_this.renderBuffer(this.buffer,_this.mem.quadIndexes,2,0,max);
		}
	}
	onRemove() {
		super.onRemove();
		if(this.buffer != null) {
			this.buffer.dispose();
			this.buffer = null;
		}
	}
}
$hxClasses["src.ParticlesMesh"] = src_ParticlesMesh;
src_ParticlesMesh.__name__ = "src.ParticlesMesh";
src_ParticlesMesh.__super__ = h3d_scene_Mesh;
Object.assign(src_ParticlesMesh.prototype, {
	__class__: src_ParticlesMesh
	,pshader: null
	,frames: null
	,count: null
	,hasColor: null
	,sortMode: null
	,globalSize: null
	,head: null
	,tail: null
	,pool: null
	,tmp: null
	,tmpBuf: null
	,buffer: null
	,bufferSize: null
});
class src_PathedInterior extends src_InteriorObject {
	constructor() {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.stopped = false;
		this.markerData = [];
		this.triggers = [];
		super._hx_constructor();
	}
	init(level,onFinish) {
		this.basePosition = mis_MisParser.parseVector3(this.element.baseposition);
		this.basePosition.x = -this.basePosition.x;
		this.baseOrientation = mis_MisParser.parseRotation(this.element.baserotation);
		this.baseOrientation.x = -this.baseOrientation.x;
		this.baseOrientation.w = -this.baseOrientation.w;
		this.baseScale = mis_MisParser.parseVector3(this.element.basescale);
		if(this.baseScale.x == 0) {
			this.baseScale.x = 0.0001;
		}
		if(this.baseScale.y == 0) {
			this.baseScale.y = 0.0001;
		}
		if(this.baseScale.z == 0) {
			this.baseScale.z = 0.0001;
		}
		let _this = this.baseOrientation;
		this.setRotationQuat(new h3d_Quat(_this.x,_this.y,_this.z,_this.w));
		this.collider.setTransform(this.getTransform());
		this.collider.fastTransform = true;
		let _this1 = this.simGroup.elements;
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this1.length) {
			let v = _this1[_g1];
			++_g1;
			if(v._type == mis_MissionElementType.Path) {
				_g.push(v);
			}
		}
		this.path = _g[0];
		let _this2 = this.path.markers;
		let result = new Array(_this2.length);
		let _g2 = 0;
		let _g3 = _this2.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let x = _this2[i];
			let marker = new src_PathedInteriorMarker();
			marker.msToNext = mis_MisParser.parseNumber(x.mstonext) / 1000;
			marker.smoothingType = x.smoothingtype;
			marker.position = mis_MisParser.parseVector3(x.position);
			marker.position.x = -marker.position.x;
			marker.rotation = mis_MisParser.parseRotation(x.rotation);
			marker.rotation.x = -marker.rotation.x;
			marker.rotation.w = -marker.rotation.w;
			result[i] = marker;
		}
		this.markerData = result;
		this.computeDuration();
		let _this3 = this.simGroup.elements;
		let _g4 = [];
		let _g5 = 0;
		while(_g5 < _this3.length) {
			let v = _this3[_g5];
			++_g5;
			if(v._type == mis_MissionElementType.Trigger) {
				_g4.push(v);
			}
		}
		let _g6 = 0;
		while(_g6 < _g4.length) {
			let triggerElement = _g4[_g6];
			++_g6;
			let te = triggerElement;
			if(te.targettime == null) {
				continue;
			}
			let trigger = new triggers_MustChangeTrigger(te,this);
			this.triggers.push(trigger);
		}
		let _gthis = this;
		if(this.element.datablock.toLowerCase() == "pathedmovingblock") {
			src_ResourceLoader.load("sound/movingblockloop.wav").entry.load(function() {
				let tmp = src_ResourceLoader.getResource("data/sound/movingblockloop.wav",src_ResourceLoader.getAudio,_gthis.soundResources);
				_gthis.soundChannel = src_AudioManager.playSound(tmp,new h3d_Vector(),true);
			});
		}
		this.reset();
		onFinish();
	}
	pushTickState() {
		this._storedColliderTransform = this.collider.transform.clone();
		let tform = this.getAbsPos();
		if(this.isCollideable) {
			this.collider.setTransform(tform);
			this.collisionWorld.updateTransform(this.collider);
		}
	}
	popTickState() {
		if(this.isCollideable) {
			this.collider.setTransform(this._storedColliderTransform);
			this.collisionWorld.updateTransform(this.collider);
		}
	}
	computeNextPathStep(timeDelta) {
		this.stopped = false;
		let _this = this.position;
		this.prevPosition = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
		if(this.currentTime == this.targetTime) {
			let _this = this.velocity;
			_this.x = 0;
			_this.y = 0;
			_this.z = 0;
			_this.w = 1.;
		} else {
			let delta = 0.0;
			if(this.targetTime < 0) {
				if(this.targetTime == -1) {
					delta = timeDelta;
				} else if(this.targetTime == -2) {
					delta = -timeDelta;
				}
				this.currentTime += delta;
				while(this.currentTime >= this.duration) this.currentTime -= this.duration;
				while(this.currentTime < 0) this.currentTime += this.duration;
			} else {
				delta = this.targetTime - this.currentTime;
				if(delta < -timeDelta) {
					delta = -timeDelta;
				} else if(delta > timeDelta) {
					delta = timeDelta;
				}
				this.currentTime += delta;
			}
			let curTform = this.position;
			let tForm = this.getTransformAtTime(this.currentTime);
			let _this_x = 0.;
			let _this_y = 0.;
			let _this_z = 0.;
			let _this_w = 1.;
			let x = tForm._41;
			let y = tForm._42;
			let z = tForm._43;
			let w = tForm._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			_this_x = x;
			_this_y = y;
			_this_z = z;
			_this_w = w;
			let x1 = _this_x - curTform.x;
			let y1 = _this_y - curTform.y;
			let z1 = _this_z - curTform.z;
			if(z1 == null) {
				z1 = 0.;
			}
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let displaceDelta_x = x1;
			let displaceDelta_y = y1;
			let displaceDelta_z = z1;
			let _this = this.velocity;
			let x2 = displaceDelta_x / timeDelta;
			let y2 = displaceDelta_y / timeDelta;
			let z2 = displaceDelta_z / timeDelta;
			if(z2 == null) {
				z2 = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			_this.x = x2;
			_this.y = y2;
			_this.z = z2;
			_this.w = 1.;
			let _this1 = this.velocity;
			this.collider.velocity = new h3d_Vector(_this1.x,_this1.y,_this1.z,_this1.w);
		}
	}
	advance(timeDelta) {
		if(this.stopped) {
			return;
		}
		let _this = this.velocity;
		if(Math.sqrt(_this.x * _this.x + _this.y * _this.y + _this.z * _this.z) == 0) {
			return;
		}
		this.velocity.w = 0;
		let _this1 = this.position;
		let _this2 = this.velocity;
		let x = _this2.x * timeDelta;
		let y = _this2.y * timeDelta;
		let z = _this2.z * timeDelta;
		let w = _this2.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let v_x = x;
		let v_y = y;
		let v_z = z;
		let v_w = w;
		let newp = new h3d_Vector(_this1.x + v_x,_this1.y + v_y,_this1.z + v_z,_this1.w + v_w);
		let tform = this.getAbsPos().clone();
		tform._41 = newp.x;
		tform._42 = newp.y;
		tform._43 = newp.z;
		tform._44 = newp.w;
		if(this.isCollideable) {
			this.collider.setTransform(tform);
			this.collisionWorld.updateTransform(this.collider);
		}
		this.position = newp;
		if(this.soundChannel != null) {
			let spat = this.soundChannel.getEffect(hxd_snd_effect_Spatialization);
			spat.position = newp;
		}
	}
	update(timeState) {
		if(!this.stopped) {
			let x = this.prevPosition.x + this.velocity.x * timeState.dt;
			let y = this.prevPosition.y + this.velocity.y * timeState.dt;
			let z = this.prevPosition.z + this.velocity.z * timeState.dt;
			this.x = x;
			this.flags |= 1;
			this.y = y;
			this.flags |= 1;
			this.z = z;
			this.flags |= 1;
			this.flags |= 1;
		} else {
			let x = this.stoppedPosition.x;
			let y = this.stoppedPosition.y;
			let z = this.stoppedPosition.z;
			this.x = x;
			this.flags |= 1;
			this.y = y;
			this.flags |= 1;
			this.z = z;
			this.flags |= 1;
			this.flags |= 1;
		}
	}
	setStopped(stopped) {
		if(stopped == null) {
			stopped = true;
		}
		this.stopped = stopped;
		let _this = this.position;
		this.stoppedPosition = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
	}
	computeDuration() {
		let total = 0.0;
		let _g = 0;
		let _g1 = this.markerData.length;
		while(_g < _g1) {
			let i = _g++;
			let marker = this.markerData[i];
			total += marker.msToNext;
		}
		this.duration = total;
	}
	setTargetTime(now,target) {
		this.targetTime = target;
	}
	updatePosition() {
		let _this = this.getAbsPos();
		let v = new h3d_Vector();
		let x = _this._41;
		let y = _this._42;
		let z = _this._43;
		let w = _this._44;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		v.x = x;
		v.y = y;
		v.z = z;
		v.w = w;
		this.position = v;
		this.prevPosition = v;
		let x1 = v.x;
		let y1 = v.y;
		let z1 = v.z;
		this.x = x1;
		this.flags |= 1;
		this.y = y1;
		this.flags |= 1;
		this.z = z1;
		this.flags |= 1;
		this.flags |= 1;
		this.collider.setTransform(this.getTransform());
		this.collider.velocity = this.velocity;
		if(this.soundChannel != null) {
			let spat = this.soundChannel.getEffect(hxd_snd_effect_Spatialization);
			spat.position = v;
		}
	}
	getTransformAtTime(time) {
		let m1 = this.markerData[0];
		let m2 = this.markerData[1];
		if(m1 == null) {
			let tmp = new h3d_Matrix();
			let mat = h3d_Matrix.S(this.baseScale.x,this.baseScale.y,this.baseScale.z);
			let _this = this.baseOrientation;
			let m = tmp;
			if(tmp == null) {
				m = new h3d_Matrix();
			}
			let xx = _this.x * _this.x;
			let xy = _this.x * _this.y;
			let xz = _this.x * _this.z;
			let xw = _this.x * _this.w;
			let yy = _this.y * _this.y;
			let yz = _this.y * _this.z;
			let yw = _this.y * _this.w;
			let zz = _this.z * _this.z;
			let zw = _this.z * _this.w;
			m._11 = 1 - 2 * (yy + zz);
			m._12 = 2 * (xy + zw);
			m._13 = 2 * (xz - yw);
			m._14 = 0;
			m._21 = 2 * (xy - zw);
			m._22 = 1 - 2 * (xx + zz);
			m._23 = 2 * (yz + xw);
			m._24 = 0;
			m._31 = 2 * (xz + yw);
			m._32 = 2 * (yz - xw);
			m._33 = 1 - 2 * (xx + yy);
			m._34 = 0;
			m._41 = 0;
			m._42 = 0;
			m._43 = 0;
			m._44 = 1;
			mat.multiply3x4(mat,tmp);
			let v = this.basePosition;
			mat._41 = v.x;
			mat._42 = v.y;
			mat._43 = v.z;
			mat._44 = v.w;
			return mat;
		}
		let currentEndTime = m1.msToNext;
		let i = 2;
		while(currentEndTime < time && i < this.markerData.length) {
			m1 = m2;
			m2 = this.markerData[i++];
			currentEndTime += m1.msToNext;
		}
		if(m2 == null) {
			m2 = m1;
		}
		if(i == this.markerData.length && currentEndTime < time) {
			m1 = m2;
			m2 = this.markerData[0];
			currentEndTime += m1.msToNext;
		}
		let m1Time = currentEndTime - m1.msToNext;
		let m2Time = currentEndTime;
		let duration = m2Time - m1Time;
		let position = null;
		let value = duration != 0 ? (time - m1Time) / duration : 1;
		let compvarion = value < 0 ? 0 : value > 1 ? 1 : value;
		if(m1.smoothingType == "Accelerate") {
			compvarion = Math.sin(compvarion * Math.PI - Math.PI / 2) * 0.5 + 0.5;
		} else if(m1.smoothingType == "Spline") {
			let preStart = i - 2 - 1;
			let postEnd = i - 1 + 1;
			if(postEnd >= this.markerData.length) {
				postEnd = 0;
			}
			if(preStart < 0) {
				preStart = this.markerData.length - 1;
			}
			let p0 = this.markerData[preStart].position;
			let p1 = m1.position;
			let p2 = m2.position;
			let p3 = this.markerData[postEnd].position;
			position = new h3d_Vector();
			let p01 = p0.x;
			let p11 = p1.x;
			let p21 = p2.x;
			let p31 = p3.x;
			let point = compvarion * compvarion * compvarion * (-1 * p01 + 3 * p11 - 3 * p21 + p31) / 2;
			point += compvarion * compvarion * (2 * p01 - 5 * p11 + 4 * p21 - p31) / 2;
			point += compvarion * (-1 * p01 + p21) / 2;
			position.x = point += p11;
			let p02 = p0.y;
			let p12 = p1.y;
			let p22 = p2.y;
			let p32 = p3.y;
			let point1 = compvarion * compvarion * compvarion * (-1 * p02 + 3 * p12 - 3 * p22 + p32) / 2;
			point1 += compvarion * compvarion * (2 * p02 - 5 * p12 + 4 * p22 - p32) / 2;
			point1 += compvarion * (-1 * p02 + p22) / 2;
			position.y = point1 += p12;
			let p03 = p0.z;
			let p13 = p1.z;
			let p23 = p2.z;
			let p33 = p3.z;
			let point2 = compvarion * compvarion * compvarion * (-1 * p03 + 3 * p13 - 3 * p23 + p33) / 2;
			point2 += compvarion * compvarion * (2 * p03 - 5 * p13 + 4 * p23 - p33) / 2;
			point2 += compvarion * (-1 * p03 + p23) / 2;
			position.z = point2 += p13;
		}
		if(position == null) {
			let p1 = m1.position;
			let p2 = m2.position;
			let a = p1.x;
			let a1 = p1.y;
			let a2 = p1.z;
			let a3 = p1.w;
			position = new h3d_Vector(a + (p2.x - a) * compvarion,a1 + (p2.y - a1) * compvarion,a2 + (p2.z - a2) * compvarion,a3 + (p2.w - a3) * compvarion);
		}
		let firstPosition = this.markerData[0].position;
		let x = position.x - firstPosition.x;
		let y = position.y - firstPosition.y;
		let z = position.z - firstPosition.z;
		let w = position.w - firstPosition.w;
		if(w == null) {
			w = 1.;
		}
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let _this_x = x;
		let _this_y = y;
		let _this_z = z;
		let _this_w = w;
		let v = this.basePosition;
		position = new h3d_Vector(_this_x + v.x,_this_y + v.y,_this_z + v.z,_this_w + v.w);
		let tmp = new h3d_Matrix();
		let mat = h3d_Matrix.S(this.baseScale.x,this.baseScale.y,this.baseScale.z);
		let _this = this.baseOrientation;
		let m = tmp;
		if(tmp == null) {
			m = new h3d_Matrix();
		}
		let xx = _this.x * _this.x;
		let xy = _this.x * _this.y;
		let xz = _this.x * _this.z;
		let xw = _this.x * _this.w;
		let yy = _this.y * _this.y;
		let yz = _this.y * _this.z;
		let yw = _this.y * _this.w;
		let zz = _this.z * _this.z;
		let zw = _this.z * _this.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		mat.multiply3x4(mat,tmp);
		mat._41 = position.x;
		mat._42 = position.y;
		mat._43 = position.z;
		mat._44 = position.w;
		return mat;
	}
	reset() {
		this.currentTime = 0;
		this.targetTime = 0;
		if(this.element.initialposition != "") {
			this.currentTime = mis_MisParser.parseNumber(this.element.initialposition) / 1000;
		}
		if(this.element.initialtargetposition != "") {
			this.targetTime = mis_MisParser.parseNumber(this.element.initialtargetposition);
			if(this.targetTime > 0) {
				this.targetTime /= 1000;
			}
			if(this.targetTime > 0 && this.targetTime < 0.05) {
				this.currentTime = this.duration;
			}
		}
		this.stopped = false;
		this.velocity = new h3d_Vector();
		let initialTform = this.getTransformAtTime(this.currentTime);
		this.setTransform(initialTform);
		this.updatePosition();
	}
	static createFromSimGroup(simGroup,level,onFinish) {
		let _this = simGroup.elements;
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this.length) {
			let v = _this[_g1];
			++_g1;
			if(v._type == mis_MissionElementType.PathedInterior) {
				_g.push(v);
			}
		}
		let interiorElement = _g[0];
		let difFile = level.mission.getDifPath(interiorElement.interiorresource);
		if(difFile == null) {
			onFinish(null);
		}
		let pathedInterior = new src_PathedInterior();
		pathedInterior.level = level;
		pathedInterior.collisionWorld = level.collisionWorld;
		src_DifBuilder.loadDif(difFile,pathedInterior,function() {
			pathedInterior.identifier = difFile + interiorElement.interiorindex;
			pathedInterior.simGroup = simGroup;
			pathedInterior.element = interiorElement;
			level.interiors.push(pathedInterior);
			pathedInterior.init(level,function() {
				onFinish(pathedInterior);
			});
		},mis_MisParser.parseNumber(interiorElement.interiorindex));
	}
}
$hxClasses["src.PathedInterior"] = src_PathedInterior;
src_PathedInterior.__name__ = "src.PathedInterior";
src_PathedInterior.__super__ = src_InteriorObject;
Object.assign(src_PathedInterior.prototype, {
	__class__: src_PathedInterior
	,path: null
	,simGroup: null
	,element: null
	,triggers: null
	,markerData: null
	,duration: null
	,currentTime: null
	,targetTime: null
	,basePosition: null
	,baseOrientation: null
	,baseScale: null
	,prevPosition: null
	,position: null
	,velocity: null
	,_storedColliderTransform: null
	,stopped: null
	,stoppedPosition: null
	,soundChannel: null
});
class src_PathedInteriorMarker {
	constructor() {
	}
}
$hxClasses["src.PathedInteriorMarker"] = src_PathedInteriorMarker;
src_PathedInteriorMarker.__name__ = "src.PathedInteriorMarker";
Object.assign(src_PathedInteriorMarker.prototype, {
	__class__: src_PathedInteriorMarker
	,msToNext: null
	,smoothingType: null
	,position: null
	,rotation: null
});
class src_PreviewWorld extends src_Scheduler {
	constructor(scene) {
		src_Scheduler._hx_skip_constructor = true;
		super();
		src_Scheduler._hx_skip_constructor = false;
		this._hx_constructor(scene);
	}
	_hx_constructor(scene) {
		this._cubemapNeedsUpdate = false;
		this._loadToken = 0;
		this.ssAddTime = 0;
		this.itrAddTime = 0;
		this.marbles = [];
		this.dtsObjects = [];
		this.interiors = [];
		this.timeState = new src_TimeState();
		this.levelGroups = new haxe_ds_StringMap();
		super._hx_constructor();
		this.scene = scene;
	}
	init(onFinish) {
		let entry = src_ResourceLoader.getFileEntry("data/missions/megaMission.mis").entry;
		let misText = entry.getText();
		let mparser = new mis_MisParser(misText);
		this.misFile = mparser.parse();
		let _g = 0;
		let _g1 = this.misFile.root.elements;
		while(_g < _g1.length) {
			let elem = _g1[_g];
			++_g;
			if(elem._type == mis_MissionElementType.SimGroup) {
				this.levelGroups.h[elem._name.toLowerCase()] = elem;
			}
		}
		this.initScene();
		onFinish();
	}
	initScene() {
		let _g = 0;
		let _g1 = this.misFile.root.elements;
		while(_g < _g1.length) {
			let element = _g1[_g];
			++_g;
			if(element._type != mis_MissionElementType.Sun) {
				continue;
			}
			let sunElement = element;
			let directionalColor = mis_MisParser.parseVector4(sunElement.color);
			let ambientColor = mis_MisParser.parseVector4(sunElement.ambient);
			ambientColor.x *= 1.18;
			ambientColor.y *= 1.06;
			ambientColor.z *= 0.95;
			let sunDirection = mis_MisParser.parseVector3(sunElement.direction);
			sunDirection.x = -sunDirection.x;
			let ls = js_Boot.__cast(this.scene.lightSystem , h3d_scene_fwd_LightSystem);
			let _this = ls.ambientLight;
			_this.x = ambientColor.x;
			_this.y = ambientColor.y;
			_this.z = ambientColor.z;
			_this.w = ambientColor.w;
			let sunlight = new shaders_DirLight(sunDirection,this.scene);
			sunlight.set_color(directionalColor);
			return;
		}
	}
	loadMission(misname,onFinish,physics) {
		if(physics == null) {
			physics = false;
		}
		if(this.currentMission == misname) {
			onFinish();
			return;
		}
		this._loadToken++;
		let groupName = (misname + "group").toLowerCase();
		let group = this.levelGroups.h[groupName];
		let _gthis = this;
		if(group != null) {
			this.destroyAllObjects();
			this.currentMission = misname;
			this.instanceManager = new src_InstanceManager(this.scene);
			if(physics) {
				this.collisionWorld = new collision_CollisionWorld();
			} else {
				this.collisionWorld = null;
			}
			let p = new h3d_prim_Cube(0.001,0.001,0.001);
			p.addUVs();
			p.addTangents();
			let mat = h3d_mat_Material.create();
			new h3d_scene_Mesh(p,mat,this.scene);
			let itrpaths = [];
			let shapeDbs = [];
			let _g = 0;
			let _g1 = group.elements;
			while(_g < _g1.length) {
				let elem = _g1[_g];
				++_g;
				if(elem._type == mis_MissionElementType.InteriorInstance) {
					let itrElem = elem;
					itrpaths.push(itrElem);
				}
				if(elem._type == mis_MissionElementType.StaticShape) {
					let shapeElem = elem;
					shapeDbs.push(shapeElem);
				}
				if(elem._type == mis_MissionElementType.SpawnSphere) {
					let shapeElem = elem;
					if(shapeElem.datablock.toLowerCase() == "cameraspawnspheremarker") {
						let camPos = mis_MisParser.parseVector3(shapeElem.position);
						camPos.x *= -1;
						let camRot = mis_MisParser.parseRotation(shapeElem.rotation);
						camRot.x *= -1;
						camRot.w *= -1;
						let m = null;
						m = new h3d_Matrix();
						let xx = camRot.x * camRot.x;
						let xy = camRot.x * camRot.y;
						let xz = camRot.x * camRot.z;
						let xw = camRot.x * camRot.w;
						let yy = camRot.y * camRot.y;
						let yz = camRot.y * camRot.z;
						let yw = camRot.y * camRot.w;
						let zz = camRot.z * camRot.z;
						let zw = camRot.z * camRot.w;
						m._11 = 1 - 2 * (yy + zz);
						m._12 = 2 * (xy + zw);
						m._13 = 2 * (xz - yw);
						m._14 = 0;
						m._21 = 2 * (xy - zw);
						m._22 = 1 - 2 * (xx + zz);
						m._23 = 2 * (yz + xw);
						m._24 = 0;
						m._31 = 2 * (xz + yw);
						m._32 = 2 * (yz - xw);
						m._33 = 1 - 2 * (xx + yy);
						m._34 = 0;
						m._41 = 0;
						m._42 = 0;
						m._43 = 0;
						m._44 = 1;
						let camMat = m;
						let off_x = 0;
						let off_y = 0;
						let off_z = 1.5;
						let px = off_x * camMat._11 + off_y * camMat._21 + 1.5 * camMat._31;
						let py = off_x * camMat._12 + off_y * camMat._22 + 1.5 * camMat._32;
						let pz = off_x * camMat._13 + off_y * camMat._23 + 1.5 * camMat._33;
						off_x = px;
						off_y = py;
						off_z = pz;
						let directionVector_x = 0;
						let directionVector_y = 1;
						let directionVector_z = 0;
						let px1 = directionVector_x * camMat._11 + directionVector_y * camMat._21 + directionVector_z * camMat._31;
						let py1 = directionVector_x * camMat._12 + directionVector_y * camMat._22 + directionVector_z * camMat._32;
						let pz1 = directionVector_x * camMat._13 + directionVector_y * camMat._23 + directionVector_z * camMat._33;
						directionVector_x = px1;
						directionVector_y = py1;
						directionVector_z = pz1;
						this.scene.camera.setFovX(90,src_Settings.optionsSettings.screenWidth / src_Settings.optionsSettings.screenHeight);
						let _this = this.scene.camera.up;
						_this.x = 0;
						_this.y = 0;
						_this.z = 1;
						_this.w = 1.;
						let _this1 = this.scene.camera.pos;
						let x = camPos.x + off_x;
						let y = camPos.y + off_y;
						let z = camPos.z + off_z;
						let w = camPos.w + 1.;
						if(w == null) {
							w = 1.;
						}
						if(z == null) {
							z = 0.;
						}
						if(y == null) {
							y = 0.;
						}
						if(x == null) {
							x = 0.;
						}
						let v_x = x;
						let v_y = y;
						let v_z = z;
						let v_w = w;
						_this1.x = v_x;
						_this1.y = v_y;
						_this1.z = v_z;
						_this1.w = v_w;
						let _this2 = this.scene.camera.target;
						let _this3 = this.scene.camera.pos;
						let x1 = _this3.x + directionVector_x;
						let y1 = _this3.y + directionVector_y;
						let z1 = _this3.z + directionVector_z;
						let w1 = _this3.w + 1.;
						if(w1 == null) {
							w1 = 1.;
						}
						if(z1 == null) {
							z1 = 0.;
						}
						if(y1 == null) {
							y1 = 0.;
						}
						if(x1 == null) {
							x1 = 0.;
						}
						let v_x1 = x1;
						let v_y1 = y1;
						let v_z1 = z1;
						let v_w1 = w1;
						_this2.x = v_x1;
						_this2.y = v_y1;
						_this2.z = v_z1;
						_this2.w = v_w1;
					}
				}
			}
			let difficulty = "beginner";
			let mis = src_MissionList.missionsFilenameLookup.h[(misname + ".mis").toLowerCase()];
			if(misname == "marblepicker") {
				difficulty = "advanced";
			} else {
				difficulty = mis.type;
			}
			let curToken = this._loadToken;
			let worker = new src_ResourceLoaderWorker(onFinish);
			worker.addTask(function(fwd) {
				if(_gthis._loadToken != curToken) {
					fwd();
				} else {
					_gthis.addScenery(difficulty,fwd);
				}
			});
			this.itrAddTime = 0;
			this.ssAddTime = 0;
			let _g2 = 0;
			while(_g2 < itrpaths.length) {
				let elem = itrpaths[_g2];
				++_g2;
				worker.addTask(function(fwd) {
					if(_gthis._loadToken != curToken) {
						fwd();
					} else {
						let startTime = HxOverrides.now() / 1000;
						_gthis.addInteriorFromMis(elem,curToken,function() {
							_gthis.itrAddTime += HxOverrides.now() / 1000 - startTime;
							fwd();
						},physics);
					}
				});
			}
			let _g3 = 0;
			while(_g3 < shapeDbs.length) {
				let elem = shapeDbs[_g3];
				++_g3;
				worker.addTask(function(fwd) {
					if(_gthis._loadToken != curToken) {
						fwd();
					} else {
						let startTime = HxOverrides.now() / 1000;
						_gthis.addStaticShape(elem,curToken,function() {
							_gthis.ssAddTime += HxOverrides.now() / 1000 - startTime;
							fwd();
						});
					}
				});
			}
			worker.addTask(function(fwd) {
				_gthis.timeState.timeSinceLoad = 0;
				_gthis.timeState.dt = 0;
				src_Console.instance.addEntry("log","ITR ADD TIME: " + _gthis.itrAddTime);
				src_Console.instance.addEntry("log","SS ADD TIME: " + _gthis.ssAddTime);
				fwd();
			});
			worker.run();
		} else {
			onFinish();
		}
	}
	addScenery(difficulty,onFinish) {
		let worker = new src_ResourceLoaderWorker(onFinish);
		let astrolabe = new shapes_Astrolabe();
		astrolabe.x = 0;
		astrolabe.flags |= 1;
		astrolabe.y = 0;
		astrolabe.flags |= 1;
		astrolabe.z = -612.988;
		astrolabe.flags |= 1;
		astrolabe.flags |= 1;
		let _gthis = this;
		worker.addTask(function(fwd) {
			astrolabe.init(null,function() {
				_gthis.scene.addChild(astrolabe);
				_gthis.dtsObjects.push(astrolabe);
				fwd();
			});
		});
		let clouds = new shapes_Sky("astrolabeclouds" + difficulty + "shape");
		worker.addTask(function(fwd) {
			clouds.init(null,function() {
				_gthis.scene.addChild(clouds);
				fwd();
			});
		});
		let skyElem = new mis_MissionElementSky();
		skyElem.fogcolor = "0.600000 0.600000 0.600000 1.000000";
		skyElem.skysolidcolor = "0.600000 0.600000 0.600000 1.000000";
		let skyDml = "data/skies/sky_" + difficulty + ".dml";
		this.sky = new src_Sky();
		this.sky.dmlPath = src_ResourceLoader.getProperFilepath(skyDml);
		worker.addTask(function(fwd) {
			_gthis.sky.init(null,function() {
				_gthis.scene.addChild(_gthis.sky);
				let _this = _gthis.sky;
				let x = _gthis.scene.camera.pos.x;
				let y = _gthis.scene.camera.pos.y;
				let z = _gthis.scene.camera.pos.z;
				_this.x = x;
				_this.flags |= 1;
				_this.y = y;
				_this.flags |= 1;
				_this.z = z;
				_this.flags |= 1;
				_this.flags |= 1;
				fwd();
			},skyElem);
		});
		if(net_Net.isMP) {
			worker.loadFile("sound/spawn_alternate.wav");
			worker.loadFile("sound/infotutorial.wav");
		}
		worker.run();
	}
	destroyAllObjects() {
		this.currentMission = null;
		this.collisionWorld = null;
		let _g = 0;
		let _g1 = this.interiors;
		while(_g < _g1.length) {
			let itr = _g1[_g];
			++_g;
			itr.dispose();
		}
		let _g2 = 0;
		let _g3 = this.dtsObjects;
		while(_g2 < _g3.length) {
			let shape = _g3[_g2];
			++_g2;
			shape.dispose();
		}
		let _g4 = 0;
		let _g5 = this.marbles;
		while(_g4 < _g5.length) {
			let marb = _g5[_g4];
			++_g4;
			marb.dispose();
		}
		src_DtsObject.disposeShared();
		this.interiors = [];
		this.dtsObjects = [];
		this.marbles = [];
		this.scene.removeChildren();
	}
	addInteriorFromMis(element,token,onFinish,physics) {
		if(physics == null) {
			physics = false;
		}
		let difPath = this.getDifPath(element.interiorfile);
		if(difPath == "" || token != this._loadToken) {
			onFinish();
			return;
		}
		src_Console.instance.addEntry("log","Adding interior: " + difPath);
		let interior = new src_InteriorObject();
		interior.interiorFile = difPath;
		interior.isCollideable = physics;
		this.addInterior(interior,token,function() {
			let interiorPosition = mis_MisParser.parseVector3(element.position);
			interiorPosition.x = -interiorPosition.x;
			let interiorRotation = mis_MisParser.parseRotation(element.rotation);
			interiorRotation.x = -interiorRotation.x;
			interiorRotation.w = -interiorRotation.w;
			let interiorScale = mis_MisParser.parseVector3(element.scale);
			let hasCollision = interiorScale.x * interiorScale.y * interiorScale.z != 0;
			if(interiorScale.x == 0) {
				interiorScale.x = 0.0001;
			}
			if(interiorScale.y == 0) {
				interiorScale.y = 0.0001;
			}
			if(interiorScale.z == 0) {
				interiorScale.z = 0.0001;
			}
			let mat = h3d_Matrix.S(interiorScale.x,interiorScale.y,interiorScale.z);
			let tmp = new h3d_Matrix();
			let m = tmp;
			if(tmp == null) {
				m = new h3d_Matrix();
			}
			let xx = interiorRotation.x * interiorRotation.x;
			let xy = interiorRotation.x * interiorRotation.y;
			let xz = interiorRotation.x * interiorRotation.z;
			let xw = interiorRotation.x * interiorRotation.w;
			let yy = interiorRotation.y * interiorRotation.y;
			let yz = interiorRotation.y * interiorRotation.z;
			let yw = interiorRotation.y * interiorRotation.w;
			let zz = interiorRotation.z * interiorRotation.z;
			let zw = interiorRotation.z * interiorRotation.w;
			m._11 = 1 - 2 * (yy + zz);
			m._12 = 2 * (xy + zw);
			m._13 = 2 * (xz - yw);
			m._14 = 0;
			m._21 = 2 * (xy - zw);
			m._22 = 1 - 2 * (xx + zz);
			m._23 = 2 * (yz + xw);
			m._24 = 0;
			m._31 = 2 * (xz + yw);
			m._32 = 2 * (yz - xw);
			m._33 = 1 - 2 * (xx + yy);
			m._34 = 0;
			m._41 = 0;
			m._42 = 0;
			m._43 = 0;
			m._44 = 1;
			mat.multiply3x4(mat,tmp);
			let tmat = h3d_Matrix.T(interiorPosition.x,interiorPosition.y,interiorPosition.z);
			mat.multiply(mat,tmat);
			interior.setTransform(mat);
			interior.isCollideable = hasCollision && physics;
			onFinish();
		},physics);
	}
	addInterior(obj,token,onFinish,physics) {
		if(physics == null) {
			physics = false;
		}
		if(token != this._loadToken) {
			onFinish();
			return;
		}
		this.interiors.push(obj);
		let t = HxOverrides.now() / 1000;
		let _gthis = this;
		obj.init(null,function() {
			if(token != _gthis._loadToken) {
				onFinish();
				return;
			}
			let interval = HxOverrides.now() / 1000 - t;
			src_Console.instance.addEntry("log","Init interior: " + interval + "ms");
			if(obj.useInstancing) {
				_gthis.instanceManager.addObject(obj);
			} else {
				_gthis.scene.addChild(obj);
			}
			if(physics) {
				_gthis.collisionWorld.addEntity(obj.collider);
				obj.collisionWorld = _gthis.collisionWorld;
			}
			onFinish();
		});
	}
	addStaticShape(element,token,onFinish) {
		if(token != this._loadToken) {
			onFinish();
			return;
		}
		let shape = null;
		let dataBlockLowerCase = element.datablock.toLowerCase();
		if(dataBlockLowerCase != "") {
			if(dataBlockLowerCase == "startpad") {
				shape = new shapes_StartPad();
			} else if(dataBlockLowerCase == "endpad") {
				shape = new shapes_EndPad();
			} else if(dataBlockLowerCase.startsWith("arrow")) {
				shape = new shapes_SignPlain(element);
			} else if(dataBlockLowerCase.startsWith("gemitem")) {
				shape = new shapes_Gem(element);
			} else if(dataBlockLowerCase == "superjumpitem") {
				shape = new shapes_SuperJump(element);
			} else if(dataBlockLowerCase.startsWith("signcaution")) {
				shape = new shapes_SignCaution(element);
			} else if(dataBlockLowerCase == "roundbumper") {
				shape = new shapes_RoundBumper();
			} else if(dataBlockLowerCase == "helicopteritem") {
				shape = new shapes_Helicopter(element);
			} else if(dataBlockLowerCase == "eastereggitem") {
				shape = new shapes_EasterEgg(element);
			} else if(dataBlockLowerCase == "checkpointshape") {
				shape = new shapes_Checkpoint(element);
			} else if(dataBlockLowerCase == "ductfan") {
				shape = new shapes_DuctFan();
			} else if(dataBlockLowerCase == "smallductfan") {
				shape = new shapes_SmallDuctFan();
			} else if(dataBlockLowerCase == "antigravityitem") {
				shape = new shapes_AntiGravity(element);
			} else if(dataBlockLowerCase == "norespawnantigravityitem") {
				shape = new shapes_AntiGravity(element,true);
			} else if(dataBlockLowerCase == "superspeeditem") {
				shape = new shapes_SuperSpeed(element);
			} else if(dataBlockLowerCase == "timetravelitem" || dataBlockLowerCase == "timepenaltyitem") {
				shape = new shapes_TimeTravel(element);
			} else if(dataBlockLowerCase == "blastitem") {
				shape = new shapes_Blast(element);
			} else if(dataBlockLowerCase == "megamarbleitem") {
				shape = new shapes_MegaMarble(element);
			} else if(dataBlockLowerCase == "trapdoor") {
				shape = new shapes_Trapdoor();
			} else if(["glass_3shape","glass_6shape","glass_9shape","glass_12shape","glass_15shape","glass_18shape"].includes(dataBlockLowerCase)) {
				shape = new shapes_Glass(element);
			} else if(["astrolabecloudsbeginnershape","astrolabecloudsintermediateshape","astrolabecloudsadvancedshape"].includes(dataBlockLowerCase)) {
				shape = new shapes_Sky(dataBlockLowerCase);
			} else if(dataBlockLowerCase == "astrolabeshape") {
				shape = new shapes_Astrolabe();
			} else {
				src_Console.instance.addEntry("error","Unknown item: " + element.datablock);
				onFinish();
				return;
			}
		}
		let shapePosition = mis_MisParser.parseVector3(element.position);
		shapePosition.x = -shapePosition.x;
		let shapeRotation = mis_MisParser.parseRotation(element.rotation);
		shapeRotation.x = -shapeRotation.x;
		shapeRotation.w = -shapeRotation.w;
		let shapeScale = mis_MisParser.parseVector3(element.scale);
		if(shapeScale.x == 0) {
			shapeScale.x = 0.0001;
		}
		if(shapeScale.y == 0) {
			shapeScale.y = 0.0001;
		}
		if(shapeScale.z == 0) {
			shapeScale.z = 0.0001;
		}
		let mat = h3d_Matrix.S(shapeScale.x,shapeScale.y,shapeScale.z);
		let tmp = new h3d_Matrix();
		let m = tmp;
		if(tmp == null) {
			m = new h3d_Matrix();
		}
		let xx = shapeRotation.x * shapeRotation.x;
		let xy = shapeRotation.x * shapeRotation.y;
		let xz = shapeRotation.x * shapeRotation.z;
		let xw = shapeRotation.x * shapeRotation.w;
		let yy = shapeRotation.y * shapeRotation.y;
		let yz = shapeRotation.y * shapeRotation.z;
		let yw = shapeRotation.y * shapeRotation.w;
		let zz = shapeRotation.z * shapeRotation.z;
		let zw = shapeRotation.z * shapeRotation.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		mat.multiply3x4(mat,tmp);
		mat._41 = shapePosition.x;
		mat._42 = shapePosition.y;
		mat._43 = shapePosition.z;
		mat._44 = shapePosition.w;
		shape.isCollideable = false;
		shape.isBoundingBoxCollideable = false;
		let _gthis = this;
		this.addDtsObject(shape,token,function() {
			if(token != _gthis._loadToken) {
				onFinish();
				return;
			}
			shape.setTransform(mat);
			onFinish();
		});
	}
	addDtsObject(obj,token,onFinish,isTsStatic) {
		if(isTsStatic == null) {
			isTsStatic = false;
		}
		if(token != this._loadToken) {
			onFinish();
			return;
		}
		let _gthis = this;
		src_ResourceLoader.load(obj.dtsPath).entry.load(function() {
			if(token != _gthis._loadToken) {
				onFinish();
				return;
			}
			let dtsFile = src_ResourceLoader.loadDts(obj.dtsPath);
			let texToLoad = obj.getPreloadMaterials(dtsFile.resource);
			let worker = new src_ResourceLoaderWorker(function() {
				obj.isTSStatic = isTsStatic;
				_gthis.dtsObjects.push(obj);
				obj.init(null,function() {
					if(token != _gthis._loadToken) {
						onFinish();
						return;
					}
					obj.update(_gthis.timeState);
					if(obj.useInstancing) {
						_gthis.instanceManager.addObject(obj);
					} else {
						_gthis.scene.addChild(obj);
					}
					onFinish();
				});
			});
			let _g = 0;
			while(_g < texToLoad.length) {
				let texPath = texToLoad[_g];
				++_g;
				worker.loadFile(texPath);
			}
			worker.run();
		});
	}
	getDifPath(rawElementPath) {
		if(rawElementPath.includes("$usermods")) {
			let _this = rawElementPath.split("@").slice(1);
			let result = new Array(_this.length);
			let _g = 0;
			let _g1 = _this.length;
			while(_g < _g1) {
				let i = _g++;
				let a = StringTools.trim(_this[i]);
				a = src_Util.unescape(HxOverrides.substr(a,1,a.length - 2));
				result[i] = a;
			}
			rawElementPath = result.join("");
		}
		let fname = rawElementPath.substring(rawElementPath.lastIndexOf("/") + 1);
		rawElementPath = rawElementPath.toLowerCase();
		if(rawElementPath.startsWith("./")) {
			rawElementPath = rawElementPath.substring(2);
			rawElementPath = "data/missions/" + rawElementPath;
		}
		let path = StringTools.replace(rawElementPath.substring(rawElementPath.indexOf("data/")),"\"","");
		path = StringTools.replace(path,"data/","");
		if(!path.endsWith(".dif")) {
			path += ".dif";
		}
		if(src_ResourceLoader.exists(path)) {
			return path;
		}
		if(path.includes("interiors_mbg/")) {
			path = StringTools.replace(path,"interiors_mbg/","interiors/");
		}
		let dirpath = path.substring(0,path.lastIndexOf("/") + 1);
		if(src_ResourceLoader.exists(path)) {
			return path;
		}
		if(src_ResourceLoader.exists(dirpath + fname)) {
			return dirpath + fname;
		}
		path = StringTools.replace(path,"lbinteriors","interiors");
		if(src_ResourceLoader.exists(path)) {
			return path;
		}
		src_Console.instance.addEntry("error","Interior resource not found: " + rawElementPath);
		return "";
	}
	spawnMarble(onFinish) {
		let marb = new src_Marble();
		marb.controllable = false;
		let _gthis = this;
		marb.init(null,null,function() {
			marb.collisionWorld = _gthis.collisionWorld;
			_gthis.collisionWorld.addMovingEntity(marb.collider);
			_gthis.scene.addChild(marb);
			_gthis.marbles.push(marb);
			onFinish(marb);
		});
	}
	removeMarble(marb) {
		if(HxOverrides.remove(this.marbles,marb)) {
			this.scene.removeChild(marb);
			this.collisionWorld.removeMovingEntity(marb.collider);
			marb.dispose();
		}
	}
	update(dt) {
		this.timeState.dt = dt;
		this.timeState.timeSinceLoad += dt;
		let _g = 0;
		let _g1 = this.dtsObjects;
		while(_g < _g1.length) {
			let dts = _g1[_g];
			++_g;
			dts.update(this.timeState);
		}
		let _g2 = 0;
		let _g3 = this.marbles;
		while(_g2 < _g3.length) {
			let marb = _g3[_g2];
			++_g2;
			marb.update(this.timeState,this.collisionWorld,[]);
		}
		this._cubemapNeedsUpdate = true;
		src_Renderer.dirtyBuffers = true;
		this.instanceManager.render();
	}
	render(e) {
		let _g = 0;
		let _g1 = this.marbles;
		while(_g < _g1.length) {
			let marble = _g1[_g];
			++_g;
			if(marble != null && marble.cubemapRenderer != null) {
				if(this._cubemapNeedsUpdate) {
					let _this = marble.cubemapRenderer.position;
					let _this1 = marble.getAbsPos();
					let v_x = 0.;
					let v_y = 0.;
					let v_z = 0.;
					let v_w = 1.;
					let x = _this1._41;
					let y = _this1._42;
					let z = _this1._43;
					let w = _this1._44;
					if(w == null) {
						w = 1.;
					}
					if(z == null) {
						z = 0.;
					}
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					v_x = x;
					v_y = y;
					v_z = z;
					v_w = w;
					_this.x = v_x;
					_this.y = v_y;
					_this.z = v_z;
					_this.w = v_w;
					marble.cubemapRenderer.render(e);
					this._cubemapNeedsUpdate = false;
				}
			}
		}
	}
}
$hxClasses["src.PreviewWorld"] = src_PreviewWorld;
src_PreviewWorld.__name__ = "src.PreviewWorld";
src_PreviewWorld.__super__ = src_Scheduler;
Object.assign(src_PreviewWorld.prototype, {
	__class__: src_PreviewWorld
	,scene: null
	,instanceManager: null
	,collisionWorld: null
	,misFile: null
	,currentMission: null
	,levelGroups: null
	,timeState: null
	,interiors: null
	,dtsObjects: null
	,marbles: null
	,sky: null
	,itrAddTime: null
	,ssAddTime: null
	,_loadToken: null
	,_cubemapNeedsUpdate: null
});
class src_ProfilerUI {
	constructor(s2d) {
		if(src_ProfilerUI.instance != null) {
			return;
		}
		src_ProfilerUI.instance = this;
		this.s2d = s2d;
	}
	static begin(type) {
		if(!src_ProfilerUI.enabled) {
			return;
		}
		if(type == src_ProfilerUI.mode) {
			src_ProfilerUI.instance.debugProfiler.begin();
		}
	}
	static measure(name,type) {
		if(!src_ProfilerUI.enabled) {
			return;
		}
		if(type == src_ProfilerUI.mode) {
			src_ProfilerUI.instance.debugProfiler.measure(name);
		}
	}
	static end(type) {
		if(!src_ProfilerUI.enabled) {
			return;
		}
		if(type == src_ProfilerUI.mode) {
			src_ProfilerUI.instance.debugProfiler.end();
		}
	}
	static update(fps) {
		src_ProfilerUI.instance.fps = fps;
		if(!src_ProfilerUI.enabled) {
			return;
		}
		src_ProfilerUI.instance.fpsCounter.set_text("FPS: " + fps);
		src_ProfilerUI.updateNetworkStats();
	}
	static setEnabled(val) {
		src_ProfilerUI.enabled = val;
		if(src_ProfilerUI.enabled) {
			if(src_ProfilerUI.instance.debugProfiler != null) {
				let _this = src_ProfilerUI.instance.debugProfiler;
				if(_this != null && _this.parent != null) {
					_this.parent.removeChild(_this);
				}
				src_ProfilerUI.instance.debugProfiler = null;
			}
			if(src_ProfilerUI.instance.fpsCounter != null) {
				let _this = src_ProfilerUI.instance.fpsCounter;
				if(_this != null && _this.parent != null) {
					_this.parent.removeChild(_this);
				}
				src_ProfilerUI.instance.fpsCounter = null;
			}
			if(src_ProfilerUI.instance.networkStats != null) {
				let _this = src_ProfilerUI.instance.networkStats;
				if(_this != null && _this.parent != null) {
					_this.parent.removeChild(_this);
				}
				src_ProfilerUI.instance.networkStats = null;
			}
			src_ProfilerUI.instance.debugProfiler = new h3d_impl_Benchmark(src_ProfilerUI.instance.s2d);
			let _this = src_ProfilerUI.instance.debugProfiler;
			_this.posChanged = true;
			_this.y = 40;
			let tmp = hxd_res_DefaultFont.get();
			src_ProfilerUI.instance.fpsCounter = new h2d_Text(tmp,src_ProfilerUI.instance.s2d);
			let _this1 = src_ProfilerUI.instance.fpsCounter;
			_this1.posChanged = true;
			_this1.y = 80;
			src_ProfilerUI.instance.fpsCounter.color = new h3d_Vector(1,1,1,1);
			let tmp1 = hxd_res_DefaultFont.get();
			src_ProfilerUI.instance.networkStats = new h2d_Text(tmp1,src_ProfilerUI.instance.s2d);
			let _this2 = src_ProfilerUI.instance.networkStats;
			_this2.posChanged = true;
			_this2.y = 150;
			src_ProfilerUI.instance.networkStats.color = new h3d_Vector(1,1,1,1);
			src_ProfilerUI.instance.debugProfiler.end();
		} else {
			let _this = src_ProfilerUI.instance.debugProfiler;
			if(_this != null && _this.parent != null) {
				_this.parent.removeChild(_this);
			}
			let _this1 = src_ProfilerUI.instance.fpsCounter;
			if(_this1 != null && _this1.parent != null) {
				_this1.parent.removeChild(_this1);
			}
			let _this2 = src_ProfilerUI.instance.networkStats;
			if(_this2 != null && _this2.parent != null) {
				_this2.parent.removeChild(_this2);
			}
			src_ProfilerUI.instance.debugProfiler = null;
			src_ProfilerUI.instance.fpsCounter = null;
			src_ProfilerUI.instance.networkStats = null;
		}
	}
	static setDisplayMode(m) {
		src_ProfilerUI.mode = m;
		if(src_ProfilerUI.instance.debugProfiler != null) {
			src_ProfilerUI.instance.debugProfiler.end();
		}
	}
	static updateNetworkStats() {
		if(src_MarbleGame.instance.world != null && src_MarbleGame.instance.world.isMultiplayer) {
			if(net_Net.isClient && net_Net.clientConnection.moveManager.queuedMoves.length > 0) {
				src_ProfilerUI.updateNetworkStats_lastSentMove = net_Net.clientConnection.moveManager.queuedMoves[net_Net.clientConnection.moveManager.queuedMoves.length - 1].id;
			}
			if(net_Net.isClient && src_ProfilerUI.updateNetworkStats_lastSentMove != 0 && src_MarbleGame.instance.world.lastMoves != null && src_MarbleGame.instance.world.lastMoves.myMarbleUpdate != null) {
				src_ProfilerUI.instance.networkStats.set_text("Client World Ticks: " + src_MarbleGame.instance.world.timeState.ticks + "\n" + ("Client Marble Ticks: " + src_MarbleGame.instance.world.marble.serverTicks + "\n") + ("Server Ticks: " + src_MarbleGame.instance.world.lastMoves.myMarbleUpdate.serverTicks + "\n") + ("Client Move Queue Size: " + (net_Net.isClient ? net_Net.clientConnection.moveManager.queuedMoves.length : 0) + "\n") + ("Server Move Queue Size: " + (net_Net.isClient ? src_MarbleGame.instance.world.lastMoves.myMarbleUpdate.moveQueueSize : 0) + "\n") + ("Last Sent Move: " + (net_Net.isClient ? src_ProfilerUI.updateNetworkStats_lastSentMove : 0) + "\n") + ("Last Ack Move: " + (net_Net.isClient ? net_Net.clientConnection.moveManager.lastAckMoveId : 0) + "\n") + ("Move Ack RTT: " + (net_Net.isClient ? net_Net.clientConnection.moveManager.ackRTT : 0)));
			}
			if(net_Net.isHost) {
				let strs = [];
				strs.push("World Ticks: " + src_MarbleGame.instance.world.timeState.ticks);
				let this1 = net_Net.clients;
				let _g_keys = this1.keys();
				while(_g_keys.hasNext()) {
					let key = _g_keys.next();
					let _g_value = this1.get(key);
					strs.push("" + _g_value.id + " move: sz " + _g_value.moveManager.queuedMoves.length + " avg " + _g_value.moveManager.serverAvgMoveListSize);
				}
				src_ProfilerUI.instance.networkStats.set_text(strs.join("\n"));
			}
		} else {
			src_ProfilerUI.instance.networkStats.set_text("");
		}
	}
}
$hxClasses["src.ProfilerUI"] = src_ProfilerUI;
src_ProfilerUI.__name__ = "src.ProfilerUI";
Object.assign(src_ProfilerUI.prototype, {
	__class__: src_ProfilerUI
	,fpsCounter: null
	,networkStats: null
	,debugProfiler: null
	,s2d: null
	,fps: null
});
class src_Radar {
	constructor(level,scene2d) {
		this._dirty = false;
		this.time = 0.0;
		this.minArrowFraction = 0.4;
		this.maxTargetAlpha = 0.4;
		this.maxArrowAlpha = 0.6;
		this.fullArrowWidth = 40.0;
		this.fullArrowLength = 60.0;
		this.ellipseScreenFraction = new h3d_Vector(0.79,0.9);
		this.level = level;
		this.scene2d = scene2d;
		this.marbleNameTexts = new haxe_ds_ObjectMap();
	}
	init() {
		this.g = new gui_Graphics(this.scene2d);
	}
	update(dt) {
		this.time += dt;
		this._dirty = true;
	}
	render() {
		if(!this._dirty) {
			return;
		}
		this.g.clear();
		let gemCount = 0;
		let _g = 0;
		let _g1 = this.level.gems;
		while(_g < _g1.length) {
			let gem = _g1[_g];
			++_g;
			if(!gem.pickedUp) {
				let _this = gem.boundingCollider.boundingBox;
				let x = (_this.xMin + _this.xMax) * 0.5;
				let y = (_this.yMin + _this.yMax) * 0.5;
				let z = (_this.zMin + _this.zMax) * 0.5;
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let _this_x = x;
				let _this_y = y;
				let _this_z = z;
				this.renderArrow(new h3d_Vector(_this_x,_this_y,_this_z),gem.radarColor);
				++gemCount;
			}
		}
		if(this.level.endPad != null && gemCount == 0) {
			let _this = this.level.endPad.getAbsPos();
			let v = new h3d_Vector();
			let x = _this._41;
			let y = _this._42;
			let z = _this._43;
			let w = _this._44;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			v.x = x;
			v.y = y;
			v.z = z;
			v.w = w;
			this.renderArrow(v,15132390);
		}
		let fadeDistance = this.level.scene.camera.zFar * 0.1;
		let this1 = this.marbleNameTexts;
		let _g_keys = this1.keys();
		while(_g_keys.hasNext()) {
			let key = _g_keys.next();
			let _g_value = this1.get(key);
			if(_g_value != null) {
				_g_value.alpha = 0;
			}
		}
		let _g2 = 0;
		let _g3 = this.level.marbles;
		while(_g2 < _g3.length) {
			let marble = _g3[_g2];
			++_g2;
			if(marble != this.level.marble) {
				let _this = marble.getAbsPos();
				let v = new h3d_Vector();
				let x = _this._41;
				let y = _this._42;
				let z = _this._43;
				let w = _this._44;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				v.x = x;
				v.y = y;
				v.z = z;
				v.w = w;
				let v1 = this.level.scene.camera.pos;
				let x1 = v.x - v1.x;
				let y1 = v.y - v1.y;
				let z1 = v.z - v1.z;
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let shapeDir_x = x1;
				let shapeDir_y = y1;
				let shapeDir_z = z1;
				let shapeDist = shapeDir_x * shapeDir_x + shapeDir_y * shapeDir_y + shapeDir_z * shapeDir_z;
				if(shapeDist == 0 || shapeDist > this.level.scene.camera.zFar * this.level.scene.camera.zFar) {
					this.dontRenderName(marble);
					continue;
				}
				let validProjection = this.frustumHasPoint(this.level.scene.camera.frustum,v);
				if(!validProjection) {
					this.dontRenderName(marble);
					continue;
				}
				v.z += 0.5;
				let projectedPos = this.level.scene.camera.project(v.x,v.y,v.z,this.scene2d.width,this.scene2d.height);
				let opacity = shapeDist < fadeDistance ? 1.0 : 1.0 - (shapeDist - fadeDistance) / (this.level.scene.camera.zFar - fadeDistance);
				this.renderName(projectedPos,marble,opacity);
			}
		}
		this._dirty = false;
	}
	blink() {
		this.time = 0;
	}
	reset() {
		this.time = 0;
		this.g.clear();
	}
	dispose() {
		this.g.clear();
		this.scene2d.removeChild(this.g);
		this.g = null;
		let txt = this.marbleNameTexts.iterator();
		while(txt.hasNext()) {
			let txt1 = txt.next();
			if(txt1 != null) {
				this.scene2d.removeChild(txt1);
			}
		}
		this.marbleNameTexts = null;
	}
	frustumHasPoint(frustum,p) {
		let plane = frustum.pleft;
		if(plane.nx * p.x + plane.ny * p.y + plane.nz * p.z - plane.d < 0) {
			return false;
		}
		let plane1 = frustum.pright;
		if(plane1.nx * p.x + plane1.ny * p.y + plane1.nz * p.z - plane1.d < 0) {
			return false;
		}
		let plane2 = frustum.ptop;
		if(plane2.nx * p.x + plane2.ny * p.y + plane2.nz * p.z - plane2.d < 0) {
			return false;
		}
		let plane3 = frustum.pbottom;
		if(plane3.nx * p.x + plane3.ny * p.y + plane3.nz * p.z - plane3.d < 0) {
			return false;
		}
		if(frustum.checkNearFar) {
			let plane = frustum.pnear;
			if(plane.nx * p.x + plane.ny * p.y + plane.nz * p.z - plane.d < 0) {
				return false;
			}
			let plane1 = frustum.pfar;
			if(plane1.nx * p.x + plane1.ny * p.y + plane1.nz * p.z - plane1.d < 0) {
				return false;
			}
		}
		return true;
	}
	renderArrow(pos,color) {
		let validProjection = this.frustumHasPoint(this.level.scene.camera.frustum,pos);
		let projectedPos = this.level.scene.camera.project(pos.x,pos.y,pos.z,this.scene2d.width,this.scene2d.height);
		let fovX = this.level.scene.camera.getFovX() * 0.5 * Math.PI / 180.0;
		let fovY = this.level.scene.camera.fovY * 0.5 * Math.PI / 180.0;
		let blink = this.time < 3 && (Math.floor(this.time * 1000 / 500) | 0) % 2 == 1;
		let _this = this.level.getOrientationQuat(this.level.timeState.currentAttemptTime);
		let m = null;
		m = new h3d_Matrix();
		let xx = _this.x * _this.x;
		let xy = _this.x * _this.y;
		let xz = _this.x * _this.z;
		let xw = _this.x * _this.w;
		let yy = _this.y * _this.y;
		let yz = _this.y * _this.z;
		let yw = _this.y * _this.w;
		let zz = _this.z * _this.z;
		let zw = _this.z * _this.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		let gravityMat = m;
		let _this1 = this.level.scene.camera.target;
		let v = this.level.scene.camera.pos;
		let x = _this1.x - v.x;
		let y = _this1.y - v.y;
		let z = _this1.z - v.z;
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let _this_x = x;
		let _this_y = y;
		let _this_z = z;
		let k = _this_x * _this_x + _this_y * _this_y + _this_z * _this_z;
		if(k < 1e-10) {
			k = 0;
		} else {
			k = 1. / Math.sqrt(k);
		}
		let x1 = _this_x * k;
		let y1 = _this_y * k;
		let z1 = _this_z * k;
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let front_x = x1;
		let front_y = y1;
		let front_z = z1;
		let x2 = gravityMat._31;
		let y2 = gravityMat._32;
		let z2 = gravityMat._33;
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let up_x = x2;
		let up_y = y2;
		let up_z = z2;
		let k1 = up_x * up_x + up_y * up_y + up_z * up_z;
		if(k1 < 1e-10) {
			k1 = 0;
		} else {
			k1 = 1. / Math.sqrt(k1);
		}
		up_x *= k1;
		up_y *= k1;
		up_z *= k1;
		let x3 = up_y * front_z - up_z * front_y;
		let y3 = up_z * front_x - up_x * front_z;
		let z3 = up_x * front_y - up_y * front_x;
		if(z3 == null) {
			z3 = 0.;
		}
		if(y3 == null) {
			y3 = 0.;
		}
		if(x3 == null) {
			x3 = 0.;
		}
		let _this_x1 = x3;
		let _this_y1 = y3;
		let _this_z1 = z3;
		let k2 = _this_x1 * _this_x1 + _this_y1 * _this_y1 + _this_z1 * _this_z1;
		if(k2 < 1e-10) {
			k2 = 0;
		} else {
			k2 = 1. / Math.sqrt(k2);
		}
		let x4 = _this_x1 * k2;
		let y4 = _this_y1 * k2;
		let z4 = _this_z1 * k2;
		if(z4 == null) {
			z4 = 0.;
		}
		if(y4 == null) {
			y4 = 0.;
		}
		if(x4 == null) {
			x4 = 0.;
		}
		let right_x = x4;
		let right_y = y4;
		let right_z = z4;
		gravityMat.initInverse(gravityMat);
		let v1 = this.level.scene.camera.pos;
		let x5 = pos.x - v1.x;
		let y5 = pos.y - v1.y;
		let z5 = pos.z - v1.z;
		let w = pos.w - v1.w;
		if(w == null) {
			w = 1.;
		}
		if(z5 == null) {
			z5 = 0.;
		}
		if(y5 == null) {
			y5 = 0.;
		}
		if(x5 == null) {
			x5 = 0.;
		}
		let shapeDist_x = x5;
		let shapeDist_y = y5;
		let shapeDist_z = z5;
		let shapeDist_w = w;
		let k3 = shapeDist_x * shapeDist_x + shapeDist_y * shapeDist_y + shapeDist_z * shapeDist_z;
		if(k3 < 1e-10) {
			k3 = 0;
		} else {
			k3 = 1. / Math.sqrt(k3);
		}
		let x6 = shapeDist_x * k3;
		let y6 = shapeDist_y * k3;
		let z6 = shapeDist_z * k3;
		if(z6 == null) {
			z6 = 0.;
		}
		if(y6 == null) {
			y6 = 0.;
		}
		if(x6 == null) {
			x6 = 0.;
		}
		let shapeDir_x = x6;
		let shapeDir_y = y6;
		let shapeDir_z = z6;
		let distToShape = Math.sqrt(shapeDist_x * shapeDist_x + shapeDist_y * shapeDist_y + shapeDist_z * shapeDist_z);
		let k4 = shapeDir_x * shapeDir_x + shapeDir_y * shapeDir_y + shapeDir_z * shapeDir_z;
		if(k4 < 1e-10) {
			k4 = 0;
		} else {
			k4 = 1. / Math.sqrt(k4);
		}
		shapeDir_x *= k4;
		shapeDir_y *= k4;
		shapeDir_z *= k4;
		let v2 = Math.sin(fovX);
		let x7 = right_x * v2;
		let y7 = right_y * v2;
		let z7 = right_z * v2;
		if(z7 == null) {
			z7 = 0.;
		}
		if(y7 == null) {
			y7 = 0.;
		}
		if(x7 == null) {
			x7 = 0.;
		}
		let v_x = x7;
		let v_y = y7;
		let v_z = z7;
		let x8 = front_x + v_x;
		let y8 = front_y + v_y;
		let z8 = front_z + v_z;
		if(z8 == null) {
			z8 = 0.;
		}
		if(y8 == null) {
			y8 = 0.;
		}
		if(x8 == null) {
			x8 = 0.;
		}
		let _this_x2 = x8;
		let _this_y2 = y8;
		let _this_z2 = z8;
		let x9 = up_x * fovY;
		let y9 = up_y * fovY;
		let z9 = up_z * fovY;
		if(z9 == null) {
			z9 = 0.;
		}
		if(y9 == null) {
			y9 = 0.;
		}
		if(x9 == null) {
			x9 = 0.;
		}
		let v_x1 = x9;
		let v_y1 = y9;
		let v_z1 = z9;
		let x10 = _this_x2 + v_x1;
		let y10 = _this_y2 + v_y1;
		let z10 = _this_z2 + v_z1;
		if(z10 == null) {
			z10 = 0.;
		}
		if(y10 == null) {
			y10 = 0.;
		}
		if(x10 == null) {
			x10 = 0.;
		}
		let p1_x = x10;
		let p1_y = y10;
		let p1_z = z10;
		let v3 = Math.sin(fovX);
		let x11 = right_x * v3;
		let y11 = right_y * v3;
		let z11 = right_z * v3;
		if(z11 == null) {
			z11 = 0.;
		}
		if(y11 == null) {
			y11 = 0.;
		}
		if(x11 == null) {
			x11 = 0.;
		}
		let v_x2 = x11;
		let v_y2 = y11;
		let v_z2 = z11;
		let x12 = front_x + v_x2;
		let y12 = front_y + v_y2;
		let z12 = front_z + v_z2;
		if(z12 == null) {
			z12 = 0.;
		}
		if(y12 == null) {
			y12 = 0.;
		}
		if(x12 == null) {
			x12 = 0.;
		}
		let _this_x3 = x12;
		let _this_y3 = y12;
		let _this_z3 = z12;
		let x13 = up_x * fovY;
		let y13 = up_y * fovY;
		let z13 = up_z * fovY;
		if(z13 == null) {
			z13 = 0.;
		}
		if(y13 == null) {
			y13 = 0.;
		}
		if(x13 == null) {
			x13 = 0.;
		}
		let v_x3 = x13;
		let v_y3 = y13;
		let v_z3 = z13;
		let x14 = _this_x3 - v_x3;
		let y14 = _this_y3 - v_y3;
		let z14 = _this_z3 - v_z3;
		if(z14 == null) {
			z14 = 0.;
		}
		if(y14 == null) {
			y14 = 0.;
		}
		if(x14 == null) {
			x14 = 0.;
		}
		let p2_x = x14;
		let p2_y = y14;
		let p2_z = z14;
		let px = p1_x * gravityMat._11 + p1_y * gravityMat._21 + p1_z * gravityMat._31 + 3. * gravityMat._41;
		let py = p1_x * gravityMat._12 + p1_y * gravityMat._22 + p1_z * gravityMat._32 + 3. * gravityMat._42;
		let pz = p1_x * gravityMat._13 + p1_y * gravityMat._23 + p1_z * gravityMat._33 + 3. * gravityMat._43;
		let x15 = px;
		let y15 = py;
		let z15 = pz;
		if(pz == null) {
			z15 = 0.;
		}
		if(py == null) {
			y15 = 0.;
		}
		if(px == null) {
			x15 = 0.;
		}
		let camCone1G_x = x15;
		let camCone1G_y = y15;
		let camCone1G_z = z15;
		let px1 = p2_x * gravityMat._11 + p2_y * gravityMat._21 + p2_z * gravityMat._31 + gravityMat._41;
		let py1 = p2_x * gravityMat._12 + p2_y * gravityMat._22 + p2_z * gravityMat._32 + gravityMat._42;
		let pz1 = p2_x * gravityMat._13 + p2_y * gravityMat._23 + p2_z * gravityMat._33 + gravityMat._43;
		let x16 = px1;
		let y16 = py1;
		let z16 = pz1;
		if(pz1 == null) {
			z16 = 0.;
		}
		if(py1 == null) {
			y16 = 0.;
		}
		if(px1 == null) {
			x16 = 0.;
		}
		let camCone2G_x = x16;
		let camCone2G_y = y16;
		let camCone2G_z = z16;
		let px2 = shapeDir_x * gravityMat._11 + shapeDir_y * gravityMat._21 + shapeDir_z * gravityMat._31 + gravityMat._41;
		let py2 = shapeDir_x * gravityMat._12 + shapeDir_y * gravityMat._22 + shapeDir_z * gravityMat._32 + gravityMat._42;
		let pz2 = shapeDir_x * gravityMat._13 + shapeDir_y * gravityMat._23 + shapeDir_z * gravityMat._33 + gravityMat._43;
		let x17 = px2;
		let y17 = py2;
		let z17 = pz2;
		if(pz2 == null) {
			z17 = 0.;
		}
		if(py2 == null) {
			y17 = 0.;
		}
		if(px2 == null) {
			x17 = 0.;
		}
		let shapeDirGrav_x = x17;
		let shapeDirGrav_y = y17;
		let shapeDirGrav_z = z17;
		let x18 = Math.sqrt(camCone1G_x * camCone1G_x + camCone1G_y * camCone1G_y);
		let y18 = camCone1G_z;
		if(camCone1G_z == null) {
			y18 = 0.;
		}
		if(x18 == null) {
			x18 = 0.;
		}
		let cc1_x = x18;
		let cc1_y = y18;
		let cc1_z = 0;
		let x19 = Math.sqrt(camCone2G_x * camCone2G_x + camCone2G_y * camCone2G_y);
		let y19 = camCone2G_z;
		if(camCone2G_z == null) {
			y19 = 0.;
		}
		if(x19 == null) {
			x19 = 0.;
		}
		let cc2_x = x19;
		let cc2_y = y19;
		let cc2_z = 0;
		let x20 = Math.sqrt(shapeDirGrav_x * shapeDirGrav_x + shapeDirGrav_y * shapeDirGrav_y);
		let y20 = shapeDirGrav_z;
		if(shapeDirGrav_z == null) {
			y20 = 0.;
		}
		if(x20 == null) {
			x20 = 0.;
		}
		let sd_x = x20;
		let sd_y = y20;
		let sd_z = 0;
		let k5 = cc1_x * cc1_x + cc1_y * cc1_y + cc1_z * cc1_z;
		if(k5 < 1e-10) {
			k5 = 0;
		} else {
			k5 = 1. / Math.sqrt(k5);
		}
		cc1_x *= k5;
		cc1_y *= k5;
		let k6 = cc2_x * cc2_x + cc2_y * cc2_y + cc2_z * cc2_z;
		if(k6 < 1e-10) {
			k6 = 0;
		} else {
			k6 = 1. / Math.sqrt(k6);
		}
		cc2_x *= k6;
		cc2_y *= k6;
		let k7 = sd_x * sd_x + sd_y * sd_y + sd_z * sd_z;
		if(k7 < 1e-10) {
			k7 = 0;
		} else {
			k7 = 1. / Math.sqrt(k7);
		}
		sd_x *= k7;
		sd_y *= k7;
		let arrowPosY = 0.0;
		let arrowPosX = 0.0;
		if(cc1_y >= sd_y) {
			if(cc2_y <= sd_y) {
				arrowPosY = this.scene2d.height * ((sd_x * cc1_y - cc1_x * sd_y) / (sd_y * (cc2_x - cc1_x) - (cc2_y - cc1_y) * sd_x));
			} else {
				arrowPosY = this.scene2d.height;
			}
		}
		let px3 = shapeDist_x * gravityMat._11 + shapeDist_y * gravityMat._21 + shapeDist_z * gravityMat._31 + shapeDist_w * gravityMat._41;
		let py3 = shapeDist_x * gravityMat._12 + shapeDist_y * gravityMat._22 + shapeDist_z * gravityMat._32 + shapeDist_w * gravityMat._42;
		let pz3 = shapeDist_x * gravityMat._13 + shapeDist_y * gravityMat._23 + shapeDist_z * gravityMat._33 + shapeDist_w * gravityMat._43;
		let x21 = px3;
		let y21 = py3;
		let z18 = pz3;
		if(pz3 == null) {
			z18 = 0.;
		}
		if(py3 == null) {
			y21 = 0.;
		}
		if(px3 == null) {
			x21 = 0.;
		}
		let r1_x = x21;
		let r1_y = y21;
		let r1_z = z18;
		let px4 = front_x * gravityMat._11 + front_y * gravityMat._21 + front_z * gravityMat._31 + gravityMat._41;
		let py4 = front_x * gravityMat._12 + front_y * gravityMat._22 + front_z * gravityMat._32 + gravityMat._42;
		let pz4 = front_x * gravityMat._13 + front_y * gravityMat._23 + front_z * gravityMat._33 + gravityMat._43;
		let x22 = px4;
		let y22 = py4;
		let z19 = pz4;
		if(pz4 == null) {
			z19 = 0.;
		}
		if(py4 == null) {
			y22 = 0.;
		}
		if(px4 == null) {
			x22 = 0.;
		}
		let r2_x = x22;
		let r2_y = y22;
		let r2_z = z19;
		r1_z = 0;
		r2_z = 0;
		let k8 = r1_x * r1_x + r1_y * r1_y + r1_z * r1_z;
		if(k8 < 1e-10) {
			k8 = 0;
		} else {
			k8 = 1. / Math.sqrt(k8);
		}
		r1_x *= k8;
		r1_y *= k8;
		r1_z *= k8;
		let k9 = r2_x * r2_x + r2_y * r2_y + r2_z * r2_z;
		if(k9 < 1e-10) {
			k9 = 0;
		} else {
			k9 = 1. / Math.sqrt(k9);
		}
		r2_x *= k9;
		r2_y *= k9;
		r2_z *= k9;
		let z20 = r1_x * r2_y - r1_y * r2_x;
		if(z20 == null) {
			z20 = 0.;
		}
		let cp_z = z20;
		let forwardness = r1_x * r2_x + r1_y * r2_y + r1_z * r2_z;
		let xfPosAngle = -Math.asin(cp_z);
		let foldAmount = 0.0;
		let foldArrow = false;
		if(forwardness < 0.5) {
			foldArrow = true;
			foldAmount = (0.5 - forwardness) / 3;
		}
		if(forwardness < 0.0) {
			if(xfPosAngle >= 0.0) {
				xfPosAngle += Math.PI;
			} else {
				xfPosAngle -= Math.PI;
			}
		}
		if(-fovX <= xfPosAngle) {
			if(fovX >= xfPosAngle) {
				arrowPosX = this.scene2d.width * 0.5 + Math.tan(xfPosAngle) * (this.scene2d.width * 0.5) / Math.tan(fovX);
			} else {
				arrowPosX = this.scene2d.width;
			}
		}
		let drawPoint = new h3d_Vector(arrowPosX,arrowPosY);
		if(validProjection) {
			drawPoint.x = projectedPos.x;
			drawPoint.y = projectedPos.y;
			drawPoint.z = projectedPos.z;
			drawPoint.w = projectedPos.w;
			let dx = projectedPos.x - drawPoint.x;
			let dy = projectedPos.y - drawPoint.y;
			let dz = projectedPos.z - drawPoint.z;
			if(dx * dx + dy * dy + dz * dz <= 5625) {
				let dx = projectedPos.x - drawPoint.x;
				let dy = projectedPos.y - drawPoint.y;
				let dz = projectedPos.z - drawPoint.z;
				let distOff = Math.sqrt(dx * dx + dy * dy + dz * dz);
				let x = arrowPosX;
				let y = arrowPosY;
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v2_x = x;
				let v2_y = y;
				let t = distOff / 75;
				let a = projectedPos.x;
				let a1 = projectedPos.y;
				let a2 = projectedPos.z;
				let a3 = projectedPos.w;
				drawPoint = new h3d_Vector(a + (v2_x - a) * t,a1 + (v2_y - a1) * t,a2 + (0. - a2) * t,a3 + (1. - a3) * t);
			}
		}
		let x23 = this.scene2d.width / 2 * this.ellipseScreenFraction.x;
		let y23 = this.scene2d.height / 2 * this.ellipseScreenFraction.y;
		if(y23 == null) {
			y23 = 0.;
		}
		if(x23 == null) {
			x23 = 0.;
		}
		let ellipse_x = x23;
		let ellipse_y = y23;
		let x24 = this.scene2d.width / 2;
		let y24 = this.scene2d.height / 2;
		if(y24 == null) {
			y24 = 0.;
		}
		if(x24 == null) {
			x24 = 0.;
		}
		let v_x4 = x24;
		let v_y4 = y24;
		let x25 = drawPoint.x - v_x4;
		let y25 = drawPoint.y - v_y4;
		let z21 = drawPoint.z;
		let w1 = drawPoint.w - 1.;
		if(w1 == null) {
			w1 = 1.;
		}
		if(z21 == null) {
			z21 = 0.;
		}
		if(y25 == null) {
			y25 = 0.;
		}
		if(x25 == null) {
			x25 = 0.;
		}
		let arrowDir_x = x25;
		let arrowDir_y = y25;
		let arrowDir_z = z21;
		let arrowDir_w = w1;
		let ellipseDistance = Math.sqrt(arrowDir_x * arrowDir_x / (ellipse_x * ellipse_x) + arrowDir_y * arrowDir_y / (ellipse_y * ellipse_y));
		let arrowAlpha = this.maxArrowAlpha;
		let circleAlpha = 0.0;
		if(ellipseDistance <= 1) {
			if(ellipseDistance <= 0.7) {
				arrowAlpha = 0;
				circleAlpha = this.maxTargetAlpha;
			} else {
				arrowAlpha = (ellipseDistance - 0.7) * 3.3333333333333335 * this.maxArrowAlpha;
				circleAlpha = this.maxArrowAlpha - arrowAlpha * this.maxTargetAlpha / this.maxArrowAlpha;
			}
		} else {
			let v = 1 / ellipseDistance;
			drawPoint = new h3d_Vector(arrowDir_x * v,arrowDir_y * v,arrowDir_z * v,arrowDir_w);
			drawPoint.x += this.scene2d.width / 2;
			drawPoint.y += this.scene2d.height / 2;
		}
		let k10 = arrowDir_x * arrowDir_x + arrowDir_y * arrowDir_y + arrowDir_z * arrowDir_z;
		if(k10 < 1e-10) {
			k10 = 0;
		} else {
			k10 = 1. / Math.sqrt(k10);
		}
		arrowDir_x *= k10;
		arrowDir_y *= k10;
		arrowDir_z *= k10;
		if(blink) {
			let r = color >> 16 & 255;
			let g = color >> 8 & 255;
			let b = color & 255;
			if(r <= 127) {
				r = 127;
			}
			if(g <= 127) {
				g = 127;
			}
			if(b <= 127) {
				b = 127;
			}
			color = r << 16 | g << 8 | b;
			arrowAlpha *= 1.3;
			if(arrowAlpha > 1) {
				arrowAlpha = 1;
			}
			circleAlpha *= 1.3;
			if(circleAlpha > 1) {
				circleAlpha = 1;
			}
		}
		let value = 1 - distToShape / 100;
		let min = this.minArrowFraction;
		let arrowScale = value < min ? min : value > 1 ? 1 : value;
		let yScaleLength = this.scene2d.height / 480;
		if(arrowAlpha != 0) {
			let arrowWidth = this.fullArrowWidth * arrowScale * yScaleLength;
			let arrowLength = this.fullArrowLength * arrowScale * yScaleLength;
			let x = arrowWidth * arrowDir_y;
			let y = arrowWidth * -arrowDir_x;
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let arrowSideVector_x = x;
			let arrowSideVector_y = y;
			let x1 = arrowSideVector_x * 0.5;
			let y1 = arrowSideVector_y * 0.5;
			if(y1 == null) {
				y1 = 0.;
			}
			if(x1 == null) {
				x1 = 0.;
			}
			let halfArrowSideVec_x = x1;
			let halfArrowSideVec_y = y1;
			let x2 = arrowDir_x * arrowLength;
			let y2 = arrowDir_y * arrowLength;
			let z = arrowDir_z * arrowLength;
			let w = arrowDir_w;
			if(arrowDir_w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y2 == null) {
				y2 = 0.;
			}
			if(x2 == null) {
				x2 = 0.;
			}
			let arrowForwardVec_x = x2;
			let arrowForwardVec_y = y2;
			let arrowForwardVec_z = z;
			let arrowForwardVec_w = w;
			let x3 = drawPoint.x - arrowForwardVec_x;
			let y3 = drawPoint.y - arrowForwardVec_y;
			let z1 = drawPoint.z - arrowForwardVec_z;
			let w1 = drawPoint.w - arrowForwardVec_w;
			if(w1 == null) {
				w1 = 1.;
			}
			if(z1 == null) {
				z1 = 0.;
			}
			if(y3 == null) {
				y3 = 0.;
			}
			if(x3 == null) {
				x3 = 0.;
			}
			let arrowBack_x = x3;
			let arrowBack_y = y3;
			let x4 = arrowBack_x + halfArrowSideVec_x;
			let y4 = arrowBack_y + halfArrowSideVec_y;
			if(y4 == null) {
				y4 = 0.;
			}
			if(x4 == null) {
				x4 = 0.;
			}
			let lowerRight_x = x4;
			let lowerRight_y = y4;
			let x5 = arrowBack_x - halfArrowSideVec_x;
			let y5 = arrowBack_y - halfArrowSideVec_y;
			if(y5 == null) {
				y5 = 0.;
			}
			if(x5 == null) {
				x5 = 0.;
			}
			let lowerLeft_x = x5;
			let lowerLeft_y = y5;
			if(foldAmount == 0) {
				foldArrow = false;
			}
			let halfFoldWidth = 0.5 * arrowWidth * foldAmount;
			let x6 = halfFoldWidth * arrowDir_y;
			let y6 = -halfFoldWidth * arrowDir_x;
			if(y6 == null) {
				y6 = 0.;
			}
			if(x6 == null) {
				x6 = 0.;
			}
			let halfFoldForwardWidthVec_x = x6;
			let halfFoldForwardWidthVec_y = y6;
			let foldLength = foldAmount * arrowLength;
			let x7 = arrowDir_x * foldLength;
			let y7 = arrowDir_y * foldLength;
			let z2 = arrowDir_z * foldLength;
			let w2 = arrowDir_w;
			if(arrowDir_w == null) {
				w2 = 1.;
			}
			if(z2 == null) {
				z2 = 0.;
			}
			if(y7 == null) {
				y7 = 0.;
			}
			if(x7 == null) {
				x7 = 0.;
			}
			let foldForwardVec_x = x7;
			let foldForwardVec_y = y7;
			let foldForwardVec_z = z2;
			let foldForwardVec_w = w2;
			let x8 = drawPoint.x - foldForwardVec_x;
			let y8 = drawPoint.y - foldForwardVec_y;
			let z3 = drawPoint.z - foldForwardVec_z;
			let w3 = drawPoint.w - foldForwardVec_w;
			if(w3 == null) {
				w3 = 1.;
			}
			if(z3 == null) {
				z3 = 0.;
			}
			if(y8 == null) {
				y8 = 0.;
			}
			if(x8 == null) {
				x8 = 0.;
			}
			let foldBack_x = x8;
			let foldBack_y = y8;
			let x9 = foldBack_x + halfFoldForwardWidthVec_x;
			let y9 = foldBack_y + halfFoldForwardWidthVec_y;
			if(y9 == null) {
				y9 = 0.;
			}
			if(x9 == null) {
				x9 = 0.;
			}
			let foldLowerRight_x = x9;
			let foldLowerRight_y = y9;
			let x10 = foldBack_x - halfFoldForwardWidthVec_x;
			let y10 = foldBack_y - halfFoldForwardWidthVec_y;
			if(y10 == null) {
				y10 = 0.;
			}
			if(x10 == null) {
				x10 = 0.;
			}
			let foldLowerLeft_x = x10;
			let foldLowerLeft_y = y10;
			let v = foldLength + foldLength;
			let x11 = arrowDir_x * v;
			let y11 = arrowDir_y * v;
			let z4 = arrowDir_z * v;
			let w4 = arrowDir_w;
			if(arrowDir_w == null) {
				w4 = 1.;
			}
			if(z4 == null) {
				z4 = 0.;
			}
			if(y11 == null) {
				y11 = 0.;
			}
			if(x11 == null) {
				x11 = 0.;
			}
			let doubleFoldVec_x = x11;
			let doubleFoldVec_y = y11;
			let x12 = drawPoint.x - doubleFoldVec_x;
			let y12 = drawPoint.y - doubleFoldVec_y;
			if(y12 == null) {
				y12 = 0.;
			}
			if(x12 == null) {
				x12 = 0.;
			}
			let foldedTip_x = x12;
			let foldedTip_y = y12;
			this.g.beginFill(color,arrowAlpha);
			this.g.lineStyle(0,color,arrowAlpha);
			if(foldArrow) {
				let _this = this.g;
				_this.flush();
				_this.addVertex(lowerRight_x,lowerRight_y,_this.curR,_this.curG,_this.curB,_this.curA,lowerRight_x * _this.ma + lowerRight_y * _this.mc + _this.mx,lowerRight_x * _this.mb + lowerRight_y * _this.md + _this.my);
				let _this1 = this.g;
				_this1.addVertex(lowerLeft_x,lowerLeft_y,_this1.curR,_this1.curG,_this1.curB,_this1.curA,lowerLeft_x * _this1.ma + lowerLeft_y * _this1.mc + _this1.mx,lowerLeft_x * _this1.mb + lowerLeft_y * _this1.md + _this1.my);
				let _this2 = this.g;
				_this2.addVertex(foldLowerLeft_x,foldLowerLeft_y,_this2.curR,_this2.curG,_this2.curB,_this2.curA,foldLowerLeft_x * _this2.ma + foldLowerLeft_y * _this2.mc + _this2.mx,foldLowerLeft_x * _this2.mb + foldLowerLeft_y * _this2.md + _this2.my);
				let _this3 = this.g;
				_this3.flush();
				_this3.addVertex(lowerRight_x,lowerRight_y,_this3.curR,_this3.curG,_this3.curB,_this3.curA,lowerRight_x * _this3.ma + lowerRight_y * _this3.mc + _this3.mx,lowerRight_x * _this3.mb + lowerRight_y * _this3.md + _this3.my);
				let _this4 = this.g;
				_this4.addVertex(foldLowerRight_x,foldLowerRight_y,_this4.curR,_this4.curG,_this4.curB,_this4.curA,foldLowerRight_x * _this4.ma + foldLowerRight_y * _this4.mc + _this4.mx,foldLowerRight_x * _this4.mb + foldLowerRight_y * _this4.md + _this4.my);
				let _this5 = this.g;
				_this5.addVertex(foldLowerLeft_x,foldLowerLeft_y,_this5.curR,_this5.curG,_this5.curB,_this5.curA,foldLowerLeft_x * _this5.ma + foldLowerLeft_y * _this5.mc + _this5.mx,foldLowerLeft_x * _this5.mb + foldLowerLeft_y * _this5.md + _this5.my);
			} else {
				let _this = this.g;
				let x = drawPoint.x;
				let y = drawPoint.y;
				_this.flush();
				_this.addVertex(x,y,_this.curR,_this.curG,_this.curB,_this.curA,x * _this.ma + y * _this.mc + _this.mx,x * _this.mb + y * _this.md + _this.my);
				let _this1 = this.g;
				_this1.addVertex(lowerRight_x,lowerRight_y,_this1.curR,_this1.curG,_this1.curB,_this1.curA,lowerRight_x * _this1.ma + lowerRight_y * _this1.mc + _this1.mx,lowerRight_x * _this1.mb + lowerRight_y * _this1.md + _this1.my);
				let _this2 = this.g;
				_this2.addVertex(lowerLeft_x,lowerLeft_y,_this2.curR,_this2.curG,_this2.curB,_this2.curA,lowerLeft_x * _this2.ma + lowerLeft_y * _this2.mc + _this2.mx,lowerLeft_x * _this2.mb + lowerLeft_y * _this2.md + _this2.my);
			}
			this.g.endFill();
			this.g.lineStyle(1,0,arrowAlpha);
			let _this = this.g;
			let alpha = arrowAlpha;
			if(alpha == null) {
				alpha = 1.;
			}
			_this.curA = alpha;
			_this.curR = 0.;
			_this.curG = 0.;
			_this.curB = 0.;
			if(foldArrow) {
				let _this = this.g;
				_this.flush();
				_this.addVertex(lowerRight_x,lowerRight_y,_this.curR,_this.curG,_this.curB,_this.curA,lowerRight_x * _this.ma + lowerRight_y * _this.mc + _this.mx,lowerRight_x * _this.mb + lowerRight_y * _this.md + _this.my);
				let _this1 = this.g;
				_this1.addVertex(foldLowerRight_x,foldLowerRight_y,_this1.curR,_this1.curG,_this1.curB,_this1.curA,foldLowerRight_x * _this1.ma + foldLowerRight_y * _this1.mc + _this1.mx,foldLowerRight_x * _this1.mb + foldLowerRight_y * _this1.md + _this1.my);
				let _this2 = this.g;
				_this2.addVertex(foldLowerLeft_x,foldLowerLeft_y,_this2.curR,_this2.curG,_this2.curB,_this2.curA,foldLowerLeft_x * _this2.ma + foldLowerLeft_y * _this2.mc + _this2.mx,foldLowerLeft_x * _this2.mb + foldLowerLeft_y * _this2.md + _this2.my);
				let _this3 = this.g;
				_this3.addVertex(lowerLeft_x,lowerLeft_y,_this3.curR,_this3.curG,_this3.curB,_this3.curA,lowerLeft_x * _this3.ma + lowerLeft_y * _this3.mc + _this3.mx,lowerLeft_x * _this3.mb + lowerLeft_y * _this3.md + _this3.my);
				let _this4 = this.g;
				_this4.addVertex(lowerRight_x,lowerRight_y,_this4.curR,_this4.curG,_this4.curB,_this4.curA,lowerRight_x * _this4.ma + lowerRight_y * _this4.mc + _this4.mx,lowerRight_x * _this4.mb + lowerRight_y * _this4.md + _this4.my);
				let _this5 = this.g;
				_this5.flush();
				_this5.addVertex(foldLowerRight_x,foldLowerRight_y,_this5.curR,_this5.curG,_this5.curB,_this5.curA,foldLowerRight_x * _this5.ma + foldLowerRight_y * _this5.mc + _this5.mx,foldLowerRight_x * _this5.mb + foldLowerRight_y * _this5.md + _this5.my);
				let _this6 = this.g;
				_this6.addVertex(foldedTip_x,foldedTip_y,_this6.curR,_this6.curG,_this6.curB,_this6.curA,foldedTip_x * _this6.ma + foldedTip_y * _this6.mc + _this6.mx,foldedTip_x * _this6.mb + foldedTip_y * _this6.md + _this6.my);
				let _this7 = this.g;
				_this7.addVertex(foldLowerLeft_x,foldLowerLeft_y,_this7.curR,_this7.curG,_this7.curB,_this7.curA,foldLowerLeft_x * _this7.ma + foldLowerLeft_y * _this7.mc + _this7.mx,foldLowerLeft_x * _this7.mb + foldLowerLeft_y * _this7.md + _this7.my);
				let _this8 = this.g;
				_this8.flush();
				_this8.addVertex(foldedTip_x,foldedTip_y,_this8.curR,_this8.curG,_this8.curB,_this8.curA,foldedTip_x * _this8.ma + foldedTip_y * _this8.mc + _this8.mx,foldedTip_x * _this8.mb + foldedTip_y * _this8.md + _this8.my);
			} else {
				let _this = this.g;
				let x = drawPoint.x;
				let y = drawPoint.y;
				_this.flush();
				_this.addVertex(x,y,_this.curR,_this.curG,_this.curB,_this.curA,x * _this.ma + y * _this.mc + _this.mx,x * _this.mb + y * _this.md + _this.my);
				let _this1 = this.g;
				_this1.addVertex(lowerRight_x,lowerRight_y,_this1.curR,_this1.curG,_this1.curB,_this1.curA,lowerRight_x * _this1.ma + lowerRight_y * _this1.mc + _this1.mx,lowerRight_x * _this1.mb + lowerRight_y * _this1.md + _this1.my);
				let _this2 = this.g;
				_this2.addVertex(lowerLeft_x,lowerLeft_y,_this2.curR,_this2.curG,_this2.curB,_this2.curA,lowerLeft_x * _this2.ma + lowerLeft_y * _this2.mc + _this2.mx,lowerLeft_x * _this2.mb + lowerLeft_y * _this2.md + _this2.my);
				let _this3 = this.g;
				let x1 = drawPoint.x;
				let y1 = drawPoint.y;
				_this3.addVertex(x1,y1,_this3.curR,_this3.curG,_this3.curB,_this3.curA,x1 * _this3.ma + y1 * _this3.mc + _this3.mx,x1 * _this3.mb + y1 * _this3.md + _this3.my);
			}
		}
		if(circleAlpha != 0) {
			let arrowLen = this.fullArrowLength * arrowScale * 0.4 * yScaleLength;
			let halfArrowLen = arrowLen * 0.55;
			if(arrowScale >= 0.7) {
				if(arrowScale < 0.8) {
					arrowLen = (arrowScale - 0.7) * 10.0 * (arrowLen - halfArrowLen) + halfArrowLen;
				}
				let x = arrowLen;
				let y = arrowLen;
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v_x = x;
				let v_y = y;
				let x1 = drawPoint.x - v_x;
				let y1 = drawPoint.y - v_y;
				let z = drawPoint.z;
				let w = drawPoint.w - 1.;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let topLeft_x = x1;
				let topLeft_y = y1;
				let x2 = halfArrowLen;
				let y2 = halfArrowLen;
				if(halfArrowLen == null) {
					y2 = 0.;
				}
				if(halfArrowLen == null) {
					x2 = 0.;
				}
				let v_x1 = x2;
				let v_y1 = y2;
				let x3 = topLeft_x + v_x1;
				let y3 = topLeft_y + v_y1;
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				let midTopLeft_x = x3;
				let midTopLeft_y = y3;
				let x4 = arrowLen;
				let y4 = arrowLen;
				if(y4 == null) {
					y4 = 0.;
				}
				if(x4 == null) {
					x4 = 0.;
				}
				let v_x2 = x4;
				let v_y2 = y4;
				let x5 = drawPoint.x + v_x2;
				let y5 = drawPoint.y + v_y2;
				let z1 = drawPoint.z;
				let w1 = drawPoint.w + 1.;
				if(w1 == null) {
					w1 = 1.;
				}
				if(z1 == null) {
					z1 = 0.;
				}
				if(y5 == null) {
					y5 = 0.;
				}
				if(x5 == null) {
					x5 = 0.;
				}
				let bottomRight_x = x5;
				let bottomRight_y = y5;
				let x6 = halfArrowLen;
				let y6 = halfArrowLen;
				if(halfArrowLen == null) {
					y6 = 0.;
				}
				if(halfArrowLen == null) {
					x6 = 0.;
				}
				let v_x3 = x6;
				let v_y3 = y6;
				let x7 = bottomRight_x - v_x3;
				let y7 = bottomRight_y - v_y3;
				if(y7 == null) {
					y7 = 0.;
				}
				if(x7 == null) {
					x7 = 0.;
				}
				let midBottomRight_x = x7;
				let midBottomRight_y = y7;
				this.g.beginFill(color,circleAlpha);
				this.g.lineStyle(0,color,circleAlpha);
				let _this = this.g;
				_this.flush();
				_this.addVertex(midTopLeft_x,midTopLeft_y,_this.curR,_this.curG,_this.curB,_this.curA,midTopLeft_x * _this.ma + midTopLeft_y * _this.mc + _this.mx,midTopLeft_x * _this.mb + midTopLeft_y * _this.md + _this.my);
				let _this1 = this.g;
				_this1.addVertex(midTopLeft_x,topLeft_y,_this1.curR,_this1.curG,_this1.curB,_this1.curA,midTopLeft_x * _this1.ma + topLeft_y * _this1.mc + _this1.mx,midTopLeft_x * _this1.mb + topLeft_y * _this1.md + _this1.my);
				let _this2 = this.g;
				_this2.addVertex(topLeft_x,midTopLeft_y,_this2.curR,_this2.curG,_this2.curB,_this2.curA,topLeft_x * _this2.ma + midTopLeft_y * _this2.mc + _this2.mx,topLeft_x * _this2.mb + midTopLeft_y * _this2.md + _this2.my);
				this.g.endFill();
				this.g.beginFill(color,circleAlpha);
				this.g.lineStyle(0,color,circleAlpha);
				let _this3 = this.g;
				_this3.flush();
				_this3.addVertex(midBottomRight_x,midTopLeft_y,_this3.curR,_this3.curG,_this3.curB,_this3.curA,midBottomRight_x * _this3.ma + midTopLeft_y * _this3.mc + _this3.mx,midBottomRight_x * _this3.mb + midTopLeft_y * _this3.md + _this3.my);
				let _this4 = this.g;
				_this4.addVertex(midBottomRight_x,topLeft_y,_this4.curR,_this4.curG,_this4.curB,_this4.curA,midBottomRight_x * _this4.ma + topLeft_y * _this4.mc + _this4.mx,midBottomRight_x * _this4.mb + topLeft_y * _this4.md + _this4.my);
				let _this5 = this.g;
				_this5.addVertex(bottomRight_x,midTopLeft_y,_this5.curR,_this5.curG,_this5.curB,_this5.curA,bottomRight_x * _this5.ma + midTopLeft_y * _this5.mc + _this5.mx,bottomRight_x * _this5.mb + midTopLeft_y * _this5.md + _this5.my);
				this.g.endFill();
				this.g.beginFill(color,circleAlpha);
				this.g.lineStyle(0,color,circleAlpha);
				let _this6 = this.g;
				_this6.flush();
				_this6.addVertex(midBottomRight_x,midBottomRight_y,_this6.curR,_this6.curG,_this6.curB,_this6.curA,midBottomRight_x * _this6.ma + midBottomRight_y * _this6.mc + _this6.mx,midBottomRight_x * _this6.mb + midBottomRight_y * _this6.md + _this6.my);
				let _this7 = this.g;
				_this7.addVertex(midBottomRight_x,bottomRight_y,_this7.curR,_this7.curG,_this7.curB,_this7.curA,midBottomRight_x * _this7.ma + bottomRight_y * _this7.mc + _this7.mx,midBottomRight_x * _this7.mb + bottomRight_y * _this7.md + _this7.my);
				let _this8 = this.g;
				_this8.addVertex(bottomRight_x,midBottomRight_y,_this8.curR,_this8.curG,_this8.curB,_this8.curA,bottomRight_x * _this8.ma + midBottomRight_y * _this8.mc + _this8.mx,bottomRight_x * _this8.mb + midBottomRight_y * _this8.md + _this8.my);
				this.g.endFill();
				this.g.beginFill(color,circleAlpha);
				this.g.lineStyle(0,color,circleAlpha);
				let _this9 = this.g;
				_this9.flush();
				_this9.addVertex(midTopLeft_x,midBottomRight_y,_this9.curR,_this9.curG,_this9.curB,_this9.curA,midTopLeft_x * _this9.ma + midBottomRight_y * _this9.mc + _this9.mx,midTopLeft_x * _this9.mb + midBottomRight_y * _this9.md + _this9.my);
				let _this10 = this.g;
				_this10.addVertex(midTopLeft_x,bottomRight_y,_this10.curR,_this10.curG,_this10.curB,_this10.curA,midTopLeft_x * _this10.ma + bottomRight_y * _this10.mc + _this10.mx,midTopLeft_x * _this10.mb + bottomRight_y * _this10.md + _this10.my);
				let _this11 = this.g;
				_this11.addVertex(topLeft_x,midBottomRight_y,_this11.curR,_this11.curG,_this11.curB,_this11.curA,topLeft_x * _this11.ma + midBottomRight_y * _this11.mc + _this11.mx,topLeft_x * _this11.mb + midBottomRight_y * _this11.md + _this11.my);
				this.g.endFill();
				this.g.lineStyle(1,0,circleAlpha);
				let _this12 = this.g;
				let alpha = circleAlpha;
				if(alpha == null) {
					alpha = 1.;
				}
				_this12.curA = alpha;
				_this12.curR = 0.;
				_this12.curG = 0.;
				_this12.curB = 0.;
				let _this13 = this.g;
				_this13.flush();
				_this13.addVertex(midTopLeft_x,topLeft_y,_this13.curR,_this13.curG,_this13.curB,_this13.curA,midTopLeft_x * _this13.ma + topLeft_y * _this13.mc + _this13.mx,midTopLeft_x * _this13.mb + topLeft_y * _this13.md + _this13.my);
				let _this14 = this.g;
				_this14.addVertex(topLeft_x,midTopLeft_y,_this14.curR,_this14.curG,_this14.curB,_this14.curA,topLeft_x * _this14.ma + midTopLeft_y * _this14.mc + _this14.mx,topLeft_x * _this14.mb + midTopLeft_y * _this14.md + _this14.my);
				let _this15 = this.g;
				_this15.flush();
				_this15.addVertex(midBottomRight_x,topLeft_y,_this15.curR,_this15.curG,_this15.curB,_this15.curA,midBottomRight_x * _this15.ma + topLeft_y * _this15.mc + _this15.mx,midBottomRight_x * _this15.mb + topLeft_y * _this15.md + _this15.my);
				let _this16 = this.g;
				_this16.addVertex(bottomRight_x,midTopLeft_y,_this16.curR,_this16.curG,_this16.curB,_this16.curA,bottomRight_x * _this16.ma + midTopLeft_y * _this16.mc + _this16.mx,bottomRight_x * _this16.mb + midTopLeft_y * _this16.md + _this16.my);
				let _this17 = this.g;
				_this17.flush();
				_this17.addVertex(midBottomRight_x,bottomRight_y,_this17.curR,_this17.curG,_this17.curB,_this17.curA,midBottomRight_x * _this17.ma + bottomRight_y * _this17.mc + _this17.mx,midBottomRight_x * _this17.mb + bottomRight_y * _this17.md + _this17.my);
				let _this18 = this.g;
				_this18.addVertex(bottomRight_x,midBottomRight_y,_this18.curR,_this18.curG,_this18.curB,_this18.curA,bottomRight_x * _this18.ma + midBottomRight_y * _this18.mc + _this18.mx,bottomRight_x * _this18.mb + midBottomRight_y * _this18.md + _this18.my);
				let _this19 = this.g;
				_this19.flush();
				_this19.addVertex(midTopLeft_x,bottomRight_y,_this19.curR,_this19.curG,_this19.curB,_this19.curA,midTopLeft_x * _this19.ma + bottomRight_y * _this19.mc + _this19.mx,midTopLeft_x * _this19.mb + bottomRight_y * _this19.md + _this19.my);
				let _this20 = this.g;
				_this20.addVertex(topLeft_x,midBottomRight_y,_this20.curR,_this20.curG,_this20.curB,_this20.curA,topLeft_x * _this20.ma + midBottomRight_y * _this20.mc + _this20.mx,topLeft_x * _this20.mb + midBottomRight_y * _this20.md + _this20.my);
			} else {
				let x = halfArrowLen;
				let y = halfArrowLen;
				if(halfArrowLen == null) {
					y = 0.;
				}
				if(halfArrowLen == null) {
					x = 0.;
				}
				let v_x = x;
				let v_y = y;
				let x1 = drawPoint.x - v_x;
				let y1 = drawPoint.y - v_y;
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let halfTopLeft_x = x1;
				let halfTopLeft_y = y1;
				let x2 = halfArrowLen;
				let y2 = halfArrowLen;
				if(halfArrowLen == null) {
					y2 = 0.;
				}
				if(halfArrowLen == null) {
					x2 = 0.;
				}
				let v_x1 = x2;
				let v_y1 = y2;
				let x3 = drawPoint.x + v_x1;
				let y3 = drawPoint.y + v_y1;
				if(y3 == null) {
					y3 = 0.;
				}
				if(x3 == null) {
					x3 = 0.;
				}
				let halfBottomRight_x = x3;
				let halfBottomRight_y = y3;
				this.g.beginFill(color,circleAlpha);
				this.g.lineStyle(0,color,circleAlpha);
				let _this = this.g;
				let y4 = drawPoint.y;
				_this.flush();
				_this.addVertex(halfTopLeft_x,y4,_this.curR,_this.curG,_this.curB,_this.curA,halfTopLeft_x * _this.ma + y4 * _this.mc + _this.mx,halfTopLeft_x * _this.mb + y4 * _this.md + _this.my);
				let _this1 = this.g;
				let x4 = drawPoint.x;
				_this1.addVertex(x4,halfTopLeft_y,_this1.curR,_this1.curG,_this1.curB,_this1.curA,x4 * _this1.ma + halfTopLeft_y * _this1.mc + _this1.mx,x4 * _this1.mb + halfTopLeft_y * _this1.md + _this1.my);
				let _this2 = this.g;
				let y5 = drawPoint.y;
				_this2.addVertex(halfBottomRight_x,y5,_this2.curR,_this2.curG,_this2.curB,_this2.curA,halfBottomRight_x * _this2.ma + y5 * _this2.mc + _this2.mx,halfBottomRight_x * _this2.mb + y5 * _this2.md + _this2.my);
				this.g.endFill();
				this.g.beginFill(color,circleAlpha);
				this.g.lineStyle(0,color,circleAlpha);
				let _this3 = this.g;
				let y6 = drawPoint.y;
				_this3.flush();
				_this3.addVertex(halfTopLeft_x,y6,_this3.curR,_this3.curG,_this3.curB,_this3.curA,halfTopLeft_x * _this3.ma + y6 * _this3.mc + _this3.mx,halfTopLeft_x * _this3.mb + y6 * _this3.md + _this3.my);
				let _this4 = this.g;
				let x5 = drawPoint.x;
				_this4.addVertex(x5,halfBottomRight_y,_this4.curR,_this4.curG,_this4.curB,_this4.curA,x5 * _this4.ma + halfBottomRight_y * _this4.mc + _this4.mx,x5 * _this4.mb + halfBottomRight_y * _this4.md + _this4.my);
				let _this5 = this.g;
				let y7 = drawPoint.y;
				_this5.addVertex(halfBottomRight_x,y7,_this5.curR,_this5.curG,_this5.curB,_this5.curA,halfBottomRight_x * _this5.ma + y7 * _this5.mc + _this5.mx,halfBottomRight_x * _this5.mb + y7 * _this5.md + _this5.my);
				this.g.endFill();
				this.g.lineStyle(1,0,circleAlpha);
				let _this6 = this.g;
				let alpha = circleAlpha;
				if(alpha == null) {
					alpha = 1.;
				}
				_this6.curA = alpha;
				_this6.curR = 0.;
				_this6.curG = 0.;
				_this6.curB = 0.;
				let _this7 = this.g;
				let y8 = drawPoint.y;
				_this7.flush();
				_this7.addVertex(halfBottomRight_x,y8,_this7.curR,_this7.curG,_this7.curB,_this7.curA,halfBottomRight_x * _this7.ma + y8 * _this7.mc + _this7.mx,halfBottomRight_x * _this7.mb + y8 * _this7.md + _this7.my);
				let _this8 = this.g;
				let x6 = drawPoint.x;
				_this8.addVertex(x6,halfTopLeft_y,_this8.curR,_this8.curG,_this8.curB,_this8.curA,x6 * _this8.ma + halfTopLeft_y * _this8.mc + _this8.mx,x6 * _this8.mb + halfTopLeft_y * _this8.md + _this8.my);
				let _this9 = this.g;
				let x7 = drawPoint.x;
				_this9.flush();
				_this9.addVertex(x7,halfTopLeft_y,_this9.curR,_this9.curG,_this9.curB,_this9.curA,x7 * _this9.ma + halfTopLeft_y * _this9.mc + _this9.mx,x7 * _this9.mb + halfTopLeft_y * _this9.md + _this9.my);
				let _this10 = this.g;
				let y9 = drawPoint.y;
				_this10.addVertex(halfTopLeft_x,y9,_this10.curR,_this10.curG,_this10.curB,_this10.curA,halfTopLeft_x * _this10.ma + y9 * _this10.mc + _this10.mx,halfTopLeft_x * _this10.mb + y9 * _this10.md + _this10.my);
				let _this11 = this.g;
				let y10 = drawPoint.y;
				_this11.flush();
				_this11.addVertex(halfTopLeft_x,y10,_this11.curR,_this11.curG,_this11.curB,_this11.curA,halfTopLeft_x * _this11.ma + y10 * _this11.mc + _this11.mx,halfTopLeft_x * _this11.mb + y10 * _this11.md + _this11.my);
				let _this12 = this.g;
				let x8 = drawPoint.x;
				_this12.addVertex(x8,halfBottomRight_y,_this12.curR,_this12.curG,_this12.curB,_this12.curA,x8 * _this12.ma + halfBottomRight_y * _this12.mc + _this12.mx,x8 * _this12.mb + halfBottomRight_y * _this12.md + _this12.my);
				let _this13 = this.g;
				let x9 = drawPoint.x;
				_this13.flush();
				_this13.addVertex(x9,halfBottomRight_y,_this13.curR,_this13.curG,_this13.curB,_this13.curA,x9 * _this13.ma + halfBottomRight_y * _this13.mc + _this13.mx,x9 * _this13.mb + halfBottomRight_y * _this13.md + _this13.my);
				let _this14 = this.g;
				let y11 = drawPoint.y;
				_this14.addVertex(halfBottomRight_x,y11,_this14.curR,_this14.curG,_this14.curB,_this14.curA,halfBottomRight_x * _this14.ma + y11 * _this14.mc + _this14.mx,halfBottomRight_x * _this14.mb + y11 * _this14.md + _this14.my);
			}
		}
	}
	renderName(pos,marble,opacity) {
		if(this.marbleNameTexts.h.__keys__[marble.__id__] == null) {
			let arialb14fontdata = src_ResourceLoader.getFileEntry("data/font/Arial Bold.fnt");
			let arialb14b = new hxd_res_BitmapFont(arialb14fontdata.entry);
			arialb14b.loader = src_ResourceLoader.loader;
			let arialBold14 = arialb14b.toSdfFont(16 * src_Settings.uiScale,4);
			let txt = new h2d_Text(arialBold14,this.scene2d);
			this.marbleNameTexts.set(marble,txt);
			txt.set_textColor(16776960);
		}
		let textObj = this.marbleNameTexts.h[marble.__id__];
		textObj.set_text(marble.connection.name);
		let x = pos.x - textObj.get_textWidth() / 2;
		let y = pos.y - textObj.get_textHeight();
		textObj.posChanged = true;
		textObj.x = x;
		textObj.posChanged = true;
		textObj.y = y;
		textObj.alpha = opacity;
	}
	dontRenderName(marble) {
		if(this.marbleNameTexts.h.__keys__[marble.__id__] != null) {
			this.marbleNameTexts.h[marble.__id__].alpha = 0;
		}
	}
}
$hxClasses["src.Radar"] = src_Radar;
src_Radar.__name__ = "src.Radar";
Object.assign(src_Radar.prototype, {
	__class__: src_Radar
	,level: null
	,scene2d: null
	,g: null
	,marbleNameTexts: null
	,ellipseScreenFraction: null
	,fullArrowLength: null
	,fullArrowWidth: null
	,maxArrowAlpha: null
	,maxTargetAlpha: null
	,minArrowFraction: null
	,time: null
	,_dirty: null
});
class src_Renderer extends h3d_scene_Renderer {
	constructor() {
		h3d_scene_Renderer._hx_skip_constructor = true;
		super();
		h3d_scene_Renderer._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.shadow = new h3d_pass_DefaultShadowMap(1);
		this.normal = new h3d_scene_fwd_NormalPass();
		this.depth = new h3d_scene_fwd_DepthPass();
		super._hx_constructor();
		this.defaultPass = new shaders_RendererDefaultPass("default");
		this.allPasses = [this.defaultPass,this.depth,this.normal,this.shadow];
		this.blurShader = new h3d_pass_ScreenFx(new shaders_Blur());
		this.copyPass = new h3d_pass_Copy();
		src_Renderer.sfxBuffer = new h3d_mat_Texture(512,512,[h3d_mat_TextureFlags.Target]);
		let _gthis = this;
		hxd_Window.getInstance().addResizeEvent(function() {
			_gthis.onResize();
		});
		this.shadow.autoShrink = false;
		this.shadow.power = 0;
		this.shadow.set_mode(h3d_pass_RenderMode.Static);
		this.shadow.minDist = 0.1;
		this.shadow.maxDist = 0.1;
		this.shadow.bias = 0;
	}
	renderPass(p,passes,sort) {
		p.draw(passes,sort);
	}
	onResize() {
		if(this.backBuffer != null) {
			this.backBuffer.dispose();
			this.backBuffer = null;
		}
		if(this.glowBuffer != null) {
			this.glowBuffer.dispose();
			this.glowBuffer = null;
		}
		if(this.depthBuffer != null) {
			this.depthBuffer.dispose();
			this.depthBuffer = null;
		}
		src_Renderer.pixelRatio = 1;
		src_Renderer.pixelRatio = window.devicePixelRatio / Math.min(src_Settings.optionsSettings.maxPixelRatio,window.devicePixelRatio);
	}
	getPassByName(name) {
		if(name == "alpha" || name == "additive" || name == "glowPre" || name == "glow" || name == "refract" || name == "glowPreNoRender" || name == "interior" || name == "zPass" || name == "marble" || name == "shadowPass1" || name == "shadowPass2" || name == "shadowPass3") {
			return this.defaultPass;
		}
		return super.getPassByName(name);
	}
	render() {
		if(this.backBuffer == null) {
			this.depthBuffer = new h3d_mat_DepthBuffer(this.ctx.engine.width / src_Renderer.pixelRatio,this.ctx.engine.height / src_Renderer.pixelRatio,h3d_mat_DepthFormat.Depth24Stencil8);
			this.backBuffer = this.ctx.textures.allocTarget("backBuffer",this.ctx.engine.width / src_Renderer.pixelRatio,this.ctx.engine.height / src_Renderer.pixelRatio,false);
			this.backBuffer.depthBuffer = this.depthBuffer;
		}
		if(!src_Renderer.cubemapPass) {
			this.ctx.engine.pushTarget(this.backBuffer);
		}
		this.ctx.engine.clear(0,1,0);
		if(this.has("shadow")) {
			this.renderPass(this.shadow,this.get("shadow"));
		}
		if(this.has("depth")) {
			this.renderPass(this.depth,this.get("depth"));
		}
		if(this.has("normal")) {
			this.renderPass(this.normal,this.get("normal"));
		}
		if(this.glowBuffer == null) {
			this.glowBuffer = this.ctx.textures.allocTarget("glowBuffer",this.ctx.engine.width / src_Renderer.pixelRatio,this.ctx.engine.height / src_Renderer.pixelRatio);
			this.glowBuffer.depthBuffer = this.depthBuffer;
		}
		if(this.growBufferTemps == null) {
			this.growBufferTemps = [this.ctx.textures.allocTarget("gb1",320,320,false),this.ctx.textures.allocTarget("gb2",320,320,false)];
		}
		if(!src_Renderer.cubemapPass) {
			src_ProfilerUI.measure("sky",0);
		}
		if(!src_Renderer.cubemapPass || src_Settings.optionsSettings.reflectionDetail >= 1) {
			this.renderPass(this.defaultPass,this.get("sky"));
			this.renderPass(this.defaultPass,this.get("skyshape"),this.backToFront);
		}
		if(!src_Renderer.cubemapPass || src_Settings.optionsSettings.reflectionDetail >= 2) {
			if(!src_Renderer.cubemapPass) {
				src_ProfilerUI.measure("interior",0);
			}
			this.renderPass(this.defaultPass,this.get("interior"));
		}
		if(!src_Renderer.cubemapPass) {
			src_ProfilerUI.measure("render",0);
		}
		if(!src_Renderer.cubemapPass || src_Settings.optionsSettings.reflectionDetail >= 3) {
			this.renderPass(this.defaultPass,this.get("default"));
		}
		this.renderPass(this.defaultPass,this.get("shadowPass1"));
		this.renderPass(this.defaultPass,this.get("shadowPass2"));
		this.renderPass(this.defaultPass,this.get("shadowPass3"));
		this.renderPass(this.defaultPass,this.get("marble"));
		if(!src_Renderer.cubemapPass) {
			src_ProfilerUI.measure("glow",0);
		}
		if(!src_Renderer.cubemapPass || src_Settings.optionsSettings.reflectionDetail >= 4) {
			this.renderPass(this.defaultPass,this.get("glowPre"));
		}
		if(!src_Renderer.cubemapPass || src_Settings.optionsSettings.reflectionDetail >= 4) {
			let glowObjects = this.get("glow");
			if(glowObjects.current != null) {
				let frustum = this.ctx.camera.frustum;
				let hasOne = false;
				let _g_o = glowObjects.current;
				while(_g_o != null) {
					let tmp = _g_o;
					_g_o = _g_o.next;
					let bounds = tmp.obj.getBounds();
					if(frustum.hasBounds(bounds)) {
						hasOne = true;
						break;
					}
				}
				if(hasOne) {
					if(src_Renderer.dirtyBuffers) {
						this.ctx.engine.pushTarget(this.glowBuffer);
						this.ctx.engine.clear(0);
						this.renderPass(this.defaultPass,glowObjects);
						this.bloomPass(this.ctx);
						this.ctx.engine.popTarget();
					}
					this.copyPass.shader.texture__ = this.growBufferTemps[0];
					let _this = this.copyPass.pass;
					let src = h3d_mat_Blend.One;
					let dst = h3d_mat_Blend.One;
					_this.set_blendSrc(src);
					_this.set_blendAlphaSrc(src);
					_this.set_blendDst(dst);
					_this.set_blendAlphaDst(dst);
					this.copyPass.pass.depth(false,h3d_mat_Compare.Always);
					this.copyPass.render();
				}
			}
		}
		if(!src_Renderer.cubemapPass) {
			src_ProfilerUI.measure("refract",0);
		}
		if(!src_Renderer.cubemapPass || src_Settings.optionsSettings.reflectionDetail >= 4) {
			let refractObjects = this.get("refract");
			if(refractObjects.current != null) {
				if(src_Renderer.dirtyBuffers) {
					h3d_pass_Copy.run(this.backBuffer,src_Renderer.sfxBuffer);
				}
				this.renderPass(this.defaultPass,refractObjects);
			}
		}
		if(!src_Renderer.cubemapPass) {
			src_ProfilerUI.measure("alpha",0);
		}
		if(!src_Renderer.cubemapPass || src_Settings.optionsSettings.reflectionDetail >= 4) {
			this.renderPass(this.defaultPass,this.get("alpha"),this.backToFront);
			this.renderPass(this.defaultPass,this.get("additive"));
		}
		if(!src_Renderer.cubemapPass && src_Renderer.dirtyBuffers) {
			src_Renderer.dirtyBuffers = false;
		}
		if(!src_Renderer.cubemapPass) {
			this.ctx.engine.popTarget();
		}
		if(!src_Renderer.cubemapPass) {
			let _this = this.copyPass.pass;
			let src = h3d_mat_Blend.One;
			let dst = h3d_mat_Blend.Zero;
			_this.set_blendSrc(src);
			_this.set_blendAlphaSrc(src);
			_this.set_blendDst(dst);
			_this.set_blendAlphaDst(dst);
			this.copyPass.shader.texture__ = this.backBuffer;
			this.copyPass.render();
		}
	}
	bloomPass(ctx) {
		h3d_pass_Copy.run(this.glowBuffer,this.growBufferTemps[0]);
		if(!src_Renderer.bloomPass_kernelComputed) {
			src_Renderer.bloomPass_kernelX.push(new h3d_Vector(src_Renderer.bloomPass_offsets[0] / 320,0,src_Renderer.bloomPass_divisors[0]));
			src_Renderer.bloomPass_divisor += src_Renderer.bloomPass_divisors[0];
			src_Renderer.bloomPass_kernelX.push(new h3d_Vector(src_Renderer.bloomPass_offsets[1] / 320,0,src_Renderer.bloomPass_divisors[1]));
			src_Renderer.bloomPass_divisor += src_Renderer.bloomPass_divisors[1];
			src_Renderer.bloomPass_kernelX.push(new h3d_Vector(src_Renderer.bloomPass_offsets[2] / 320,0,src_Renderer.bloomPass_divisors[2]));
			src_Renderer.bloomPass_divisor += src_Renderer.bloomPass_divisors[2];
			src_Renderer.bloomPass_kernelX.push(new h3d_Vector(src_Renderer.bloomPass_offsets[3] / 320,0,src_Renderer.bloomPass_divisors[3]));
			src_Renderer.bloomPass_divisor += src_Renderer.bloomPass_divisors[3];
			src_Renderer.bloomPass_kernelX.push(new h3d_Vector(src_Renderer.bloomPass_offsets[4] / 320,0,src_Renderer.bloomPass_divisors[4]));
			src_Renderer.bloomPass_divisor += src_Renderer.bloomPass_divisors[4];
			src_Renderer.bloomPass_kernelX.push(new h3d_Vector(src_Renderer.bloomPass_offsets[5] / 320,0,src_Renderer.bloomPass_divisors[5]));
			src_Renderer.bloomPass_divisor += src_Renderer.bloomPass_divisors[5];
			src_Renderer.bloomPass_kernelX.push(new h3d_Vector(src_Renderer.bloomPass_offsets[6] / 320,0,src_Renderer.bloomPass_divisors[6]));
			src_Renderer.bloomPass_divisor += src_Renderer.bloomPass_divisors[6];
			src_Renderer.bloomPass_kernelX.push(new h3d_Vector(src_Renderer.bloomPass_offsets[7] / 320,0,src_Renderer.bloomPass_divisors[7]));
			src_Renderer.bloomPass_divisor += src_Renderer.bloomPass_divisors[7];
			src_Renderer.bloomPass_kernelX.push(new h3d_Vector(src_Renderer.bloomPass_offsets[8] / 320,0,src_Renderer.bloomPass_divisors[8]));
			src_Renderer.bloomPass_divisor += src_Renderer.bloomPass_divisors[8];
			src_Renderer.bloomPass_kernelX.push(new h3d_Vector(src_Renderer.bloomPass_offsets[9] / 320,0,src_Renderer.bloomPass_divisors[9]));
			src_Renderer.bloomPass_divisor += src_Renderer.bloomPass_divisors[9];
			src_Renderer.bloomPass_kernelX.push(new h3d_Vector(src_Renderer.bloomPass_offsets[10] / 320,0,src_Renderer.bloomPass_divisors[10]));
			src_Renderer.bloomPass_divisor += src_Renderer.bloomPass_divisors[10];
			src_Renderer.bloomPass_kernelX.push(new h3d_Vector(src_Renderer.bloomPass_offsets[11] / 320,0,src_Renderer.bloomPass_divisors[11]));
			src_Renderer.bloomPass_divisor += src_Renderer.bloomPass_divisors[11];
			src_Renderer.bloomPass_kernelX.push(new h3d_Vector(src_Renderer.bloomPass_offsets[12] / 320,0,src_Renderer.bloomPass_divisors[12]));
			src_Renderer.bloomPass_divisor += src_Renderer.bloomPass_divisors[12];
			src_Renderer.bloomPass_kernelY.push(new h3d_Vector(0,src_Renderer.bloomPass_offsets[0] / 320,src_Renderer.bloomPass_divisors[0]));
			src_Renderer.bloomPass_kernelY.push(new h3d_Vector(0,src_Renderer.bloomPass_offsets[1] / 320,src_Renderer.bloomPass_divisors[1]));
			src_Renderer.bloomPass_kernelY.push(new h3d_Vector(0,src_Renderer.bloomPass_offsets[2] / 320,src_Renderer.bloomPass_divisors[2]));
			src_Renderer.bloomPass_kernelY.push(new h3d_Vector(0,src_Renderer.bloomPass_offsets[3] / 320,src_Renderer.bloomPass_divisors[3]));
			src_Renderer.bloomPass_kernelY.push(new h3d_Vector(0,src_Renderer.bloomPass_offsets[4] / 320,src_Renderer.bloomPass_divisors[4]));
			src_Renderer.bloomPass_kernelY.push(new h3d_Vector(0,src_Renderer.bloomPass_offsets[5] / 320,src_Renderer.bloomPass_divisors[5]));
			src_Renderer.bloomPass_kernelY.push(new h3d_Vector(0,src_Renderer.bloomPass_offsets[6] / 320,src_Renderer.bloomPass_divisors[6]));
			src_Renderer.bloomPass_kernelY.push(new h3d_Vector(0,src_Renderer.bloomPass_offsets[7] / 320,src_Renderer.bloomPass_divisors[7]));
			src_Renderer.bloomPass_kernelY.push(new h3d_Vector(0,src_Renderer.bloomPass_offsets[8] / 320,src_Renderer.bloomPass_divisors[8]));
			src_Renderer.bloomPass_kernelY.push(new h3d_Vector(0,src_Renderer.bloomPass_offsets[9] / 320,src_Renderer.bloomPass_divisors[9]));
			src_Renderer.bloomPass_kernelY.push(new h3d_Vector(0,src_Renderer.bloomPass_offsets[10] / 320,src_Renderer.bloomPass_divisors[10]));
			src_Renderer.bloomPass_kernelY.push(new h3d_Vector(0,src_Renderer.bloomPass_offsets[11] / 320,src_Renderer.bloomPass_divisors[11]));
			src_Renderer.bloomPass_kernelY.push(new h3d_Vector(0,src_Renderer.bloomPass_offsets[12] / 320,src_Renderer.bloomPass_divisors[12]));
			src_Renderer.bloomPass_kernelComputed = true;
		}
		this.blurShader.shader.kernel__ = src_Renderer.bloomPass_kernelX;
		this.blurShader.shader.divisor__ = src_Renderer.bloomPass_divisor;
		this.blurShader.shader.texture__ = this.growBufferTemps[0];
		ctx.engine.pushTarget(this.growBufferTemps[1]);
		ctx.engine.clear(0,1);
		this.blurShader.render();
		ctx.engine.popTarget();
		this.blurShader.shader.kernel__ = src_Renderer.bloomPass_kernelY;
		this.blurShader.shader.divisor__ = src_Renderer.bloomPass_divisor;
		this.blurShader.shader.texture__ = this.growBufferTemps[1];
		ctx.engine.pushTarget(this.growBufferTemps[0]);
		ctx.engine.clear(0,1);
		this.blurShader.render();
		ctx.engine.popTarget();
	}
}
$hxClasses["src.Renderer"] = src_Renderer;
src_Renderer.__name__ = "src.Renderer";
src_Renderer.__super__ = h3d_scene_Renderer;
Object.assign(src_Renderer.prototype, {
	__class__: src_Renderer
	,depth: null
	,normal: null
	,shadow: null
	,glowBuffer: null
	,blurShader: null
	,growBufferTemps: null
	,copyPass: null
	,backBuffer: null
	,depthBuffer: null
});
var src_ReplayMarbleState = $hxEnums["src.ReplayMarbleState"] = { __ename__:true,__constructs__:null
	,UsedPowerup: {_hx_name:"UsedPowerup",_hx_index:0,__enum__:"src.ReplayMarbleState",toString:$estr}
	,Jumped: {_hx_name:"Jumped",_hx_index:1,__enum__:"src.ReplayMarbleState",toString:$estr}
	,InstantTeleport: {_hx_name:"InstantTeleport",_hx_index:2,__enum__:"src.ReplayMarbleState",toString:$estr}
	,UsedBlast: {_hx_name:"UsedBlast",_hx_index:3,__enum__:"src.ReplayMarbleState",toString:$estr}
};
src_ReplayMarbleState.__constructs__ = [src_ReplayMarbleState.UsedPowerup,src_ReplayMarbleState.Jumped,src_ReplayMarbleState.InstantTeleport,src_ReplayMarbleState.UsedBlast];
src_ReplayMarbleState.__empty_constructs__ = [src_ReplayMarbleState.UsedPowerup,src_ReplayMarbleState.Jumped,src_ReplayMarbleState.InstantTeleport,src_ReplayMarbleState.UsedBlast];
class src_ReplayFrame {
	constructor() {
	}
	interpolate(next,time) {
		let t = (time - this.time) / (next.time - this.time);
		let dt = time - this.time;
		let interpFrame = new src_ReplayFrame();
		interpFrame.time = time;
		interpFrame.bonusTime = this.bonusTime;
		interpFrame.clockTime = this.clockTime;
		if(interpFrame.bonusTime != 0 && time >= 3.5) {
			if(dt <= this.bonusTime) {
				interpFrame.bonusTime -= dt;
			} else {
				interpFrame.clockTime += dt - this.bonusTime;
				interpFrame.bonusTime = 0;
			}
		} else if(this.time >= 3.5) {
			interpFrame.clockTime += dt;
		} else if(this.time + dt >= 3.5) {
			interpFrame.clockTime += this.time + dt - 3.5;
		}
		if((this.marbleStateFlags & 4) != 0) {
			let _this = this.marblePosition;
			interpFrame.marblePosition = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
			let _this1 = this.marbleVelocity;
			interpFrame.marbleVelocity = new h3d_Vector(_this1.x,_this1.y,_this1.z,_this1.w);
			let _this2 = this.marbleOrientation;
			interpFrame.marbleOrientation = new h3d_Quat(_this2.x,_this2.y,_this2.z,_this2.w);
			let _this3 = this.marbleAngularVelocity;
			interpFrame.marbleAngularVelocity = new h3d_Vector(_this3.x,_this3.y,_this3.z,_this3.w);
			interpFrame.marbleStateFlags |= 4;
		} else {
			let v1 = this.marblePosition;
			let v2 = next.marblePosition;
			let a = v1.x;
			let a1 = v1.y;
			let a2 = v1.z;
			let a3 = v1.w;
			interpFrame.marblePosition = new h3d_Vector(a + (v2.x - a) * t,a1 + (v2.y - a1) * t,a2 + (v2.z - a2) * t,a3 + (v2.w - a3) * t);
			let v11 = this.marbleVelocity;
			let v21 = next.marbleVelocity;
			let a4 = v11.x;
			let a5 = v11.y;
			let a6 = v11.z;
			let a7 = v11.w;
			interpFrame.marbleVelocity = new h3d_Vector(a4 + (v21.x - a4) * t,a5 + (v21.y - a5) * t,a6 + (v21.z - a6) * t,a7 + (v21.w - a7) * t);
			interpFrame.marbleOrientation = new h3d_Quat();
			let _this = interpFrame.marbleOrientation;
			let q1 = this.marbleOrientation;
			let q2 = next.marbleOrientation;
			let cosHalfTheta = q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;
			if((cosHalfTheta < 0 ? -cosHalfTheta : cosHalfTheta) >= 1) {
				_this.x = q1.x;
				_this.y = q1.y;
				_this.z = q1.z;
				_this.w = q1.w;
			} else {
				let halfTheta = Math.acos(cosHalfTheta);
				let invSinHalfTheta = 1. / Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
				if((invSinHalfTheta < 0 ? -invSinHalfTheta : invSinHalfTheta) > 1e3) {
					let v = 0.5;
					if(q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w < 0) {
						v = -0.5;
					}
					let x = q1.x * 0.5 + q2.x * v;
					let y = q1.y * 0.5 + q2.y * v;
					let z = q1.z * 0.5 + q2.z * v;
					let w = q1.w * 0.5 + q2.w * v;
					_this.x = x;
					_this.y = y;
					_this.z = z;
					_this.w = w;
				} else {
					let a = Math.sin((1 - t) * halfTheta) * invSinHalfTheta;
					let b = Math.sin(t * halfTheta) * invSinHalfTheta * (cosHalfTheta < 0 ? -1 : 1);
					_this.x = q1.x * a + q2.x * b;
					_this.y = q1.y * a + q2.y * b;
					_this.z = q1.z * a + q2.z * b;
					_this.w = q1.w * a + q2.w * b;
				}
			}
			let _this1 = interpFrame.marbleOrientation;
			let len = _this1.x * _this1.x + _this1.y * _this1.y + _this1.z * _this1.z + _this1.w * _this1.w;
			if(len < 1e-10) {
				_this1.x = _this1.y = _this1.z = 0;
				_this1.w = 1;
			} else {
				let m = 1. / Math.sqrt(len);
				_this1.x *= m;
				_this1.y *= m;
				_this1.z *= m;
				_this1.w *= m;
			}
			let v12 = this.marbleAngularVelocity;
			let v22 = next.marbleAngularVelocity;
			let a8 = v12.x;
			let a9 = v12.y;
			let a10 = v12.z;
			let a11 = v12.w;
			interpFrame.marbleAngularVelocity = new h3d_Vector(a8 + (v22.x - a8) * t,a9 + (v22.y - a9) * t,a10 + (v22.z - a10) * t,a11 + (v22.w - a11) * t);
		}
		if((this.marbleStateFlags & 4) != 0) {
			interpFrame.cameraYaw = this.cameraYaw;
			interpFrame.cameraPitch = this.cameraPitch;
		} else {
			let a = this.cameraYaw;
			interpFrame.cameraYaw = a + (next.cameraYaw - a) * t;
			let a1 = this.cameraPitch;
			interpFrame.cameraPitch = a1 + (next.cameraPitch - a1) * t;
		}
		if((this.marbleStateFlags & 1) != 0) {
			interpFrame.marbleStateFlags |= 1;
		}
		if((this.marbleStateFlags & 2) != 0) {
			interpFrame.marbleStateFlags |= 2;
		}
		if((this.marbleStateFlags & 8) != 0) {
			interpFrame.marbleStateFlags |= 8;
		}
		interpFrame.marbleX = this.marbleX;
		interpFrame.marbleY = this.marbleY;
		if(this.gravityChange) {
			let _this = this.gravity;
			interpFrame.gravity = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
			interpFrame.gravityInstant = this.gravityInstant;
			interpFrame.gravityChange = true;
		}
		if(next.gravityChange) {
			let _this = next.gravity;
			interpFrame.gravity = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
			interpFrame.gravityInstant = next.gravityInstant;
			interpFrame.gravityChange = true;
		}
		if(this.powerupPickup != null) {
			interpFrame.powerupPickup = this.powerupPickup;
		}
		return interpFrame;
	}
	write(bw) {
		bw.writeFloat(this.time);
		bw.writeFloat(this.clockTime);
		bw.writeFloat(this.bonusTime);
		bw.writeFloat(this.marblePosition.x);
		bw.writeFloat(this.marblePosition.y);
		bw.writeFloat(this.marblePosition.z);
		bw.writeFloat(this.marbleVelocity.x);
		bw.writeFloat(this.marbleVelocity.y);
		bw.writeFloat(this.marbleVelocity.z);
		bw.writeFloat(this.marbleOrientation.x);
		bw.writeFloat(this.marbleOrientation.y);
		bw.writeFloat(this.marbleOrientation.z);
		bw.writeFloat(this.marbleOrientation.w);
		bw.writeFloat(this.marbleAngularVelocity.x);
		bw.writeFloat(this.marbleAngularVelocity.y);
		bw.writeFloat(this.marbleAngularVelocity.z);
		bw.writeByte(this.marbleStateFlags);
		bw.writeFloat(this.cameraPitch);
		bw.writeFloat(this.cameraYaw);
		bw.writeFloat(this.marbleX);
		bw.writeFloat(this.marbleY);
		if(this.gravityChange) {
			bw.writeByte(1);
			bw.writeFloat(this.gravity.x);
			bw.writeFloat(this.gravity.y);
			bw.writeFloat(this.gravity.z);
			bw.writeByte(this.gravityInstant ? 1 : 0);
		} else {
			bw.writeByte(0);
		}
		if(this.powerupPickup != null) {
			bw.writeByte(1);
			bw.writeStr(this.powerupPickup);
		} else {
			bw.writeByte(0);
		}
	}
	read(br) {
		this.time = br.readFloat();
		this.clockTime = br.readFloat();
		this.bonusTime = br.readFloat();
		this.marblePosition = new h3d_Vector(br.readFloat(),br.readFloat(),br.readFloat());
		this.marbleVelocity = new h3d_Vector(br.readFloat(),br.readFloat(),br.readFloat());
		this.marbleOrientation = new h3d_Quat(br.readFloat(),br.readFloat(),br.readFloat(),br.readFloat());
		this.marbleAngularVelocity = new h3d_Vector(br.readFloat(),br.readFloat(),br.readFloat());
		let i = br.readByte();
		let i1 = i;
		if(i == null) {
			i1 = 0;
		}
		this.marbleStateFlags = i1;
		this.cameraPitch = br.readFloat();
		this.cameraYaw = br.readFloat();
		this.marbleX = br.readFloat();
		this.marbleY = br.readFloat();
		if(br.readByte() == 1) {
			this.gravity = new h3d_Vector(br.readFloat(),br.readFloat(),br.readFloat());
			this.gravityInstant = br.readByte() == 1;
			this.gravityChange = true;
		} else {
			this.gravityChange = false;
		}
		if(br.readByte() == 1) {
			this.powerupPickup = br.readStr();
		} else {
			this.powerupPickup = null;
		}
	}
}
$hxClasses["src.ReplayFrame"] = src_ReplayFrame;
src_ReplayFrame.__name__ = "src.ReplayFrame";
Object.assign(src_ReplayFrame.prototype, {
	__class__: src_ReplayFrame
	,time: null
	,clockTime: null
	,bonusTime: null
	,marblePosition: null
	,marbleVelocity: null
	,marbleOrientation: null
	,marbleAngularVelocity: null
	,marbleStateFlags: null
	,powerupPickup: null
	,cameraPitch: null
	,cameraYaw: null
	,marbleX: null
	,marbleY: null
	,gravity: null
	,gravityInstant: null
	,gravityChange: null
});
class src_ReplayInitialState {
	constructor() {
		this.randomGenTimes = [];
		this.randomGens = [];
		this.pushButtonContactTimes = [];
		this.landMineDisappearTimes = [];
		this.trapdoorLastCompletions = [];
		this.trapdoorLastDirections = [];
		this.trapdoorLastContactTimes = [];
	}
	write(bw) {
		bw.writeInt16(this.trapdoorLastContactTimes.length);
		let _g = 0;
		let _g1 = this.trapdoorLastContactTimes;
		while(_g < _g1.length) {
			let time = _g1[_g];
			++_g;
			bw.writeFloat(time);
		}
		let _g2 = 0;
		let _g3 = this.trapdoorLastDirections;
		while(_g2 < _g3.length) {
			let dir = _g3[_g2];
			++_g2;
			bw.writeByte(dir);
		}
		let _g4 = 0;
		let _g5 = this.trapdoorLastCompletions;
		while(_g4 < _g5.length) {
			let completion = _g5[_g4];
			++_g4;
			bw.writeFloat(completion);
		}
		bw.writeInt16(this.landMineDisappearTimes.length);
		let _g6 = 0;
		let _g7 = this.landMineDisappearTimes;
		while(_g6 < _g7.length) {
			let time = _g7[_g6];
			++_g6;
			bw.writeFloat(time);
		}
		bw.writeInt16(this.pushButtonContactTimes.length);
		let _g8 = 0;
		let _g9 = this.pushButtonContactTimes;
		while(_g8 < _g9.length) {
			let time = _g9[_g8];
			++_g8;
			bw.writeFloat(time);
		}
		bw.writeInt16(this.randomGens.length);
		let _g10 = 0;
		let _g11 = this.randomGens;
		while(_g10 < _g11.length) {
			let ri = _g11[_g10];
			++_g10;
			bw.writeByte(ri);
		}
	}
	read(br,version) {
		let trapdoorCount = br.readInt16();
		let _g = 0;
		while(_g < trapdoorCount) {
			++_g;
			this.trapdoorLastContactTimes.push(br.readFloat());
		}
		let _g1 = 0;
		while(_g1 < trapdoorCount) {
			++_g1;
			this.trapdoorLastDirections.push(br.readByte());
		}
		let _g2 = 0;
		while(_g2 < trapdoorCount) {
			++_g2;
			this.trapdoorLastCompletions.push(br.readFloat());
		}
		let landMineCount = br.readInt16();
		let _g3 = 0;
		while(_g3 < landMineCount) {
			++_g3;
			this.landMineDisappearTimes.push(br.readFloat());
		}
		if(version > 5) {
			let pushButtonCount = br.readInt16();
			let _g = 0;
			while(_g < pushButtonCount) {
				++_g;
				this.pushButtonContactTimes.push(br.readFloat());
			}
			let rcount = br.readInt16();
			let _g1 = 0;
			while(_g1 < rcount) {
				++_g1;
				this.randomGens.push(br.readByte());
			}
		}
	}
}
$hxClasses["src.ReplayInitialState"] = src_ReplayInitialState;
src_ReplayInitialState.__name__ = "src.ReplayInitialState";
Object.assign(src_ReplayInitialState.prototype, {
	__class__: src_ReplayInitialState
	,trapdoorLastContactTimes: null
	,trapdoorLastDirections: null
	,trapdoorLastCompletions: null
	,landMineDisappearTimes: null
	,pushButtonContactTimes: null
	,randomGens: null
	,randomGenTimes: null
});
class src_Replay {
	constructor(mission,customId) {
		if(customId == null) {
			customId = 0;
		}
		this.version = 6;
		this.mission = mission;
		this.customId = customId;
		this.initialState = new src_ReplayInitialState();
	}
	startFrame() {
		this.currentRecordFrame = new src_ReplayFrame();
	}
	endFrame() {
		if(this.currentRecordFrame != null) {
			this.frames.push(this.currentRecordFrame);
		}
		this.currentRecordFrame = null;
	}
	recordTimeState(time,clockTime,bonusTime) {
		if(this.currentRecordFrame == null) {
			return;
		}
		this.currentRecordFrame.time = time;
		this.currentRecordFrame.clockTime = clockTime;
		this.currentRecordFrame.bonusTime = bonusTime;
	}
	recordMarbleState(position,velocity,orientation,angularVelocity) {
		if(this.currentRecordFrame == null) {
			return;
		}
		this.currentRecordFrame.marblePosition = new h3d_Vector(position.x,position.y,position.z,position.w);
		this.currentRecordFrame.marbleVelocity = new h3d_Vector(velocity.x,velocity.y,velocity.z,velocity.w);
		this.currentRecordFrame.marbleOrientation = new h3d_Quat(orientation.x,orientation.y,orientation.z,orientation.w);
		this.currentRecordFrame.marbleAngularVelocity = new h3d_Vector(angularVelocity.x,angularVelocity.y,angularVelocity.z,angularVelocity.w);
	}
	recordMarbleStateFlags(jumped,usedPowerup,instantTeleport,usedBlast) {
		if(this.currentRecordFrame == null) {
			return;
		}
		if(jumped) {
			this.currentRecordFrame.marbleStateFlags |= 2;
		}
		if(usedPowerup) {
			this.currentRecordFrame.marbleStateFlags |= 1;
		}
		if(instantTeleport) {
			this.currentRecordFrame.marbleStateFlags |= 4;
		}
		if(usedBlast) {
			this.currentRecordFrame.marbleStateFlags |= 8;
		}
	}
	recordPowerupPickup(powerup) {
		if(this.currentRecordFrame == null) {
			return;
		}
		if(powerup == null) {
			this.currentRecordFrame.powerupPickup = "";
		} else {
			this.currentRecordFrame.powerupPickup = powerup.identifier;
		}
	}
	recordMarbleInput(x,y) {
		if(this.currentRecordFrame == null) {
			return;
		}
		this.currentRecordFrame.marbleX = x;
		this.currentRecordFrame.marbleY = y;
	}
	recordCameraState(pitch,yaw) {
		if(this.currentRecordFrame == null) {
			return;
		}
		this.currentRecordFrame.cameraPitch = pitch;
		this.currentRecordFrame.cameraYaw = yaw;
	}
	recordGravity(gravity,instant) {
		if(this.currentRecordFrame == null) {
			return;
		}
		this.currentRecordFrame.gravityChange = true;
		this.currentRecordFrame.gravity = new h3d_Vector(gravity.x,gravity.y,gravity.z,gravity.w);
		if(instant) {
			this.currentRecordFrame.gravityInstant = instant;
		}
	}
	recordTrapdoorState(lastContactTime,lastDirection,lastCompletion) {
		this.initialState.trapdoorLastContactTimes.push(lastContactTime);
		this.initialState.trapdoorLastDirections.push(lastDirection);
		this.initialState.trapdoorLastCompletions.push(lastCompletion);
	}
	recordRandomGenState(ri) {
		this.initialState.randomGens.push(ri);
		if(this.currentRecordFrame == null) {
			this.initialState.randomGenTimes.push(0);
		} else {
			this.initialState.randomGenTimes.push(this.currentRecordFrame.time);
		}
	}
	getRandomGenState() {
		return this.initialState.randomGens.shift();
	}
	getTrapdoorState(idx) {
		return { lastContactTime : this.initialState.trapdoorLastContactTimes[idx], lastDirection : this.initialState.trapdoorLastDirections[idx], lastCompletion : this.initialState.trapdoorLastCompletions[idx]};
	}
	clear() {
		this.frames = [];
		this.initialState.randomGens = [];
		this.currentRecordFrame = null;
	}
	advance(dt) {
		if(this.currentPlaybackFrame == null) {
			this.currentPlaybackFrame = this.frames[this.currentPlaybackFrameIdx];
		}
		let nextT = this.currentPlaybackTime + dt;
		let startFrame = this.frames[this.currentPlaybackFrameIdx];
		if(this.currentPlaybackFrameIdx + 1 >= this.frames.length) {
			return false;
		}
		let nextFrame = this.frames[this.currentPlaybackFrameIdx + 1];
		let stateFlags = 0;
		let nextGravityChange = false;
		let nextGravityState = null;
		let powerup = null;
		while(nextFrame.time <= nextT) {
			this.currentPlaybackFrameIdx++;
			if(this.currentPlaybackFrameIdx + 1 >= this.frames.length) {
				return false;
			}
			let testNextFrame = this.frames[this.currentPlaybackFrameIdx + 1];
			stateFlags |= testNextFrame.marbleStateFlags;
			if(testNextFrame.gravityChange) {
				nextGravityChange = true;
				let _this = testNextFrame.gravity;
				nextGravityState = { instant : testNextFrame.gravityInstant, gravity : new h3d_Vector(_this.x,_this.y,_this.z,_this.w)};
			}
			if(testNextFrame.powerupPickup != null) {
				powerup = testNextFrame.powerupPickup;
			}
			startFrame = nextFrame;
			nextFrame = testNextFrame;
		}
		let i = stateFlags;
		if(i == null) {
			i = 0;
		}
		nextFrame.marbleStateFlags = i;
		if(nextGravityChange) {
			nextFrame.gravityChange = true;
			nextFrame.gravityInstant = nextGravityState.instant;
			let _this = nextGravityState.gravity;
			nextFrame.gravity = new h3d_Vector(_this.x,_this.y,_this.z,_this.w);
		}
		if(powerup != null) {
			nextFrame.powerupPickup = powerup;
		}
		this.currentPlaybackFrame = startFrame.interpolate(nextFrame,nextT);
		this.currentPlaybackTime += dt;
		return true;
	}
	rewind() {
		this.currentPlaybackTime = 0;
		this.currentPlaybackFrame = null;
		this.currentPlaybackFrameIdx = 0;
	}
	spliceReplay(cutAfterTime) {
		if(this.frames.length > 0) {
			let curframe = this.frames[this.frames.length - 1];
			while(curframe.time > cutAfterTime && this.frames.length > 0) {
				this.frames.pop();
				curframe = this.frames[this.frames.length - 1];
			}
		}
		if(this.initialState.randomGenTimes.length > 0) {
			let rtimeIdx = this.initialState.randomGenTimes.length - 1;
			while(this.initialState.randomGenTimes[rtimeIdx] > cutAfterTime && this.initialState.randomGenTimes.length > 0) {
				this.initialState.randomGenTimes.pop();
				this.initialState.randomGens.pop();
				rtimeIdx = this.initialState.randomGenTimes.length - 1;
			}
		}
	}
	write() {
		let bw = new dif_io_BytesWriter();
		this.initialState.write(bw);
		bw.writeInt32(this.frames.length);
		let _g = 0;
		let _g1 = this.frames;
		while(_g < _g1.length) {
			let frame = _g1[_g];
			++_g;
			frame.write(bw);
		}
		let buf = bw.getBuffer();
		let bufsize = buf.length;
		let stream = zip_DeflateStream.create(zip_CompressionLevel.GOOD,true);
		stream.write(new haxe_io_BytesInput(bw.getBuffer()));
		let compressed = stream.finalize();
		if(this.name == null) {
			this.name = this.mission;
		}
		let finalB = new haxe_io_BytesBuffer();
		finalB.addByte(this.version);
		finalB.addByte(this.name.length);
		finalB.addString(this.name);
		finalB.addByte(this.mission.length);
		finalB.addString(this.mission);
		finalB.addInt32(this.customId);
		finalB.addInt32(bufsize);
		finalB.addBytes(compressed,0,compressed.length);
		return finalB.getBytes();
	}
	read(data) {
		src_Console.instance.addEntry("log","Loading replay");
		let replayVersion = data.b[0];
		if(replayVersion > this.version) {
			src_Console.instance.addEntry("log","Replay loading failed: unknown version");
			return false;
		}
		if(replayVersion < 5) {
			src_Console.instance.addEntry("log","Replay loading failed: version " + replayVersion + " does not have a header");
			return false;
		}
		let nameLength = data.b[1];
		this.name = data.getString(2,nameLength);
		let missionLength = data.b[2 + nameLength];
		this.mission = data.getString(3 + nameLength,missionLength);
		let uncompressedLength = 0;
		let compressedData = null;
		if(replayVersion > 5) {
			this.customId = data.getInt32(3 + nameLength + missionLength);
			uncompressedLength = data.getInt32(7 + nameLength + missionLength);
			compressedData = data.sub(11 + nameLength + missionLength,data.length - 11 - nameLength - missionLength);
		} else {
			uncompressedLength = data.getInt32(3 + nameLength + missionLength);
			compressedData = data.sub(7 + nameLength + missionLength,data.length - 7 - nameLength - missionLength);
		}
		let uncompressed = haxe_zip_InflateImpl.run(new haxe_io_BytesInput(compressedData),uncompressedLength);
		let br = new dif_io_BytesReader(uncompressed);
		this.initialState.read(br,replayVersion);
		let frameCount = br.readInt32();
		this.frames = [];
		let _g = 0;
		while(_g < frameCount) {
			++_g;
			let frame = new src_ReplayFrame();
			frame.read(br);
			this.frames.push(frame);
		}
		return true;
	}
}
$hxClasses["src.Replay"] = src_Replay;
src_Replay.__name__ = "src.Replay";
Object.assign(src_Replay.prototype, {
	__class__: src_Replay
	,mission: null
	,name: null
	,customId: null
	,frames: null
	,initialState: null
	,currentRecordFrame: null
	,currentPlaybackFrame: null
	,currentPlaybackFrameIdx: null
	,currentPlaybackTime: null
	,version: null
});
class src_ReusableListIterator_$src_$MeshInstance {
	constructor(l) {
		this.i = 0;
		this.l = l;
	}
	hasNext() {
		return this.i != this.l.length;
	}
	next() {
		let ret = this.l.array[this.i];
		this.i += 1;
		return ret;
	}
}
$hxClasses["src.ReusableListIterator_src_MeshInstance"] = src_ReusableListIterator_$src_$MeshInstance;
src_ReusableListIterator_$src_$MeshInstance.__name__ = "src.ReusableListIterator_src_MeshInstance";
Object.assign(src_ReusableListIterator_$src_$MeshInstance.prototype, {
	__class__: src_ReusableListIterator_$src_$MeshInstance
	,l: null
	,i: null
});
class src_ReusableList_$src_$MeshInstance {
	constructor() {
		this.length = 0;
		this.array = [];
	}
}
$hxClasses["src.ReusableList_src_MeshInstance"] = src_ReusableList_$src_$MeshInstance;
src_ReusableList_$src_$MeshInstance.__name__ = "src.ReusableList_src_MeshInstance";
Object.assign(src_ReusableList_$src_$MeshInstance.prototype, {
	__class__: src_ReusableList_$src_$MeshInstance
	,array: null
	,length: null
});
class src_Settings {
	static applySettings() {
		src_AudioManager.updateVolumes();
		(js_Boot.__cast(src_MarbleGame.instance.scene.renderer , src_Renderer)).onResize();
		src_MarbleGame.canvas.render(src_MarbleGame.canvas.scene2d);
		src_Settings.save();
	}
	static saveScore(mapPath,score,scoreType) {
		if(scoreType == null) {
			scoreType = modes_ScoreType.Time;
		}
		if(Object.prototype.hasOwnProperty.call(src_Settings.highScores.h,mapPath)) {
			let scoreList = src_Settings.highScores.h[mapPath];
			scoreList.push(score);
			scoreList.sort(function(a,b) {
				if(a.time == b.time) {
					return 0;
				} else if(a.time > b.time) {
					return 1;
				} else {
					return -1;
				}
			});
			if(scoreType == modes_ScoreType.Score) {
				scoreList.reverse();
			}
		} else {
			src_Settings.highScores.h[mapPath] = [score];
		}
		src_Settings.save();
	}
	static getScores(mapPath) {
		if(Object.prototype.hasOwnProperty.call(src_Settings.highScores.h,mapPath)) {
			return src_Settings.highScores.h[mapPath].slice();
		} else {
			return [];
		}
	}
	static save() {
		let outputData = { options : src_Settings.optionsSettings, controls : src_Settings.controlsSettings, touch : src_Settings.touchSettings, gamepad : src_Settings.gamepadSettings, stats : src_Settings.playStatistics, highscoreName : src_Settings.highscoreName, userId : src_Settings.userId, marbleIndex : src_Settings.optionsSettings.marbleIndex, marbleSkin : src_Settings.optionsSettings.marbleSkin, marbleModel : src_Settings.optionsSettings.marbleModel, marbleCategoryIndex : src_Settings.optionsSettings.marbleCategoryIndex, marbleShader : src_Settings.optionsSettings.marbleShader, achievementProgression : src_Settings.achievementProgression};
		let h = src_Settings.highScores.h;
		let _g_keys = Object.keys(h);
		let _g_length = _g_keys.length;
		let _g_current = 0;
		while(_g_current < _g_length) ++_g_current;
		let h1 = src_Settings.easterEggs.h;
		let _g_keys1 = Object.keys(h1);
		let _g_length1 = _g_keys1.length;
		let _g_current1 = 0;
		while(_g_current1 < _g_length1) ++_g_current1;
		let h2 = src_Settings.levelStatistics.h;
		let _g_keys2 = Object.keys(h2);
		let _g_length2 = _g_keys2.length;
		let _g_current2 = 0;
		while(_g_current2 < _g_length2) ++_g_current2;
		let kvps = [];
		let h3 = src_Settings.highScores.h;
		let _g_keys3 = Object.keys(h3);
		let _g_length3 = _g_keys3.length;
		let _g_current3 = 0;
		while(_g_current3 < _g_length3) {
			let key = _g_keys3[_g_current3++];
			let _g_value = h3[key];
			kvps.push([key,_g_value]);
		}
		let jobj = Object.fromEntries(kvps);
		outputData.highScores = jobj;
		kvps = [];
		let h4 = src_Settings.easterEggs.h;
		let _g_keys4 = Object.keys(h4);
		let _g_length4 = _g_keys4.length;
		let _g_current4 = 0;
		while(_g_current4 < _g_length4) {
			let key = _g_keys4[_g_current4++];
			let _g_value = h4[key];
			kvps.push([key,_g_value]);
		}
		jobj = Object.fromEntries(kvps);
		outputData.easterEggs = jobj;
		kvps = [];
		let h5 = src_Settings.levelStatistics.h;
		let _g_keys5 = Object.keys(h5);
		let _g_length5 = _g_keys5.length;
		let _g_current5 = 0;
		while(_g_current5 < _g_length5) {
			let key = _g_keys5[_g_current5++];
			let _g_value = h5[key];
			kvps.push([key,_g_value]);
		}
		jobj = Object.fromEntries(kvps);
		outputData.levelStatistics = jobj;
		let json = JSON.stringify(outputData);
		let localStorage = js_Browser.getLocalStorage();
		if(localStorage != null) {
			localStorage.setItem("MBHaxeSettings",json);
		}
	}
	static load() {
		src_Console.instance.addEntry("log","Loading settings");
		let settingsExists = false;
		let localStorage = js_Browser.getLocalStorage();
		if(localStorage != null) {
			settingsExists = localStorage.getItem("MBHaxeSettings") != null;
		}
		if(settingsExists) {
			let json = JSON.parse(localStorage.getItem("MBHaxeSettings"));
			let highScoreData = json.highScores;
			let _g_keys = Reflect.fields(highScoreData);
			let _g_index = 0;
			while(_g_index < _g_keys.length) {
				let key = _g_keys[_g_index++];
				let _g_value = highScoreData[key];
				src_Settings.highScores.h[key] = _g_value;
			}
			let easterEggData = json.easterEggs;
			if(easterEggData != null) {
				let _g_keys = Reflect.fields(easterEggData);
				let _g_index = 0;
				while(_g_index < _g_keys.length) {
					let key = _g_keys[_g_index++];
					let _g_value = easterEggData[key];
					src_Settings.easterEggs.h[key] = _g_value;
				}
			}
			src_Settings.optionsSettings = json.options;
			if(src_Settings.optionsSettings.fovX == 0 || src_Settings.optionsSettings.fovX == null) {
				src_Settings.optionsSettings.fovX = 90;
			}
			if(src_Settings.optionsSettings.rewindEnabled == false || src_Settings.optionsSettings.rewindEnabled == null) {
				src_Settings.optionsSettings.rewindEnabled = false;
			}
			if(src_Settings.optionsSettings.rewindTimescale == 0 || src_Settings.optionsSettings.rewindTimescale == null) {
				src_Settings.optionsSettings.rewindTimescale = 1;
			}
			if(src_Settings.optionsSettings.reflectionDetail == null) {
				src_Settings.optionsSettings.reflectionDetail = 2;
			}
			if(src_Settings.controlsSettings.controllerVerticalCenter == null) {
				src_Settings.controlsSettings.controllerVerticalCenter = true;
			}
			if(src_Settings.optionsSettings.huntRandom == null) {
				src_Settings.optionsSettings.huntRandom = false;
			}
			if(src_Settings.optionsSettings.fastLoad == null) {
				src_Settings.optionsSettings.fastLoad = false;
			}
			if(src_Settings.optionsSettings.maxPixelRatio == 0 || src_Settings.optionsSettings.maxPixelRatio == null) {
				src_Settings.optionsSettings.maxPixelRatio = 1;
			}
			src_Settings.controlsSettings = json.controls;
			if(json.touch != null) {
				src_Settings.touchSettings = json.touch;
			}
			if(src_Settings.controlsSettings.rewind == 0) {
				src_Settings.controlsSettings.rewind = 82;
			}
			if(src_Settings.controlsSettings.chat == 0) {
				src_Settings.controlsSettings.chat = 84;
			}
			if(src_Settings.touchSettings.blastButtonPos == null) {
				src_Settings.touchSettings.blastButtonPos = [300,240];
				src_Settings.touchSettings.blastButtonSize = 60;
			}
			if(src_Settings.touchSettings.rewindButtonPos == null) {
				src_Settings.touchSettings.rewindButtonPos = [300,100];
				src_Settings.touchSettings.rewindButtonSize = 60;
			}
			if(src_Settings.touchSettings.hideControls == null) {
				src_Settings.touchSettings.hideControls = false;
			}
			if(src_Settings.touchSettings.cameraSwipeExtent == null) {
				src_Settings.touchSettings.cameraSwipeExtent = 10.0;
			}
			if(src_Settings.touchSettings.dynamicJoystick == null) {
				src_Settings.touchSettings.dynamicJoystick = false;
			}
			if(src_Settings.touchSettings.cameraSwipeExtent == 0) {
				src_Settings.touchSettings.cameraSwipeExtent = 10.0;
			}
			if(json.gamepad != null) {
				src_Settings.gamepadSettings = json.gamepad;
			}
			if(src_Settings.gamepadSettings.respawn == null) {
				src_Settings.gamepadSettings.respawn = ["back"];
			}
			if(src_Settings.gamepadSettings.blast == null) {
				src_Settings.gamepadSettings.blast = ["X","LB","RB"];
			}
			if(src_Settings.gamepadSettings.rewind == null) {
				src_Settings.gamepadSettings.rewind = ["Y"];
			}
			if(json.stats != null) {
				src_Settings.playStatistics = json.stats;
				if(src_Settings.playStatistics.totalMPScore == null) {
					src_Settings.playStatistics.totalMPScore = 0;
				}
			}
			src_Settings.achievementProgression = json.achievementProgression;
			if(json.levelStatistics != null) {
				let levelStatData = json.levelStatistics;
				let _g_keys = Reflect.fields(levelStatData);
				let _g_index = 0;
				while(_g_index < _g_keys.length) {
					let key = _g_keys[_g_index++];
					let _g_value = levelStatData[key];
					src_Settings.levelStatistics.h[key] = _g_value;
				}
			}
			if(src_Settings.optionsSettings.marbleIndex == null) {
				src_Settings.optionsSettings.marbleIndex = 0;
				src_Settings.optionsSettings.marbleSkin = "base";
				src_Settings.optionsSettings.marbleModel = "data/shapes/balls/marble01.dts";
			}
			if(src_Settings.optionsSettings.marbleCategoryIndex == null) {
				src_Settings.optionsSettings.marbleCategoryIndex = 0;
			}
			if(src_Settings.optionsSettings.marbleShader == null) {
				src_Settings.optionsSettings.marbleShader = "ClassicGlassPureSphere";
			}
			if(src_Settings.controlsSettings.blast == null) {
				src_Settings.controlsSettings.blast = 69;
			}
			if(src_Settings.controlsSettings.rewind == null) {
				src_Settings.controlsSettings.rewind = 82;
			}
			if(src_Settings.controlsSettings.chat == null) {
				src_Settings.controlsSettings.chat = 84;
			}
			if(src_Settings.controlsSettings.oobRespawnKeyByPowerup == null) {
				src_Settings.controlsSettings.oobRespawnKeyByPowerup = false;
			}
			if(src_Settings.controlsSettings.moddedController == null) {
				src_Settings.controlsSettings.moddedController = false;
			}
			if(src_Settings.optionsSettings.rewindEnabled == null) {
				src_Settings.optionsSettings.rewindEnabled = false;
			}
			if(src_Settings.optionsSettings.rewindTimescale == null) {
				src_Settings.optionsSettings.rewindTimescale = 1;
			}
			if(src_Settings.achievementProgression == null) {
				src_Settings.achievementProgression = 0;
			}
			src_Settings.highscoreName = json.highscoreName;
			if(src_Settings.highscoreName == null) {
				src_Settings.highscoreName = "";
			}
			src_Settings.userId = json.userId;
			if(src_Settings.userId == null || src_Settings.userId == "") {
				src_Settings.userId = net_Uuid.v4();
			}
		} else {
			src_Console.instance.addEntry("warn","Settings file does not exist");
			src_Settings.save();
		}
	}
	static init() {
		src_Settings.load();
		hxd_Window.getInstance().propagateKeyEvents = true;
		hxd_Window.getInstance().addResizeEvent(function() {
			hxd_Window.getInstance();
			hxd_Window.getInstance().get_windowToPixelRatio();
			let zoomRatio;
			if(src_Util.isTouchDevice()) {
				let reg = new EReg("iPad|tablet","gm");
				let t1 = reg.match($global.navigator.userAgent);
				let zoomRatio1;
				if(!t1) {
					let reg2 = new EReg("Mac","gm");
					zoomRatio1 = reg2.match($global.navigator.userAgent) && $global.navigator.maxTouchPoints != null && $global.navigator.maxTouchPoints > 2;
				} else {
					zoomRatio1 = true;
				}
				zoomRatio = !zoomRatio1;
			} else {
				zoomRatio = false;
			}
			let zoomRatio1 = zoomRatio ? window.screen.height * window.devicePixelRatio / 768 : window.devicePixelRatio;
			let reg = new EReg("iPhone","gm");
			if(reg.match($global.navigator.userAgent)) {
				zoomRatio1 = 1.5;
			}
			let reg1 = new EReg("iPhone","gm");
			if(reg1.match($global.navigator.userAgent) && window.devicePixelRatio == 2) {
				zoomRatio1 = 1.0;
			}
			src_Settings.zoomRatio = zoomRatio1;
			let tmp = window.screen.width;
			src_Settings.optionsSettings.screenWidth = Math.max(tmp,window.screen.height);
			let tmp1 = window.screen.width;
			src_Settings.optionsSettings.screenHeight = Math.min(tmp1,window.screen.height);
			let canvasElement = window.document.getElementById("webgl");
			canvasElement.style.width = "100%";
			canvasElement.style.height = "100%";
			src_Console.instance.addEntry("log","Window resized to " + src_Settings.optionsSettings.screenWidth + "x" + src_Settings.optionsSettings.screenHeight + " (Zoom " + zoomRatio1 + ")");
			src_MarbleGame.canvas.scene2d.set_scaleMode(h2d_ScaleMode.Zoom(zoomRatio1));
			if(src_MarbleGame.instance.world != null) {
				src_MarbleGame.instance.world.scene.camera.setFovX(src_Settings.optionsSettings.fovX,src_Settings.optionsSettings.screenWidth / src_Settings.optionsSettings.screenHeight);
			}
			src_MarbleGame.canvas.onResize(src_MarbleGame.canvas.scene2d.width,src_MarbleGame.canvas.scene2d.height);
			src_MarbleGame.canvas.render(src_MarbleGame.canvas.scene2d);
		});
	}
}
$hxClasses["src.Settings"] = src_Settings;
src_Settings.__name__ = "src.Settings";
class src_Sky extends h3d_scene_Object {
	constructor() {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.imageResources = [];
		super._hx_constructor();
	}
	init(level,onFinish,element) {
		let _gthis = this;
		this.createSkyboxCubeTextured(this.dmlPath,element,function(texture) {
			let sky = new h3d_prim_Sphere(1,128,128);
			sky.addNormals();
			sky.addUVs();
			let skyMesh = new h3d_scene_Mesh(sky,null,_gthis);
			skyMesh.material.passes.set_culling(h3d_mat_Face.None);
			skyMesh.material.passes.set_enableLights(false);
			let _this = skyMesh.material;
			_this.set_castShadows(false);
			_this.set_receiveShadows(false);
			skyMesh.material.set_blendMode(h2d_BlendMode.None);
			let v = skyMesh.scaleX * 10;
			skyMesh.scaleX = v;
			skyMesh.flags |= 1;
			let v1 = skyMesh.scaleY * 10;
			skyMesh.scaleY = v1;
			skyMesh.flags |= 1;
			let v2 = skyMesh.scaleZ * 10;
			skyMesh.scaleZ = v2;
			skyMesh.flags |= 1;
			skyMesh.flags |= 1;
			let shad = new shaders_Skybox(texture);
			skyMesh.material.passes.removeShader(skyMesh.material.textureShader);
			skyMesh.material.passes.addShader(shad);
			skyMesh.material.passes.set_depthWrite(false);
			skyMesh.material.passes.depth(false,h3d_mat_Compare.Always);
			skyMesh.material.passes.setPassName("sky");
			_gthis.cubemap = texture;
			onFinish();
		});
	}
	dispose() {
		let _g = 0;
		let _g1 = this.imageResources;
		while(_g < _g1.length) {
			let imageResource = _g1[_g];
			++_g;
			imageResource.release();
		}
	}
	createSkyboxCubeTextured(dmlPath,element,onFinish) {
		dmlPath = StringTools.replace(dmlPath,"data/","");
		if(src_ResourceLoader.exists(dmlPath)) {
			let dmlFileEntry = src_ResourceLoader.getFileEntry(dmlPath).entry;
			dmlFileEntry.load(function() {
				let dmlFile = dmlFileEntry.getText();
				let dmlDirectory = haxe_io_Path.directory(dmlPath);
				let _this = dmlFile.split("\n");
				let result = new Array(_this.length);
				let _g = 0;
				let _g1 = _this.length;
				while(_g < _g1) {
					let i = _g++;
					result[i] = _this[i].toLowerCase();
				}
				let lines = result;
				let skyboxImages = [];
				let skyboxIndices_5;
				let skyboxIndices_4;
				let skyboxIndices_3;
				let skyboxIndices_2;
				let skyboxIndices_1;
				let skyboxIndices_0 = 3;
				skyboxIndices_1 = 1;
				skyboxIndices_2 = 2;
				skyboxIndices_3 = 0;
				skyboxIndices_4 = 4;
				skyboxIndices_5 = 5;
				let filestoload = [];
				let line = StringTools.trim(lines[0]);
				let filenames = src_ResourceLoader.getFullNamesOf(dmlDirectory + "/" + line);
				if(filenames.length != 0) {
					filestoload.push(filenames[0]);
				}
				let line1 = StringTools.trim(lines[1]);
				let filenames1 = src_ResourceLoader.getFullNamesOf(dmlDirectory + "/" + line1);
				if(filenames1.length != 0) {
					filestoload.push(filenames1[0]);
				}
				let line2 = StringTools.trim(lines[2]);
				let filenames2 = src_ResourceLoader.getFullNamesOf(dmlDirectory + "/" + line2);
				if(filenames2.length != 0) {
					filestoload.push(filenames2[0]);
				}
				let line3 = StringTools.trim(lines[3]);
				let filenames3 = src_ResourceLoader.getFullNamesOf(dmlDirectory + "/" + line3);
				if(filenames3.length != 0) {
					filestoload.push(filenames3[0]);
				}
				let line4 = StringTools.trim(lines[4]);
				let filenames4 = src_ResourceLoader.getFullNamesOf(dmlDirectory + "/" + line4);
				if(filenames4.length != 0) {
					filestoload.push(filenames4[0]);
				}
				let line5 = StringTools.trim(lines[5]);
				let filenames5 = src_ResourceLoader.getFullNamesOf(dmlDirectory + "/" + line5);
				if(filenames5.length != 0) {
					filestoload.push(filenames5[0]);
				}
				let fogColor = mis_MisParser.parseVector4(element.fogcolor);
				let skySolidColor = mis_MisParser.parseVector4(element.skysolidcolor);
				let skyColor = fogColor;
				if(skySolidColor.x != 0.6 || skySolidColor.y != 0.6 || skySolidColor.z != 0.6) {
					skyColor = skySolidColor;
				}
				if(skyColor.x > 1) {
					skyColor.x = 1 - (skyColor.x - 1) % 256 / 256;
				}
				if(skyColor.y > 1) {
					skyColor.y = 1 - (skyColor.y - 1) % 256 / 256;
				}
				if(skyColor.z > 1) {
					skyColor.z = 1 - (skyColor.z - 1) % 256 / 256;
				}
				let noSkyTexture = element.useskytextures == "0";
				let worker = new src_ResourceLoaderWorker(function() {
					let cubemaptexture = null;
					if(Object.prototype.hasOwnProperty.call(src_Sky.cubemapTextureCache.h,dmlPath)) {
						cubemaptexture = src_Sky.cubemapTextureCache.h[dmlPath];
					} else {
						let fnames = [];
						let _g = 0;
						while(_g < 6) {
							let i = _g++;
							let line = StringTools.trim(lines[i]);
							let filenames = src_ResourceLoader.getFullNamesOf(dmlDirectory + "/" + line);
							if(filenames.length == 0 || noSkyTexture) {
								let f = skyColor.w;
								let f1 = skyColor.x;
								let f2 = skyColor.y;
								let f3 = skyColor.z;
								let pixels = h3d_mat_Texture.fromColor(((f < 0. ? 0. : f > 1. ? 1. : f) * 255 + 0.499 | 0) << 24 | ((f1 < 0. ? 0. : f1 > 1. ? 1. : f1) * 255 + 0.499 | 0) << 16 | ((f2 < 0. ? 0. : f2 > 1. ? 1. : f2) * 255 + 0.499 | 0) << 8 | ((f3 < 0. ? 0. : f3 > 1. ? 1. : f3) * 255 + 0.499 | 0)).capturePixels(0,0);
								skyboxImages.push(pixels);
								fnames.push("");
								src_Console.instance.addEntry("error","Skybox image " + filenames[0] + " does not exist");
							} else {
								fnames.push(filenames[0]);
								let pixels = src_ResourceLoader.getImagePixels(filenames[0]);
								skyboxImages.push(pixels);
							}
						}
						let maxwidth = 0;
						let maxheight = 0;
						let _g1 = 0;
						while(_g1 < skyboxImages.length) {
							let texture = skyboxImages[_g1];
							++_g1;
							if(texture.height > maxheight) {
								maxheight = texture.height;
							}
							if(texture.width > maxwidth) {
								maxwidth = texture.width;
							}
						}
						if(fnames[0].toLowerCase().endsWith(".bmp")) {
							src_Util.flipImage(skyboxImages[0],true,true);
						} else {
							src_Util.flipImage(skyboxImages[0],true,false);
						}
						if(fnames[4].toLowerCase().endsWith(".bmp")) {
							src_Util.flipImage(skyboxImages[4],true,true);
						} else {
							src_Util.flipImage(skyboxImages[4],true,false);
						}
						src_Util.rotateImage(skyboxImages[5],Math.PI);
						if(fnames[5].toLowerCase().endsWith(".bmp")) {
							src_Util.flipImage(skyboxImages[5],true,true);
						} else {
							src_Util.flipImage(skyboxImages[5],true,false);
						}
						src_Util.rotateImage(skyboxImages[1],-Math.PI / 2);
						if(!fnames[1].toLowerCase().endsWith(".bmp")) {
							src_Util.flipImage(skyboxImages[1],true,false);
						}
						src_Util.rotateImage(skyboxImages[2],Math.PI);
						if(fnames[2].toLowerCase().endsWith(".bmp")) {
							src_Util.flipImage(skyboxImages[2],true,true);
						} else {
							src_Util.flipImage(skyboxImages[2],true,false);
						}
						src_Util.rotateImage(skyboxImages[3],Math.PI / 2);
						if(!fnames[3].toLowerCase().endsWith(".bmp")) {
							src_Util.flipImage(skyboxImages[3],true,false);
						}
						cubemaptexture = new h3d_mat_Texture(maxheight,maxwidth,[h3d_mat_TextureFlags.Cube]);
						cubemaptexture.uploadPixels(skyboxImages[skyboxIndices_0],0,0);
						cubemaptexture.uploadPixels(skyboxImages[skyboxIndices_1],0,1);
						cubemaptexture.uploadPixels(skyboxImages[skyboxIndices_2],0,2);
						cubemaptexture.uploadPixels(skyboxImages[skyboxIndices_3],0,3);
						cubemaptexture.uploadPixels(skyboxImages[skyboxIndices_4],0,4);
						cubemaptexture.uploadPixels(skyboxImages[skyboxIndices_5],0,5);
						src_Sky.cubemapTextureCache.h[dmlPath] = cubemaptexture;
					}
					onFinish(cubemaptexture);
				});
				let _g2 = 0;
				while(_g2 < filestoload.length) {
					let file = filestoload[_g2];
					++_g2;
					worker.loadFile(file);
				}
				worker.run();
			});
		} else {
			onFinish(null);
		}
	}
}
$hxClasses["src.Sky"] = src_Sky;
src_Sky.__name__ = "src.Sky";
src_Sky.__super__ = h3d_scene_Object;
Object.assign(src_Sky.prototype, {
	__class__: src_Sky
	,dmlPath: null
	,cubemap: null
	,imageResources: null
});
class src_TimeState {
	constructor() {
	}
	clone() {
		let n = new src_TimeState();
		n.timeSinceLoad = this.timeSinceLoad;
		n.currentAttemptTime = this.currentAttemptTime;
		n.gameplayClock = this.gameplayClock;
		n.dt = this.dt;
		n.ticks = this.ticks;
		n.subframe = this.subframe;
		return n;
	}
}
$hxClasses["src.TimeState"] = src_TimeState;
src_TimeState.__name__ = "src.TimeState";
Object.assign(src_TimeState.prototype, {
	__class__: src_TimeState
	,timeSinceLoad: null
	,currentAttemptTime: null
	,gameplayClock: null
	,dt: null
	,ticks: null
	,subframe: null
});
class src_Util {
	static rotateImage(bitmap,angle) {
		let curpixels = bitmap.clone();
		if(angle == Math.PI / 2) {
			let _g = 0;
			let _g1 = curpixels.width;
			while(_g < _g1) {
				let x = _g++;
				let _g1 = 0;
				let _g2 = curpixels.height;
				while(_g1 < _g2) {
					let y = _g1++;
					let psrc = (y + (curpixels.height - x - 1) * curpixels.width) * curpixels.bytesPerPixel + curpixels.offset;
					let pdest = (x + y * curpixels.width) * curpixels.bytesPerPixel + curpixels.offset;
					switch(curpixels.innerFormat._hx_index) {
					case 0:case 1:case 2:
						bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
						bitmap.bytes.b[pdest + 1] = curpixels.bytes.b[psrc + 1];
						bitmap.bytes.b[pdest + 2] = curpixels.bytes.b[psrc + 2];
						bitmap.bytes.b[pdest + 3] = curpixels.bytes.b[psrc + 3];
						break;
					case 5:
						bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
						break;
					case 8:
						bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
						bitmap.bytes.b[pdest + 1] = curpixels.bytes.b[psrc + 1];
						break;
					default:
					}
				}
			}
		}
		if(angle == -Math.PI / 2) {
			let _g = 0;
			let _g1 = curpixels.width;
			while(_g < _g1) {
				let x = _g++;
				let _g1 = 0;
				let _g2 = curpixels.height;
				while(_g1 < _g2) {
					let y = _g1++;
					let psrc = (curpixels.width - y - 1 + x * curpixels.width) * curpixels.bytesPerPixel + curpixels.offset;
					let pdest = (x + y * curpixels.width) * curpixels.bytesPerPixel + curpixels.offset;
					switch(curpixels.innerFormat._hx_index) {
					case 0:case 1:case 2:
						bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
						bitmap.bytes.b[pdest + 1] = curpixels.bytes.b[psrc + 1];
						bitmap.bytes.b[pdest + 2] = curpixels.bytes.b[psrc + 2];
						bitmap.bytes.b[pdest + 3] = curpixels.bytes.b[psrc + 3];
						break;
					case 5:
						bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
						break;
					case 8:
						bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
						bitmap.bytes.b[pdest + 1] = curpixels.bytes.b[psrc + 1];
						break;
					default:
					}
				}
			}
		}
		if(angle == Math.PI) {
			let _g = 0;
			let _g1 = curpixels.width;
			while(_g < _g1) {
				let x = _g++;
				let _g1 = 0;
				let _g2 = curpixels.height;
				while(_g1 < _g2) {
					let y = _g1++;
					let psrc = (curpixels.width - x - 1 + (curpixels.height - y - 1) * curpixels.width) * curpixels.bytesPerPixel + curpixels.offset;
					let pdest = (x + y * curpixels.width) * curpixels.bytesPerPixel + curpixels.offset;
					switch(curpixels.innerFormat._hx_index) {
					case 0:case 1:case 2:
						bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
						bitmap.bytes.b[pdest + 1] = curpixels.bytes.b[psrc + 1];
						bitmap.bytes.b[pdest + 2] = curpixels.bytes.b[psrc + 2];
						bitmap.bytes.b[pdest + 3] = curpixels.bytes.b[psrc + 3];
						break;
					case 5:
						bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
						break;
					case 8:
						bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
						bitmap.bytes.b[pdest + 1] = curpixels.bytes.b[psrc + 1];
						break;
					default:
					}
				}
			}
		}
	}
	static flipImage(bitmap,hflip,vflip) {
		let curpixels = bitmap.clone();
		if(hflip && vflip) {
			let _g = 0;
			let _g1 = curpixels.width;
			while(_g < _g1) {
				let x = _g++;
				let _g1 = 0;
				let _g2 = curpixels.height;
				while(_g1 < _g2) {
					let y = _g1++;
					let psrc = (curpixels.width - x - 1 + (curpixels.width - y - 1) * curpixels.width) * curpixels.bytesPerPixel + curpixels.offset;
					let pdest = (x + y * curpixels.width) * curpixels.bytesPerPixel + curpixels.offset;
					switch(curpixels.innerFormat._hx_index) {
					case 0:case 1:case 2:
						bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
						bitmap.bytes.b[pdest + 1] = curpixels.bytes.b[psrc + 1];
						bitmap.bytes.b[pdest + 2] = curpixels.bytes.b[psrc + 2];
						bitmap.bytes.b[pdest + 3] = curpixels.bytes.b[psrc + 3];
						break;
					case 5:
						bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
						break;
					case 8:
						bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
						bitmap.bytes.b[pdest + 1] = curpixels.bytes.b[psrc + 1];
						break;
					default:
					}
				}
			}
		} else {
			if(hflip) {
				let _g = 0;
				let _g1 = curpixels.width;
				while(_g < _g1) {
					let x = _g++;
					let _g1 = 0;
					let _g2 = curpixels.height;
					while(_g1 < _g2) {
						let y = _g1++;
						let psrc = (curpixels.width - x - 1 + y * curpixels.width) * curpixels.bytesPerPixel + curpixels.offset;
						let pdest = (x + y * curpixels.width) * curpixels.bytesPerPixel + curpixels.offset;
						switch(curpixels.innerFormat._hx_index) {
						case 0:case 1:case 2:
							bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
							bitmap.bytes.b[pdest + 1] = curpixels.bytes.b[psrc + 1];
							bitmap.bytes.b[pdest + 2] = curpixels.bytes.b[psrc + 2];
							bitmap.bytes.b[pdest + 3] = curpixels.bytes.b[psrc + 3];
							break;
						case 5:
							bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
							break;
						case 8:
							bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
							bitmap.bytes.b[pdest + 1] = curpixels.bytes.b[psrc + 1];
							break;
						default:
						}
					}
				}
			}
			if(vflip) {
				let _g = 0;
				let _g1 = curpixels.width;
				while(_g < _g1) {
					let x = _g++;
					let _g1 = 0;
					let _g2 = curpixels.height;
					while(_g1 < _g2) {
						let y = _g1++;
						let psrc = (x + (curpixels.width - y - 1) * curpixels.width) * curpixels.bytesPerPixel + curpixels.offset;
						let pdest = (x + y * curpixels.width) * curpixels.bytesPerPixel + curpixels.offset;
						switch(curpixels.innerFormat._hx_index) {
						case 0:case 1:case 2:
							bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
							bitmap.bytes.b[pdest + 1] = curpixels.bytes.b[psrc + 1];
							bitmap.bytes.b[pdest + 2] = curpixels.bytes.b[psrc + 2];
							bitmap.bytes.b[pdest + 3] = curpixels.bytes.b[psrc + 3];
							break;
						case 5:
							bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
							break;
						case 8:
							bitmap.bytes.b[pdest] = curpixels.bytes.b[psrc];
							bitmap.bytes.b[pdest + 1] = curpixels.bytes.b[psrc + 1];
							break;
						default:
						}
					}
				}
			}
		}
	}
	static splitIgnoreStringLiterals(str,splitter,strLiteralToken) {
		if(strLiteralToken == null) {
			strLiteralToken = "\"";
		}
		let indices = [];
		let inString = false;
		let _g = 0;
		let _g1 = str.length;
		while(_g < _g1) {
			let i = _g++;
			let c = str.charAt(i);
			if(inString) {
				if(c == strLiteralToken && str.charAt(i - 1) != "\\") {
					inString = false;
				}
				continue;
			}
			if(c == strLiteralToken) {
				inString = true;
			} else if(c == splitter) {
				indices.push(i);
			}
		}
		let parts = [];
		let remaining = str;
		let _g2 = 0;
		let _g3 = indices.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let index = indices[i] - (str.length - remaining.length);
			let part = remaining.substring(0,index);
			remaining = remaining.substring(index + 1);
			parts.push(part);
		}
		parts.push(remaining);
		return parts;
	}
	static unescape(str) {
		let specialCases_h = Object.create(null);
		specialCases_h["\\t"] = "\t";
		specialCases_h["\\v"] = "\x0B";
		specialCases_h["\\0"] = "\x00";
		specialCases_h["\\f"] = "\x0C";
		specialCases_h["\\n"] = "\n";
		specialCases_h["\\r"] = "\r";
		specialCases_h["\\'"] = "'";
		specialCases_h["\\\""] = "\"";
		let _g_keys = Object.keys(specialCases_h);
		let _g_length = _g_keys.length;
		let _g_current = 0;
		while(_g_current < _g_length) {
			let key = _g_keys[_g_current++];
			let _g_value = specialCases_h[key];
			str = StringTools.replace(str,key,_g_value);
		}
		return str;
	}
	static indexOfIgnoreStringLiterals(str,searchString,position,strLiteralToken) {
		if(strLiteralToken == null) {
			strLiteralToken = 34;
		}
		if(position == null) {
			position = 0;
		}
		let inString = false;
		let _g = position;
		let _g1 = str.length;
		while(_g < _g1) {
			let i = _g++;
			let c = str.charCodeAt(i);
			if(inString) {
				if(c == strLiteralToken && str.charCodeAt(i - 1) != 92) {
					inString = false;
				}
				continue;
			}
			if(c == strLiteralToken) {
				inString = true;
			} else if(str.startsWith(searchString,i)) {
				return i;
			}
		}
		return -1;
	}
	static indexIsInStringLiteral(str,index,strLiteralToken) {
		if(strLiteralToken == null) {
			strLiteralToken = "\"";
		}
		let inString = false;
		let _g = 0;
		let _g1 = str.length;
		while(_g < _g1) {
			let i = _g++;
			let c = str.charAt(i);
			if(inString) {
				if(i == index) {
					return true;
				}
				if(c == strLiteralToken && str.charAt(i - 1) != "\\") {
					inString = false;
				}
				continue;
			}
			if(c == strLiteralToken) {
				inString = true;
			}
		}
		return false;
	}
	static formatTime(time) {
		let et = time * 1000;
		let hundredth = et % 1000 / 10 | 0;
		let totalSeconds = et / 1000 | 0;
		let seconds = totalSeconds % 60;
		let minutes = (totalSeconds - seconds) / 60;
		let secondsOne = seconds % 10;
		let secondsTen = (seconds - secondsOne) / 10;
		let minutesOne = minutes % 10;
		let minutesTen = (minutes - minutesOne) / 10;
		let hundredthOne = hundredth % 10;
		let hundredthTen = (hundredth - hundredthOne) / 10;
		return "" + minutesTen + minutesOne + ":" + secondsTen + secondsOne + "." + hundredthTen + hundredthOne;
	}
	static m_matF_x_vectorF(matrix,v) {
		let m = matrix.clone();
		m.transpose();
		let v0 = v.x;
		let v1 = v.y;
		let v2 = v.z;
		let vresult_0 = m._11 * v0 + m._12 * v1 + m._13 * v2;
		let vresult_1 = m._21 * v0 + m._22 * v1 + m._23 * v2;
		let vresult_2 = m._31 * v0 + m._23 * v1 + m._33 * v2;
		let x = vresult_0;
		let y = vresult_1;
		let z = vresult_2;
		if(vresult_2 == null) {
			z = 0.;
		}
		if(vresult_1 == null) {
			y = 0.;
		}
		if(vresult_0 == null) {
			x = 0.;
		}
		v.x = x;
		v.y = y;
		v.z = z;
		v.w = 1.;
	}
	static isTouchDevice() {
		let _g = src_Settings.isTouch;
		switch(_g._hx_index) {
		case 0:
			let val = _g.v;
			return val;
		case 1:
			let reg = new EReg("iPad|iPhone|iPod","gm");
			let t1 = reg.match($global.navigator.userAgent);
			let tmp;
			if(!t1) {
				let reg2 = new EReg("Mac","gm");
				tmp = reg2.match($global.navigator.userAgent) && $global.navigator.maxTouchPoints != null && $global.navigator.maxTouchPoints > 2;
			} else {
				tmp = true;
			}
			if(tmp) {
				src_Settings.isTouch = haxe_ds_Option.Some(true);
				return true;
			}
			src_Settings.isTouch = haxe_ds_Option.Some(Object.keys(window).includes("ontouchstart"));
			return Object.keys(window).includes("ontouchstart");
		}
	}
	static isIOSInstancingSupported() {
		if(src_Util.isIOSInstancingSupported__supported != null) {
			return src_Util.isIOSInstancingSupported__supported;
		}
		let reg = new EReg("iPad|iPhone|iPod","gm");
		let t1 = reg.match($global.navigator.userAgent);
		let tmp;
		if(!t1) {
			let reg2 = new EReg("Mac","gm");
			tmp = reg2.match($global.navigator.userAgent) && $global.navigator.maxTouchPoints != null && $global.navigator.maxTouchPoints > 2;
		} else {
			tmp = true;
		}
		if(tmp) {
			let reg = new EReg("OS (\\d+)_(\\d+)_?(\\d+)?","");
			if(reg.match($global.navigator.userAgent)) {
				let mainVer = Std.parseInt(reg.matched(1));
				if(mainVer < 17) {
					src_Util.isIOSInstancingSupported__supported = false;
					return false;
				} else {
					src_Util.isIOSInstancingSupported__supported = true;
					return true;
				}
			} else {
				src_Util.isIOSInstancingSupported__supported = false;
				return false;
			}
		} else {
			src_Util.isIOSInstancingSupported__supported = true;
			return true;
		}
	}
}
$hxClasses["src.Util"] = src_Util;
src_Util.__name__ = "src.Util";
class stb_format_tools_Crc32 {
	static init() {
		if(stb_format_tools_Crc32.table != null) {
			return;
		}
		stb_format_tools_Crc32.table = new Array(256);
		let _g = 0;
		while(_g < 256) {
			let i = _g++;
			let s = i << 24;
			s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
			s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
			s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
			s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
			s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
			s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
			s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
			s = s << 1 ^ (UInt.gte(s,1 << 31) ? 79764919 : 0);
			stb_format_tools_Crc32.table[i] = s;
		}
	}
}
$hxClasses["stb.format.tools.Crc32"] = stb_format_tools_Crc32;
stb_format_tools_Crc32.__name__ = "stb.format.tools.Crc32";
class stb_format_vorbis_Reader {
	constructor(input,seekFunc,inputLength) {
		this.seekFunc = seekFunc;
		this.inputLength = inputLength;
		this.decoder = stb_format_vorbis_VorbisDecoder.start(input);
		this.decoder.setupSampleNumber(seekFunc,inputLength);
		this.loopStart = this.get_header().comment.get_loopStart();
		this.loopLength = this.get_header().comment.get_loopLength();
	}
	get_header() {
		return this.decoder.header;
	}
	get_totalSample() {
		return this.decoder.totalSample;
	}
	set_currentSample(value) {
		this.decoder.seek(this.seekFunc,this.inputLength,value);
		return this.decoder.currentSample;
	}
	read(output,samples,channels,sampleRate,useFloat) {
		if(useFloat == null) {
			useFloat = false;
		}
		this.decoder.ensurePosition(this.seekFunc);
		if(samples == null) {
			samples = this.decoder.totalSample;
		}
		if(channels == null) {
			channels = this.get_header().channel;
		}
		if(sampleRate == null) {
			sampleRate = this.get_header().sampleRate;
		}
		return this.decoder.read(output,samples,channels,sampleRate,useFloat);
	}
	static openFromBytes(bytes) {
		let input = new haxe_io_BytesInput(bytes);
		let bytes1 = input;
		return new stb_format_vorbis_Reader(input,function(pos) {
			stb_format_vorbis_Reader.seekBytes(bytes1,pos);
		},bytes.length);
	}
	static seekBytes(bytes,pos) {
		bytes.set_position(pos);
	}
}
$hxClasses["stb.format.vorbis.Reader"] = stb_format_vorbis_Reader;
stb_format_vorbis_Reader.__name__ = "stb.format.vorbis.Reader";
Object.assign(stb_format_vorbis_Reader.prototype, {
	__class__: stb_format_vorbis_Reader
	,decoder: null
	,loopStart: null
	,loopLength: null
	,seekFunc: null
	,inputLength: null
});
class stb_format_vorbis_VorbisDecodeState {
	constructor(input) {
		this.nextSeg = 0;
		this.firstDecode = false;
		this.bytesInSeg = 0;
		this.validBits = 0;
		this.input = input;
		this.inputPosition = 0;
		this.page = new stb_format_vorbis_data_Page();
		stb_format_tools_Crc32.init();
	}
	setup(loc0,loc1) {
		this.inputPosition += 1;
		let segmentCount = this.input.readByte();
		this.inputPosition += segmentCount;
		let vec = new Array(segmentCount);
		let _g = 0;
		while(_g < segmentCount) {
			let i = _g++;
			vec[i] = this.input.readByte();
		}
		this.segments = vec;
		this.endSegWithKnownLoc = -2;
		if(loc0 != -1 || loc1 != -1) {
			let i = segmentCount - 1;
			while(i >= 0) {
				if(this.segments[i] < 255) {
					break;
				}
				if(i >= 0) {
					this.endSegWithKnownLoc = i;
					this.knownLocForPacket = loc0;
				}
				--i;
			}
		}
		if(this.firstDecode) {
			let len = 0;
			let p = new stb_format_vorbis_data_ProbedPage();
			let _g = 0;
			while(_g < segmentCount) {
				let i = _g++;
				len += this.segments[i];
			}
			len += 27 + segmentCount;
			p.pageStart = this.firstAudioPageOffset;
			p.pageEnd = p.pageStart + len;
			p.firstDecodedSample = 0;
			p.lastDecodedSample = loc0;
			this.pFirst = p;
		}
		this.nextSeg = 0;
	}
	clone(seekFunc) {
		let state = Object.create(stb_format_vorbis_VorbisDecodeState.prototype);
		seekFunc(this.inputPosition);
		state.input = this.input;
		state.eof = this.eof;
		state.validBits = this.validBits;
		state.discardSamplesDeferred = this.discardSamplesDeferred;
		state.firstDecode = this.firstDecode;
		state.nextSeg = this.nextSeg;
		state.bytesInSeg = this.bytesInSeg;
		state.acc = state.acc;
		state.lastSeg = this.lastSeg;
		state.lastSegWhich = this.lastSegWhich;
		state.currentLoc = this.currentLoc;
		state.currentLocValid = this.currentLocValid;
		state.inputPosition = this.inputPosition;
		state.firstAudioPageOffset = this.firstAudioPageOffset;
		state.error = this.error;
		state.segments = this.segments;
		state.pFirst = this.pFirst;
		state.pLast = this.pLast;
		state.page = this.page.clone();
		return state;
	}
	next() {
		if(this.lastSeg) {
			return 0;
		}
		if(this.nextSeg == -1) {
			this.lastSegWhich = this.segments.length - 1;
			try {
				this.page.start(this);
			} catch( _g ) {
				let _g1 = haxe_Exception.caught(_g).unwrap();
				if(((_g1) instanceof stb_format_vorbis_data_ReaderError)) {
					let e = _g1;
					this.lastSeg = true;
					this.error = e;
					return 0;
				} else {
					throw _g;
				}
			}
			if((this.page.flag & 1) == 0) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.CONTINUED_PACKET_FLAG_INVALID,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 171, className : "stb.format.vorbis.VorbisDecodeState", methodName : "next"}));
			}
		}
		let len = this.segments[this.nextSeg++];
		if(len < 255) {
			this.lastSeg = true;
			this.lastSegWhich = this.nextSeg - 1;
		}
		if(this.nextSeg >= this.segments.length) {
			this.nextSeg = -1;
		}
		if(this.bytesInSeg != 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.OTHER,"",{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 184, className : "stb.format.vorbis.VorbisDecodeState", methodName : "next"}));
		}
		this.bytesInSeg = len;
		return len;
	}
	startPacket() {
		while(this.nextSeg == -1) {
			this.page.start(this);
			if((this.page.flag & 1) != 0) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 193, className : "stb.format.vorbis.VorbisDecodeState", methodName : "startPacket"}));
			}
		}
		this.lastSeg = false;
		this.validBits = 0;
		this.bytesInSeg = 0;
	}
	maybeStartPacket() {
		if(this.nextSeg == -1) {
			let eof = false;
			let x;
			try {
				this.inputPosition += 1;
				x = this.input.readByte();
			} catch( _g ) {
				if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
					eof = true;
					x = 0;
				} else {
					throw _g;
				}
			}
			if(eof) {
				return false;
			}
			let tmp;
			let tmp1;
			let tmp2;
			if(x == 79) {
				this.inputPosition += 1;
				tmp2 = this.input.readByte() != 103;
			} else {
				tmp2 = true;
			}
			if(!tmp2) {
				this.inputPosition += 1;
				tmp1 = this.input.readByte() != 103;
			} else {
				tmp1 = true;
			}
			if(!tmp1) {
				this.inputPosition += 1;
				tmp = this.input.readByte() != 83;
			} else {
				tmp = true;
			}
			if(tmp) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 218, className : "stb.format.vorbis.VorbisDecodeState", methodName : "maybeStartPacket"}));
			}
			this.page.startWithoutCapturePattern(this);
		}
		this.startPacket();
		return true;
	}
	readBits(n) {
		if(this.validBits < 0) {
			return 0;
		} else if(this.validBits < n) {
			if(n > 24) {
				return this.readBits(24) + (this.readBits(n - 24) << 24);
			} else {
				if(this.validBits == 0) {
					this.acc = 0;
				}
				do if(this.bytesInSeg == 0 && (this.lastSeg || this.next() == 0)) {
					this.validBits = -1;
					break;
				} else {
					this.bytesInSeg--;
					this.inputPosition += 1;
					this.acc = this.acc + (this.input.readByte() << this.validBits);
					this.validBits += 8;
				} while(this.validBits < n);
				if(this.validBits < 0) {
					return 0;
				} else {
					let z = this.acc & (1 << n) - 1;
					this.acc = this.acc >>> n;
					this.validBits -= n;
					return z;
				}
			}
		} else {
			let z = this.acc & (1 << n) - 1;
			this.acc = this.acc >>> n;
			this.validBits -= n;
			return z;
		}
	}
	firstPageValidate() {
		if(this.segments.length != 1) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"segmentCount",{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 307, className : "stb.format.vorbis.VorbisDecodeState", methodName : "firstPageValidate"}));
		}
		if(this.segments[0] != 30) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"decodeState head",{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 310, className : "stb.format.vorbis.VorbisDecodeState", methodName : "firstPageValidate"}));
		}
	}
	startFirstDecode() {
		this.firstAudioPageOffset = this.inputPosition;
		this.firstDecode = true;
	}
	prepHuffman() {
		if(this.validBits <= 24) {
			if(this.validBits == 0) {
				this.acc = 0;
			}
			do if(this.bytesInSeg == 0 && (this.lastSeg || this.next() == 0)) {
				return;
			} else {
				this.bytesInSeg--;
				this.inputPosition += 1;
				this.acc = this.acc + (this.input.readByte() << this.validBits);
				this.validBits += 8;
			} while(this.validBits <= 24);
		}
	}
	finishDecodePacket(previousLength,n,r) {
		let left = r.left.start;
		let currentLocValid = false;
		let n2 = n >> 1;
		if(this.firstDecode) {
			this.currentLoc = -n2;
			this.discardSamplesDeferred = n - r.right.end;
			currentLocValid = true;
			this.firstDecode = false;
		} else if(this.discardSamplesDeferred != 0) {
			r.left.start += this.discardSamplesDeferred;
			left = r.left.start;
			this.discardSamplesDeferred = 0;
		}
		if(this.lastSegWhich == this.endSegWithKnownLoc) {
			if(currentLocValid && (this.page.flag & 4) != 0) {
				let currentEnd = this.knownLocForPacket - (n - r.right.end);
				if(currentEnd < this.currentLoc + r.right.end) {
					let len = currentEnd < this.currentLoc ? 0 : currentEnd - this.currentLoc;
					len += r.left.start;
					this.currentLoc += len;
					return { len : len, left : left, right : r.right.start};
				}
			}
			this.currentLoc = this.knownLocForPacket - (n2 - r.left.start);
			currentLocValid = true;
		}
		if(currentLocValid) {
			this.currentLoc += r.right.start - r.left.start;
		}
		return { len : r.right.end, left : left, right : r.right.start};
	}
	getSampleNumber(seekFunc,inputLength) {
		let restoreOffset = this.inputPosition;
		let previousSafe = UInt.gte(inputLength,65536) && UInt.gte(inputLength - 65536,this.firstAudioPageOffset) ? inputLength - 65536 : this.firstAudioPageOffset;
		seekFunc(this.inputPosition = previousSafe);
		let end = 0;
		let last = false;
		let _g = this.findPage(seekFunc,inputLength);
		switch(_g._hx_index) {
		case 0:
			end = _g.end;
			last = _g.last;
			break;
		case 1:
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 518, className : "stb.format.vorbis.VorbisDecodeState", methodName : "getSampleNumber"}));
		}
		let lastPageLoc = this.inputPosition;
		_hx_loop1: while(!last) {
			seekFunc(this.inputPosition = end);
			let _g = this.findPage(seekFunc,inputLength);
			switch(_g._hx_index) {
			case 0:
				end = _g.end;
				last = _g.last;
				break;
			case 1:
				break _hx_loop1;
			}
			previousSafe = lastPageLoc + 1;
			lastPageLoc = this.inputPosition;
		}
		seekFunc(this.inputPosition = lastPageLoc);
		this.inputPosition += 6;
		let vec = new Array(6);
		let _g1 = 0;
		while(_g1 < 6) {
			let i = _g1++;
			vec[i] = this.input.readByte();
		}
		this.inputPosition += 4;
		let lo = this.input.readInt32();
		this.inputPosition += 4;
		let hi = this.input.readInt32();
		if(lo == -1 && hi == -1 || hi > 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 552, className : "stb.format.vorbis.VorbisDecodeState", methodName : "getSampleNumber"}));
		}
		this.pLast = new stb_format_vorbis_data_ProbedPage();
		this.pLast.pageStart = lastPageLoc;
		this.pLast.pageEnd = end;
		this.pLast.lastDecodedSample = lo;
		this.pLast.firstDecodedSample = null;
		this.pLast.afterPreviousPageStart = previousSafe;
		seekFunc(this.inputPosition = restoreOffset);
		return lo;
	}
	findPage(seekFunc,inputLength) {
		try {
			while(true) {
				this.inputPosition += 1;
				let n = this.input.readByte();
				if(n == 79) {
					let retryLoc = this.inputPosition;
					if(retryLoc - 25 > inputLength) {
						return stb_format_vorbis__$VorbisDecodeState_FindPageResult.NotFound;
					}
					let tmp;
					let tmp1;
					this.inputPosition += 1;
					if(this.input.readByte() == 103) {
						this.inputPosition += 1;
						tmp1 = this.input.readByte() != 103;
					} else {
						tmp1 = true;
					}
					if(!tmp1) {
						this.inputPosition += 1;
						tmp = this.input.readByte() != 83;
					} else {
						tmp = true;
					}
					if(tmp) {
						continue;
					}
					let header = new Array(27);
					header[0] = 79;
					header[1] = 103;
					header[2] = 103;
					header[3] = 83;
					this.inputPosition += 1;
					header[4] = this.input.readByte();
					this.inputPosition += 1;
					header[5] = this.input.readByte();
					this.inputPosition += 1;
					header[6] = this.input.readByte();
					this.inputPosition += 1;
					header[7] = this.input.readByte();
					this.inputPosition += 1;
					header[8] = this.input.readByte();
					this.inputPosition += 1;
					header[9] = this.input.readByte();
					this.inputPosition += 1;
					header[10] = this.input.readByte();
					this.inputPosition += 1;
					header[11] = this.input.readByte();
					this.inputPosition += 1;
					header[12] = this.input.readByte();
					this.inputPosition += 1;
					header[13] = this.input.readByte();
					this.inputPosition += 1;
					header[14] = this.input.readByte();
					this.inputPosition += 1;
					header[15] = this.input.readByte();
					this.inputPosition += 1;
					header[16] = this.input.readByte();
					this.inputPosition += 1;
					header[17] = this.input.readByte();
					this.inputPosition += 1;
					header[18] = this.input.readByte();
					this.inputPosition += 1;
					header[19] = this.input.readByte();
					this.inputPosition += 1;
					header[20] = this.input.readByte();
					this.inputPosition += 1;
					header[21] = this.input.readByte();
					this.inputPosition += 1;
					header[22] = this.input.readByte();
					this.inputPosition += 1;
					header[23] = this.input.readByte();
					this.inputPosition += 1;
					header[24] = this.input.readByte();
					this.inputPosition += 1;
					header[25] = this.input.readByte();
					this.inputPosition += 1;
					header[26] = this.input.readByte();
					if(header[4] != 0) {
						seekFunc(this.inputPosition = retryLoc);
						continue;
					}
					let goal = header[22] + (header[23] << 8) + (header[24] << 16) + (header[25] << 24);
					header[22] = 0;
					header[23] = 0;
					header[24] = 0;
					header[25] = 0;
					let crc = 0;
					let _g = 0;
					while(_g < 27) {
						let i = _g++;
						crc = crc << 8 ^ stb_format_tools_Crc32.table[header[i] ^ crc >>> 24];
					}
					let len = 0;
					try {
						let _g = 0;
						let _g1 = header[26];
						while(_g < _g1) {
							++_g;
							this.inputPosition += 1;
							let s = this.input.readByte();
							crc = crc << 8 ^ stb_format_tools_Crc32.table[s ^ crc >>> 24];
							len += s;
						}
						let _g2 = 0;
						let _g3 = len;
						while(_g2 < _g3) {
							++_g2;
							this.inputPosition += 1;
							let byte = this.input.readByte();
							crc = crc << 8 ^ stb_format_tools_Crc32.table[byte ^ crc >>> 24];
						}
					} catch( _g ) {
						if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
							return stb_format_vorbis__$VorbisDecodeState_FindPageResult.NotFound;
						} else {
							throw _g;
						}
					}
					if(crc == goal) {
						let end = this.inputPosition;
						seekFunc(this.inputPosition = retryLoc - 1);
						return stb_format_vorbis__$VorbisDecodeState_FindPageResult.Found(end,(header[5] & 4) != 0);
					}
				}
			}
		} catch( _g ) {
			if(((haxe_Exception.caught(_g).unwrap()) instanceof haxe_io_Eof)) {
				return stb_format_vorbis__$VorbisDecodeState_FindPageResult.NotFound;
			} else {
				throw _g;
			}
		}
	}
	analyzePage(seekFunc,h) {
		let z = new stb_format_vorbis_data_ProbedPage();
		let packetType = new Array(255);
		z.pageStart = this.inputPosition;
		this.inputPosition += 27;
		let vec = new Array(27);
		let _g = 0;
		while(_g < 27) {
			let i = _g++;
			vec[i] = this.input.readByte();
		}
		if(!(vec[0] == 79 && vec[1] == 103 && vec[2] == 103 && vec[3] == 83)) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.OTHER,"",{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 660, className : "stb.format.vorbis.VorbisDecodeState", methodName : "analyzePage"}));
		}
		let n = vec[26];
		this.inputPosition += n;
		let vec1 = new Array(n);
		let _g1 = 0;
		while(_g1 < n) {
			let i = _g1++;
			vec1[i] = this.input.readByte();
		}
		let len = 0;
		let _g2 = 0;
		let _g3 = vec[26];
		while(_g2 < _g3) {
			let i = _g2++;
			len += vec1[i];
		}
		z.pageEnd = z.pageStart + 27 + vec[26] + len;
		z.lastDecodedSample = vec[6] + (vec[7] << 8) + (vec[8] << 16) + (vec[9] << 16);
		if((vec[5] & 4) != 0) {
			z.firstDecodedSample = null;
			seekFunc(this.inputPosition = z.pageStart);
			return z;
		}
		let numPacket = 0;
		let packetStart = (vec[5] & 1) == 0;
		let modeCount = h.modes.length;
		let _g4 = 0;
		let _g5 = vec[26];
		while(_g4 < _g5) {
			let i = _g4++;
			if(packetStart) {
				if(vec1[i] == 0) {
					seekFunc(this.inputPosition = z.pageStart);
					return null;
				}
				this.inputPosition += 1;
				let n = this.input.readByte();
				if((n & 1) != 0) {
					seekFunc(this.inputPosition = z.pageStart);
					return null;
				}
				n >>= 1;
				let n1 = modeCount - 1;
				let log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
				let b = n1 < 16384 ? n1 < 16 ? log2_4[n1] : n1 < 512 ? 5 + log2_4[n1 >> 5] : 10 + log2_4[n1 >> 10] : n1 < 16777216 ? n1 < 524288 ? 15 + log2_4[n1 >> 15] : 20 + log2_4[n1 >> 20] : n1 < 536870912 ? 25 + log2_4[n1 >> 25] : n1 < -2147483648 ? 30 + log2_4[n1 >> 30] : 0;
				n &= (1 << b) - 1;
				if(n >= modeCount) {
					seekFunc(this.inputPosition = z.pageStart);
					return null;
				}
				packetType[numPacket++] = h.modes[n].blockflag;
				let len = vec1[i] - 1;
				this.inputPosition += len;
				let vec = new Array(len);
				let _g = 0;
				while(_g < len) {
					let i = _g++;
					vec[i] = this.input.readByte();
				}
			} else {
				let len = vec1[i];
				this.inputPosition += len;
				let vec = new Array(len);
				let _g = 0;
				while(_g < len) {
					let i = _g++;
					vec[i] = this.input.readByte();
				}
			}
			packetStart = vec1[i] < 255;
		}
		let samples = 0;
		if(numPacket > 1) {
			samples = packetType[numPacket - 1] ? h.blocksize1 : h.blocksize0;
		}
		let i = numPacket - 2;
		while(i >= 1) {
			--i;
			if(packetType[i]) {
				if(packetType[i + 1]) {
					samples += h.blocksize1 >> 1;
				} else {
					samples += (h.blocksize1 - h.blocksize0 >> 2) + (h.blocksize0 >> 1);
				}
			} else {
				samples += h.blocksize0 >> 1;
			}
			--i;
		}
		z.firstDecodedSample = z.lastDecodedSample - samples;
		seekFunc(this.inputPosition = z.pageStart);
		return z;
	}
	decodeScalarRaw(c) {
		this.prepHuffman();
		if(!(c.sortedCodewords != null || c.codewords != null)) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.OTHER,"",{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 787, className : "stb.format.vorbis.VorbisDecodeState", methodName : "decodeScalarRaw"}));
		}
		let codewordLengths = c.codewordLengths;
		let codewords = c.codewords;
		let sortedCodewords = c.sortedCodewords;
		if(c.entries > 8 ? sortedCodewords != null : codewords != null) {
			let n = this.acc;
			n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
			n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
			n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
			n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
			let code = n >>> 16 | n << 16;
			let x = 0;
			let n1 = c.sortedEntries;
			while(n1 > 1) {
				let m = x + (n1 >> 1);
				if(UInt.gte(code,sortedCodewords[m])) {
					x = m;
					n1 -= n1 >> 1;
				} else {
					n1 >>= 1;
				}
			}
			if(!c.sparse) {
				x = c.sortedValues[x];
			}
			let len = codewordLengths[x];
			if(this.validBits >= len) {
				this.acc = this.acc >>> len;
				this.validBits -= len;
				return x;
			}
			this.validBits = 0;
			return -1;
		}
		if(c.sparse) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.OTHER,"",{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 829, className : "stb.format.vorbis.VorbisDecodeState", methodName : "decodeScalarRaw"}));
		}
		let _g = 0;
		let _g1 = c.entries;
		while(_g < _g1) {
			let i = _g++;
			let cl = codewordLengths[i];
			if(cl == 255) {
				continue;
			}
			if(codewords[i] == (this.acc & (1 << cl) - 1)) {
				if(this.validBits >= cl) {
					this.acc = this.acc >>> cl;
					this.validBits -= cl;
					return i;
				}
				this.validBits = 0;
				return -1;
			}
		}
		this.error = new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 846, className : "stb.format.vorbis.VorbisDecodeState", methodName : "decodeScalarRaw"});
		this.validBits = 0;
		return -1;
	}
}
$hxClasses["stb.format.vorbis.VorbisDecodeState"] = stb_format_vorbis_VorbisDecodeState;
stb_format_vorbis_VorbisDecodeState.__name__ = "stb.format.vorbis.VorbisDecodeState";
Object.assign(stb_format_vorbis_VorbisDecodeState.prototype, {
	__class__: stb_format_vorbis_VorbisDecodeState
	,page: null
	,eof: null
	,pFirst: null
	,pLast: null
	,validBits: null
	,inputPosition: null
	,input: null
	,discardSamplesDeferred: null
	,segments: null
	,bytesInSeg: null
	,firstDecode: null
	,nextSeg: null
	,acc: null
	,lastSeg: null
	,lastSegWhich: null
	,endSegWithKnownLoc: null
	,knownLocForPacket: null
	,error: null
	,currentLoc: null
	,currentLocValid: null
	,firstAudioPageOffset: null
});
var stb_format_vorbis__$VorbisDecodeState_FindPageResult = $hxEnums["stb.format.vorbis._VorbisDecodeState.FindPageResult"] = { __ename__:true,__constructs__:null
	,Found: ($_=function(end,last) { return {_hx_index:0,end:end,last:last,__enum__:"stb.format.vorbis._VorbisDecodeState.FindPageResult",toString:$estr}; },$_._hx_name="Found",$_.__params__ = ["end","last"],$_)
	,NotFound: {_hx_name:"NotFound",_hx_index:1,__enum__:"stb.format.vorbis._VorbisDecodeState.FindPageResult",toString:$estr}
};
stb_format_vorbis__$VorbisDecodeState_FindPageResult.__constructs__ = [stb_format_vorbis__$VorbisDecodeState_FindPageResult.Found,stb_format_vorbis__$VorbisDecodeState_FindPageResult.NotFound];
stb_format_vorbis__$VorbisDecodeState_FindPageResult.__empty_constructs__ = [stb_format_vorbis__$VorbisDecodeState_FindPageResult.NotFound];
class stb_format_vorbis_VorbisDecoder {
	constructor(header,decodeState) {
		this.header = header;
		this.decodeState = decodeState;
		this.totalSample = null;
		this.currentSample = 0;
		this.previousLength = 0;
		this.channelBuffers = new Array(header.channel);
		this.previousWindow = new Array(header.channel);
		this.finalY = new Array(header.channel);
		let _g = 0;
		let _g1 = header.channel;
		while(_g < _g1) {
			let i = _g++;
			let this1 = this.channelBuffers;
			let vec = new Array(header.blocksize1);
			this1[i] = vec;
			let this2 = this.previousWindow;
			let vec1 = new Array(header.blocksize1 / 2 | 0);
			this2[i] = vec1;
			this.finalY[i] = [];
		}
		this.a = new Array(2);
		this.b = new Array(2);
		this.c = new Array(2);
		this.window = new Array(2);
		this.bitReverseData = new Array(2);
		this.initBlocksize(0,header.blocksize0);
		this.initBlocksize(1,header.blocksize1);
	}
	read(output,samples,channels,sampleRate,useFloat) {
		if((UInt.toFloat(sampleRate) % UInt.toFloat(this.header.sampleRate) | 0) != 0) {
			throw haxe_Exception.thrown("Unsupported sampleRate : can't convert " + (this.header.sampleRate == null ? "null" : Std.string(UInt.toFloat(this.header.sampleRate))) + " to " + sampleRate);
		}
		if(channels % this.header.channel != 0) {
			throw haxe_Exception.thrown("Unsupported channels : can't convert " + this.header.channel + " to " + channels);
		}
		let sampleRepeat = UInt.toFloat(sampleRate) / UInt.toFloat(this.header.sampleRate) | 0;
		let channelRepeat = channels / this.header.channel | 0;
		let n = 0;
		let len = Math.floor(samples / sampleRepeat);
		if(this.totalSample != null && len > this.totalSample - this.currentSample) {
			len = this.totalSample - this.currentSample;
		}
		while(n < len) {
			let k = this.channelBufferEnd - this.channelBufferStart;
			if(k >= len - n) {
				k = len - n;
			}
			let _g = this.channelBufferStart;
			let _g1 = this.channelBufferStart + k;
			while(_g < _g1) {
				let j = _g++;
				let _g1 = 0;
				while(_g1 < sampleRepeat) {
					++_g1;
					let _g = 0;
					let _g2 = this.header.channel;
					while(_g < _g2) {
						let i = _g++;
						let _g1 = 0;
						while(_g1 < channelRepeat) {
							++_g1;
							let value = this.channelBuffers[i][j];
							if(value > 1) {
								value = 1;
							} else if(value < -1) {
								value = -1;
							}
							if(useFloat) {
								output.writeFloat(value);
							} else {
								output.writeInt16(Math.floor(value * 32767));
							}
						}
					}
				}
			}
			n += k;
			this.channelBufferStart += k;
			if(n == len || this.getFrameFloat() == 0) {
				break;
			}
		}
		let _g = n;
		let _g1 = len;
		while(_g < _g1) {
			++_g;
			let _g1 = 0;
			while(_g1 < sampleRepeat) {
				++_g1;
				let _g = 0;
				let _g2 = this.header.channel;
				while(_g < _g2) {
					++_g;
					let _g1 = 0;
					while(_g1 < channelRepeat) {
						++_g1;
						if(useFloat) {
							output.writeFloat(0);
						} else {
							output.writeInt16(0);
						}
					}
				}
			}
		}
		this.currentSample += len;
		return len * sampleRepeat;
	}
	skipSamples(len) {
		let n = 0;
		if(this.totalSample != null && len > this.totalSample - this.currentSample) {
			len = this.totalSample - this.currentSample;
		}
		while(n < len) {
			let k = this.channelBufferEnd - this.channelBufferStart;
			if(k >= len - n) {
				k = len - n;
			}
			n += k;
			this.channelBufferStart += k;
			if(n == len || this.getFrameFloat() == 0) {
				break;
			}
		}
		this.currentSample += len;
		return len;
	}
	setupSampleNumber(seekFunc,inputLength) {
		if(this.totalSample == null) {
			this.totalSample = this.decodeState.getSampleNumber(seekFunc,inputLength);
		}
	}
	seek(seekFunc,inputLength,sampleNumber) {
		if(this.currentSample == sampleNumber) {
			return;
		}
		if(this.totalSample == null) {
			this.setupSampleNumber(seekFunc,inputLength);
			if(this.totalSample == 0) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 182, className : "stb.format.vorbis.VorbisDecoder", methodName : "seek"}));
			}
		}
		if(sampleNumber < 0) {
			sampleNumber = 0;
		}
		let p0 = this.decodeState.pFirst;
		let p1 = this.decodeState.pLast;
		if(sampleNumber >= p1.lastDecodedSample) {
			sampleNumber = p1.lastDecodedSample - 1;
		}
		if(sampleNumber < p0.lastDecodedSample) {
			this.seekFrameFromPage(seekFunc,p0.pageStart,0,sampleNumber);
		} else {
			let attempts = 0;
			while(p0.pageEnd < p1.pageStart) {
				let startOffset = p0.pageEnd;
				let endOffset = p1.afterPreviousPageStart;
				let startSample = p0.lastDecodedSample;
				let endSample = p1.lastDecodedSample;
				if(startSample == null || endSample == null) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 214, className : "stb.format.vorbis.VorbisDecoder", methodName : "seek"}));
				}
				if(UInt.gt(endOffset,startOffset + 4000)) {
					endOffset = endOffset - 4000;
				}
				let probe = startOffset + Math.floor(UInt.toFloat(endOffset - startOffset) / UInt.toFloat(endSample - startSample) * (sampleNumber - startSample));
				if(attempts >= 4) {
					let probe2 = startOffset + (endOffset - startOffset >>> 1);
					probe = attempts >= 8 ? probe2 : UInt.gt(probe2,probe) ? probe + (probe2 - probe >>> 1) : probe2 + (probe - probe2 >>> 1);
				}
				++attempts;
				seekFunc(this.decodeState.inputPosition = probe);
				switch(this.decodeState.findPage(seekFunc,inputLength)._hx_index) {
				case 0:
					break;
				case 1:
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 244, className : "stb.format.vorbis.VorbisDecoder", methodName : "seek"}));
				}
				let q = this.decodeState.analyzePage(seekFunc,this.header);
				if(q == null) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 250, className : "stb.format.vorbis.VorbisDecoder", methodName : "seek"}));
				}
				q.afterPreviousPageStart = probe;
				if(q.pageStart == p1.pageStart) {
					p1 = q;
					continue;
				}
				if(sampleNumber < q.lastDecodedSample) {
					p1 = q;
				} else {
					p0 = q;
				}
			}
			if(p0.lastDecodedSample <= sampleNumber && sampleNumber < p1.lastDecodedSample) {
				this.seekFrameFromPage(seekFunc,p1.pageStart,p0.lastDecodedSample,sampleNumber);
			} else {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 270, className : "stb.format.vorbis.VorbisDecoder", methodName : "seek"}));
			}
		}
	}
	seekFrameFromPage(seekFunc,pageStart,firstSample,targetSample) {
		let frame = 0;
		let frameStart = firstSample;
		seekFunc(this.decodeState.inputPosition = pageStart);
		this.decodeState.nextSeg = -1;
		let leftEnd = 0;
		let leftStart = 0;
		let prevState = null;
		let lastState = null;
		while(true) {
			prevState = lastState;
			lastState = this.decodeState.clone(seekFunc);
			let initialResult = this.decodeInitial();
			if(initialResult == null) {
				lastState = prevState;
				break;
			}
			leftStart = initialResult.left.start;
			leftEnd = initialResult.left.end;
			let start = frame == 0 ? leftEnd : leftStart;
			if(targetSample < frameStart + initialResult.right.start - start) {
				break;
			}
			let _this = this.decodeState;
			while(_this.bytesInSeg != 0 || !_this.lastSeg && _this.next() != 0) {
				_this.bytesInSeg--;
				_this.inputPosition += 1;
				_this.input.readByte();
			}
			frameStart += initialResult.right.start - start;
			++frame;
		}
		this.decodeState = lastState;
		seekFunc(this.decodeState.inputPosition);
		this.previousLength = 0;
		this.pumpFirstFrame();
		this.currentSample = frameStart;
		this.skipSamples(targetSample - frameStart);
	}
	ensurePosition(seekFunc) {
		seekFunc(this.decodeState.inputPosition);
	}
	getFrameFloat() {
		let result = this.decodePacket();
		if(result == null) {
			this.channelBufferStart = this.channelBufferEnd = 0;
			return 0;
		}
		let len = this.finishFrame(result);
		this.channelBufferStart = result.left;
		this.channelBufferEnd = result.left + len;
		return len;
	}
	pumpFirstFrame() {
		this.finishFrame(this.decodePacket());
	}
	finishFrame(r) {
		let len = r.len;
		let right = r.right;
		let left = r.left;
		if(this.previousLength != 0) {
			let n = this.previousLength;
			let w = this.getWindow(n);
			let _g = 0;
			let _g1 = this.header.channel;
			while(_g < _g1) {
				let i = _g++;
				let cb = this.channelBuffers[i];
				let pw = this.previousWindow[i];
				let _g1 = 0;
				while(_g1 < n) {
					let j = _g1++;
					cb[left + j] = cb[left + j] * w[j] + pw[j] * w[n - 1 - j];
				}
			}
		}
		let prev = this.previousLength;
		this.previousLength = len - right;
		let _g = 0;
		let _g1 = this.header.channel;
		while(_g < _g1) {
			let i = _g++;
			let pw = this.previousWindow[i];
			let cb = this.channelBuffers[i];
			let _g1 = 0;
			let _g2 = len - right;
			while(_g1 < _g2) {
				let j = _g1++;
				pw[j] = cb[right + j];
			}
		}
		if(prev == 0) {
			return 0;
		}
		if(len < right) {
			right = len;
		}
		return right - left;
	}
	getWindow(len) {
		len <<= 1;
		if(len == this.header.blocksize0) {
			return this.window[0];
		} else if(len == this.header.blocksize1) {
			return this.window[1];
		} else {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.OTHER,"",{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 461, className : "stb.format.vorbis.VorbisDecoder", methodName : "getWindow"}));
		}
	}
	initBlocksize(bs,n) {
		let n2 = n >> 1;
		let n4 = n >> 2;
		let n8 = n >> 3;
		this.a[bs] = new Array(n2);
		this.b[bs] = new Array(n2);
		this.c[bs] = new Array(n4);
		this.window[bs] = new Array(n2);
		this.bitReverseData[bs] = new Array(n8);
		stb_format_vorbis_VorbisTools.computeTwiddleFactors(n,this.a[bs],this.b[bs],this.c[bs]);
		stb_format_vorbis_VorbisTools.computeWindow(n,this.window[bs]);
		stb_format_vorbis_VorbisTools.computeBitReverse(n,this.bitReverseData[bs]);
	}
	inverseMdct(buffer,n,blocktype) {
		let bt = blocktype ? 1 : 0;
		let a = this.a[bt];
		let b = this.b[bt];
		let c = this.c[bt];
		let bitReverse = this.bitReverseData[bt];
		let n2 = n >> 1;
		let n4 = n >> 2;
		let n8 = n >> 3;
		let buf2 = new Array(n2);
		let dOffset = n2 - 2;
		let aaOffset = 0;
		let eOffset = 0;
		while(eOffset != n2) {
			buf2[dOffset + 1] = buffer[eOffset] * a[aaOffset] - buffer[eOffset + 2] * a[aaOffset + 1];
			buf2[dOffset] = buffer[eOffset] * a[aaOffset + 1] + buffer[eOffset + 2] * a[aaOffset];
			dOffset -= 2;
			aaOffset += 2;
			eOffset += 4;
		}
		eOffset = n2 - 3;
		while(dOffset >= 0) {
			buf2[dOffset + 1] = -buffer[eOffset + 2] * a[aaOffset] - -buffer[eOffset] * a[aaOffset + 1];
			buf2[dOffset] = -buffer[eOffset + 2] * a[aaOffset + 1] + -buffer[eOffset] * a[aaOffset];
			dOffset -= 2;
			aaOffset += 2;
			eOffset -= 4;
		}
		let aaOffset1 = n2 - 8;
		let eOffset0 = n4;
		let eOffset1 = 0;
		let dOffset0 = n4;
		let dOffset1 = 0;
		while(aaOffset1 >= 0) {
			let v41_21 = buf2[eOffset0 + 1] - buf2[eOffset1 + 1];
			let v40_20 = buf2[eOffset0] - buf2[eOffset1];
			buffer[dOffset0 + 1] = buf2[eOffset0 + 1] + buf2[eOffset1 + 1];
			buffer[dOffset0] = buf2[eOffset0] + buf2[eOffset1];
			buffer[dOffset1 + 1] = v41_21 * a[aaOffset1 + 4] - v40_20 * a[aaOffset1 + 5];
			buffer[dOffset1] = v40_20 * a[aaOffset1 + 4] + v41_21 * a[aaOffset1 + 5];
			v41_21 = buf2[eOffset0 + 3] - buf2[eOffset1 + 3];
			v40_20 = buf2[eOffset0 + 2] - buf2[eOffset1 + 2];
			buffer[dOffset0 + 3] = buf2[eOffset0 + 3] + buf2[eOffset1 + 3];
			buffer[dOffset0 + 2] = buf2[eOffset0 + 2] + buf2[eOffset1 + 2];
			buffer[dOffset1 + 3] = v41_21 * a[aaOffset1] - v40_20 * a[aaOffset1 + 1];
			buffer[dOffset1 + 2] = v40_20 * a[aaOffset1] + v41_21 * a[aaOffset1 + 1];
			aaOffset1 -= 8;
			dOffset0 += 4;
			dOffset1 += 4;
			eOffset0 += 4;
			eOffset1 += 4;
		}
		let log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
		let ld = (n < 16384 ? n < 16 ? log2_4[n] : n < 512 ? 5 + log2_4[n >> 5] : 10 + log2_4[n >> 10] : n < 16777216 ? n < 524288 ? 15 + log2_4[n >> 15] : 20 + log2_4[n >> 20] : n < 536870912 ? 25 + log2_4[n >> 25] : n < -2147483648 ? 30 + log2_4[n >> 30] : 0) - 1;
		let i_off = n2 - 1 - n4 * 0;
		let eeOffset0 = i_off;
		let eeOffset2 = i_off + -(n >> 3);
		let aOffset = 0;
		let i = (n >> 4 >> 2) + 1;
		while(--i > 0) {
			let k00_20 = buffer[eeOffset0] - buffer[eeOffset2];
			let k01_21 = buffer[eeOffset0 + (-1)] - buffer[eeOffset2 + (-1)];
			buffer[eeOffset0] += buffer[eeOffset2];
			buffer[eeOffset0 + (-1)] += buffer[eeOffset2 + (-1)];
			buffer[eeOffset2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			buffer[eeOffset2 + (-1)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			k00_20 = buffer[eeOffset0 + (-2)] - buffer[eeOffset2 + (-2)];
			k01_21 = buffer[eeOffset0 + (-3)] - buffer[eeOffset2 + (-3)];
			buffer[eeOffset0 + (-2)] += buffer[eeOffset2 + (-2)];
			buffer[eeOffset0 + (-3)] += buffer[eeOffset2 + (-3)];
			buffer[eeOffset2 + (-2)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			buffer[eeOffset2 + (-3)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			k00_20 = buffer[eeOffset0 + (-4)] - buffer[eeOffset2 + (-4)];
			k01_21 = buffer[eeOffset0 + (-5)] - buffer[eeOffset2 + (-5)];
			buffer[eeOffset0 + (-4)] += buffer[eeOffset2 + (-4)];
			buffer[eeOffset0 + (-5)] += buffer[eeOffset2 + (-5)];
			buffer[eeOffset2 + (-4)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			buffer[eeOffset2 + (-5)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			k00_20 = buffer[eeOffset0 + (-6)] - buffer[eeOffset2 + (-6)];
			k01_21 = buffer[eeOffset0 + (-7)] - buffer[eeOffset2 + (-7)];
			buffer[eeOffset0 + (-6)] += buffer[eeOffset2 + (-6)];
			buffer[eeOffset0 + (-7)] += buffer[eeOffset2 + (-7)];
			buffer[eeOffset2 + (-6)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
			buffer[eeOffset2 + (-7)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
			aOffset += 8;
			eeOffset0 -= 8;
			eeOffset2 -= 8;
		}
		let i_off1 = n2 - 1 - n4;
		let eeOffset01 = i_off1;
		let eeOffset21 = i_off1 + -(n >> 3);
		let aOffset1 = 0;
		let i1 = (n >> 4 >> 2) + 1;
		while(--i1 > 0) {
			let k00_20 = buffer[eeOffset01] - buffer[eeOffset21];
			let k01_21 = buffer[eeOffset01 + (-1)] - buffer[eeOffset21 + (-1)];
			buffer[eeOffset01] += buffer[eeOffset21];
			buffer[eeOffset01 + (-1)] += buffer[eeOffset21 + (-1)];
			buffer[eeOffset21] = k00_20 * a[aOffset1] - k01_21 * a[aOffset1 + 1];
			buffer[eeOffset21 + (-1)] = k01_21 * a[aOffset1] + k00_20 * a[aOffset1 + 1];
			aOffset1 += 8;
			k00_20 = buffer[eeOffset01 + (-2)] - buffer[eeOffset21 + (-2)];
			k01_21 = buffer[eeOffset01 + (-3)] - buffer[eeOffset21 + (-3)];
			buffer[eeOffset01 + (-2)] += buffer[eeOffset21 + (-2)];
			buffer[eeOffset01 + (-3)] += buffer[eeOffset21 + (-3)];
			buffer[eeOffset21 + (-2)] = k00_20 * a[aOffset1] - k01_21 * a[aOffset1 + 1];
			buffer[eeOffset21 + (-3)] = k01_21 * a[aOffset1] + k00_20 * a[aOffset1 + 1];
			aOffset1 += 8;
			k00_20 = buffer[eeOffset01 + (-4)] - buffer[eeOffset21 + (-4)];
			k01_21 = buffer[eeOffset01 + (-5)] - buffer[eeOffset21 + (-5)];
			buffer[eeOffset01 + (-4)] += buffer[eeOffset21 + (-4)];
			buffer[eeOffset01 + (-5)] += buffer[eeOffset21 + (-5)];
			buffer[eeOffset21 + (-4)] = k00_20 * a[aOffset1] - k01_21 * a[aOffset1 + 1];
			buffer[eeOffset21 + (-5)] = k01_21 * a[aOffset1] + k00_20 * a[aOffset1 + 1];
			aOffset1 += 8;
			k00_20 = buffer[eeOffset01 + (-6)] - buffer[eeOffset21 + (-6)];
			k01_21 = buffer[eeOffset01 + (-7)] - buffer[eeOffset21 + (-7)];
			buffer[eeOffset01 + (-6)] += buffer[eeOffset21 + (-6)];
			buffer[eeOffset01 + (-7)] += buffer[eeOffset21 + (-7)];
			buffer[eeOffset21 + (-6)] = k00_20 * a[aOffset1] - k01_21 * a[aOffset1 + 1];
			buffer[eeOffset21 + (-7)] = k01_21 * a[aOffset1] + k00_20 * a[aOffset1 + 1];
			aOffset1 += 8;
			eeOffset01 -= 8;
			eeOffset21 -= 8;
		}
		let d0 = n2 - 1 - n8 * 0;
		let aOffset2 = 0;
		let eOffset01 = d0;
		let eOffset2 = d0 + -(n >> 4);
		let i2 = (n >> 5 >> 2) + 1;
		while(--i2 > 0) {
			let k00_20 = buffer[eOffset01] - buffer[eOffset2];
			let k01_21 = buffer[eOffset01 + (-1)] - buffer[eOffset2 + (-1)];
			buffer[eOffset01] += buffer[eOffset2];
			buffer[eOffset01 + (-1)] += buffer[eOffset2 + (-1)];
			buffer[eOffset2] = k00_20 * a[aOffset2] - k01_21 * a[aOffset2 + 1];
			buffer[eOffset2 + (-1)] = k01_21 * a[aOffset2] + k00_20 * a[aOffset2 + 1];
			aOffset2 += 16;
			k00_20 = buffer[eOffset01 + (-2)] - buffer[eOffset2 + (-2)];
			k01_21 = buffer[eOffset01 + (-3)] - buffer[eOffset2 + (-3)];
			buffer[eOffset01 + (-2)] += buffer[eOffset2 + (-2)];
			buffer[eOffset01 + (-3)] += buffer[eOffset2 + (-3)];
			buffer[eOffset2 + (-2)] = k00_20 * a[aOffset2] - k01_21 * a[aOffset2 + 1];
			buffer[eOffset2 + (-3)] = k01_21 * a[aOffset2] + k00_20 * a[aOffset2 + 1];
			aOffset2 += 16;
			k00_20 = buffer[eOffset01 + (-4)] - buffer[eOffset2 + (-4)];
			k01_21 = buffer[eOffset01 + (-5)] - buffer[eOffset2 + (-5)];
			buffer[eOffset01 + (-4)] += buffer[eOffset2 + (-4)];
			buffer[eOffset01 + (-5)] += buffer[eOffset2 + (-5)];
			buffer[eOffset2 + (-4)] = k00_20 * a[aOffset2] - k01_21 * a[aOffset2 + 1];
			buffer[eOffset2 + (-5)] = k01_21 * a[aOffset2] + k00_20 * a[aOffset2 + 1];
			aOffset2 += 16;
			k00_20 = buffer[eOffset01 + (-6)] - buffer[eOffset2 + (-6)];
			k01_21 = buffer[eOffset01 + (-7)] - buffer[eOffset2 + (-7)];
			buffer[eOffset01 + (-6)] += buffer[eOffset2 + (-6)];
			buffer[eOffset01 + (-7)] += buffer[eOffset2 + (-7)];
			buffer[eOffset2 + (-6)] = k00_20 * a[aOffset2] - k01_21 * a[aOffset2 + 1];
			buffer[eOffset2 + (-7)] = k01_21 * a[aOffset2] + k00_20 * a[aOffset2 + 1];
			eOffset01 -= 8;
			eOffset2 -= 8;
			aOffset2 += 16;
		}
		let d01 = n2 - 1 - n8;
		let aOffset3 = 0;
		let eOffset02 = d01;
		let eOffset21 = d01 + -(n >> 4);
		let i3 = (n >> 5 >> 2) + 1;
		while(--i3 > 0) {
			let k00_20 = buffer[eOffset02] - buffer[eOffset21];
			let k01_21 = buffer[eOffset02 + (-1)] - buffer[eOffset21 + (-1)];
			buffer[eOffset02] += buffer[eOffset21];
			buffer[eOffset02 + (-1)] += buffer[eOffset21 + (-1)];
			buffer[eOffset21] = k00_20 * a[aOffset3] - k01_21 * a[aOffset3 + 1];
			buffer[eOffset21 + (-1)] = k01_21 * a[aOffset3] + k00_20 * a[aOffset3 + 1];
			aOffset3 += 16;
			k00_20 = buffer[eOffset02 + (-2)] - buffer[eOffset21 + (-2)];
			k01_21 = buffer[eOffset02 + (-3)] - buffer[eOffset21 + (-3)];
			buffer[eOffset02 + (-2)] += buffer[eOffset21 + (-2)];
			buffer[eOffset02 + (-3)] += buffer[eOffset21 + (-3)];
			buffer[eOffset21 + (-2)] = k00_20 * a[aOffset3] - k01_21 * a[aOffset3 + 1];
			buffer[eOffset21 + (-3)] = k01_21 * a[aOffset3] + k00_20 * a[aOffset3 + 1];
			aOffset3 += 16;
			k00_20 = buffer[eOffset02 + (-4)] - buffer[eOffset21 + (-4)];
			k01_21 = buffer[eOffset02 + (-5)] - buffer[eOffset21 + (-5)];
			buffer[eOffset02 + (-4)] += buffer[eOffset21 + (-4)];
			buffer[eOffset02 + (-5)] += buffer[eOffset21 + (-5)];
			buffer[eOffset21 + (-4)] = k00_20 * a[aOffset3] - k01_21 * a[aOffset3 + 1];
			buffer[eOffset21 + (-5)] = k01_21 * a[aOffset3] + k00_20 * a[aOffset3 + 1];
			aOffset3 += 16;
			k00_20 = buffer[eOffset02 + (-6)] - buffer[eOffset21 + (-6)];
			k01_21 = buffer[eOffset02 + (-7)] - buffer[eOffset21 + (-7)];
			buffer[eOffset02 + (-6)] += buffer[eOffset21 + (-6)];
			buffer[eOffset02 + (-7)] += buffer[eOffset21 + (-7)];
			buffer[eOffset21 + (-6)] = k00_20 * a[aOffset3] - k01_21 * a[aOffset3 + 1];
			buffer[eOffset21 + (-7)] = k01_21 * a[aOffset3] + k00_20 * a[aOffset3 + 1];
			eOffset02 -= 8;
			eOffset21 -= 8;
			aOffset3 += 16;
		}
		let d02 = n2 - 1 - n8 * 2;
		let aOffset4 = 0;
		let eOffset03 = d02;
		let eOffset22 = d02 + -(n >> 4);
		let i4 = (n >> 5 >> 2) + 1;
		while(--i4 > 0) {
			let k00_20 = buffer[eOffset03] - buffer[eOffset22];
			let k01_21 = buffer[eOffset03 + (-1)] - buffer[eOffset22 + (-1)];
			buffer[eOffset03] += buffer[eOffset22];
			buffer[eOffset03 + (-1)] += buffer[eOffset22 + (-1)];
			buffer[eOffset22] = k00_20 * a[aOffset4] - k01_21 * a[aOffset4 + 1];
			buffer[eOffset22 + (-1)] = k01_21 * a[aOffset4] + k00_20 * a[aOffset4 + 1];
			aOffset4 += 16;
			k00_20 = buffer[eOffset03 + (-2)] - buffer[eOffset22 + (-2)];
			k01_21 = buffer[eOffset03 + (-3)] - buffer[eOffset22 + (-3)];
			buffer[eOffset03 + (-2)] += buffer[eOffset22 + (-2)];
			buffer[eOffset03 + (-3)] += buffer[eOffset22 + (-3)];
			buffer[eOffset22 + (-2)] = k00_20 * a[aOffset4] - k01_21 * a[aOffset4 + 1];
			buffer[eOffset22 + (-3)] = k01_21 * a[aOffset4] + k00_20 * a[aOffset4 + 1];
			aOffset4 += 16;
			k00_20 = buffer[eOffset03 + (-4)] - buffer[eOffset22 + (-4)];
			k01_21 = buffer[eOffset03 + (-5)] - buffer[eOffset22 + (-5)];
			buffer[eOffset03 + (-4)] += buffer[eOffset22 + (-4)];
			buffer[eOffset03 + (-5)] += buffer[eOffset22 + (-5)];
			buffer[eOffset22 + (-4)] = k00_20 * a[aOffset4] - k01_21 * a[aOffset4 + 1];
			buffer[eOffset22 + (-5)] = k01_21 * a[aOffset4] + k00_20 * a[aOffset4 + 1];
			aOffset4 += 16;
			k00_20 = buffer[eOffset03 + (-6)] - buffer[eOffset22 + (-6)];
			k01_21 = buffer[eOffset03 + (-7)] - buffer[eOffset22 + (-7)];
			buffer[eOffset03 + (-6)] += buffer[eOffset22 + (-6)];
			buffer[eOffset03 + (-7)] += buffer[eOffset22 + (-7)];
			buffer[eOffset22 + (-6)] = k00_20 * a[aOffset4] - k01_21 * a[aOffset4 + 1];
			buffer[eOffset22 + (-7)] = k01_21 * a[aOffset4] + k00_20 * a[aOffset4 + 1];
			eOffset03 -= 8;
			eOffset22 -= 8;
			aOffset4 += 16;
		}
		let d03 = n2 - 1 - n8 * 3;
		let aOffset5 = 0;
		let eOffset04 = d03;
		let eOffset23 = d03 + -(n >> 4);
		let i5 = (n >> 5 >> 2) + 1;
		while(--i5 > 0) {
			let k00_20 = buffer[eOffset04] - buffer[eOffset23];
			let k01_21 = buffer[eOffset04 + (-1)] - buffer[eOffset23 + (-1)];
			buffer[eOffset04] += buffer[eOffset23];
			buffer[eOffset04 + (-1)] += buffer[eOffset23 + (-1)];
			buffer[eOffset23] = k00_20 * a[aOffset5] - k01_21 * a[aOffset5 + 1];
			buffer[eOffset23 + (-1)] = k01_21 * a[aOffset5] + k00_20 * a[aOffset5 + 1];
			aOffset5 += 16;
			k00_20 = buffer[eOffset04 + (-2)] - buffer[eOffset23 + (-2)];
			k01_21 = buffer[eOffset04 + (-3)] - buffer[eOffset23 + (-3)];
			buffer[eOffset04 + (-2)] += buffer[eOffset23 + (-2)];
			buffer[eOffset04 + (-3)] += buffer[eOffset23 + (-3)];
			buffer[eOffset23 + (-2)] = k00_20 * a[aOffset5] - k01_21 * a[aOffset5 + 1];
			buffer[eOffset23 + (-3)] = k01_21 * a[aOffset5] + k00_20 * a[aOffset5 + 1];
			aOffset5 += 16;
			k00_20 = buffer[eOffset04 + (-4)] - buffer[eOffset23 + (-4)];
			k01_21 = buffer[eOffset04 + (-5)] - buffer[eOffset23 + (-5)];
			buffer[eOffset04 + (-4)] += buffer[eOffset23 + (-4)];
			buffer[eOffset04 + (-5)] += buffer[eOffset23 + (-5)];
			buffer[eOffset23 + (-4)] = k00_20 * a[aOffset5] - k01_21 * a[aOffset5 + 1];
			buffer[eOffset23 + (-5)] = k01_21 * a[aOffset5] + k00_20 * a[aOffset5 + 1];
			aOffset5 += 16;
			k00_20 = buffer[eOffset04 + (-6)] - buffer[eOffset23 + (-6)];
			k01_21 = buffer[eOffset04 + (-7)] - buffer[eOffset23 + (-7)];
			buffer[eOffset04 + (-6)] += buffer[eOffset23 + (-6)];
			buffer[eOffset04 + (-7)] += buffer[eOffset23 + (-7)];
			buffer[eOffset23 + (-6)] = k00_20 * a[aOffset5] - k01_21 * a[aOffset5 + 1];
			buffer[eOffset23 + (-7)] = k01_21 * a[aOffset5] + k00_20 * a[aOffset5 + 1];
			eOffset04 -= 8;
			eOffset23 -= 8;
			aOffset5 += 16;
		}
		let _g = 2;
		let _g1 = ld - 3 >> 1;
		while(_g < _g1) {
			let l = _g++;
			let k0 = n >> l + 2;
			let k0_2 = k0 >> 1;
			let lim = 1 << l + 1;
			let _g1 = 0;
			while(_g1 < lim) {
				let i = _g1++;
				let d0 = n2 - 1 - k0 * i;
				let k1 = 1 << l + 3;
				let aOffset = 0;
				let eOffset0 = d0;
				let eOffset2 = d0 + -k0_2;
				let i1 = (n >> l + 4 >> 2) + 1;
				while(--i1 > 0) {
					let k00_20 = buffer[eOffset0] - buffer[eOffset2];
					let k01_21 = buffer[eOffset0 + (-1)] - buffer[eOffset2 + (-1)];
					buffer[eOffset0] += buffer[eOffset2];
					buffer[eOffset0 + (-1)] += buffer[eOffset2 + (-1)];
					buffer[eOffset2] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
					buffer[eOffset2 + (-1)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
					aOffset += k1;
					k00_20 = buffer[eOffset0 + (-2)] - buffer[eOffset2 + (-2)];
					k01_21 = buffer[eOffset0 + (-3)] - buffer[eOffset2 + (-3)];
					buffer[eOffset0 + (-2)] += buffer[eOffset2 + (-2)];
					buffer[eOffset0 + (-3)] += buffer[eOffset2 + (-3)];
					buffer[eOffset2 + (-2)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
					buffer[eOffset2 + (-3)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
					aOffset += k1;
					k00_20 = buffer[eOffset0 + (-4)] - buffer[eOffset2 + (-4)];
					k01_21 = buffer[eOffset0 + (-5)] - buffer[eOffset2 + (-5)];
					buffer[eOffset0 + (-4)] += buffer[eOffset2 + (-4)];
					buffer[eOffset0 + (-5)] += buffer[eOffset2 + (-5)];
					buffer[eOffset2 + (-4)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
					buffer[eOffset2 + (-5)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
					aOffset += k1;
					k00_20 = buffer[eOffset0 + (-6)] - buffer[eOffset2 + (-6)];
					k01_21 = buffer[eOffset0 + (-7)] - buffer[eOffset2 + (-7)];
					buffer[eOffset0 + (-6)] += buffer[eOffset2 + (-6)];
					buffer[eOffset0 + (-7)] += buffer[eOffset2 + (-7)];
					buffer[eOffset2 + (-6)] = k00_20 * a[aOffset] - k01_21 * a[aOffset + 1];
					buffer[eOffset2 + (-7)] = k01_21 * a[aOffset] + k00_20 * a[aOffset + 1];
					eOffset0 -= 8;
					eOffset2 -= 8;
					aOffset += k1;
				}
			}
		}
		let _g2 = ld - 3 >> 1;
		let _g3 = ld - 6;
		while(_g2 < _g3) {
			let l = _g2++;
			let k0 = n >> l + 2;
			let k1 = 1 << l + 3;
			let k0_2 = k0 >> 1;
			let rlim = n >> l + 6;
			let lim = 1 << l + 1;
			let aOffset = 0;
			let i_off = n2 - 1;
			let r = rlim + 1;
			while(--r > 0) {
				let A0 = a[aOffset];
				let A1 = a[aOffset + 1];
				let A2 = a[aOffset + k1];
				let A3 = a[aOffset + k1 + 1];
				let A4 = a[aOffset + k1 * 2];
				let A5 = a[aOffset + k1 * 2 + 1];
				let A6 = a[aOffset + k1 * 3];
				let A7 = a[aOffset + k1 * 3 + 1];
				let eeOffset0 = i_off;
				let eeOffset2 = i_off + -k0_2;
				let i = lim + 1;
				while(--i > 0) {
					let k00 = buffer[eeOffset0] - buffer[eeOffset2];
					let k11 = buffer[eeOffset0 + (-1)] - buffer[eeOffset2 + (-1)];
					buffer[eeOffset0] += buffer[eeOffset2];
					buffer[eeOffset0 + (-1)] += buffer[eeOffset2 + (-1)];
					buffer[eeOffset2] = k00 * A0 - k11 * A1;
					buffer[eeOffset2 + (-1)] = k11 * A0 + k00 * A1;
					k00 = buffer[eeOffset0 + (-2)] - buffer[eeOffset2 + (-2)];
					k11 = buffer[eeOffset0 + (-3)] - buffer[eeOffset2 + (-3)];
					buffer[eeOffset0 + (-2)] += buffer[eeOffset2 + (-2)];
					buffer[eeOffset0 + (-3)] += buffer[eeOffset2 + (-3)];
					buffer[eeOffset2 + (-2)] = k00 * A2 - k11 * A3;
					buffer[eeOffset2 + (-3)] = k11 * A2 + k00 * A3;
					k00 = buffer[eeOffset0 + (-4)] - buffer[eeOffset2 + (-4)];
					k11 = buffer[eeOffset0 + (-5)] - buffer[eeOffset2 + (-5)];
					buffer[eeOffset0 + (-4)] += buffer[eeOffset2 + (-4)];
					buffer[eeOffset0 + (-5)] += buffer[eeOffset2 + (-5)];
					buffer[eeOffset2 + (-4)] = k00 * A4 - k11 * A5;
					buffer[eeOffset2 + (-5)] = k11 * A4 + k00 * A5;
					k00 = buffer[eeOffset0 + (-6)] - buffer[eeOffset2 + (-6)];
					k11 = buffer[eeOffset0 + (-7)] - buffer[eeOffset2 + (-7)];
					buffer[eeOffset0 + (-6)] += buffer[eeOffset2 + (-6)];
					buffer[eeOffset0 + (-7)] += buffer[eeOffset2 + (-7)];
					buffer[eeOffset2 + (-6)] = k00 * A6 - k11 * A7;
					buffer[eeOffset2 + (-7)] = k11 * A6 + k00 * A7;
					eeOffset0 -= k0;
					eeOffset2 -= k0;
				}
				aOffset += k1 * 4;
				i_off -= 8;
			}
		}
		let i_off2 = n2 - 1;
		let A2 = a[n >> 3];
		let zOffset = i_off2;
		let baseOffset = i_off2 - 16 * (n >> 5);
		while(zOffset > baseOffset) {
			let t0 = buffer[zOffset];
			let t1 = buffer[zOffset + (-8)];
			buffer[zOffset + (-8)] = t0 - t1;
			buffer[zOffset] = t0 + t1;
			t0 = buffer[zOffset + (-1)];
			t1 = buffer[zOffset + (-9)];
			buffer[zOffset + (-9)] = t0 - t1;
			buffer[zOffset + (-1)] = t0 + t1;
			t0 = buffer[zOffset + (-2)];
			t1 = buffer[zOffset + (-10)];
			let k00 = t0 - t1;
			buffer[zOffset + (-2)] = t0 + t1;
			t0 = buffer[zOffset + (-3)];
			t1 = buffer[zOffset + (-11)];
			let k11 = t0 - t1;
			buffer[zOffset + (-3)] = t0 + t1;
			buffer[zOffset + (-10)] = (k00 + k11) * A2;
			buffer[zOffset + (-11)] = (k11 - k00) * A2;
			t0 = buffer[zOffset + (-4)];
			t1 = buffer[zOffset + (-12)];
			k00 = t1 - t0;
			buffer[zOffset + (-4)] = t0 + t1;
			t0 = buffer[zOffset + (-5)];
			t1 = buffer[zOffset + (-13)];
			k11 = t0 - t1;
			buffer[zOffset + (-5)] = t0 + t1;
			buffer[zOffset + (-12)] = k11;
			buffer[zOffset + (-13)] = k00;
			t0 = buffer[zOffset + (-6)];
			t1 = buffer[zOffset + (-14)];
			k00 = t1 - t0;
			buffer[zOffset + (-6)] = t0 + t1;
			t0 = buffer[zOffset + (-7)];
			t1 = buffer[zOffset + (-15)];
			k11 = t0 - t1;
			buffer[zOffset + (-7)] = t0 + t1;
			buffer[zOffset + (-14)] = (k00 + k11) * A2;
			buffer[zOffset + (-15)] = (k00 - k11) * A2;
			let t01 = buffer[zOffset];
			let t11 = buffer[zOffset + (-4)];
			let k001 = t01 - t11;
			let y0 = t01 + t11;
			t01 = buffer[zOffset + (-2)];
			t11 = buffer[zOffset + (-6)];
			let y2 = t01 + t11;
			let k22 = t01 - t11;
			buffer[zOffset] = y0 + y2;
			buffer[zOffset + (-2)] = y0 - y2;
			let k33 = buffer[zOffset + (-3)] - buffer[zOffset + (-7)];
			buffer[zOffset + (-4)] = k001 + k33;
			buffer[zOffset + (-6)] = k001 - k33;
			t01 = buffer[zOffset + (-1)];
			t11 = buffer[zOffset + (-5)];
			let k111 = t01 - t11;
			let y1 = t01 + t11;
			let y3 = buffer[zOffset + (-3)] + buffer[zOffset + (-7)];
			buffer[zOffset + (-1)] = y1 + y3;
			buffer[zOffset + (-3)] = y1 - y3;
			buffer[zOffset + (-5)] = k111 - k22;
			buffer[zOffset + (-7)] = k111 + k22;
			let zOffset1 = zOffset - 8;
			let t02 = buffer[zOffset1];
			let t12 = buffer[zOffset1 + (-4)];
			let k002 = t02 - t12;
			let y01 = t02 + t12;
			t02 = buffer[zOffset1 + (-2)];
			t12 = buffer[zOffset1 + (-6)];
			let y21 = t02 + t12;
			let k221 = t02 - t12;
			buffer[zOffset1] = y01 + y21;
			buffer[zOffset1 + (-2)] = y01 - y21;
			let k331 = buffer[zOffset1 + (-3)] - buffer[zOffset1 + (-7)];
			buffer[zOffset1 + (-4)] = k002 + k331;
			buffer[zOffset1 + (-6)] = k002 - k331;
			t02 = buffer[zOffset1 + (-1)];
			t12 = buffer[zOffset1 + (-5)];
			let k112 = t02 - t12;
			let y11 = t02 + t12;
			let y31 = buffer[zOffset1 + (-3)] + buffer[zOffset1 + (-7)];
			buffer[zOffset1 + (-1)] = y11 + y31;
			buffer[zOffset1 + (-3)] = y11 - y31;
			buffer[zOffset1 + (-5)] = k112 - k221;
			buffer[zOffset1 + (-7)] = k112 + k221;
			zOffset -= 16;
		}
		let brOffset = 0;
		let dOffset01 = n4 - 4;
		let dOffset11 = n2 - 4;
		while(dOffset01 >= 0) {
			let k4 = bitReverse[brOffset];
			buf2[dOffset11 + 3] = buffer[k4];
			buf2[dOffset11 + 2] = buffer[k4 + 1];
			buf2[dOffset01 + 3] = buffer[k4 + 2];
			buf2[dOffset01 + 2] = buffer[k4 + 3];
			k4 = bitReverse[brOffset + 1];
			buf2[dOffset11 + 1] = buffer[k4];
			buf2[dOffset11] = buffer[k4 + 1];
			buf2[dOffset01 + 1] = buffer[k4 + 2];
			buf2[dOffset01] = buffer[k4 + 3];
			dOffset01 -= 4;
			dOffset11 -= 4;
			brOffset += 2;
		}
		let cOffset = 0;
		let dOffset2 = 0;
		let eOffset3 = n2 - 4;
		while(dOffset2 < eOffset3) {
			let a02 = buf2[dOffset2] - buf2[eOffset3 + 2];
			let a11 = buf2[dOffset2 + 1] + buf2[eOffset3 + 3];
			let b0 = c[cOffset + 1] * a02 + c[cOffset] * a11;
			let b1 = c[cOffset + 1] * a11 - c[cOffset] * a02;
			let b2 = buf2[dOffset2] + buf2[eOffset3 + 2];
			let b3 = buf2[dOffset2 + 1] - buf2[eOffset3 + 3];
			buf2[dOffset2] = b2 + b0;
			buf2[dOffset2 + 1] = b3 + b1;
			buf2[eOffset3 + 2] = b2 - b0;
			buf2[eOffset3 + 3] = b1 - b3;
			a02 = buf2[dOffset2 + 2] - buf2[eOffset3];
			a11 = buf2[dOffset2 + 3] + buf2[eOffset3 + 1];
			b0 = c[cOffset + 3] * a02 + c[cOffset + 2] * a11;
			b1 = c[cOffset + 3] * a11 - c[cOffset + 2] * a02;
			b2 = buf2[dOffset2 + 2] + buf2[eOffset3];
			b3 = buf2[dOffset2 + 3] - buf2[eOffset3 + 1];
			buf2[dOffset2 + 2] = b2 + b0;
			buf2[dOffset2 + 3] = b3 + b1;
			buf2[eOffset3] = b2 - b0;
			buf2[eOffset3 + 1] = b1 - b3;
			cOffset += 4;
			dOffset2 += 4;
			eOffset3 -= 4;
		}
		let bOffset = n2 - 8;
		let eOffset4 = n2 - 8;
		let dOffset02 = 0;
		let dOffset12 = n2 - 4;
		let dOffset21 = n2;
		let dOffset3 = n - 4;
		while(eOffset4 >= 0) {
			let p3 = buf2[eOffset4 + 6] * b[bOffset + 7] - buf2[eOffset4 + 7] * b[bOffset + 6];
			let p2 = -buf2[eOffset4 + 6] * b[bOffset + 6] - buf2[eOffset4 + 7] * b[bOffset + 7];
			buffer[dOffset02] = p3;
			buffer[dOffset12 + 3] = -p3;
			buffer[dOffset21] = p2;
			buffer[dOffset3 + 3] = p2;
			let p1 = buf2[eOffset4 + 4] * b[bOffset + 5] - buf2[eOffset4 + 5] * b[bOffset + 4];
			let p0 = -buf2[eOffset4 + 4] * b[bOffset + 4] - buf2[eOffset4 + 5] * b[bOffset + 5];
			buffer[dOffset02 + 1] = p1;
			buffer[dOffset12 + 2] = -p1;
			buffer[dOffset21 + 1] = p0;
			buffer[dOffset3 + 2] = p0;
			p3 = buf2[eOffset4 + 2] * b[bOffset + 3] - buf2[eOffset4 + 3] * b[bOffset + 2];
			p2 = -buf2[eOffset4 + 2] * b[bOffset + 2] - buf2[eOffset4 + 3] * b[bOffset + 3];
			buffer[dOffset02 + 2] = p3;
			buffer[dOffset12 + 1] = -p3;
			buffer[dOffset21 + 2] = p2;
			buffer[dOffset3 + 1] = p2;
			p1 = buf2[eOffset4] * b[bOffset + 1] - buf2[eOffset4 + 1] * b[bOffset];
			p0 = -buf2[eOffset4] * b[bOffset] - buf2[eOffset4 + 1] * b[bOffset + 1];
			buffer[dOffset02 + 3] = p1;
			buffer[dOffset12] = -p1;
			buffer[dOffset21 + 3] = p0;
			buffer[dOffset3] = p0;
			bOffset -= 8;
			eOffset4 -= 8;
			dOffset02 += 4;
			dOffset21 += 4;
			dOffset12 -= 4;
			dOffset3 -= 4;
		}
	}
	decodePacket() {
		let result = this.decodeInitial();
		if(result == null) {
			return null;
		}
		let rest = this.decodePacketRest(result);
		return rest;
	}
	decodeInitial() {
		this.channelBufferStart = this.channelBufferEnd = 0;
		while(true) {
			if(!this.decodeState.maybeStartPacket()) {
				return null;
			}
			let _this = this.decodeState;
			let tmp;
			if(_this.validBits < 0) {
				tmp = 0;
			} else if(_this.validBits < 1) {
				if(_this.validBits == 0) {
					_this.acc = 0;
				}
				do if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
					_this.validBits = -1;
					break;
				} else {
					_this.bytesInSeg--;
					_this.inputPosition += 1;
					_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
					_this.validBits += 8;
				} while(_this.validBits < 1);
				if(_this.validBits < 0) {
					tmp = 0;
				} else {
					let z = _this.acc & 1;
					_this.acc = _this.acc >>> 1;
					_this.validBits -= 1;
					tmp = z;
				}
			} else {
				let z = _this.acc & 1;
				_this.acc = _this.acc >>> 1;
				_this.validBits -= 1;
				tmp = z;
			}
			if(tmp != 0) {
				while(true) {
					let _this = this.decodeState;
					let x;
					if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
						x = -1;
					} else {
						_this.bytesInSeg--;
						_this.inputPosition += 1;
						x = _this.input.readByte();
					}
					_this.validBits = 0;
					if(!(-1 != x)) {
						break;
					}
				}
				continue;
			}
			break;
		}
		let _this = this.decodeState;
		let n = this.header.modes.length - 1;
		let log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
		let n1 = n < 16384 ? n < 16 ? log2_4[n] : n < 512 ? 5 + log2_4[n >> 5] : 10 + log2_4[n >> 10] : n < 16777216 ? n < 524288 ? 15 + log2_4[n >> 15] : 20 + log2_4[n >> 20] : n < 536870912 ? 25 + log2_4[n >> 25] : n < -2147483648 ? 30 + log2_4[n >> 30] : 0;
		let i;
		if(_this.validBits < 0) {
			i = 0;
		} else if(_this.validBits < n1) {
			if(n1 > 24) {
				let i1;
				if(_this.validBits < 0) {
					i1 = 0;
				} else if(_this.validBits < 24) {
					if(_this.validBits == 0) {
						_this.acc = 0;
					}
					do if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
						_this.validBits = -1;
						break;
					} else {
						_this.bytesInSeg--;
						_this.inputPosition += 1;
						_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
						_this.validBits += 8;
					} while(_this.validBits < 24);
					if(_this.validBits < 0) {
						i1 = 0;
					} else {
						let z = _this.acc & 16777215;
						_this.acc = _this.acc >>> 24;
						_this.validBits -= 24;
						i1 = z;
					}
				} else {
					let z = _this.acc & 16777215;
					_this.acc = _this.acc >>> 24;
					_this.validBits -= 24;
					i1 = z;
				}
				let n = n1 - 24;
				let i2;
				if(_this.validBits < 0) {
					i2 = 0;
				} else if(_this.validBits < n) {
					if(n > 24) {
						i2 = _this.readBits(24) + (_this.readBits(n - 24) << 24);
					} else {
						if(_this.validBits == 0) {
							_this.acc = 0;
						}
						do if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
							_this.validBits = -1;
							break;
						} else {
							_this.bytesInSeg--;
							_this.inputPosition += 1;
							_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
							_this.validBits += 8;
						} while(_this.validBits < n);
						if(_this.validBits < 0) {
							i2 = 0;
						} else {
							let z = _this.acc & (1 << n) - 1;
							_this.acc = _this.acc >>> n;
							_this.validBits -= n;
							i2 = z;
						}
					}
				} else {
					let z = _this.acc & (1 << n) - 1;
					_this.acc = _this.acc >>> n;
					_this.validBits -= n;
					i2 = z;
				}
				i = i1 + (i2 << 24);
			} else {
				if(_this.validBits == 0) {
					_this.acc = 0;
				}
				do if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
					_this.validBits = -1;
					break;
				} else {
					_this.bytesInSeg--;
					_this.inputPosition += 1;
					_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
					_this.validBits += 8;
				} while(_this.validBits < n1);
				if(_this.validBits < 0) {
					i = 0;
				} else {
					let z = _this.acc & (1 << n1) - 1;
					_this.acc = _this.acc >>> n1;
					_this.validBits -= n1;
					i = z;
				}
			}
		} else {
			let z = _this.acc & (1 << n1) - 1;
			_this.acc = _this.acc >>> n1;
			_this.validBits -= n1;
			i = z;
		}
		if(i == -1 || i >= this.header.modes.length) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 514, className : "stb.format.vorbis.VorbisDecoder", methodName : "decodeInitial"}));
		}
		let m = this.header.modes[i];
		let n2;
		let prev;
		let next;
		if(m.blockflag) {
			n2 = this.header.blocksize1;
			let _this = this.decodeState;
			if(_this.validBits < 0) {
				prev = 0;
			} else if(_this.validBits < 1) {
				if(_this.validBits == 0) {
					_this.acc = 0;
				}
				do if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
					_this.validBits = -1;
					break;
				} else {
					_this.bytesInSeg--;
					_this.inputPosition += 1;
					_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
					_this.validBits += 8;
				} while(_this.validBits < 1);
				if(_this.validBits < 0) {
					prev = 0;
				} else {
					let z = _this.acc & 1;
					_this.acc = _this.acc >>> 1;
					_this.validBits -= 1;
					prev = z;
				}
			} else {
				let z = _this.acc & 1;
				_this.acc = _this.acc >>> 1;
				_this.validBits -= 1;
				prev = z;
			}
			let _this1 = this.decodeState;
			if(_this1.validBits < 0) {
				next = 0;
			} else if(_this1.validBits < 1) {
				if(_this1.validBits == 0) {
					_this1.acc = 0;
				}
				do if(_this1.bytesInSeg == 0 && (_this1.lastSeg || _this1.next() == 0)) {
					_this1.validBits = -1;
					break;
				} else {
					_this1.bytesInSeg--;
					_this1.inputPosition += 1;
					_this1.acc = _this1.acc + (_this1.input.readByte() << _this1.validBits);
					_this1.validBits += 8;
				} while(_this1.validBits < 1);
				if(_this1.validBits < 0) {
					next = 0;
				} else {
					let z = _this1.acc & 1;
					_this1.acc = _this1.acc >>> 1;
					_this1.validBits -= 1;
					next = z;
				}
			} else {
				let z = _this1.acc & 1;
				_this1.acc = _this1.acc >>> 1;
				_this1.validBits -= 1;
				next = z;
			}
		} else {
			next = 0;
			prev = 0;
			n2 = this.header.blocksize0;
		}
		let windowCenter = n2 >> 1;
		return { mode : i, left : m.blockflag && prev == 0 ? { start : n2 - this.header.blocksize0 >> 2, end : n2 + this.header.blocksize0 >> 2} : { start : 0, end : windowCenter}, right : m.blockflag && next == 0 ? { start : n2 * 3 - this.header.blocksize0 >> 2, end : n2 * 3 + this.header.blocksize0 >> 2} : { start : windowCenter, end : n2}};
	}
	decodePacketRest(r) {
		let m = this.header.modes[r.mode];
		let zeroChannel = new Array(256);
		let reallyZeroChannel = new Array(256);
		let n = m.blockflag ? this.header.blocksize1 : this.header.blocksize0;
		let map = this.header.mapping[m.mapping];
		let n2 = n >> 1;
		let rangeList = [256,128,86,64];
		let codebooks = this.header.codebooks;
		let _g = 0;
		let _g1 = this.header.channel;
		while(_g < _g1) {
			let i = _g++;
			let s = map.chan[i].mux;
			zeroChannel[i] = false;
			let floor = this.header.floorConfig[map.submapFloor[s]];
			if(floor.type == 0) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "stb/format/vorbis/VorbisDecoder.hx", lineNumber : 576, className : "stb.format.vorbis.VorbisDecoder", methodName : "decodePacketRest"}));
			} else {
				let g = floor.floor1;
				let _this = this.decodeState;
				let tmp;
				if(_this.validBits < 0) {
					tmp = 0;
				} else if(_this.validBits < 1) {
					if(_this.validBits == 0) {
						_this.acc = 0;
					}
					do if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
						_this.validBits = -1;
						break;
					} else {
						_this.bytesInSeg--;
						_this.inputPosition += 1;
						_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
						_this.validBits += 8;
					} while(_this.validBits < 1);
					if(_this.validBits < 0) {
						tmp = 0;
					} else {
						let z = _this.acc & 1;
						_this.acc = _this.acc >>> 1;
						_this.validBits -= 1;
						tmp = z;
					}
				} else {
					let z = _this.acc & 1;
					_this.acc = _this.acc >>> 1;
					_this.validBits -= 1;
					tmp = z;
				}
				if(tmp != 0) {
					let fy = [];
					let step2Flag = new Array(256);
					let range = rangeList[g.floor1Multiplier - 1];
					let offset = 2;
					fy = this.finalY[i];
					let _this = this.decodeState;
					let log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
					let n = (range < 16384 ? range < 16 ? log2_4[range] : range < 512 ? 5 + log2_4[range >> 5] : 10 + log2_4[range >> 10] : range < 16777216 ? range < 524288 ? 15 + log2_4[range >> 15] : 20 + log2_4[range >> 20] : range < 536870912 ? 25 + log2_4[range >> 25] : range < -2147483648 ? 30 + log2_4[range >> 30] : 0) - 1;
					let tmp;
					if(_this.validBits < 0) {
						tmp = 0;
					} else if(_this.validBits < n) {
						if(n > 24) {
							let tmp1;
							if(_this.validBits < 0) {
								tmp1 = 0;
							} else if(_this.validBits < 24) {
								if(_this.validBits == 0) {
									_this.acc = 0;
								}
								do if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
									_this.validBits = -1;
									break;
								} else {
									_this.bytesInSeg--;
									_this.inputPosition += 1;
									_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
									_this.validBits += 8;
								} while(_this.validBits < 24);
								if(_this.validBits < 0) {
									tmp1 = 0;
								} else {
									let z = _this.acc & 16777215;
									_this.acc = _this.acc >>> 24;
									_this.validBits -= 24;
									tmp1 = z;
								}
							} else {
								let z = _this.acc & 16777215;
								_this.acc = _this.acc >>> 24;
								_this.validBits -= 24;
								tmp1 = z;
							}
							let n1 = n - 24;
							let tmp2;
							if(_this.validBits < 0) {
								tmp2 = 0;
							} else if(_this.validBits < n1) {
								if(n1 > 24) {
									tmp2 = _this.readBits(24) + (_this.readBits(n1 - 24) << 24);
								} else {
									if(_this.validBits == 0) {
										_this.acc = 0;
									}
									do if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
										_this.validBits = -1;
										break;
									} else {
										_this.bytesInSeg--;
										_this.inputPosition += 1;
										_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
										_this.validBits += 8;
									} while(_this.validBits < n1);
									if(_this.validBits < 0) {
										tmp2 = 0;
									} else {
										let z = _this.acc & (1 << n1) - 1;
										_this.acc = _this.acc >>> n1;
										_this.validBits -= n1;
										tmp2 = z;
									}
								}
							} else {
								let z = _this.acc & (1 << n1) - 1;
								_this.acc = _this.acc >>> n1;
								_this.validBits -= n1;
								tmp2 = z;
							}
							tmp = tmp1 + (tmp2 << 24);
						} else {
							if(_this.validBits == 0) {
								_this.acc = 0;
							}
							do if(_this.bytesInSeg == 0 && (_this.lastSeg || _this.next() == 0)) {
								_this.validBits = -1;
								break;
							} else {
								_this.bytesInSeg--;
								_this.inputPosition += 1;
								_this.acc = _this.acc + (_this.input.readByte() << _this.validBits);
								_this.validBits += 8;
							} while(_this.validBits < n);
							if(_this.validBits < 0) {
								tmp = 0;
							} else {
								let z = _this.acc & (1 << n) - 1;
								_this.acc = _this.acc >>> n;
								_this.validBits -= n;
								tmp = z;
							}
						}
					} else {
						let z = _this.acc & (1 << n) - 1;
						_this.acc = _this.acc >>> n;
						_this.validBits -= n;
						tmp = z;
					}
					fy[0] = tmp;
					let _this1 = this.decodeState;
					let log2_41 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
					let n1 = (range < 16384 ? range < 16 ? log2_41[range] : range < 512 ? 5 + log2_41[range >> 5] : 10 + log2_41[range >> 10] : range < 16777216 ? range < 524288 ? 15 + log2_41[range >> 15] : 20 + log2_41[range >> 20] : range < 536870912 ? 25 + log2_41[range >> 25] : range < -2147483648 ? 30 + log2_41[range >> 30] : 0) - 1;
					let tmp1;
					if(_this1.validBits < 0) {
						tmp1 = 0;
					} else if(_this1.validBits < n1) {
						if(n1 > 24) {
							let tmp;
							if(_this1.validBits < 0) {
								tmp = 0;
							} else if(_this1.validBits < 24) {
								if(_this1.validBits == 0) {
									_this1.acc = 0;
								}
								do if(_this1.bytesInSeg == 0 && (_this1.lastSeg || _this1.next() == 0)) {
									_this1.validBits = -1;
									break;
								} else {
									_this1.bytesInSeg--;
									_this1.inputPosition += 1;
									_this1.acc = _this1.acc + (_this1.input.readByte() << _this1.validBits);
									_this1.validBits += 8;
								} while(_this1.validBits < 24);
								if(_this1.validBits < 0) {
									tmp = 0;
								} else {
									let z = _this1.acc & 16777215;
									_this1.acc = _this1.acc >>> 24;
									_this1.validBits -= 24;
									tmp = z;
								}
							} else {
								let z = _this1.acc & 16777215;
								_this1.acc = _this1.acc >>> 24;
								_this1.validBits -= 24;
								tmp = z;
							}
							let n = n1 - 24;
							let tmp2;
							if(_this1.validBits < 0) {
								tmp2 = 0;
							} else if(_this1.validBits < n) {
								if(n > 24) {
									tmp2 = _this1.readBits(24) + (_this1.readBits(n - 24) << 24);
								} else {
									if(_this1.validBits == 0) {
										_this1.acc = 0;
									}
									do if(_this1.bytesInSeg == 0 && (_this1.lastSeg || _this1.next() == 0)) {
										_this1.validBits = -1;
										break;
									} else {
										_this1.bytesInSeg--;
										_this1.inputPosition += 1;
										_this1.acc = _this1.acc + (_this1.input.readByte() << _this1.validBits);
										_this1.validBits += 8;
									} while(_this1.validBits < n);
									if(_this1.validBits < 0) {
										tmp2 = 0;
									} else {
										let z = _this1.acc & (1 << n) - 1;
										_this1.acc = _this1.acc >>> n;
										_this1.validBits -= n;
										tmp2 = z;
									}
								}
							} else {
								let z = _this1.acc & (1 << n) - 1;
								_this1.acc = _this1.acc >>> n;
								_this1.validBits -= n;
								tmp2 = z;
							}
							tmp1 = tmp + (tmp2 << 24);
						} else {
							if(_this1.validBits == 0) {
								_this1.acc = 0;
							}
							do if(_this1.bytesInSeg == 0 && (_this1.lastSeg || _this1.next() == 0)) {
								_this1.validBits = -1;
								break;
							} else {
								_this1.bytesInSeg--;
								_this1.inputPosition += 1;
								_this1.acc = _this1.acc + (_this1.input.readByte() << _this1.validBits);
								_this1.validBits += 8;
							} while(_this1.validBits < n1);
							if(_this1.validBits < 0) {
								tmp1 = 0;
							} else {
								let z = _this1.acc & (1 << n1) - 1;
								_this1.acc = _this1.acc >>> n1;
								_this1.validBits -= n1;
								tmp1 = z;
							}
						}
					} else {
						let z = _this1.acc & (1 << n1) - 1;
						_this1.acc = _this1.acc >>> n1;
						_this1.validBits -= n1;
						tmp1 = z;
					}
					fy[1] = tmp1;
					let _g = 0;
					let _g1 = g.partitions;
					while(_g < _g1) {
						let j = _g++;
						let pclass = g.partitionClassList[j];
						let cdim = g.classDimensions[pclass];
						let cbits = g.classSubclasses[pclass];
						let csub = (1 << cbits) - 1;
						let cval = 0;
						if(cbits != 0) {
							let c = codebooks[g.classMasterbooks[pclass]];
							let _this = this.decodeState;
							if(_this.validBits < 10) {
								_this.prepHuffman();
							}
							let i = c.fastHuffman[_this.acc & 1023];
							let val;
							if(i >= 0) {
								let l = c.codewordLengths[i];
								_this.acc = _this.acc >>> l;
								_this.validBits -= l;
								if(_this.validBits < 0) {
									_this.validBits = 0;
									val = -1;
								} else {
									val = i;
								}
							} else {
								val = _this.decodeScalarRaw(c);
							}
							if(c.sparse) {
								val = c.sortedValues[val];
							}
							cval = val;
						}
						let books = g.subclassBooks[pclass];
						let _g1 = 0;
						while(_g1 < cdim) {
							++_g1;
							let book = books[cval & csub];
							cval >>= cbits;
							let tmp = offset++;
							let tmp1;
							if(book >= 0) {
								let _this = this.decodeState;
								let c = codebooks[book];
								if(_this.validBits < 10) {
									_this.prepHuffman();
								}
								let i = c.fastHuffman[_this.acc & 1023];
								let val;
								if(i >= 0) {
									let l = c.codewordLengths[i];
									_this.acc = _this.acc >>> l;
									_this.validBits -= l;
									if(_this.validBits < 0) {
										_this.validBits = 0;
										val = -1;
									} else {
										val = i;
									}
								} else {
									val = _this.decodeScalarRaw(c);
								}
								if(c.sparse) {
									val = c.sortedValues[val];
								}
								tmp1 = val;
							} else {
								tmp1 = 0;
							}
							fy[tmp] = tmp1;
						}
					}
					if(this.decodeState.validBits == -1) {
						zeroChannel[i] = true;
						continue;
					}
					step2Flag[1] = true;
					step2Flag[0] = true;
					let naighbors = g.neighbors;
					let xlist = g.xlist;
					let _g2 = 2;
					let _g3 = g.values;
					while(_g2 < _g3) {
						let j = _g2++;
						let low = naighbors[j][0];
						let high = naighbors[j][1];
						let x0 = xlist[low];
						let y0 = fy[low];
						let dy = fy[high] - y0;
						let adx = xlist[high] - x0;
						let err = Math.abs(dy) * (xlist[j] - x0);
						let off = err / adx | 0;
						let lowroom = dy < 0 ? y0 - off : y0 + off;
						let val = fy[j];
						let highroom = range - lowroom;
						let room = highroom < lowroom ? highroom * 2 : lowroom * 2;
						if(val != 0) {
							step2Flag[high] = true;
							step2Flag[low] = true;
							step2Flag[j] = true;
							if(val >= room) {
								if(highroom > lowroom) {
									fy[j] = val - lowroom + lowroom;
								} else {
									fy[j] = lowroom - val + highroom - 1;
								}
							} else if((val & 1) != 0) {
								fy[j] = lowroom - (val + 1 >> 1);
							} else {
								fy[j] = lowroom + (val >> 1);
							}
						} else {
							step2Flag[j] = false;
							fy[j] = lowroom;
						}
					}
					let _g4 = 0;
					let _g5 = g.values;
					while(_g4 < _g5) {
						let j = _g4++;
						if(!step2Flag[j]) {
							fy[j] = -1;
						}
					}
				} else {
					zeroChannel[i] = true;
				}
			}
		}
		let _g2 = 0;
		let _g3 = this.header.channel;
		while(_g2 < _g3) {
			let i = _g2++;
			reallyZeroChannel[i] = zeroChannel[i];
		}
		let _g4 = 0;
		let _g5 = map.couplingSteps;
		while(_g4 < _g5) {
			let i = _g4++;
			if(!zeroChannel[map.chan[i].magnitude] || !zeroChannel[map.chan[i].angle]) {
				let index = map.chan[i].magnitude;
				zeroChannel[map.chan[i].angle] = false;
				zeroChannel[index] = false;
			}
		}
		let _g6 = 0;
		let _g7 = map.submaps;
		while(_g6 < _g7) {
			let i = _g6++;
			let residueBuffers = new Array(this.header.channel);
			let doNotDecode = new Array(256);
			let ch = 0;
			let _g = 0;
			let _g1 = this.header.channel;
			while(_g < _g1) {
				let j = _g++;
				if(map.chan[j].mux == i) {
					if(zeroChannel[j]) {
						doNotDecode[ch] = true;
						residueBuffers[ch] = null;
					} else {
						doNotDecode[ch] = false;
						residueBuffers[ch] = this.channelBuffers[j];
					}
					++ch;
				}
			}
			let r = map.submapResidue[i];
			let residue = this.header.residueConfig[r];
			residue.decode(this.decodeState,this.header,residueBuffers,ch,n2,doNotDecode,this.channelBuffers);
		}
		let i = map.couplingSteps;
		let n21 = n >> 1;
		while(--i >= 0) {
			let m = this.channelBuffers[map.chan[i].magnitude];
			let a = this.channelBuffers[map.chan[i].angle];
			let _g = 0;
			while(_g < n21) {
				let j = _g++;
				let a2;
				let m2;
				if(m[j] > 0) {
					if(a[j] > 0) {
						m2 = m[j];
						a2 = m[j] - a[j];
					} else {
						a2 = m[j];
						m2 = m[j] + a[j];
					}
				} else if(a[j] > 0) {
					m2 = m[j];
					a2 = m[j] + a[j];
				} else {
					a2 = m[j];
					m2 = m[j] - a[j];
				}
				m[j] = m2;
				a[j] = a2;
			}
		}
		let _g8 = 0;
		let _g9 = this.header.channel;
		while(_g8 < _g9) {
			let i = _g8++;
			if(reallyZeroChannel[i]) {
				let _g = 0;
				while(_g < n21) {
					let j = _g++;
					this.channelBuffers[i][j] = 0;
				}
			} else {
				map.doFloor(this.header.floorConfig,i,n,this.channelBuffers[i],this.finalY[i],null);
			}
		}
		let _g10 = 0;
		let _g11 = this.header.channel;
		while(_g10 < _g11) {
			let i = _g10++;
			this.inverseMdct(this.channelBuffers[i],n,m.blockflag);
		}
		let _this = this.decodeState;
		while(_this.bytesInSeg != 0 || !_this.lastSeg && _this.next() != 0) {
			_this.bytesInSeg--;
			_this.inputPosition += 1;
			_this.input.readByte();
		}
		return this.decodeState.finishDecodePacket(this.previousLength,n,r);
	}
	static start(input) {
		let decodeState = new stb_format_vorbis_VorbisDecodeState(input);
		let header = stb_format_vorbis_data_Header.read(decodeState);
		let decoder = new stb_format_vorbis_VorbisDecoder(header,decodeState);
		decodeState.startFirstDecode();
		decoder.pumpFirstFrame();
		return decoder;
	}
}
$hxClasses["stb.format.vorbis.VorbisDecoder"] = stb_format_vorbis_VorbisDecoder;
stb_format_vorbis_VorbisDecoder.__name__ = "stb.format.vorbis.VorbisDecoder";
Object.assign(stb_format_vorbis_VorbisDecoder.prototype, {
	__class__: stb_format_vorbis_VorbisDecoder
	,previousWindow: null
	,previousLength: null
	,finalY: null
	,a: null
	,b: null
	,c: null
	,window: null
	,bitReverseData: null
	,channelBuffers: null
	,channelBufferStart: null
	,channelBufferEnd: null
	,header: null
	,currentSample: null
	,totalSample: null
	,decodeState: null
});
class stb_format_vorbis_VorbisTools {
	static pointCompare(a,b) {
		if(a.x < b.x) {
			return -1;
		} else if(a.x > b.x) {
			return 1;
		} else {
			return 0;
		}
	}
	static uintAsc(a,b) {
		if(UInt.gt(b,a)) {
			return -1;
		} else if(a == b) {
			return 0;
		} else {
			return 1;
		}
	}
	static lookup1Values(entries,dim) {
		let r = Math.exp(Math.log(entries) / dim) | 0;
		if((Math.pow(r + 1,dim) | 0) <= entries) {
			++r;
		}
		if(!(Math.pow(r + 1,dim) > entries)) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.OTHER,"",{ fileName : "stb/format/vorbis/VorbisTools.hx", lineNumber : 155, className : "stb.format.vorbis.VorbisTools", methodName : "lookup1Values"}));
		}
		if((Math.pow(r,dim) | 0) > entries) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.OTHER,"",{ fileName : "stb/format/vorbis/VorbisTools.hx", lineNumber : 156, className : "stb.format.vorbis.VorbisTools", methodName : "lookup1Values"}));
		}
		return r;
	}
	static computeWindow(n,$window) {
		let n2 = n >> 1;
		let _g = 0;
		while(_g < n2) {
			let i = _g++;
			$window[i] = Math.sin(1.5707963267948966 * stb_format_vorbis_VorbisTools.square(Math.sin((i + 0.5) / n2 * 0.5 * 3.14159265358979323846264)));
		}
	}
	static square(f) {
		return f * f;
	}
	static computeBitReverse(n,rev) {
		let log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
		let ld = (n < 16384 ? n < 16 ? log2_4[n] : n < 512 ? 5 + log2_4[n >> 5] : 10 + log2_4[n >> 10] : n < 16777216 ? n < 524288 ? 15 + log2_4[n >> 15] : 20 + log2_4[n >> 20] : n < 536870912 ? 25 + log2_4[n >> 25] : n < -2147483648 ? 30 + log2_4[n >> 30] : 0) - 1;
		let n8 = n >> 3;
		let _g = 0;
		while(_g < n8) {
			let i = _g++;
			let n = i;
			n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
			n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
			n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
			n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
			rev[i] = (n >>> 16 | n << 16) >>> 32 - ld + 3 << 2;
		}
	}
	static computeTwiddleFactors(n,af,bf,cf) {
		let n4 = n >> 2;
		let n8 = n >> 3;
		let k2 = 0;
		let _g = 0;
		while(_g < n4) {
			let k = _g++;
			af[k2] = Math.cos(4 * k * 3.14159265358979323846264 / n);
			af[k2 + 1] = -Math.sin(4 * k * 3.14159265358979323846264 / n);
			bf[k2] = Math.cos((k2 + 1) * 3.14159265358979323846264 / n / 2) * 0.5;
			bf[k2 + 1] = Math.sin((k2 + 1) * 3.14159265358979323846264 / n / 2) * 0.5;
			k2 += 2;
		}
		let k21 = 0;
		let _g1 = 0;
		while(_g1 < n8) {
			++_g1;
			cf[k21] = Math.cos(2 * (k21 + 1) * 3.14159265358979323846264 / n);
			cf[k21 + 1] = -Math.sin(2 * (k21 + 1) * 3.14159265358979323846264 / n);
			k21 += 2;
		}
	}
	static drawLine(output,x0,y0,x1,y1,n) {
		if(stb_format_vorbis_VorbisTools.integerDivideTable == null) {
			stb_format_vorbis_VorbisTools.integerDivideTable = new Array(32);
			let _g = 0;
			while(_g < 32) {
				let i = _g++;
				stb_format_vorbis_VorbisTools.integerDivideTable[i] = new Array(64);
				let _g1 = 1;
				while(_g1 < 64) {
					let j = _g1++;
					stb_format_vorbis_VorbisTools.integerDivideTable[i][j] = i / j | 0;
				}
			}
		}
		let dy = y1 - y0;
		let adx = x1 - x0;
		let ady = dy < 0 ? -dy : dy;
		let base;
		let y = y0;
		let err = 0;
		let sy;
		if(adx < 64 && ady < 32) {
			if(dy < 0) {
				base = -stb_format_vorbis_VorbisTools.integerDivideTable[ady][adx];
				sy = base - 1;
			} else {
				base = stb_format_vorbis_VorbisTools.integerDivideTable[ady][adx];
				sy = base + 1;
			}
		} else {
			base = dy / adx | 0;
			sy = dy < 0 ? base - 1 : base + 1;
		}
		ady -= (base < 0 ? -base : base) * adx;
		if(x1 > n) {
			x1 = n;
		}
		output[x0] *= stb_format_vorbis_VorbisTools.INVERSE_DB_TABLE[y0];
		let _g = x0 + 1;
		let _g1 = x1;
		while(_g < _g1) {
			let i = _g++;
			err += ady;
			if(err >= adx) {
				err -= adx;
				y += sy;
			} else {
				y += base;
			}
			output[i] *= stb_format_vorbis_VorbisTools.INVERSE_DB_TABLE[y];
		}
	}
}
$hxClasses["stb.format.vorbis.VorbisTools"] = stb_format_vorbis_VorbisTools;
stb_format_vorbis_VorbisTools.__name__ = "stb.format.vorbis.VorbisTools";
class stb_format_vorbis_data_Codebook {
	constructor() {
	}
	computeCodewords(len,n,values) {
		let available = new Array(32);
		available[0] = 0;
		available[1] = 0;
		available[2] = 0;
		available[3] = 0;
		available[4] = 0;
		available[5] = 0;
		available[6] = 0;
		available[7] = 0;
		available[8] = 0;
		available[9] = 0;
		available[10] = 0;
		available[11] = 0;
		available[12] = 0;
		available[13] = 0;
		available[14] = 0;
		available[15] = 0;
		available[16] = 0;
		available[17] = 0;
		available[18] = 0;
		available[19] = 0;
		available[20] = 0;
		available[21] = 0;
		available[22] = 0;
		available[23] = 0;
		available[24] = 0;
		available[25] = 0;
		available[26] = 0;
		available[27] = 0;
		available[28] = 0;
		available[29] = 0;
		available[30] = 0;
		available[31] = 0;
		let k = 0;
		while(k < n) {
			if(len[k] < 255) {
				break;
			}
			++k;
		}
		if(k == n) {
			if(this.sortedEntries != 0) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.OTHER,"",{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 228, className : "stb.format.vorbis.data.Codebook", methodName : "computeCodewords"}));
			}
			return true;
		}
		let m = 0;
		m = 1;
		if(!this.sparse) {
			this.codewords[k] = 0;
		} else {
			this.codewords[0] = 0;
			this.codewordLengths[0] = len[k];
			values[0] = k;
		}
		let i = 0;
		while(++i <= len[k]) available[i] = 1 << 32 - i;
		i = k;
		while(++i < n) {
			let z = len[i];
			if(z == 255) {
				continue;
			}
			while(z > 0 && available[z] == 0) --z;
			if(z == 0) {
				return false;
			}
			let res = available[z];
			available[z] = 0;
			let n = res;
			n = (res & -1431655766) >>> 1 | (res & 1431655765) << 1;
			n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
			n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
			n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
			let huffCode = n >>> 16 | n << 16;
			let count = m++;
			if(!this.sparse) {
				this.codewords[i] = huffCode;
			} else {
				this.codewords[count] = huffCode;
				this.codewordLengths[count] = len[i];
				values[count] = i;
			}
			if(z != len[i]) {
				let y = len[i];
				while(y > z) {
					if(available[y] != 0) {
						throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.OTHER,"",{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 272, className : "stb.format.vorbis.data.Codebook", methodName : "computeCodewords"}));
					}
					available[y] = res + (1 << 32 - y);
					--y;
				}
			}
		}
		return true;
	}
	computeSortedHuffman(lengths,values) {
		if(!this.sparse) {
			let k = 0;
			let _g = 0;
			let _g1 = this.entries;
			while(_g < _g1) {
				let i = _g++;
				let len = lengths[i];
				let tmp;
				if(this.sparse) {
					if(len == 255) {
						throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.OTHER,"",{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 201, className : "stb.format.vorbis.data.Codebook", methodName : "includeInSort"}));
					}
					tmp = true;
				} else {
					tmp = len == 255 ? false : len > 10;
				}
				if(tmp) {
					let n = this.codewords[i];
					n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
					n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
					n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
					n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
					this.sortedCodewords[k++] = n >>> 16 | n << 16;
				}
			}
			if(k != this.sortedEntries) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.OTHER,"",{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 296, className : "stb.format.vorbis.data.Codebook", methodName : "computeSortedHuffman"}));
			}
		} else {
			let _g = 0;
			let _g1 = this.sortedEntries;
			while(_g < _g1) {
				let i = _g++;
				let n = this.codewords[i];
				n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
				n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
				n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
				n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
				this.sortedCodewords[i] = n >>> 16 | n << 16;
			}
		}
		this.sortedCodewords[this.sortedEntries] = -1;
		this.sortedCodewords.sort(stb_format_vorbis_VorbisTools.uintAsc);
		let len = this.sparse ? this.sortedEntries : this.entries;
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			let huffLen = this.sparse ? lengths[values[i]] : lengths[i];
			let tmp;
			if(this.sparse) {
				if(huffLen == 255) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.OTHER,"",{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 201, className : "stb.format.vorbis.data.Codebook", methodName : "includeInSort"}));
				}
				tmp = true;
			} else {
				tmp = huffLen == 255 ? false : huffLen > 10;
			}
			if(tmp) {
				let n = this.codewords[i];
				n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
				n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
				n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
				n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
				let code = n >>> 16 | n << 16;
				let x = 0;
				let n1 = this.sortedEntries;
				while(n1 > 1) {
					let m = x + (n1 >> 1);
					if(UInt.gte(code,this.sortedCodewords[m])) {
						x = m;
						n1 -= n1 >> 1;
					} else {
						n1 >>= 1;
					}
				}
				if(this.sparse) {
					this.sortedValues[x] = values[i];
					this.codewordLengths[x] = huffLen;
				} else {
					this.sortedValues[x] = i;
				}
			}
		}
	}
	computeAcceleratedHuffman() {
		this.fastHuffman = new Array(1024);
		this.fastHuffman[0] = -1;
		let _g = 0;
		while(_g < 1024) {
			let i = _g++;
			this.fastHuffman[i] = -1;
		}
		let len = this.sparse ? this.sortedEntries : this.entries;
		let _g1 = 0;
		let _g2 = len;
		while(_g1 < _g2) {
			let i = _g1++;
			if(this.codewordLengths[i] <= 10) {
				let z;
				if(this.sparse) {
					let n = this.sortedCodewords[i];
					n = (n & -1431655766) >>> 1 | (n & 1431655765) << 1;
					n = (n & -858993460) >>> 2 | (n & 858993459) << 2;
					n = (n & -252645136) >>> 4 | (n & 252645135) << 4;
					n = (n & -16711936) >>> 8 | (n & 16711935) << 8;
					z = n >>> 16 | n << 16;
				} else {
					z = this.codewords[i];
				}
				while(z < 1024) {
					this.fastHuffman[z] = i;
					z += 1 << this.codewordLengths[i];
				}
			}
		}
	}
	codebookDecode(decodeState,output,offset,len) {
		if(decodeState.validBits < 10) {
			decodeState.prepHuffman();
		}
		let i = this.fastHuffman[decodeState.acc & 1023];
		let val;
		if(i >= 0) {
			let l = this.codewordLengths[i];
			decodeState.acc = decodeState.acc >>> l;
			decodeState.validBits -= l;
			if(decodeState.validBits < 0) {
				decodeState.validBits = 0;
				val = -1;
			} else {
				val = i;
			}
		} else {
			val = decodeState.decodeScalarRaw(this);
		}
		if(this.sparse) {
			val = this.sortedValues[val];
		}
		let z = val;
		let lookupValues = this.lookupValues;
		let sequenceP = this.sequenceP;
		let multiplicands = this.multiplicands;
		let minimumValue = this.minimumValue;
		if(z < 0) {
			return false;
		}
		if(len > this.dimensions) {
			len = this.dimensions;
		}
		if(this.lookupType == 1) {
			let div = 1;
			let last = 0.0;
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				let off = UInt.toFloat(z / div | 0) % UInt.toFloat(lookupValues) | 0;
				let val = multiplicands[off] + last;
				output[offset + i] += val;
				if(sequenceP) {
					last = val + minimumValue;
				}
				div = div * lookupValues;
			}
			return true;
		}
		z *= this.dimensions;
		if(sequenceP) {
			let last = 0.0;
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				let val = multiplicands[z + i] + last;
				output[offset + i] += val;
				last = val + minimumValue;
			}
		} else {
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				output[offset + i] += multiplicands[z + i];
			}
		}
		return true;
	}
	codebookDecodeStep(decodeState,output,offset,len,step) {
		if(decodeState.validBits < 10) {
			decodeState.prepHuffman();
		}
		let i = this.fastHuffman[decodeState.acc & 1023];
		let val;
		if(i >= 0) {
			let l = this.codewordLengths[i];
			decodeState.acc = decodeState.acc >>> l;
			decodeState.validBits -= l;
			if(decodeState.validBits < 0) {
				decodeState.validBits = 0;
				val = -1;
			} else {
				val = i;
			}
		} else {
			val = decodeState.decodeScalarRaw(this);
		}
		if(this.sparse) {
			val = this.sortedValues[val];
		}
		let z = val;
		let last = 0.0;
		if(z < 0) {
			return false;
		}
		if(len > this.dimensions) {
			len = this.dimensions;
		}
		let lookupValues = this.lookupValues;
		let sequenceP = this.sequenceP;
		let multiplicands = this.multiplicands;
		if(this.lookupType == 1) {
			let div = 1;
			let _g = 0;
			let _g1 = len;
			while(_g < _g1) {
				let i = _g++;
				let off = UInt.toFloat(z / div | 0) % UInt.toFloat(lookupValues) | 0;
				let val = multiplicands[off] + last;
				output[offset + i * step] += val;
				if(sequenceP) {
					last = val;
				}
				div = div * lookupValues;
			}
			return true;
		}
		z *= this.dimensions;
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			let val = multiplicands[z + i] + last;
			output[offset + i * step] += val;
			if(sequenceP) {
				last = val;
			}
		}
		return true;
	}
	decodeDeinterleaveRepeat(decodeState,residueBuffers,ch,cInter,pInter,len,totalDecode) {
		let effective = this.dimensions;
		if(this.lookupType == 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 488, className : "stb.format.vorbis.data.Codebook", methodName : "decodeDeinterleaveRepeat"}));
		}
		let multiplicands = this.multiplicands;
		let sequenceP = this.sequenceP;
		let lookupValues = this.lookupValues;
		while(totalDecode > 0) {
			let last = 0.0;
			if(decodeState.validBits < 10) {
				decodeState.prepHuffman();
			}
			let i = this.fastHuffman[decodeState.acc & 1023];
			let val;
			if(i >= 0) {
				let l = this.codewordLengths[i];
				decodeState.acc = decodeState.acc >>> l;
				decodeState.validBits -= l;
				if(decodeState.validBits < 0) {
					decodeState.validBits = 0;
					val = -1;
				} else {
					val = i;
				}
			} else {
				val = decodeState.decodeScalarRaw(this);
			}
			if(this.sparse) {
				val = this.sortedValues[val];
			}
			let z = val;
			if(z < 0) {
				if(decodeState.bytesInSeg == 0 && decodeState.lastSeg) {
					return null;
				}
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 503, className : "stb.format.vorbis.data.Codebook", methodName : "decodeDeinterleaveRepeat"}));
			}
			if(cInter + pInter * ch + effective > len * ch) {
				effective = len * ch - (pInter * ch - cInter);
			}
			if(this.lookupType == 1) {
				let div = 1;
				if(sequenceP) {
					let _g = 0;
					let _g1 = effective;
					while(_g < _g1) {
						++_g;
						let off = UInt.toFloat(z / div | 0) % UInt.toFloat(lookupValues) | 0;
						let val = multiplicands[off] + last;
						residueBuffers[cInter][pInter] += val;
						if(++cInter == ch) {
							cInter = 0;
							++pInter;
						}
						last = val;
						div = div * lookupValues;
					}
				} else {
					let _g = 0;
					let _g1 = effective;
					while(_g < _g1) {
						++_g;
						let off = UInt.toFloat(z / div | 0) % UInt.toFloat(lookupValues) | 0;
						let val = multiplicands[off];
						residueBuffers[cInter][pInter] += val;
						if(++cInter == ch) {
							cInter = 0;
							++pInter;
						}
						div = div * lookupValues;
					}
				}
			} else {
				z *= this.dimensions;
				if(sequenceP) {
					let _g = 0;
					let _g1 = effective;
					while(_g < _g1) {
						let i = _g++;
						let val = multiplicands[z + i] + last;
						residueBuffers[cInter][pInter] += val;
						if(++cInter == ch) {
							cInter = 0;
							++pInter;
						}
						last = val;
					}
				} else {
					let _g = 0;
					let _g1 = effective;
					while(_g < _g1) {
						let i = _g++;
						let val = multiplicands[z + i];
						residueBuffers[cInter][pInter] += val;
						if(++cInter == ch) {
							cInter = 0;
							++pInter;
						}
					}
				}
			}
			totalDecode -= effective;
		}
		return { cInter : cInter, pInter : pInter};
	}
	residueDecode(decodeState,target,offset,n,rtype) {
		if(rtype == 0) {
			let step = n / this.dimensions | 0;
			let _g = 0;
			while(_g < step) {
				let k = _g++;
				if(!this.codebookDecodeStep(decodeState,target,offset + k,n - offset - k,step)) {
					return false;
				}
			}
		} else {
			let k = 0;
			while(k < n) {
				if(!this.codebookDecode(decodeState,target,offset,n - k)) {
					return false;
				}
				k += this.dimensions;
				offset += this.dimensions;
			}
		}
		return true;
	}
	static read(decodeState) {
		let c = new stb_format_vorbis_data_Codebook();
		let tmp;
		let tmp1;
		let tmp2;
		if(decodeState.validBits < 0) {
			tmp2 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 8);
			if(decodeState.validBits < 0) {
				tmp2 = 0;
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp2 = z;
			}
		} else {
			let z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp2 = z;
		}
		if(tmp2 == 66) {
			let tmp;
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else if(decodeState.validBits < 8) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 8);
				if(decodeState.validBits < 0) {
					tmp = 0;
				} else {
					let z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					tmp = z;
				}
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp = z;
			}
			tmp1 = tmp != 67;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			let tmp1;
			if(decodeState.validBits < 0) {
				tmp1 = 0;
			} else if(decodeState.validBits < 8) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 8);
				if(decodeState.validBits < 0) {
					tmp1 = 0;
				} else {
					let z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					tmp1 = z;
				}
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp1 = z;
			}
			tmp = tmp1 != 86;
		} else {
			tmp = true;
		}
		if(tmp) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 40, className : "stb.format.vorbis.data.Codebook", methodName : "read"}));
		}
		let x;
		if(decodeState.validBits < 0) {
			x = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 8);
			if(decodeState.validBits < 0) {
				x = 0;
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				x = z;
			}
		} else {
			let z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			x = z;
		}
		let tmp3;
		if(decodeState.validBits < 0) {
			tmp3 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 8);
			if(decodeState.validBits < 0) {
				tmp3 = 0;
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp3 = z;
			}
		} else {
			let z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp3 = z;
		}
		c.dimensions = (tmp3 << 8) + x;
		let x1;
		if(decodeState.validBits < 0) {
			x1 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 8);
			if(decodeState.validBits < 0) {
				x1 = 0;
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				x1 = z;
			}
		} else {
			let z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			x1 = z;
		}
		let y;
		if(decodeState.validBits < 0) {
			y = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 8);
			if(decodeState.validBits < 0) {
				y = 0;
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				y = z;
			}
		} else {
			let z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			y = z;
		}
		let tmp4;
		if(decodeState.validBits < 0) {
			tmp4 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 8);
			if(decodeState.validBits < 0) {
				tmp4 = 0;
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp4 = z;
			}
		} else {
			let z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp4 = z;
		}
		c.entries = (tmp4 << 16) + (y << 8) + x1;
		let ordered;
		if(decodeState.validBits < 0) {
			ordered = 0;
		} else if(decodeState.validBits < 1) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 1);
			if(decodeState.validBits < 0) {
				ordered = 0;
			} else {
				let z = decodeState.acc & 1;
				decodeState.acc = decodeState.acc >>> 1;
				decodeState.validBits -= 1;
				ordered = z;
			}
		} else {
			let z = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			ordered = z;
		}
		let tmp5;
		if(ordered != 0) {
			tmp5 = false;
		} else {
			let tmp;
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else if(decodeState.validBits < 1) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 1);
				if(decodeState.validBits < 0) {
					tmp = 0;
				} else {
					let z = decodeState.acc & 1;
					decodeState.acc = decodeState.acc >>> 1;
					decodeState.validBits -= 1;
					tmp = z;
				}
			} else {
				let z = decodeState.acc & 1;
				decodeState.acc = decodeState.acc >>> 1;
				decodeState.validBits -= 1;
				tmp = z;
			}
			tmp5 = tmp != 0;
		}
		c.sparse = tmp5;
		let lengths = new Array(c.entries);
		if(!c.sparse) {
			c.codewordLengths = lengths;
		}
		let total = 0;
		if(ordered != 0) {
			let currentEntry = 0;
			let currentLength;
			if(decodeState.validBits < 0) {
				currentLength = 0;
			} else if(decodeState.validBits < 5) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 5);
				if(decodeState.validBits < 0) {
					currentLength = 0;
				} else {
					let z = decodeState.acc & 31;
					decodeState.acc = decodeState.acc >>> 5;
					decodeState.validBits -= 5;
					currentLength = z;
				}
			} else {
				let z = decodeState.acc & 31;
				decodeState.acc = decodeState.acc >>> 5;
				decodeState.validBits -= 5;
				currentLength = z;
			}
			let currentLength1 = currentLength + 1;
			while(currentEntry < c.entries) {
				let limit = c.entries - currentEntry;
				let log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
				let n = limit < 16384 ? limit < 16 ? log2_4[limit] : limit < 512 ? 5 + log2_4[limit >> 5] : 10 + log2_4[limit >> 10] : limit < 16777216 ? limit < 524288 ? 15 + log2_4[limit >> 15] : 20 + log2_4[limit >> 20] : limit < 536870912 ? 25 + log2_4[limit >> 25] : limit < -2147483648 ? 30 + log2_4[limit >> 30] : 0;
				let n1;
				if(decodeState.validBits < 0) {
					n1 = 0;
				} else if(decodeState.validBits < n) {
					if(n > 24) {
						let n2;
						if(decodeState.validBits < 0) {
							n2 = 0;
						} else if(decodeState.validBits < 24) {
							if(decodeState.validBits == 0) {
								decodeState.acc = 0;
							}
							do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
								decodeState.validBits = -1;
								break;
							} else {
								decodeState.bytesInSeg--;
								decodeState.inputPosition += 1;
								decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
								decodeState.validBits += 8;
							} while(decodeState.validBits < 24);
							if(decodeState.validBits < 0) {
								n2 = 0;
							} else {
								let z = decodeState.acc & 16777215;
								decodeState.acc = decodeState.acc >>> 24;
								decodeState.validBits -= 24;
								n2 = z;
							}
						} else {
							let z = decodeState.acc & 16777215;
							decodeState.acc = decodeState.acc >>> 24;
							decodeState.validBits -= 24;
							n2 = z;
						}
						let n3 = n - 24;
						let n4;
						if(decodeState.validBits < 0) {
							n4 = 0;
						} else if(decodeState.validBits < n3) {
							if(n3 > 24) {
								n4 = decodeState.readBits(24) + (decodeState.readBits(n3 - 24) << 24);
							} else {
								if(decodeState.validBits == 0) {
									decodeState.acc = 0;
								}
								do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
									decodeState.validBits = -1;
									break;
								} else {
									decodeState.bytesInSeg--;
									decodeState.inputPosition += 1;
									decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
									decodeState.validBits += 8;
								} while(decodeState.validBits < n3);
								if(decodeState.validBits < 0) {
									n4 = 0;
								} else {
									let z = decodeState.acc & (1 << n3) - 1;
									decodeState.acc = decodeState.acc >>> n3;
									decodeState.validBits -= n3;
									n4 = z;
								}
							}
						} else {
							let z = decodeState.acc & (1 << n3) - 1;
							decodeState.acc = decodeState.acc >>> n3;
							decodeState.validBits -= n3;
							n4 = z;
						}
						n1 = n2 + (n4 << 24);
					} else {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						} while(decodeState.validBits < n);
						if(decodeState.validBits < 0) {
							n1 = 0;
						} else {
							let z = decodeState.acc & (1 << n) - 1;
							decodeState.acc = decodeState.acc >>> n;
							decodeState.validBits -= n;
							n1 = z;
						}
					}
				} else {
					let z = decodeState.acc & (1 << n) - 1;
					decodeState.acc = decodeState.acc >>> n;
					decodeState.validBits -= n;
					n1 = z;
				}
				if(currentEntry + n1 > c.entries) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"codebook entrys",{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 67, className : "stb.format.vorbis.data.Codebook", methodName : "read"}));
				}
				let _g = 0;
				let _g1 = n1;
				while(_g < _g1) {
					let i = _g++;
					lengths[currentEntry + i] = currentLength1;
				}
				currentEntry += n1;
				++currentLength1;
			}
		} else {
			let _g = 0;
			let _g1 = c.entries;
			while(_g < _g1) {
				let j = _g++;
				let present;
				if(c.sparse) {
					if(decodeState.validBits < 0) {
						present = 0;
					} else if(decodeState.validBits < 1) {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						} while(decodeState.validBits < 1);
						if(decodeState.validBits < 0) {
							present = 0;
						} else {
							let z = decodeState.acc & 1;
							decodeState.acc = decodeState.acc >>> 1;
							decodeState.validBits -= 1;
							present = z;
						}
					} else {
						let z = decodeState.acc & 1;
						decodeState.acc = decodeState.acc >>> 1;
						decodeState.validBits -= 1;
						present = z;
					}
				} else {
					present = 1;
				}
				if(present != 0) {
					let val;
					if(decodeState.validBits < 0) {
						val = 0;
					} else if(decodeState.validBits < 5) {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						} while(decodeState.validBits < 5);
						if(decodeState.validBits < 0) {
							val = 0;
						} else {
							let z = decodeState.acc & 31;
							decodeState.acc = decodeState.acc >>> 5;
							decodeState.validBits -= 5;
							val = z;
						}
					} else {
						let z = decodeState.acc & 31;
						decodeState.acc = decodeState.acc >>> 5;
						decodeState.validBits -= 5;
						val = z;
					}
					lengths[j] = val + 1;
					++total;
				} else {
					lengths[j] = 255;
				}
			}
		}
		if(c.sparse && total >= c.entries >> 2) {
			c.codewordLengths = lengths;
			c.sparse = false;
		}
		let tmp6;
		if(c.sparse) {
			tmp6 = total;
		} else {
			let sortedCount = 0;
			let _g = 0;
			let _g1 = c.entries;
			while(_g < _g1) {
				let j = _g++;
				let l = lengths[j];
				if(l > 10 && l != 255) {
					++sortedCount;
				}
			}
			tmp6 = sortedCount;
		}
		c.sortedEntries = tmp6;
		let values = null;
		if(!c.sparse) {
			c.codewords = new Array(c.entries);
		} else if(c.sortedEntries != 0) {
			c.codewordLengths = new Array(c.sortedEntries);
			c.codewords = new Array(c.entries);
			values = new Array(c.entries);
		}
		if(!c.computeCodewords(lengths,c.entries,values)) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"compute codewords",{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 120, className : "stb.format.vorbis.data.Codebook", methodName : "read"}));
		}
		if(c.sortedEntries != 0) {
			c.sortedCodewords = [];
			c.sortedValues = new Array(c.sortedEntries);
			c.computeSortedHuffman(lengths,values);
		}
		if(c.sparse) {
			c.codewords = null;
		}
		c.computeAcceleratedHuffman();
		let tmp7;
		if(decodeState.validBits < 0) {
			tmp7 = 0;
		} else if(decodeState.validBits < 4) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 4);
			if(decodeState.validBits < 0) {
				tmp7 = 0;
			} else {
				let z = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp7 = z;
			}
		} else {
			let z = decodeState.acc & 15;
			decodeState.acc = decodeState.acc >>> 4;
			decodeState.validBits -= 4;
			tmp7 = z;
		}
		c.lookupType = tmp7;
		if(c.lookupType > 2) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"codebook lookup type",{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 143, className : "stb.format.vorbis.data.Codebook", methodName : "read"}));
		}
		if(c.lookupType > 0) {
			let x;
			if(decodeState.validBits < 0) {
				x = 0;
			} else if(decodeState.validBits < 32) {
				let x1;
				if(decodeState.validBits < 0) {
					x1 = 0;
				} else if(decodeState.validBits < 24) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					} while(decodeState.validBits < 24);
					if(decodeState.validBits < 0) {
						x1 = 0;
					} else {
						let z = decodeState.acc & 16777215;
						decodeState.acc = decodeState.acc >>> 24;
						decodeState.validBits -= 24;
						x1 = z;
					}
				} else {
					let z = decodeState.acc & 16777215;
					decodeState.acc = decodeState.acc >>> 24;
					decodeState.validBits -= 24;
					x1 = z;
				}
				let x2;
				if(decodeState.validBits < 0) {
					x2 = 0;
				} else if(decodeState.validBits < 8) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					} while(decodeState.validBits < 8);
					if(decodeState.validBits < 0) {
						x2 = 0;
					} else {
						let z = decodeState.acc & 255;
						decodeState.acc = decodeState.acc >>> 8;
						decodeState.validBits -= 8;
						x2 = z;
					}
				} else {
					let z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					x2 = z;
				}
				x = x1 + (x2 << 24);
			} else {
				let z = decodeState.acc & 0;
				decodeState.acc = decodeState.acc >>> 32;
				decodeState.validBits -= 32;
				x = z;
			}
			let mantissa = UInt.toFloat(x & 2097151);
			let sign = x & -2147483648;
			let exp = (x & 2145386496) >>> 21;
			let res = sign != 0 ? -mantissa : mantissa;
			c.minimumValue = res * Math.pow(2,exp - 788);
			let x1;
			if(decodeState.validBits < 0) {
				x1 = 0;
			} else if(decodeState.validBits < 32) {
				let x;
				if(decodeState.validBits < 0) {
					x = 0;
				} else if(decodeState.validBits < 24) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					} while(decodeState.validBits < 24);
					if(decodeState.validBits < 0) {
						x = 0;
					} else {
						let z = decodeState.acc & 16777215;
						decodeState.acc = decodeState.acc >>> 24;
						decodeState.validBits -= 24;
						x = z;
					}
				} else {
					let z = decodeState.acc & 16777215;
					decodeState.acc = decodeState.acc >>> 24;
					decodeState.validBits -= 24;
					x = z;
				}
				let x2;
				if(decodeState.validBits < 0) {
					x2 = 0;
				} else if(decodeState.validBits < 8) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					} while(decodeState.validBits < 8);
					if(decodeState.validBits < 0) {
						x2 = 0;
					} else {
						let z = decodeState.acc & 255;
						decodeState.acc = decodeState.acc >>> 8;
						decodeState.validBits -= 8;
						x2 = z;
					}
				} else {
					let z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					x2 = z;
				}
				x1 = x + (x2 << 24);
			} else {
				let z = decodeState.acc & 0;
				decodeState.acc = decodeState.acc >>> 32;
				decodeState.validBits -= 32;
				x1 = z;
			}
			let mantissa1 = UInt.toFloat(x1 & 2097151);
			let sign1 = x1 & -2147483648;
			let exp1 = (x1 & 2145386496) >>> 21;
			let res1 = sign1 != 0 ? -mantissa1 : mantissa1;
			c.deltaValue = res1 * Math.pow(2,exp1 - 788);
			let tmp;
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else if(decodeState.validBits < 4) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 4);
				if(decodeState.validBits < 0) {
					tmp = 0;
				} else {
					let z = decodeState.acc & 15;
					decodeState.acc = decodeState.acc >>> 4;
					decodeState.validBits -= 4;
					tmp = z;
				}
			} else {
				let z = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp = z;
			}
			c.valueBits = tmp + 1;
			let tmp1;
			if(decodeState.validBits < 0) {
				tmp1 = 0;
			} else if(decodeState.validBits < 1) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 1);
				if(decodeState.validBits < 0) {
					tmp1 = 0;
				} else {
					let z = decodeState.acc & 1;
					decodeState.acc = decodeState.acc >>> 1;
					decodeState.validBits -= 1;
					tmp1 = z;
				}
			} else {
				let z = decodeState.acc & 1;
				decodeState.acc = decodeState.acc >>> 1;
				decodeState.validBits -= 1;
				tmp1 = z;
			}
			c.sequenceP = tmp1 != 0;
			if(c.lookupType == 1) {
				c.lookupValues = stb_format_vorbis_VorbisTools.lookup1Values(c.entries,c.dimensions);
			} else {
				c.lookupValues = c.entries * c.dimensions;
			}
			let mults = new Array(c.lookupValues);
			let _g = 0;
			let _g1 = c.lookupValues;
			while(_g < _g1) {
				let j = _g++;
				let n = c.valueBits;
				let q;
				if(decodeState.validBits < 0) {
					q = 0;
				} else if(decodeState.validBits < n) {
					if(n > 24) {
						let q1;
						if(decodeState.validBits < 0) {
							q1 = 0;
						} else if(decodeState.validBits < 24) {
							if(decodeState.validBits == 0) {
								decodeState.acc = 0;
							}
							do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
								decodeState.validBits = -1;
								break;
							} else {
								decodeState.bytesInSeg--;
								decodeState.inputPosition += 1;
								decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
								decodeState.validBits += 8;
							} while(decodeState.validBits < 24);
							if(decodeState.validBits < 0) {
								q1 = 0;
							} else {
								let z = decodeState.acc & 16777215;
								decodeState.acc = decodeState.acc >>> 24;
								decodeState.validBits -= 24;
								q1 = z;
							}
						} else {
							let z = decodeState.acc & 16777215;
							decodeState.acc = decodeState.acc >>> 24;
							decodeState.validBits -= 24;
							q1 = z;
						}
						let n1 = n - 24;
						let q2;
						if(decodeState.validBits < 0) {
							q2 = 0;
						} else if(decodeState.validBits < n1) {
							if(n1 > 24) {
								q2 = decodeState.readBits(24) + (decodeState.readBits(n1 - 24) << 24);
							} else {
								if(decodeState.validBits == 0) {
									decodeState.acc = 0;
								}
								do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
									decodeState.validBits = -1;
									break;
								} else {
									decodeState.bytesInSeg--;
									decodeState.inputPosition += 1;
									decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
									decodeState.validBits += 8;
								} while(decodeState.validBits < n1);
								if(decodeState.validBits < 0) {
									q2 = 0;
								} else {
									let z = decodeState.acc & (1 << n1) - 1;
									decodeState.acc = decodeState.acc >>> n1;
									decodeState.validBits -= n1;
									q2 = z;
								}
							}
						} else {
							let z = decodeState.acc & (1 << n1) - 1;
							decodeState.acc = decodeState.acc >>> n1;
							decodeState.validBits -= n1;
							q2 = z;
						}
						q = q1 + (q2 << 24);
					} else {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						} while(decodeState.validBits < n);
						if(decodeState.validBits < 0) {
							q = 0;
						} else {
							let z = decodeState.acc & (1 << n) - 1;
							decodeState.acc = decodeState.acc >>> n;
							decodeState.validBits -= n;
							q = z;
						}
					}
				} else {
					let z = decodeState.acc & (1 << n) - 1;
					decodeState.acc = decodeState.acc >>> n;
					decodeState.validBits -= n;
					q = z;
				}
				if(q == -1) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"fail lookup",{ fileName : "stb/format/vorbis/data/Codebook.hx", lineNumber : 161, className : "stb.format.vorbis.data.Codebook", methodName : "read"}));
				}
				mults[j] = q;
			}
			c.multiplicands = new Array(c.lookupValues);
			let _g2 = 0;
			let _g3 = c.lookupValues;
			while(_g2 < _g3) {
				let j = _g2++;
				c.multiplicands[j] = mults[j] * c.deltaValue + c.minimumValue;
			}
			if(c.lookupType == 2 && c.sequenceP) {
				let _g = 1;
				let _g1 = c.lookupValues;
				while(_g < _g1) {
					let j = _g++;
					c.multiplicands[j] = c.multiplicands[j - 1];
				}
				c.sequenceP = false;
			}
		}
		return c;
	}
}
$hxClasses["stb.format.vorbis.data.Codebook"] = stb_format_vorbis_data_Codebook;
stb_format_vorbis_data_Codebook.__name__ = "stb.format.vorbis.data.Codebook";
Object.assign(stb_format_vorbis_data_Codebook.prototype, {
	__class__: stb_format_vorbis_data_Codebook
	,dimensions: null
	,entries: null
	,codewordLengths: null
	,minimumValue: null
	,deltaValue: null
	,valueBits: null
	,lookupType: null
	,sequenceP: null
	,sparse: null
	,lookupValues: null
	,multiplicands: null
	,codewords: null
	,fastHuffman: null
	,sortedCodewords: null
	,sortedValues: null
	,sortedEntries: null
});
class stb_format_vorbis_data_Comment {
	constructor() {
		this.data = new haxe_ds_StringMap();
	}
	get_loopStart() {
		return Std.parseInt(this.getString("loopstart"));
	}
	get_loopLength() {
		return Std.parseInt(this.getString("looplength"));
	}
	add(key,value) {
		key = key.toLowerCase();
		if(Object.prototype.hasOwnProperty.call(this.data.h,key)) {
			this.data.h[key].push(value);
		} else {
			let v = [value];
			this.data.h[key] = v;
		}
	}
	getString(key) {
		key = key.toLowerCase();
		if(Object.prototype.hasOwnProperty.call(this.data.h,key)) {
			return this.data.h[key][0];
		} else {
			return null;
		}
	}
}
$hxClasses["stb.format.vorbis.data.Comment"] = stb_format_vorbis_data_Comment;
stb_format_vorbis_data_Comment.__name__ = "stb.format.vorbis.data.Comment";
Object.assign(stb_format_vorbis_data_Comment.prototype, {
	__class__: stb_format_vorbis_data_Comment
	,data: null
});
class stb_format_vorbis_data_Floor {
	constructor() {
	}
	static read(decodeState,codebooks) {
		let floor = new stb_format_vorbis_data_Floor();
		let tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 16) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 16);
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				let z = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				tmp = z;
			}
		} else {
			let z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp = z;
		}
		floor.type = tmp;
		if(floor.type > 1) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Floor.hx", lineNumber : 28, className : "stb.format.vorbis.data.Floor", methodName : "read"}));
		}
		if(floor.type == 0) {
			let g = floor.floor0 = new stb_format_vorbis_data_Floor0();
			let tmp;
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else if(decodeState.validBits < 8) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 8);
				if(decodeState.validBits < 0) {
					tmp = 0;
				} else {
					let z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					tmp = z;
				}
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp = z;
			}
			g.order = tmp;
			let tmp1;
			if(decodeState.validBits < 0) {
				tmp1 = 0;
			} else if(decodeState.validBits < 16) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 16);
				if(decodeState.validBits < 0) {
					tmp1 = 0;
				} else {
					let z = decodeState.acc & 65535;
					decodeState.acc = decodeState.acc >>> 16;
					decodeState.validBits -= 16;
					tmp1 = z;
				}
			} else {
				let z = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				tmp1 = z;
			}
			g.rate = tmp1;
			let tmp2;
			if(decodeState.validBits < 0) {
				tmp2 = 0;
			} else if(decodeState.validBits < 16) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 16);
				if(decodeState.validBits < 0) {
					tmp2 = 0;
				} else {
					let z = decodeState.acc & 65535;
					decodeState.acc = decodeState.acc >>> 16;
					decodeState.validBits -= 16;
					tmp2 = z;
				}
			} else {
				let z = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				tmp2 = z;
			}
			g.barkMapSize = tmp2;
			let tmp3;
			if(decodeState.validBits < 0) {
				tmp3 = 0;
			} else if(decodeState.validBits < 6) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 6);
				if(decodeState.validBits < 0) {
					tmp3 = 0;
				} else {
					let z = decodeState.acc & 63;
					decodeState.acc = decodeState.acc >>> 6;
					decodeState.validBits -= 6;
					tmp3 = z;
				}
			} else {
				let z = decodeState.acc & 63;
				decodeState.acc = decodeState.acc >>> 6;
				decodeState.validBits -= 6;
				tmp3 = z;
			}
			g.amplitudeBits = tmp3;
			let tmp4;
			if(decodeState.validBits < 0) {
				tmp4 = 0;
			} else if(decodeState.validBits < 8) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 8);
				if(decodeState.validBits < 0) {
					tmp4 = 0;
				} else {
					let z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					tmp4 = z;
				}
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp4 = z;
			}
			g.amplitudeOffset = tmp4;
			let tmp5;
			if(decodeState.validBits < 0) {
				tmp5 = 0;
			} else if(decodeState.validBits < 4) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 4);
				if(decodeState.validBits < 0) {
					tmp5 = 0;
				} else {
					let z = decodeState.acc & 15;
					decodeState.acc = decodeState.acc >>> 4;
					decodeState.validBits -= 4;
					tmp5 = z;
				}
			} else {
				let z = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp5 = z;
			}
			g.numberOfBooks = tmp5 + 1;
			let _g = 0;
			let _g1 = g.numberOfBooks;
			while(_g < _g1) {
				let j = _g++;
				let this1 = g.bookList;
				let val;
				if(decodeState.validBits < 0) {
					val = 0;
				} else if(decodeState.validBits < 8) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					} while(decodeState.validBits < 8);
					if(decodeState.validBits < 0) {
						val = 0;
					} else {
						let z = decodeState.acc & 255;
						decodeState.acc = decodeState.acc >>> 8;
						decodeState.validBits -= 8;
						val = z;
					}
				} else {
					let z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					val = z;
				}
				this1[j] = val;
			}
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.FEATURE_NOT_SUPPORTED,null,{ fileName : "stb/format/vorbis/data/Floor.hx", lineNumber : 41, className : "stb.format.vorbis.data.Floor", methodName : "read"}));
		} else {
			let p = [];
			let g = floor.floor1 = new stb_format_vorbis_data_Floor1();
			let maxClass = -1;
			let tmp;
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else if(decodeState.validBits < 5) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 5);
				if(decodeState.validBits < 0) {
					tmp = 0;
				} else {
					let z = decodeState.acc & 31;
					decodeState.acc = decodeState.acc >>> 5;
					decodeState.validBits -= 5;
					tmp = z;
				}
			} else {
				let z = decodeState.acc & 31;
				decodeState.acc = decodeState.acc >>> 5;
				decodeState.validBits -= 5;
				tmp = z;
			}
			g.partitions = tmp;
			g.partitionClassList = new Array(g.partitions);
			let _g = 0;
			let _g1 = g.partitions;
			while(_g < _g1) {
				let j = _g++;
				let this1 = g.partitionClassList;
				let val;
				if(decodeState.validBits < 0) {
					val = 0;
				} else if(decodeState.validBits < 4) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					} while(decodeState.validBits < 4);
					if(decodeState.validBits < 0) {
						val = 0;
					} else {
						let z = decodeState.acc & 15;
						decodeState.acc = decodeState.acc >>> 4;
						decodeState.validBits -= 4;
						val = z;
					}
				} else {
					let z = decodeState.acc & 15;
					decodeState.acc = decodeState.acc >>> 4;
					decodeState.validBits -= 4;
					val = z;
				}
				this1[j] = val;
				if(g.partitionClassList[j] > maxClass) {
					maxClass = g.partitionClassList[j];
				}
			}
			g.classDimensions = new Array(maxClass + 1);
			g.classMasterbooks = new Array(maxClass + 1);
			g.classSubclasses = new Array(maxClass + 1);
			g.subclassBooks = new Array(maxClass + 1);
			let _g2 = 0;
			let _g3 = maxClass + 1;
			while(_g2 < _g3) {
				let j = _g2++;
				let this1 = g.classDimensions;
				let val;
				if(decodeState.validBits < 0) {
					val = 0;
				} else if(decodeState.validBits < 3) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					} while(decodeState.validBits < 3);
					if(decodeState.validBits < 0) {
						val = 0;
					} else {
						let z = decodeState.acc & 7;
						decodeState.acc = decodeState.acc >>> 3;
						decodeState.validBits -= 3;
						val = z;
					}
				} else {
					let z = decodeState.acc & 7;
					decodeState.acc = decodeState.acc >>> 3;
					decodeState.validBits -= 3;
					val = z;
				}
				this1[j] = val + 1;
				let this2 = g.classSubclasses;
				let val1;
				if(decodeState.validBits < 0) {
					val1 = 0;
				} else if(decodeState.validBits < 2) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					} while(decodeState.validBits < 2);
					if(decodeState.validBits < 0) {
						val1 = 0;
					} else {
						let z = decodeState.acc & 3;
						decodeState.acc = decodeState.acc >>> 2;
						decodeState.validBits -= 2;
						val1 = z;
					}
				} else {
					let z = decodeState.acc & 3;
					decodeState.acc = decodeState.acc >>> 2;
					decodeState.validBits -= 2;
					val1 = z;
				}
				this2[j] = val1;
				if(g.classSubclasses[j] != 0) {
					let this1 = g.classMasterbooks;
					let val;
					if(decodeState.validBits < 0) {
						val = 0;
					} else if(decodeState.validBits < 8) {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						} while(decodeState.validBits < 8);
						if(decodeState.validBits < 0) {
							val = 0;
						} else {
							let z = decodeState.acc & 255;
							decodeState.acc = decodeState.acc >>> 8;
							decodeState.validBits -= 8;
							val = z;
						}
					} else {
						let z = decodeState.acc & 255;
						decodeState.acc = decodeState.acc >>> 8;
						decodeState.validBits -= 8;
						val = z;
					}
					this1[j] = val;
					if(g.classMasterbooks[j] >= codebooks.length) {
						throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Floor.hx", lineNumber : 64, className : "stb.format.vorbis.data.Floor", methodName : "read"}));
					}
				}
				let kl = 1 << g.classSubclasses[j];
				g.subclassBooks[j] = new Array(kl);
				let _g = 0;
				while(_g < kl) {
					let k = _g++;
					let this1 = g.subclassBooks[j];
					let val;
					if(decodeState.validBits < 0) {
						val = 0;
					} else if(decodeState.validBits < 8) {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						} while(decodeState.validBits < 8);
						if(decodeState.validBits < 0) {
							val = 0;
						} else {
							let z = decodeState.acc & 255;
							decodeState.acc = decodeState.acc >>> 8;
							decodeState.validBits -= 8;
							val = z;
						}
					} else {
						let z = decodeState.acc & 255;
						decodeState.acc = decodeState.acc >>> 8;
						decodeState.validBits -= 8;
						val = z;
					}
					this1[k] = val - 1;
					if(g.subclassBooks[j][k] >= codebooks.length) {
						throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Floor.hx", lineNumber : 73, className : "stb.format.vorbis.data.Floor", methodName : "read"}));
					}
				}
			}
			let tmp1;
			if(decodeState.validBits < 0) {
				tmp1 = 0;
			} else if(decodeState.validBits < 2) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 2);
				if(decodeState.validBits < 0) {
					tmp1 = 0;
				} else {
					let z = decodeState.acc & 3;
					decodeState.acc = decodeState.acc >>> 2;
					decodeState.validBits -= 2;
					tmp1 = z;
				}
			} else {
				let z = decodeState.acc & 3;
				decodeState.acc = decodeState.acc >>> 2;
				decodeState.validBits -= 2;
				tmp1 = z;
			}
			g.floor1Multiplier = tmp1 + 1;
			let tmp2;
			if(decodeState.validBits < 0) {
				tmp2 = 0;
			} else if(decodeState.validBits < 4) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 4);
				if(decodeState.validBits < 0) {
					tmp2 = 0;
				} else {
					let z = decodeState.acc & 15;
					decodeState.acc = decodeState.acc >>> 4;
					decodeState.validBits -= 4;
					tmp2 = z;
				}
			} else {
				let z = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp2 = z;
			}
			g.rangebits = tmp2;
			g.xlist = new Array(250);
			g.xlist[0] = 0;
			g.xlist[1] = 1 << g.rangebits;
			g.values = 2;
			let _g4 = 0;
			let _g5 = g.partitions;
			while(_g4 < _g5) {
				let j = _g4++;
				let c = g.partitionClassList[j];
				let _g = 0;
				let _g1 = g.classDimensions[c];
				while(_g < _g1) {
					++_g;
					let this1 = g.xlist;
					let index = g.values;
					let n = g.rangebits;
					let val;
					if(decodeState.validBits < 0) {
						val = 0;
					} else if(decodeState.validBits < n) {
						if(n > 24) {
							let val1;
							if(decodeState.validBits < 0) {
								val1 = 0;
							} else if(decodeState.validBits < 24) {
								if(decodeState.validBits == 0) {
									decodeState.acc = 0;
								}
								do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
									decodeState.validBits = -1;
									break;
								} else {
									decodeState.bytesInSeg--;
									decodeState.inputPosition += 1;
									decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
									decodeState.validBits += 8;
								} while(decodeState.validBits < 24);
								if(decodeState.validBits < 0) {
									val1 = 0;
								} else {
									let z = decodeState.acc & 16777215;
									decodeState.acc = decodeState.acc >>> 24;
									decodeState.validBits -= 24;
									val1 = z;
								}
							} else {
								let z = decodeState.acc & 16777215;
								decodeState.acc = decodeState.acc >>> 24;
								decodeState.validBits -= 24;
								val1 = z;
							}
							let n1 = n - 24;
							let val2;
							if(decodeState.validBits < 0) {
								val2 = 0;
							} else if(decodeState.validBits < n1) {
								if(n1 > 24) {
									let val;
									if(decodeState.validBits < 0) {
										val = 0;
									} else if(decodeState.validBits < 24) {
										if(decodeState.validBits == 0) {
											decodeState.acc = 0;
										}
										do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
											decodeState.validBits = -1;
											break;
										} else {
											decodeState.bytesInSeg--;
											decodeState.inputPosition += 1;
											decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
											decodeState.validBits += 8;
										} while(decodeState.validBits < 24);
										if(decodeState.validBits < 0) {
											val = 0;
										} else {
											let z = decodeState.acc & 16777215;
											decodeState.acc = decodeState.acc >>> 24;
											decodeState.validBits -= 24;
											val = z;
										}
									} else {
										let z = decodeState.acc & 16777215;
										decodeState.acc = decodeState.acc >>> 24;
										decodeState.validBits -= 24;
										val = z;
									}
									let n = n1 - 24;
									let val1;
									if(decodeState.validBits < 0) {
										val1 = 0;
									} else if(decodeState.validBits < n) {
										if(n > 24) {
											val1 = decodeState.readBits(24) + (decodeState.readBits(n - 24) << 24);
										} else {
											if(decodeState.validBits == 0) {
												decodeState.acc = 0;
											}
											do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
												decodeState.validBits = -1;
												break;
											} else {
												decodeState.bytesInSeg--;
												decodeState.inputPosition += 1;
												decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
												decodeState.validBits += 8;
											} while(decodeState.validBits < n);
											if(decodeState.validBits < 0) {
												val1 = 0;
											} else {
												let z = decodeState.acc & (1 << n) - 1;
												decodeState.acc = decodeState.acc >>> n;
												decodeState.validBits -= n;
												val1 = z;
											}
										}
									} else {
										let z = decodeState.acc & (1 << n) - 1;
										decodeState.acc = decodeState.acc >>> n;
										decodeState.validBits -= n;
										val1 = z;
									}
									val2 = val + (val1 << 24);
								} else {
									if(decodeState.validBits == 0) {
										decodeState.acc = 0;
									}
									do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
										decodeState.validBits = -1;
										break;
									} else {
										decodeState.bytesInSeg--;
										decodeState.inputPosition += 1;
										decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
										decodeState.validBits += 8;
									} while(decodeState.validBits < n1);
									if(decodeState.validBits < 0) {
										val2 = 0;
									} else {
										let z = decodeState.acc & (1 << n1) - 1;
										decodeState.acc = decodeState.acc >>> n1;
										decodeState.validBits -= n1;
										val2 = z;
									}
								}
							} else {
								let z = decodeState.acc & (1 << n1) - 1;
								decodeState.acc = decodeState.acc >>> n1;
								decodeState.validBits -= n1;
								val2 = z;
							}
							val = val1 + (val2 << 24);
						} else {
							if(decodeState.validBits == 0) {
								decodeState.acc = 0;
							}
							do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
								decodeState.validBits = -1;
								break;
							} else {
								decodeState.bytesInSeg--;
								decodeState.inputPosition += 1;
								decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
								decodeState.validBits += 8;
							} while(decodeState.validBits < n);
							if(decodeState.validBits < 0) {
								val = 0;
							} else {
								let z = decodeState.acc & (1 << n) - 1;
								decodeState.acc = decodeState.acc >>> n;
								decodeState.validBits -= n;
								val = z;
							}
						}
					} else {
						let z = decodeState.acc & (1 << n) - 1;
						decodeState.acc = decodeState.acc >>> n;
						decodeState.validBits -= n;
						val = z;
					}
					this1[index] = val;
					g.values++;
				}
			}
			let _g6 = 0;
			let _g7 = g.values;
			while(_g6 < _g7) {
				let j = _g6++;
				p.push(new stb_format_vorbis_data_IntPoint());
				p[j].x = g.xlist[j];
				p[j].y = j;
			}
			p.sort(stb_format_vorbis_VorbisTools.pointCompare);
			g.sortedOrder = new Array(g.values);
			let _g8 = 0;
			let _g9 = g.values;
			while(_g8 < _g9) {
				let j = _g8++;
				g.sortedOrder[j] = p[j].y;
			}
			g.neighbors = new Array(g.values);
			let _g10 = 2;
			let _g11 = g.values;
			while(_g10 < _g11) {
				let j = _g10++;
				let x = g.xlist;
				let low = -1;
				let high = 65536;
				let plow = 0;
				let phigh = 0;
				let _g = 0;
				while(_g < j) {
					let i = _g++;
					if(x[i] > low && x[i] < x[j]) {
						plow = i;
						low = x[i];
					}
					if(x[i] < high && x[i] > x[j]) {
						phigh = i;
						high = x[i];
					}
				}
				let ne_low = plow;
				let ne_high = phigh;
				g.neighbors[j] = new Array(g.values);
				g.neighbors[j][0] = ne_low;
				g.neighbors[j][1] = ne_high;
			}
		}
		return floor;
	}
}
$hxClasses["stb.format.vorbis.data.Floor"] = stb_format_vorbis_data_Floor;
stb_format_vorbis_data_Floor.__name__ = "stb.format.vorbis.data.Floor";
Object.assign(stb_format_vorbis_data_Floor.prototype, {
	__class__: stb_format_vorbis_data_Floor
	,floor0: null
	,floor1: null
	,type: null
});
class stb_format_vorbis_data_Floor0 {
	constructor() {
	}
}
$hxClasses["stb.format.vorbis.data.Floor0"] = stb_format_vorbis_data_Floor0;
stb_format_vorbis_data_Floor0.__name__ = "stb.format.vorbis.data.Floor0";
Object.assign(stb_format_vorbis_data_Floor0.prototype, {
	__class__: stb_format_vorbis_data_Floor0
	,order: null
	,rate: null
	,barkMapSize: null
	,amplitudeBits: null
	,amplitudeOffset: null
	,numberOfBooks: null
	,bookList: null
});
class stb_format_vorbis_data_Floor1 {
	constructor() {
	}
}
$hxClasses["stb.format.vorbis.data.Floor1"] = stb_format_vorbis_data_Floor1;
stb_format_vorbis_data_Floor1.__name__ = "stb.format.vorbis.data.Floor1";
Object.assign(stb_format_vorbis_data_Floor1.prototype, {
	__class__: stb_format_vorbis_data_Floor1
	,partitions: null
	,partitionClassList: null
	,classDimensions: null
	,classSubclasses: null
	,classMasterbooks: null
	,subclassBooks: null
	,xlist: null
	,sortedOrder: null
	,neighbors: null
	,floor1Multiplier: null
	,rangebits: null
	,values: null
});
class stb_format_vorbis_data_Header {
	constructor() {
	}
	static read(decodeState) {
		let page = decodeState.page;
		page.start(decodeState);
		if((page.flag & 2) == 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"not firstPage",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 46, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
		if((page.flag & 4) != 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"lastPage",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 49, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
		if((page.flag & 1) != 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"continuedPacket",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 52, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
		decodeState.firstPageValidate();
		decodeState.inputPosition += 1;
		if(decodeState.input.readByte() != 1) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"decodeState head",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 57, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
		let header = new haxe_io_Bytes(new ArrayBuffer(6));
		let x;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header.b[0] = x;
		let x1;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x1 = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x1 = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header.b[1] = x1;
		let x2;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x2 = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x2 = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header.b[2] = x2;
		let x3;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x3 = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x3 = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header.b[3] = x3;
		let x4;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x4 = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x4 = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header.b[4] = x4;
		let x5;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x5 = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x5 = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header.b[5] = x5;
		if(header.toString() != "vorbis") {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"vorbis header",{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 300, className : "stb.format.vorbis.VorbisDecodeState", methodName : "vorbisValidate"}));
		}
		decodeState.inputPosition += 4;
		let version = decodeState.input.readInt32();
		if(version != 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"vorbis version : " + version,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 66, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
		let header1 = new stb_format_vorbis_data_Header();
		decodeState.inputPosition += 1;
		header1.channel = decodeState.input.readByte();
		if(header1.channel == 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"no channel",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 73, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		} else if(header1.channel > 16) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.TOO_MANY_CHANNELS,"too many channels",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 75, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
		decodeState.inputPosition += 4;
		header1.sampleRate = decodeState.input.readInt32();
		if(header1.sampleRate == 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,"no sampling rate",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 80, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
		decodeState.inputPosition += 4;
		header1.maximumBitRate = decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		header1.nominalBitRate = decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		header1.minimumBitRate = decodeState.input.readInt32();
		decodeState.inputPosition += 1;
		let x6 = decodeState.input.readByte();
		let log0 = x6 & 15;
		let log1 = x6 >> 4;
		header1.blocksize0 = 1 << log0;
		header1.blocksize1 = 1 << log1;
		if(log0 < 6 || log0 > 13) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 93, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
		if(log1 < 6 || log1 > 13) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 96, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
		if(log0 > log1) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 99, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
		decodeState.inputPosition += 1;
		let x7 = decodeState.input.readByte();
		if((x7 & 1) == 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 105, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
		decodeState.page.start(decodeState);
		decodeState.startPacket();
		let len = 0;
		let output = new haxe_io_BytesOutput();
		while(true) {
			len = decodeState.next();
			if(!(len != 0)) {
				break;
			}
			decodeState.inputPosition += len;
			output.write(decodeState.input.read(len));
			decodeState.bytesInSeg = 0;
		}
		let packetInput = new haxe_io_BytesInput(output.getBytes());
		packetInput.readByte();
		packetInput.read(6);
		let vendorLength = packetInput.readInt32();
		header1.vendor = packetInput.readString(vendorLength);
		header1.comment = new stb_format_vorbis_data_Comment();
		let commentCount = packetInput.readInt32();
		let _g = 0;
		while(_g < commentCount) {
			++_g;
			let n = packetInput.readInt32();
			let str = packetInput.readString(n);
			let splitter = str.indexOf("=");
			if(splitter != -1) {
				header1.comment.add(str.substring(0,splitter),str.substring(splitter + 1));
			}
		}
		let x8 = packetInput.readByte();
		if((x8 & 1) == 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 141, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
		decodeState.startPacket();
		let x9;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x9 = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x9 = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		if(x9 != 5) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"setup packet",{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 149, className : "stb.format.vorbis.data.Header", methodName : "read"}));
		}
		let header2 = new haxe_io_Bytes(new ArrayBuffer(6));
		let x10;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x10 = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x10 = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header2.b[0] = x10;
		let x11;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x11 = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x11 = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header2.b[1] = x11;
		let x12;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x12 = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x12 = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header2.b[2] = x12;
		let x13;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x13 = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x13 = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header2.b[3] = x13;
		let x14;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x14 = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x14 = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header2.b[4] = x14;
		let x15;
		if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
			x15 = -1;
		} else {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			x15 = decodeState.input.readByte();
		}
		decodeState.validBits = 0;
		header2.b[5] = x15;
		if(header2.toString() != "vorbis") {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"vorbis header",{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 300, className : "stb.format.vorbis.VorbisDecodeState", methodName : "vorbisValidate"}));
		}
		let codebookCount;
		if(decodeState.validBits < 0) {
			codebookCount = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 8);
			if(decodeState.validBits < 0) {
				codebookCount = 0;
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				codebookCount = z;
			}
		} else {
			let z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			codebookCount = z;
		}
		let codebookCount1 = codebookCount + 1;
		header1.codebooks = new Array(codebookCount1);
		let _g1 = 0;
		while(_g1 < codebookCount1) {
			let i = _g1++;
			header1.codebooks[i] = stb_format_vorbis_data_Codebook.read(decodeState);
		}
		let x16;
		if(decodeState.validBits < 0) {
			x16 = 0;
		} else if(decodeState.validBits < 6) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 6);
			if(decodeState.validBits < 0) {
				x16 = 0;
			} else {
				let z = decodeState.acc & 63;
				decodeState.acc = decodeState.acc >>> 6;
				decodeState.validBits -= 6;
				x16 = z;
			}
		} else {
			let z = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			x16 = z;
		}
		x7 = x16 + 1;
		let _g2 = 0;
		let _g3 = x7;
		while(_g2 < _g3) {
			++_g2;
			let tmp;
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else if(decodeState.validBits < 16) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 16);
				if(decodeState.validBits < 0) {
					tmp = 0;
				} else {
					let z = decodeState.acc & 65535;
					decodeState.acc = decodeState.acc >>> 16;
					decodeState.validBits -= 16;
					tmp = z;
				}
			} else {
				let z = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				tmp = z;
			}
			if(tmp != 0) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 165, className : "stb.format.vorbis.data.Header", methodName : "read"}));
			}
		}
		let floorCount;
		if(decodeState.validBits < 0) {
			floorCount = 0;
		} else if(decodeState.validBits < 6) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 6);
			if(decodeState.validBits < 0) {
				floorCount = 0;
			} else {
				let z = decodeState.acc & 63;
				decodeState.acc = decodeState.acc >>> 6;
				decodeState.validBits -= 6;
				floorCount = z;
			}
		} else {
			let z = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			floorCount = z;
		}
		let floorCount1 = floorCount + 1;
		header1.floorConfig = new Array(floorCount1);
		let _g4 = 0;
		while(_g4 < floorCount1) {
			let i = _g4++;
			header1.floorConfig[i] = stb_format_vorbis_data_Floor.read(decodeState,header1.codebooks);
		}
		let residueCount;
		if(decodeState.validBits < 0) {
			residueCount = 0;
		} else if(decodeState.validBits < 6) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 6);
			if(decodeState.validBits < 0) {
				residueCount = 0;
			} else {
				let z = decodeState.acc & 63;
				decodeState.acc = decodeState.acc >>> 6;
				decodeState.validBits -= 6;
				residueCount = z;
			}
		} else {
			let z = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			residueCount = z;
		}
		let residueCount1 = residueCount + 1;
		header1.residueConfig = new Array(residueCount1);
		let _g5 = 0;
		while(_g5 < residueCount1) {
			let i = _g5++;
			header1.residueConfig[i] = stb_format_vorbis_data_Residue.read(decodeState,header1.codebooks);
		}
		let mappingCount;
		if(decodeState.validBits < 0) {
			mappingCount = 0;
		} else if(decodeState.validBits < 6) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 6);
			if(decodeState.validBits < 0) {
				mappingCount = 0;
			} else {
				let z = decodeState.acc & 63;
				decodeState.acc = decodeState.acc >>> 6;
				decodeState.validBits -= 6;
				mappingCount = z;
			}
		} else {
			let z = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			mappingCount = z;
		}
		let mappingCount1 = mappingCount + 1;
		header1.mapping = new Array(mappingCount1);
		let _g6 = 0;
		while(_g6 < mappingCount1) {
			let i = _g6++;
			let map = stb_format_vorbis_data_Mapping.read(decodeState,header1.channel);
			header1.mapping[i] = map;
			let _g = 0;
			let _g1 = map.submaps;
			while(_g < _g1) {
				let j = _g++;
				if(map.submapFloor[j] >= header1.floorConfig.length) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 191, className : "stb.format.vorbis.data.Header", methodName : "read"}));
				}
				if(map.submapResidue[j] >= header1.residueConfig.length) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 194, className : "stb.format.vorbis.data.Header", methodName : "read"}));
				}
			}
		}
		let modeCount;
		if(decodeState.validBits < 0) {
			modeCount = 0;
		} else if(decodeState.validBits < 6) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 6);
			if(decodeState.validBits < 0) {
				modeCount = 0;
			} else {
				let z = decodeState.acc & 63;
				decodeState.acc = decodeState.acc >>> 6;
				decodeState.validBits -= 6;
				modeCount = z;
			}
		} else {
			let z = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			modeCount = z;
		}
		let modeCount1 = modeCount + 1;
		header1.modes = new Array(modeCount1);
		let _g7 = 0;
		while(_g7 < modeCount1) {
			let i = _g7++;
			let mode = stb_format_vorbis_data_Mode.read(decodeState);
			header1.modes[i] = mode;
			if(mode.mapping >= header1.mapping.length) {
				throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Header.hx", lineNumber : 205, className : "stb.format.vorbis.data.Header", methodName : "read"}));
			}
		}
		while(decodeState.bytesInSeg != 0 || !decodeState.lastSeg && decodeState.next() != 0) {
			decodeState.bytesInSeg--;
			decodeState.inputPosition += 1;
			decodeState.input.readByte();
		}
		return header1;
	}
}
$hxClasses["stb.format.vorbis.data.Header"] = stb_format_vorbis_data_Header;
stb_format_vorbis_data_Header.__name__ = "stb.format.vorbis.data.Header";
Object.assign(stb_format_vorbis_data_Header.prototype, {
	__class__: stb_format_vorbis_data_Header
	,maximumBitRate: null
	,nominalBitRate: null
	,minimumBitRate: null
	,sampleRate: null
	,channel: null
	,blocksize0: null
	,blocksize1: null
	,codebooks: null
	,floorConfig: null
	,residueConfig: null
	,mapping: null
	,modes: null
	,comment: null
	,vendor: null
});
class stb_format_vorbis_data_IntPoint {
	constructor() {
	}
}
$hxClasses["stb.format.vorbis.data.IntPoint"] = stb_format_vorbis_data_IntPoint;
stb_format_vorbis_data_IntPoint.__name__ = "stb.format.vorbis.data.IntPoint";
Object.assign(stb_format_vorbis_data_IntPoint.prototype, {
	__class__: stb_format_vorbis_data_IntPoint
	,x: null
	,y: null
});
class stb_format_vorbis_data_Mapping {
	constructor() {
	}
	doFloor(floors,i,n,target,finalY,step2Flag) {
		let n2 = n >> 1;
		let s = this.chan[i].mux;
		let floor = floors[this.submapFloor[s]];
		if(floor.type == 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,null,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 94, className : "stb.format.vorbis.data.Mapping", methodName : "doFloor"}));
		} else {
			let g = floor.floor1;
			let lx = 0;
			let ly = finalY[0] * g.floor1Multiplier;
			let _g = 1;
			let _g1 = g.values;
			while(_g < _g1) {
				let q = _g++;
				let j = g.sortedOrder[q];
				if(finalY[j] >= 0) {
					let hy = finalY[j] * g.floor1Multiplier;
					let hx = g.xlist[j];
					stb_format_vorbis_VorbisTools.drawLine(target,lx,ly,hx,hy,n2);
					lx = hx;
					ly = hy;
				}
			}
			if(lx < n2) {
				let _g = lx;
				while(_g < n2) {
					let j = _g++;
					target[j] *= stb_format_vorbis_VorbisTools.INVERSE_DB_TABLE[ly];
				}
			}
		}
	}
	static read(decodeState,channels) {
		let m = new stb_format_vorbis_data_Mapping();
		let mappingType;
		if(decodeState.validBits < 0) {
			mappingType = 0;
		} else if(decodeState.validBits < 16) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 16);
			if(decodeState.validBits < 0) {
				mappingType = 0;
			} else {
				let z = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				mappingType = z;
			}
		} else {
			let z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			mappingType = z;
		}
		if(mappingType != 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,"mapping type " + mappingType,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 22, className : "stb.format.vorbis.data.Mapping", methodName : "read"}));
		}
		m.chan = new Array(channels);
		let _g = 0;
		while(_g < channels) {
			let j = _g++;
			m.chan[j] = new stb_format_vorbis_data_MappingChannel();
		}
		let tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 1) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 1);
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				let z = decodeState.acc & 1;
				decodeState.acc = decodeState.acc >>> 1;
				decodeState.validBits -= 1;
				tmp = z;
			}
		} else {
			let z = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp = z;
		}
		if(tmp != 0) {
			let tmp;
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else if(decodeState.validBits < 4) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 4);
				if(decodeState.validBits < 0) {
					tmp = 0;
				} else {
					let z = decodeState.acc & 15;
					decodeState.acc = decodeState.acc >>> 4;
					decodeState.validBits -= 4;
					tmp = z;
				}
			} else {
				let z = decodeState.acc & 15;
				decodeState.acc = decodeState.acc >>> 4;
				decodeState.validBits -= 4;
				tmp = z;
			}
			m.submaps = tmp + 1;
		} else {
			m.submaps = 1;
		}
		let tmp1;
		if(decodeState.validBits < 0) {
			tmp1 = 0;
		} else if(decodeState.validBits < 1) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 1);
			if(decodeState.validBits < 0) {
				tmp1 = 0;
			} else {
				let z = decodeState.acc & 1;
				decodeState.acc = decodeState.acc >>> 1;
				decodeState.validBits -= 1;
				tmp1 = z;
			}
		} else {
			let z = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp1 = z;
		}
		if(tmp1 != 0) {
			let tmp;
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else if(decodeState.validBits < 8) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 8);
				if(decodeState.validBits < 0) {
					tmp = 0;
				} else {
					let z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					tmp = z;
				}
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp = z;
			}
			m.couplingSteps = tmp + 1;
			let _g = 0;
			let _g1 = m.couplingSteps;
			while(_g < _g1) {
				let k = _g++;
				let n = channels - 1;
				let log2_4 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
				let n1 = n < 16384 ? n < 16 ? log2_4[n] : n < 512 ? 5 + log2_4[n >> 5] : 10 + log2_4[n >> 10] : n < 16777216 ? n < 524288 ? 15 + log2_4[n >> 15] : 20 + log2_4[n >> 20] : n < 536870912 ? 25 + log2_4[n >> 25] : n < -2147483648 ? 30 + log2_4[n >> 30] : 0;
				let tmp;
				if(decodeState.validBits < 0) {
					tmp = 0;
				} else if(decodeState.validBits < n1) {
					if(n1 > 24) {
						let tmp1;
						if(decodeState.validBits < 0) {
							tmp1 = 0;
						} else if(decodeState.validBits < 24) {
							if(decodeState.validBits == 0) {
								decodeState.acc = 0;
							}
							do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
								decodeState.validBits = -1;
								break;
							} else {
								decodeState.bytesInSeg--;
								decodeState.inputPosition += 1;
								decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
								decodeState.validBits += 8;
							} while(decodeState.validBits < 24);
							if(decodeState.validBits < 0) {
								tmp1 = 0;
							} else {
								let z = decodeState.acc & 16777215;
								decodeState.acc = decodeState.acc >>> 24;
								decodeState.validBits -= 24;
								tmp1 = z;
							}
						} else {
							let z = decodeState.acc & 16777215;
							decodeState.acc = decodeState.acc >>> 24;
							decodeState.validBits -= 24;
							tmp1 = z;
						}
						let n = n1 - 24;
						let tmp2;
						if(decodeState.validBits < 0) {
							tmp2 = 0;
						} else if(decodeState.validBits < n) {
							if(n > 24) {
								tmp2 = decodeState.readBits(24) + (decodeState.readBits(n - 24) << 24);
							} else {
								if(decodeState.validBits == 0) {
									decodeState.acc = 0;
								}
								do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
									decodeState.validBits = -1;
									break;
								} else {
									decodeState.bytesInSeg--;
									decodeState.inputPosition += 1;
									decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
									decodeState.validBits += 8;
								} while(decodeState.validBits < n);
								if(decodeState.validBits < 0) {
									tmp2 = 0;
								} else {
									let z = decodeState.acc & (1 << n) - 1;
									decodeState.acc = decodeState.acc >>> n;
									decodeState.validBits -= n;
									tmp2 = z;
								}
							}
						} else {
							let z = decodeState.acc & (1 << n) - 1;
							decodeState.acc = decodeState.acc >>> n;
							decodeState.validBits -= n;
							tmp2 = z;
						}
						tmp = tmp1 + (tmp2 << 24);
					} else {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						} while(decodeState.validBits < n1);
						if(decodeState.validBits < 0) {
							tmp = 0;
						} else {
							let z = decodeState.acc & (1 << n1) - 1;
							decodeState.acc = decodeState.acc >>> n1;
							decodeState.validBits -= n1;
							tmp = z;
						}
					}
				} else {
					let z = decodeState.acc & (1 << n1) - 1;
					decodeState.acc = decodeState.acc >>> n1;
					decodeState.validBits -= n1;
					tmp = z;
				}
				m.chan[k].magnitude = tmp;
				let n2 = channels - 1;
				let log2_41 = [0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4];
				let n3 = n2 < 16384 ? n2 < 16 ? log2_41[n2] : n2 < 512 ? 5 + log2_41[n2 >> 5] : 10 + log2_41[n2 >> 10] : n2 < 16777216 ? n2 < 524288 ? 15 + log2_41[n2 >> 15] : 20 + log2_41[n2 >> 20] : n2 < 536870912 ? 25 + log2_41[n2 >> 25] : n2 < -2147483648 ? 30 + log2_41[n2 >> 30] : 0;
				let tmp1;
				if(decodeState.validBits < 0) {
					tmp1 = 0;
				} else if(decodeState.validBits < n3) {
					if(n3 > 24) {
						let tmp;
						if(decodeState.validBits < 0) {
							tmp = 0;
						} else if(decodeState.validBits < 24) {
							if(decodeState.validBits == 0) {
								decodeState.acc = 0;
							}
							do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
								decodeState.validBits = -1;
								break;
							} else {
								decodeState.bytesInSeg--;
								decodeState.inputPosition += 1;
								decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
								decodeState.validBits += 8;
							} while(decodeState.validBits < 24);
							if(decodeState.validBits < 0) {
								tmp = 0;
							} else {
								let z = decodeState.acc & 16777215;
								decodeState.acc = decodeState.acc >>> 24;
								decodeState.validBits -= 24;
								tmp = z;
							}
						} else {
							let z = decodeState.acc & 16777215;
							decodeState.acc = decodeState.acc >>> 24;
							decodeState.validBits -= 24;
							tmp = z;
						}
						let n = n3 - 24;
						let tmp2;
						if(decodeState.validBits < 0) {
							tmp2 = 0;
						} else if(decodeState.validBits < n) {
							if(n > 24) {
								tmp2 = decodeState.readBits(24) + (decodeState.readBits(n - 24) << 24);
							} else {
								if(decodeState.validBits == 0) {
									decodeState.acc = 0;
								}
								do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
									decodeState.validBits = -1;
									break;
								} else {
									decodeState.bytesInSeg--;
									decodeState.inputPosition += 1;
									decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
									decodeState.validBits += 8;
								} while(decodeState.validBits < n);
								if(decodeState.validBits < 0) {
									tmp2 = 0;
								} else {
									let z = decodeState.acc & (1 << n) - 1;
									decodeState.acc = decodeState.acc >>> n;
									decodeState.validBits -= n;
									tmp2 = z;
								}
							}
						} else {
							let z = decodeState.acc & (1 << n) - 1;
							decodeState.acc = decodeState.acc >>> n;
							decodeState.validBits -= n;
							tmp2 = z;
						}
						tmp1 = tmp + (tmp2 << 24);
					} else {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						} while(decodeState.validBits < n3);
						if(decodeState.validBits < 0) {
							tmp1 = 0;
						} else {
							let z = decodeState.acc & (1 << n3) - 1;
							decodeState.acc = decodeState.acc >>> n3;
							decodeState.validBits -= n3;
							tmp1 = z;
						}
					}
				} else {
					let z = decodeState.acc & (1 << n3) - 1;
					decodeState.acc = decodeState.acc >>> n3;
					decodeState.validBits -= n3;
					tmp1 = z;
				}
				m.chan[k].angle = tmp1;
				if(m.chan[k].magnitude >= channels) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 46, className : "stb.format.vorbis.data.Mapping", methodName : "read"}));
				}
				if(m.chan[k].angle >= channels) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 49, className : "stb.format.vorbis.data.Mapping", methodName : "read"}));
				}
				if(m.chan[k].magnitude == m.chan[k].angle) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 52, className : "stb.format.vorbis.data.Mapping", methodName : "read"}));
				}
			}
		} else {
			m.couplingSteps = 0;
		}
		let tmp2;
		if(decodeState.validBits < 0) {
			tmp2 = 0;
		} else if(decodeState.validBits < 2) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 2);
			if(decodeState.validBits < 0) {
				tmp2 = 0;
			} else {
				let z = decodeState.acc & 3;
				decodeState.acc = decodeState.acc >>> 2;
				decodeState.validBits -= 2;
				tmp2 = z;
			}
		} else {
			let z = decodeState.acc & 3;
			decodeState.acc = decodeState.acc >>> 2;
			decodeState.validBits -= 2;
			tmp2 = z;
		}
		if(tmp2 != 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 61, className : "stb.format.vorbis.data.Mapping", methodName : "read"}));
		}
		if(m.submaps > 1) {
			let _g = 0;
			while(_g < channels) {
				let j = _g++;
				let tmp;
				if(decodeState.validBits < 0) {
					tmp = 0;
				} else if(decodeState.validBits < 4) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					} while(decodeState.validBits < 4);
					if(decodeState.validBits < 0) {
						tmp = 0;
					} else {
						let z = decodeState.acc & 15;
						decodeState.acc = decodeState.acc >>> 4;
						decodeState.validBits -= 4;
						tmp = z;
					}
				} else {
					let z = decodeState.acc & 15;
					decodeState.acc = decodeState.acc >>> 4;
					decodeState.validBits -= 4;
					tmp = z;
				}
				m.chan[j].mux = tmp;
				if(m.chan[j].mux >= m.submaps) {
					throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mapping.hx", lineNumber : 67, className : "stb.format.vorbis.data.Mapping", methodName : "read"}));
				}
			}
		} else {
			let _g = 0;
			while(_g < channels) {
				let j = _g++;
				m.chan[j].mux = 0;
			}
		}
		m.submapFloor = new Array(m.submaps);
		m.submapResidue = new Array(m.submaps);
		let _g1 = 0;
		let _g2 = m.submaps;
		while(_g1 < _g2) {
			let j = _g1++;
			if(decodeState.validBits >= 0) {
				if(decodeState.validBits < 8) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					} while(decodeState.validBits < 8);
					if(decodeState.validBits >= 0) {
						decodeState.acc = decodeState.acc >>> 8;
						decodeState.validBits -= 8;
					}
				} else {
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
				}
			}
			let this1 = m.submapFloor;
			let val;
			if(decodeState.validBits < 0) {
				val = 0;
			} else if(decodeState.validBits < 8) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 8);
				if(decodeState.validBits < 0) {
					val = 0;
				} else {
					let z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					val = z;
				}
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				val = z;
			}
			this1[j] = val;
			let this2 = m.submapResidue;
			let val1;
			if(decodeState.validBits < 0) {
				val1 = 0;
			} else if(decodeState.validBits < 8) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 8);
				if(decodeState.validBits < 0) {
					val1 = 0;
				} else {
					let z = decodeState.acc & 255;
					decodeState.acc = decodeState.acc >>> 8;
					decodeState.validBits -= 8;
					val1 = z;
				}
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				val1 = z;
			}
			this2[j] = val1;
		}
		return m;
	}
}
$hxClasses["stb.format.vorbis.data.Mapping"] = stb_format_vorbis_data_Mapping;
stb_format_vorbis_data_Mapping.__name__ = "stb.format.vorbis.data.Mapping";
Object.assign(stb_format_vorbis_data_Mapping.prototype, {
	__class__: stb_format_vorbis_data_Mapping
	,couplingSteps: null
	,chan: null
	,submaps: null
	,submapFloor: null
	,submapResidue: null
});
class stb_format_vorbis_data_MappingChannel {
	constructor() {
	}
}
$hxClasses["stb.format.vorbis.data.MappingChannel"] = stb_format_vorbis_data_MappingChannel;
stb_format_vorbis_data_MappingChannel.__name__ = "stb.format.vorbis.data.MappingChannel";
Object.assign(stb_format_vorbis_data_MappingChannel.prototype, {
	__class__: stb_format_vorbis_data_MappingChannel
	,magnitude: null
	,angle: null
	,mux: null
});
class stb_format_vorbis_data_Mode {
	constructor() {
	}
	static read(decodeState) {
		let m = new stb_format_vorbis_data_Mode();
		let tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 1) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 1);
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				let z = decodeState.acc & 1;
				decodeState.acc = decodeState.acc >>> 1;
				decodeState.validBits -= 1;
				tmp = z;
			}
		} else {
			let z = decodeState.acc & 1;
			decodeState.acc = decodeState.acc >>> 1;
			decodeState.validBits -= 1;
			tmp = z;
		}
		m.blockflag = tmp != 0;
		let tmp1;
		if(decodeState.validBits < 0) {
			tmp1 = 0;
		} else if(decodeState.validBits < 16) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 16);
			if(decodeState.validBits < 0) {
				tmp1 = 0;
			} else {
				let z = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				tmp1 = z;
			}
		} else {
			let z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp1 = z;
		}
		m.windowtype = tmp1;
		let tmp2;
		if(decodeState.validBits < 0) {
			tmp2 = 0;
		} else if(decodeState.validBits < 16) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 16);
			if(decodeState.validBits < 0) {
				tmp2 = 0;
			} else {
				let z = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				tmp2 = z;
			}
		} else {
			let z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp2 = z;
		}
		m.transformtype = tmp2;
		let tmp3;
		if(decodeState.validBits < 0) {
			tmp3 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 8);
			if(decodeState.validBits < 0) {
				tmp3 = 0;
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp3 = z;
			}
		} else {
			let z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp3 = z;
		}
		m.mapping = tmp3;
		if(m.windowtype != 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mode.hx", lineNumber : 22, className : "stb.format.vorbis.data.Mode", methodName : "read"}));
		}
		if(m.transformtype != 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Mode.hx", lineNumber : 25, className : "stb.format.vorbis.data.Mode", methodName : "read"}));
		}
		return m;
	}
}
$hxClasses["stb.format.vorbis.data.Mode"] = stb_format_vorbis_data_Mode;
stb_format_vorbis_data_Mode.__name__ = "stb.format.vorbis.data.Mode";
Object.assign(stb_format_vorbis_data_Mode.prototype, {
	__class__: stb_format_vorbis_data_Mode
	,blockflag: null
	,mapping: null
	,windowtype: null
	,transformtype: null
});
class stb_format_vorbis_data_Page {
	constructor() {
	}
	clone() {
		let page = new stb_format_vorbis_data_Page();
		page.flag = this.flag;
		return page;
	}
	start(decodeState) {
		let tmp;
		let tmp1;
		let tmp2;
		decodeState.inputPosition += 1;
		if(decodeState.input.readByte() == 79) {
			decodeState.inputPosition += 1;
			tmp2 = decodeState.input.readByte() != 103;
		} else {
			tmp2 = true;
		}
		if(!tmp2) {
			decodeState.inputPosition += 1;
			tmp1 = decodeState.input.readByte() != 103;
		} else {
			tmp1 = true;
		}
		if(!tmp1) {
			decodeState.inputPosition += 1;
			tmp = decodeState.input.readByte() != 83;
		} else {
			tmp = true;
		}
		if(tmp) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,null,{ fileName : "stb/format/vorbis/VorbisDecodeState.hx", lineNumber : 323, className : "stb.format.vorbis.VorbisDecodeState", methodName : "capturePattern"}));
		}
		this.startWithoutCapturePattern(decodeState);
	}
	startWithoutCapturePattern(decodeState) {
		decodeState.inputPosition += 1;
		let version = decodeState.input.readByte();
		if(version != 0) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM_STRUCTURE_VERSION,"" + version,{ fileName : "stb/format/vorbis/data/Page.hx", lineNumber : 34, className : "stb.format.vorbis.data.Page", methodName : "startWithoutCapturePattern"}));
		}
		decodeState.inputPosition += 1;
		this.flag = decodeState.input.readByte();
		decodeState.inputPosition += 4;
		let loc0 = decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		let loc1 = decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		decodeState.input.readInt32();
		decodeState.inputPosition += 4;
		decodeState.input.readInt32();
		decodeState.setup(loc0,loc1);
	}
}
$hxClasses["stb.format.vorbis.data.Page"] = stb_format_vorbis_data_Page;
stb_format_vorbis_data_Page.__name__ = "stb.format.vorbis.data.Page";
Object.assign(stb_format_vorbis_data_Page.prototype, {
	__class__: stb_format_vorbis_data_Page
	,flag: null
});
class stb_format_vorbis_data_ProbedPage {
	constructor() {
	}
}
$hxClasses["stb.format.vorbis.data.ProbedPage"] = stb_format_vorbis_data_ProbedPage;
stb_format_vorbis_data_ProbedPage.__name__ = "stb.format.vorbis.data.ProbedPage";
Object.assign(stb_format_vorbis_data_ProbedPage.prototype, {
	__class__: stb_format_vorbis_data_ProbedPage
	,pageStart: null
	,pageEnd: null
	,afterPreviousPageStart: null
	,firstDecodedSample: null
	,lastDecodedSample: null
});
class stb_format_vorbis_data_ReaderError {
	constructor(type,message,posInfos) {
		if(message == null) {
			message = "";
		}
		this.type = type;
		this.message = message;
		this.posInfos = posInfos;
	}
}
$hxClasses["stb.format.vorbis.data.ReaderError"] = stb_format_vorbis_data_ReaderError;
stb_format_vorbis_data_ReaderError.__name__ = "stb.format.vorbis.data.ReaderError";
Object.assign(stb_format_vorbis_data_ReaderError.prototype, {
	__class__: stb_format_vorbis_data_ReaderError
	,type: null
	,message: null
	,posInfos: null
});
var stb_format_vorbis_data_ReaderErrorType = $hxEnums["stb.format.vorbis.data.ReaderErrorType"] = { __ename__:true,__constructs__:null
	,NEED_MORE_DATA: {_hx_name:"NEED_MORE_DATA",_hx_index:0,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,INVALID_API_MIXING: {_hx_name:"INVALID_API_MIXING",_hx_index:1,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,OUTOFMEM: {_hx_name:"OUTOFMEM",_hx_index:2,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,FEATURE_NOT_SUPPORTED: {_hx_name:"FEATURE_NOT_SUPPORTED",_hx_index:3,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,TOO_MANY_CHANNELS: {_hx_name:"TOO_MANY_CHANNELS",_hx_index:4,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,FILE_OPEN_FAILURE: {_hx_name:"FILE_OPEN_FAILURE",_hx_index:5,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,SEEK_WITHOUT_LENGTH: {_hx_name:"SEEK_WITHOUT_LENGTH",_hx_index:6,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,UNEXPECTED_EOF: {_hx_name:"UNEXPECTED_EOF",_hx_index:7,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,SEEK_INVALID: {_hx_name:"SEEK_INVALID",_hx_index:8,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,INVALID_SETUP: {_hx_name:"INVALID_SETUP",_hx_index:9,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,INVALID_STREAM: {_hx_name:"INVALID_STREAM",_hx_index:10,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,MISSING_CAPTURE_PATTERN: {_hx_name:"MISSING_CAPTURE_PATTERN",_hx_index:11,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,INVALID_STREAM_STRUCTURE_VERSION: {_hx_name:"INVALID_STREAM_STRUCTURE_VERSION",_hx_index:12,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,CONTINUED_PACKET_FLAG_INVALID: {_hx_name:"CONTINUED_PACKET_FLAG_INVALID",_hx_index:13,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,INCORRECT_STREAM_SERIAL_NUMBER: {_hx_name:"INCORRECT_STREAM_SERIAL_NUMBER",_hx_index:14,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,INVALID_FIRST_PAGE: {_hx_name:"INVALID_FIRST_PAGE",_hx_index:15,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,BAD_PACKET_TYPE: {_hx_name:"BAD_PACKET_TYPE",_hx_index:16,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,CANT_FIND_LAST_PAGE: {_hx_name:"CANT_FIND_LAST_PAGE",_hx_index:17,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,SEEK_FAILED: {_hx_name:"SEEK_FAILED",_hx_index:18,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
	,OTHER: {_hx_name:"OTHER",_hx_index:19,__enum__:"stb.format.vorbis.data.ReaderErrorType",toString:$estr}
};
stb_format_vorbis_data_ReaderErrorType.__constructs__ = [stb_format_vorbis_data_ReaderErrorType.NEED_MORE_DATA,stb_format_vorbis_data_ReaderErrorType.INVALID_API_MIXING,stb_format_vorbis_data_ReaderErrorType.OUTOFMEM,stb_format_vorbis_data_ReaderErrorType.FEATURE_NOT_SUPPORTED,stb_format_vorbis_data_ReaderErrorType.TOO_MANY_CHANNELS,stb_format_vorbis_data_ReaderErrorType.FILE_OPEN_FAILURE,stb_format_vorbis_data_ReaderErrorType.SEEK_WITHOUT_LENGTH,stb_format_vorbis_data_ReaderErrorType.UNEXPECTED_EOF,stb_format_vorbis_data_ReaderErrorType.SEEK_INVALID,stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,stb_format_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM_STRUCTURE_VERSION,stb_format_vorbis_data_ReaderErrorType.CONTINUED_PACKET_FLAG_INVALID,stb_format_vorbis_data_ReaderErrorType.INCORRECT_STREAM_SERIAL_NUMBER,stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,stb_format_vorbis_data_ReaderErrorType.BAD_PACKET_TYPE,stb_format_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE,stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,stb_format_vorbis_data_ReaderErrorType.OTHER];
stb_format_vorbis_data_ReaderErrorType.__empty_constructs__ = [stb_format_vorbis_data_ReaderErrorType.NEED_MORE_DATA,stb_format_vorbis_data_ReaderErrorType.INVALID_API_MIXING,stb_format_vorbis_data_ReaderErrorType.OUTOFMEM,stb_format_vorbis_data_ReaderErrorType.FEATURE_NOT_SUPPORTED,stb_format_vorbis_data_ReaderErrorType.TOO_MANY_CHANNELS,stb_format_vorbis_data_ReaderErrorType.FILE_OPEN_FAILURE,stb_format_vorbis_data_ReaderErrorType.SEEK_WITHOUT_LENGTH,stb_format_vorbis_data_ReaderErrorType.UNEXPECTED_EOF,stb_format_vorbis_data_ReaderErrorType.SEEK_INVALID,stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM,stb_format_vorbis_data_ReaderErrorType.MISSING_CAPTURE_PATTERN,stb_format_vorbis_data_ReaderErrorType.INVALID_STREAM_STRUCTURE_VERSION,stb_format_vorbis_data_ReaderErrorType.CONTINUED_PACKET_FLAG_INVALID,stb_format_vorbis_data_ReaderErrorType.INCORRECT_STREAM_SERIAL_NUMBER,stb_format_vorbis_data_ReaderErrorType.INVALID_FIRST_PAGE,stb_format_vorbis_data_ReaderErrorType.BAD_PACKET_TYPE,stb_format_vorbis_data_ReaderErrorType.CANT_FIND_LAST_PAGE,stb_format_vorbis_data_ReaderErrorType.SEEK_FAILED,stb_format_vorbis_data_ReaderErrorType.OTHER];
class stb_format_vorbis_data_Residue {
	constructor() {
	}
	decode(decodeState,header,residueBuffers,ch,n,doNotDecode,channelBuffers) {
		let codebooks = header.codebooks;
		let classwords = codebooks[this.classbook].dimensions;
		let nRead = this.end - this.begin;
		let partSize = this.partSize;
		let partRead = UInt.toFloat(nRead) / UInt.toFloat(partSize) | 0;
		let partClassdata = new Array(header.channel * partRead);
		let _g = 0;
		while(_g < ch) {
			let i = _g++;
			if(!doNotDecode[i]) {
				let buffer = residueBuffers[i];
				let _g = 0;
				let _g1 = buffer.length;
				while(_g < _g1) {
					let j = _g++;
					buffer[j] = 0;
				}
			}
		}
		if(this.type == 2 && ch != 1) {
			let _g = 0;
			while(_g < ch) {
				let j = _g++;
				if(!doNotDecode[j]) {
					break;
				} else if(j == ch - 1) {
					return;
				}
			}
			let _g1 = 0;
			while(_g1 < 8) {
				let pass = _g1++;
				let pcount = 0;
				let classSet = 0;
				if(ch == 2) {
					while(pcount < partRead) {
						let z = this.begin + pcount * partSize;
						let cInter = z & 1;
						let pInter = z >>> 1;
						if(pass == 0) {
							let c = codebooks[this.classbook];
							if(decodeState.validBits < 10) {
								decodeState.prepHuffman();
							}
							let i = c.fastHuffman[decodeState.acc & 1023];
							let val;
							if(i >= 0) {
								let l = c.codewordLengths[i];
								decodeState.acc = decodeState.acc >>> l;
								decodeState.validBits -= l;
								if(decodeState.validBits < 0) {
									decodeState.validBits = 0;
									val = -1;
								} else {
									val = i;
								}
							} else {
								val = decodeState.decodeScalarRaw(c);
							}
							if(c.sparse) {
								val = c.sortedValues[val];
							}
							let q = val;
							if(q == -1) {
								return;
							}
							partClassdata[classSet] = this.classdata[q];
						}
						let _g = 0;
						while(_g < classwords) {
							let i = _g++;
							if(pcount >= partRead) {
								break;
							}
							let z = this.begin + pcount * partSize;
							let c = partClassdata[classSet][i];
							let b = this.residueBooks[c][pass];
							if(b >= 0) {
								let book = codebooks[b];
								let result = book.decodeDeinterleaveRepeat(decodeState,residueBuffers,ch,cInter,pInter,n,partSize);
								if(result == null) {
									return;
								} else {
									cInter = result.cInter;
									pInter = result.pInter;
								}
							} else {
								z = z + partSize;
								cInter = z & 1;
								pInter = z >>> 1;
							}
							++pcount;
						}
						++classSet;
					}
				} else if(ch == 1) {
					while(pcount < partRead) {
						let z = this.begin + pcount * partSize;
						let cInter = 0;
						let pInter = z;
						if(pass == 0) {
							let c = codebooks[this.classbook];
							if(decodeState.validBits < 10) {
								decodeState.prepHuffman();
							}
							let i = c.fastHuffman[decodeState.acc & 1023];
							let val;
							if(i >= 0) {
								let l = c.codewordLengths[i];
								decodeState.acc = decodeState.acc >>> l;
								decodeState.validBits -= l;
								if(decodeState.validBits < 0) {
									decodeState.validBits = 0;
									val = -1;
								} else {
									val = i;
								}
							} else {
								val = decodeState.decodeScalarRaw(c);
							}
							if(c.sparse) {
								val = c.sortedValues[val];
							}
							let q = val;
							if(q == -1) {
								return;
							}
							partClassdata[classSet] = this.classdata[q];
						}
						let _g = 0;
						while(_g < classwords) {
							let i = _g++;
							if(pcount >= partRead) {
								break;
							}
							let z = this.begin + pcount * partSize;
							let c = partClassdata[classSet][i];
							let b = this.residueBooks[c][pass];
							if(b >= 0) {
								let book = codebooks[b];
								let result = book.decodeDeinterleaveRepeat(decodeState,residueBuffers,ch,cInter,pInter,n,partSize);
								if(result == null) {
									return;
								} else {
									cInter = result.cInter;
									pInter = result.pInter;
								}
							} else {
								z = z + partSize;
								cInter = 0;
								pInter = z;
							}
							++pcount;
						}
						++classSet;
					}
				} else {
					while(pcount < partRead) {
						let z = this.begin + pcount * partSize;
						let cInter = UInt.toFloat(z) % UInt.toFloat(ch) | 0;
						let pInter = UInt.toFloat(z) / UInt.toFloat(ch) | 0;
						if(pass == 0) {
							let c = codebooks[this.classbook];
							if(decodeState.validBits < 10) {
								decodeState.prepHuffman();
							}
							let i = c.fastHuffman[decodeState.acc & 1023];
							let val;
							if(i >= 0) {
								let l = c.codewordLengths[i];
								decodeState.acc = decodeState.acc >>> l;
								decodeState.validBits -= l;
								if(decodeState.validBits < 0) {
									decodeState.validBits = 0;
									val = -1;
								} else {
									val = i;
								}
							} else {
								val = decodeState.decodeScalarRaw(c);
							}
							if(c.sparse) {
								val = c.sortedValues[val];
							}
							let q = val;
							if(q == -1) {
								return;
							}
							partClassdata[classSet] = this.classdata[q];
						}
						let _g = 0;
						while(_g < classwords) {
							let i = _g++;
							if(pcount >= partRead) {
								break;
							}
							let z = this.begin + pcount * partSize;
							let c = partClassdata[classSet][i];
							let b = this.residueBooks[c][pass];
							if(b >= 0) {
								let book = codebooks[b];
								let result = book.decodeDeinterleaveRepeat(decodeState,residueBuffers,ch,cInter,pInter,n,partSize);
								if(result == null) {
									return;
								} else {
									cInter = result.cInter;
									pInter = result.pInter;
								}
							} else {
								z = z + partSize;
								cInter = UInt.toFloat(z) % UInt.toFloat(ch) | 0;
								pInter = UInt.toFloat(z) / UInt.toFloat(ch) | 0;
							}
							++pcount;
						}
						++classSet;
					}
				}
			}
			return;
		}
		let _g1 = 0;
		while(_g1 < 8) {
			let pass = _g1++;
			let pcount = 0;
			let classSet = 0;
			while(pcount < partRead) {
				if(pass == 0) {
					let _g = 0;
					while(_g < ch) {
						let j = _g++;
						if(!doNotDecode[j]) {
							let c = codebooks[this.classbook];
							if(decodeState.validBits < 10) {
								decodeState.prepHuffman();
							}
							let i = c.fastHuffman[decodeState.acc & 1023];
							let val;
							if(i >= 0) {
								let l = c.codewordLengths[i];
								decodeState.acc = decodeState.acc >>> l;
								decodeState.validBits -= l;
								if(decodeState.validBits < 0) {
									decodeState.validBits = 0;
									val = -1;
								} else {
									val = i;
								}
							} else {
								val = decodeState.decodeScalarRaw(c);
							}
							if(c.sparse) {
								val = c.sortedValues[val];
							}
							let temp = val;
							if(temp == -1) {
								return;
							}
							partClassdata[j * partRead + classSet] = this.classdata[temp];
						}
					}
				}
				let _g = 0;
				while(_g < classwords) {
					let i = _g++;
					if(pcount >= partRead) {
						break;
					}
					let _g1 = 0;
					while(_g1 < ch) {
						let j = _g1++;
						if(!doNotDecode[j]) {
							let c = partClassdata[j * partRead + classSet][i];
							let b = this.residueBooks[c][pass];
							if(b >= 0) {
								let target = residueBuffers[j];
								let offset = this.begin + pcount * partSize;
								let book = codebooks[b];
								if(!book.residueDecode(decodeState,target,offset,partSize,this.type)) {
									return;
								}
							}
						}
					}
					++pcount;
				}
				++classSet;
			}
		}
	}
	static read(decodeState,codebooks) {
		let r = new stb_format_vorbis_data_Residue();
		let tmp;
		if(decodeState.validBits < 0) {
			tmp = 0;
		} else if(decodeState.validBits < 16) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 16);
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else {
				let z = decodeState.acc & 65535;
				decodeState.acc = decodeState.acc >>> 16;
				decodeState.validBits -= 16;
				tmp = z;
			}
		} else {
			let z = decodeState.acc & 65535;
			decodeState.acc = decodeState.acc >>> 16;
			decodeState.validBits -= 16;
			tmp = z;
		}
		r.type = tmp;
		if(r.type > 2) {
			throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Residue.hx", lineNumber : 29, className : "stb.format.vorbis.data.Residue", methodName : "read"}));
		}
		let residueCascade = new Array(64);
		let tmp1;
		if(decodeState.validBits < 0) {
			tmp1 = 0;
		} else if(decodeState.validBits < 24) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 24);
			if(decodeState.validBits < 0) {
				tmp1 = 0;
			} else {
				let z = decodeState.acc & 16777215;
				decodeState.acc = decodeState.acc >>> 24;
				decodeState.validBits -= 24;
				tmp1 = z;
			}
		} else {
			let z = decodeState.acc & 16777215;
			decodeState.acc = decodeState.acc >>> 24;
			decodeState.validBits -= 24;
			tmp1 = z;
		}
		r.begin = tmp1;
		let tmp2;
		if(decodeState.validBits < 0) {
			tmp2 = 0;
		} else if(decodeState.validBits < 24) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 24);
			if(decodeState.validBits < 0) {
				tmp2 = 0;
			} else {
				let z = decodeState.acc & 16777215;
				decodeState.acc = decodeState.acc >>> 24;
				decodeState.validBits -= 24;
				tmp2 = z;
			}
		} else {
			let z = decodeState.acc & 16777215;
			decodeState.acc = decodeState.acc >>> 24;
			decodeState.validBits -= 24;
			tmp2 = z;
		}
		r.end = tmp2;
		let tmp3;
		if(decodeState.validBits < 0) {
			tmp3 = 0;
		} else if(decodeState.validBits < 24) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 24);
			if(decodeState.validBits < 0) {
				tmp3 = 0;
			} else {
				let z = decodeState.acc & 16777215;
				decodeState.acc = decodeState.acc >>> 24;
				decodeState.validBits -= 24;
				tmp3 = z;
			}
		} else {
			let z = decodeState.acc & 16777215;
			decodeState.acc = decodeState.acc >>> 24;
			decodeState.validBits -= 24;
			tmp3 = z;
		}
		r.partSize = tmp3 + 1;
		let classifications;
		if(decodeState.validBits < 0) {
			classifications = 0;
		} else if(decodeState.validBits < 6) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 6);
			if(decodeState.validBits < 0) {
				classifications = 0;
			} else {
				let z = decodeState.acc & 63;
				decodeState.acc = decodeState.acc >>> 6;
				decodeState.validBits -= 6;
				classifications = z;
			}
		} else {
			let z = decodeState.acc & 63;
			decodeState.acc = decodeState.acc >>> 6;
			decodeState.validBits -= 6;
			classifications = z;
		}
		let classifications1 = r.classifications = classifications + 1;
		let tmp4;
		if(decodeState.validBits < 0) {
			tmp4 = 0;
		} else if(decodeState.validBits < 8) {
			if(decodeState.validBits == 0) {
				decodeState.acc = 0;
			}
			do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
				decodeState.validBits = -1;
				break;
			} else {
				decodeState.bytesInSeg--;
				decodeState.inputPosition += 1;
				decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
				decodeState.validBits += 8;
			} while(decodeState.validBits < 8);
			if(decodeState.validBits < 0) {
				tmp4 = 0;
			} else {
				let z = decodeState.acc & 255;
				decodeState.acc = decodeState.acc >>> 8;
				decodeState.validBits -= 8;
				tmp4 = z;
			}
		} else {
			let z = decodeState.acc & 255;
			decodeState.acc = decodeState.acc >>> 8;
			decodeState.validBits -= 8;
			tmp4 = z;
		}
		r.classbook = tmp4;
		let _g = 0;
		let _g1 = r.classifications;
		while(_g < _g1) {
			let j = _g++;
			let highBits = 0;
			let lowBits;
			if(decodeState.validBits < 0) {
				lowBits = 0;
			} else if(decodeState.validBits < 3) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 3);
				if(decodeState.validBits < 0) {
					lowBits = 0;
				} else {
					let z = decodeState.acc & 7;
					decodeState.acc = decodeState.acc >>> 3;
					decodeState.validBits -= 3;
					lowBits = z;
				}
			} else {
				let z = decodeState.acc & 7;
				decodeState.acc = decodeState.acc >>> 3;
				decodeState.validBits -= 3;
				lowBits = z;
			}
			let tmp;
			if(decodeState.validBits < 0) {
				tmp = 0;
			} else if(decodeState.validBits < 1) {
				if(decodeState.validBits == 0) {
					decodeState.acc = 0;
				}
				do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
					decodeState.validBits = -1;
					break;
				} else {
					decodeState.bytesInSeg--;
					decodeState.inputPosition += 1;
					decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
					decodeState.validBits += 8;
				} while(decodeState.validBits < 1);
				if(decodeState.validBits < 0) {
					tmp = 0;
				} else {
					let z = decodeState.acc & 1;
					decodeState.acc = decodeState.acc >>> 1;
					decodeState.validBits -= 1;
					tmp = z;
				}
			} else {
				let z = decodeState.acc & 1;
				decodeState.acc = decodeState.acc >>> 1;
				decodeState.validBits -= 1;
				tmp = z;
			}
			if(tmp != 0) {
				if(decodeState.validBits < 0) {
					highBits = 0;
				} else if(decodeState.validBits < 5) {
					if(decodeState.validBits == 0) {
						decodeState.acc = 0;
					}
					do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
						decodeState.validBits = -1;
						break;
					} else {
						decodeState.bytesInSeg--;
						decodeState.inputPosition += 1;
						decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
						decodeState.validBits += 8;
					} while(decodeState.validBits < 5);
					if(decodeState.validBits < 0) {
						highBits = 0;
					} else {
						let z = decodeState.acc & 31;
						decodeState.acc = decodeState.acc >>> 5;
						decodeState.validBits -= 5;
						highBits = z;
					}
				} else {
					let z = decodeState.acc & 31;
					decodeState.acc = decodeState.acc >>> 5;
					decodeState.validBits -= 5;
					highBits = z;
				}
			}
			residueCascade[j] = highBits * 8 + lowBits;
		}
		r.residueBooks = new Array(r.classifications);
		let _g2 = 0;
		let _g3 = r.classifications;
		while(_g2 < _g3) {
			let j = _g2++;
			r.residueBooks[j] = new Array(8);
			let _g = 0;
			while(_g < 8) {
				let k = _g++;
				if((residueCascade[j] & 1 << k) != 0) {
					let this1 = r.residueBooks[j];
					let val;
					if(decodeState.validBits < 0) {
						val = 0;
					} else if(decodeState.validBits < 8) {
						if(decodeState.validBits == 0) {
							decodeState.acc = 0;
						}
						do if(decodeState.bytesInSeg == 0 && (decodeState.lastSeg || decodeState.next() == 0)) {
							decodeState.validBits = -1;
							break;
						} else {
							decodeState.bytesInSeg--;
							decodeState.inputPosition += 1;
							decodeState.acc = decodeState.acc + (decodeState.input.readByte() << decodeState.validBits);
							decodeState.validBits += 8;
						} while(decodeState.validBits < 8);
						if(decodeState.validBits < 0) {
							val = 0;
						} else {
							let z = decodeState.acc & 255;
							decodeState.acc = decodeState.acc >>> 8;
							decodeState.validBits -= 8;
							val = z;
						}
					} else {
						let z = decodeState.acc & 255;
						decodeState.acc = decodeState.acc >>> 8;
						decodeState.validBits -= 8;
						val = z;
					}
					this1[k] = val;
					if(r.residueBooks[j][k] >= codebooks.length) {
						throw haxe_Exception.thrown(new stb_format_vorbis_data_ReaderError(stb_format_vorbis_data_ReaderErrorType.INVALID_SETUP,null,{ fileName : "stb/format/vorbis/data/Residue.hx", lineNumber : 55, className : "stb.format.vorbis.data.Residue", methodName : "read"}));
					}
				} else {
					r.residueBooks[j][k] = -1;
				}
			}
		}
		let el = codebooks[r.classbook].entries;
		let classwords = codebooks[r.classbook].dimensions;
		r.classdata = new Array(el);
		let _g4 = 0;
		while(_g4 < el) {
			let j = _g4++;
			let temp = j;
			let k = classwords;
			let cd = r.classdata[j] = new Array(classwords);
			while(--k >= 0) {
				cd[k] = temp % classifications1;
				temp = temp / classifications1 | 0;
			}
		}
		return r;
	}
}
$hxClasses["stb.format.vorbis.data.Residue"] = stb_format_vorbis_data_Residue;
stb_format_vorbis_data_Residue.__name__ = "stb.format.vorbis.data.Residue";
Object.assign(stb_format_vorbis_data_Residue.prototype, {
	__class__: stb_format_vorbis_data_Residue
	,begin: null
	,end: null
	,partSize: null
	,classifications: null
	,classbook: null
	,classdata: null
	,residueBooks: null
	,type: null
});
class touch_TouchButton {
	constructor(img,position,radius) {
		this.identifier = -1;
		this.enabled = true;
		this.pressed = false;
		this.added = false;
		let imgTile = img.toTile();
		let g = new h2d_Graphics();
		g.beginFill(16777215);
		g.drawCircle(0,0,radius);
		g.beginTileFill(-(imgTile.width * 1.5 * radius / imgTile.width) / 2,-(imgTile.height * 1.5 * radius / imgTile.width) / 2,1.5 * radius / imgTile.width,1.5 * radius / imgTile.height,imgTile);
		g.drawRect(-(imgTile.width * 1.5 * radius / imgTile.width) / 2,-(imgTile.height * 1.5 * radius / imgTile.width / 2),imgTile.width * 1.5 * radius / imgTile.width,imgTile.height * 1.5 * radius / imgTile.width);
		g.endFill();
		this.guiElement = new gui_GuiGraphics(g);
		this.guiElement.position = position;
		this.guiElement.extent = new h3d_Vector(2 * radius,2 * radius);
		this.guiElement.horizSizing = gui_HorizSizing.Left;
		this.guiElement.vertSizing = gui_VertSizing.Top;
		this.radius = radius;
		this.collider = new h2d_Interactive(2 * radius,2 * radius,this.guiElement.graphics,new h2d_col_Circle(0,0,radius));
		let _gthis = this;
		this.collider.onPush = function(e) {
			_gthis.onClick();
			if(_gthis.enabled) {
				g.alpha = 0.9;
			} else {
				g.alpha = 0.5;
			}
			_gthis.identifier = e.touchId;
		};
		this.collider.onRelease = function(e) {
			if(e.touchId != _gthis.identifier) {
				return;
			}
			_gthis.identifier = -1;
			_gthis.onRelease();
			if(_gthis.enabled) {
				g.alpha = 0.4;
			} else {
				g.alpha = 0.2;
			}
		};
		if(this.enabled) {
			g.alpha = 0.4;
		} else {
			g.alpha = 0.2;
		}
	}
	add(parentGui) {
		parentGui.addChild(this.guiElement);
		this.added = true;
	}
	remove(parentGui) {
		parentGui.removeChild(this.guiElement);
		this.added = false;
	}
	setEnabled(enabled) {
		this.enabled = enabled;
		if(this.enabled) {
			this.guiElement.graphics.alpha = 0.4;
		} else {
			this.guiElement.graphics.alpha = 0.2;
		}
		if(this.pressed) {
			if(this.enabled) {
				this.guiElement.graphics.alpha = 0.9;
			} else {
				this.guiElement.graphics.alpha = 0.5;
			}
		}
	}
	setVisible(enabled) {
		this.guiElement.graphics.set_visible(enabled);
	}
	onClick() {
		this.pressed = true;
	}
	onRelease() {
		this.pressed = false;
	}
	dispose() {
		this.guiElement.dispose();
	}
}
$hxClasses["touch.TouchButton"] = touch_TouchButton;
touch_TouchButton.__name__ = "touch.TouchButton";
Object.assign(touch_TouchButton.prototype, {
	__class__: touch_TouchButton
	,guiElement: null
	,radius: null
	,added: null
	,pressed: null
	,enabled: null
	,identifier: null
	,collider: null
});
class touch_BlastButton extends touch_TouchButton {
	constructor() {
		let tmp = src_Settings.touchSettings.blastButtonPos[0];
		let tmp1 = src_Settings.touchSettings.blastButtonPos[1];
		super(src_ResourceLoader.getImage("data/ui/touch/explosion.png").resource,new h3d_Vector(tmp,tmp1),src_Settings.touchSettings.blastButtonSize);
		this.setEnabled(false);
	}
}
$hxClasses["touch.BlastButton"] = touch_BlastButton;
touch_BlastButton.__name__ = "touch.BlastButton";
touch_BlastButton.__super__ = touch_TouchButton;
Object.assign(touch_BlastButton.prototype, {
	__class__: touch_BlastButton
});
class touch_CameraInput {
	constructor() {
		this.added = false;
		this.pressed = false;
		this.enabled = false;
		this.identifier = -1;
		let width = src_MarbleGame.canvas.scene2d.width;
		let height = src_MarbleGame.canvas.scene2d.height;
		let g = new h2d_Graphics();
		let b = new h2d_col_Bounds();
		b.xMin = 0;
		b.yMin = 0;
		b.xMax = width;
		b.yMax = height;
		let interactive = new h2d_Interactive(width,height,g,b);
		this.collider = new gui_GuiGraphics(g);
		this.collider.position = new h3d_Vector(0,0);
		this.collider.extent = new h3d_Vector(width,height);
		this.collider.horizSizing = gui_HorizSizing.Width;
		this.collider.vertSizing = gui_VertSizing.Height;
		this.pressed = false;
		let prevMouse_z;
		let prevMouse_y;
		let prevMouse_x;
		let prevMouse_w;
		prevMouse_x = 0;
		prevMouse_y = 0;
		prevMouse_z = 0.;
		prevMouse_w = 1.;
		let _gthis = this;
		interactive.onPush = function(e) {
			e.propagate = true;
			if(!_gthis.enabled) {
				return;
			}
			if(_gthis.pressed) {
				return;
			}
			let scene2d = interactive.getScene();
			if(e.relX < scene2d.width / 2) {
				if(src_Settings.touchSettings.dynamicJoystick) {
					src_MarbleGame.instance.touchInput.movementInput.moveToFinger(e);
				}
				return;
			}
			_gthis.pressed = true;
			_gthis.identifier = e.touchId;
			prevMouse_x = e.relX;
			prevMouse_y = e.relY;
		};
		interactive.onMove = function(e) {
			e.propagate = true;
			if(!_gthis.enabled) {
				return;
			}
			if(_gthis.identifier != e.touchId) {
				return;
			}
			if(_gthis.pressed) {
				let x = e.relX;
				let y = e.relY;
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let curPos_x = x;
				let curPos_y = y;
				let x1 = curPos_x - prevMouse_x;
				let y1 = curPos_y - prevMouse_y;
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let delta_x = x1;
				let delta_y = y1;
				let scaleFactor = 1.0;
				scaleFactor = window.devicePixelRatio / src_Settings.zoomRatio;
				let jumpcam = src_MarbleGame.instance.touchInput.jumpButton.pressed || src_MarbleGame.instance.touchInput.powerupButton.pressed;
				if(jumpcam) {
					scaleFactor /= src_Settings.touchSettings.buttonJoystickMultiplier;
				}
				if(Math.abs(delta_x) < 0.05) {
					delta_x = 0;
				}
				if(Math.abs(delta_y) < 0.05) {
					delta_y = 0;
				}
				src_MarbleGame.instance.world.marble.camera.orbit(_gthis.applyNonlinearScale(delta_x / scaleFactor),_gthis.applyNonlinearScale(delta_y / scaleFactor),true);
				prevMouse_x = e.relX;
				prevMouse_y = e.relY;
			}
		};
		interactive.onRelease = function(e) {
			e.propagate = true;
			if(!_gthis.enabled) {
				return;
			}
			if(_gthis.identifier != e.touchId) {
				return;
			}
			_gthis.pressed = false;
			_gthis.identifier = -1;
		};
	}
	applyNonlinearScale(value) {
		let min = -src_Settings.touchSettings.cameraSwipeExtent;
		let max = src_Settings.touchSettings.cameraSwipeExtent;
		let clamped = value < min ? min : value > max ? max : value;
		if(Math.abs(clamped) < 3) {
			return Math.pow(Math.abs(clamped / 2),2.7) * (clamped >= 0 ? 1 : -1);
		} else {
			return clamped;
		}
	}
	dispose() {
		this.collider.dispose();
	}
	add(parentGui) {
		parentGui.addChild(this.collider);
		this.added = true;
	}
	remove(parentGui) {
		parentGui.removeChild(this.collider);
		this.added = false;
	}
}
$hxClasses["touch.CameraInput"] = touch_CameraInput;
touch_CameraInput.__name__ = "touch.CameraInput";
Object.assign(touch_CameraInput.prototype, {
	__class__: touch_CameraInput
	,identifier: null
	,enabled: null
	,pressed: null
	,added: null
	,collider: null
});
class touch_JumpButton extends touch_TouchButton {
	constructor() {
		let tmp = src_Settings.touchSettings.jumpButtonPos[0];
		let tmp1 = src_Settings.touchSettings.jumpButtonPos[1];
		super(src_ResourceLoader.getImage("data/ui/touch/up-arrow.png").resource,new h3d_Vector(tmp,tmp1),src_Settings.touchSettings.jumpButtonSize);
	}
}
$hxClasses["touch.JumpButton"] = touch_JumpButton;
touch_JumpButton.__name__ = "touch.JumpButton";
touch_JumpButton.__super__ = touch_TouchButton;
Object.assign(touch_JumpButton.prototype, {
	__class__: touch_JumpButton
});
class touch_MovementInput {
	constructor() {
		this.touchId = -1;
		this.capturing = false;
		this.value = new h3d_Vector();
		this.pressed = false;
		this.added = false;
		let size = src_Settings.touchSettings.joystickSize;
		let g = new h2d_Graphics();
		g.beginFill(16777215,0.4);
		g.drawRoundedRect(0,0,size * 6,size * 6,size);
		g.endFill();
		this.area = new gui_GuiGraphics(g);
		this.area.position = new h3d_Vector(src_Settings.touchSettings.joystickPos[0],src_Settings.touchSettings.joystickPos[1]);
		this.area.extent = new h3d_Vector(size * 6,size * 6);
		this.area.vertSizing = gui_VertSizing.Top;
		let tmp = size * 6;
		let tmp1 = size * 6;
		let b = new h2d_col_Bounds();
		b.xMin = 0;
		b.yMin = 0;
		b.xMax = size * 6;
		b.yMax = size * 6;
		this.collider = new h2d_Interactive(tmp,tmp1,g,b);
		let g2 = new h2d_Graphics();
		g2.beginFill(16777215,0.7);
		g2.drawCircle(0,0,size);
		g2.endFill();
		this.joystick = new gui_GuiGraphics(g2);
		this.joystick.position = new h3d_Vector(size * 3,size * 3);
		this.joystick.extent = new h3d_Vector(size,size);
		this.area.addChild(this.joystick);
		let _gthis = this;
		this.collider.onPush = function(e) {
			_gthis.area.graphics.alpha = 1;
			_gthis.joystick.graphics.alpha = 1;
			if(!_gthis.pressed) {
				_gthis.pressed = true;
				_gthis.touchId = e.touchId;
				let stopped = false;
				_gthis.capturing = true;
				_gthis.collider.startCapture(function(emove) {
					if(e.touchId != emove.touchId) {
						emove.propagate = true;
						return;
					}
					if(emove.kind == hxd_EventKind.EMove) {
						let value = emove.relX;
						let max = size * 5;
						let xPos = value < size ? size : value > max ? max : value;
						let value1 = emove.relY;
						let max1 = size * 5;
						let yPos = value1 < size ? size : value1 > max1 ? max1 : value1;
						_gthis.value.x = (xPos - size * 3) / (size * 2);
						_gthis.value.y = (yPos - size * 3) / (size * 2);
						let _this = _gthis.joystick.graphics;
						let x = _gthis.area.graphics.x + xPos;
						let y = _gthis.area.graphics.y + yPos;
						_this.posChanged = true;
						_this.x = x;
						_this.posChanged = true;
						_this.y = y;
					}
					if(emove.kind == hxd_EventKind.ERelease || emove.kind == hxd_EventKind.EReleaseOutside) {
						stopped = true;
						_gthis.collider.stopCapture();
						_gthis.capturing = false;
					}
				},function() {
					if(stopped) {
						_gthis.area.graphics.alpha = 0;
						_gthis.joystick.graphics.alpha = 0;
						_gthis.pressed = false;
						_gthis.capturing = false;
						_gthis.value = new h3d_Vector(0,0);
					}
				},e.touchId);
			}
		};
		this.area.graphics.alpha = 1;
		this.joystick.graphics.alpha = 1;
	}
	moveToFinger(e) {
		let size = src_Settings.touchSettings.joystickSize;
		let scene2d = this.collider.getScene();
		let _this = this.area.graphics;
		let value = e.relX - size * 3;
		let max = scene2d.width / 2 - size * 6;
		let value1 = e.relY - size * 3;
		let max1 = scene2d.height - size * 6;
		_this.posChanged = true;
		_this.x = value < 0 ? 0 : value > max ? max : value;
		_this.posChanged = true;
		_this.y = value1 < 0 ? 0 : value1 > max1 ? max1 : value1;
		this.collider.onPush(e);
	}
	add(parentGui) {
		parentGui.addChild(this.area);
		this.added = true;
	}
	remove(parentGui) {
		parentGui.removeChild(this.area);
		this.added = false;
	}
	setVisible(enabled) {
		this.area.graphics.set_visible(enabled);
		this.joystick.graphics.set_visible(enabled);
	}
	dispose() {
		this.area.dispose();
	}
}
$hxClasses["touch.MovementInput"] = touch_MovementInput;
touch_MovementInput.__name__ = "touch.MovementInput";
Object.assign(touch_MovementInput.prototype, {
	__class__: touch_MovementInput
	,area: null
	,added: null
	,collider: null
	,joystick: null
	,pressed: null
	,value: null
	,capturing: null
	,touchId: null
});
class touch_MovementInputEdit extends gui_GuiGraphics {
	constructor() {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor();
	}
	_hx_constructor() {
		this.state = 0;
		this.selected = false;
		let size = src_Settings.touchSettings.joystickSize;
		this.size = size;
		let g = new h2d_Graphics();
		g.beginFill(16777215,0.4);
		g.drawRoundedRect(0,0,size * 6,size * 6,size);
		g.endFill();
		super._hx_constructor(g);
		this.position = new h3d_Vector(src_Settings.touchSettings.joystickPos[0],src_Settings.touchSettings.joystickPos[1]);
		this.extent = new h3d_Vector(size * 6,size * 6);
		this.vertSizing = gui_VertSizing.Top;
		let b = new h2d_col_Bounds();
		b.xMin = 0;
		b.yMin = 0;
		b.xMax = size * 6;
		b.yMax = size * 6;
		new h2d_Interactive(size * 6,size * 6,g,b);
		let g2 = new h2d_Graphics();
		g2.beginFill(16777215,0.7);
		g2.drawCircle(0,0,size);
		g2.endFill();
		let joystick = new gui_GuiGraphics(g2);
		joystick.position = new h3d_Vector(size * 3,size * 3);
		joystick.extent = new h3d_Vector(size,size);
		this.addChild(joystick);
	}
	onMousePress(mouseState) {
		this.onClick(mouseState);
		this.mousePos = mouseState.position;
		let renderRect = this.getHitTestRect();
		let x = renderRect.position.x + renderRect.extent.x / 2;
		let y = renderRect.position.y + 15;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let knobPos_x = x;
		let knobPos_y = y;
		let _this = mouseState.position;
		let x1 = _this.x - knobPos_x;
		let y1 = _this.y - knobPos_y;
		let z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let _this_x = x1;
		let _this_y = y1;
		let _this_z = z;
		if(Math.sqrt(_this_x * _this_x + _this_y * _this_y + _this_z * _this_z) < 15) {
			this.state = 2;
		} else {
			this.state = 1;
		}
	}
	onMouseDown(mouseState) {
		if(this.selected) {
			let _this = mouseState.position;
			let v = this.mousePos;
			let x = _this.x - v.x;
			let y = _this.y - v.y;
			let z = _this.z - v.z;
			let w = _this.w - v.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let deltaPos_x = x;
			let deltaPos_y = y;
			let deltaPos_z = z;
			let deltaPos_w = w;
			this.mousePos = mouseState.position;
			if(this.state == 1) {
				let _this = this.graphics;
				_this.posChanged = true;
				_this.x = this.graphics.x + deltaPos_x;
				_this.posChanged = true;
				_this.y = this.graphics.y + deltaPos_y;
				let _this1 = this.position;
				this.position = new h3d_Vector(_this1.x + deltaPos_x,_this1.y + deltaPos_y,_this1.z + deltaPos_z,_this1.w + deltaPos_w);
				let joy = this.children[0];
				let _this2 = joy.graphics;
				_this2.posChanged = true;
				_this2.x = joy.graphics.x + deltaPos_x;
				_this2.posChanged = true;
				_this2.y = joy.graphics.y + deltaPos_y;
				this.onChangeCb(this.position,this.size);
			}
			if(this.state == 2) {
				let renderRect = this.getHitTestRect();
				let x = renderRect.position.x + renderRect.extent.x / 2;
				if(x == null) {
					x = 0.;
				}
				let knobPos_x = x;
				let value = Math.abs(mouseState.position.y - (renderRect.position.y + renderRect.extent.y / 2)) / 3;
				let newSize = value < 15 ? 15 : value > 70 ? 70 : value;
				let x1 = knobPos_x - newSize * 3;
				let y = mouseState.position.y;
				if(y == null) {
					y = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let newPos_x = x1;
				let newPos_y = y;
				let x2 = renderRect.position.x + 15 + 6.5 - newPos_x;
				let y1 = renderRect.position.y + 15 + 6.5 - newPos_y;
				if(y1 == null) {
					y1 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let deltaPos_x = x2;
				let deltaPos_y = y1;
				this.size = newSize;
				this.extent = new h3d_Vector(this.size * 6,this.size * 6);
				let _this = this.position;
				this.position = new h3d_Vector(_this.x - deltaPos_x,_this.y - deltaPos_y,_this.z,_this.w - 1.);
				let _this1 = this.graphics;
				_this1.posChanged = true;
				_this1.x = this.graphics.x - deltaPos_x;
				_this1.posChanged = true;
				_this1.y = this.graphics.y - deltaPos_y;
				let joystick = this.children[0];
				joystick.position = new h3d_Vector(this.size * 3,this.size * 3);
				joystick.extent = new h3d_Vector(this.size,this.size);
				let _this2 = joystick.graphics;
				_this2.posChanged = true;
				_this2.x = this.graphics.x + this.size * 3;
				_this2.posChanged = true;
				_this2.y = this.graphics.y + this.size * 3;
				this.setSelected(false);
				this.setSelected(true);
				joystick.graphics.clear();
				joystick.graphics.beginFill(16777215,0.7);
				joystick.graphics.drawCircle(0,0,this.size);
				joystick.graphics.endFill();
				this.onChangeCb(this.position,this.size);
			}
		}
	}
	onMouseRelease(mouseState) {
		this.state = 0;
	}
	getHitTestRect(useScroll) {
		if(useScroll == null) {
			useScroll = true;
		}
		let thisRect = this.getRenderRectangle();
		if(this.selected) {
			let _this = thisRect.position;
			thisRect.position = new h3d_Vector(_this.x + (-21.5),_this.y + (-21.5),_this.z,_this.w + 1.);
			let _this1 = thisRect.extent;
			let v_x = 43;
			let v_y = 43;
			thisRect.extent = new h3d_Vector(_this1.x + v_x,_this1.y + v_y,_this1.z,_this1.w + 1.);
		}
		if(this.parent == null) {
			return thisRect;
		} else {
			return thisRect.intersect(this.parent.getRenderRectangle());
		}
	}
	setSelected(selected) {
		this.selected = selected;
		if(selected) {
			this.graphics.lineStyle(3,16777215);
			let _this = this.graphics;
			_this.flush();
			_this.addVertex(-6.5,-6.5,_this.curR,_this.curG,_this.curB,_this.curA,-6.5 * _this.ma + -6.5 * _this.mc + _this.mx,-6.5 * _this.mb + -6.5 * _this.md + _this.my);
			let _this1 = this.graphics;
			let x = this.size * 6 + 6.5;
			_this1.addVertex(x,-6.5,_this1.curR,_this1.curG,_this1.curB,_this1.curA,x * _this1.ma + -6.5 * _this1.mc + _this1.mx,x * _this1.mb + -6.5 * _this1.md + _this1.my);
			let _this2 = this.graphics;
			let x1 = this.size * 6 + 6.5;
			let y = this.size * 6 + 6.5;
			_this2.addVertex(x1,y,_this2.curR,_this2.curG,_this2.curB,_this2.curA,x1 * _this2.ma + y * _this2.mc + _this2.mx,x1 * _this2.mb + y * _this2.md + _this2.my);
			let _this3 = this.graphics;
			let y1 = this.size * 6 + 6.5;
			_this3.addVertex(-6.5,y1,_this3.curR,_this3.curG,_this3.curB,_this3.curA,-6.5 * _this3.ma + y1 * _this3.mc + _this3.mx,-6.5 * _this3.mb + y1 * _this3.md + _this3.my);
			let _this4 = this.graphics;
			_this4.addVertex(-6.5,-6.5,_this4.curR,_this4.curG,_this4.curB,_this4.curA,-6.5 * _this4.ma + -6.5 * _this4.mc + _this4.mx,-6.5 * _this4.mb + -6.5 * _this4.md + _this4.my);
			this.graphics.beginFill(9145227);
			this.graphics.lineStyle(0,16777215);
			this.graphics.drawCircle(this.size * 3,-6.5,15);
			this.graphics.endFill();
		} else {
			this.graphics.clear();
			this.graphics.beginFill(16777215,0.4);
			this.graphics.drawRoundedRect(0,0,this.size * 6,this.size * 6,this.size);
			this.graphics.endFill();
		}
	}
}
$hxClasses["touch.MovementInputEdit"] = touch_MovementInputEdit;
touch_MovementInputEdit.__name__ = "touch.MovementInputEdit";
touch_MovementInputEdit.__super__ = gui_GuiGraphics;
Object.assign(touch_MovementInputEdit.prototype, {
	__class__: touch_MovementInputEdit
	,selected: null
	,onClick: null
	,onChangeCb: null
	,mousePos: null
	,size: null
	,state: null
});
class touch_PauseButton extends touch_TouchButton {
	constructor() {
		let offset = src_MarbleGame.instance.world != null ? src_MarbleGame.instance.world.totalGems > 0 ? 30 : 0 : 0;
		super(src_ResourceLoader.getImage("data/ui/touch/pause-button.png").resource,new h3d_Vector(55,55 + offset),35);
		this.guiElement.horizSizing = gui_HorizSizing.Right;
		this.guiElement.vertSizing = gui_VertSizing.Bottom;
		this.onClick = function() {
			if(src_MarbleGame.instance.world != null) {
				src_MarbleGame.instance.handlePauseGame();
			}
		};
	}
}
$hxClasses["touch.PauseButton"] = touch_PauseButton;
touch_PauseButton.__name__ = "touch.PauseButton";
touch_PauseButton.__super__ = touch_TouchButton;
Object.assign(touch_PauseButton.prototype, {
	__class__: touch_PauseButton
});
class touch_PowerupButton extends touch_TouchButton {
	constructor() {
		let tmp = src_Settings.touchSettings.powerupButtonPos[0];
		let tmp1 = src_Settings.touchSettings.powerupButtonPos[1];
		super(src_ResourceLoader.getImage("data/ui/touch/energy.png").resource,new h3d_Vector(tmp,tmp1),src_Settings.touchSettings.powerupButtonSize);
		this.setEnabled(false);
	}
}
$hxClasses["touch.PowerupButton"] = touch_PowerupButton;
touch_PowerupButton.__name__ = "touch.PowerupButton";
touch_PowerupButton.__super__ = touch_TouchButton;
Object.assign(touch_PowerupButton.prototype, {
	__class__: touch_PowerupButton
});
class touch_RestartButton extends touch_TouchButton {
	constructor() {
		let offset = src_MarbleGame.instance.world != null ? src_MarbleGame.instance.world.totalGems > 0 ? 30 : 0 : 0;
		super(src_ResourceLoader.getImage("data/ui/touch/refresh.png").resource,new h3d_Vector(135,55 + offset),35);
		this.guiElement.horizSizing = gui_HorizSizing.Right;
		this.guiElement.vertSizing = gui_VertSizing.Bottom;
		this.onClick = function() {
			if(src_MarbleGame.instance.world.finishTime == null) {
				src_MarbleGame.instance.world.performRestart();
			}
		};
	}
}
$hxClasses["touch.RestartButton"] = touch_RestartButton;
touch_RestartButton.__name__ = "touch.RestartButton";
touch_RestartButton.__super__ = touch_TouchButton;
Object.assign(touch_RestartButton.prototype, {
	__class__: touch_RestartButton
});
class touch_RewindButton extends touch_TouchButton {
	constructor() {
		let tmp = src_Settings.touchSettings.rewindButtonPos[0];
		let tmp1 = src_Settings.touchSettings.rewindButtonPos[1];
		super(src_ResourceLoader.getImage("data/ui/touch/rewind.png").resource,new h3d_Vector(tmp,tmp1),src_Settings.touchSettings.rewindButtonSize);
	}
}
$hxClasses["touch.RewindButton"] = touch_RewindButton;
touch_RewindButton.__name__ = "touch.RewindButton";
touch_RewindButton.__super__ = touch_TouchButton;
Object.assign(touch_RewindButton.prototype, {
	__class__: touch_RewindButton
});
class touch_TouchEditButton extends gui_GuiGraphics {
	constructor(img,position,radius) {
		gui_GuiControl._hx_skip_constructor = true;
		super();
		gui_GuiControl._hx_skip_constructor = false;
		this._hx_constructor(img,position,radius);
	}
	_hx_constructor(img,position,radius) {
		this.state = 0;
		this.selected = false;
		this.imgTile = img.toTile();
		let g = new h2d_Graphics();
		g.beginFill(16777215);
		g.drawCircle(0,0,radius);
		g.beginTileFill(-(this.imgTile.width * 1.5 * radius / this.imgTile.width) / 2,-(this.imgTile.height * 1.5 * radius / this.imgTile.width) / 2,1.5 * radius / this.imgTile.width,1.5 * radius / this.imgTile.height,this.imgTile);
		g.drawRect(-(this.imgTile.width * 1.5 * radius / this.imgTile.width) / 2,-(this.imgTile.height * 1.5 * radius / this.imgTile.width / 2),this.imgTile.width * 1.5 * radius / this.imgTile.width,this.imgTile.height * 1.5 * radius / this.imgTile.width);
		g.endFill();
		super._hx_constructor(g);
		this.position = position;
		this.extent = new h3d_Vector(2 * radius,2 * radius);
		this.horizSizing = gui_HorizSizing.Left;
		this.vertSizing = gui_VertSizing.Top;
		this.radius = radius;
	}
	getHitTestRect(useScroll) {
		if(useScroll == null) {
			useScroll = true;
		}
		let thisRect = this.getRenderRectangle();
		let _this = thisRect.position;
		let x = this.radius;
		let y = this.radius;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let v_x = x;
		let v_y = y;
		thisRect.position = new h3d_Vector(_this.x - v_x,_this.y - v_y,_this.z,_this.w - 1.);
		if(this.selected) {
			let _this = thisRect.position;
			thisRect.position = new h3d_Vector(_this.x + (-21.5),_this.y + (-21.5),_this.z,_this.w + 1.);
			let _this1 = thisRect.extent;
			let v_x = 43;
			let v_y = 43;
			thisRect.extent = new h3d_Vector(_this1.x + v_x,_this1.y + v_y,_this1.z,_this1.w + 1.);
		}
		if(this.parent == null) {
			return thisRect;
		} else {
			return thisRect.intersect(this.parent.getRenderRectangle());
		}
	}
	onMousePress(mouseState) {
		this.onClick(this,mouseState);
		this.mousePos = mouseState.position;
		let renderRect = this.getHitTestRect();
		let x = renderRect.position.x + renderRect.extent.x / 2;
		let y = renderRect.position.y + 15;
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let knobPos_x = x;
		let knobPos_y = y;
		let _this = mouseState.position;
		let x1 = _this.x - knobPos_x;
		let y1 = _this.y - knobPos_y;
		let z = _this.z;
		if(z == null) {
			z = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let _this_x = x1;
		let _this_y = y1;
		let _this_z = z;
		if(Math.sqrt(_this_x * _this_x + _this_y * _this_y + _this_z * _this_z) < 15) {
			this.state = 1;
		} else {
			this.state = 2;
		}
	}
	onMouseDown(mouseState) {
		if(this.selected) {
			let _this = mouseState.position;
			let v = this.mousePos;
			let x = _this.x - v.x;
			let y = _this.y - v.y;
			let z = _this.z - v.z;
			let w = _this.w - v.w;
			if(w == null) {
				w = 1.;
			}
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let deltaPos_x = x;
			let deltaPos_y = y;
			let deltaPos_z = z;
			let deltaPos_w = w;
			this.mousePos = mouseState.position;
			if(this.state == 1) {
				let renderRect = this.getHitTestRect();
				let _this = mouseState.position;
				let _this1 = renderRect.position;
				let _this2 = renderRect.extent;
				let x = _this2.x * 0.5;
				let y = _this2.y * 0.5;
				let z = _this2.z * 0.5;
				let w = _this2.w;
				if(w == null) {
					w = 1.;
				}
				if(z == null) {
					z = 0.;
				}
				if(y == null) {
					y = 0.;
				}
				if(x == null) {
					x = 0.;
				}
				let v_x = x;
				let v_y = y;
				let v_z = z;
				let v_w = w;
				let x1 = _this1.x + v_x;
				let y1 = _this1.y + v_y;
				let z1 = _this1.z + v_z;
				let w1 = _this1.w + v_w;
				if(w1 == null) {
					w1 = 1.;
				}
				if(z1 == null) {
					z1 = 0.;
				}
				if(y1 == null) {
					y1 = 0.;
				}
				if(x1 == null) {
					x1 = 0.;
				}
				let v_x1 = x1;
				let v_y1 = y1;
				let v_z1 = z1;
				let x2 = _this.x - v_x1;
				let y2 = _this.y - v_y1;
				let z2 = _this.z - v_z1;
				if(z2 == null) {
					z2 = 0.;
				}
				if(y2 == null) {
					y2 = 0.;
				}
				if(x2 == null) {
					x2 = 0.;
				}
				let _this_x = x2;
				let _this_y = y2;
				let _this_z = z2;
				let value = Math.sqrt(_this_x * _this_x + _this_y * _this_y + _this_z * _this_z);
				let newRadius = value < 15 ? 15 : value > 80 ? 80 : value;
				this.radius = newRadius;
				this.extent = new h3d_Vector(2 * newRadius,2 * newRadius);
				this.setSelected(false);
				this.setSelected(true);
				this.onChangeCb(this,this.position,this.radius);
			}
			if(this.state == 2) {
				let _this = this.graphics;
				_this.posChanged = true;
				_this.x = this.graphics.x + deltaPos_x;
				_this.posChanged = true;
				_this.y = this.graphics.y + deltaPos_y;
				let _this1 = this.position;
				this.position = new h3d_Vector(_this1.x + deltaPos_x,_this1.y + deltaPos_y,_this1.z + deltaPos_z,_this1.w + deltaPos_w);
				this.onChangeCb(this,this.position,this.radius);
			}
		}
	}
	onMouseRelease(mouseState) {
		this.state = 0;
	}
	setSelected(selected) {
		this.selected = selected;
		if(selected) {
			this.graphics.beginFill(16777215);
			this.graphics.drawPieInner(0,0,this.radius + 8,this.radius + 5,0,2 * Math.PI);
			this.graphics.endFill();
			this.graphics.beginFill(9145227);
			this.graphics.drawCircle(0,-this.radius - 6.5,15);
			this.graphics.endFill();
		} else {
			this.graphics.clear();
			this.graphics.beginFill(16777215);
			this.graphics.drawCircle(0,0,this.radius);
			this.graphics.beginTileFill(-(this.imgTile.width * 1.5 * this.radius / this.imgTile.width) / 2,-(this.imgTile.height * 1.5 * this.radius / this.imgTile.width) / 2,1.5 * this.radius / this.imgTile.width,1.5 * this.radius / this.imgTile.height,this.imgTile);
			this.graphics.drawRect(-(this.imgTile.width * 1.5 * this.radius / this.imgTile.width) / 2,-(this.imgTile.height * 1.5 * this.radius / this.imgTile.width / 2),this.imgTile.width * 1.5 * this.radius / this.imgTile.width,this.imgTile.height * 1.5 * this.radius / this.imgTile.width);
			this.graphics.endFill();
		}
	}
}
$hxClasses["touch.TouchEditButton"] = touch_TouchEditButton;
touch_TouchEditButton.__name__ = "touch.TouchEditButton";
touch_TouchEditButton.__super__ = gui_GuiGraphics;
Object.assign(touch_TouchEditButton.prototype, {
	__class__: touch_TouchEditButton
	,radius: null
	,selected: null
	,onClick: null
	,onChangeCb: null
	,imgTile: null
	,mousePos: null
	,state: null
});
var touch_TouchState = $hxEnums["touch.TouchState"] = { __ename__:true,__constructs__:null
	,Pressed: {_hx_name:"Pressed",_hx_index:0,__enum__:"touch.TouchState",toString:$estr}
	,Move: {_hx_name:"Move",_hx_index:1,__enum__:"touch.TouchState",toString:$estr}
	,Release: {_hx_name:"Release",_hx_index:2,__enum__:"touch.TouchState",toString:$estr}
};
touch_TouchState.__constructs__ = [touch_TouchState.Pressed,touch_TouchState.Move,touch_TouchState.Release];
touch_TouchState.__empty_constructs__ = [touch_TouchState.Pressed,touch_TouchState.Move,touch_TouchState.Release];
class touch_Touch {
	constructor(state,position,deltaPos,id) {
		this.state = state;
		this.position = position;
		this.deltaPosition = deltaPos;
		this.identifier = id;
	}
}
$hxClasses["touch.Touch"] = touch_Touch;
touch_Touch.__name__ = "touch.Touch";
Object.assign(touch_Touch.prototype, {
	__class__: touch_Touch
	,state: null
	,position: null
	,deltaPosition: null
	,identifier: null
});
class touch_TouchEventState {
	constructor() {
		this.changedTouches = [];
	}
}
$hxClasses["touch.TouchEventState"] = touch_TouchEventState;
touch_TouchEventState.__name__ = "touch.TouchEventState";
Object.assign(touch_TouchEventState.prototype, {
	__class__: touch_TouchEventState
	,changedTouches: null
});
class touch_TouchInput {
	constructor() {
		this.touches = new haxe_ds_IntMap();
		this.cameraInput = new touch_CameraInput();
		this.movementInput = new touch_MovementInput();
		this.jumpButton = new touch_JumpButton();
		this.powerupButton = new touch_PowerupButton();
		this.blastbutton = new touch_BlastButton();
		this.pauseButton = new touch_PauseButton();
		this.rewindButton = new touch_RewindButton();
		this.restartButton = new touch_RestartButton();
		this.currentTouchState = new touch_TouchEventState();
		this.previousTouchState = new touch_TouchEventState();
	}
	registerTouchInput() {
		let pointercontainer = window.document.querySelector("#webgl");
		let _gthis = this;
		pointercontainer.addEventListener("touchstart",function(e) {
			let _g = 0;
			let _g1 = e.changedTouches;
			while(_g < _g1.length) {
				let touch = _g1[_g];
				++_g;
				let t = new touch_Touch(touch_TouchState.Pressed,new h3d_Vector(touch.clientX,touch.clientY),new h3d_Vector(0,0),touch.identifier);
				_gthis.currentTouchState.changedTouches.push(t);
				_gthis.touches.h[touch.identifier] = t;
			}
		});
		pointercontainer.addEventListener("touchmove",function(e) {
			let _g = 0;
			let _g1 = e.changedTouches;
			while(_g < _g1.length) {
				let touch = _g1[_g];
				++_g;
				let prevt = _gthis.touches.h[touch.identifier];
				let prevDelta = new h3d_Vector(0,0);
				if(prevt != null) {
					let x = touch.clientX;
					let y = touch.clientY;
					if(y == null) {
						y = 0.;
					}
					if(x == null) {
						x = 0.;
					}
					let _this_x = x;
					let _this_y = y;
					let v = prevt.position;
					prevDelta = new h3d_Vector(_this_x - v.x,_this_y - v.y,0. - v.z,1. - v.w);
				}
				let t = new touch_Touch(touch_TouchState.Move,new h3d_Vector(touch.clientX,touch.clientY),prevDelta,touch.identifier);
				_gthis.currentTouchState.changedTouches.push(t);
				_gthis.touches.h[touch.identifier] = t;
			}
		});
		pointercontainer.addEventListener("touchend",function(e) {
			let _g = 0;
			let _g1 = e.changedTouches;
			while(_g < _g1.length) {
				let touch = _g1[_g];
				++_g;
				let t = new touch_Touch(touch_TouchState.Release,new h3d_Vector(touch.clientX,touch.clientY),new h3d_Vector(0,0),touch.identifier);
				_gthis.currentTouchState.changedTouches.push(t);
				_gthis.touches.remove(touch.identifier);
			}
		});
	}
	update() {
		this.previousTouchState = this.currentTouchState;
		this.currentTouchState = new touch_TouchEventState();
	}
	showControls(parentGui,ultra) {
		this.jumpButton.dispose();
		this.powerupButton.dispose();
		if(ultra) {
			this.blastbutton.dispose();
		}
		this.movementInput.dispose();
		this.pauseButton.dispose();
		this.restartButton.dispose();
		this.cameraInput.dispose();
		this.cameraInput = new touch_CameraInput();
		this.movementInput = new touch_MovementInput();
		this.jumpButton = new touch_JumpButton();
		this.powerupButton = new touch_PowerupButton();
		if(src_Settings.optionsSettings.rewindEnabled && !net_Net.isMP) {
			this.rewindButton = new touch_RewindButton();
		}
		if(ultra) {
			this.blastbutton = new touch_BlastButton();
		}
		this.pauseButton = new touch_PauseButton();
		if(!net_Net.isMP) {
			this.restartButton = new touch_RestartButton();
		}
		this.pauseButton.add(parentGui);
		if(!net_Net.isMP) {
			this.restartButton.add(parentGui);
		}
		this.jumpButton.add(parentGui);
		this.powerupButton.add(parentGui);
		if(src_Settings.optionsSettings.rewindEnabled && !net_Net.isMP) {
			this.rewindButton.add(parentGui);
		}
		if(ultra) {
			this.blastbutton.add(parentGui);
		}
		this.movementInput.add(parentGui);
		this.cameraInput.add(parentGui);
		this.cameraInput.enabled = true;
		if(src_Settings.touchSettings.hideControls) {
			this.jumpButton.setVisible(false);
			this.powerupButton.setVisible(false);
			if(this.blastbutton != null) {
				this.blastbutton.setVisible(false);
			}
			this.movementInput.setVisible(false);
			this.pauseButton.setVisible(false);
			if(this.restartButton != null) {
				this.restartButton.setVisible(false);
			}
			if(this.rewindButton != null) {
				this.rewindButton.setVisible(false);
			}
		}
	}
	setControlsEnabled(enabled) {
		this.jumpButton.setVisible(enabled);
		this.powerupButton.setVisible(enabled);
		if(this.blastbutton != null) {
			this.blastbutton.setVisible(enabled);
		}
		this.movementInput.setVisible(enabled);
		this.pauseButton.setVisible(enabled);
		if(this.restartButton != null) {
			this.restartButton.setVisible(enabled);
		}
		if(this.rewindButton != null) {
			this.rewindButton.setVisible(enabled);
		}
		this.cameraInput.enabled = enabled;
		if(src_Settings.touchSettings.hideControls) {
			this.jumpButton.setVisible(false);
			this.powerupButton.setVisible(false);
			if(this.blastbutton != null) {
				this.blastbutton.setVisible(false);
			}
			this.movementInput.setVisible(false);
			if(this.rewindButton != null) {
				this.rewindButton.setVisible(false);
			}
		}
	}
	hideControls(parentGui) {
		this.jumpButton.remove(parentGui);
		this.powerupButton.remove(parentGui);
		if(this.blastbutton != null) {
			this.blastbutton.remove(parentGui);
		}
		this.movementInput.remove(parentGui);
		this.pauseButton.remove(parentGui);
		if(this.restartButton != null) {
			this.restartButton.remove(parentGui);
		}
		this.cameraInput.remove(parentGui);
		if(this.rewindButton != null) {
			this.rewindButton.remove(parentGui);
		}
		this.jumpButton.dispose();
		this.powerupButton.dispose();
		this.movementInput.dispose();
		this.pauseButton.dispose();
		this.restartButton.dispose();
		this.cameraInput.dispose();
		if(this.rewindButton != null) {
			this.rewindButton.dispose();
		}
	}
}
$hxClasses["touch.TouchInput"] = touch_TouchInput;
touch_TouchInput.__name__ = "touch.TouchInput";
Object.assign(touch_TouchInput.prototype, {
	__class__: touch_TouchInput
	,cameraInput: null
	,movementInput: null
	,jumpButton: null
	,powerupButton: null
	,blastbutton: null
	,pauseButton: null
	,rewindButton: null
	,restartButton: null
	,currentTouchState: null
	,previousTouchState: null
	,touches: null
});
class triggers_Trigger extends src_GameObject {
	constructor(element,level) {
		if(h3d_scene_Object._hx_skip_constructor) {
			super();
			return;
		}
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(element,level);
	}
	_hx_constructor(element,level) {
		this.accountForGravity = false;
		super._hx_constructor();
		this.element = element;
		this.id = element._id;
		this.level = level;
		let coordinates = mis_MisParser.parseNumberList(element.polyhedron);
		let x = -coordinates[0];
		let y = coordinates[1];
		let z = coordinates[2];
		if(z == null) {
			z = 0.;
		}
		if(y == null) {
			y = 0.;
		}
		if(x == null) {
			x = 0.;
		}
		let origin_x = x;
		let origin_y = y;
		let origin_z = z;
		let x1 = -coordinates[3];
		let y1 = coordinates[4];
		let z1 = coordinates[5];
		if(z1 == null) {
			z1 = 0.;
		}
		if(y1 == null) {
			y1 = 0.;
		}
		if(x1 == null) {
			x1 = 0.;
		}
		let d1_x = x1;
		let d1_y = y1;
		let d1_z = z1;
		let x2 = -coordinates[6];
		let y2 = coordinates[7];
		let z2 = coordinates[8];
		if(z2 == null) {
			z2 = 0.;
		}
		if(y2 == null) {
			y2 = 0.;
		}
		if(x2 == null) {
			x2 = 0.;
		}
		let d2_x = x2;
		let d2_y = y2;
		let d2_z = z2;
		let x3 = -coordinates[9];
		let y3 = coordinates[10];
		let z3 = coordinates[11];
		if(z3 == null) {
			z3 = 0.;
		}
		if(y3 == null) {
			y3 = 0.;
		}
		if(x3 == null) {
			x3 = 0.;
		}
		let d3_x = x3;
		let d3_y = y3;
		let d3_z = z3;
		let p1 = new h3d_Vector(origin_x,origin_y,origin_z,1.);
		let p2 = new h3d_Vector(origin_x + d1_x,origin_y + d1_y,origin_z + d1_z,2.);
		let p3 = new h3d_Vector(origin_x + d2_x,origin_y + d2_y,origin_z + d2_z,2.);
		let p4 = new h3d_Vector(origin_x + d3_x,origin_y + d3_y,origin_z + d3_z,2.);
		let x4 = origin_x + d1_x;
		let y4 = origin_y + d1_y;
		let z4 = origin_z + d1_z;
		if(z4 == null) {
			z4 = 0.;
		}
		if(y4 == null) {
			y4 = 0.;
		}
		if(x4 == null) {
			x4 = 0.;
		}
		let _this_x = x4;
		let _this_y = y4;
		let _this_z = z4;
		let p5 = new h3d_Vector(_this_x + d2_x,_this_y + d2_y,_this_z + d2_z,3.);
		let x5 = origin_x + d1_x;
		let y5 = origin_y + d1_y;
		let z5 = origin_z + d1_z;
		if(z5 == null) {
			z5 = 0.;
		}
		if(y5 == null) {
			y5 = 0.;
		}
		if(x5 == null) {
			x5 = 0.;
		}
		let _this_x1 = x5;
		let _this_y1 = y5;
		let _this_z1 = z5;
		let p6 = new h3d_Vector(_this_x1 + d3_x,_this_y1 + d3_y,_this_z1 + d3_z,3.);
		let x6 = origin_x + d2_x;
		let y6 = origin_y + d2_y;
		let z6 = origin_z + d2_z;
		if(z6 == null) {
			z6 = 0.;
		}
		if(y6 == null) {
			y6 = 0.;
		}
		if(x6 == null) {
			x6 = 0.;
		}
		let _this_x2 = x6;
		let _this_y2 = y6;
		let _this_z2 = z6;
		let p7 = new h3d_Vector(_this_x2 + d3_x,_this_y2 + d3_y,_this_z2 + d3_z,3.);
		let x7 = origin_x + d1_x;
		let y7 = origin_y + d1_y;
		let z7 = origin_z + d1_z;
		if(z7 == null) {
			z7 = 0.;
		}
		if(y7 == null) {
			y7 = 0.;
		}
		if(x7 == null) {
			x7 = 0.;
		}
		let _this_x3 = x7;
		let _this_y3 = y7;
		let _this_z3 = z7;
		let x8 = _this_x3 + d2_x;
		let y8 = _this_y3 + d2_y;
		let z8 = _this_z3 + d2_z;
		if(z8 == null) {
			z8 = 0.;
		}
		if(y8 == null) {
			y8 = 0.;
		}
		if(x8 == null) {
			x8 = 0.;
		}
		let _this_x4 = x8;
		let _this_y4 = y8;
		let _this_z4 = z8;
		let p8 = new h3d_Vector(_this_x4 + d3_x,_this_y4 + d3_y,_this_z4 + d3_z,4.);
		let scale = mis_MisParser.parseVector3(element.scale);
		let mat = new h3d_Matrix();
		mat.identity();
		mat.scale(scale.x,scale.y,scale.z);
		let quat = mis_MisParser.parseRotation(element.rotation);
		quat.x = -quat.x;
		quat.w = -quat.w;
		let m = null;
		m = new h3d_Matrix();
		let xx = quat.x * quat.x;
		let xy = quat.x * quat.y;
		let xz = quat.x * quat.z;
		let xw = quat.x * quat.w;
		let yy = quat.y * quat.y;
		let yz = quat.y * quat.z;
		let yw = quat.y * quat.w;
		let zz = quat.z * quat.z;
		let zw = quat.z * quat.w;
		m._11 = 1 - 2 * (yy + zz);
		m._12 = 2 * (xy + zw);
		m._13 = 2 * (xz - yw);
		m._14 = 0;
		m._21 = 2 * (xy - zw);
		m._22 = 1 - 2 * (xx + zz);
		m._23 = 2 * (yz + xw);
		m._24 = 0;
		m._31 = 2 * (xz + yw);
		m._32 = 2 * (yz - xw);
		m._33 = 1 - 2 * (xx + yy);
		m._34 = 0;
		m._41 = 0;
		m._42 = 0;
		m._43 = 0;
		m._44 = 1;
		mat.multiply(mat,m);
		let pos = mis_MisParser.parseVector3(element.position);
		pos.x = -pos.x;
		let _this = [p1,p2,p3,p4,p5,p6,p7,p8];
		let result = new Array(_this.length);
		let _g = 0;
		let _g1 = _this.length;
		while(_g < _g1) {
			let i = _g++;
			let vert = _this[i];
			let px = vert.x * mat._11 + vert.y * mat._21 + vert.z * mat._31 + vert.w * mat._41;
			let py = vert.x * mat._12 + vert.y * mat._22 + vert.z * mat._32 + vert.w * mat._42;
			let pz = vert.x * mat._13 + vert.y * mat._23 + vert.z * mat._33 + vert.w * mat._43;
			let pw = vert.x * mat._14 + vert.y * mat._24 + vert.z * mat._34 + vert.w * mat._44;
			result[i] = new h3d_Vector(px,py,pz,pw);
		}
		this.vertices = result;
		let boundingbox = new h3d_col_Bounds();
		let _g2 = 0;
		let _g3 = this.vertices;
		while(_g2 < _g3.length) {
			let vector = _g3[_g2];
			++_g2;
			let x = vector.x + pos.x;
			let y = vector.y + pos.y;
			let z = vector.z + pos.z;
			if(z == null) {
				z = 0.;
			}
			if(y == null) {
				y = 0.;
			}
			if(x == null) {
				x = 0.;
			}
			let _this_x = x;
			let _this_y = y;
			let _this_z = z;
			let x1 = _this_x;
			let y1 = _this_y;
			let z1 = _this_z;
			if(_this_z == null) {
				z1 = 0.;
			}
			if(_this_y == null) {
				y1 = 0.;
			}
			if(_this_x == null) {
				x1 = 0.;
			}
			let p_x = x1;
			let p_y = y1;
			let p_z = z1;
			if(p_x < boundingbox.xMin) {
				boundingbox.xMin = p_x;
			}
			if(p_x > boundingbox.xMax) {
				boundingbox.xMax = p_x;
			}
			if(p_y < boundingbox.yMin) {
				boundingbox.yMin = p_y;
			}
			if(p_y > boundingbox.yMax) {
				boundingbox.yMax = p_y;
			}
			if(p_z < boundingbox.zMin) {
				boundingbox.zMin = p_z;
			}
			if(p_z > boundingbox.zMax) {
				boundingbox.zMax = p_z;
			}
		}
		this.collider = new collision_BoxCollisionEntity(boundingbox,this);
	}
	update(timeState) {
	}
	init(onFinish) {
		onFinish();
	}
}
$hxClasses["triggers.Trigger"] = triggers_Trigger;
triggers_Trigger.__name__ = "triggers.Trigger";
triggers_Trigger.__super__ = src_GameObject;
Object.assign(triggers_Trigger.prototype, {
	__class__: triggers_Trigger
	,id: null
	,level: null
	,element: null
	,vertices: null
	,collider: null
	,accountForGravity: null
});
class triggers_CheckpointTrigger extends triggers_Trigger {
	constructor(element,level) {
		h3d_scene_Object._hx_skip_constructor = true;
		super();
		h3d_scene_Object._hx_skip_constructor = false;
		this._hx_constructor(element,level);
	}
	_hx_constructor(element,level) {
		this.add = null;
		this.disableOOB = false;
		super._hx_constructor(element,level);
		this.disableOOB = Object.prototype.hasOwnProperty.call(element.fields.h,"disableOob") && mis_MisParser.parseBoolean(element.fields.h["disableOob"][0]);
		this.add = Object.prototype.hasOwnProperty.call(element.fields.h,"add") ? mis_MisParser.parseVector3(element.fields.h["add"][0]) : null;
		this.seqNum = Object.prototype.hasOwnProperty.call(element.fields.h,"sequence") ? Std.parseInt(element.sequence) : 1;
	}
	init(onFinish) {
		super.init(function() {
			src_ResourceLoader.load("sound/checkpoint.wav").entry.load(onFinish);
		});
	}
	onMarbleEnter(marble,time) {
		super.onMarbleEnter(marble,time);
		if(this.simGroup == null) {
			return;
		}
		let _this = this.level.simGroups.h[this.simGroup.__id__];
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this.length) {
			let v = _this[_g1];
			++_g1;
			if(v.identifier == "Checkpoint") {
				_g.push(v);
			}
		}
		if(_g.length == 0) {
			return;
		}
		let chk = _g[0];
		let prevChk = this.level.currentCheckpoint;
		let issame = prevChk == chk;
		if(this.level.saveCheckpointState(chk,this)) {
			if(!issame) {
				chk.lastActivatedTime = time.timeSinceLoad;
				let _g = 0;
				let _g1 = this.level.dtsObjects;
				while(_g < _g1.length) {
					let obj = _g1[_g];
					++_g;
					if(obj.identifier == "Checkpoint" && obj != chk) {
						(js_Boot.__cast(obj , shapes_Checkpoint)).lastActivatedTime = Infinity;
					}
				}
			}
		}
	}
}
$hxClasses["triggers.CheckpointTrigger"] = triggers_CheckpointTrigger;
triggers_CheckpointTrigger.__name__ = "triggers.CheckpointTrigger";
triggers_CheckpointTrigger.__super__ = triggers_Trigger;
Object.assign(triggers_CheckpointTrigger.prototype, {
	__class__: triggers_CheckpointTrigger
	,disableOOB: null
	,add: null
	,simGroup: null
	,seqNum: null
});
class triggers_HelpTrigger extends triggers_Trigger {
	constructor(element,level) {
		super(element,level);
	}
	onMarbleEnter(marble,timeState) {
		src_AudioManager.playSound(src_ResourceLoader.getResource("data/sound/infotutorial.wav",src_ResourceLoader.getAudio,this.soundResources));
		if(this.element.text != null && this.element.text != "") {
			this.level.displayHelp(this.element.text);
		}
	}
	init(onFinish) {
		src_ResourceLoader.load("sound/infotutorial.wav").entry.load(onFinish);
	}
}
$hxClasses["triggers.HelpTrigger"] = triggers_HelpTrigger;
triggers_HelpTrigger.__name__ = "triggers.HelpTrigger";
triggers_HelpTrigger.__super__ = triggers_Trigger;
Object.assign(triggers_HelpTrigger.prototype, {
	__class__: triggers_HelpTrigger
});
class triggers_InBoundsTrigger extends triggers_Trigger {
	constructor(element,level) {
		super(element,level);
		this.accountForGravity = true;
	}
	onMarbleLeave(marble,timeState) {
		this.level.goOutOfBounds(marble);
	}
	init(onFinish) {
		src_ResourceLoader.load("sound/whoosh.wav").entry.load(onFinish);
	}
}
$hxClasses["triggers.InBoundsTrigger"] = triggers_InBoundsTrigger;
triggers_InBoundsTrigger.__name__ = "triggers.InBoundsTrigger";
triggers_InBoundsTrigger.__super__ = triggers_Trigger;
Object.assign(triggers_InBoundsTrigger.prototype, {
	__class__: triggers_InBoundsTrigger
});
class triggers_MustChangeTrigger extends triggers_Trigger {
	constructor(element,interior) {
		super(element,interior.level);
		this.interior = interior;
	}
	onMarbleEnter(marble,time) {
		let ttime = mis_MisParser.parseNumber(this.element.targettime);
		if(ttime > 0) {
			ttime /= 1000;
		}
		this.interior.setTargetTime(time,ttime);
		if(this.element.instant == "1") {
			if(this.element.icontinuetottime != null && this.element.icontinuetottime != "0") {
				this.interior.currentTime = this.interior.targetTime;
				let tmp = mis_MisParser.parseNumber(this.element.icontinuetottime);
				this.interior.targetTime = tmp / 1000;
			}
		}
	}
}
$hxClasses["triggers.MustChangeTrigger"] = triggers_MustChangeTrigger;
triggers_MustChangeTrigger.__name__ = "triggers.MustChangeTrigger";
triggers_MustChangeTrigger.__super__ = triggers_Trigger;
Object.assign(triggers_MustChangeTrigger.prototype, {
	__class__: triggers_MustChangeTrigger
	,interior: null
});
class triggers_OutOfBoundsTrigger extends triggers_Trigger {
	constructor(element,level) {
		super(element,level);
	}
	onMarbleInside(marble,time) {
		this.level.goOutOfBounds(marble);
	}
	init(onFinish) {
		src_ResourceLoader.load("sound/whoosh.wav").entry.load(onFinish);
	}
}
$hxClasses["triggers.OutOfBoundsTrigger"] = triggers_OutOfBoundsTrigger;
triggers_OutOfBoundsTrigger.__name__ = "triggers.OutOfBoundsTrigger";
triggers_OutOfBoundsTrigger.__super__ = triggers_Trigger;
Object.assign(triggers_OutOfBoundsTrigger.prototype, {
	__class__: triggers_OutOfBoundsTrigger
});
var zip_CompressionLevel = $hxEnums["zip.CompressionLevel"] = { __ename__:true,__constructs__:null
	,UNCOMPRESSED: {_hx_name:"UNCOMPRESSED",_hx_index:0,__enum__:"zip.CompressionLevel",toString:$estr}
	,FAST: {_hx_name:"FAST",_hx_index:1,__enum__:"zip.CompressionLevel",toString:$estr}
	,NORMAL: {_hx_name:"NORMAL",_hx_index:2,__enum__:"zip.CompressionLevel",toString:$estr}
	,GOOD: {_hx_name:"GOOD",_hx_index:3,__enum__:"zip.CompressionLevel",toString:$estr}
};
zip_CompressionLevel.__constructs__ = [zip_CompressionLevel.UNCOMPRESSED,zip_CompressionLevel.FAST,zip_CompressionLevel.NORMAL,zip_CompressionLevel.GOOD];
zip_CompressionLevel.__empty_constructs__ = [zip_CompressionLevel.UNCOMPRESSED,zip_CompressionLevel.FAST,zip_CompressionLevel.NORMAL,zip_CompressionLevel.GOOD];
class zip_MemoryRange {
	constructor(offset,end) {
		this.offset = offset;
		this.end = end;
	}
}
$hxClasses["zip.MemoryRange"] = zip_MemoryRange;
zip_MemoryRange.__name__ = "zip.MemoryRange";
Object.assign(zip_MemoryRange.prototype, {
	__class__: zip_MemoryRange
	,offset: null
	,end: null
});
class zip__$DeflateStream_Memory {
}
$hxClasses["zip._DeflateStream.Memory"] = zip__$DeflateStream_Memory;
zip__$DeflateStream_Memory.__name__ = "zip._DeflateStream.Memory";
class zip_DeflateStream {
	constructor(level,writeZLIBInfo,scratchAddr,startAddr) {
		this._new(level,writeZLIBInfo,scratchAddr,startAddr);
	}
	_new(level,writeZLIBInfo,scratchAddr,startAddr) {
		this.level = level;
		this.zlib = writeZLIBInfo;
		this.scratchAddr = scratchAddr;
		this.startAddr = startAddr;
		this.currentAddr = startAddr;
		this.rangeResult = new zip_MemoryRange(0,0);
		zip__$DeflateStream_HuffmanTree.scratchAddr = scratchAddr + 1348;
		let minLength = startAddr + 15;
		if(zip__$DeflateStream_Memory.memory.length < minLength) {
			let isMemory = zip__$DeflateStream_Memory.memory == zip_DeflateStream.memory;
			let temp = zip__$DeflateStream_Memory.memory;
			zip__$DeflateStream_Memory.memory = new haxe_io_Bytes(new ArrayBuffer(minLength));
			zip__$DeflateStream_Memory.memory.blit(0,temp,0,temp.length);
			if(isMemory) {
				zip_DeflateStream.memory = zip__$DeflateStream_Memory.memory;
			}
		}
		this.distanceCodes = -1;
		this.blockInProgress = false;
		this.blockStartAddr = this.currentAddr;
		this.bitOffset = 0;
		this.s1 = 1;
		this.s2 = 0;
		if(this.zlib) {
			zip__$DeflateStream_Memory.memory.b[this.currentAddr] = 120;
			++this.currentAddr;
			zip__$DeflateStream_Memory.memory.b[this.currentAddr] = 156;
			++this.currentAddr;
		}
		if(this.level == zip_CompressionLevel.NORMAL || this.level == zip_CompressionLevel.GOOD) {
			let offset = this.scratchAddr + 2492;
			zip__$DeflateStream_Memory.memory.setInt32(offset + 12,16842755);
			zip__$DeflateStream_Memory.memory.setInt32(offset + 16,16908292);
			zip__$DeflateStream_Memory.memory.setInt32(offset + 20,16973829);
			zip__$DeflateStream_Memory.memory.setInt32(offset + 24,17039366);
			zip__$DeflateStream_Memory.memory.setInt32(offset + 28,17104903);
			zip__$DeflateStream_Memory.memory.setInt32(offset + 32,17170440);
			zip__$DeflateStream_Memory.memory.setInt32(offset + 36,17235977);
			zip__$DeflateStream_Memory.memory.setInt32(offset + 40,17301514);
			let base = 11;
			let symbol = 265;
			let _g = 11;
			while(_g < 13) {
				let i = _g++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,17375243);
			}
			base = 13;
			symbol = 266;
			let _g1 = 13;
			while(_g1 < 15) {
				let i = _g1++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,17440781);
			}
			base = 15;
			symbol = 267;
			let _g2 = 15;
			while(_g2 < 17) {
				let i = _g2++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,17506319);
			}
			base = 17;
			symbol = 268;
			let _g3 = 17;
			while(_g3 < 19) {
				let i = _g3++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,17571857);
			}
			base = 19;
			symbol = 269;
			let _g4 = 19;
			while(_g4 < 23) {
				let i = _g4++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,17645587);
			}
			base = 23;
			symbol = 270;
			let _g5 = 23;
			while(_g5 < 27) {
				let i = _g5++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,17711127);
			}
			base = 27;
			symbol = 271;
			let _g6 = 27;
			while(_g6 < 31) {
				let i = _g6++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,17776667);
			}
			base = 31;
			symbol = 272;
			let _g7 = 31;
			while(_g7 < 35) {
				let i = _g7++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,17842207);
			}
			base = 35;
			symbol = 273;
			let _g8 = 35;
			while(_g8 < 43) {
				let i = _g8++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,17915939);
			}
			base = 43;
			symbol = 274;
			let _g9 = 43;
			while(_g9 < 51) {
				let i = _g9++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,17981483);
			}
			base = 51;
			symbol = 275;
			let _g10 = 51;
			while(_g10 < 59) {
				let i = _g10++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,18047027);
			}
			base = 59;
			symbol = 276;
			let _g11 = 59;
			while(_g11 < 67) {
				let i = _g11++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,18112571);
			}
			base = 67;
			symbol = 277;
			let _g12 = 67;
			while(_g12 < 83) {
				let i = _g12++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,18186307);
			}
			base = 83;
			symbol = 278;
			let _g13 = 83;
			while(_g13 < 99) {
				let i = _g13++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,18251859);
			}
			base = 99;
			symbol = 279;
			let _g14 = 99;
			while(_g14 < 115) {
				let i = _g14++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,18317411);
			}
			base = 115;
			symbol = 280;
			let _g15 = 115;
			while(_g15 < 131) {
				let i = _g15++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,18382963);
			}
			base = 131;
			symbol = 281;
			let _g16 = 131;
			while(_g16 < 163) {
				let i = _g16++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,18456707);
			}
			base = 163;
			symbol = 282;
			let _g17 = 163;
			while(_g17 < 195) {
				let i = _g17++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,18522275);
			}
			base = 195;
			symbol = 283;
			let _g18 = 195;
			while(_g18 < 227) {
				let i = _g18++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,18587843);
			}
			base = 227;
			symbol = 284;
			let _g19 = 227;
			while(_g19 < 259) {
				let i = _g19++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,18653411);
			}
			base = 259;
			symbol = 285;
			zip__$DeflateStream_Memory.memory.setInt32(offset + 1032,18678018);
			offset = this.scratchAddr + 3528;
			zip__$DeflateStream_Memory.memory.setInt32(offset + 4,1);
			zip__$DeflateStream_Memory.memory.setInt32(offset + 8,16777218);
			zip__$DeflateStream_Memory.memory.setInt32(offset + 12,33554435);
			zip__$DeflateStream_Memory.memory.setInt32(offset + 16,50331652);
			base = 5;
			symbol = 4;
			let _g20 = 1;
			while(_g20 < 7) {
				let extraBits = _g20++;
				let _g = base;
				let _g1 = base + (1 << extraBits);
				while(_g < _g1) {
					let i = _g++;
					zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,symbol << 24 | extraBits << 16 | base);
				}
				base += 1 << extraBits;
				++symbol;
				let _g2 = base;
				let _g3 = base + (1 << extraBits);
				while(_g2 < _g3) {
					let i = _g2++;
					zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,symbol << 24 | extraBits << 16 | base);
				}
				base += 1 << extraBits;
				++symbol;
			}
			offset += 1024;
			let _g21 = 7;
			while(_g21 < 14) {
				let extraBits = _g21++;
				let _g = base >>> 7;
				let _g1 = (base >>> 7) + (1 << extraBits - 7);
				while(_g < _g1) {
					let i = _g++;
					zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,symbol << 24 | extraBits << 16 | base);
				}
				base += 1 << extraBits;
				++symbol;
				let _g2 = base >>> 7;
				let _g3 = (base >>> 7) + (1 << extraBits - 7);
				while(_g2 < _g3) {
					let i = _g2++;
					zip__$DeflateStream_Memory.memory.setInt32(offset + i * 4,symbol << 24 | extraBits << 16 | base);
				}
				base += 1 << extraBits;
				++symbol;
			}
		}
		zip__$DeflateStream_Memory.memory.b[this.currentAddr] = 0;
	}
	write(bytes) {
		let inputByteCount = bytes.totlen - bytes.pos;
		let blockCount;
		let blockOverhead;
		let multiplier = 1;
		let extraScratch = 0;
		if(this.level == zip_CompressionLevel.UNCOMPRESSED) {
			blockOverhead = 8;
			blockCount = Math.ceil(UInt.toFloat(inputByteCount) / UInt.toFloat(65535));
		} else {
			if(this.level == zip_CompressionLevel.FAST) {
				blockCount = Math.ceil(inputByteCount * 2 / 49152);
			} else {
				blockCount = Math.ceil(inputByteCount / 98304);
				if(this.level == zip_CompressionLevel.NORMAL) {
					extraScratch = 458752;
				} else if(this.level == zip_CompressionLevel.GOOD) {
					extraScratch = 524308;
				}
			}
			multiplier = 2;
			blockOverhead = 300;
		}
		let offset = this.currentAddr + (inputByteCount * multiplier + blockOverhead * (blockCount + 1) + extraScratch);
		let end = offset + (bytes.totlen - bytes.pos);
		if(zip__$DeflateStream_Memory.memory.length < end) {
			let isMemory = zip__$DeflateStream_Memory.memory == zip_DeflateStream.memory;
			let temp = zip__$DeflateStream_Memory.memory;
			zip__$DeflateStream_Memory.memory = new haxe_io_Bytes(new ArrayBuffer(end));
			zip__$DeflateStream_Memory.memory.blit(0,temp,0,temp.length);
			if(isMemory) {
				zip_DeflateStream.memory = zip__$DeflateStream_Memory.memory;
			}
		}
		let length = 0;
		length = bytes.totlen;
		bytes.readBytes(zip__$DeflateStream_Memory.memory,offset,length);
		this.fastWrite(offset,end);
	}
	fastWrite(offset,end) {
		if(this.level == zip_CompressionLevel.UNCOMPRESSED) {
			let offset1 = offset;
			if(this.zlib) {
				let offset1 = offset;
				while(offset1 + 5552 <= end) {
					let i = offset1;
					while(i < offset1 + 5552) {
						this.s2 = this.s2 + ((this.s1 << 4) + zip__$DeflateStream_Memory.memory.b[i] * 16 + zip__$DeflateStream_Memory.memory.b[i + 1] * 15 + zip__$DeflateStream_Memory.memory.b[i + 2] * 14 + zip__$DeflateStream_Memory.memory.b[i + 3] * 13 + zip__$DeflateStream_Memory.memory.b[i + 4] * 12 + zip__$DeflateStream_Memory.memory.b[i + 5] * 11 + zip__$DeflateStream_Memory.memory.b[i + 6] * 10 + zip__$DeflateStream_Memory.memory.b[i + 7] * 9 + zip__$DeflateStream_Memory.memory.b[i + 8] * 8 + zip__$DeflateStream_Memory.memory.b[i + 9] * 7 + zip__$DeflateStream_Memory.memory.b[i + 10] * 6 + zip__$DeflateStream_Memory.memory.b[i + 11] * 5 + zip__$DeflateStream_Memory.memory.b[i + 12] * 4 + zip__$DeflateStream_Memory.memory.b[i + 13] * 3 + zip__$DeflateStream_Memory.memory.b[i + 14] * 2 + zip__$DeflateStream_Memory.memory.b[i + 15]);
						this.s1 = this.s1 + (zip__$DeflateStream_Memory.memory.b[i] + zip__$DeflateStream_Memory.memory.b[i + 1] + zip__$DeflateStream_Memory.memory.b[i + 2] + zip__$DeflateStream_Memory.memory.b[i + 3] + zip__$DeflateStream_Memory.memory.b[i + 4] + zip__$DeflateStream_Memory.memory.b[i + 5] + zip__$DeflateStream_Memory.memory.b[i + 6] + zip__$DeflateStream_Memory.memory.b[i + 7] + zip__$DeflateStream_Memory.memory.b[i + 8] + zip__$DeflateStream_Memory.memory.b[i + 9] + zip__$DeflateStream_Memory.memory.b[i + 10] + zip__$DeflateStream_Memory.memory.b[i + 11] + zip__$DeflateStream_Memory.memory.b[i + 12] + zip__$DeflateStream_Memory.memory.b[i + 13] + zip__$DeflateStream_Memory.memory.b[i + 14] + zip__$DeflateStream_Memory.memory.b[i + 15]);
						i += 16;
					}
					this.s1 = UInt.toFloat(this.s1) % UInt.toFloat(65521) | 0;
					this.s2 = UInt.toFloat(this.s2) % UInt.toFloat(65521) | 0;
					offset1 += 5552;
				}
				if(offset1 != end) {
					let _g = offset1;
					while(_g < end) {
						let i = _g++;
						this.s1 = this.s1 + zip__$DeflateStream_Memory.memory.b[i];
						this.s2 = this.s2 + this.s1;
					}
					this.s1 = UInt.toFloat(this.s1) % UInt.toFloat(65521) | 0;
					this.s2 = UInt.toFloat(this.s2) % UInt.toFloat(65521) | 0;
				}
			}
			let freeSpace = zip__$DeflateStream_Memory.memory.length - this.currentAddr;
			if(zip__$DeflateStream_Memory.memory.length < freeSpace) {
				let isMemory = zip__$DeflateStream_Memory.memory == zip_DeflateStream.memory;
				let temp = zip__$DeflateStream_Memory.memory;
				zip__$DeflateStream_Memory.memory = new haxe_io_Bytes(new ArrayBuffer(freeSpace));
				zip__$DeflateStream_Memory.memory.blit(0,temp,0,temp.length);
				if(isMemory) {
					zip_DeflateStream.memory = zip__$DeflateStream_Memory.memory;
				}
			}
			while(end - offset1 > 0) {
				let len = Math.min(end - offset1,UInt.toFloat(65535)) | 0;
				this.blockInProgress = true;
				if(this.level == zip_CompressionLevel.UNCOMPRESSED) {
					if(this.bitOffset == 0) {
						zip__$DeflateStream_Memory.memory.b[this.currentAddr] = 0;
					}
					let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
					current |= 0 << this.bitOffset;
					zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
					this.bitOffset += 3;
					this.currentAddr += this.bitOffset >>> 3;
					this.bitOffset &= 7;
					if(this.bitOffset > 0) {
						let bitCount = 8 - this.bitOffset;
						let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current |= 0 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
						this.bitOffset += bitCount;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
					}
				} else {
					let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
					current |= 4 << this.bitOffset;
					zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
					this.bitOffset += 3;
					this.currentAddr += this.bitOffset >>> 3;
					this.bitOffset &= 7;
				}
				this.blockStartAddr = this.currentAddr;
				zip__$DeflateStream_Memory.memory.setUInt16(this.currentAddr,len);
				this.currentAddr += 2;
				zip__$DeflateStream_Memory.memory.setUInt16(this.currentAddr,~len);
				this.currentAddr += 2;
				let cappedEnd = offset1 + len;
				let cappedEnd32 = offset1 + (len & -32);
				let i = offset1;
				while(i < cappedEnd32) {
					let addr = this.currentAddr;
					let v = zip__$DeflateStream_Memory.memory.getInt32(i);
					zip__$DeflateStream_Memory.memory.setInt32(addr,v);
					let addr1 = this.currentAddr + 4;
					let v1 = zip__$DeflateStream_Memory.memory.getInt32(i + 4);
					zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
					let addr2 = this.currentAddr + 8;
					let v2 = zip__$DeflateStream_Memory.memory.getInt32(i + 8);
					zip__$DeflateStream_Memory.memory.setInt32(addr2,v2);
					let addr3 = this.currentAddr + 12;
					let v3 = zip__$DeflateStream_Memory.memory.getInt32(i + 12);
					zip__$DeflateStream_Memory.memory.setInt32(addr3,v3);
					let addr4 = this.currentAddr + 16;
					let v4 = zip__$DeflateStream_Memory.memory.getInt32(i + 16);
					zip__$DeflateStream_Memory.memory.setInt32(addr4,v4);
					let addr5 = this.currentAddr + 20;
					let v5 = zip__$DeflateStream_Memory.memory.getInt32(i + 20);
					zip__$DeflateStream_Memory.memory.setInt32(addr5,v5);
					let addr6 = this.currentAddr + 24;
					let v6 = zip__$DeflateStream_Memory.memory.getInt32(i + 24);
					zip__$DeflateStream_Memory.memory.setInt32(addr6,v6);
					let addr7 = this.currentAddr + 28;
					let v7 = zip__$DeflateStream_Memory.memory.getInt32(i + 28);
					zip__$DeflateStream_Memory.memory.setInt32(addr7,v7);
					this.currentAddr += 32;
					i += 32;
				}
				while(i < cappedEnd) {
					zip__$DeflateStream_Memory.memory.b[this.currentAddr] = zip__$DeflateStream_Memory.memory.b[i];
					++this.currentAddr;
					++i;
				}
				if(this.level != zip_CompressionLevel.UNCOMPRESSED) {
					let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1024);
					let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
					current |= compressed >>> 16 << this.bitOffset;
					zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
					this.bitOffset += compressed & 65535;
					this.currentAddr += this.bitOffset >>> 3;
					this.bitOffset &= 7;
				}
				this.blockInProgress = false;
				offset1 += len;
			}
		} else {
			let len = end - offset;
			let blockCount;
			let blockOverhead;
			let multiplier = 1;
			let extraScratch = 0;
			if(this.level == zip_CompressionLevel.UNCOMPRESSED) {
				blockOverhead = 8;
				blockCount = Math.ceil(UInt.toFloat(len) / UInt.toFloat(65535));
			} else {
				if(this.level == zip_CompressionLevel.FAST) {
					blockCount = Math.ceil(len * 2 / 49152);
				} else {
					blockCount = Math.ceil(len / 98304);
					if(this.level == zip_CompressionLevel.NORMAL) {
						extraScratch = 458752;
					} else if(this.level == zip_CompressionLevel.GOOD) {
						extraScratch = 524308;
					}
				}
				multiplier = 2;
				blockOverhead = 300;
			}
			let neededLen = len * multiplier + blockOverhead * (blockCount + 1) + extraScratch + this.currentAddr;
			if(zip__$DeflateStream_Memory.memory.length < neededLen) {
				let isMemory = zip__$DeflateStream_Memory.memory == zip_DeflateStream.memory;
				let temp = zip__$DeflateStream_Memory.memory;
				zip__$DeflateStream_Memory.memory = new haxe_io_Bytes(new ArrayBuffer(neededLen));
				zip__$DeflateStream_Memory.memory.blit(0,temp,0,temp.length);
				if(isMemory) {
					zip_DeflateStream.memory = zip__$DeflateStream_Memory.memory;
				}
			}
			if(this.zlib) {
				let offset1 = offset;
				while(offset1 + 5552 <= end) {
					let i = offset1;
					while(i < offset1 + 5552) {
						this.s2 = this.s2 + ((this.s1 << 4) + zip__$DeflateStream_Memory.memory.b[i] * 16 + zip__$DeflateStream_Memory.memory.b[i + 1] * 15 + zip__$DeflateStream_Memory.memory.b[i + 2] * 14 + zip__$DeflateStream_Memory.memory.b[i + 3] * 13 + zip__$DeflateStream_Memory.memory.b[i + 4] * 12 + zip__$DeflateStream_Memory.memory.b[i + 5] * 11 + zip__$DeflateStream_Memory.memory.b[i + 6] * 10 + zip__$DeflateStream_Memory.memory.b[i + 7] * 9 + zip__$DeflateStream_Memory.memory.b[i + 8] * 8 + zip__$DeflateStream_Memory.memory.b[i + 9] * 7 + zip__$DeflateStream_Memory.memory.b[i + 10] * 6 + zip__$DeflateStream_Memory.memory.b[i + 11] * 5 + zip__$DeflateStream_Memory.memory.b[i + 12] * 4 + zip__$DeflateStream_Memory.memory.b[i + 13] * 3 + zip__$DeflateStream_Memory.memory.b[i + 14] * 2 + zip__$DeflateStream_Memory.memory.b[i + 15]);
						this.s1 = this.s1 + (zip__$DeflateStream_Memory.memory.b[i] + zip__$DeflateStream_Memory.memory.b[i + 1] + zip__$DeflateStream_Memory.memory.b[i + 2] + zip__$DeflateStream_Memory.memory.b[i + 3] + zip__$DeflateStream_Memory.memory.b[i + 4] + zip__$DeflateStream_Memory.memory.b[i + 5] + zip__$DeflateStream_Memory.memory.b[i + 6] + zip__$DeflateStream_Memory.memory.b[i + 7] + zip__$DeflateStream_Memory.memory.b[i + 8] + zip__$DeflateStream_Memory.memory.b[i + 9] + zip__$DeflateStream_Memory.memory.b[i + 10] + zip__$DeflateStream_Memory.memory.b[i + 11] + zip__$DeflateStream_Memory.memory.b[i + 12] + zip__$DeflateStream_Memory.memory.b[i + 13] + zip__$DeflateStream_Memory.memory.b[i + 14] + zip__$DeflateStream_Memory.memory.b[i + 15]);
						i += 16;
					}
					this.s1 = UInt.toFloat(this.s1) % UInt.toFloat(65521) | 0;
					this.s2 = UInt.toFloat(this.s2) % UInt.toFloat(65521) | 0;
					offset1 += 5552;
				}
				if(offset1 != end) {
					let _g = offset1;
					while(_g < end) {
						let i = _g++;
						this.s1 = this.s1 + zip__$DeflateStream_Memory.memory.b[i];
						this.s2 = this.s2 + this.s1;
					}
					this.s1 = UInt.toFloat(this.s1) % UInt.toFloat(65521) | 0;
					this.s2 = UInt.toFloat(this.s2) % UInt.toFloat(65521) | 0;
				}
			}
			if(this.level == zip_CompressionLevel.FAST) {
				let offset1 = offset;
				let i = offset;
				let endCheck;
				while(end - offset1 > 2048) {
					endCheck = offset1 + 2048;
					if(!this.blockInProgress) {
						this.blockInProgress = true;
						if(this.level == zip_CompressionLevel.UNCOMPRESSED) {
							if(this.bitOffset == 0) {
								zip__$DeflateStream_Memory.memory.b[this.currentAddr] = 0;
							}
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= 0 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += 3;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							if(this.bitOffset > 0) {
								let bitCount = 8 - this.bitOffset;
								let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
								current |= 0 << this.bitOffset;
								zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
								this.bitOffset += bitCount;
								this.currentAddr += this.bitOffset >>> 3;
								this.bitOffset &= 7;
							}
						} else {
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= 4 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += 3;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						this.blockStartAddr = this.currentAddr;
						this.createAndWriteHuffmanTrees(offset1,Math.min(end,offset1 + 98304) | 0);
					}
					while(i < endCheck) {
						let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[i] * 4);
						let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current |= compressed >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
						this.bitOffset += compressed & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current1 |= compressed1 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
						this.bitOffset += compressed1 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed2 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current2 |= compressed2 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
						this.bitOffset += compressed2 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed3 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current3 |= compressed3 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
						this.bitOffset += compressed3 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed4 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current4 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current4 |= compressed4 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current4);
						this.bitOffset += compressed4 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed5 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current5 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current5 |= compressed5 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current5);
						this.bitOffset += compressed5 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed6 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current6 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current6 |= compressed6 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current6);
						this.bitOffset += compressed6 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed7 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current7 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current7 |= compressed7 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current7);
						this.bitOffset += compressed7 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed8 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current8 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current8 |= compressed8 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current8);
						this.bitOffset += compressed8 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed9 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current9 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current9 |= compressed9 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current9);
						this.bitOffset += compressed9 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed10 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current10 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current10 |= compressed10 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current10);
						this.bitOffset += compressed10 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed11 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current11 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current11 |= compressed11 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current11);
						this.bitOffset += compressed11 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed12 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current12 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current12 |= compressed12 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current12);
						this.bitOffset += compressed12 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed13 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current13 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current13 |= compressed13 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current13);
						this.bitOffset += compressed13 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed14 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current14 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current14 |= compressed14 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current14);
						this.bitOffset += compressed14 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed15 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current15 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current15 |= compressed15 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current15);
						this.bitOffset += compressed15 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed16 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current16 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current16 |= compressed16 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current16);
						this.bitOffset += compressed16 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed17 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current17 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current17 |= compressed17 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current17);
						this.bitOffset += compressed17 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed18 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current18 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current18 |= compressed18 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current18);
						this.bitOffset += compressed18 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed19 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current19 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current19 |= compressed19 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current19);
						this.bitOffset += compressed19 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed20 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current20 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current20 |= compressed20 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current20);
						this.bitOffset += compressed20 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed21 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current21 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current21 |= compressed21 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current21);
						this.bitOffset += compressed21 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed22 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current22 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current22 |= compressed22 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current22);
						this.bitOffset += compressed22 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed23 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current23 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current23 |= compressed23 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current23);
						this.bitOffset += compressed23 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed24 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current24 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current24 |= compressed24 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current24);
						this.bitOffset += compressed24 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed25 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current25 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current25 |= compressed25 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current25);
						this.bitOffset += compressed25 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed26 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current26 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current26 |= compressed26 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current26);
						this.bitOffset += compressed26 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed27 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current27 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current27 |= compressed27 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current27);
						this.bitOffset += compressed27 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed28 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current28 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current28 |= compressed28 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current28);
						this.bitOffset += compressed28 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed29 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current29 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current29 |= compressed29 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current29);
						this.bitOffset += compressed29 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed30 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current30 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current30 |= compressed30 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current30);
						this.bitOffset += compressed30 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						let compressed31 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[++i] * 4);
						let current31 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current31 |= compressed31 >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current31);
						this.bitOffset += compressed31 & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						++i;
					}
					offset1 += 2048;
					if((this.blockInProgress ? this.currentAddr - this.blockStartAddr : 0) > 49152) {
						if(this.level != zip_CompressionLevel.UNCOMPRESSED) {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1024);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						this.blockInProgress = false;
					}
				}
				if(i < end) {
					if(!this.blockInProgress) {
						this.blockInProgress = true;
						if(this.level == zip_CompressionLevel.UNCOMPRESSED) {
							if(this.bitOffset == 0) {
								zip__$DeflateStream_Memory.memory.b[this.currentAddr] = 0;
							}
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= 0 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += 3;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							if(this.bitOffset > 0) {
								let bitCount = 8 - this.bitOffset;
								let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
								current |= 0 << this.bitOffset;
								zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
								this.bitOffset += bitCount;
								this.currentAddr += this.bitOffset >>> 3;
								this.bitOffset &= 7;
							}
						} else {
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= 4 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += 3;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						this.blockStartAddr = this.currentAddr;
						this.createAndWriteHuffmanTrees(offset1,end);
					}
					while(i < end) {
						let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + zip__$DeflateStream_Memory.memory.b[i] * 4);
						let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current |= compressed >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
						this.bitOffset += compressed & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						++i;
					}
					if((this.blockInProgress ? this.currentAddr - this.blockStartAddr : 0) > 49152) {
						if(this.level != zip_CompressionLevel.UNCOMPRESSED) {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1024);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						this.blockInProgress = false;
					}
				}
			} else if(this.level == zip_CompressionLevel.NORMAL) {
				let offset1 = offset;
				let cappedEnd;
				let safeEnd;
				let symbol;
				let length;
				let distance;
				let distanceInfo;
				let hashOffset;
				let j;
				let k;
				let inputByteCount = end - offset;
				let blockCount;
				let blockOverhead;
				let multiplier = 1;
				let extraScratch = 0;
				if(this.level == zip_CompressionLevel.UNCOMPRESSED) {
					blockOverhead = 8;
					blockCount = Math.ceil(UInt.toFloat(inputByteCount) / UInt.toFloat(65535));
				} else {
					if(this.level == zip_CompressionLevel.FAST) {
						blockCount = Math.ceil(inputByteCount * 2 / 49152);
					} else {
						blockCount = Math.ceil(inputByteCount / 98304);
						if(this.level == zip_CompressionLevel.NORMAL) {
							extraScratch = 458752;
						} else if(this.level == zip_CompressionLevel.GOOD) {
							extraScratch = 524308;
						}
					}
					multiplier = 2;
					blockOverhead = 300;
				}
				let hashAddr = this.currentAddr + (inputByteCount * multiplier + blockOverhead * (blockCount + 1) + extraScratch) - 262144;
				let bufferAddr = hashAddr - 196608;
				let currentBufferAddr;
				let i = hashAddr + 262144 - 32;
				while(i >= hashAddr) {
					zip__$DeflateStream_Memory.memory.setInt32(i,-1);
					zip__$DeflateStream_Memory.memory.setInt32(i + 4,-1);
					zip__$DeflateStream_Memory.memory.setInt32(i + 8,-1);
					zip__$DeflateStream_Memory.memory.setInt32(i + 12,-1);
					zip__$DeflateStream_Memory.memory.setInt32(i + 16,-1);
					zip__$DeflateStream_Memory.memory.setInt32(i + 20,-1);
					zip__$DeflateStream_Memory.memory.setInt32(i + 24,-1);
					zip__$DeflateStream_Memory.memory.setInt32(i + 28,-1);
					i -= 32;
				}
				while(end - offset1 > 0) {
					cappedEnd = Math.min(end,offset1 + 98304) | 0;
					safeEnd = cappedEnd - 4;
					let _g = 0;
					while(_g < 286) {
						let symbol = _g++;
						zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + (symbol << 2),0);
					}
					let _g1 = 0;
					while(_g1 < 30) {
						let symbol = _g1++;
						zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1144 + (symbol << 2),0);
					}
					currentBufferAddr = bufferAddr;
					i = offset1;
					while(i < safeEnd) {
						let h1 = 775236557;
						let k1 = zip__$DeflateStream_Memory.memory.getInt32(i) * -862048943;
						k1 = k1 << 15 | k1 >>> 17;
						h1 = 775236557 ^ k1 * 461845907;
						h1 = h1 << 13 | h1 >>> 19;
						h1 = h1 * 5 + (-430675100);
						let h = h1 ^ 4;
						h ^= h >>> 16;
						h *= -2048144789;
						h ^= h >>> 13;
						h *= -1028477387;
						hashOffset = ((h ^ h >>> 16) & 65535) << 2;
						j = zip__$DeflateStream_Memory.memory.getInt32(hashAddr + hashOffset);
						if(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(j) == zip__$DeflateStream_Memory.memory.getInt32(i)) {
							length = 4;
							j += 4;
							k = i + 4;
							while(k < cappedEnd && zip__$DeflateStream_Memory.memory.b[j] == zip__$DeflateStream_Memory.memory.b[k] && length < 258) {
								++j;
								++k;
								++length;
							}
							zip__$DeflateStream_Memory.memory.setInt32(hashAddr + hashOffset,i);
							distance = k - j;
							if(distance <= 32768) {
								let symbol = zip__$DeflateStream_Memory.memory.getUInt16(this.scratchAddr + 2492 + (length << 2) + 2);
								let addr = this.scratchAddr + (symbol << 2);
								let v = zip__$DeflateStream_Memory.memory.getInt32(addr) + 1;
								zip__$DeflateStream_Memory.memory.setInt32(addr,v);
								distanceInfo = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance <= 256 ? distance : 256 + (distance - 1 >>> 7)) << 2));
								let addr1 = this.scratchAddr + 1144 + (distanceInfo >>> 24 << 2);
								let v1 = zip__$DeflateStream_Memory.memory.getInt32(addr1) + 1;
								zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
								zip__$DeflateStream_Memory.memory.setInt32(currentBufferAddr,length | 512 | distance << 16);
								currentBufferAddr += 4;
								i += length;
								if(i < safeEnd) {
									let h1 = 775236557;
									let k1 = zip__$DeflateStream_Memory.memory.getInt32(i - 1) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 = 775236557 ^ k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									let h = h1 ^ 4;
									h ^= h >>> 16;
									h *= -2048144789;
									h ^= h >>> 13;
									h *= -1028477387;
									zip__$DeflateStream_Memory.memory.setInt32(hashAddr + (((h ^ h >>> 16) & 65535) << 2),i - 1);
								}
							} else {
								symbol = zip__$DeflateStream_Memory.memory.b[i];
								zip__$DeflateStream_Memory.memory.setUInt16(currentBufferAddr,symbol);
								let addr = this.scratchAddr + (symbol << 2);
								let v = zip__$DeflateStream_Memory.memory.getInt32(addr) + 1;
								zip__$DeflateStream_Memory.memory.setInt32(addr,v);
								currentBufferAddr += 2;
								++i;
							}
						} else {
							symbol = zip__$DeflateStream_Memory.memory.b[i];
							zip__$DeflateStream_Memory.memory.setUInt16(currentBufferAddr,symbol);
							let addr = this.scratchAddr + (symbol << 2);
							let v = zip__$DeflateStream_Memory.memory.getInt32(addr) + 1;
							zip__$DeflateStream_Memory.memory.setInt32(addr,v);
							zip__$DeflateStream_Memory.memory.setInt32(hashAddr + hashOffset,i);
							currentBufferAddr += 2;
							++i;
						}
					}
					while(i < cappedEnd) {
						symbol = zip__$DeflateStream_Memory.memory.b[i];
						zip__$DeflateStream_Memory.memory.setUInt16(currentBufferAddr,symbol);
						let addr = this.scratchAddr + (symbol << 2);
						let v = zip__$DeflateStream_Memory.memory.getInt32(addr) + 1;
						zip__$DeflateStream_Memory.memory.setInt32(addr,v);
						currentBufferAddr += 2;
						++i;
					}
					this.blockInProgress = true;
					if(this.level == zip_CompressionLevel.UNCOMPRESSED) {
						if(this.bitOffset == 0) {
							zip__$DeflateStream_Memory.memory.b[this.currentAddr] = 0;
						}
						let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current |= 0 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
						this.bitOffset += 3;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						if(this.bitOffset > 0) {
							let bitCount = 8 - this.bitOffset;
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= 0 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += bitCount;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
					} else {
						let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current |= 4 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
						this.bitOffset += 3;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
					}
					this.blockStartAddr = this.currentAddr;
					this.createAndWriteHuffmanTrees(offset1,cappedEnd);
					i = bufferAddr;
					while(i + 64 <= currentBufferAddr) {
						let length;
						let distance;
						let lengthInfo;
						let distanceInfo;
						let symbol1 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol1 & 512) != 0) {
							length = symbol1 ^ 512;
							lengthInfo = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length - (lengthInfo & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance <= 256 ? distance : 256 + (distance - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance - (distanceInfo & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol1 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol1;
						i += 2 + ((symbol1 & 512) >>> 8);
						let length1;
						let distance1;
						let lengthInfo1;
						let distanceInfo1;
						let symbol2 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol2 & 512) != 0) {
							length1 = symbol2 ^ 512;
							lengthInfo1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length1 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo1 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length1 - (lengthInfo1 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo1 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance1 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance1 <= 256 ? distance1 : 256 + (distance1 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo1 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance1 - (distanceInfo1 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo1 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol2 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol2;
						i += 2 + ((symbol2 & 512) >>> 8);
						let length2;
						let distance2;
						let lengthInfo2;
						let distanceInfo2;
						let symbol3 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol3 & 512) != 0) {
							length2 = symbol3 ^ 512;
							lengthInfo2 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length2 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo2 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length2 - (lengthInfo2 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo2 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance2 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo2 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance2 <= 256 ? distance2 : 256 + (distance2 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo2 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance2 - (distanceInfo2 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo2 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol3 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol3;
						i += 2 + ((symbol3 & 512) >>> 8);
						let length3;
						let distance3;
						let lengthInfo3;
						let distanceInfo3;
						let symbol4 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol4 & 512) != 0) {
							length3 = symbol4 ^ 512;
							lengthInfo3 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length3 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo3 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length3 - (lengthInfo3 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo3 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance3 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo3 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance3 <= 256 ? distance3 : 256 + (distance3 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo3 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance3 - (distanceInfo3 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo3 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol4 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol4;
						i += 2 + ((symbol4 & 512) >>> 8);
						let length4;
						let distance4;
						let lengthInfo4;
						let distanceInfo4;
						let symbol5 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol5 & 512) != 0) {
							length4 = symbol5 ^ 512;
							lengthInfo4 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length4 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo4 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length4 - (lengthInfo4 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo4 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance4 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo4 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance4 <= 256 ? distance4 : 256 + (distance4 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo4 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance4 - (distanceInfo4 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo4 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol5 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol5;
						i += 2 + ((symbol5 & 512) >>> 8);
						let length5;
						let distance5;
						let lengthInfo5;
						let distanceInfo5;
						let symbol6 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol6 & 512) != 0) {
							length5 = symbol6 ^ 512;
							lengthInfo5 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length5 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo5 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length5 - (lengthInfo5 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo5 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance5 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo5 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance5 <= 256 ? distance5 : 256 + (distance5 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo5 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance5 - (distanceInfo5 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo5 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol6 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol6;
						i += 2 + ((symbol6 & 512) >>> 8);
						let length6;
						let distance6;
						let lengthInfo6;
						let distanceInfo6;
						let symbol7 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol7 & 512) != 0) {
							length6 = symbol7 ^ 512;
							lengthInfo6 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length6 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo6 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length6 - (lengthInfo6 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo6 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance6 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo6 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance6 <= 256 ? distance6 : 256 + (distance6 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo6 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance6 - (distanceInfo6 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo6 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol7 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol7;
						i += 2 + ((symbol7 & 512) >>> 8);
						let length7;
						let distance7;
						let lengthInfo7;
						let distanceInfo7;
						let symbol8 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol8 & 512) != 0) {
							length7 = symbol8 ^ 512;
							lengthInfo7 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length7 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo7 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length7 - (lengthInfo7 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo7 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance7 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo7 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance7 <= 256 ? distance7 : 256 + (distance7 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo7 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance7 - (distanceInfo7 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo7 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol8 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol8;
						i += 2 + ((symbol8 & 512) >>> 8);
						let length8;
						let distance8;
						let lengthInfo8;
						let distanceInfo8;
						let symbol9 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol9 & 512) != 0) {
							length8 = symbol9 ^ 512;
							lengthInfo8 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length8 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo8 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length8 - (lengthInfo8 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo8 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance8 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo8 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance8 <= 256 ? distance8 : 256 + (distance8 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo8 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance8 - (distanceInfo8 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo8 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol9 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol9;
						i += 2 + ((symbol9 & 512) >>> 8);
						let length9;
						let distance9;
						let lengthInfo9;
						let distanceInfo9;
						let symbol10 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol10 & 512) != 0) {
							length9 = symbol10 ^ 512;
							lengthInfo9 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length9 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo9 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length9 - (lengthInfo9 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo9 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance9 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo9 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance9 <= 256 ? distance9 : 256 + (distance9 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo9 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance9 - (distanceInfo9 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo9 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol10 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol10;
						i += 2 + ((symbol10 & 512) >>> 8);
						let length10;
						let distance10;
						let lengthInfo10;
						let distanceInfo10;
						let symbol11 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol11 & 512) != 0) {
							length10 = symbol11 ^ 512;
							lengthInfo10 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length10 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo10 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length10 - (lengthInfo10 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo10 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance10 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo10 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance10 <= 256 ? distance10 : 256 + (distance10 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo10 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance10 - (distanceInfo10 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo10 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol11 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol11;
						i += 2 + ((symbol11 & 512) >>> 8);
						let length11;
						let distance11;
						let lengthInfo11;
						let distanceInfo11;
						let symbol12 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol12 & 512) != 0) {
							length11 = symbol12 ^ 512;
							lengthInfo11 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length11 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo11 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length11 - (lengthInfo11 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo11 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance11 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo11 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance11 <= 256 ? distance11 : 256 + (distance11 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo11 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance11 - (distanceInfo11 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo11 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol12 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol12;
						i += 2 + ((symbol12 & 512) >>> 8);
						let length12;
						let distance12;
						let lengthInfo12;
						let distanceInfo12;
						let symbol13 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol13 & 512) != 0) {
							length12 = symbol13 ^ 512;
							lengthInfo12 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length12 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo12 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length12 - (lengthInfo12 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo12 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance12 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo12 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance12 <= 256 ? distance12 : 256 + (distance12 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo12 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance12 - (distanceInfo12 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo12 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol13 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol13;
						i += 2 + ((symbol13 & 512) >>> 8);
						let length13;
						let distance13;
						let lengthInfo13;
						let distanceInfo13;
						let symbol14 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol14 & 512) != 0) {
							length13 = symbol14 ^ 512;
							lengthInfo13 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length13 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo13 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length13 - (lengthInfo13 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo13 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance13 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo13 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance13 <= 256 ? distance13 : 256 + (distance13 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo13 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance13 - (distanceInfo13 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo13 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol14 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol14;
						i += 2 + ((symbol14 & 512) >>> 8);
						let length14;
						let distance14;
						let lengthInfo14;
						let distanceInfo14;
						let symbol15 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol15 & 512) != 0) {
							length14 = symbol15 ^ 512;
							lengthInfo14 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length14 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo14 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length14 - (lengthInfo14 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo14 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance14 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo14 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance14 <= 256 ? distance14 : 256 + (distance14 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo14 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance14 - (distanceInfo14 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo14 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol15 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol15;
						i += 2 + ((symbol15 & 512) >>> 8);
						let length15;
						let distance15;
						let lengthInfo15;
						let distanceInfo15;
						let symbol16 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol16 & 512) != 0) {
							length15 = symbol16 ^ 512;
							lengthInfo15 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length15 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo15 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length15 - (lengthInfo15 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo15 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance15 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo15 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance15 <= 256 ? distance15 : 256 + (distance15 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo15 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance15 - (distanceInfo15 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo15 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol16 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol16;
						i += 2 + ((symbol16 & 512) >>> 8);
					}
					while(i < currentBufferAddr) {
						let length;
						let distance;
						let lengthInfo;
						let distanceInfo;
						let symbol1 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol1 & 512) != 0) {
							length = symbol1 ^ 512;
							lengthInfo = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length - (lengthInfo & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance <= 256 ? distance : 256 + (distance - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance - (distanceInfo & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol1 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol1;
						i += 2 + ((symbol1 & 512) >>> 8);
					}
					if(this.level != zip_CompressionLevel.UNCOMPRESSED) {
						let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1024);
						let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current |= compressed >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
						this.bitOffset += compressed & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
					}
					this.blockInProgress = false;
					offset1 = cappedEnd;
				}
			} else if(this.level == zip_CompressionLevel.GOOD) {
				let offset1 = offset;
				let cappedEnd;
				let maxMatchEnd;
				let lookaheadEnd;
				let symbol;
				let length;
				let distanceInfo;
				let i;
				let inputByteCount = end - offset;
				let blockCount;
				let blockOverhead;
				let multiplier = 1;
				let extraScratch = 0;
				if(this.level == zip_CompressionLevel.UNCOMPRESSED) {
					blockOverhead = 8;
					blockCount = Math.ceil(UInt.toFloat(inputByteCount) / UInt.toFloat(65535));
				} else {
					if(this.level == zip_CompressionLevel.FAST) {
						blockCount = Math.ceil(inputByteCount * 2 / 49152);
					} else {
						blockCount = Math.ceil(inputByteCount / 98304);
						if(this.level == zip_CompressionLevel.NORMAL) {
							extraScratch = 458752;
						} else if(this.level == zip_CompressionLevel.GOOD) {
							extraScratch = 524308;
						}
					}
					multiplier = 2;
					blockOverhead = 300;
				}
				let hashAddr = this.currentAddr + (inputByteCount * multiplier + blockOverhead * (blockCount + 1) + extraScratch) - 327700;
				let bufferAddr = hashAddr - 196608;
				let currentBufferAddr;
				let hash = new zip__$DeflateStream_LZHash(hashAddr,258,32768);
				while(end - offset1 > 0) {
					cappedEnd = Math.min(end,offset1 + 98304) | 0;
					lookaheadEnd = cappedEnd - 9;
					maxMatchEnd = lookaheadEnd - 516 - 1;
					let _g = 0;
					while(_g < 286) {
						let symbol = _g++;
						zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + (symbol << 2),0);
					}
					let _g1 = 0;
					while(_g1 < 30) {
						let symbol = _g1++;
						zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1144 + (symbol << 2),0);
					}
					currentBufferAddr = bufferAddr;
					i = offset1;
					if(i < maxMatchEnd) {
						let h1 = 775236557;
						let k1 = zip__$DeflateStream_Memory.memory.getInt32(offset1) * -862048943;
						k1 = k1 << 15 | k1 >>> 17;
						h1 = 775236557 ^ k1 * 461845907;
						h1 = h1 << 13 | h1 >>> 19;
						h1 = h1 * 5 + (-430675100);
						let h = h1 ^ 4;
						h ^= h >>> 16;
						h *= -2048144789;
						h ^= h >>> 13;
						h *= -1028477387;
						let hashOffset = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
						let longestLength = 3;
						let longestEndPosition = -1;
						let length;
						let k;
						let j = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
						if(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(offset1) == zip__$DeflateStream_Memory.memory.getInt32(j) && offset1 - j <= hash.windowSize) {
							k = offset1 + 4;
							length = 4;
							j += 4;
							while(zip__$DeflateStream_Memory.memory.getInt32(j) == zip__$DeflateStream_Memory.memory.getInt32(k) && length + 4 <= hash.maxMatchLength) {
								length += 4;
								j += 4;
								k += 4;
							}
							while(zip__$DeflateStream_Memory.memory.b[j] == zip__$DeflateStream_Memory.memory.b[k] && length < hash.maxMatchLength) {
								++length;
								++j;
								++k;
							}
							longestLength = length;
							longestEndPosition = j;
						}
						let _g = 5;
						while(_g < 9) {
							let hashDepth = _g++;
							let addr = hash.hashScratchAddr;
							let v = zip__$DeflateStream_Memory.memory.getInt32(offset1);
							zip__$DeflateStream_Memory.memory.setInt32(addr,v);
							let addr1 = hash.hashScratchAddr + 4;
							let v1 = zip__$DeflateStream_Memory.memory.getInt32(offset1 + 4);
							zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
							zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
							let h1 = 775236557;
							let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
							k1 = k1 << 15 | k1 >>> 17;
							h1 = 775236557 ^ k1 * 461845907;
							h1 = h1 << 13 | h1 >>> 19;
							h1 = h1 * 5 + (-430675100);
							k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
							k1 = k1 << 15 | k1 >>> 17;
							h1 ^= k1 * 461845907;
							h1 = h1 << 13 | h1 >>> 19;
							h1 = h1 * 5 + (-430675100);
							let h = h1 ^ hashDepth;
							h ^= h >>> 16;
							h *= -2048144789;
							h ^= h >>> 13;
							h *= -1028477387;
							j = zip__$DeflateStream_Memory.memory.getInt32(hash.addr + ((h ^ h >>> 16) & 65535) * 5 + 1);
							if(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(j + longestLength - 3) == zip__$DeflateStream_Memory.memory.getInt32(offset1 + longestLength - 3) && zip__$DeflateStream_Memory.memory.getInt32(offset1) == zip__$DeflateStream_Memory.memory.getInt32(j) && offset1 - j <= hash.windowSize) {
								k = offset1 + 4;
								length = 4;
								j += 4;
								while(zip__$DeflateStream_Memory.memory.getInt32(j) == zip__$DeflateStream_Memory.memory.getInt32(k) && length + 4 <= hash.maxMatchLength) {
									length += 4;
									j += 4;
									k += 4;
								}
								while(zip__$DeflateStream_Memory.memory.b[j] == zip__$DeflateStream_Memory.memory.b[k] && length < hash.maxMatchLength) {
									++length;
									++j;
									++k;
								}
								if(length > longestLength) {
									longestLength = length;
									longestEndPosition = j;
								}
							}
						}
						zip__$DeflateStream_Memory.memory.setInt32(hash.resultAddr,offset1 - (longestEndPosition - longestLength) << 16 | longestLength);
						let hashOffset1 = hashOffset;
						let hashDepth = 4;
						let index = offset1;
						let nextIndex;
						let nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset];
						if(nextDepth < 8 && nextDepth >= 0) {
							nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
							zip__$DeflateStream_Memory.memory.b[hashOffset] = 4;
							zip__$DeflateStream_Memory.memory.setInt32(hashOffset + 1,index);
							hashDepth = nextDepth + 1;
							index = nextIndex;
							let addr = hash.hashScratchAddr;
							let v = zip__$DeflateStream_Memory.memory.getInt32(index);
							zip__$DeflateStream_Memory.memory.setInt32(addr,v);
							let addr1 = hash.hashScratchAddr + 4;
							let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
							zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
							zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
							let h1 = 775236557;
							let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
							k1 = k1 << 15 | k1 >>> 17;
							h1 = 775236557 ^ k1 * 461845907;
							h1 = h1 << 13 | h1 >>> 19;
							h1 = h1 * 5 + (-430675100);
							k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
							k1 = k1 << 15 | k1 >>> 17;
							h1 ^= k1 * 461845907;
							h1 = h1 << 13 | h1 >>> 19;
							h1 = h1 * 5 + (-430675100);
							let h = h1 ^ hashDepth;
							h ^= h >>> 16;
							h *= -2048144789;
							h ^= h >>> 13;
							h *= -1028477387;
							hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
							nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
							if(nextDepth < 8 && nextDepth >= 0) {
								nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
								zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
								zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
								hashDepth = nextDepth + 1;
								index = nextIndex;
								let addr = hash.hashScratchAddr;
								let v = zip__$DeflateStream_Memory.memory.getInt32(index);
								zip__$DeflateStream_Memory.memory.setInt32(addr,v);
								let addr1 = hash.hashScratchAddr + 4;
								let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
								zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
								zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
								let h1 = 775236557;
								let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 = 775236557 ^ k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 ^= k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								let h = h1 ^ hashDepth;
								h ^= h >>> 16;
								h *= -2048144789;
								h ^= h >>> 13;
								h *= -1028477387;
								hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
								nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
								if(nextDepth < 8 && nextDepth >= 0) {
									nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
									zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
									zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
									hashDepth = nextDepth + 1;
									index = nextIndex;
									let addr = hash.hashScratchAddr;
									let v = zip__$DeflateStream_Memory.memory.getInt32(index);
									zip__$DeflateStream_Memory.memory.setInt32(addr,v);
									let addr1 = hash.hashScratchAddr + 4;
									let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
									zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
									zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
									let h1 = 775236557;
									let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 = 775236557 ^ k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 ^= k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									let h = h1 ^ hashDepth;
									h ^= h >>> 16;
									h *= -2048144789;
									h ^= h >>> 13;
									h *= -1028477387;
									hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
									nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
									if(nextDepth < 8 && nextDepth >= 0) {
										nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
										zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
										zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
										hashDepth = nextDepth + 1;
										index = nextIndex;
										let addr = hash.hashScratchAddr;
										let v = zip__$DeflateStream_Memory.memory.getInt32(index);
										zip__$DeflateStream_Memory.memory.setInt32(addr,v);
										let addr1 = hash.hashScratchAddr + 4;
										let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
										zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
										zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
										let h1 = 775236557;
										let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 = 775236557 ^ k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 ^= k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										let h = h1 ^ hashDepth;
										h ^= h >>> 16;
										h *= -2048144789;
										h ^= h >>> 13;
										h *= -1028477387;
										hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
									}
								}
							}
						}
						zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
						zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
						hash.resultAddr = hash.baseResultAddr + (hash.resultAddr - hash.baseResultAddr + 4 & 7);
					} else if(i < lookaheadEnd) {
						let h1 = 775236557;
						let k1 = zip__$DeflateStream_Memory.memory.getInt32(offset1) * -862048943;
						k1 = k1 << 15 | k1 >>> 17;
						h1 = 775236557 ^ k1 * 461845907;
						h1 = h1 << 13 | h1 >>> 19;
						h1 = h1 * 5 + (-430675100);
						let h = h1 ^ 4;
						h ^= h >>> 16;
						h *= -2048144789;
						h ^= h >>> 13;
						h *= -1028477387;
						let hashOffset = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
						let longestLength = 3;
						let longestEndPosition = -1;
						let length;
						let k;
						let j = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
						if(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(offset1) == zip__$DeflateStream_Memory.memory.getInt32(j) && offset1 - j <= hash.windowSize) {
							k = offset1 + 4;
							length = 4;
							j += 4;
							while(k + 4 <= cappedEnd && zip__$DeflateStream_Memory.memory.getInt32(j) == zip__$DeflateStream_Memory.memory.getInt32(k) && length + 4 <= hash.maxMatchLength) {
								length += 4;
								j += 4;
								k += 4;
							}
							while(k < cappedEnd && zip__$DeflateStream_Memory.memory.b[j] == zip__$DeflateStream_Memory.memory.b[k] && length < hash.maxMatchLength) {
								++length;
								++j;
								++k;
							}
							longestLength = length;
							longestEndPosition = j;
						}
						let _g = 5;
						while(_g < 9) {
							let hashDepth = _g++;
							let addr = hash.hashScratchAddr;
							let v = zip__$DeflateStream_Memory.memory.getInt32(offset1);
							zip__$DeflateStream_Memory.memory.setInt32(addr,v);
							let addr1 = hash.hashScratchAddr + 4;
							let v1 = zip__$DeflateStream_Memory.memory.getInt32(offset1 + 4);
							zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
							zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
							let h1 = 775236557;
							let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
							k1 = k1 << 15 | k1 >>> 17;
							h1 = 775236557 ^ k1 * 461845907;
							h1 = h1 << 13 | h1 >>> 19;
							h1 = h1 * 5 + (-430675100);
							k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
							k1 = k1 << 15 | k1 >>> 17;
							h1 ^= k1 * 461845907;
							h1 = h1 << 13 | h1 >>> 19;
							h1 = h1 * 5 + (-430675100);
							let h = h1 ^ hashDepth;
							h ^= h >>> 16;
							h *= -2048144789;
							h ^= h >>> 13;
							h *= -1028477387;
							j = zip__$DeflateStream_Memory.memory.getInt32(hash.addr + ((h ^ h >>> 16) & 65535) * 5 + 1);
							if(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(offset1) == zip__$DeflateStream_Memory.memory.getInt32(j) && offset1 - j <= hash.windowSize) {
								k = offset1 + 4;
								length = 4;
								j += 4;
								while(k + 4 <= cappedEnd && zip__$DeflateStream_Memory.memory.getInt32(j) == zip__$DeflateStream_Memory.memory.getInt32(k) && length + 4 <= hash.maxMatchLength) {
									length += 4;
									j += 4;
									k += 4;
								}
								while(k < cappedEnd && zip__$DeflateStream_Memory.memory.b[j] == zip__$DeflateStream_Memory.memory.b[k] && length < hash.maxMatchLength) {
									++length;
									++j;
									++k;
								}
								if(length > longestLength) {
									longestLength = length;
									longestEndPosition = j;
								}
							}
						}
						zip__$DeflateStream_Memory.memory.setInt32(hash.resultAddr,offset1 - (longestEndPosition - longestLength) << 16 | longestLength);
						let hashOffset1 = hashOffset;
						let hashDepth = 4;
						let index = offset1;
						let nextIndex;
						let nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset];
						if(nextDepth < 8 && nextDepth >= 0) {
							nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
							zip__$DeflateStream_Memory.memory.b[hashOffset] = 4;
							zip__$DeflateStream_Memory.memory.setInt32(hashOffset + 1,index);
							hashDepth = nextDepth + 1;
							index = nextIndex;
							let addr = hash.hashScratchAddr;
							let v = zip__$DeflateStream_Memory.memory.getInt32(index);
							zip__$DeflateStream_Memory.memory.setInt32(addr,v);
							let addr1 = hash.hashScratchAddr + 4;
							let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
							zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
							zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
							let h1 = 775236557;
							let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
							k1 = k1 << 15 | k1 >>> 17;
							h1 = 775236557 ^ k1 * 461845907;
							h1 = h1 << 13 | h1 >>> 19;
							h1 = h1 * 5 + (-430675100);
							k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
							k1 = k1 << 15 | k1 >>> 17;
							h1 ^= k1 * 461845907;
							h1 = h1 << 13 | h1 >>> 19;
							h1 = h1 * 5 + (-430675100);
							let h = h1 ^ hashDepth;
							h ^= h >>> 16;
							h *= -2048144789;
							h ^= h >>> 13;
							h *= -1028477387;
							hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
							nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
							if(nextDepth < 8 && nextDepth >= 0) {
								nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
								zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
								zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
								hashDepth = nextDepth + 1;
								index = nextIndex;
								let addr = hash.hashScratchAddr;
								let v = zip__$DeflateStream_Memory.memory.getInt32(index);
								zip__$DeflateStream_Memory.memory.setInt32(addr,v);
								let addr1 = hash.hashScratchAddr + 4;
								let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
								zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
								zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
								let h1 = 775236557;
								let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 = 775236557 ^ k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 ^= k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								let h = h1 ^ hashDepth;
								h ^= h >>> 16;
								h *= -2048144789;
								h ^= h >>> 13;
								h *= -1028477387;
								hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
								nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
								if(nextDepth < 8 && nextDepth >= 0) {
									nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
									zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
									zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
									hashDepth = nextDepth + 1;
									index = nextIndex;
									let addr = hash.hashScratchAddr;
									let v = zip__$DeflateStream_Memory.memory.getInt32(index);
									zip__$DeflateStream_Memory.memory.setInt32(addr,v);
									let addr1 = hash.hashScratchAddr + 4;
									let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
									zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
									zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
									let h1 = 775236557;
									let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 = 775236557 ^ k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 ^= k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									let h = h1 ^ hashDepth;
									h ^= h >>> 16;
									h *= -2048144789;
									h ^= h >>> 13;
									h *= -1028477387;
									hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
									nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
									if(nextDepth < 8 && nextDepth >= 0) {
										nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
										zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
										zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
										hashDepth = nextDepth + 1;
										index = nextIndex;
										let addr = hash.hashScratchAddr;
										let v = zip__$DeflateStream_Memory.memory.getInt32(index);
										zip__$DeflateStream_Memory.memory.setInt32(addr,v);
										let addr1 = hash.hashScratchAddr + 4;
										let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
										zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
										zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
										let h1 = 775236557;
										let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 = 775236557 ^ k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 ^= k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										let h = h1 ^ hashDepth;
										h ^= h >>> 16;
										h *= -2048144789;
										h ^= h >>> 13;
										h *= -1028477387;
										hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
									}
								}
							}
						}
						zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
						zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
						hash.resultAddr = hash.baseResultAddr + (hash.resultAddr - hash.baseResultAddr + 4 & 7);
					}
					while(i < maxMatchEnd) {
						let length1;
						let h1 = 775236557;
						let k1 = zip__$DeflateStream_Memory.memory.getInt32(i + 1) * -862048943;
						k1 = k1 << 15 | k1 >>> 17;
						h1 = 775236557 ^ k1 * 461845907;
						h1 = h1 << 13 | h1 >>> 19;
						h1 = h1 * 5 + (-430675100);
						let h = h1 ^ 4;
						h ^= h >>> 16;
						h *= -2048144789;
						h ^= h >>> 13;
						h *= -1028477387;
						let hashOffset = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
						if(zip__$DeflateStream_Memory.memory.getUInt16(hash.baseResultAddr + (hash.resultAddr - hash.baseResultAddr + 4 & 7)) < hash.avgMatchLength + 4) {
							let i1 = i + 1;
							let longestLength = 3;
							let longestEndPosition = -1;
							let length;
							let k;
							let j = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
							if(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(i1) == zip__$DeflateStream_Memory.memory.getInt32(j) && i1 - j <= hash.windowSize) {
								k = i1 + 4;
								length = 4;
								j += 4;
								while(zip__$DeflateStream_Memory.memory.getInt32(j) == zip__$DeflateStream_Memory.memory.getInt32(k) && length + 4 <= hash.maxMatchLength) {
									length += 4;
									j += 4;
									k += 4;
								}
								while(zip__$DeflateStream_Memory.memory.b[j] == zip__$DeflateStream_Memory.memory.b[k] && length < hash.maxMatchLength) {
									++length;
									++j;
									++k;
								}
								longestLength = length;
								longestEndPosition = j;
							}
							let _g = 5;
							while(_g < 9) {
								let hashDepth = _g++;
								let addr = hash.hashScratchAddr;
								let v = zip__$DeflateStream_Memory.memory.getInt32(i1);
								zip__$DeflateStream_Memory.memory.setInt32(addr,v);
								let addr1 = hash.hashScratchAddr + 4;
								let v1 = zip__$DeflateStream_Memory.memory.getInt32(i1 + 4);
								zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
								zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
								let h1 = 775236557;
								let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 = 775236557 ^ k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 ^= k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								let h = h1 ^ hashDepth;
								h ^= h >>> 16;
								h *= -2048144789;
								h ^= h >>> 13;
								h *= -1028477387;
								j = zip__$DeflateStream_Memory.memory.getInt32(hash.addr + ((h ^ h >>> 16) & 65535) * 5 + 1);
								if(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(j + longestLength - 3) == zip__$DeflateStream_Memory.memory.getInt32(i1 + longestLength - 3) && zip__$DeflateStream_Memory.memory.getInt32(i1) == zip__$DeflateStream_Memory.memory.getInt32(j) && i1 - j <= hash.windowSize) {
									k = i1 + 4;
									length = 4;
									j += 4;
									while(zip__$DeflateStream_Memory.memory.getInt32(j) == zip__$DeflateStream_Memory.memory.getInt32(k) && length + 4 <= hash.maxMatchLength) {
										length += 4;
										j += 4;
										k += 4;
									}
									while(zip__$DeflateStream_Memory.memory.b[j] == zip__$DeflateStream_Memory.memory.b[k] && length < hash.maxMatchLength) {
										++length;
										++j;
										++k;
									}
									if(length > longestLength) {
										longestLength = length;
										longestEndPosition = j;
									}
								}
							}
							zip__$DeflateStream_Memory.memory.setInt32(hash.resultAddr,i1 - (longestEndPosition - longestLength) << 16 | longestLength);
						} else {
							zip__$DeflateStream_Memory.memory.setInt32(hash.resultAddr,0);
						}
						let hashOffset1 = hashOffset;
						let hashDepth = 4;
						let index = i + 1;
						let nextIndex;
						let nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset];
						if(nextDepth < 8 && nextDepth >= 0) {
							nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
							zip__$DeflateStream_Memory.memory.b[hashOffset] = 4;
							zip__$DeflateStream_Memory.memory.setInt32(hashOffset + 1,index);
							hashDepth = nextDepth + 1;
							index = nextIndex;
							let addr = hash.hashScratchAddr;
							let v = zip__$DeflateStream_Memory.memory.getInt32(index);
							zip__$DeflateStream_Memory.memory.setInt32(addr,v);
							let addr1 = hash.hashScratchAddr + 4;
							let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
							zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
							zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
							let h1 = 775236557;
							let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
							k1 = k1 << 15 | k1 >>> 17;
							h1 = 775236557 ^ k1 * 461845907;
							h1 = h1 << 13 | h1 >>> 19;
							h1 = h1 * 5 + (-430675100);
							k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
							k1 = k1 << 15 | k1 >>> 17;
							h1 ^= k1 * 461845907;
							h1 = h1 << 13 | h1 >>> 19;
							h1 = h1 * 5 + (-430675100);
							let h = h1 ^ hashDepth;
							h ^= h >>> 16;
							h *= -2048144789;
							h ^= h >>> 13;
							h *= -1028477387;
							hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
							nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
							if(nextDepth < 8 && nextDepth >= 0) {
								nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
								zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
								zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
								hashDepth = nextDepth + 1;
								index = nextIndex;
								let addr = hash.hashScratchAddr;
								let v = zip__$DeflateStream_Memory.memory.getInt32(index);
								zip__$DeflateStream_Memory.memory.setInt32(addr,v);
								let addr1 = hash.hashScratchAddr + 4;
								let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
								zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
								zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
								let h1 = 775236557;
								let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 = 775236557 ^ k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 ^= k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								let h = h1 ^ hashDepth;
								h ^= h >>> 16;
								h *= -2048144789;
								h ^= h >>> 13;
								h *= -1028477387;
								hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
								nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
								if(nextDepth < 8 && nextDepth >= 0) {
									nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
									zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
									zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
									hashDepth = nextDepth + 1;
									index = nextIndex;
									let addr = hash.hashScratchAddr;
									let v = zip__$DeflateStream_Memory.memory.getInt32(index);
									zip__$DeflateStream_Memory.memory.setInt32(addr,v);
									let addr1 = hash.hashScratchAddr + 4;
									let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
									zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
									zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
									let h1 = 775236557;
									let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 = 775236557 ^ k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 ^= k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									let h = h1 ^ hashDepth;
									h ^= h >>> 16;
									h *= -2048144789;
									h ^= h >>> 13;
									h *= -1028477387;
									hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
									nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
									if(nextDepth < 8 && nextDepth >= 0) {
										nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
										zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
										zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
										hashDepth = nextDepth + 1;
										index = nextIndex;
										let addr = hash.hashScratchAddr;
										let v = zip__$DeflateStream_Memory.memory.getInt32(index);
										zip__$DeflateStream_Memory.memory.setInt32(addr,v);
										let addr1 = hash.hashScratchAddr + 4;
										let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
										zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
										zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
										let h1 = 775236557;
										let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 = 775236557 ^ k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 ^= k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										let h = h1 ^ hashDepth;
										h ^= h >>> 16;
										h *= -2048144789;
										h ^= h >>> 13;
										h *= -1028477387;
										hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
									}
								}
							}
						}
						zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
						zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
						hash.resultAddr = hash.baseResultAddr + (hash.resultAddr - hash.baseResultAddr + 4 & 7);
						if(zip__$DeflateStream_Memory.memory.getUInt16(hash.resultAddr) >= 4) {
							length1 = zip__$DeflateStream_Memory.memory.getUInt16(hash.resultAddr);
							if(zip__$DeflateStream_Memory.memory.getUInt16(hash.baseResultAddr + (hash.resultAddr - hash.baseResultAddr + 4 & 7)) > length1) {
								zip__$DeflateStream_Memory.memory.setInt32(hash.resultAddr,0);
							} else {
								hash.avgMatchLength = (hash.avgMatchLength << 1) + (hash.avgMatchLength << 2) + (length1 << 1) >>> 3;
								if(length1 < hash.avgMatchLength + 4) {
									let _g = i + 1 + 1;
									let _g1 = i + length1;
									while(_g < _g1) {
										let k = _g++;
										let hashDepth = 4;
										let index = k;
										let nextIndex;
										let h1 = 775236557;
										let k1 = zip__$DeflateStream_Memory.memory.getInt32(k) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 = 775236557 ^ k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										let h = h1 ^ 4;
										h ^= h >>> 16;
										h *= -2048144789;
										h ^= h >>> 13;
										h *= -1028477387;
										let hashOffset = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
										let nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset];
										if(nextDepth < 8 && nextDepth >= 0) {
											nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
											zip__$DeflateStream_Memory.memory.b[hashOffset] = 4;
											zip__$DeflateStream_Memory.memory.setInt32(hashOffset + 1,k);
											hashDepth = nextDepth + 1;
											index = nextIndex;
											let addr = hash.hashScratchAddr;
											let v = zip__$DeflateStream_Memory.memory.getInt32(index);
											zip__$DeflateStream_Memory.memory.setInt32(addr,v);
											let addr1 = hash.hashScratchAddr + 4;
											let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
											zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
											zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
											let h1 = 775236557;
											let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
											k1 = k1 << 15 | k1 >>> 17;
											h1 = 775236557 ^ k1 * 461845907;
											h1 = h1 << 13 | h1 >>> 19;
											h1 = h1 * 5 + (-430675100);
											k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
											k1 = k1 << 15 | k1 >>> 17;
											h1 ^= k1 * 461845907;
											h1 = h1 << 13 | h1 >>> 19;
											h1 = h1 * 5 + (-430675100);
											let h = h1 ^ hashDepth;
											h ^= h >>> 16;
											h *= -2048144789;
											h ^= h >>> 13;
											h *= -1028477387;
											hashOffset = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
											nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset];
											if(nextDepth < 8 && nextDepth >= 0) {
												nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
												zip__$DeflateStream_Memory.memory.b[hashOffset] = hashDepth;
												zip__$DeflateStream_Memory.memory.setInt32(hashOffset + 1,index);
												hashDepth = nextDepth + 1;
												index = nextIndex;
												let addr = hash.hashScratchAddr;
												let v = zip__$DeflateStream_Memory.memory.getInt32(index);
												zip__$DeflateStream_Memory.memory.setInt32(addr,v);
												let addr1 = hash.hashScratchAddr + 4;
												let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
												zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
												zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
												let h1 = 775236557;
												let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
												k1 = k1 << 15 | k1 >>> 17;
												h1 = 775236557 ^ k1 * 461845907;
												h1 = h1 << 13 | h1 >>> 19;
												h1 = h1 * 5 + (-430675100);
												k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
												k1 = k1 << 15 | k1 >>> 17;
												h1 ^= k1 * 461845907;
												h1 = h1 << 13 | h1 >>> 19;
												h1 = h1 * 5 + (-430675100);
												let h = h1 ^ hashDepth;
												h ^= h >>> 16;
												h *= -2048144789;
												h ^= h >>> 13;
												h *= -1028477387;
												hashOffset = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
											}
										}
										zip__$DeflateStream_Memory.memory.b[hashOffset] = hashDepth;
										zip__$DeflateStream_Memory.memory.setInt32(hashOffset + 1,index);
									}
								}
								hash.resultAddr = hash.baseResultAddr + (hash.resultAddr - hash.baseResultAddr + 4 & 7);
								let i1 = i + length1;
								let h1 = 775236557;
								let k1 = zip__$DeflateStream_Memory.memory.getInt32(i1) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 = 775236557 ^ k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								let h = h1 ^ 4;
								h ^= h >>> 16;
								h *= -2048144789;
								h ^= h >>> 13;
								h *= -1028477387;
								let hashOffset = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
								let longestLength = 3;
								let longestEndPosition = -1;
								let length;
								let k;
								let j = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
								if(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(i1) == zip__$DeflateStream_Memory.memory.getInt32(j) && i1 - j <= hash.windowSize) {
									k = i1 + 4;
									length = 4;
									j += 4;
									while(zip__$DeflateStream_Memory.memory.getInt32(j) == zip__$DeflateStream_Memory.memory.getInt32(k) && length + 4 <= hash.maxMatchLength) {
										length += 4;
										j += 4;
										k += 4;
									}
									while(zip__$DeflateStream_Memory.memory.b[j] == zip__$DeflateStream_Memory.memory.b[k] && length < hash.maxMatchLength) {
										++length;
										++j;
										++k;
									}
									longestLength = length;
									longestEndPosition = j;
								}
								let _g = 5;
								while(_g < 9) {
									let hashDepth = _g++;
									let addr = hash.hashScratchAddr;
									let v = zip__$DeflateStream_Memory.memory.getInt32(i1);
									zip__$DeflateStream_Memory.memory.setInt32(addr,v);
									let addr1 = hash.hashScratchAddr + 4;
									let v1 = zip__$DeflateStream_Memory.memory.getInt32(i1 + 4);
									zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
									zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
									let h1 = 775236557;
									let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 = 775236557 ^ k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 ^= k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									let h = h1 ^ hashDepth;
									h ^= h >>> 16;
									h *= -2048144789;
									h ^= h >>> 13;
									h *= -1028477387;
									j = zip__$DeflateStream_Memory.memory.getInt32(hash.addr + ((h ^ h >>> 16) & 65535) * 5 + 1);
									if(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(j + longestLength - 3) == zip__$DeflateStream_Memory.memory.getInt32(i1 + longestLength - 3) && zip__$DeflateStream_Memory.memory.getInt32(i1) == zip__$DeflateStream_Memory.memory.getInt32(j) && i1 - j <= hash.windowSize) {
										k = i1 + 4;
										length = 4;
										j += 4;
										while(zip__$DeflateStream_Memory.memory.getInt32(j) == zip__$DeflateStream_Memory.memory.getInt32(k) && length + 4 <= hash.maxMatchLength) {
											length += 4;
											j += 4;
											k += 4;
										}
										while(zip__$DeflateStream_Memory.memory.b[j] == zip__$DeflateStream_Memory.memory.b[k] && length < hash.maxMatchLength) {
											++length;
											++j;
											++k;
										}
										if(length > longestLength) {
											longestLength = length;
											longestEndPosition = j;
										}
									}
								}
								zip__$DeflateStream_Memory.memory.setInt32(hash.resultAddr,i1 - (longestEndPosition - longestLength) << 16 | longestLength);
								let hashOffset1 = hashOffset;
								let hashDepth = 4;
								let index = i1;
								let nextIndex;
								let nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset];
								if(nextDepth < 8 && nextDepth >= 0) {
									nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
									zip__$DeflateStream_Memory.memory.b[hashOffset] = 4;
									zip__$DeflateStream_Memory.memory.setInt32(hashOffset + 1,i1);
									hashDepth = nextDepth + 1;
									index = nextIndex;
									let addr = hash.hashScratchAddr;
									let v = zip__$DeflateStream_Memory.memory.getInt32(index);
									zip__$DeflateStream_Memory.memory.setInt32(addr,v);
									let addr1 = hash.hashScratchAddr + 4;
									let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
									zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
									zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
									let h1 = 775236557;
									let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 = 775236557 ^ k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 ^= k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									let h = h1 ^ hashDepth;
									h ^= h >>> 16;
									h *= -2048144789;
									h ^= h >>> 13;
									h *= -1028477387;
									hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
									nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
									if(nextDepth < 8 && nextDepth >= 0) {
										nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
										zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
										zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
										hashDepth = nextDepth + 1;
										index = nextIndex;
										let addr = hash.hashScratchAddr;
										let v = zip__$DeflateStream_Memory.memory.getInt32(index);
										zip__$DeflateStream_Memory.memory.setInt32(addr,v);
										let addr1 = hash.hashScratchAddr + 4;
										let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
										zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
										zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
										let h1 = 775236557;
										let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 = 775236557 ^ k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 ^= k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										let h = h1 ^ hashDepth;
										h ^= h >>> 16;
										h *= -2048144789;
										h ^= h >>> 13;
										h *= -1028477387;
										hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
										nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
										if(nextDepth < 8 && nextDepth >= 0) {
											nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
											zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
											zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
											hashDepth = nextDepth + 1;
											index = nextIndex;
											let addr = hash.hashScratchAddr;
											let v = zip__$DeflateStream_Memory.memory.getInt32(index);
											zip__$DeflateStream_Memory.memory.setInt32(addr,v);
											let addr1 = hash.hashScratchAddr + 4;
											let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
											zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
											zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
											let h1 = 775236557;
											let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
											k1 = k1 << 15 | k1 >>> 17;
											h1 = 775236557 ^ k1 * 461845907;
											h1 = h1 << 13 | h1 >>> 19;
											h1 = h1 * 5 + (-430675100);
											k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
											k1 = k1 << 15 | k1 >>> 17;
											h1 ^= k1 * 461845907;
											h1 = h1 << 13 | h1 >>> 19;
											h1 = h1 * 5 + (-430675100);
											let h = h1 ^ hashDepth;
											h ^= h >>> 16;
											h *= -2048144789;
											h ^= h >>> 13;
											h *= -1028477387;
											hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
											nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
											if(nextDepth < 8 && nextDepth >= 0) {
												nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
												zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
												zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
												hashDepth = nextDepth + 1;
												index = nextIndex;
												let addr = hash.hashScratchAddr;
												let v = zip__$DeflateStream_Memory.memory.getInt32(index);
												zip__$DeflateStream_Memory.memory.setInt32(addr,v);
												let addr1 = hash.hashScratchAddr + 4;
												let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
												zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
												zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
												let h1 = 775236557;
												let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
												k1 = k1 << 15 | k1 >>> 17;
												h1 = 775236557 ^ k1 * 461845907;
												h1 = h1 << 13 | h1 >>> 19;
												h1 = h1 * 5 + (-430675100);
												k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
												k1 = k1 << 15 | k1 >>> 17;
												h1 ^= k1 * 461845907;
												h1 = h1 << 13 | h1 >>> 19;
												h1 = h1 * 5 + (-430675100);
												let h = h1 ^ hashDepth;
												h ^= h >>> 16;
												h *= -2048144789;
												h ^= h >>> 13;
												h *= -1028477387;
												hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
											}
										}
									}
								}
								zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
								zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
								hash.resultAddr = hash.baseResultAddr + (hash.resultAddr - hash.baseResultAddr + 4 & 7);
							}
						}
						if(zip__$DeflateStream_Memory.memory.getUInt16(hash.resultAddr) >= 4) {
							length = zip__$DeflateStream_Memory.memory.getUInt16(hash.resultAddr);
							let symbol = zip__$DeflateStream_Memory.memory.getUInt16(this.scratchAddr + 2492 + (length << 2) + 2);
							let addr = this.scratchAddr + (symbol << 2);
							let v = zip__$DeflateStream_Memory.memory.getInt32(addr) + 1;
							zip__$DeflateStream_Memory.memory.setInt32(addr,v);
							let distance = zip__$DeflateStream_Memory.memory.getUInt16(hash.resultAddr + 2);
							distanceInfo = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance <= 256 ? distance : 256 + (distance - 1 >>> 7)) << 2));
							let addr1 = this.scratchAddr + 1144 + (distanceInfo >>> 24 << 2);
							let v1 = zip__$DeflateStream_Memory.memory.getInt32(addr1) + 1;
							zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
							let v2 = zip__$DeflateStream_Memory.memory.getInt32(hash.resultAddr) | 512;
							zip__$DeflateStream_Memory.memory.setInt32(currentBufferAddr,v2);
							currentBufferAddr += 4;
							i += length;
						} else {
							symbol = zip__$DeflateStream_Memory.memory.b[i];
							zip__$DeflateStream_Memory.memory.setUInt16(currentBufferAddr,symbol);
							let addr = this.scratchAddr + (symbol << 2);
							let v = zip__$DeflateStream_Memory.memory.getInt32(addr) + 1;
							zip__$DeflateStream_Memory.memory.setInt32(addr,v);
							currentBufferAddr += 2;
							++i;
						}
					}
					while(i < lookaheadEnd) {
						let length1;
						let h1 = 775236557;
						let k1 = zip__$DeflateStream_Memory.memory.getInt32(i + 1) * -862048943;
						k1 = k1 << 15 | k1 >>> 17;
						h1 = 775236557 ^ k1 * 461845907;
						h1 = h1 << 13 | h1 >>> 19;
						h1 = h1 * 5 + (-430675100);
						let h = h1 ^ 4;
						h ^= h >>> 16;
						h *= -2048144789;
						h ^= h >>> 13;
						h *= -1028477387;
						let hashOffset = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
						if(zip__$DeflateStream_Memory.memory.getUInt16(hash.baseResultAddr + (hash.resultAddr - hash.baseResultAddr + 4 & 7)) < hash.avgMatchLength + 4) {
							let i1 = i + 1;
							let longestLength = 3;
							let longestEndPosition = -1;
							let length;
							let k;
							let j = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
							if(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(i1) == zip__$DeflateStream_Memory.memory.getInt32(j) && i1 - j <= hash.windowSize) {
								k = i1 + 4;
								length = 4;
								j += 4;
								while(k + 4 <= cappedEnd && zip__$DeflateStream_Memory.memory.getInt32(j) == zip__$DeflateStream_Memory.memory.getInt32(k) && length + 4 <= hash.maxMatchLength) {
									length += 4;
									j += 4;
									k += 4;
								}
								while(k < cappedEnd && zip__$DeflateStream_Memory.memory.b[j] == zip__$DeflateStream_Memory.memory.b[k] && length < hash.maxMatchLength) {
									++length;
									++j;
									++k;
								}
								longestLength = length;
								longestEndPosition = j;
							}
							let _g = 5;
							while(_g < 9) {
								let hashDepth = _g++;
								let addr = hash.hashScratchAddr;
								let v = zip__$DeflateStream_Memory.memory.getInt32(i1);
								zip__$DeflateStream_Memory.memory.setInt32(addr,v);
								let addr1 = hash.hashScratchAddr + 4;
								let v1 = zip__$DeflateStream_Memory.memory.getInt32(i1 + 4);
								zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
								zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
								let h1 = 775236557;
								let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 = 775236557 ^ k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 ^= k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								let h = h1 ^ hashDepth;
								h ^= h >>> 16;
								h *= -2048144789;
								h ^= h >>> 13;
								h *= -1028477387;
								j = zip__$DeflateStream_Memory.memory.getInt32(hash.addr + ((h ^ h >>> 16) & 65535) * 5 + 1);
								if(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(i1) == zip__$DeflateStream_Memory.memory.getInt32(j) && i1 - j <= hash.windowSize) {
									k = i1 + 4;
									length = 4;
									j += 4;
									while(k + 4 <= cappedEnd && zip__$DeflateStream_Memory.memory.getInt32(j) == zip__$DeflateStream_Memory.memory.getInt32(k) && length + 4 <= hash.maxMatchLength) {
										length += 4;
										j += 4;
										k += 4;
									}
									while(k < cappedEnd && zip__$DeflateStream_Memory.memory.b[j] == zip__$DeflateStream_Memory.memory.b[k] && length < hash.maxMatchLength) {
										++length;
										++j;
										++k;
									}
									if(length > longestLength) {
										longestLength = length;
										longestEndPosition = j;
									}
								}
							}
							zip__$DeflateStream_Memory.memory.setInt32(hash.resultAddr,i1 - (longestEndPosition - longestLength) << 16 | longestLength);
						} else {
							zip__$DeflateStream_Memory.memory.setInt32(hash.resultAddr,0);
						}
						let hashOffset1 = hashOffset;
						let hashDepth = 4;
						let index = i + 1;
						let nextIndex;
						let nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset];
						if(nextDepth < 8 && nextDepth >= 0) {
							nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
							zip__$DeflateStream_Memory.memory.b[hashOffset] = 4;
							zip__$DeflateStream_Memory.memory.setInt32(hashOffset + 1,index);
							hashDepth = nextDepth + 1;
							index = nextIndex;
							let addr = hash.hashScratchAddr;
							let v = zip__$DeflateStream_Memory.memory.getInt32(index);
							zip__$DeflateStream_Memory.memory.setInt32(addr,v);
							let addr1 = hash.hashScratchAddr + 4;
							let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
							zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
							zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
							let h1 = 775236557;
							let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
							k1 = k1 << 15 | k1 >>> 17;
							h1 = 775236557 ^ k1 * 461845907;
							h1 = h1 << 13 | h1 >>> 19;
							h1 = h1 * 5 + (-430675100);
							k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
							k1 = k1 << 15 | k1 >>> 17;
							h1 ^= k1 * 461845907;
							h1 = h1 << 13 | h1 >>> 19;
							h1 = h1 * 5 + (-430675100);
							let h = h1 ^ hashDepth;
							h ^= h >>> 16;
							h *= -2048144789;
							h ^= h >>> 13;
							h *= -1028477387;
							hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
							nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
							if(nextDepth < 8 && nextDepth >= 0) {
								nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
								zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
								zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
								hashDepth = nextDepth + 1;
								index = nextIndex;
								let addr = hash.hashScratchAddr;
								let v = zip__$DeflateStream_Memory.memory.getInt32(index);
								zip__$DeflateStream_Memory.memory.setInt32(addr,v);
								let addr1 = hash.hashScratchAddr + 4;
								let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
								zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
								zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
								let h1 = 775236557;
								let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 = 775236557 ^ k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 ^= k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								let h = h1 ^ hashDepth;
								h ^= h >>> 16;
								h *= -2048144789;
								h ^= h >>> 13;
								h *= -1028477387;
								hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
								nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
								if(nextDepth < 8 && nextDepth >= 0) {
									nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
									zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
									zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
									hashDepth = nextDepth + 1;
									index = nextIndex;
									let addr = hash.hashScratchAddr;
									let v = zip__$DeflateStream_Memory.memory.getInt32(index);
									zip__$DeflateStream_Memory.memory.setInt32(addr,v);
									let addr1 = hash.hashScratchAddr + 4;
									let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
									zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
									zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
									let h1 = 775236557;
									let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 = 775236557 ^ k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 ^= k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									let h = h1 ^ hashDepth;
									h ^= h >>> 16;
									h *= -2048144789;
									h ^= h >>> 13;
									h *= -1028477387;
									hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
									nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
									if(nextDepth < 8 && nextDepth >= 0) {
										nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
										zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
										zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
										hashDepth = nextDepth + 1;
										index = nextIndex;
										let addr = hash.hashScratchAddr;
										let v = zip__$DeflateStream_Memory.memory.getInt32(index);
										zip__$DeflateStream_Memory.memory.setInt32(addr,v);
										let addr1 = hash.hashScratchAddr + 4;
										let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
										zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
										zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
										let h1 = 775236557;
										let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 = 775236557 ^ k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 ^= k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										let h = h1 ^ hashDepth;
										h ^= h >>> 16;
										h *= -2048144789;
										h ^= h >>> 13;
										h *= -1028477387;
										hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
									}
								}
							}
						}
						zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
						zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
						hash.resultAddr = hash.baseResultAddr + (hash.resultAddr - hash.baseResultAddr + 4 & 7);
						if(zip__$DeflateStream_Memory.memory.getUInt16(hash.resultAddr) >= 4) {
							length1 = zip__$DeflateStream_Memory.memory.getUInt16(hash.resultAddr);
							if(zip__$DeflateStream_Memory.memory.getUInt16(hash.baseResultAddr + (hash.resultAddr - hash.baseResultAddr + 4 & 7)) > length1) {
								zip__$DeflateStream_Memory.memory.setInt32(hash.resultAddr,0);
							} else if(i + length1 + 9 < cappedEnd) {
								if(length1 < hash.avgMatchLength + 4) {
									let _g = i + 1 + 1;
									let _g1 = i + length1;
									while(_g < _g1) {
										let k = _g++;
										let hashDepth = 4;
										let index = k;
										let nextIndex;
										let h1 = 775236557;
										let k1 = zip__$DeflateStream_Memory.memory.getInt32(k) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 = 775236557 ^ k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										let h = h1 ^ 4;
										h ^= h >>> 16;
										h *= -2048144789;
										h ^= h >>> 13;
										h *= -1028477387;
										let hashOffset = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
										let nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset];
										if(nextDepth < 8 && nextDepth >= 0) {
											nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
											zip__$DeflateStream_Memory.memory.b[hashOffset] = 4;
											zip__$DeflateStream_Memory.memory.setInt32(hashOffset + 1,k);
											hashDepth = nextDepth + 1;
											index = nextIndex;
											let addr = hash.hashScratchAddr;
											let v = zip__$DeflateStream_Memory.memory.getInt32(index);
											zip__$DeflateStream_Memory.memory.setInt32(addr,v);
											let addr1 = hash.hashScratchAddr + 4;
											let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
											zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
											zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
											let h1 = 775236557;
											let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
											k1 = k1 << 15 | k1 >>> 17;
											h1 = 775236557 ^ k1 * 461845907;
											h1 = h1 << 13 | h1 >>> 19;
											h1 = h1 * 5 + (-430675100);
											k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
											k1 = k1 << 15 | k1 >>> 17;
											h1 ^= k1 * 461845907;
											h1 = h1 << 13 | h1 >>> 19;
											h1 = h1 * 5 + (-430675100);
											let h = h1 ^ hashDepth;
											h ^= h >>> 16;
											h *= -2048144789;
											h ^= h >>> 13;
											h *= -1028477387;
											hashOffset = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
											nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset];
											if(nextDepth < 8 && nextDepth >= 0) {
												nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
												zip__$DeflateStream_Memory.memory.b[hashOffset] = hashDepth;
												zip__$DeflateStream_Memory.memory.setInt32(hashOffset + 1,index);
												hashDepth = nextDepth + 1;
												index = nextIndex;
												let addr = hash.hashScratchAddr;
												let v = zip__$DeflateStream_Memory.memory.getInt32(index);
												zip__$DeflateStream_Memory.memory.setInt32(addr,v);
												let addr1 = hash.hashScratchAddr + 4;
												let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
												zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
												zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
												let h1 = 775236557;
												let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
												k1 = k1 << 15 | k1 >>> 17;
												h1 = 775236557 ^ k1 * 461845907;
												h1 = h1 << 13 | h1 >>> 19;
												h1 = h1 * 5 + (-430675100);
												k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
												k1 = k1 << 15 | k1 >>> 17;
												h1 ^= k1 * 461845907;
												h1 = h1 << 13 | h1 >>> 19;
												h1 = h1 * 5 + (-430675100);
												let h = h1 ^ hashDepth;
												h ^= h >>> 16;
												h *= -2048144789;
												h ^= h >>> 13;
												h *= -1028477387;
												hashOffset = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
											}
										}
										zip__$DeflateStream_Memory.memory.b[hashOffset] = hashDepth;
										zip__$DeflateStream_Memory.memory.setInt32(hashOffset + 1,index);
									}
								}
								hash.resultAddr = hash.baseResultAddr + (hash.resultAddr - hash.baseResultAddr + 4 & 7);
								let i1 = i + length1;
								let h1 = 775236557;
								let k1 = zip__$DeflateStream_Memory.memory.getInt32(i1) * -862048943;
								k1 = k1 << 15 | k1 >>> 17;
								h1 = 775236557 ^ k1 * 461845907;
								h1 = h1 << 13 | h1 >>> 19;
								h1 = h1 * 5 + (-430675100);
								let h = h1 ^ 4;
								h ^= h >>> 16;
								h *= -2048144789;
								h ^= h >>> 13;
								h *= -1028477387;
								let hashOffset = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
								let longestLength = 3;
								let longestEndPosition = -1;
								let length;
								let k;
								let j = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
								if(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(i1) == zip__$DeflateStream_Memory.memory.getInt32(j) && i1 - j <= hash.windowSize) {
									k = i1 + 4;
									length = 4;
									j += 4;
									while(k + 4 <= cappedEnd && zip__$DeflateStream_Memory.memory.getInt32(j) == zip__$DeflateStream_Memory.memory.getInt32(k) && length + 4 <= hash.maxMatchLength) {
										length += 4;
										j += 4;
										k += 4;
									}
									while(k < cappedEnd && zip__$DeflateStream_Memory.memory.b[j] == zip__$DeflateStream_Memory.memory.b[k] && length < hash.maxMatchLength) {
										++length;
										++j;
										++k;
									}
									longestLength = length;
									longestEndPosition = j;
								}
								let _g = 5;
								while(_g < 9) {
									let hashDepth = _g++;
									let addr = hash.hashScratchAddr;
									let v = zip__$DeflateStream_Memory.memory.getInt32(i1);
									zip__$DeflateStream_Memory.memory.setInt32(addr,v);
									let addr1 = hash.hashScratchAddr + 4;
									let v1 = zip__$DeflateStream_Memory.memory.getInt32(i1 + 4);
									zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
									zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
									let h1 = 775236557;
									let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 = 775236557 ^ k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 ^= k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									let h = h1 ^ hashDepth;
									h ^= h >>> 16;
									h *= -2048144789;
									h ^= h >>> 13;
									h *= -1028477387;
									j = zip__$DeflateStream_Memory.memory.getInt32(hash.addr + ((h ^ h >>> 16) & 65535) * 5 + 1);
									if(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(i1) == zip__$DeflateStream_Memory.memory.getInt32(j) && i1 - j <= hash.windowSize) {
										k = i1 + 4;
										length = 4;
										j += 4;
										while(k + 4 <= cappedEnd && zip__$DeflateStream_Memory.memory.getInt32(j) == zip__$DeflateStream_Memory.memory.getInt32(k) && length + 4 <= hash.maxMatchLength) {
											length += 4;
											j += 4;
											k += 4;
										}
										while(k < cappedEnd && zip__$DeflateStream_Memory.memory.b[j] == zip__$DeflateStream_Memory.memory.b[k] && length < hash.maxMatchLength) {
											++length;
											++j;
											++k;
										}
										if(length > longestLength) {
											longestLength = length;
											longestEndPosition = j;
										}
									}
								}
								zip__$DeflateStream_Memory.memory.setInt32(hash.resultAddr,i1 - (longestEndPosition - longestLength) << 16 | longestLength);
								let hashOffset1 = hashOffset;
								let hashDepth = 4;
								let index = i1;
								let nextIndex;
								let nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset];
								if(nextDepth < 8 && nextDepth >= 0) {
									nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset + 1);
									zip__$DeflateStream_Memory.memory.b[hashOffset] = 4;
									zip__$DeflateStream_Memory.memory.setInt32(hashOffset + 1,i1);
									hashDepth = nextDepth + 1;
									index = nextIndex;
									let addr = hash.hashScratchAddr;
									let v = zip__$DeflateStream_Memory.memory.getInt32(index);
									zip__$DeflateStream_Memory.memory.setInt32(addr,v);
									let addr1 = hash.hashScratchAddr + 4;
									let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
									zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
									zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
									let h1 = 775236557;
									let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 = 775236557 ^ k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
									k1 = k1 << 15 | k1 >>> 17;
									h1 ^= k1 * 461845907;
									h1 = h1 << 13 | h1 >>> 19;
									h1 = h1 * 5 + (-430675100);
									let h = h1 ^ hashDepth;
									h ^= h >>> 16;
									h *= -2048144789;
									h ^= h >>> 13;
									h *= -1028477387;
									hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
									nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
									if(nextDepth < 8 && nextDepth >= 0) {
										nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
										zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
										zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
										hashDepth = nextDepth + 1;
										index = nextIndex;
										let addr = hash.hashScratchAddr;
										let v = zip__$DeflateStream_Memory.memory.getInt32(index);
										zip__$DeflateStream_Memory.memory.setInt32(addr,v);
										let addr1 = hash.hashScratchAddr + 4;
										let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
										zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
										zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
										let h1 = 775236557;
										let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 = 775236557 ^ k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
										k1 = k1 << 15 | k1 >>> 17;
										h1 ^= k1 * 461845907;
										h1 = h1 << 13 | h1 >>> 19;
										h1 = h1 * 5 + (-430675100);
										let h = h1 ^ hashDepth;
										h ^= h >>> 16;
										h *= -2048144789;
										h ^= h >>> 13;
										h *= -1028477387;
										hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
										nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
										if(nextDepth < 8 && nextDepth >= 0) {
											nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
											zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
											zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
											hashDepth = nextDepth + 1;
											index = nextIndex;
											let addr = hash.hashScratchAddr;
											let v = zip__$DeflateStream_Memory.memory.getInt32(index);
											zip__$DeflateStream_Memory.memory.setInt32(addr,v);
											let addr1 = hash.hashScratchAddr + 4;
											let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
											zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
											zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
											let h1 = 775236557;
											let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
											k1 = k1 << 15 | k1 >>> 17;
											h1 = 775236557 ^ k1 * 461845907;
											h1 = h1 << 13 | h1 >>> 19;
											h1 = h1 * 5 + (-430675100);
											k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
											k1 = k1 << 15 | k1 >>> 17;
											h1 ^= k1 * 461845907;
											h1 = h1 << 13 | h1 >>> 19;
											h1 = h1 * 5 + (-430675100);
											let h = h1 ^ hashDepth;
											h ^= h >>> 16;
											h *= -2048144789;
											h ^= h >>> 13;
											h *= -1028477387;
											hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
											nextDepth = zip__$DeflateStream_Memory.memory.b[hashOffset1];
											if(nextDepth < 8 && nextDepth >= 0) {
												nextIndex = zip__$DeflateStream_Memory.memory.getInt32(hashOffset1 + 1);
												zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
												zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
												hashDepth = nextDepth + 1;
												index = nextIndex;
												let addr = hash.hashScratchAddr;
												let v = zip__$DeflateStream_Memory.memory.getInt32(index);
												zip__$DeflateStream_Memory.memory.setInt32(addr,v);
												let addr1 = hash.hashScratchAddr + 4;
												let v1 = zip__$DeflateStream_Memory.memory.getInt32(index + 4);
												zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
												zip__$DeflateStream_Memory.memory.setInt32(hash.hashScratchAddr + hashDepth,0);
												let h1 = 775236557;
												let k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr) * -862048943;
												k1 = k1 << 15 | k1 >>> 17;
												h1 = 775236557 ^ k1 * 461845907;
												h1 = h1 << 13 | h1 >>> 19;
												h1 = h1 * 5 + (-430675100);
												k1 = zip__$DeflateStream_Memory.memory.getInt32(hash.hashScratchAddr + 4) * -862048943;
												k1 = k1 << 15 | k1 >>> 17;
												h1 ^= k1 * 461845907;
												h1 = h1 << 13 | h1 >>> 19;
												h1 = h1 * 5 + (-430675100);
												let h = h1 ^ hashDepth;
												h ^= h >>> 16;
												h *= -2048144789;
												h ^= h >>> 13;
												h *= -1028477387;
												hashOffset1 = hash.addr + ((h ^ h >>> 16) & 65535) * 5;
											}
										}
									}
								}
								zip__$DeflateStream_Memory.memory.b[hashOffset1] = hashDepth;
								zip__$DeflateStream_Memory.memory.setInt32(hashOffset1 + 1,index);
								hash.resultAddr = hash.baseResultAddr + (hash.resultAddr - hash.baseResultAddr + 4 & 7);
							}
						}
						if(zip__$DeflateStream_Memory.memory.getUInt16(hash.resultAddr) >= 4) {
							length = zip__$DeflateStream_Memory.memory.getUInt16(hash.resultAddr);
							let symbol = zip__$DeflateStream_Memory.memory.getUInt16(this.scratchAddr + 2492 + (length << 2) + 2);
							let addr = this.scratchAddr + (symbol << 2);
							let v = zip__$DeflateStream_Memory.memory.getInt32(addr) + 1;
							zip__$DeflateStream_Memory.memory.setInt32(addr,v);
							let distance = zip__$DeflateStream_Memory.memory.getUInt16(hash.resultAddr + 2);
							distanceInfo = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance <= 256 ? distance : 256 + (distance - 1 >>> 7)) << 2));
							let addr1 = this.scratchAddr + 1144 + (distanceInfo >>> 24 << 2);
							let v1 = zip__$DeflateStream_Memory.memory.getInt32(addr1) + 1;
							zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
							let v2 = zip__$DeflateStream_Memory.memory.getInt32(hash.resultAddr) | 512;
							zip__$DeflateStream_Memory.memory.setInt32(currentBufferAddr,v2);
							currentBufferAddr += 4;
							i += length;
						} else {
							symbol = zip__$DeflateStream_Memory.memory.b[i];
							zip__$DeflateStream_Memory.memory.setUInt16(currentBufferAddr,symbol);
							let addr = this.scratchAddr + (symbol << 2);
							let v = zip__$DeflateStream_Memory.memory.getInt32(addr) + 1;
							zip__$DeflateStream_Memory.memory.setInt32(addr,v);
							currentBufferAddr += 2;
							++i;
						}
					}
					while(i < cappedEnd) {
						symbol = zip__$DeflateStream_Memory.memory.b[i];
						zip__$DeflateStream_Memory.memory.setUInt16(currentBufferAddr,symbol);
						let addr = this.scratchAddr + (symbol << 2);
						let v = zip__$DeflateStream_Memory.memory.getInt32(addr) + 1;
						zip__$DeflateStream_Memory.memory.setInt32(addr,v);
						currentBufferAddr += 2;
						++i;
					}
					this.blockInProgress = true;
					if(this.level == zip_CompressionLevel.UNCOMPRESSED) {
						if(this.bitOffset == 0) {
							zip__$DeflateStream_Memory.memory.b[this.currentAddr] = 0;
						}
						let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current |= 0 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
						this.bitOffset += 3;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
						if(this.bitOffset > 0) {
							let bitCount = 8 - this.bitOffset;
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= 0 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += bitCount;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
					} else {
						let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current |= 4 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
						this.bitOffset += 3;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
					}
					this.blockStartAddr = this.currentAddr;
					this.createAndWriteHuffmanTrees(offset1,cappedEnd);
					i = bufferAddr;
					while(i + 64 <= currentBufferAddr) {
						let length;
						let distance;
						let lengthInfo;
						let distanceInfo;
						let symbol1 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol1 & 512) != 0) {
							length = symbol1 ^ 512;
							lengthInfo = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length - (lengthInfo & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance <= 256 ? distance : 256 + (distance - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance - (distanceInfo & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol1 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol1;
						i += 2 + ((symbol1 & 512) >>> 8);
						let length1;
						let distance1;
						let lengthInfo1;
						let distanceInfo1;
						let symbol2 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol2 & 512) != 0) {
							length1 = symbol2 ^ 512;
							lengthInfo1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length1 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo1 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length1 - (lengthInfo1 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo1 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance1 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance1 <= 256 ? distance1 : 256 + (distance1 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo1 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance1 - (distanceInfo1 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo1 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol2 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol2;
						i += 2 + ((symbol2 & 512) >>> 8);
						let length2;
						let distance2;
						let lengthInfo2;
						let distanceInfo2;
						let symbol3 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol3 & 512) != 0) {
							length2 = symbol3 ^ 512;
							lengthInfo2 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length2 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo2 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length2 - (lengthInfo2 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo2 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance2 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo2 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance2 <= 256 ? distance2 : 256 + (distance2 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo2 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance2 - (distanceInfo2 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo2 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol3 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol3;
						i += 2 + ((symbol3 & 512) >>> 8);
						let length3;
						let distance3;
						let lengthInfo3;
						let distanceInfo3;
						let symbol4 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol4 & 512) != 0) {
							length3 = symbol4 ^ 512;
							lengthInfo3 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length3 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo3 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length3 - (lengthInfo3 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo3 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance3 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo3 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance3 <= 256 ? distance3 : 256 + (distance3 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo3 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance3 - (distanceInfo3 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo3 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol4 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol4;
						i += 2 + ((symbol4 & 512) >>> 8);
						let length4;
						let distance4;
						let lengthInfo4;
						let distanceInfo4;
						let symbol5 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol5 & 512) != 0) {
							length4 = symbol5 ^ 512;
							lengthInfo4 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length4 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo4 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length4 - (lengthInfo4 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo4 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance4 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo4 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance4 <= 256 ? distance4 : 256 + (distance4 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo4 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance4 - (distanceInfo4 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo4 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol5 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol5;
						i += 2 + ((symbol5 & 512) >>> 8);
						let length5;
						let distance5;
						let lengthInfo5;
						let distanceInfo5;
						let symbol6 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol6 & 512) != 0) {
							length5 = symbol6 ^ 512;
							lengthInfo5 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length5 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo5 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length5 - (lengthInfo5 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo5 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance5 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo5 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance5 <= 256 ? distance5 : 256 + (distance5 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo5 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance5 - (distanceInfo5 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo5 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol6 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol6;
						i += 2 + ((symbol6 & 512) >>> 8);
						let length6;
						let distance6;
						let lengthInfo6;
						let distanceInfo6;
						let symbol7 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol7 & 512) != 0) {
							length6 = symbol7 ^ 512;
							lengthInfo6 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length6 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo6 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length6 - (lengthInfo6 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo6 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance6 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo6 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance6 <= 256 ? distance6 : 256 + (distance6 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo6 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance6 - (distanceInfo6 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo6 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol7 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol7;
						i += 2 + ((symbol7 & 512) >>> 8);
						let length7;
						let distance7;
						let lengthInfo7;
						let distanceInfo7;
						let symbol8 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol8 & 512) != 0) {
							length7 = symbol8 ^ 512;
							lengthInfo7 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length7 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo7 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length7 - (lengthInfo7 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo7 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance7 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo7 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance7 <= 256 ? distance7 : 256 + (distance7 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo7 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance7 - (distanceInfo7 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo7 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol8 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol8;
						i += 2 + ((symbol8 & 512) >>> 8);
						let length8;
						let distance8;
						let lengthInfo8;
						let distanceInfo8;
						let symbol9 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol9 & 512) != 0) {
							length8 = symbol9 ^ 512;
							lengthInfo8 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length8 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo8 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length8 - (lengthInfo8 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo8 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance8 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo8 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance8 <= 256 ? distance8 : 256 + (distance8 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo8 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance8 - (distanceInfo8 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo8 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol9 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol9;
						i += 2 + ((symbol9 & 512) >>> 8);
						let length9;
						let distance9;
						let lengthInfo9;
						let distanceInfo9;
						let symbol10 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol10 & 512) != 0) {
							length9 = symbol10 ^ 512;
							lengthInfo9 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length9 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo9 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length9 - (lengthInfo9 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo9 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance9 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo9 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance9 <= 256 ? distance9 : 256 + (distance9 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo9 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance9 - (distanceInfo9 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo9 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol10 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol10;
						i += 2 + ((symbol10 & 512) >>> 8);
						let length10;
						let distance10;
						let lengthInfo10;
						let distanceInfo10;
						let symbol11 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol11 & 512) != 0) {
							length10 = symbol11 ^ 512;
							lengthInfo10 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length10 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo10 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length10 - (lengthInfo10 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo10 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance10 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo10 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance10 <= 256 ? distance10 : 256 + (distance10 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo10 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance10 - (distanceInfo10 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo10 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol11 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol11;
						i += 2 + ((symbol11 & 512) >>> 8);
						let length11;
						let distance11;
						let lengthInfo11;
						let distanceInfo11;
						let symbol12 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol12 & 512) != 0) {
							length11 = symbol12 ^ 512;
							lengthInfo11 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length11 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo11 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length11 - (lengthInfo11 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo11 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance11 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo11 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance11 <= 256 ? distance11 : 256 + (distance11 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo11 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance11 - (distanceInfo11 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo11 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol12 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol12;
						i += 2 + ((symbol12 & 512) >>> 8);
						let length12;
						let distance12;
						let lengthInfo12;
						let distanceInfo12;
						let symbol13 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol13 & 512) != 0) {
							length12 = symbol13 ^ 512;
							lengthInfo12 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length12 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo12 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length12 - (lengthInfo12 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo12 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance12 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo12 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance12 <= 256 ? distance12 : 256 + (distance12 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo12 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance12 - (distanceInfo12 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo12 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol13 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol13;
						i += 2 + ((symbol13 & 512) >>> 8);
						let length13;
						let distance13;
						let lengthInfo13;
						let distanceInfo13;
						let symbol14 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol14 & 512) != 0) {
							length13 = symbol14 ^ 512;
							lengthInfo13 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length13 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo13 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length13 - (lengthInfo13 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo13 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance13 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo13 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance13 <= 256 ? distance13 : 256 + (distance13 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo13 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance13 - (distanceInfo13 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo13 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol14 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol14;
						i += 2 + ((symbol14 & 512) >>> 8);
						let length14;
						let distance14;
						let lengthInfo14;
						let distanceInfo14;
						let symbol15 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol15 & 512) != 0) {
							length14 = symbol15 ^ 512;
							lengthInfo14 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length14 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo14 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length14 - (lengthInfo14 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo14 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance14 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo14 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance14 <= 256 ? distance14 : 256 + (distance14 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo14 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance14 - (distanceInfo14 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo14 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol15 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol15;
						i += 2 + ((symbol15 & 512) >>> 8);
						let length15;
						let distance15;
						let lengthInfo15;
						let distanceInfo15;
						let symbol16 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol16 & 512) != 0) {
							length15 = symbol16 ^ 512;
							lengthInfo15 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length15 << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo15 >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length15 - (lengthInfo15 & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo15 & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance15 = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo15 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance15 <= 256 ? distance15 : 256 + (distance15 - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo15 >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance15 - (distanceInfo15 & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo15 & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol16 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol16;
						i += 2 + ((symbol16 & 512) >>> 8);
					}
					while(i < currentBufferAddr) {
						let length;
						let distance;
						let lengthInfo;
						let distanceInfo;
						let symbol1 = zip__$DeflateStream_Memory.memory.getUInt16(i);
						if((symbol1 & 512) != 0) {
							length = symbol1 ^ 512;
							lengthInfo = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 2492 + (length << 2));
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + (lengthInfo >>> 16) * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current1 |= length - (lengthInfo & 8191) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
							this.bitOffset += (lengthInfo & 65280) >>> 13;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							distance = zip__$DeflateStream_Memory.memory.getUInt16(i + 2);
							distanceInfo = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 3528 + ((distance <= 256 ? distance : 256 + (distance - 1 >>> 7)) << 2));
							let compressed1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1144 + (distanceInfo >>> 24) * 4);
							let current2 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current2 |= compressed1 >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current2);
							this.bitOffset += compressed1 & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
							let current3 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current3 |= distance - (distanceInfo & 65535) << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current3);
							this.bitOffset += (distanceInfo & 16711680) >>> 16;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						} else {
							let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol1 * 4);
							let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
							current |= compressed >>> 16 << this.bitOffset;
							zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
							this.bitOffset += compressed & 65535;
							this.currentAddr += this.bitOffset >>> 3;
							this.bitOffset &= 7;
						}
						symbol = symbol1;
						i += 2 + ((symbol1 & 512) >>> 8);
					}
					if(this.level != zip_CompressionLevel.UNCOMPRESSED) {
						let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1024);
						let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
						current |= compressed >>> 16 << this.bitOffset;
						zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
						this.bitOffset += compressed & 65535;
						this.currentAddr += this.bitOffset >>> 3;
						this.bitOffset &= 7;
					}
					this.blockInProgress = false;
					offset1 = cappedEnd;
				}
			} else {
				throw haxe_Exception.thrown("Compression level not supported");
			}
		}
	}
	finalize() {
		let range = this.fastFinalize();
		let result = new haxe_io_Bytes(new ArrayBuffer(range.end - range.offset));
		result.blit(0,zip__$DeflateStream_Memory.memory,range.offset,range.end - range.offset);
		return result;
	}
	fastFinalize() {
		if(this.blockInProgress) {
			if(this.level != zip_CompressionLevel.UNCOMPRESSED) {
				let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1024);
				let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
				current |= compressed >>> 16 << this.bitOffset;
				zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
				this.bitOffset += compressed & 65535;
				this.currentAddr += this.bitOffset >>> 3;
				this.bitOffset &= 7;
			}
			this.blockInProgress = false;
		}
		if(this.blockInProgress) {
			if(this.level != zip_CompressionLevel.UNCOMPRESSED) {
				let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1024);
				let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
				current |= compressed >>> 16 << this.bitOffset;
				zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
				this.bitOffset += compressed & 65535;
				this.currentAddr += this.bitOffset >>> 3;
				this.bitOffset &= 7;
			}
			this.blockInProgress = false;
		}
		let currentLevel = this.level;
		this.level = zip_CompressionLevel.UNCOMPRESSED;
		this.blockInProgress = true;
		if(this.level == zip_CompressionLevel.UNCOMPRESSED) {
			if(this.bitOffset == 0) {
				zip__$DeflateStream_Memory.memory.b[this.currentAddr] = 0;
			}
			let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
			current |= 1 << this.bitOffset;
			zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
			this.bitOffset += 3;
			this.currentAddr += this.bitOffset >>> 3;
			this.bitOffset &= 7;
			if(this.bitOffset > 0) {
				let bitCount = 8 - this.bitOffset;
				let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
				current |= 0 << this.bitOffset;
				zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
				this.bitOffset += bitCount;
				this.currentAddr += this.bitOffset >>> 3;
				this.bitOffset &= 7;
			}
		} else {
			let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
			current |= 5 << this.bitOffset;
			zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
			this.bitOffset += 3;
			this.currentAddr += this.bitOffset >>> 3;
			this.bitOffset &= 7;
		}
		this.blockStartAddr = this.currentAddr;
		zip__$DeflateStream_Memory.memory.setUInt16(this.currentAddr,0);
		this.currentAddr += 2;
		zip__$DeflateStream_Memory.memory.setUInt16(this.currentAddr,-1);
		this.currentAddr += 2;
		if(this.level != zip_CompressionLevel.UNCOMPRESSED) {
			let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1024);
			let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
			current |= compressed >>> 16 << this.bitOffset;
			zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
			this.bitOffset += compressed & 65535;
			this.currentAddr += this.bitOffset >>> 3;
			this.bitOffset &= 7;
		}
		this.blockInProgress = false;
		this.level = currentLevel;
		if(this.bitOffset > 0) {
			++this.currentAddr;
		}
		if(this.zlib) {
			zip__$DeflateStream_Memory.memory.b[this.currentAddr] = this.s2 >>> 8;
			++this.currentAddr;
			zip__$DeflateStream_Memory.memory.b[this.currentAddr] = this.s2;
			++this.currentAddr;
			zip__$DeflateStream_Memory.memory.b[this.currentAddr] = this.s1 >>> 8;
			++this.currentAddr;
			zip__$DeflateStream_Memory.memory.b[this.currentAddr] = this.s1;
			++this.currentAddr;
		}
		this.rangeResult.offset = this.startAddr;
		this.rangeResult.end = this.currentAddr;
		return this.rangeResult;
	}
	createAndWriteHuffmanTrees(offset,end) {
		let n = 0;
		if(this.level == zip_CompressionLevel.FAST) {
			n = 257;
			let _g = 0;
			while(_g < 256) {
				let value = _g++;
				zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + value * 4,10);
			}
			zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1024,1);
			let len = end - offset;
			let sampleFrequency;
			if(len <= 16384) {
				sampleFrequency = 1;
			} else if(len <= 102400) {
				sampleFrequency = 5;
			} else {
				sampleFrequency = 11;
			}
			let byte;
			let samples = len / sampleFrequency | 0;
			let end16 = samples & -16;
			let i = 0;
			while(i < end16) {
				byte = zip__$DeflateStream_Memory.memory.b[offset + i * sampleFrequency];
				let addr = this.scratchAddr + byte * 4;
				let v = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr,v);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 1) * sampleFrequency];
				let addr1 = this.scratchAddr + byte * 4;
				let v1 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr1,v1);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 2) * sampleFrequency];
				let addr2 = this.scratchAddr + byte * 4;
				let v2 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr2,v2);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 3) * sampleFrequency];
				let addr3 = this.scratchAddr + byte * 4;
				let v3 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr3,v3);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 4) * sampleFrequency];
				let addr4 = this.scratchAddr + byte * 4;
				let v4 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr4,v4);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 5) * sampleFrequency];
				let addr5 = this.scratchAddr + byte * 4;
				let v5 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr5,v5);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 6) * sampleFrequency];
				let addr6 = this.scratchAddr + byte * 4;
				let v6 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr6,v6);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 7) * sampleFrequency];
				let addr7 = this.scratchAddr + byte * 4;
				let v7 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr7,v7);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 8) * sampleFrequency];
				let addr8 = this.scratchAddr + byte * 4;
				let v8 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr8,v8);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 9) * sampleFrequency];
				let addr9 = this.scratchAddr + byte * 4;
				let v9 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr9,v9);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 10) * sampleFrequency];
				let addr10 = this.scratchAddr + byte * 4;
				let v10 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr10,v10);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 11) * sampleFrequency];
				let addr11 = this.scratchAddr + byte * 4;
				let v11 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr11,v11);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 12) * sampleFrequency];
				let addr12 = this.scratchAddr + byte * 4;
				let v12 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr12,v12);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 13) * sampleFrequency];
				let addr13 = this.scratchAddr + byte * 4;
				let v13 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr13,v13);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 14) * sampleFrequency];
				let addr14 = this.scratchAddr + byte * 4;
				let v14 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr14,v14);
				byte = zip__$DeflateStream_Memory.memory.b[offset + (i + 15) * sampleFrequency];
				let addr15 = this.scratchAddr + byte * 4;
				let v15 = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr15,v15);
				i += 16;
			}
			while(i < samples) {
				byte = zip__$DeflateStream_Memory.memory.b[offset + i * sampleFrequency];
				let addr = this.scratchAddr + byte * 4;
				let v = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + byte * 4) + 1;
				zip__$DeflateStream_Memory.memory.setInt32(addr,v);
				++i;
			}
		} else if(this.level == zip_CompressionLevel.NORMAL || this.level == zip_CompressionLevel.GOOD) {
			n = 257;
			let _g = 257;
			while(_g < 286) {
				let symbol = _g++;
				if(zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol * 4) > 0) {
					n = symbol + 1;
				}
			}
			zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1024,1);
			let _g1 = 0;
			let _g2 = n;
			while(_g1 < _g2) {
				let symbol = _g1++;
				if(symbol != 256 && zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol * 4) > 0) {
					let addr = this.scratchAddr + symbol * 4;
					let v = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + symbol * 4) + 2;
					zip__$DeflateStream_Memory.memory.setInt32(addr,v);
				}
			}
		}
		zip__$DeflateStream_HuffmanTree.weightedAlphabetToCodes(this.scratchAddr,this.scratchAddr + n * 4,15);
		this.literalLengthCodes = n;
		let scratchOffset = this.scratchAddr + 1144;
		let n1 = 0;
		if(this.level == zip_CompressionLevel.NORMAL || this.level == zip_CompressionLevel.GOOD) {
			let _g = 0;
			while(_g < 30) {
				let symbol = _g++;
				if(zip__$DeflateStream_Memory.memory.getInt32(scratchOffset + symbol * 4) > 0) {
					n1 = symbol + 1;
				}
			}
		}
		zip__$DeflateStream_HuffmanTree.weightedAlphabetToCodes(scratchOffset,scratchOffset + n1 * 4,15);
		this.distanceCodes = n1;
		let literalLengthCodes = this.literalLengthCodes;
		let distanceCodes = this.distanceCodes;
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 4,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 8,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 12,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 16,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 20,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 24,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 28,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 32,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 36,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 40,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 44,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 48,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 52,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 56,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 60,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 64,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 68,1);
		zip__$DeflateStream_Memory.memory.setInt32(this.scratchAddr + 1272 + 72,1);
		let index;
		let _g = 0;
		while(_g < literalLengthCodes) {
			let i = _g++;
			index = this.scratchAddr + 1272 + zip__$DeflateStream_Memory.memory.getUInt16(this.scratchAddr + i * 4) * 4;
			let v = zip__$DeflateStream_Memory.memory.getInt32(index) + 1;
			zip__$DeflateStream_Memory.memory.setInt32(index,v);
		}
		let _g1 = 0;
		while(_g1 < distanceCodes) {
			let i = _g1++;
			index = this.scratchAddr + 1272 + zip__$DeflateStream_Memory.memory.getUInt16(this.scratchAddr + 1144 + i * 4) * 4;
			let v = zip__$DeflateStream_Memory.memory.getInt32(index) + 1;
			zip__$DeflateStream_Memory.memory.setInt32(index,v);
		}
		let offset1 = this.scratchAddr + 1272;
		zip__$DeflateStream_HuffmanTree.weightedAlphabetToCodes(offset1,offset1 + 76,7);
		let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
		current |= this.literalLengthCodes - 257 << this.bitOffset;
		zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
		this.bitOffset += 5;
		this.currentAddr += this.bitOffset >>> 3;
		this.bitOffset &= 7;
		if(this.distanceCodes == 0) {
			let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
			current |= 0 << this.bitOffset;
			zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
			this.bitOffset += 5;
			this.currentAddr += this.bitOffset >>> 3;
			this.bitOffset &= 7;
		} else {
			let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
			current |= this.distanceCodes - 1 << this.bitOffset;
			zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
			this.bitOffset += 5;
			this.currentAddr += this.bitOffset >>> 3;
			this.bitOffset &= 7;
		}
		let current1 = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
		current1 |= 15 << this.bitOffset;
		zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current1);
		this.bitOffset += 4;
		this.currentAddr += this.bitOffset >>> 3;
		this.bitOffset &= 7;
		let _g2 = 0;
		let _g3 = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
		while(_g2 < _g3.length) {
			let rank = _g3[_g2];
			++_g2;
			let bits = zip__$DeflateStream_Memory.memory.getUInt16(this.scratchAddr + 1272 + rank * 4);
			let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
			current |= bits << this.bitOffset;
			zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
			this.bitOffset += 3;
			this.currentAddr += this.bitOffset >>> 3;
			this.bitOffset &= 7;
		}
		let _g4 = 0;
		let _g5 = this.literalLengthCodes;
		while(_g4 < _g5) {
			let i = _g4++;
			let symbol = zip__$DeflateStream_Memory.memory.getUInt16(this.scratchAddr + i * 4);
			let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1272 + symbol * 4);
			let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
			current |= compressed >>> 16 << this.bitOffset;
			zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
			this.bitOffset += compressed & 65535;
			this.currentAddr += this.bitOffset >>> 3;
			this.bitOffset &= 7;
		}
		if(this.distanceCodes == 0) {
			let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1272);
			let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
			current |= compressed >>> 16 << this.bitOffset;
			zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
			this.bitOffset += compressed & 65535;
			this.currentAddr += this.bitOffset >>> 3;
			this.bitOffset &= 7;
		} else {
			let _g = 0;
			let _g1 = this.distanceCodes;
			while(_g < _g1) {
				let i = _g++;
				let symbol = zip__$DeflateStream_Memory.memory.getUInt16(this.scratchAddr + 1144 + i * 4);
				let compressed = zip__$DeflateStream_Memory.memory.getInt32(this.scratchAddr + 1272 + symbol * 4);
				let current = zip__$DeflateStream_Memory.memory.b[this.currentAddr];
				current |= compressed >>> 16 << this.bitOffset;
				zip__$DeflateStream_Memory.memory.setInt32(this.currentAddr,current);
				this.bitOffset += compressed & 65535;
				this.currentAddr += this.bitOffset >>> 3;
				this.bitOffset &= 7;
			}
		}
	}
	static create(level,writeZLIBInfo) {
		if(writeZLIBInfo == null) {
			writeZLIBInfo = false;
		}
		if(zip_DeflateStream.memory == null) {
			zip_DeflateStream.memory = new haxe_io_Bytes(new ArrayBuffer(5576));
		}
		zip__$DeflateStream_Memory.memory = zip_DeflateStream.memory;
		return zip_DeflateStream.createEx(level,0,5576,writeZLIBInfo);
	}
	static createEx(level,scratchAddr,startAddr,writeZLIBInfo) {
		if(writeZLIBInfo == null) {
			writeZLIBInfo = false;
		}
		return new zip_DeflateStream(level,writeZLIBInfo,scratchAddr,startAddr);
	}
}
$hxClasses["zip.DeflateStream"] = zip_DeflateStream;
zip_DeflateStream.__name__ = "zip.DeflateStream";
Object.assign(zip_DeflateStream.prototype, {
	__class__: zip_DeflateStream
	,level: null
	,zlib: null
	,startAddr: null
	,currentAddr: null
	,scratchAddr: null
	,blockInProgress: null
	,blockStartAddr: null
	,rangeResult: null
	,literalLengthCodes: null
	,distanceCodes: null
	,s1: null
	,s2: null
	,bitOffset: null
});
class zip__$DeflateStream_LZHash {
	constructor(addr,maxMatchLength,windowSize) {
		this.addr = addr;
		this.maxMatchLength = maxMatchLength;
		this.windowSize = windowSize;
		this.avgMatchLength = 12;
		this.baseResultAddr = this.resultAddr = addr + 327700 - 20;
		this.hashScratchAddr = this.baseResultAddr + 8;
		this.clearTable();
	}
	clearTable() {
		let i = this.addr;
		let end = this.addr + 327680;
		while(i < end) {
			zip__$DeflateStream_Memory.memory.setInt32(i,-1);
			zip__$DeflateStream_Memory.memory.setInt32(i + 4,-1);
			zip__$DeflateStream_Memory.memory.setInt32(i + 8,-1);
			zip__$DeflateStream_Memory.memory.setInt32(i + 12,-1);
			zip__$DeflateStream_Memory.memory.setInt32(i + 16,-1);
			zip__$DeflateStream_Memory.memory.setInt32(i + 20,-1);
			zip__$DeflateStream_Memory.memory.setInt32(i + 24,-1);
			zip__$DeflateStream_Memory.memory.setInt32(i + 28,-1);
			i += 32;
		}
	}
}
$hxClasses["zip._DeflateStream.LZHash"] = zip__$DeflateStream_LZHash;
zip__$DeflateStream_LZHash.__name__ = "zip._DeflateStream.LZHash";
Object.assign(zip__$DeflateStream_LZHash.prototype, {
	__class__: zip__$DeflateStream_LZHash
	,addr: null
	,baseResultAddr: null
	,hashScratchAddr: null
	,maxMatchLength: null
	,windowSize: null
	,avgMatchLength: null
	,resultAddr: null
});
class zip__$DeflateStream_HuffmanTree {
	static weightedAlphabetToCodes(offset,end,maxCodeLength) {
		let end1 = end;
		let originalN = end - offset >> 2;
		let n = originalN;
		if(originalN > 0) {
			let _g = 0;
			let _g1 = originalN;
			while(_g < _g1) {
				let i = _g++;
				zip__$DeflateStream_Memory.memory.setInt32(zip__$DeflateStream_HuffmanTree.scratchAddr + (i << 2),i);
			}
			let jump = 0;
			let _g2 = 0;
			let _g3 = originalN;
			while(_g2 < _g3) {
				let i = _g2++;
				if(zip__$DeflateStream_Memory.memory.getInt32(offset + (i << 2)) == 0) {
					++jump;
				} else {
					let v = zip__$DeflateStream_Memory.memory.getInt32(offset + (i << 2));
					zip__$DeflateStream_Memory.memory.setInt32(offset + (i - jump << 2),v);
					let offset1 = zip__$DeflateStream_HuffmanTree.scratchAddr;
					let v1 = zip__$DeflateStream_Memory.memory.getInt32(zip__$DeflateStream_HuffmanTree.scratchAddr + (i << 2));
					zip__$DeflateStream_Memory.memory.setInt32(offset1 + (i - jump << 2),v1);
				}
			}
			n = originalN - jump;
			end1 = offset + (n << 2);
			let j;
			let currentWeight;
			let currentSymbol;
			let len = end1 - offset;
			let i = 4;
			while(i < len) {
				currentWeight = zip__$DeflateStream_Memory.memory.getInt32(offset + i);
				currentSymbol = zip__$DeflateStream_Memory.memory.getInt32(zip__$DeflateStream_HuffmanTree.scratchAddr + i);
				j = i - 4;
				while(j >= 0 && zip__$DeflateStream_Memory.memory.getInt32(offset + j) > currentWeight) {
					let v = zip__$DeflateStream_Memory.memory.getInt32(offset + j);
					zip__$DeflateStream_Memory.memory.setInt32(offset + j + 4,v);
					let addr = zip__$DeflateStream_HuffmanTree.scratchAddr + j + 4;
					let v1 = zip__$DeflateStream_Memory.memory.getInt32(zip__$DeflateStream_HuffmanTree.scratchAddr + j);
					zip__$DeflateStream_Memory.memory.setInt32(addr,v1);
					j -= 4;
				}
				zip__$DeflateStream_Memory.memory.setInt32(offset + j + 4,currentWeight);
				zip__$DeflateStream_Memory.memory.setInt32(zip__$DeflateStream_HuffmanTree.scratchAddr + j + 4,currentSymbol);
				i += 4;
			}
		}
		let root;
		let leaf;
		let next;
		let avbl;
		let used;
		let dpth;
		if(n != 0) {
			if(n != 1) {
				let v = zip__$DeflateStream_Memory.memory.getInt32(offset) + zip__$DeflateStream_Memory.memory.getInt32(offset + 4);
				zip__$DeflateStream_Memory.memory.setInt32(offset,v);
				root = 0;
				leaf = 2;
				next = 1;
				while(next < n - 1) {
					if(leaf >= n || zip__$DeflateStream_Memory.memory.getInt32(offset + (root << 2)) < zip__$DeflateStream_Memory.memory.getInt32(offset + (leaf << 2))) {
						let v = zip__$DeflateStream_Memory.memory.getInt32(offset + (root << 2));
						zip__$DeflateStream_Memory.memory.setInt32(offset + (next << 2),v);
						zip__$DeflateStream_Memory.memory.setInt32(offset + (root++ << 2),next);
					} else {
						let v = zip__$DeflateStream_Memory.memory.getInt32(offset + (leaf++ << 2));
						zip__$DeflateStream_Memory.memory.setInt32(offset + (next << 2),v);
					}
					if(leaf >= n || root < next && zip__$DeflateStream_Memory.memory.getInt32(offset + (root << 2)) < zip__$DeflateStream_Memory.memory.getInt32(offset + (leaf << 2))) {
						let v = zip__$DeflateStream_Memory.memory.getInt32(offset + (next << 2)) + zip__$DeflateStream_Memory.memory.getInt32(offset + (root << 2));
						zip__$DeflateStream_Memory.memory.setInt32(offset + (next << 2),v);
						zip__$DeflateStream_Memory.memory.setInt32(offset + (root++ << 2),next);
					} else {
						let v = zip__$DeflateStream_Memory.memory.getInt32(offset + (next << 2)) + zip__$DeflateStream_Memory.memory.getInt32(offset + (leaf++ << 2));
						zip__$DeflateStream_Memory.memory.setInt32(offset + (next << 2),v);
					}
					++next;
				}
				zip__$DeflateStream_Memory.memory.setInt32(offset + (n - 2 << 2),0);
				next = n - 3;
				while(next >= 0) {
					let i = zip__$DeflateStream_Memory.memory.getInt32(offset + (next << 2));
					let v = zip__$DeflateStream_Memory.memory.getInt32(offset + (i << 2)) + 1;
					zip__$DeflateStream_Memory.memory.setInt32(offset + (next << 2),v);
					--next;
				}
				avbl = 1;
				dpth = 0;
				used = 0;
				root = n - 2;
				next = n - 1;
				while(avbl > 0) {
					while(root >= 0 && zip__$DeflateStream_Memory.memory.getInt32(offset + (root << 2)) == dpth) {
						++used;
						--root;
					}
					while(avbl > used) {
						zip__$DeflateStream_Memory.memory.setInt32(offset + (next-- << 2),dpth);
						--avbl;
					}
					avbl = 2 * used;
					++dpth;
					used = 0;
				}
			} else {
				zip__$DeflateStream_Memory.memory.setInt32(offset,1);
			}
		}
		let overflow = false;
		let n1 = end1 - offset >>> 2;
		let _g = 0;
		while(_g < n1) {
			let i = _g++;
			if(zip__$DeflateStream_Memory.memory.getInt32(offset + (i << 2)) > maxCodeLength) {
				zip__$DeflateStream_Memory.memory.setInt32(offset + (i << 2),maxCodeLength);
				overflow = true;
			}
		}
		if(overflow) {
			let K = 0.0;
			let _g = 0;
			while(_g < n1) {
				let i = _g++;
				K += Math.pow(2,-zip__$DeflateStream_Memory.memory.getInt32(offset + (i << 2)));
			}
			let i = 0;
			while(K > 1 && i < n1) {
				while(zip__$DeflateStream_Memory.memory.getInt32(offset + (i << 2)) < maxCodeLength && K > 1) {
					let v = zip__$DeflateStream_Memory.memory.getInt32(offset + (i << 2)) + 1;
					zip__$DeflateStream_Memory.memory.setInt32(offset + (i << 2),v);
					K -= Math.pow(2,-zip__$DeflateStream_Memory.memory.getInt32(offset + (i << 2)));
				}
				++i;
			}
			i = n1 - 1;
			while(i >= 0) {
				while(K + Math.pow(2,-zip__$DeflateStream_Memory.memory.getInt32(offset + (i << 2))) <= 1) {
					K += Math.pow(2,-zip__$DeflateStream_Memory.memory.getInt32(offset + (i << 2)));
					let v = zip__$DeflateStream_Memory.memory.getInt32(offset + (i << 2)) - 1;
					zip__$DeflateStream_Memory.memory.setInt32(offset + (i << 2),v);
				}
				--i;
			}
		}
		let _g1 = 0;
		let _g2 = n;
		while(_g1 < _g2) {
			let i = _g1++;
			let offset1 = zip__$DeflateStream_HuffmanTree.scratchAddr;
			let v = zip__$DeflateStream_Memory.memory.getInt32(zip__$DeflateStream_HuffmanTree.scratchAddr + (i << 2)) << 16 | zip__$DeflateStream_Memory.memory.getInt32(offset + (i << 2));
			zip__$DeflateStream_Memory.memory.setInt32(offset1 + (i << 2),v);
		}
		let offset1 = zip__$DeflateStream_HuffmanTree.scratchAddr;
		let j;
		let current;
		let currentCodeLen;
		let currentSymbol;
		let i = 4;
		while(i < end1 - offset) {
			current = zip__$DeflateStream_Memory.memory.getInt32(offset1 + i);
			currentSymbol = current >>> 16;
			currentCodeLen = current & 65535;
			j = i - 4;
			while(true) {
				let tmp;
				if(j >= 0) {
					let codeLenDiff = zip__$DeflateStream_Memory.memory.getUInt16(offset1 + j) - currentCodeLen;
					tmp = codeLenDiff == 0 ? zip__$DeflateStream_Memory.memory.getUInt16(offset1 + j + 2) < currentSymbol : codeLenDiff < 0;
				} else {
					tmp = false;
				}
				if(!tmp) {
					break;
				}
				let v = zip__$DeflateStream_Memory.memory.getInt32(offset1 + j);
				zip__$DeflateStream_Memory.memory.setInt32(offset1 + j + 4,v);
				j -= 4;
			}
			zip__$DeflateStream_Memory.memory.setInt32(offset1 + j + 4,current);
			i += 4;
		}
		if(n != originalN) {
			let _g = 0;
			while(_g < originalN) {
				let i = _g++;
				zip__$DeflateStream_Memory.memory.setInt32(offset + (i << 2),0);
			}
		}
		let symbolCodeOffset = zip__$DeflateStream_HuffmanTree.scratchAddr;
		if(n != 0) {
			let i = n - 1;
			let code = 0;
			let curLen = zip__$DeflateStream_Memory.memory.getUInt16(symbolCodeOffset + i * 4);
			let s;
			let newLen;
			while(i >= 0) {
				s = zip__$DeflateStream_Memory.memory.getInt32(symbolCodeOffset + i * 4);
				newLen = s & 65535;
				code <<= newLen - curLen;
				let v = code;
				v = v >>> 1 & 1431655765 | (v & 1431655765) << 1;
				v = v >>> 2 & 858993459 | (v & 858993459) << 2;
				v = v >>> 4 & 252645135 | (v & 252645135) << 4;
				v = v >>> 8 & 16711935 | (v & 16711935) << 8;
				zip__$DeflateStream_Memory.memory.setInt32(offset + (s >>> 16) * 4,(v & 65535) >>> 16 - newLen << 16 | newLen);
				++code;
				curLen = newLen;
				if(code >= 1 << newLen) {
					curLen = newLen + 1;
				}
				--i;
			}
		}
	}
}
$hxClasses["zip._DeflateStream.HuffmanTree"] = zip__$DeflateStream_HuffmanTree;
zip__$DeflateStream_HuffmanTree.__name__ = "zip._DeflateStream.HuffmanTree";
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	Object.defineProperty(String.prototype,"__class__",{ value : $hxClasses["String"] = String, enumerable : false, writable : true});
	String.__name__ = "String";
	$hxClasses["Array"] = Array;
	Array.__name__ = "Array";
	Date.prototype.__class__ = $hxClasses["Date"] = Date;
	Date.__name__ = "Date";
	var Int = { };
	var Dynamic = { };
	var Float = Number;
	var Bool = Boolean;
	var Class = { };
	var Enum = { };
}
haxe_MainLoop.add(hxd_System.updateCursor,-1);
{
	var hx__registerFont;
	hx__registerFont = function(name,data) {
		let s = window.document.createElement("style");
		s.type = "text/css";
		s.innerHTML = "@font-face{ font-family: " + name + "; src: url('data:font/ttf;base64," + data + "') format('truetype'); }";
		window.document.getElementsByTagName("head")[0].appendChild(s);
		let div = window.document.createElement("div");
		div.style.fontFamily = name;
		div.style.opacity = 0;
		div.style.width = "1px";
		div.style.height = "1px";
		div.style.position = "fixed";
		div.style.bottom = "0px";
		div.style.right = "0px";
		div.innerHTML = ".";
		div.className = "hx__loadFont";
		window.document.body.appendChild(div);
	};
}
js_Boot.__toStr = ({ }).toString;
MPCustoms.missionList = [];
MPCustoms._requestSent = false;
hxd_App._hx_skip_constructor = false;
RandomLCG.msSeed = 1376312589;
RandomLCG.quotient = 127773;
RandomLCG.remainder = 2836;
Xml.Element = 0;
Xml.PCData = 1;
Xml.CData = 2;
Xml.Comment = 3;
Xml.DocType = 4;
Xml.ProcessingInstruction = 5;
Xml.Document = 6;
collision_CollisionPool.pool = [];
collision_CollisionPool.currentPtr = 0;
collision_Grid.CELL_SIZE = 16;
dts_ShapeFlags.Blend = 4;
dts_ShapeFlags.Cyclic = 8;
dts_ShapeFlags.MakePath = 16;
dts_TSDrawPrimitive.Triangles = 0;
dts_TSDrawPrimitive.Strip = 1073741824;
dts_TSDrawPrimitive.Fan = -2147483648;
dts_TSDrawPrimitive.MaterialMask = 268435455;
dts_TSDrawPrimitive.TypeMask = -1073741824;
format_mp3_MPEG.Reserved = 1;
format_mp3_MPEG.V1_Bitrates = [[format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_288,format_mp3_Bitrate.BR_320,format_mp3_Bitrate.BR_352,format_mp3_Bitrate.BR_384,format_mp3_Bitrate.BR_416,format_mp3_Bitrate.BR_448,format_mp3_Bitrate.BR_Bad]];
format_mp3_MPEG.V2_Bitrates = [[format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_8,format_mp3_Bitrate.BR_16,format_mp3_Bitrate.BR_24,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_40,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_Bad],[format_mp3_Bitrate.BR_Free,format_mp3_Bitrate.BR_32,format_mp3_Bitrate.BR_48,format_mp3_Bitrate.BR_56,format_mp3_Bitrate.BR_64,format_mp3_Bitrate.BR_80,format_mp3_Bitrate.BR_96,format_mp3_Bitrate.BR_112,format_mp3_Bitrate.BR_128,format_mp3_Bitrate.BR_144,format_mp3_Bitrate.BR_160,format_mp3_Bitrate.BR_176,format_mp3_Bitrate.BR_192,format_mp3_Bitrate.BR_224,format_mp3_Bitrate.BR_256,format_mp3_Bitrate.BR_Bad]];
format_mp3_MPEG.SamplingRates = [[format_mp3_SamplingRate.SR_11025,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_8000,format_mp3_SamplingRate.SR_Bad],[format_mp3_SamplingRate.SR_Bad,format_mp3_SamplingRate.SR_Bad,format_mp3_SamplingRate.SR_Bad,format_mp3_SamplingRate.SR_Bad],[format_mp3_SamplingRate.SR_22050,format_mp3_SamplingRate.SR_24000,format_mp3_SamplingRate.SR_12000,format_mp3_SamplingRate.SR_Bad],[format_mp3_SamplingRate.SR_44100,format_mp3_SamplingRate.SR_48000,format_mp3_SamplingRate.SR_32000,format_mp3_SamplingRate.SR_Bad]];
format_mp3_CLayer.LReserved = 0;
h2d_Object._hx_skip_constructor = false;
h2d_Object.tmpPoint = new h2d_col_Point();
gui_GuiControl._hx_skip_constructor = false;
gui_AchievementsGui.mpAchs = 0;
h3d_prim_Primitive._hx_skip_constructor = false;
gui_HtmlText.REG_SPACES = new EReg("[\r\n\t ]+","g");
gui_LevelSelectGui.currentSelectionStatic = 0;
gui_LevelSelectGui.currentDifficultyStatic = "beginner";
gui_MarblePickerGui.marbleData = [{ name : "1", dts : "data/shapes/balls/marble01.dts", skin : "base", shader : "ClassicGlassPureSphere"},{ name : "2", dts : "data/shapes/balls/marble03.dts", skin : "base", shader : "ClassicGlassPureSphere"},{ name : "3", dts : "data/shapes/balls/marble04.dts", skin : "base", shader : "ClassicGlassPureSphere"},{ name : "4", dts : "data/shapes/balls/marble05.dts", skin : "base", shader : "ClassicGlassPureSphere"},{ name : "5", dts : "data/shapes/balls/marble06.dts", skin : "base", shader : "ClassicGlassPureSphere"},{ name : "6", dts : "data/shapes/balls/marble07.dts", skin : "base", shader : "ClassicGlassPureSphere"},{ name : "7", dts : "data/shapes/balls/marble12.dts", skin : "base", shader : "ClassicGlassPureSphere"},{ name : "8", dts : "data/shapes/balls/marble15.dts", skin : "base", shader : "ClassicGlassPureSphere"},{ name : "9", dts : "data/shapes/balls/marble02.dts", skin : "base", shader : "CrystalMarb"},{ name : "10", dts : "data/shapes/balls/marble26.dts", skin : "base", shader : "CrystalMarb"},{ name : "11", dts : "data/shapes/balls/marble27.dts", skin : "base", shader : "CrystalMarb"},{ name : "12", dts : "data/shapes/balls/marble28.dts", skin : "base", shader : "CrystalMarb"},{ name : "13", dts : "data/shapes/balls/marble29.dts", skin : "base", shader : "CrystalMarb"},{ name : "14", dts : "data/shapes/balls/marble30.dts", skin : "base", shader : "CrystalMarb"},{ name : "15", dts : "data/shapes/balls/marble11.dts", skin : "base", shader : "ClassicMetal"},{ name : "16", dts : "data/shapes/balls/marble18.dts", skin : "base", shader : "ClassicMarbGlass18"},{ name : "17", dts : "data/shapes/balls/marble20.dts", skin : "base", shader : "ClassicMarbGlass20"},{ name : "18", dts : "data/shapes/balls/marble33.dts", skin : "base", shader : "ClassicMetal"},{ name : "19", dts : "data/shapes/balls/marble34.dts", skin : "base", shader : "ClassicMarb2"},{ name : "20", dts : "data/shapes/balls/marble09.dts", skin : "base", shader : "ClassicMarb3"},{ name : "21", dts : "data/shapes/balls/marble13.dts", skin : "base", shader : "ClassicMarb3"},{ name : "22", dts : "data/shapes/balls/marble14.dts", skin : "base", shader : "ClassicMarb3"},{ name : "23", dts : "data/shapes/balls/marble17.dts", skin : "base", shader : "ClassicMarb3"},{ name : "24", dts : "data/shapes/balls/marble19.dts", skin : "base", shader : "ClassicMarb3"},{ name : "25", dts : "data/shapes/balls/marble21.dts", skin : "base", shader : "ClassicMarb3"},{ name : "26", dts : "data/shapes/balls/marble22.dts", skin : "base", shader : "ClassicMarb3"},{ name : "27", dts : "data/shapes/balls/marble23.dts", skin : "base", shader : "ClassicMarb3"},{ name : "28", dts : "data/shapes/balls/marble24.dts", skin : "base", shader : "ClassicMarb3"},{ name : "29", dts : "data/shapes/balls/marble25.dts", skin : "base", shader : "ClassicMarb3"},{ name : "30", dts : "data/shapes/balls/marble31.dts", skin : "base", shader : "ClassicMarb3"},{ name : "31", dts : "data/shapes/balls/marble32.dts", skin : "base", shader : "ClassicMarb3"},{ name : "32", dts : "data/shapes/balls/marble08.dts", skin : "base", shader : "ClassicMarb"},{ name : "33", dts : "data/shapes/balls/marble10.dts", skin : "base", shader : "ClassicMarb2"},{ name : "34", dts : "data/shapes/balls/marble16.dts", skin : "base", shader : "ClassicMarb3"},{ name : "35", dts : "data/shapes/balls/marble35.dts", skin : "base", shader : "ClassicMarb3"}];
gui_MultiplayerLevelSelectGui.currentSelectionStatic = 0;
gui_MultiplayerLevelSelectGui.custSelected = false;
h2d_HtmlText.REG_SPACES = new EReg("[\r\n\t ]+","g");
h3d_impl_RenderContext._hx_skip_constructor = false;
h2d_TextInput.modifierKey = 17;
h2d_filter_Filter._hx_skip_constructor = false;
h2d_filter_Filter.defaultUseScreenResolution = false;
hxsl_Shader._hx_skip_constructor = false;
h3d_shader_ScreenShader.SRC = "HXSLF2gzZC5zaGFkZXIuU2NyZWVuU2hhZGVyBwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACghfX2luaXRfXw4GAAALBnZlcnRleA4GAAACAgoAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAALAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAA";
h2d_filter__$Mask_MaskShader.SRC = "HXSLG2gyZC5maWx0ZXIuX01hc2suTWFza1NoYWRlcg0BBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQoCAAALBG1hc2sKAgAADAhtYXNrTWF0QQULAgAADQhtYXNrTWF0QgULAgAADgtzbW9vdGhBbHBoYQICAAEAAAAAAA8IX19pbml0X18OBgAAEAZ2ZXJ0ZXgOBgAAEQhmcmFnbWVudA4GAAADAg8AAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAQAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAERAAAFBQgSBWNvbG9yBQwEAAAJAyEOAgIKCgIDBQoFDAAIEwJ1dgULBAAACQMpDgICAwUKAQMAAAAAAADwPwMFCwAIFAFrBQwEAAAJAyEOAgILCgkDKA4CCQMdDgICEwULAgwFCwMJAx0OAgITBQsCDQULAwUKBQwACBUFYWxwaGEDBAAACwIOAgoCFAUMDAADCQMmDgEGBwoCFAUMDAADAQMAAAAAAAAAAAMCAwMABgQCBwUMBgECEgUMAhUDBQwFDAA";
h3d_Buffer.GUID = 0;
h3d_Engine.SOFTWARE_DRIVER = false;
h3d_Engine.ANTIALIASING = 0;
h3d_Matrix.tmp = new h3d_Matrix();
h3d_scene_Object._hx_skip_constructor = false;
h3d_scene_Object.tmpMat = new h3d_Matrix();
h3d_impl_InputNames.UID = 0;
h3d_impl_InputNames.CACHE = new haxe_ds_StringMap();
h3d_impl_GlDriver.ALLOW_WEBGL2 = true;
h3d_impl_GlDriver.BLACK = new h3d_Vector(0,0,0,0);
h3d_impl_GlDriver.outOfMemoryCheck = false;
h3d_impl_GlDriver.TFILTERS = [[[9728,9728],[9729,9729]],[[9728,9984],[9729,9985]],[[9728,9986],[9729,9987]]];
h3d_impl_GlDriver.TWRAP = [33071,10497];
h3d_impl_GlDriver.FACES = [0,1028,1029,1032];
h3d_impl_GlDriver.BLEND = [1,0,770,768,772,774,771,769,773,775,32769,32771,32770,32772,776];
h3d_impl_GlDriver.COMPARE = [519,512,514,517,516,518,513,515];
h3d_impl_GlDriver.STENCIL_OP = [7680,0,7681,7682,34055,7683,34056,5386];
h3d_impl_GlDriver.OP = [32774,32778,32779,32775,32776];
h3d_impl_GlDriver.CUBE_FACES = [34069,34070,34071,34072,34073,34074];
h3d_impl_GlDriver.CBUFFERS = (function($this) {
	var $r;
	let _g = [];
	{
		let _g1 = 0;
		while(_g1 < 32) {
			let i = _g1++;
			let _g2 = [];
			let _g3 = 0;
			while(_g3 < i) {
				let k = _g3++;
				_g2.push(36064 + k);
			}
			_g.push(_g2);
		}
	}
	$r = _g;
	return $r;
}(this));
h3d_impl_MemoryManager.ALL_FLAGS = h3d_BufferFlag.__empty_constructs__.slice();
h3d_mat_BaseMaterial._hx_skip_constructor = false;
h3d_mat_Defaults.defaultKillAlphaThreshold = 0.5;
h3d_mat_Defaults.loadingTextureColor = -65281;
h3d_mat_MaterialSetup.current = new h3d_mat_MaterialSetup("Default");
h3d_mat_Texture._hx_skip_constructor = false;
h3d_mat_Texture.UID = 0;
h3d_mat_Texture.PREVENT_AUTO_DISPOSE = 2147483647;
h3d_mat_Texture.nativeFormat = hxd_PixelFormat.RGBA;
h3d_mat_Texture.TRILINEAR_FILTERING_ENABLED = true;
h3d_mat_Texture.DEFAULT_WRAP = h3d_mat_Wrap.Clamp;
h3d_pass_Base._hx_skip_constructor = false;
h3d_pass_ScreenFx._hx_skip_constructor = false;
h3d_pass_Blur.__meta__ = { obj : { ignore : ["shader"]}};
h3d_pass__$Border_BorderShader.SRC = "HXSLHWgzZC5wYXNzLl9Cb3JkZXIuQm9yZGVyU2hhZGVyCQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgVjb2xvcgUMAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMAgoFDAUMAA";
h3d_pass_ColorMatrixShader.SRC = "HXSLGmgzZC5wYXNzLkNvbG9yTWF0cml4U2hhZGVyFQEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgd0ZXh0dXJlCgIAAAsGbWF0cml4BwIAAAwIdXNlQWxwaGECAgABAAAAAAANB3VzZU1hc2sCAgABAAAAAAAOCm1hc2tJbnZlcnQCAgABAAAAAAAPD2hhc1NlY29uZE1hdHJpeAICAAEAAAAAABAHbWF0cml4MgcCAAARBG1hc2sKAgAAEghtYXNrTWF0QQULAgAAEwhtYXNrTWF0QgULAgAAFAltYXNrUG93ZXIDAgAAFQttYXNrQ2hhbm5lbAUMAgAAFghfX2luaXRfXw4GAAAXBnZlcnRleA4GAAAYBWFwcGx5DgYAABkIZnJhZ21lbnQOBgAABAIWAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAAFwAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAADGAIaBWNvbG9yBQwEAAAbA21hdAcEAAAFDAUBDQsCDAIGAQIaBQwCGwcFDAYBCQMqDgIKAhoFDJIABQsBAwAAAAAAAPA/AwUMAhsHBQwFDAAAARkAAAUBCwINAgUFCBwFY29sb3IFDAQAAAkDIQ4CAgoKAgMFCgUMAAgdAnV2BQsEAAAJAykOAgIDBQoBAwAAAAAAAPA/AwULAAgeAWsDBAAACQMIDgIJAx0OAgkDIQ4CAhEKCQMoDgIJAx0OAgIdBQsCEgULAwkDHQ4CAh0FCwITBQsDBQoFDAIVBQwDAhQDAwAIHwZjb2xvcjIFDAQAAAsCDwIJAhgOAgIcBQwCEAcFDAIcBQwFDAAGBAIHBQwLAg4CCQMYDgMCHwUMCQIYDgICHAUMAgsHBQwCHgMFDAkDGA4DCQIYDgICHAUMAgsHBQwCHwUMAh4DBQwFDAUMAAYEAgcFDAkCGA4CCQMhDgICCgoCAwUKBQwCCwcFDAUMAAA";
h3d_pass__$Copy_ArrayCopyShader.SRC = "HXSLHmgzZC5wYXNzLl9Db3B5LkFycmF5Q29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQsCAAALBWxheWVyAQIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFAQYEAggFDAkDIQ4CAgoLCQMpDgICCQUKCQMmDgECCwEDBQsFDAUMAA";
h3d_pass__$Copy_CopyShader.SRC = "HXSLGWgzZC5wYXNzLl9Db3B5LkNvcHlTaGFkZXIJAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKB3RleHR1cmUKAgAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANCGZyYWdtZW50DgYAAAMCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ0AAAUBBgQCCAUMCQMhDgICCgoCCQUKBQwFDAA";
h3d_pass__$CubeCopy_CubeCopyShader.SRC = "HXSLIWgzZC5wYXNzLl9DdWJlQ29weS5DdWJlQ29weVNoYWRlcgoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQwCAAALA21hdAYCAAAMCF9faW5pdF9fDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwIMAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADQAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDgAABQIIDwJ1dgUKBAAABgMGAQIJBQoBAwAAAAAAAABAAwUKAQMAAAAAAADwPwMFCgAGBAIIBQwJAyEOAgIKDAkDHw4BBgEJAykOAgIPBQoBAwAAAAAAAPA/AwULAgsGBQsFCwUMBQwA";
h3d_pass__$HardwarePick_FixedColor.SRC = "HXSLIWgzZC5wYXNzLl9IYXJkd2FyZVBpY2suRml4ZWRDb2xvcgUBB2NvbG9ySUQFDAIAAAIIdmlld3BvcnQFDAIAAAMGb3V0cHV0DQECBAhwb3NpdGlvbgUMBAMABQdjb2xvcklEBQwEAwAEAAAGBnZlcnRleA4GAAAHCGZyYWdtZW50DgYAAAIABgAABQEGBAIEBQwGAQQGAAIEBQwGAQkDKg4DCgICBQwRAAUKAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMCgIEBQwMAAMFDAUMBQwJAyoOAwoCAgUMOQAFCgEDAAAAAAAA8D8DAQMAAAAAAADwPwMFDAUMBQwAAQcAAAUBBgQCBQUMAgEFDAUMAA";
h3d_pass_ShaderManager.STRICT = true;
h3d_scene_Mesh.tmpMat = new h3d_Matrix();
h3d_scene_LightSystem._hx_skip_constructor = false;
h3d_scene_Renderer._hx_skip_constructor = false;
h3d_scene_pbr_IrradBase.SRC = "HXSLF2gzZC5zY2VuZS5wYnIuSXJyYWRCYXNlCwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgtzYW1wbGVzQml0cwECAAEAAAAAAAsIX19pbml0X18OBgAADAZ2ZXJ0ZXgOBgAADQxfcmV2ZXJzZWJpdHMOBgAADgpoYW1tZXJzbGV5DgYAAA8TaW1wb3J0YW5jZVNhbXBsZUdHWA4GAAAFAgsAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAMAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAMNARABaQEEAAABBQYIEQFyAQQAAAYMBAYQAhABAQIQAAAAAQEBBAYSAhABAQIQAAAAAQEBAQAGBAIRAQYMBAYQBAYLAhEBAQL/AP8AAQEBAQIIAAAAAQEBBAYSBAYLAhEBAQIA/wD/AQEBAQIIAAAAAQEBAQEGBAIRAQYMBAYQBAYLAhEBAQIPDw8PAQEBAQIEAAAAAQEBBAYSBAYLAhEBAQLw8PDwAQEBAQIEAAAAAQEBAQEGBAIRAQYMBAYQBAYLAhEBAQIzMzMzAQEBAQICAAAAAQEBBAYSBAYLAhEBAQLMzMzMAQEBAQICAAAAAQEBAQEGBAIRAQYMBAYQBAYLAhEBAQJVVVVVAQEBAQIBAAAAAQEBBAYSBAYLAhEBAQKqqqqqAQEBAQIBAAAAAQEBAQENAhEBAAADDgISAWkBBAAAEwNtYXgBBAAABQoFAggUAnJpAwQAAAYBCQMmDgEJAg0OAQISAQEDAQMAAAAAAADwPQMDAA0JAygOAgYCCQMmDgECEgEDCQMmDgECEwEDAwIUAwUKAAADDwMVCXJvdWdobmVzcwMEAAAWAXAFCgQAABcBbgULBAAABQsFCQgYAWEDBAAABgECFQMCFQMDAAgZA3BoaQMEAAAGAQYBAQMAAAAAAAAAQAMBAxgtRFT7IQlAAwMKAhYFCgAAAwMACBoEY29zVAMEAAAJAxUOAgkDDQ4BBgIEBgMBAwAAAAAAAPA/AwoCFgUKBAADAwMEBgABAwAAAAAAAPA/AwYBBAYDBgECGAMCGAMDAQMAAAAAAADwPwMDAwoCFgUKBAADAwMDAwMBAwAAAAAAAPA/AwMACBsEc2luVAMEAAAJAw0OAQYDAQMAAAAAAADwPwMGAQIaAwIaAwMDAwAIHARsdGFuBQsEAAAJAykOAwYBAhsDCQMDDgECGQMDAwYBAhsDCQMCDgECGQMDAwIaAwULAAgdAnVwBQsEAAALBgkJAw8OAQoCFwULCAADAwEDK4cW2c737z8DAgkDKQ4DAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQsJAykOAwEDAAAAAAAA8D8DAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwULBQsACB4EdGFuWAULBAAACQMfDgEJAx4OAgIdBQsCFwULBQsFCwAIHwR0YW5ZBQsEAAAJAx8OAQkDHg4CAhcFCwIeBQsFCwULAA0JAx8OAQQGAAYABgECHgULCgIcBQsAAAMFCwYBAh8FCwoCHAULBAADBQsFCwYBAhcFCwoCHAULCAADBQsFCwULBQsAAA";
h3d_scene_pbr_IrradShader.SRC = "HXSLGWgzZC5zY2VuZS5wYnIuSXJyYWRTaGFkZXIXAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKC3NhbXBsZXNCaXRzAQIAAQAAAAAACwpmYWNlTWF0cml4BgIAAAwGZW52TWFwDAIAAA0KaXNTcGVjdWxhcgICAAEAAAAAAA4GaXNTUkdCAgIAAQAAAAAADwlyb3VnaG5lc3MDAgAAEAhjdWJlU2l6ZQMCAAARD2N1YmVTY2FsZUZhY3RvcgMCAAASBmhkck1heAMCAAATCF9faW5pdF9fDgYAABQGdmVydGV4DgYAABUMX3JldmVyc2ViaXRzDgYAABYKaGFtbWVyc2xleQ4GAAAXE2ltcG9ydGFuY2VTYW1wbGVHR1gOBgAAGBZjb3NpbmVXZWlnaHRlZFNhbXBsaW5nDgYAABkJZ2V0Tm9ybWFsDgYAABoMZ2FtbWFDb3JyZWN0DgYAABsIZnJhZ21lbnQOBgAACQITAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAAFAAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAADFQEcAWkBBAAAAQUGCB0BcgEEAAAGDAQGEAIcAQECEAAAAAEBAQQGEgIcAQECEAAAAAEBAQEABgQCHQEGDAQGEAQGCwIdAQEC/wD/AAEBAQECCAAAAAEBAQQGEgQGCwIdAQECAP8A/wEBAQECCAAAAAEBAQEBBgQCHQEGDAQGEAQGCwIdAQECDw8PDwEBAQECBAAAAAEBAQQGEgQGCwIdAQEC8PDw8AEBAQECBAAAAAEBAQEBBgQCHQEGDAQGEAQGCwIdAQECMzMzMwEBAQECAgAAAAEBAQQGEgQGCwIdAQECzMzMzAEBAQECAgAAAAEBAQEBBgQCHQEGDAQGEAQGCwIdAQECVVVVVQEBAQECAQAAAAEBAQQGEgQGCwIdAQECqqqqqgEBAQECAQAAAAEBAQEBDQIdAQAAAxYCHgFpAQQAAB8DbWF4AQQAAAUKBQIIIAJyaQMEAAAGAQkDJg4BCQIVDgECHgEBAwEDAAAAAAAA8D0DAwANCQMoDgIGAgkDJg4BAh4BAwkDJg4BAh8BAwMCIAMFCgAAAxcDIQlyb3VnaG5lc3MDBAAAIgFwBQoEAAAjAW4FCwQAAAULBQkIJAFhAwQAAAYBAiEDAiEDAwAIJQNwaGkDBAAABgEGAQEDAAAAAAAAAEADAQMYLURU+yEJQAMDCgIiBQoAAAMDAAgmBGNvc1QDBAAACQMVDgIJAw0OAQYCBAYDAQMAAAAAAADwPwMKAiIFCgQAAwMDBAYAAQMAAAAAAADwPwMGAQQGAwYBAiQDAiQDAwEDAAAAAAAA8D8DAwMKAiIFCgQAAwMDAwMDAQMAAAAAAADwPwMDAAgnBHNpblQDBAAACQMNDgEGAwEDAAAAAAAA8D8DBgECJgMCJgMDAwMACCgEbHRhbgULBAAACQMpDgMGAQInAwkDAw4BAiUDAwMGAQInAwkDAg4BAiUDAwMCJgMFCwAIKQJ1cAULBAAACwYJCQMPDgEKAiMFCwgAAwMBAyuHFtnO9+8/AwIJAykOAwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwULCQMpDgMBAwAAAAAAAPA/AwEDAAAAAAAAAAADAQMAAAAAAAAAAAMFCwULAAgqBHRhblgFCwQAAAkDHw4BCQMeDgICKQULAiMFCwULBQsACCsEdGFuWQULBAAACQMfDgEJAx4OAgIjBQsCKgULBQsFCwANCQMfDgEEBgAGAAYBAioFCwoCKAULAAADBQsGAQIrBQsKAigFCwQAAwULBQsGAQIjBQsKAigFCwgAAwULBQsFCwULAAADGAIsAXAFCgQAAC0BbgULBAAABQsFBwguAnNxAwQAAAkDDQ4BBgMBAwAAAAAAAPA/AwoCLAUKAAADAwMACC8FYWxwaGEDBAAABgEGAQEDAAAAAAAAAEADAQMYLURU+yEJQAMDCgIsBQoEAAMDAAgwBGx0YW4FCwQAAAkDKQ4DBgECLgMJAwMOAQIvAwMDBgECLgMJAwIOAQIvAwMDCQMNDgEKAiwFCgAAAwMFCwAIMQJ1cAULBAAACwYJCQMPDgEKAi0FCwgAAwMBAyuHFtnO9+8/AwIJAykOAwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwULCQMpDgMBAwAAAAAAAPA/AwEDAAAAAAAAAAADAQMAAAAAAAAAAAMFCwULAAgyBHRhblgFCwQAAAkDHw4BCQMeDgICMQULAi0FCwULBQsACDMEdGFuWQULBAAACQMfDgEJAx4OAgItBQsCMgULBQsFCwANCQMfDgEEBgAGAAYBAjIFCwoCMAULAAADBQsGAQIzBQsKAjAFCwQAAwULBQsGAQItBQsKAjAFCwgAAwULBQsFCwULAAADGQAFCwUDCDQBZAUKBAAABgMGAQIDBQoBAwAAAAAAAABAAwUKAQMAAAAAAADwPwMFCgALAg0CBQEGgAI0BQoGAQIRAwQGAQYBAjQFCgI0BQoFCgI0BQoFCgUKBQoFCgAAAA0JAx8OAQQGAQkDKQ4CAjQFCgEDAAAAAAAA8D8DBQsCCwYFCwULBQsAAAMaATUFY29sb3IFCwQAAAULBQENCwIOAgI1BQsJAwgOAgI1BQsJAykOAQEDmpmZmZmZAUADBQsFCwULAAABGwAABQYINgVjb2xvcgULBAAACQMpDgEBAwAAAAAAAAAAAwULAAg3AW4FCwQAAAkCGQ4ABQsACDgLdG90YWxXZWlnaHQDBAAAAQO7vdfZ33zbPQMACDkKbnVtU2FtcGxlcwEEAAAGEAECAQAAAAECCgEBAA46AWkBBAAABhUBAgAAAAABAjkBDwEAAAUFCDsBcAUKBAAACQIWDgICOgECOQEFCgAIPAFsBQsEAAAAAAsCDQIFAwg9AWgFCwQAAAkCFw4DAg8DAjsFCgI3BQsFCwAIPgF2BQsEAAACNwULAAYEAjwFCwkDHw4BCQMgDgIHAwI+BQsFCwI9BQsFCwULBQsABQEGBAI8BQsJAhgOAgI7BQoCNwULBQsFCwAACD8GYW1vdW50AwQAAAkDNQ4BCQMdDgICNwULAjwFCwMDAAsGBwI/AwEDAAAAAAAAAAADAgUDCEAIZW52Q29sb3IFCwQAAAkCGg4BCQMVDgIKCQMhDgICDAwCPAULBQySAAULAhIDBQsFCwAGgAI2BQsGAQJABQsCPwMFCwULBoACOAMCPwMDAAAAAAAGBAIHBQwJAyoOAgYCAjYFCwI4AwULAQMAAAAAAADwPwMFDAUMAA";
h3d_scene_pbr_IrradLut.SRC = "HXSLFmgzZC5zY2VuZS5wYnIuSXJyYWRMdXQOAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKC3NhbXBsZXNCaXRzAQIAAQAAAAAACwhfX2luaXRfXw4GAAAMBnZlcnRleA4GAAANDF9yZXZlcnNlYml0cw4GAAAOCmhhbW1lcnNsZXkOBgAADxNpbXBvcnRhbmNlU2FtcGxlR0dYDgYAABADR0dYDgYAABEHR19TbWl0aA4GAAASCGZyYWdtZW50DgYAAAgCCwAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAAwAAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAw0BEwFpAQQAAAEFBggUAXIBBAAABgwEBhACEwEBAhAAAAABAQEEBhICEwEBAhAAAAABAQEBAAYEAhQBBgwEBhAEBgsCFAEBAv8A/wABAQEBAggAAAABAQEEBhIEBgsCFAEBAgD/AP8BAQEBAggAAAABAQEBAQYEAhQBBgwEBhAEBgsCFAEBAg8PDw8BAQEBAgQAAAABAQEEBhIEBgsCFAEBAvDw8PABAQEBAgQAAAABAQEBAQYEAhQBBgwEBhAEBgsCFAEBAjMzMzMBAQEBAgIAAAABAQEEBhIEBgsCFAEBAszMzMwBAQEBAgIAAAABAQEBAQYEAhQBBgwEBhAEBgsCFAEBAlVVVVUBAQEBAgEAAAABAQEEBhIEBgsCFAEBAqqqqqoBAQEBAgEAAAABAQEBAQ0CFAEAAAMOAhUBaQEEAAAWA21heAEEAAAFCgUCCBcCcmkDBAAABgEJAyYOAQkCDQ4BAhUBAQMBAwAAAAAAAPA9AwMADQkDKA4CBgIJAyYOAQIVAQMJAyYOAQIWAQMDAhcDBQoAAAMPAxgJcm91Z2huZXNzAwQAABkBcAUKBAAAGgFuBQsEAAAFCwUJCBsBYQMEAAAGAQIYAwIYAwMACBwDcGhpAwQAAAYBBgEBAwAAAAAAAABAAwEDGC1EVPshCUADAwoCGQUKAAADAwAIHQRjb3NUAwQAAAkDFQ4CCQMNDgEGAgQGAwEDAAAAAAAA8D8DCgIZBQoEAAMDAwQGAAEDAAAAAAAA8D8DBgEEBgMGAQIbAwIbAwMBAwAAAAAAAPA/AwMDCgIZBQoEAAMDAwMDAwEDAAAAAAAA8D8DAwAIHgRzaW5UAwQAAAkDDQ4BBgMBAwAAAAAAAPA/AwYBAh0DAh0DAwMDAAgfBGx0YW4FCwQAAAkDKQ4DBgECHgMJAwMOAQIcAwMDBgECHgMJAwIOAQIcAwMDAh0DBQsACCACdXAFCwQAAAsGCQkDDw4BCgIaBQsIAAMDAQMrhxbZzvfvPwMCCQMpDgMBAwAAAAAAAAAAAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFCwkDKQ4DAQMAAAAAAADwPwMBAwAAAAAAAAAAAwEDAAAAAAAAAAADBQsFCwAIIQR0YW5YBQsEAAAJAx8OAQkDHg4CAiAFCwIaBQsFCwULAAgiBHRhblkFCwQAAAkDHw4BCQMeDgICGgULAiEFCwULBQsADQkDHw4BBAYABgAGAQIhBQsKAh8FCwAAAwULBgECIgULCgIfBQsEAAMFCwULBgECGgULCgIfBQsIAAMFCwULBQsFCwAAAxACIwVOZG90VgMEAAAkCXJvdWdobmVzcwMEAAADBQIIJQFrAwQAAAYBBAYBAiQDAiQDAwMBAwAAAAAAAOA/AwMADQYCAiMDBAYABgECIwMEBgMBAwAAAAAAAPA/AwIlAwMDAwIlAwMDAwAAAxEDJglyb3VnaG5lc3MDBAAAJwVuRG90VgMEAAAoBW5Eb3RMAwQAAAMFAQ0GAQkCEA4CAigDAiYDAwkCEA4CAicDAiYDAwMAAAESAAAFCQgpCXJvdWdobmVzcwMEAAAKAgMFCgAAAwAIKgNOb1YDBAAACgIDBQoEAAMACCsBdgULBAAACQMpDgMJAw0OAQYDAQMAAAAAAADwPwMGAQIqAwIqAwMDAwEDAAAAAAAAAAADAioDBQsACCwBbgULBAAACQMpDgMBAwAAAAAAAAAAAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFCwAILQpudW1TYW1wbGVzAQQAAAYQAQIBAAAAAQIKAQEACC4BYQMEAAABAwAAAAAAAAAAAwAILwFiAwQAAAEDAAAAAAAAAAADAA4wAWkBBAAABhUBAgAAAAABAi0BDwEAAAUHCDECeGkFCgQAAAkCDg4CAjABAi0BBQoACDIBaAULBAAACQIPDgMCKQMCMQUKAiwFCwULAAgzAWwFCwQAAAkDIA4CBwMCKwULBQsCMgULBQsACDQDTm9MAwQAAAkDNQ4BCQMdDgICLAULAjMFCwMDAAg1A05vSAMEAAAJAzUOAQkDHQ4CAiwFCwIyBQsDAwAINgNWb0gDBAAACQM1DgEJAx0OAgIrBQsCMgULAwMACwYHAjQDAQMAAAAAAAAAAAMCBQUINwFnAwQAAAkCEQ4DAikDAioDAjQDAwAIOARndmlzAwQAAAYCBgECNwMCNgMDBAYBAjUDAioDAwMDAAg5B2ZyZXNuZWwDBAAACQMIDgIGAwEDAAAAAAAA8D8DAjYDAwEDAAAAAAAAFEADAwAGgAIuAwYBBAYDAQMAAAAAAADwPwMCOQMDAwI4AwMDBoACLwMGAQI5AwI4AwMDAAAAAAAGBAIHBQwJAyoOBAYCAi4DCQMmDgECLQEDAwYCAi8DCQMmDgECLQEDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAA";
h3d_scene_pbr_PanoramaToCube.SRC = "HXSLHGgzZC5zY2VuZS5wYnIuUGFub3JhbWFUb0N1YmUNAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKB3RleHR1cmUKAgAACwpmYWNlTWF0cml4BgIAAAwJdGhyZXNob2xkAwIAAA0TYWJvdmVUaHJlc2hvbGRTY2FsZQMCAAAOCF9faW5pdF9fDgYAAA8GdmVydGV4DgYAABAJZ2V0Tm9ybWFsDgYAABEIZnJhZ21lbnQOBgAABAIOAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADwAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAADEAAFCwUCCBIBZAUKBAAABgMGAQIDBQoBAwAAAAAAAABAAwUKAQMAAAAAAADwPwMFCgANCQMfDgEEBgEJAykOAgISBQoBAwAAAAAAAPA/AwULAgsGBQsFCwULAAABEQAABQYIEwFuBQsEAAAJAhAOAAULAAgUAnV2BQoEAAAJAygOAgkDBw4CCgITBQsEAAMKAhMFCwAAAwMJAwUOAQcDCgITBQsIAAMDAwUKAAaBAhQFCgkDKA4CAQOvlGWIY13EPwMBA3RGlPYGX9Q/AwUKBQoGgAIUBQoBAwAAAAAAAOA/AwUKBgQCCAUMCQMhDgICCgoCFAUKBQwFDAsGBwkDFg4CCQMWDgIKAggFDAAAAwoCCAUMBAADAwoCCAUMCAADAwIMAwIGgQIIBQwCDQMFDAAAAA";
h3d_scene_pbr_CubeToPanorama.SRC = "HXSLHGgzZC5zY2VuZS5wYnIuQ3ViZVRvUGFub3JhbWEJAQVpbnB1dA0BAgIIcG9zaXRpb24FCgEBAAMCdXYFCgEBAAEAAAQFZmxpcFkDAgAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAICnBpeGVsQ29sb3IFDAQAAAkMY2FsY3VsYXRlZFVWBQoEAAAKBnNvdXJjZQwCAAALCF9faW5pdF9fDgYAAAwGdmVydGV4DgYAAA0IZnJhZ21lbnQOBgAAAwILAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADAAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDQAABQ4IDgJQSQMEAAABA0rYEk37IQlAAwAIDwRmb3ZYAwQAAAYBAg4DAQMAAAAAAAAAQAMDAAgQBGZvdlkDBAAAAg4DAAgRB2hPZmZzZXQDBAAABgEEBgMGAQEDAAAAAAAAAEADAg4DAwIPAwMDAQMAAAAAAADgPwMDAAgSB3ZPZmZzZXQDBAAABgEEBgMCDgMCEAMDAwEDAAAAAAAA4D8DAwAIEwZoQW5nbGUDBAAABgACEQMGAQoCCQUKAAADAg8DAwMACBQGdkFuZ2xlAwQAAAYAAhIDBgEKAgkFCgQAAwIQAwMDAAgVAW4FCwQAAAkDKQ4BAQMAAAAAAAAAAAMFCwAGBAoCFQULAAADBgEJAwIOAQIUAwMJAwIOAQITAwMDAwYECgIVBQsEAAMJAwMOAQIUAwMDBgQKAhUFCwgAAwYBCQMCDgECFAMDCQMDDgECEwMDAwMGBAIVBQsJAx8OAQIVBQsFCwULBgQCCAUMCQMqDgIKCQMhDgICCgwCFQULBQySAAULAQMAAAAAAADwPwMFDAUMBgQCCAUMCQMqDgQBAwAAAAAAAPA/AwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwA";
h3d_shader_AlphaChannel.SRC = "HXSLF2gzZC5zaGFkZXIuQWxwaGFDaGFubmVsAwEKcGl4ZWxDb2xvcgUMBAAAAglzaG93QWxwaGECAgABAAAAAAADCGZyYWdtZW50DgYAAAEBAwAABQILAgICBgQKAgEFDJIABQsKAgEFDP4ABQsFCwAABgQKAgEFDAwAAwEDAAAAAAAA8D8DAwA";
h3d_shader_AlphaMult.SRC = "HXSLFGgzZC5zaGFkZXIuQWxwaGFNdWx0AwEFYWxwaGEDAgACBwAAAAAAAAAAAAAAAAAA8D8JAQAAAAIKcGl4ZWxDb2xvcgUMBAAAAwhmcmFnbWVudA4GAAABAQMAAAUBBoEKAgIFDAwAAwIBAwMA";
h3d_shader_AmbientLight.SRC = "HXSLF2gzZC5zaGFkZXIuQW1iaWVudExpZ2h0CgEGZ2xvYmFsDQECAgxhbWJpZW50TGlnaHQFCwABAAMQcGVyUGl4ZWxMaWdodGluZwIAAQEAAAAAAAAAAAQKcGl4ZWxDb2xvcgUMBAAABQ9saWdodFBpeGVsQ29sb3IFCwQAAAYKbGlnaHRDb2xvcgULBAAABwhhZGRpdGl2ZQICAAEAAAAAAAgIX19pbml0X18OBgAACRBfX2luaXRfX2ZyYWdtZW50DgYAAAoJY2FsY0xpZ2h0DgYAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAABQIIAAAFAQYEAgYFCwsCBwICAgULCQMpDgEBAwAAAAAAAAAAAwULBQsFCwACCQAABQEGBAIFBQsLAgcCAgIFCwkDKQ4BAQMAAAAAAAAAAAMFCwULBQsAAwoBDQpsaWdodENvbG9yBQsEAAAFCwUBDQsCBwICDQULBAYAAgIFCwYBCQMWDgIEBgMBAwAAAAAAAPA/AwICBQsFCwULAQMAAAAAAAAAAAMFCwINBQsFCwULBQsFCwAAAAsAAAUBCwcCAgMCAgaBCgIEBQySAAULCQIKDgECBgULBQsFCwAAAAEMAAAFAQsCAwIGgQoCBAUMkgAFCwkCCg4BAgUFCwULBQsAAAA";
h3d_shader_Base2d.SRC = "HXSLEWgzZC5zaGFkZXIuQmFzZTJkGwEFaW5wdXQNAQMCCHBvc2l0aW9uBQoBAQADAnV2BQoBAQAEBWNvbG9yBQwBAQABAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgEdGltZQMAAAAJBnpWYWx1ZQMCAAAKB3RleHR1cmUKAgAACw5zcHJpdGVQb3NpdGlvbgUMBAAADBBhYnNvbHV0ZVBvc2l0aW9uBQwEAAANCnBpeGVsQ29sb3IFDAQAAA4MdGV4dHVyZUNvbG9yBQwEAAAPDGNhbGN1bGF0ZWRVVgUKAwAAEAppc1JlbGF0aXZlAgIAAQAAAAAAEQVjb2xvcgUMAgAAEg9hYnNvbHV0ZU1hdHJpeEEFCwIAABMPYWJzb2x1dGVNYXRyaXhCBQsCAAAUDWZpbHRlck1hdHJpeEEFCwIAABUNZmlsdGVyTWF0cml4QgULAgAAFghoYXNVVlBvcwICAAEAAAAAABcFdXZQb3MFDAIAABgJa2lsbEFscGhhAgIAAQAAAAAAGQpwaXhlbEFsaWduAgIAAQAAAAAAGhBoYWxmUGl4ZWxJbnZlcnNlBQoCAAAbCXZpZXdwb3J0QQULAgAAHAl2aWV3cG9ydEIFCwIAAB0Ob3V0cHV0UG9zaXRpb24FDAQAAB4IX19pbml0X18OBgAAHwZ2ZXJ0ZXgOBgAAIAhmcmFnbWVudA4GAAADAh4AAAUGBgQCCwUMCQMqDgMCAgUKAgkDAQMAAAAAAADwPwMFDAUMCwIQAgUDBgQKAgwFDAAAAwkDHQ4CCQMpDgIKAgsFDBEABQoBAwAAAAAAAPA/AwULAhIFCwMDBgQKAgwFDAQAAwkDHQ4CCQMpDgIKAgsFDBEABQoBAwAAAAAAAPA/AwULAhMFCwMDBgQKAgwFDDkABQoKAgsFDDkABQoFCgAGBAIMBQwCCwUMBQwABgQCDwUKCwIWAgYABgECAwUKCgIXBQw5AAUKBQoKAhcFDBEABQoFCgIDBQoFCgUKBgQCDQUMCwIQAgYBAhEFDAIEBQwFDAIEBQwFDAUMBgQCDgUMCQMhDgICCgoCDwUKBQwFDAaBAg0FDAIOBQwFDAAAHwAABQUIIQN0bXAFCwQAAAkDKQ4CCgIMBQwRAAUKAQMAAAAAAADwPwMFCwAGBAIhBQsJAykOAwkDHQ4CAiEFCwIUBQsDCQMdDgICIQULAhUFCwMBAwAAAAAAAPA/AwULBQsGBAIdBQwJAyoOAwkDHQ4CAiEFCwIbBQsDCQMdDgICIQULAhwFCwMKAgwFDDkABQoFDAUMCwIZAgaDCgIdBQwRAAUKAhoFCgUKAAAGBAIGBQwCHQUMBQwAASAAAAUCCwYOAhgCBgkKAg0FDAwAAwED/Knx0k1iUD8DAgIMAAAABgQCBwUMAg0FDAUMAA";
h3d_shader_BaseMesh.SRC = "HXSLE2gzZC5zaGFkZXIuQmFzZU1lc2gXAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQVjb2xvcgUMAgAAJg1zcGVjdWxhclBvd2VyAwIAAQcAAAAAAAAAAAAAAAAAAFlAJw5zcGVjdWxhckFtb3VudAMCAAEHAAAAAAAAAAAAAAAAAAAkQCgNc3BlY3VsYXJDb2xvcgULAgAAKQhfX2luaXRfXw4GAAAqEF9faW5pdF9fZnJhZ21lbnQOBgAAKwZ2ZXJ0ZXgOBgAALAhmcmFnbWVudA4GAAAEAikAAAULBgQCGgULAhIFCwULBgQCGwULBgECGgULCQM0DgECDwcIBQsFCwYEAh4FDAYBCQMqDgICGwULAQMAAAAAAADwPwMFDAIHBwUMBQwGBAIdBQsJAx8OAQQGAQITBQsJAzIOAQIPBwYFCwULBQsFCwYEAgsFCwkDHw4BBAYDAgQFCwIbBQsFCwULBQsFCwYEAh8FDAIlBQwFDAYEAiIDAiYDAwYEAiMFCwYBAigFCwInAwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCJAMGAgkDGw4BBgMCGwULAgQFCwULAwIKAwMDAAIqAAAFBQYEAh0FCwkDHw4BAh0FCwULBQsGBAIhBQoJAzoOAQYCCgIeBQwRAAUKCgIeBQwMAAMFCgUKBQoGBAIgAwYCCgIeBQwIAAMKAh4FDAwAAwMDBgQCIgMCJgMDBgQCIwULBgECKAULAicDBQsFCwAAKwAABQIGBAIVBQwGAQIeBQwJAyoOBAEDAAAAAAAA8D8DAgUDAQMAAAAAAADwPwMBAwAAAAAAAPA/AwUMBQwFDAYEAhwFCwIbBQsFCwABLAAABQQGBAIWBQwCHwUMBQwGBAIXAwIgAwMGBAIYBQsCHQULBQsGBAIZAwIkAwMA";
h3d_shader_Blur.SRC = "HXSLD2gzZC5zaGFkZXIuQmx1choBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoVY2FtZXJhSW52ZXJzZVZpZXdQcm9qBwIAAAsHdGV4dHVyZQoCAAAMDGRlcHRoVGV4dHVyZQoCAAANB1F1YWxpdHkBAgABAAAAAAAOB2lzRGVwdGgCAgABAAAAAAAPBnZhbHVlcw8DDQIAABAHb2Zmc2V0cw8DDQIAABEFcGl4ZWwFCgIAABINaGFzRml4ZWRDb2xvcgICAAEAAAAAABMQc21vb3RoRml4ZWRDb2xvcgICAAEAAAAAABQKZml4ZWRDb2xvcgUMAgAAFRBpc0RlcHRoRGVwZW5kYW50AgIAAQAAAAAAFgloYXNOb3JtYWwCAgABAAAAAAAXDW5vcm1hbFRleHR1cmUKAgAAGAZpc0N1YmUCAgABAAAAAAAZC2N1YmVUZXh0dXJlDAIAABoHY3ViZURpcgYCAAAbCF9faW5pdF9fDgYAABwGdmVydGV4DgYAAB0IZnJhZ21lbnQOBgAAHgtnZXRQb3NpdGlvbg4GAAAEAhsAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAcAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEdAAAFAgsCFQIFBggfBHBjdXIFCwQAAAkCHg4BAgMFCgULAAggBGNjdXIFDAQAAAkDIQ4CAgsKAgMFCgUMAAghBWNvbG9yBQwEAAAJAyoOBAEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwEDAAAAAAAAAAADBQwACCIEbmN1cgULBAAACQM5DgEJAyEOAgIXCgIDBQoFDAULABUGdW5yb2xsAA4jAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUICCQCdXYFCgQAAAYAAgMFCgYBAhEFChECEA8DDQsGCQIjAQECAAAAAAECBwMCIwEBAiMBAQMFCgUKAAglAWMFDAQAAAkDIQ4CAgsKAiQFCgUMAAgmAXAFCwQAAAkCHg4BAiQFCgULAAgnAWQDBAAACQMdDgIEBgMCJgULAh8FCwULBQsGAwImBQsCHwULBQsDAAgoAW4FCwQAAAkDOQ4BCQMhDgICFwoCJAUKBQwFCwAGBAIlBQwJAxgOAwIgBQwCJQUMCQMdDgICIgULAigFCwMFDAUMBgQCJQUMCQMYDgMCJQUMAiAFDAkDFQ4CBAYBCQMWDgIEBgMCJwMBA/yp8dJNYlA/AwMDAQMAAAAAAAAAAAMDAQMAAAAAAGr4QAMDAwEDAAAAAAAA8D8DAwUMBQwGgAIhBQwGAQIlBQwRAg8PAw0LBgkCIwEBAgAAAAABAgcDAiMBAQIjAQEDBQwFDAAAAAYEAggFDAIhBQwFDAALAg4CBQMIKQN2YWwDBAAAAQMAAAAAAAAAAAMAFQZ1bnJvbGwADioBaQEEAAAGFQYABwMCDQEBAQIBAAAAAQECDQEPAQAABQELAhgCBoACKQMGAQkDNw4BCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwDEQIPDwMNCwYJAioBAQIAAAAAAQIHAwIqAQECKgEBAwMDBoACKQMGAQkDNw4BCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIqAQECAAAAAAECBwMCKgEBAioBAQMFCgkDJg4BAioBAwUKBQoFDAMRAg8PAw0LBgkCKgEBAgAAAAABAgcDAioBAQIqAQEDAwMAAAAABgQCCAUMCQM2DgEJAxUOAgIpAwEDyxpQyv//7z8DAwUMBQwABQMIKwVjb2xvcgUMBAAACQMqDgQBAwAAAAAAAAAAAwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMABUGdW5yb2xsAA4sAWkBBAAABhUGAAcDAg0BAQECAQAAAAEBAg0BDwEAAAUBCwIYAgaAAisFDAYBCQMhDgICGQwGAQkDKQ4CBgMGAQQGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAQMAAAAAAADwPwMFCwIaBgULBQwRAg8PAw0LBgkCLAEBAgAAAAABAgcDAiwBAQIsAQEDBQwFDAaAAisFDAYBCQMhDgICCwoGAAIDBQoGAQYBAhEFChECEA8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFCgkDJg4BAiwBAwUKBQoFDBECDw8DDQsGCQIsAQECAAAAAAECBwMCLAEBAiwBAQMFDAUMAAAAAAYEAggFDAIrBQwFDAAAAAsCEgIFAgsCEwIGgQoCCAUMDAADCgIUBQwMAAMDBgQKAggFDAwAAwYBCgIUBQwMAAMJAyYOAQYHCgIIBQwMAAMBAwAAAAAAAAAAAwIDAwMABgQKAggFDJIABQsGAQoCFAUMkgAFCwoCCAUMDAADBQsFCwAAAAADHgEtAnV2BQoEAAAFCwUECC4FZGVwdGgDBAAACQM3DgEJAyEOAgIMCgItBQoFDAMACC8EdGVtcAUMBAAABgEJAyoOAwkDOw4BAi0FCgUKAi4DAQMAAAAAAADwPwMFDAIKBwUMAAgwCG9yaWdpbldTBQsEAAAGAgoCLwUMkgAFCwoCLwUMDAADBQsADQIwBQsAAA";
h3d_shader_ColorAdd.SRC = "HXSLE2gzZC5zaGFkZXIuQ29sb3JBZGQDAQpwaXhlbENvbG9yBQwEAAACBWNvbG9yBQsCAAADCGZyYWdtZW50DgYAAAEBAwAABQEGgAoCAQUMkgAFCwICBQsFCwA";
h3d_shader_ColorKey.SRC = "HXSLE2gzZC5zaGFkZXIuQ29sb3JLZXkDAQhjb2xvcktleQUMAgAAAgx0ZXh0dXJlQ29sb3IFDAQAAAMIZnJhZ21lbnQOBgAAAQEDAAAFAggEBWNkaWZmBQwEAAAGAwICBQwCAQUMBQwACwYJCQMdDgICBAUMAgQFDAMBA/Fo44i1+OQ+AwIMAAAAAA";
h3d_shader_ColorMatrix.SRC = "HXSLFmgzZC5zaGFkZXIuQ29sb3JNYXRyaXgEAQpwaXhlbENvbG9yBQwEAAACBm1hdHJpeAcCAAADB2VuYWJsZWQCAgABAAAAAAAECGZyYWdtZW50DgYAAAEBBAAABQELAgMCBgQCAQUMCQMqDgIKBAYBCQMqDgIKAgEFDJIABQsBAwAAAAAAAPA/AwUMAgIHBQwFDJIABQsKBAYBAgEFDAICBwUMBQwMAAMFDAUMAAAA";
h3d_shader_CubeMap.SRC = "HXSLEmgzZC5zaGFkZXIuQ3ViZU1hcAcBCnBpeGVsQ29sb3IFDAQAAAIRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAMKcmVmbGVjdGlvbgICAAEAAAAAAAQHdGV4dHVyZQwCAAAFBmNhbWVyYQ0BAQYIcG9zaXRpb24FCwAFAAAAAAcYcGl4ZWxUcmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAICGZyYWdtZW50DgYAAAEBCAAABQIICQFuBQsEAAALAgMCCQMgDgIHAwkDHw4BBgMCBgULAgcFCwULBQsFCwICBQsFCwICBQsFCwAGgQoCAQUMkgAFCwoJAyEOAgIEDAIJBQsFDJIABQsFCwA";
h3d_shader_DirShadow.SRC = "HXSLFGgzZC5zaGFkZXIuRGlyU2hhZG93EAEGZW5hYmxlAgIAAQAAAAAAAgdVU0VfRVNNAgIAAQAAAAAAAwtzaGFkb3dQb3dlcgMCAAAEB1VTRV9QQ0YCAgABAAAAAAAFC1BDRl9TQU1QTEVTAQIAAQAAAAAABghwY2ZTY2FsZQMCAAAHCXNoYWRvd1JlcwUKAgAACAlzaGFkb3dNYXARAQIAAAkKc2hhZG93UHJvaggCAAAKCnNoYWRvd0JpYXMDAgAACxN0cmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAMBnNoYWRvdwMEAAANCWRpclNoYWRvdwMEAAAOC3BvaXNzb25EaXNrDwUMBQIAAA8EcmFuZA4GAAAQCGZyYWdtZW50DgYAAAIDDwERAXYDBAAAAwUCCBICZHADBAAACQMdDgIJAyoOAQIRAwUMCQMqDgQBA18pyxDH+ilAAwED9P3UeOmOU0ADAQOiRbbz/ZRGQAMBA1CNl24Sq1dAAwUMAwANCQMTDgEGAQkDAg4BAhIDAwEDUPwYc9Fd5UADAwMAAAEQAAAFAgsCAQIFAQsCBAIFCwYEAgwDAQMAAAAAAADwPwMDCBMJdGV4ZWxTaXplBQoEAAAGAgEDAAAAAAAA8D8DAgcFCgUKAAgUCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACBUIc2hhZG93VXYFCgQAAAkDOg4BCgIUBQsRAAUKBQoACBYEek1heAMEAAAJAzUOAQoCFAULCAADAwAIFwNyb3QDBAAABgEGAQkCDw4BBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwEDH4XrUbgeCUADAwEDAAAAAAAAAEADAwAIGARjb3NSAwQAAAkDAw4BAhcDAwAIGQRzaW5SAwQAAAkDAg4BAhcDAwAIGg5zYW1wbGVTdHJlbmd0aAMEAAAGAgEDAAAAAAAA8D8DCQMmDgECBQEDAwAIGwhvZmZTY2FsZQUKBAAABgECEwUKAgYDBQoADhwBaQEEAAAGFQECAAAAAAECBQEPAQAABQQIHQZvZmZzZXQFCgQAAAYBChECDg8FDAUCHAEFDBEABQoCGwUKBQoABgQCHQUKCQMoDgIGAwYBAhgDCgIdBQoAAAMDBgECGQMKAh0FCgQAAwMDBgAGAQIYAwoCHQUKBAADAwYBAhkDCgIdBQoAAAMDAwUKBQoIHgVkZXB0aAMEAAAJA0AOAwIIEQEGAAIVBQoCHQUKBQoBAwAAAAAAAAAAAwMABoMCDAMLBAYHBgMCFgMCCgMDAh4DAgICGgMBAwAAAAAAAAAAAwMDAAAACwICAgUFCB8Jc2hhZG93UG9zBQsEAAAGAQILBQsCCQgFCwAIIAVkZXB0aAMEAAAJAz8OAgIIEQEJAzoOAQoCHwULEQAFCgUKAwAIIQR6TWF4AwQAAAkDNQ4BCgIfBQsIAAMDAAgiBWRlbHRhAwQAAAYDCQMVDgIEBgACIAMCCgMDAwIhAwMCIQMDAAYEAgwDCQM1DgEJAwkOAQYBAgMDAiIDAwMDAwAFBAgjCXNoYWRvd1BvcwULBAAABgECCwULAgkIBQsACCQIc2hhZG93VXYFCgQAAAkDOg4BCgIjBQsRAAUKBQoACCUFZGVwdGgDBAAACQM/DgICCBEBCgIkBQoRAAUKAwAGBAIMAwsGBwYDCQM1DgEKAiMFCwgAAwMCCgMDAiUDAgEDAAAAAAAAAAADAQMAAAAAAADwPwMDAwAAAAAAAAYEAg0DAgwDAwA";
h3d_shader_FixedColor.SRC = "HXSLFWgzZC5zaGFkZXIuRml4ZWRDb2xvcgQBBWNvbG9yBQwCAAACCVVTRV9BTFBIQQICAAEAAAAAAAMGb3V0cHV0DQEBBAVjb2xvcgUMBAMABAAABQhmcmFnbWVudA4GAAABAQUAAAUBCwICAgYEAgQFDAIBBQwFDAYECgIEBQySAAULCgIBBQySAAULBQsAAA";
h3d_shader_GenTexture.SRC = "HXSLFWgzZC5zaGFkZXIuR2VuVGV4dHVyZQoBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEbW9kZQECAAEAAAAAAAsFY29sb3IFDAIAAAwIX19pbml0X18OBgAADQZ2ZXJ0ZXgOBgAADghmcmFnbWVudA4GAAADAgwAAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAANAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEOAAAFARMEAgoBAQEBAQIAAAAAAQUBBgQCCAUMCwYHCQMbDgEKAgYFDBEABQoDAQMAAAAAAADwPwMCCQMqDgEBAwAAAAAAAAAAAwUMAgsFDAUMBQwAAAAA";
h3d_shader_LineShader.SRC = "HXSLFWgzZC5zaGFkZXIuTGluZVNoYWRlcgwBBmNhbWVyYQ0BAwIEdmlldwcAAQADBHByb2oHAAEABAh2aWV3UHJvagcAAQAAAAAFBmdsb2JhbA0CAgYJcGl4ZWxTaXplBQoABQAHCW1vZGVsVmlldwcABQEDAAAACAVpbnB1dA0DAwkIcG9zaXRpb24FCwEIAAoGbm9ybWFsBQsBCAALAnV2BQoBCAABAAAMBm91dHB1dA0EAQ0IcG9zaXRpb24FDAQMAAQAAA4RdHJhbnNmb3JtZWROb3JtYWwFCwQAAA8TdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAEBFwcm9qZWN0ZWRQb3NpdGlvbgUMBAAAEQtsZW5ndGhTY2FsZQMCAAASBXdpZHRoAwIAABMEcGRpcgUMBAAAFAhfX2luaXRfXw4GAAAVBnZlcnRleA4GAAACAhQAAAUBBQUIFgNkaXIFCwQAAAYBAgoFCwkDMg4BAgcHBgULAAYEAhMFDAYBCQMqDgIGAQIWBQsJAzIOAQICBwYFCwEDAAAAAAAA8D8DBQwCAwcFDAUMBoEKAhMFDBEABQoGAgEDAAAAAAAA8D8DCQMNDgEGAAYBCgITBQwAAAMKAhMFDAAAAwMGAQoCEwUMBAADCgITBQwEAAMDAwMDBQoGgAIPBQsGAQYBAhYFCwoCCwUKAAADBQsCEQMFCwULBgQCDgULCQMfDgECFgULBQsFCwAAABUAAAUBBoAKAhAFDBEABQoGAQYBBgEGAQQGAQoCEwUMBQAFCgkDKA4CAQMAAAAAAADwPwMBAwAAAAAAAPC/AwUKBQoFCgQGAwoCCwUKBAADAQMAAAAAAADgPwMDAwUKCgIQBQwIAAMFCgIGBQoFCgISAwUKBQoA";
h3d_shader_MinMaxShader.SRC = "HXSLF2gzZC5zaGFkZXIuTWluTWF4U2hhZGVyCwEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgR0ZXhBCgIAAAsEdGV4QgoCAAAMBWlzTWF4AgIAAQAAAAAADQhfX2luaXRfXw4GAAAOBnZlcnRleA4GAAAPCGZyYWdtZW50DgYAAAMCDQAABQIGBAIHBQwCCAUMBQwGBAIJBQoCAwUKBQoAAA4AAAUBBgQCBgUMCQMqDgQKAgIFCgAAAwYBCgICBQoEAAMCBAMDAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBQwAAQ8AAAUDCBABYQUMBAAACQMhDgICCgoCCQUKBQwACBEBYgUMBAAACQMhDgICCwoCCQUKBQwABgQCCAUMCwIMAgkDFg4CAhAFDAIRBQwFDAkDFQ4CAhAFDAIRBQwFDAUMBQwA";
h3d_shader_CubeMinMaxShader.SRC = "HXSLG2gzZC5zaGFkZXIuQ3ViZU1pbk1heFNoYWRlcgwBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoEdGV4QQwCAAALBHRleEIMAgAADAVpc01heAICAAEAAAAAAA0DbWF0BgIAAA4IX19pbml0X18OBgAADwZ2ZXJ0ZXgOBgAAEAhmcmFnbWVudA4GAAADAg4AAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAPAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEQAAAFBQgRAnV2BQoEAAAGAwYBAgkFCgEDAAAAAAAAAEADBQoBAwAAAAAAAPA/AwUKAAgSA2RpcgULBAAABgEJAykOAgIRBQoBAwAAAAAAAPA/AwULAg0GBQsACBMBYQUMBAAACQMhDgICCgwCEgULBQwACBQBYgUMBAAACQMhDgICCwwCEgULBQwABgQCCAUMCwIMAgkDFg4CAhMFDAIUBQwFDAkDFQ4CAhMFDAIUBQwFDAUMBQwA";
h3d_shader_NormalMap.SRC = "HXSLFGgzZC5zaGFkZXIuTm9ybWFsTWFwCgEGY2FtZXJhDQECAghwb3NpdGlvbgULAAEAAwNkaXIFCwMBAAAAAAQGZ2xvYmFsDQIBBQltb2RlbFZpZXcHAAQBAwAAAAYFaW5wdXQNAwIHBm5vcm1hbAULAQYACAd0YW5nZW50BQsBBgABAAAJB3RleHR1cmUKAgAACgxjYWxjdWxhdGVkVVYFCgQAAAsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAADBF0cmFuc2Zvcm1lZE5vcm1hbAULBAAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAMAAA4OX19pbml0X192ZXJ0ZXgOBgAADwhmcmFnbWVudA4GAAACAg4AAAUBBgQCDQUMCQMqDgIGAQIIBQsJAzIOAQIFBwYFCwsGBwkDHQ4CAggFCwIIBQsDAQMAAAAAAADgPwMCAQMAAAAAAADwPwMBAwAAAAAAAPC/AwMFDAUMAAEPAAAFBQgQAW4FCwQAAAIMBQsACBECbmYFCwQAAAkDOQ4BCQMhDgICCQoCCgUKBQwFCwAIEgR0YW5YBQsEAAAJAx8OAQoCDQUMkgAFCwULAAgTBHRhblkFCwQAAAYBCQMeDgICEAULAhIFCwULBwMKAg0FDAwAAwMFCwAGBAIMBQsJAx8OAQQGAAYABgEKAhEFCwAAAwISBQsFCwYBCgIRBQsEAAMCEwULBQsFCwYBCgIRBQsIAAMCEAULBQsFCwULBQsFCwA";
h3d_shader_ParticleShader.SRC = "HXSLGWgzZC5zaGFkZXIuUGFydGljbGVTaGFkZXIMAQZjYW1lcmENAQICCHZpZXdQcm9qBwABAAMIcG9zaXRpb24FCwABAAAAAAQGZ2xvYmFsDQIBBQltb2RlbFZpZXcHAAQBAwAAAAYFaW5wdXQNAwQHCHBvc2l0aW9uBQsBBgAIBm5vcm1hbAULAQYACQRzaXplBQoBBgAKAnV2BQoBBgABAAALE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAwRdHJhbnNmb3JtZWROb3JtYWwFCwQAAA0RcHJvamVjdGVkUG9zaXRpb24FDAQAAA4Mcm90YXRpb25BeGlzBgIAAA8Ec2l6ZQUKAgAAEARpczNEAgIAAQAAAAAAEQppc0Fic29sdXRlAgIAAQAAAAAAEghfX2luaXRfXw4GAAATBnZlcnRleA4GAAACAhIAAAUBCwIRAgYEAgsFCwIHBQsFCwAAAAATAAAFCwgUBHJwb3MFCgQAAAoCCAULEQAFCgAIFQNyb3QDBAAACgIIBQsIAAMACBYCY3IDBAAACQMDDgECFQMDAAgXAnNyAwQAAAkDAg4BAhUDAwAIGANwb3MFCgQAAAYBAgkFCgIUBQoFCgALAhACBoECGAUKAg8FCgUKAAAIGQRydG1wAwQAAAYABgEKAhgFCgAAAwIWAwMGAQoCGAUKBAADAhcDAwMABgQKAhgFCgQAAwYDBgEKAhgFCgQAAwIWAwMGAQoCGAUKAAADAhcDAwMDBgQKAhgFCgAAAwIZAwMLAhACBQEGgAILBQsGAQkDKQ4CAhgFCgEDAAAAAAAAAAADBQsCDgYFCwULAAUCBgQCDQUMBgEJAyoOAgILBQsBAwAAAAAAAPA/AwUMAgIHBQwFDAaACgINBQwRAAUKBgECGAUKAg8FCgUKBQoAAAYEAgwFCwkDHw4BBAYDAgsFCwIDBQsFCwULBQsFCwA";
h3d_shader_Shadow.SRC = "HXSLEWgzZC5zaGFkZXIuU2hhZG93BwEGc2hhZG93DQEFAgNtYXARAQABAAMEcHJvaggAAQAEBWNvbG9yBQsAAQAFBXBvd2VyAwABAAYEYmlhcwMAAQAAAAAHCnBpeGVsQ29sb3IFDAQAAAgTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAACRhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAoJc2hhZG93UG9zBQsDAAALBnZlcnRleA4GAAAMCGZyYWdtZW50DgYAAAIACwAABQEGBAIKBQsGAQIIBQsCAwgFCwULAAEMAAAFBQgNBWRlcHRoAwQAAAkDPw4CAgIRAQkDOg4BCgIKBQsRAAUKBQoDAAgOBHpNYXgDBAAACQM1DgEKAgoFCwgAAwMACA8FZGVsdGEDBAAABgMJAxUOAgQGAAINAwIGAwMDAg4DAwIOAwMACBAFc2hhZGUDBAAACQM1DgEJAwkOAQYBAgUDAg8DAwMDAAaBCgIHBQySAAULBgAGAQQGAwEDAAAAAAAA8D8DAhADAwMKAgQFC5IABQsFCwIQAwULBQsA";
h3d_shader_SignedDistanceField.SRC = "HXSLHmgzZC5zaGFkZXIuU2lnbmVkRGlzdGFuY2VGaWVsZA8BBWlucHV0DQEDAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEABAVjb2xvcgUMAQEAAQAABQZvdXRwdXQNAgIGCHBvc2l0aW9uBQwEBQAHBWNvbG9yBQwEBQAEAAAIBHRpbWUDAAAACQ5zcHJpdGVQb3NpdGlvbgUMBAAAChBhYnNvbHV0ZVBvc2l0aW9uBQwEAAALCnBpeGVsQ29sb3IFDAQAAAwMdGV4dHVyZUNvbG9yBQwEAAANDGNhbGN1bGF0ZWRVVgUKAwAADg5vdXRwdXRQb3NpdGlvbgUMBAAADwdjaGFubmVsAQIAAQAAAAAAEA1hdXRvU21vb3RoaW5nAgIAAQAAAAAAEQthbHBoYUN1dG9mZgMCAAASCXNtb290aGluZwMCAAATBm1lZGlhbg4GAAAUCGZyYWdtZW50DgYAAAIDEwMVAXIDBAAAFgFnAwQAABcBYgMEAAADBQENCQMWDgIJAxUOAgIVAwIWAwMJAxUOAgkDFg4CAhUDAhYDAwIXAwMDAAABFAAABQUIGA10ZXh0dXJlU2FtcGxlBQwEAAACDAUMAAgZCGRpc3RhbmNlAwQAAAAABgQCGQMLBgUCDwEBAgAAAAABAgoCGAUMAAADCwYFAg8BAQIBAAAAAQIKAhgFDAQAAwsGBQIPAQECAgAAAAECCgIYBQwIAAMLBgUCDwEBAgMAAAABAgoCGAUMDAADCQITDgMKAhgFDAAAAwoCGAUMBAADCgIYBQwIAAMDAwMDAwMIGglzbW9vdGhWYWwDBAAACwIQAgkDDw4BBgEJAz4OAQIZAwMBAwAAAAAAAOA/AwMDAhIDAwAGBAIMBQwJAyoOBAEDAAAAAAAA8D8DAQMAAAAAAADwPwMBAwAAAAAAAPA/AwkDGg4DBgMCEQMCGgMDBgACEQMCGgMDAhkDAwUMBQwA";
h3d_shader_SkinBase.SRC = "HXSLE2gzZC5zaGFkZXIuU2tpbkJhc2UGARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFEWZvdXJCb25lc0J5VmVydGV4AgIAAQAAAAAABg1ib25lc01hdHJpeGVzDwgEAgABCAA";
h3d_shader_Skin.SRC = "HXSLD2gzZC5zaGFkZXIuU2tpbgkBEHJlbGF0aXZlUG9zaXRpb24FCwQAAAITdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAAxF0cmFuc2Zvcm1lZE5vcm1hbAULBAAABAhNYXhCb25lcwECAAEAAAAAAAURZm91ckJvbmVzQnlWZXJ0ZXgCAgABAAAAAAAGDWJvbmVzTWF0cml4ZXMPCAQCAAEIBwVpbnB1dA0BBAgIcG9zaXRpb24FCwEHAAkGbm9ybWFsBQsBBwAKB3dlaWdodHMFCwEHAAsHaW5kZXhlcwkEAAAAAQcAAQAADBJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAQAAA0GdmVydGV4DgYAAAEADQAABQQGBAICBQsGAAYABgEEBgECAQULEQIGDwgECQMlDgEKAgsJBAAAAAAAAwEIBQsFCwoCCgULAAADBQsGAQQGAQIBBQsRAgYPCAQJAyUOAQoCCwkEAAAABAADAQgFCwULCgIKBQsEAAMFCwULBgEEBgECAQULEQIGDwgECQMlDgEKAgsJBAAAAAgAAwEIBQsFCwoCCgULCAADBQsFCwULBgQCAwULBgAGAAYBBAYBAgkFCwkDMg4BEQIGDwgECQMlDgEKAgsJBAAAAAAAAwEIBgULBQsKAgoFCwAAAwULBgEEBgECCQULCQMyDgERAgYPCAQJAyUOAQoCCwkEAAAABAADAQgGBQsFCwoCCgULBAADBQsFCwYBBAYBAgkFCwkDMg4BEQIGDwgECQMlDgEKAgsJBAAAAAgAAwEIBgULBQsKAgoFCwgAAwULBQsFCwsCBQIFAwgOAnc0AwQAAAYDAQMAAAAAAADwPwMEBgAGAAoCCgULAAADCgIKBQsEAAMDCgIKBQsIAAMDAwMABoACAgULBgEEBgECAQULEQIGDwgECQMlDgEKAgsJBAAAAAwAAwEIBQsFCwIOAwULBQsGgAIDBQsGAQQGAQIJBQsJAzIOARECBg8IBAkDJQ4BCgILCQQAAAAIAAMBCAYFCwULAg4DBQsFCwAAAAYEAgMFCwkDHw4BAgMFCwULBQsA";
h3d_shader_SkinTangent.SRC = "HXSLFmgzZC5zaGFkZXIuU2tpblRhbmdlbnQJARByZWxhdGl2ZVBvc2l0aW9uBQsEAAACE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAMRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAQITWF4Qm9uZXMBAgABAAAAAAAFEWZvdXJCb25lc0J5VmVydGV4AgIAAQAAAAAABg1ib25lc01hdHJpeGVzDwgEAgABCAcFaW5wdXQNAQUICHBvc2l0aW9uBQsBBwAJBm5vcm1hbAULAQcACgd0YW5nZW50BQsBBwALB3dlaWdodHMFCwEHAAwHaW5kZXhlcwkEAAAAAQcAAQAADRJ0cmFuc2Zvcm1lZFRhbmdlbnQFDAQAAA4GdmVydGV4DgYAAAEADgAABQYGBAICBQsGAAYABgEEBgECAQULEQIGDwgECQMlDgEKAgwJBAAAAAAAAwEIBQsFCwoCCwULAAADBQsGAQQGAQIBBQsRAgYPCAQJAyUOAQoCDAkEAAAABAADAQgFCwULCgILBQsEAAMFCwULBgEEBgECAQULEQIGDwgECQMlDgEKAgwJBAAAAAgAAwEIBQsFCwoCCwULCAADBQsFCwULBgQCAwULBgAGAAYBBAYBAgkFCwkDMg4BEQIGDwgECQMlDgEKAgwJBAAAAAAAAwEIBgULBQsKAgsFCwAAAwULBgEEBgECCQULCQMyDgERAgYPCAQJAyUOAQoCDAkEAAAABAADAQgGBQsFCwoCCwULBAADBQsFCwYBBAYBAgkFCwkDMg4BEQIGDwgECQMlDgEKAgwJBAAAAAgAAwEIBgULBQsKAgsFCwgAAwULBQsFCwYECgINBQySAAULBgAGAAYBBAYBCgIKBQuSAAULCQMyDgERAgYPCAQJAyUOAQoCDAkEAAAAAAADAQgGBQsFCwoCCwULAAADBQsGAQQGAQoCCgULkgAFCwkDMg4BEQIGDwgECQMlDgEKAgwJBAAAAAQAAwEIBgULBQsKAgsFCwQAAwULBQsGAQQGAQoCCgULkgAFCwkDMg4BEQIGDwgECQMlDgEKAgwJBAAAAAgAAwEIBgULBQsKAgsFCwgAAwULBQsFCwsCBQIFBAgPAnc0AwQAAAYDAQMAAAAAAADwPwMEBgAGAAoCCwULAAADCgILBQsEAAMDCgILBQsIAAMDAwMABoACAgULBgEEBgECAQULEQIGDwgECQMlDgEKAgwJBAAAAAwAAwEIBQsFCwIPAwULBQsGgAIDBQsGAQQGAQIJBQsJAzIOARECBg8IBAkDJQ4BCgIMCQQAAAAIAAMBCAYFCwULAg8DBQsFCwaACgINBQySAAULBgEEBgEKAgoFC5IABQsJAzIOARECBg8IBAkDJQ4BCgIMCQQAAAAMAAMBCAYFCwULAg8DBQsFCwAAAAYEAgMFCwkDHw4BAgMFCwULBQsGBAoCDQUMkgAFCwkDHw4BCgINBQySAAULBQsFCwA";
h3d_shader_SpecularTexture.SRC = "HXSLGmgzZC5zaGFkZXIuU3BlY3VsYXJUZXh0dXJlBAEHdGV4dHVyZQoCAAACDGNhbGN1bGF0ZWRVVgUKBAAAAwlzcGVjQ29sb3IFCwQAAAQIZnJhZ21lbnQOBgAAAQEEAAAFAQaBAgMFCwoJAyEOAgIBCgICBQoFDJIABQsFCwA";
h3d_shader_Texture.SRC = "HXSLEmgzZC5zaGFkZXIuVGV4dHVyZQsBBWlucHV0DQEBAgJ1dgUKAQEAAQAAAwhhZGRpdGl2ZQICAAEAAAAAAAQJa2lsbEFscGhhAgIAAQAAAAAABQ1zcGVjdWxhckFscGhhAgIAAQAAAAAABhJraWxsQWxwaGFUaHJlc2hvbGQDAgABBwAAAAAAAAAAAAAAAAAA8D8HB3RleHR1cmUKAgAACAxjYWxjdWxhdGVkVVYFCgQAAAkKcGl4ZWxDb2xvcgUMBAAACglzcGVjQ29sb3IFCwQAAAsGdmVydGV4DgYAAAwIZnJhZ21lbnQOBgAAAgALAAAFAQYEAggFCgICBQoFCgABDAAABQQIDQFjBQwEAAAJAyEOAgIHCgIIBQoFDAALBg4CBAIGCQYDCgINBQwMAAMCBgMDAQMAAAAAAAAAAAMCAgwAAAALAgMCBoACCQUMAg0FDAUMBoECCQUMAg0FDAUMAAsCBQIGgQIKBQsKAg0FDP4ABQsFCwAAAA";
h3d_shader_UVAnim.SRC = "HXSLEWgzZC5zaGFkZXIuVVZBbmltCAEMY2FsY3VsYXRlZFVWBQoEAAACBmdsb2JhbA0BAQMEdGltZQMAAgAAAAAEBXNwZWVkAwIAAAUNZnJhbWVEaXZpc2lvbgMCAAAGC3RvdGFsRnJhbWVzAwIAAAcJc3RhcnRUaW1lAwIAAAgEbG9vcAICAAEAAAAAAAkGdmVydGV4DgYAAAEACQAABQQICgVmcmFtZQMEAAAJAyYOAQkDJQ4BBgEEBgMCAwMCBwMDAwIEAwMBAwALAggCBpMCCgMCBgMDBgQCCgMJAxUOAgIKAwYDAgYDAQMAAAAAAADwPwMDAwMACAsFZGVsdGEFCgQAAAYBCQMoDgIGAgEDAAAAAAAA8D8DAgUDAwYCAQMAAAAAAADwPwMCBQMDBQoJAygOAgYTAgoDAgUDAwkDJg4BCQMlDgEGAgIKAwIFAwMBAwUKBQoABoACAQUKAgsFCgUKAA";
h3d_shader_UVDelta.SRC = "HXSLEmgzZC5zaGFkZXIuVVZEZWx0YQQBB3V2RGVsdGEFCgIAAAIHdXZTY2FsZQUKAgAAAwxjYWxjdWxhdGVkVVYFCgQAAAQGdmVydGV4DgYAAAEABAAABQEGBAIDBQoGAAYBAgMFCgICBQoFCgIBBQoFCgUKAA";
h3d_shader_UVScroll.SRC = "HXSLE2gzZC5zaGFkZXIuVVZTY3JvbGwEAQZnbG9iYWwNAQECBHRpbWUDAAEAAAAAAwd1dlNwZWVkBQoCAAAEDGNhbGN1bGF0ZWRVVgUKBAAABQZ2ZXJ0ZXgOBgAAAQAFAAAFAQaAAgQFCgYBAgMFCgICAwUKBQoA";
h3d_shader_VertexColorAlpha.SRC = "HXSLG2gzZC5zaGFkZXIuVmVydGV4Q29sb3JBbHBoYQQBBWlucHV0DQEBAgVjb2xvcgUMAQEAAQAAAwpwaXhlbENvbG9yBQwEAAAECGFkZGl0aXZlAgIAAQAAAAAABQhmcmFnbWVudA4GAAABAQUAAAUBCwIEAgaAAgMFDAICBQwFDAaBAgMFDAICBQwFDAAA";
h3d_shader_VolumeDecal.SRC = "HXSLFmgzZC5zaGFkZXIuVm9sdW1lRGVjYWwYAQZjYW1lcmENAQoCBHZpZXcHAAEAAwRwcm9qBwABAAQIcG9zaXRpb24FCwABAAUIcHJvakZsaXADAAEABghwcm9qRGlhZwULAAEABwh2aWV3UHJvagcAAQAID2ludmVyc2VWaWV3UHJvagcAAQAJBXpOZWFyAwABAAoEekZhcgMAAQALA2RpcgULAwEAAAAADAZnbG9iYWwNAgQNBHRpbWUDAAwADglwaXhlbFNpemUFCgAMAA8JbW9kZWxWaWV3BwAMAQMQEG1vZGVsVmlld0ludmVyc2UHAAwBAwAAABEFaW5wdXQNAwISCHBvc2l0aW9uBQsBEQATBm5vcm1hbAULAREAAQAAFAZvdXRwdXQNBAUVCHBvc2l0aW9uBQwEFAAWBWNvbG9yBQwEFAAXBWRlcHRoAwQUABgGbm9ybWFsBQsEFAAZCXdvcmxkRGlzdAMEFAAEAAAaEHJlbGF0aXZlUG9zaXRpb24FCwQAABsTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAHBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAB0RdHJhbnNmb3JtZWROb3JtYWwFCwQAAB4RcHJvamVjdGVkUG9zaXRpb24FDAQAAB8KcGl4ZWxDb2xvcgUMBAAAIAVkZXB0aAMEAAAhCHNjcmVlblVWBQoEAAAiCXNwZWNQb3dlcgMEAAAjCXNwZWNDb2xvcgULBAAAJAl3b3JsZERpc3QDBAAAJQhkZXB0aE1hcBEBAAAAJgVzY2FsZQUKAgAAJwZub3JtYWwFCwIAACgHdGFuZ2VudAULAgAAKQppc0NlbnRlcmVkAgIAAQAAAAAAKgxjYWxjdWxhdGVkVVYFCgQAACsSdHJhbnNmb3JtZWRUYW5nZW50BQwEAAAsDl9faW5pdF9fdmVydGV4DgYAAC0IZnJhZ21lbnQOBgAAAgIsAAAFAgYEAh0FCwkDHw4BBAYBAicFCwkDMg4BAg8HBgULBQsFCwULBgQCKwUMCQMqDgIJAx8OAQQGAQIoBQsJAzIOAQIPBwYFCwULBQsBAwAAAAAAAPA/AwUMBQwAAS0AAAUJCC4GbWF0cml4BwQAAAYBAggHAhAHBwAILwlzY3JlZW5Qb3MFCgQAAAYCCgIeBQwRAAUKCgIeBQwMAAMFCgAIMANydXYFDAQAAAkDKg4DAi8FCgkDPw4CAiURAQkDOg4BAi8FCgUKAwEDAAAAAAAA8D8DBQwACDEEd3BvcwUMBAAABgECMAUMAi4HBQwACDIEcHBvcwUMBAAABgECMAUMAggHBQwABgQCHAULBgIKAjIFDJIABQsKAjIFDAwAAwULBQsGBAIqBQoGAQImBQoEBgIKAjEFDBEABQoKAjEFDAwAAwUKBQoFCgUKCwIpAgaAAioFCgEDAAAAAAAA4D8DBQoAAAsGCQkDFQ4CCQMVDgIKAioFCgAAAwoCKgUKBAADAwkDFQ4CBgMBAwAAAAAAAPA/AwoCKgUKAAADAwYDAQMAAAAAAADwPwMKAioFCgQAAwMDAwEDAAAAAAAAAAADAgwAAAAA";
h3d_shader_pbr_PropsValues.SRC = "HXSLGmgzZC5zaGFkZXIucGJyLlByb3BzVmFsdWVzDwEGb3V0cHV0DQEGAgltZXRhbG5lc3MDBAEAAwlyb3VnaG5lc3MDBAEABAlvY2NsdXNpb24DBAEABQhlbWlzc2l2ZQMEAQAGB2N1c3RvbTEDBAEABwdjdXN0b20yAwQBAAQAAAgObWV0YWxuZXNzVmFsdWUDAgAACQ5yb3VnaG5lc3NWYWx1ZQMCAAAKDm9jY2x1c2lvblZhbHVlAwIAAAsNZW1pc3NpdmVWYWx1ZQMCAAAMDGN1c3RvbTFWYWx1ZQMCAAANDGN1c3RvbTJWYWx1ZQMCAAAOCW1ldGFsbmVzcwMEAAAPCXJvdWdobmVzcwMEAAAQCW9jY2x1c2lvbgMEAAARCGVtaXNzaXZlAwQAABIHY3VzdG9tMQMEAAATB2N1c3RvbTIDBAAAFAhfX2luaXRfXw4GAAAVCGZyYWdtZW50DgYAAAICFAAABQYGBAIOAwIIAwMGBAIPAwIJAwMGBAIQAwIKAwMGBAIRAwILAwMGBAISAwIMAwMGBAITAwINAwMAARUAAAUGBgQCAgMCDgMDBgQCAwMCDwMDBgQCBAMCEAMDBgQCBQMCEQMDBgQCBgMCEgMDBgQCBwMCEwMDAA";
haxe_EntryPoint.pending = [];
haxe_EntryPoint.threadCount = 0;
haxe_Int32._mul = Math.imul != null ? Math.imul : function(a,b) {
	return a * (b & 65535) + (a * (b >>> 16) << 16 | 0) | 0;
};
haxe_Unserializer.DEFAULT_RESOLVER = new haxe__$Unserializer_DefaultResolver();
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
haxe_io_FPHelper.i64tmp = new haxe__$Int64__$_$_$Int64(0,0);
haxe_io_FPHelper.helper = new DataView(new ArrayBuffer(8));
haxe_xml_Parser.escapes = (function($this) {
	var $r;
	let h = new haxe_ds_StringMap();
	h.h["lt"] = "<";
	h.h["gt"] = ">";
	h.h["amp"] = "&";
	h.h["quot"] = "\"";
	h.h["apos"] = "'";
	$r = h;
	return $r;
}(this));
haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL = [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,-1,-1];
haxe_zip_InflateImpl.LEN_BASE_VAL_TBL = [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258];
haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL = [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,-1,-1];
haxe_zip_InflateImpl.DIST_BASE_VAL_TBL = [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577];
haxe_zip_InflateImpl.CODE_LENGTHS_POS = [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
hxd_Charset.complementChars = (function($this) {
	var $r;
	let _g = new haxe_ds_IntMap();
	{
		let _g1 = 0;
		let _g2 = "".length;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.h[HxOverrides.cca("",i)] = true;
		}
	}
	$r = _g;
	return $r;
}(this));
hxd_Key.initDone = false;
hxd_Key.keyPressed = [];
hxd_Key.ALLOW_KEY_REPEAT = false;
hxd_Pad.CONFIG_JS_STD = { A : 0, B : 1, X : 2, Y : 3, LB : 4, RB : 5, LT : 6, RT : 7, back : 8, start : 9, analogClick : 10, ranalogClick : 11, dpadUp : 12, dpadDown : 13, dpadLeft : 14, dpadRight : 15, analogX : 17, analogY : 18, ranalogX : 19, ranalogY : 20, names : ["A","B","X","Y","LB","RB","LT","RT","Select","Start","LCLK","RCLK","DUp","DDown","DLeft","DRight","LX","LY","RX","RY"]};
hxd_Pad.CONFIG_JS_DS4 = { A : 0, B : 1, X : 2, Y : 3, LB : 4, RB : 5, LT : 6, RT : 7, back : 8, start : 9, analogClick : 10, ranalogClick : 11, dpadUp : 12, dpadDown : 13, dpadLeft : 14, dpadRight : 15, analogX : 18, analogY : 19, ranalogX : 20, ranalogY : 21, names : ["A","B","X","Y","LB","RB","LT","RT","Select","Start","LCLK","RCLK","DUp","DDown","DLeft","DRight","LX","LY","RX","RY"]};
hxd_Pad.CONFIG_JS_DS4_FF = { A : 1, B : 2, X : 0, Y : 3, LB : 4, RB : 5, LT : 6, RT : 7, back : 8, start : 9, analogClick : 10, ranalogClick : 11, dpadUp : 9000, dpadDown : 9000, dpadLeft : 9000, dpadRight : 9000, analogX : 18, analogY : 19, ranalogX : 20, ranalogY : 23, names : ["A","B","X","Y","LB","RB","LT","RT","Select","Start","LCLK","RCLK","DUp","DDown","DLeft","DRight","LX","LY","RX","RY"]};
hxd_Pad.DEFAULT_CONFIG = hxd_Pad.CONFIG_JS_STD;
hxd_Pad.initDone = false;
hxd_Pad.pads = new haxe_ds_IntMap();
hxd_Timer.wantedFPS = 60.;
hxd_Timer.maxDeltaTime = 0.5;
hxd_Timer.smoothFactor = 0.95;
hxd_Timer.lastTimeStamp = HxOverrides.now() / 1000;
hxd_Timer.elapsedTime = 0.;
hxd_Timer.frameCount = 0;
hxd_Timer.dt = 1 / hxd_Timer.wantedFPS;
hxd_Timer.currentDT = 1 / hxd_Timer.wantedFPS;
hxd_System.setCursor = hxd_System.setNativeCursor;
hxd_System.loopInit = false;
hxd_System.fpsLimit = -1;
hxd_res_Resource._hx_skip_constructor = false;
hxd_res_Resource.LIVE_UPDATE = true;
hxd_res_Image.DEFAULT_FILTER = h3d_mat_Filter.Linear;
hxd_res_Image.MIPMAP_MAX_SIZE = 0;
hxd_res_Image.ENABLE_AUTO_WATCH = true;
hxd_res_Image.BLACK_1x1 = hxd_Pixels.alloc(1,1,hxd_PixelFormat.RGBA);
hxd_res_Image.LOG_TEXTURE_LOAD = false;
hxd_res_Sound.ENABLE_AUTO_WATCH = true;
hxd_snd_ChannelBase._hx_skip_constructor = false;
hxd_snd_Channel.ID = 0;
hxd_snd_EffectDriver._hx_skip_constructor = false;
hxd_snd_Source.ID = 0;
hxd_snd_Manager.STREAM_DURATION = 5.;
hxd_snd_Manager.STREAM_BUFFER_SAMPLE_COUNT = 44100;
hxd_snd_Manager.BUFFER_QUEUE_LENGTH = 2;
hxd_snd_Manager.MAX_SOURCES = 16;
hxd_snd_Manager.SOUND_BUFFER_CACHE_SIZE = 256;
hxd_snd_Manager.VIRTUAL_VOLUME_THRESHOLD = 1e-5;
hxd_snd_Manager.BUFFER_STREAM_SPLIT = 16;
hxsl_Tools.UID = 0;
hxsl_Tools.SWIZ = hxsl_Component.__empty_constructs__.slice();
hxsl_Tools.MAX_CHANNELS_BITS = 3;
hxsl_BatchShader.SRC = "HXSLEGh4c2wuQmF0Y2hTaGFkZXIDAQ9CYXRjaF9IYXNPZmZzZXQCAgABAAAAAAACC0JhdGNoX0NvdW50AQIAAQAAAAEAAwxCYXRjaF9CdWZmZXIQBQwCAgAAAA";
hxsl_GlslOut.KWD_LIST = ["input","output","discard","sample","dvec2","dvec3","dvec4","hvec2","hvec3","hvec4","fvec2","fvec3","fvec4","int","float","bool","long","short","double","half","fixed","unsigned","superp","lowp","mediump","highp","precision","invariant","discard","struct","asm","union","template","this","packed","goto","sizeof","namespace","noline","volatile","external","flat","input","output","out","attribute","const","uniform","varying","inout","void"];
hxsl_GlslOut.KWDS = (function($this) {
	var $r;
	let _g = new haxe_ds_StringMap();
	{
		let _g1 = 0;
		let _g2 = hxsl_GlslOut.KWD_LIST;
		while(_g1 < _g2.length) {
			let k = _g2[_g1];
			++_g1;
			_g.h[k] = true;
		}
	}
	$r = _g;
	return $r;
}(this));
hxsl_GlslOut.GLOBALS = (function($this) {
	var $r;
	let gl = [];
	{
		let _g = 0;
		let _g1 = hxsl_TGlobal.__empty_constructs__.slice();
		while(_g < _g1.length) {
			let g = _g1[_g];
			++_g;
			let n = "" + Std.string(g);
			n = n.charAt(0).toLowerCase() + HxOverrides.substr(n,1,null);
			gl[g._hx_index] = n;
		}
	}
	gl[hxsl_TGlobal.ToInt._hx_index] = "int";
	gl[hxsl_TGlobal.ToFloat._hx_index] = "float";
	gl[hxsl_TGlobal.ToBool._hx_index] = "bool";
	gl[hxsl_TGlobal.LReflect._hx_index] = "reflect";
	gl[hxsl_TGlobal.Mat3x4._hx_index] = "_mat3x4";
	gl[hxsl_TGlobal.VertexID._hx_index] = "gl_VertexID";
	gl[hxsl_TGlobal.InstanceID._hx_index] = "gl_InstanceID";
	gl[hxsl_TGlobal.IVec2._hx_index] = "ivec2";
	gl[hxsl_TGlobal.IVec3._hx_index] = "ivec3";
	gl[hxsl_TGlobal.IVec4._hx_index] = "ivec4";
	gl[hxsl_TGlobal.BVec2._hx_index] = "bvec2";
	gl[hxsl_TGlobal.BVec3._hx_index] = "bvec3";
	gl[hxsl_TGlobal.BVec4._hx_index] = "bvec4";
	gl[hxsl_TGlobal.FragCoord._hx_index] = "gl_FragCoord";
	gl[hxsl_TGlobal.FrontFacing._hx_index] = "gl_FrontFacing";
	{
		let _g2 = 0;
		while(_g2 < gl.length) {
			let g = gl[_g2];
			++_g2;
			hxsl_GlslOut.KWDS.h[g] = true;
		}
	}
	$r = gl;
	return $r;
}(this));
hxsl_GlslOut.MAT34 = "struct _mat3x4 { vec4 a; vec4 b; vec4 c; };";
hxsl__$Linker_ShaderInfos.UID = 0;
hxsl_Printer.SWIZ = ["x","y","z","w"];
hxsl_RuntimeShader.UID = 0;
hxsl_Serializer.TVECS = new haxe_ds_IntMap();
hxsl_Serializer.BOPS = (function($this) {
	var $r;
	let ops = haxe_macro_Binop.__empty_constructs__.slice();
	ops.splice(haxe_macro_Binop.OpAssignOp(null)._hx_index,0,null);
	$r = ops;
	return $r;
}(this));
hxsl_Serializer.UNOPS = haxe_macro_Unop.__empty_constructs__.slice();
hxsl_Serializer.TGLOBALS = hxsl_TGlobal.__empty_constructs__.slice();
hxsl_Serializer.TSWIZ = new haxe_ds_IntMap();
hxsl_Serializer.REGS = [hxsl_Component.X,hxsl_Component.Y,hxsl_Component.Z,hxsl_Component.W];
hxsl_Serializer.VKINDS = hxsl_VarKind.__empty_constructs__.slice();
hxsl_Serializer.PRECS = hxsl_Prec.__empty_constructs__.slice();
hxsl_Serializer.FKIND = hxsl_FunctionKind.__empty_constructs__.slice();
hxsl_Serializer.SIGN = 9139229;
hxsl_ShaderList.MAX_LIST_SIZE = 0;
hxsl_ShaderList.ALLOW_DUPLICATES = true;
hxsl_ShaderInstance.UID = 0;
hxsl_SharedShader.UNROLL_LOOPS = false;
var mis_MisParser_elementHeadRegEx = new EReg("new\\s+(\\w+)\\((.*?)\\)\\s*{","g");
var mis_MisParser_blockCommentRegEx = new EReg("/\\*(.|\n)*?\\*/","g");
var mis_MisParser_lineCommentRegEx = new EReg("//.*","g");
var mis_MisParser_assignmentRegEx = new EReg("(\\$(?:\\w|\\d)+)\\s*=\\s*(.+?);","g");
var mis_MisParser_marbleAttributesRegEx = new EReg("setMarbleAttributes\\(\"(\\w+)\",\\s*(.+?)\\);","g");
var mis_MisParser_activatePackageRegEx = new EReg("activatePackage\\((.+?)\\);","g");
var mis_MisParser_materialPropertyRegEx = new EReg("new MaterialProperty *\\( *(.+?) *\\)\\s*{\\s*((?:\\w+ *= *(\\d|\\.)+;\\s*)*)}","gi");
var mis_MisParser_addMaterialMappingRegEx = new EReg("addMaterialMapping *\\( *\"(.+?)\" *, *(.+?) *\\)","gi");
modes_NullMode._hx_skip_constructor = false;
net_GameConnection._hx_skip_constructor = false;
net_MasterServerClient.serverIp = "wss://mbomaster.randomityguy.me:8443";
net_MasterServerClient.wsToken = 0;
net_Net.checkPacketTimeout_wsAccum = 0.0;
net_Net.checkPacketTimeout_accum = 0.0;
net_Net.clientIdAllocs = 1;
net_Net.clients = new haxe_ds_ObjectMap();
net_Net.clientIdMap = new haxe_ds_IntMap();
net_Net.stunServers = ["stun:stun.l.google.com:19302"];
net_Net.turnServer = "";
net_Uuid.rndSeed = haxe_Int64Helper.fromFloat(Date.now());
net_Uuid.state0 = net_Uuid.splitmix64_seed(net_Uuid.rndSeed);
net_Uuid.state1 = (function($this) {
	var $r;
	let a = net_Uuid.rndSeed;
	let x = Std.random(10000);
	let b_high = x >> 31;
	let b_low = x;
	let high = a.high + b_high | 0;
	let low = a.low + b_low | 0;
	if(haxe_Int32.ucompare(low,a.low) < 0) {
		++high;
		high = high | 0;
	}
	let a_high = high;
	let b_high1 = 0;
	let b_low1 = 1;
	let high1 = a_high + b_high1 | 0;
	let low1 = low + b_low1 | 0;
	if(haxe_Int32.ucompare(low1,low) < 0) {
		++high1;
		high1 = high1 | 0;
	}
	$r = net_Uuid.splitmix64_seed(new haxe__$Int64__$_$_$Int64(high1,low1));
	return $r;
}(this));
shaders_Billboard.SRC = "HXSLEXNoYWRlcnMuQmlsbGJvYXJkDgEFaW5wdXQNAQECAnV2BQoBAQABAAADBmNhbWVyYQ0CAgQEdmlldwcAAwAFBHByb2oHAAMAAAAABgZnbG9iYWwNAwEHCW1vZGVsVmlldwcABgEDAAAACAVzY2FsZQMCAAEJAQAAAAkIcm90YXRpb24DAgABCQEAAAAKBWNvbG9yBQwCAAEJAQAAAAsQcmVsYXRpdmVQb3NpdGlvbgULBAAADBFwcm9qZWN0ZWRQb3NpdGlvbgUMBAAADQxjYWxjdWxhdGVkVVYFCgQAAA4KcGl4ZWxDb2xvcgUMBAAADwZ2ZXJ0ZXgOBgAAEAhmcmFnbWVudA4GAAARCWJpbGxib2FyZA4GAAASCF9faW5pdF9fDgYAAAQADwAABQQIEwNtaWQDBAAAAQMAAAAAAADgPwMACBQCdXYFCgQAAAICBQoABgQKAg0FCgAAAwYABgAGAQkDAw4BAgkDAwQGAwoCFAUKAAADAhMDAwMDBgEJAwIOAQIJAwMEBgMKAhQFCgQAAwITAwMDAwMCEwMDAwYECgINBQoEAAMGAAYDBgEJAwMOAQIJAwMEBgMKAhQFCgQAAwITAwMDAwYBCQMCDgECCQMDBAYDCgIUBQoAAAMCEwMDAwMDAhMDAwMAARAAAAUBBoECDgUMAgoFDAUMAAMRAhUDcG9zBQoEAAAWBXNjYWxlBQoEAAAFDAUBDQQGAAYBCQMqDgQBAwAAAAAAAAAAAwEDAAAAAAAAAAADAQMAAAAAAAAAAAMBAwAAAAAAAPA/AwUMBAYBAgcHAgQHBwcFDAkDKg4DBgECFQUKAhYFCgUKAQMAAAAAAAAAAAMBAwAAAAAAAAAAAwUMBQwFDAAAAhIAAAUBBgQCDAUMBgEJAhEOAgoCCwULEQAFCgkDKA4CAggDAggDBQoFDAIFBwUMBQwA";
shaders_Blur.SRC = "HXSLDHNoYWRlcnMuQmx1cgsBBWlucHV0DQECAghwb3NpdGlvbgUKAQEAAwJ1dgUKAQEAAQAABAVmbGlwWQMCAAAFBm91dHB1dA0CAgYIcG9zaXRpb24FDAQFAAcFY29sb3IFDAQFAAQAAAgKcGl4ZWxDb2xvcgUMBAAACQxjYWxjdWxhdGVkVVYFCgQAAAoHdGV4dHVyZQoCAAALBmtlcm5lbA8FDAANAgAADAdkaXZpc29yAwIAAA0IX19pbml0X18OBgAADgZ2ZXJ0ZXgOBgAADwhmcmFnbWVudA4GAAADAg0AAAUCBgQCBwUMAggFDAUMBgQCCQUKAgMFCgUKAAAOAAAFAQYEAgYFDAkDKg4ECgICBQoAAAMGAQoCAgUKBAADAgQDAwEDAAAAAAAAAAADAQMAAAAAAADwPwMFDAUMAAEPAAAFBQgQCmFjY3VtQ29sb3IFDAQAAAkDKg4BAQMAAAAAAAAAAAMFDAAOEQFpAQQAAAYVAQIAAAAAAQECDQAAAAEPAQAABQEGgAIQBQwGAQkDIQ4CAgoKBgACAwUKChECCw8FDAANAhEBBQwRAAUKBQoFDAoRAgsPBQwADQIRAQUMCAADBQwFDAAABgQCCAUMBgICEAUMAgwDBQwFDAYECgIIBQwMAAMGAAYACgIIBQwAAAMKAggFDAQAAwMGAgoCCAUMCAADAQMAAAAAAAAIQAMDAwMGgQoCCAUMkgAFCwEDAAAAAAAAAEADBQsA";
shaders_DefaultCubemapMaterial.SRC = "HXSLHnNoYWRlcnMuRGVmYXVsdEN1YmVtYXBNYXRlcmlhbBkBCmRpZmZ1c2VNYXAKAgAAAg1zcGVjdWxhckNvbG9yBQwCAAADCW5vcm1hbE1hcAoCAAAEB2N1YmVNYXAMAgAABQlzaGluaW5lc3MDAgAABhRzZWNvbmRhcnlNYXBVdkZhY3RvcgMCAAAHBmNhbWVyYQ0BAggIcG9zaXRpb24FCwAHAAkDZGlyBQsDBwAAAAAKBmdsb2JhbA0CAwsJbW9kZWxWaWV3BwAKAQMMEm1vZGVsVmlld1RyYW5zcG9zZQcACgEDDRBtb2RlbFZpZXdJbnZlcnNlBwAKAQMAAAAOBWlucHV0DQMGDwhwb3NpdGlvbgULAQ4AEAZub3JtYWwFCwEOABECdXYFCgEOABIBdAULAQ4AEwFiBQsBDgAUAW4FCwEOAAEAABUMY2FsY3VsYXRlZFVWBQoEAAAWCnBpeGVsQ29sb3IFDAQAABcJc3BlY0NvbG9yBQsEAAAYCXNwZWNQb3dlcgMEAAAZGHBpeGVsVHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAGhF0cmFuc2Zvcm1lZE5vcm1hbAULBAAAGwtkb0dhbW1hUmFtcAICAAEAAAAAABwNb3V0UmVmbGVjdFZlYwULAwAAHQtvdXRMaWdodFZlYwUMAwAAHgZvdXRQb3MFCwMAAB8Jb3V0RXllUG9zBQsDAAAgCW91dE5vcm1hbAULAwAAIQdsYW1iZXJ0DgYAACINdHJhbnNwb3NlTWF0Mw4GAAAjBnZlcnRleA4GAAAkCGZyYWdtZW50DgYAAAQDIQIlBm5vcm1hbAULBAAAJg1saWdodFBvc2l0aW9uBQsEAAADBQIIJwZyZXN1bHQDBAAACQMdDgICJQULAiYFCwMADQkDNQ4BAicDAwAAAyIBKAFtBgQAAAYFAQ0JAzIOAwkDKQ4DChECKAYBAgAAAAABBQsAAAMKEQIoBgECAQAAAAEFCwAAAwoRAigGAQICAAAAAQULAAADBQsJAykOAwoRAigGAQIAAAAAAQULBAADChECKAYBAgEAAAABBQsEAAMKEQIoBgECAgAAAAEFCwQAAwULCQMpDgMKEQIoBgECAAAAAAEFCwgAAwoRAigGAQIBAAAAAQULCAADChECKAYBAgIAAAABBQsIAAMFCwYAAAAjAAAFEQgpBmV5ZVBvcwULBAAABgECCAULCQM0DgECDQcIBQsACCoJY3ViZVRyYW5zBgQAAAkDMg4BAgsHBgAIKwpjdWJlRXllUG9zBQsEAAAGAwIIBQsKEQILBwECAwAAAAEFDJIABQsFCwAGBAIVBQoCEQUKBQoILBFvYmpUb1RhbmdlbnRTcGFjZQYEAAAJAzIOAwISBQsCEwULAhQFCwYABgQCHQUMCQMqDgEBAwAAAAAAAAAAAwUMBQwGBAIgBQsCEAULBQsILQppbkxpZ2h0VmVjBQsEAAAGAQkDKQ4DAQOBJsKGp1fivwMBA48ZqIx/n9E/AwED/IwLB0Ky6L8DBQsJAzIOAQIMBwYFCwAGBAoCHQUMkgAFCwYBBwMCLQULBQsCLAYFCwULCC4LY3ViZVZlcnRQb3MFCwQAAAYBAg8FCwIqBgULAAgvCmN1YmVOb3JtYWwFCwQAAAkDHw4BBAYBAhAFCwIqBgULBQsFCwAIMAlleWVUb1ZlcnQFCwQAAAQGAwIuBQsCKwULBQsFCwAGBAIcBQsJAyAOAgIwBQsCLwULBQsFCwgxAXAFCwQAAAIPBQsABgQCHgULBgEEBgICMQULAQMAAAAAAABZQAMFCwULAiwGBQsFCwYEAh8FCwYBBAYCAikFCwEDAAAAAAAAWUADBQsFCwIsBgULBQsGBAoCHQUMDAADCQMZDgIBAwAAAAAAAOC/AwkDHQ4CAiAFCwcDAi0FCwULAwMDAAEkAAAFDwgyB2FtYmllbnQFDAQAAAkDKg4EAQNoke18PzXePwMBA4lBYOXQIts/AwEDZmZmZmZm3j8DAQMAAAAAAADwPwMFDAAIMwdzaGFkaW5nBQwEAAAJAyoOBAEDSOF6FK5H8T8DAQN7FK5H4XrwPwMBA83MzMzMzOw/AwEDAAAAAAAA8D8DBQwACDQHZGlmZnVzZQUMBAAACQMhDgICAQoCFQUKBQwACDUGb3V0Q29sBQwEAAACNAUMAAg2CmJ1bXBOb3JtYWwFCwQAAAYDBgEKCQMhDgICAwoGAQIVBQoCBgMFCgUMkgAFCwEDAAAAAAAAAEADBQsBAwAAAAAAAPA/AwULAAg3B2J1bXBEb3QDBAAABAYBBAYACQMdDgICNgULCgIdBQySAAULAwEDAAAAAAAA8D8DAwMBAwAAAAAAAOA/AwMDAAaBAjUFDAYABAYBAjMFDAI3AwUMBQwCMgUMBQwFDAaAAjUFDAYBCgI0BQwMAAMJAyEOAgIEDAIcBQsFDAUMBQwIOAZleWVWZWMFCwQAAAkDHw4BBAYDAh8FCwIeBQsFCwULBQsACDkHaGFsZkFuZwULBAAACQMfDgEEBgACOAULCgIdBQySAAULBQsFCwULAAg6CXNwZWNWYWx1ZQMEAAAGAQkDNQ4BCQMdDgICNgULAjkFCwMDCgIdBQwMAAMDAAg7CHNwZWN1bGFyBQwEAAAGAQICBQwJAwgOAgI6AwIFAwMFDAAGgAI1BQwGAQI7BQwKAjQFDAwAAwUMBQwLAhsCBQUIPAFhAwQAAAEDHm0csRYf8D8DAAg9AWIDBAAAAQM4vvbMkgDzPwMABgQKAjUFDAAAAwYBAjwDCQMIDgIKAjUFDAAAAwI9AwMDAwYECgI1BQwEAAMGAQI8AwkDCA4CCgI1BQwEAAMCPQMDAwMGBAoCNQUMCAADBgECPAMJAwgOAgoCNQUMCAADAj0DAwMDAAAABgQCFgUMAjUFDAUMAA";
shaders_DefaultCubemapNormalMaterial.SRC = "HXSLJHNoYWRlcnMuRGVmYXVsdEN1YmVtYXBOb3JtYWxNYXRlcmlhbBcBCmRpZmZ1c2VNYXAKAgAAAg1zcGVjdWxhckNvbG9yBQwCAAADCXNoaW5pbmVzcwMCAAAEFHNlY29uZGFyeU1hcFV2RmFjdG9yAwIAAAUHY3ViZU1hcAwCAAAGBmNhbWVyYQ0BAgcIcG9zaXRpb24FCwAGAAgDZGlyBQsDBgAAAAAJBmdsb2JhbA0CAwoJbW9kZWxWaWV3BwAJAQMLEG1vZGVsVmlld0ludmVyc2UHAAkBAwwSbW9kZWxWaWV3VHJhbnNwb3NlBwAJAQMAAAANBWlucHV0DQMGDghwb3NpdGlvbgULAQ0ADwZub3JtYWwFCwENABACdXYFCgENABEBdAULAQ0AEgFiBQsBDQATAW4FCwENAAEAABQMY2FsY3VsYXRlZFVWBQoEAAAVCnBpeGVsQ29sb3IFDAQAABYJc3BlY0NvbG9yBQsEAAAXCXNwZWNQb3dlcgMEAAAYC2RvR2FtbWFSYW1wAgIAAQAAAAAAGQpvdXRTaGFkaW5nBQwDAAAaC291dExpZ2h0VmVjBQwDAAAbCW91dEV5ZVBvcwULAwAAHA1vdXRSZWZsZWN0VmVjBQsDAAAdCW91dE5vcm1hbAULAwAAHgZvdXRQb3MFCwMAAB8HbGFtYmVydA4GAAAgDXRyYW5zcG9zZU1hdDMOBgAAIQZ2ZXJ0ZXgOBgAAIghmcmFnbWVudA4GAAAEAx8CIwZub3JtYWwFCwQAACQNbGlnaHRQb3NpdGlvbgULBAAAAwUCCCUGcmVzdWx0AwQAAAkDHQ4CAiMFCwIkBQsDAA0JAzUOAQIlAwMAAAMgASYBbQYEAAAGBQENCQMyDgMJAykOAwoRAiYGAQIAAAAAAQULAAADChECJgYBAgEAAAABBQsAAAMKEQImBgECAgAAAAEFCwAAAwULCQMpDgMKEQImBgECAAAAAAEFCwQAAwoRAiYGAQIBAAAAAQULBAADChECJgYBAgIAAAABBQsEAAMFCwkDKQ4DChECJgYBAgAAAAABBQsIAAMKEQImBgECAQAAAAEFCwgAAwoRAiYGAQICAAAAAQULCAADBQsGAAAAIQAABRIGBAIUBQoCEAUKBQoGBAIaBQwJAyoOAQEDAAAAAAAAAAADBQwFDAgnCmluTGlnaHRWZWMFCwQAAAYBCQMpDgMBA4EmwoanV+K/AwEDjxmojH+f0T8DAQP8jAsHQrLovwMFCwkDMg4BAgwHBgULAAgoBmV5ZVBvcwULBAAABgECBwULCQM0DgECCwcIBQsABgQCHQULAg8FCwULBgQKAhoFDJIABQsHAwInBQsFCwULBgQKAhoFDAwAAwkDGQ4CAQMAAAAAAADgvwMJAx0OAgIdBQsHAwInBQsFCwMDAwYEAhsFCwIoBQsFCwYEAhkFDAkDKg4BCQM1DgEJAx0OAgcDAicFCwULAh0FCwMDBQwFDAYECgIZBQwMAAMBAwAAAAAAAPA/AwMGgQIZBQwJAyoOBAEDSOF6FK5H8T8DAQN7FK5H4XrwPwMBA83MzMzMzOw/AwEDAAAAAAAA8D8DBQwFDAgpCWN1YmVUcmFucwYEAAAJAzIOAQIKBwYACCoKY3ViZUV5ZVBvcwULBAAABgMCBwULChECCgcBAgMAAAABBQySAAULBQsACCsLY3ViZVZlcnRQb3MFCwQAAAYBAg4FCwIpBgULAAgsCmN1YmVOb3JtYWwFCwQAAAkDHw4BBAYBAg8FCwIpBgULBQsFCwAILQlleWVUb1ZlcnQFCwQAAAQGAwIrBQsCKgULBQsFCwAGBAIcBQsJAyAOAgItBQsCLAULBQsFCwYEAh4FCwIOBQsFCwABIgAABQwILgdkaWZmdXNlBQwEAAAJAyEOAgIBCgIUBQoFDAAILwdhbWJpZW50BQwEAAAJAyoOBAEDaJHtfD813j8DAQOJQWDl0CLbPwMBA2ZmZmZmZt4/AwEDAAAAAAAA8D8DBQwACDAGb3V0Q29sBQwEAAAGAQQGAAIZBQwCLwUMBQwFDAIuBQwFDAAGgAIwBQwGAQoCLgUMDAADCQMhDgICBQwCHAULBQwFDAUMCDEGZXllVmVjBQsEAAAJAx8OAQQGAwIbBQsCHgULBQsFCwULAAgyB2hhbGZBbmcFCwQAAAkDHw4BBAYAAjEFCwoCGgUMkgAFCwULBQsFCwAIMwlzcGVjVmFsdWUDBAAABgEJAzUOAQkDHQ4CAh0FCwIyBQsDAwoCGgUMDAADAwAINAhzcGVjdWxhcgUMBAAABgECAgUMCQMIDgICMwMCAwMDBQwABgQKAjAFDAwAAwEDAAAAAAAA8D8DAwaAAjAFDAYBAjQFDAoCLgUMDAADBQwFDAsCGAIFBQg1AWEDBAAAAQMebRyxFh/wPwMACDYBYgMEAAABAzi+9sySAPM/AwAGBAoCMAUMAAADBgECNQMJAwgOAgoCMAUMAAADAjYDAwMDBgQKAjAFDAQAAwYBAjUDCQMIDgIKAjAFDAQAAwI2AwMDAwYECgIwBQwIAAMGAQI1AwkDCA4CCgIwBQwIAAMCNgMDAwMAAAAGBAIVBQwCMAUMBQwA";
shaders_DefaultCubemapNormalNoSpecMaterial.SRC = "HXSLKnNoYWRlcnMuRGVmYXVsdEN1YmVtYXBOb3JtYWxOb1NwZWNNYXRlcmlhbBIBCmRpZmZ1c2VNYXAKAgAAAgdjdWJlTWFwDAIAAAMUc2Vjb25kYXJ5TWFwVXZGYWN0b3IDAgAABAZjYW1lcmENAQIFCHBvc2l0aW9uBQsABAAGA2RpcgULAwQAAAAABwZnbG9iYWwNAgMICW1vZGVsVmlldwcABwEDCRBtb2RlbFZpZXdJbnZlcnNlBwAHAQMKEm1vZGVsVmlld1RyYW5zcG9zZQcABwEDAAAACwVpbnB1dA0DBgwIcG9zaXRpb24FCwELAA0Gbm9ybWFsBQsBCwAOAnV2BQoBCwAPAXQFCwELABABYgULAQsAEQFuBQsBCwABAAASDGNhbGN1bGF0ZWRVVgUKBAAAEwpwaXhlbENvbG9yBQwEAAAUCXNwZWNDb2xvcgULBAAAFQlzcGVjUG93ZXIDBAAAFhhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAABcRdHJhbnNmb3JtZWROb3JtYWwFCwQAABgKb3V0U2hhZGluZwUMAwAAGQ1vdXRSZWZsZWN0VmVjBQsDAAAaB2xhbWJlcnQOBgAAGw10cmFuc3Bvc2VNYXQzDgYAABwGdmVydGV4DgYAAB0IZnJhZ21lbnQOBgAABAMaAh4Gbm9ybWFsBQsEAAAfDWxpZ2h0UG9zaXRpb24FCwQAAAMFAgggBnJlc3VsdAMEAAAJAx0OAgIeBQsCHwULAwANCQM1DgECIAMDAAADGwEhAW0GBAAABgUBDQkDMg4DCQMpDgMKEQIhBgECAAAAAAEFCwAAAwoRAiEGAQIBAAAAAQULAAADChECIQYBAgIAAAABBQsAAAMFCwkDKQ4DChECIQYBAgAAAAABBQsEAAMKEQIhBgECAQAAAAEFCwQAAwoRAiEGAQICAAAAAQULBAADBQsJAykOAwoRAiEGAQIAAAAAAQULCAADChECIQYBAgEAAAABBQsIAAMKEQIhBgECAgAAAAEFCwgAAwULBgAAABwAAAUNBgQCEgUKAg4FCgUKCCIKaW5MaWdodFZlYwULBAAABgEJAykOAwEDgSbChqdX4r8DAQOPGaiMf5/RPwMBA/yMCwdCsui/AwULCQMyDgECCgcGBQsACCMCcE4FCwQAAAINBQsABgQCGAUMCQMqDgEJAzUOAQkDHQ4CBwMCIgULBQsCIwULAwMFDAUMBgQKAhgFDAwAAwEDAAAAAAAA8D8DAwaBAhgFDAkDKg4EAQNI4XoUrkfxPwMBA3sUrkfhevA/AwEDzczMzMzM7D8DAQMAAAAAAADwPwMFDAUMCCQJY3ViZVRyYW5zBgQAAAkDMg4BAggHBgAIJQpjdWJlRXllUG9zBQsEAAAGAwIFBQsKEQIIBwECAwAAAAEFDJIABQsFCwAIJgFwBQsEAAACDAULAAgnC2N1YmVWZXJ0UG9zBQsEAAAGAQIMBQsCJAYFCwAIKApjdWJlTm9ybWFsBQsEAAAJAx8OAQQGAQINBQsCJAYFCwULBQsACCkJZXllVG9WZXJ0BQsEAAAEBgMCJwULAiUFCwULBQsABgQCGQULCQMgDgICKQULAigFCwULBQsAAR0AAAUHCCoHZGlmZnVzZQUMBAAACQMhDgICAQoCEgUKBQwACCsHYW1iaWVudAUMBAAACQMqDgQBA2iR7Xw/Nd4/AwEDiUFg5dAi2z8DAQNmZmZmZmbePwMBAwAAAAAAAPA/AwUMAAgsBm91dENvbAUMBAAABgEEBgACGAUMAisFDAUMBQwCKgUMBQwACC0LaW5jaWRlbnRSYXkFCwQAAAkDHw4BBgMCFgULAgUFCwULBQsACC4NcmVmbGVjdGlvblJheQULBAAACQMgDgICLQULAhcFCwULAAaAAiwFDAYBCgIqBQwMAAMJAyEOAgICDAIZBQsFDAUMBQwGBAITBQwCLAUMBQwA";
shaders_DefaultDiffuseMaterial.SRC = "HXSLHnNoYWRlcnMuRGVmYXVsdERpZmZ1c2VNYXRlcmlhbAoBCmRpZmZ1c2VNYXAKAgAAAgZjYW1lcmENAQIDCHBvc2l0aW9uBQsAAgAEA2RpcgULAwIAAAAABQZnbG9iYWwNAgMGCW1vZGVsVmlldwcABQEDBxBtb2RlbFZpZXdJbnZlcnNlBwAFAQMIEm1vZGVsVmlld1RyYW5zcG9zZQcABQEDAAAACQVpbnB1dA0DBgoIcG9zaXRpb24FCwEJAAsGbm9ybWFsBQsBCQAMAnV2BQoBCQANAXQFCwEJAA4BYgULAQkADwFuBQsBCQABAAAQDGNhbGN1bGF0ZWRVVgUKBAAAEQpwaXhlbENvbG9yBQwEAAASCm91dFNoYWRpbmcFDAMAABMNdHJhbnNwb3NlTWF0Mw4GAAAUBnZlcnRleA4GAAAVCGZyYWdtZW50DgYAAAMDEwEWAW0GBAAABgUBDQkDMg4DCQMpDgMKEQIWBgECAAAAAAEFCwAAAwoRAhYGAQIBAAAAAQULAAADChECFgYBAgIAAAABBQsAAAMFCwkDKQ4DChECFgYBAgAAAAABBQsEAAMKEQIWBgECAQAAAAEFCwQAAwoRAhYGAQICAAAAAQULBAADBQsJAykOAwoRAhYGAQIAAAAAAQULCAADChECFgYBAgEAAAABBQsIAAMKEQIWBgECAgAAAAEFCwgAAwULBgAAABQAAAUHBgQCEAUKAgwFCgUKCBcRb2JqVG9UYW5nZW50U3BhY2UGBAAACQMyDgMCDQULAg4FCwIPBQsGAAgYCmluTGlnaHRWZWMFCwQAAAYBCQMpDgMBA4EmwoanV+K/AwEDjxmojH+f0T8DAQP8jAsHQrLovwMFCwkDMg4BAggHBgULAAgZAW4FCwQAAAILBQsABgQCEgUMCQMqDgEJAzUOAQkDHQ4CBwMCGAULBQsCGQULAwMFDAUMBgQKAhIFDAwAAwEDAAAAAAAA8D8DAwaBAhIFDAkDKg4EAQNI4XoUrkfxPwMBA3sUrkfhevA/AwEDzczMzMzM7D8DAQMAAAAAAADwPwMFDAUMAAEVAAAFBQgaB2RpZmZ1c2UFDAQAAAkDIQ4CAgEKAhAFCgUMAAgbB2FtYmllbnQFDAQAAAkDKg4EAQNoke18PzXePwMBA4lBYOXQIts/AwEDZmZmZmZm3j8DAQMAAAAAAADwPwMFDAAIHAZvdXRDb2wFDAQAAAYAAhIFDAIbBQwFDAAGgQIcBQwCGgUMBQwGBAIRBQwCHAUMBQwA";
shaders_DefaultMaterial.SRC = "HXSLF3NoYWRlcnMuRGVmYXVsdE1hdGVyaWFsFQEKZGlmZnVzZU1hcAoCAAACDXNwZWN1bGFyQ29sb3IFDAIAAAMJbm9ybWFsTWFwCgIAAAQJc2hpbmluZXNzAwIAAAUUc2Vjb25kYXJ5TWFwVXZGYWN0b3IDAgAABgZjYW1lcmENAQIHCHBvc2l0aW9uBQsABgAIA2RpcgULAwYAAAAACQZnbG9iYWwNAgMKCW1vZGVsVmlldwcACQEDCxBtb2RlbFZpZXdJbnZlcnNlBwAJAQMMEm1vZGVsVmlld1RyYW5zcG9zZQcACQEDAAAADQVpbnB1dA0DBg4IcG9zaXRpb24FCwENAA8Gbm9ybWFsBQsBDQAQAnV2BQoBDQARAXQFCwENABIBYgULAQ0AEwFuBQsBDQABAAAUDGNhbGN1bGF0ZWRVVgUKBAAAFQpwaXhlbENvbG9yBQwEAAAWCXNwZWNDb2xvcgULBAAAFwlzcGVjUG93ZXIDBAAAGAtvdXRMaWdodFZlYwUMAwAAGQZvdXRQb3MFCwMAABoJb3V0RXllUG9zBQsDAAAbCmlzSGFsZlRpbGUCAgABAAAAAAAcC2RvR2FtbWFSYW1wAgIAAQAAAAAAHQdsYW1iZXJ0DgYAAB4NdHJhbnNwb3NlTWF0Mw4GAAAfBnZlcnRleA4GAAAgCGZyYWdtZW50DgYAAAQDHQIhBm5vcm1hbAULBAAAIg1saWdodFBvc2l0aW9uBQsEAAADBQIIIwZyZXN1bHQDBAAACQMdDgICIQULAiIFCwMADQkDNQ4BAiMDAwAAAx4BJAFtBgQAAAYFAQ0JAzIOAwkDKQ4DChECJAYBAgAAAAABBQsAAAMKEQIkBgECAQAAAAEFCwAAAwoRAiQGAQICAAAAAQULAAADBQsJAykOAwoRAiQGAQIAAAAAAQULBAADChECJAYBAgEAAAABBQsEAAMKEQIkBgECAgAAAAEFCwQAAwULCQMpDgMKEQIkBgECAAAAAAEFCwgAAwoRAiQGAQIBAAAAAQULCAADChECJAYBAgIAAAABBQsIAAMFCwYAAAAfAAAFDAYEAhQFCgIQBQoFCgsCGwIFAQaBAhQFCgEDAAAAAAAA4D8DBQoAAAAIJRFvYmpUb1RhbmdlbnRTcGFjZQYEAAAJAzIOAwIRBQsCEgULAhMFCwYABgQCGAUMCQMqDgEBAwAAAAAAAAAAAwUMBQwIJgppbkxpZ2h0VmVjBQsEAAAGAQkDKQ4DAQOBJsKGp1fivwMBA48ZqIx/n9E/AwED/IwLB0Ky6L8DBQsJAzIOAQIMBwYFCwAIJwZleWVQb3MFCwQAAAYBAgcFCwkDNA4BAgsHCAULAAYECgIYBQySAAULBgEHAwImBQsFCwIlBgULBQsIKAFwBQsEAAACDgULAAYEAhkFCwYBBAYCAigFCwEDAAAAAAAAWUADBQsFCwIlBgULBQsGBAIaBQsGAQQGAgInBQsBAwAAAAAAAFlAAwULBQsCJQYFCwULCCkCcE4FCwQAAAIPBQsABgQKAhgFDAwAAwsCGwIJAxkOAgEDAAAAAAAAAAADCQMdDgICKQULBwMCJgULBQsDAwkDGQ4CAQMAAAAAAADgvwMJAx0OAgIpBQsHAwImBQsFCwMDAwMAASAAAAUOCCoKYnVtcE5vcm1hbAULBAAABgMGAQoJAyEOAgIDCgYBAhQFCgIFAwUKBQySAAULAQMAAAAAAAAAQAMFCwEDAAAAAAAA8D8DBQsACCsHYnVtcERvdAMEAAALAhsCCQM1DgEJAx0OAgIqBQsKAhgFDJIABQsDAwQGAQQGAAkDHQ4CAioFCwoCGAUMkgAFCwMBAwAAAAAAAPA/AwMDAQMAAAAAAADgPwMDAwMACCwHZGlmZnVzZQUMBAAACQMhDgICAQoCFAUKBQwACC0HYW1iaWVudAUMBAAACQMqDgQBA2iR7Xw/Nd4/AwEDiUFg5dAi2z8DAQNmZmZmZmbePwMBAwAAAAAAAPA/AwUMAAguBm91dENvbAUMBAAAAiwFDAAILwdzaGFkaW5nBQwEAAAJAyoOBAEDSOF6FK5H8T8DAQN7FK5H4XrwPwMBA83MzMzMzOw/AwEDAAAAAAAA8D8DBQwACwIbAgUBBgQCLgUMBgEGAQIvBQwCLAUMBQwEBgACKwMCLQUMBQwFDAUMBQwABQEGgQIuBQwGAAQGAQIvBQwCKwMFDAUMAi0FDAUMBQwAAAgwBmV5ZVZlYwULBAAACQMfDgEEBgMCGgULAhkFCwULBQsFCwAIMQdoYWxmQW5nBQsEAAAJAx8OAQQGAAIwBQsKAhgFDJIABQsFCwULBQsACDIJc3BlY1ZhbHVlAwQAAAYBCQM1DgEJAx0OAgIqBQsCMQULAwMKAhgFDAwAAwMACDMIc3BlY3VsYXIFDAQAAAYBAgIFDAkDCA4CAjIDAgQDAwUMAAaAAi4FDAYBAjMFDAoCLAUMDAADBQwFDAsCHAIFBQg0AWEDBAAAAQMebRyxFh/wPwMACDUBYgMEAAABAzi+9sySAPM/AwAGBAoCLgUMAAADBgECNAMJAwgOAgoCLgUMAAADAjUDAwMDBgQKAi4FDAQAAwYBAjQDCQMIDgIKAi4FDAQAAwI1AwMDAwYECgIuBQwIAAMGAQI0AwkDCA4CCgIuBQwIAAMCNQMDAwMAAAAGBAIVBQwCLgUMBQwA";
shaders_DefaultNormalMaterial.SRC = "HXSLHXNoYWRlcnMuRGVmYXVsdE5vcm1hbE1hdGVyaWFsFQEKZGlmZnVzZU1hcAoCAAACDXNwZWN1bGFyQ29sb3IFDAIAAAMJc2hpbmluZXNzAwIAAAQUc2Vjb25kYXJ5TWFwVXZGYWN0b3IDAgAABQZjYW1lcmENAQIGCHBvc2l0aW9uBQsABQAHA2RpcgULAwUAAAAACAZnbG9iYWwNAgMJCW1vZGVsVmlldwcACAEDChBtb2RlbFZpZXdJbnZlcnNlBwAIAQMLEm1vZGVsVmlld1RyYW5zcG9zZQcACAEDAAAADAVpbnB1dA0DBg0IcG9zaXRpb24FCwEMAA4Gbm9ybWFsBQsBDAAPAnV2BQoBDAAQAXQFCwEMABEBYgULAQwAEgFuBQsBDAABAAATDGNhbGN1bGF0ZWRVVgUKBAAAFApwaXhlbENvbG9yBQwEAAAVCXNwZWNDb2xvcgULBAAAFglzcGVjUG93ZXIDBAAAFwtkb0dhbW1hUmFtcAICAAEAAAAAABgKb3V0U2hhZGluZwUMAwAAGQtvdXRMaWdodFZlYwUMAwAAGglvdXRFeWVQb3MFCwMAABsJb3V0Tm9ybWFsBQsDAAAcBm91dFBvcwULAwAAHQdsYW1iZXJ0DgYAAB4NdHJhbnNwb3NlTWF0Mw4GAAAfBnZlcnRleA4GAAAgCGZyYWdtZW50DgYAAAQDHQIhBm5vcm1hbAULBAAAIg1saWdodFBvc2l0aW9uBQsEAAADBQIIIwZyZXN1bHQDBAAACQMdDgICIQULAiIFCwMADQkDNQ4BAiMDAwAAAx4BJAFtBgQAAAYFAQ0JAzIOAwkDKQ4DChECJAYBAgAAAAABBQsAAAMKEQIkBgECAQAAAAEFCwAAAwoRAiQGAQICAAAAAQULAAADBQsJAykOAwoRAiQGAQIAAAAAAQULBAADChECJAYBAgEAAAABBQsEAAMKEQIkBgECAgAAAAEFCwQAAwULCQMpDgMKEQIkBgECAAAAAAEFCwgAAwoRAiQGAQIBAAAAAQULCAADChECJAYBAgIAAAABBQsIAAMFCwYAAAAfAAAFDAYEAhMFCgIPBQoFCgYEAhkFDAkDKg4BAQMAAAAAAAAAAAMFDAUMCCUKaW5MaWdodFZlYwULBAAABgEJAykOAwEDgSbChqdX4r8DAQOPGaiMf5/RPwMBA/yMCwdCsui/AwULCQMyDgECCwcGBQsACCYGZXllUG9zBQsEAAAGAQIGBQsJAzQOAQIKBwgFCwAGBAIbBQsCDgULBQsGBAoCGQUMkgAFCwcDAiUFCwULBQsGBAoCGQUMDAADCQMZDgIBAwAAAAAAAOC/AwkDHQ4CAhsFCwcDAiUFCwULAwMDBgQCGgULAiYFCwULBgQCGAUMCQMqDgEJAzUOAQkDHQ4CBwMCJQULBQsCGwULAwMFDAUMBgQKAhgFDAwAAwEDAAAAAAAA8D8DAwaBAhgFDAkDKg4EAQNI4XoUrkfxPwMBA3sUrkfhevA/AwEDzczMzMzM7D8DAQMAAAAAAADwPwMFDAUMBgQCHAULAg0FCwULAAEgAAAFCwgnB2RpZmZ1c2UFDAQAAAkDIQ4CAgEKAhMFCgUMAAgoB2FtYmllbnQFDAQAAAkDKg4EAQNoke18PzXePwMBA4lBYOXQIts/AwEDZmZmZmZm3j8DAQMAAAAAAADwPwMFDAAIKQZvdXRDb2wFDAQAAAYBBAYAAhgFDAIoBQwFDAUMAicFDAUMAAgqBmV5ZVZlYwULBAAACQMfDgEEBgMCGgULAhwFCwULBQsFCwAIKwdoYWxmQW5nBQsEAAAJAx8OAQQGAAIqBQsKAhkFDJIABQsFCwULBQsACCwJc3BlY1ZhbHVlAwQAAAYBCQM1DgEJAx0OAgIbBQsCKwULAwMKAhkFDAwAAwMACC0Ic3BlY3VsYXIFDAQAAAYBAgIFDAkDCA4CAiwDAgMDAwUMAAYECgIpBQwMAAMBAwAAAAAAAPA/AwMGgAIpBQwGAQItBQwKAicFDAwAAwUMBQwLAhcCBQUILgFhAwQAAAEDHm0csRYf8D8DAAgvAWIDBAAAAQM4vvbMkgDzPwMABgQKAikFDAAAAwYBAi4DCQMIDgIKAikFDAAAAwIvAwMDAwYECgIpBQwEAAMGAQIuAwkDCA4CCgIpBQwEAAMCLwMDAwMGBAoCKQUMCAADBgECLgMJAwgOAgoCKQUMCAADAi8DAwMDAAAABgQCFAUMAikFDAUMAA";
shaders_DirLightShader.SRC = "HXSLFnNoYWRlcnMuRGlyTGlnaHRTaGFkZXINAQVjb2xvcgULAgAAAglkaXJlY3Rpb24FCwIAAAMOZW5hYmxlU3BlY3VsYXICAgABAAAAAAAEBmNhbWVyYQ0BAQUIcG9zaXRpb24FCwAEAAAAAAYKbGlnaHRDb2xvcgULBAAABw9saWdodFBpeGVsQ29sb3IFCwQAAAgRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAkTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAACglzcGVjUG93ZXIDBAAACwlzcGVjQ29sb3IFCwQAAAwMY2FsY0xpZ2h0aW5nDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwMMAAULBQUIDwRkaWZmAwQAAAkDFg4CCQMdDgICCAULBwMCAgULBQsDAQMAAAAAAAAAAAMDAAsHAgIDAgINBgECAQULAg8DBQsAAAAIEAFyBQsEAAAJAx8OAQkDIA4CAgIFCwIIBQsFCwULAAgRCXNwZWNWYWx1ZQMEAAAJAxYOAgkDHQ4CAhAFCwkDHw4BBAYDAgUFCwIJBQsFCwULBQsDAQMAAAAAAAAAAAMDAA0GAQIBBQsEBgACDwMGAQILBQsJAwgOAgIRAwIKAwMFCwULBQsFCwAAAA0AAAUCBoAKAgYFC5IABQsJAgwOAAULBQsGBAIGBQsJAzUOAQIGBQsFCwULAAEOAAAFAgaACgIHBQuSAAULCQIMDgAFCwULBgQCBwULCQM1DgECBwULBQsFCwA";
shaders_DtsTexture.SRC = "HXSLEnNoYWRlcnMuRHRzVGV4dHVyZRABBWlucHV0DQECAgJ1dgUKAQEAAwZub3JtYWwFCwEBAAEAAAQGZ2xvYmFsDQICBQltb2RlbFZpZXcHAAQBAwYQbW9kZWxWaWV3SW52ZXJzZQcABAEDAAAABwhhZGRpdGl2ZQICAAEAAAAAAAgJa2lsbEFscGhhAgIAAQAAAAAACQ1zcGVjdWxhckFscGhhAgIAAQAAAAAAChJraWxsQWxwaGFUaHJlc2hvbGQDAgABBwAAAAAAAAAAAAAAAAAA8D8LB3RleHR1cmUKAgAADBBub3JtYWxpemVOb3JtYWxzAgIAAQAAAAAADQtwYXNzVGhyb3VnaAICAAEAAAAAAA4OY3VycmVudE9wYWNpdHkDAgABCQEAAAAPDGNhbGN1bGF0ZWRVVgUKBAAAEApwaXhlbENvbG9yBQwEAAARCXNwZWNDb2xvcgULBAAAEhF0cmFuc2Zvcm1lZE5vcm1hbAULBAAAEwZ2ZXJ0ZXgOBgAAFAhmcmFnbWVudA4GAAACABMAAAUDBgQCDwUKAgIFCgUKBgQCEgULBAYBAgMFCwkDMg4BAgUHBgULBQsFCwsCDAIFAggVDm5vcm1hbGl6ZWRub3JtBQsEAAAJAx8OAQISBQsFCwAGBAISBQsGAgISBQsEBgAGAAYBCgISBQsAAAMKAhIFCwAAAwMGAQoCEgULBAADCgISBQsEAAMDAwYBCgISBQsIAAMKAhIFCwgAAwMDAwULBQsAAAAAARQAAAUDCBYBYwUMBAAACQMhDgICCwoCDwUKBQwACwYOAggCBgkGAwoCFgUMDAADAgoDAwEDAAAAAAAAAAADAgIMAAAACwcCAg0CAgUDCwIHAgYEAhAFDAIWBQwFDAaBAhAFDAIWBQwFDAALAgkCBoECEQULCgIWBQz+AAULBQsAAAaBCgIQBQwMAAMGAQoCFgUMDAADAg4DAwMABQEGgQoCEAUMDAADAg4DAwAAAA";
shaders_EnvMap.SRC = "HXSLDnNoYWRlcnMuRW52TWFwBwEGZW52TWFwDAIAAAIJc2hpbmluZXNzAwIAAAMGY2FtZXJhDQECBAhwb3NpdGlvbgULAAMABQNkaXIFCwMDAAAAAAYKcGl4ZWxDb2xvcgUMBAAABxF0cmFuc2Zvcm1lZE5vcm1hbAULBAAACBhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAkIZnJhZ21lbnQOBgAAAQEJAAAFBQgKB3ZpZXdEaXIFCwQAAAkDHw4BBgMCBAULAggFCwULBQsACAsLaW5jaWRlbnRSYXkFCwQAAAkDHw4BBgMCCAULAgQFCwULBQsACAwNcmVmbGVjdGlvblJheQULBAAACQMgDgICCwULAgcFCwULAAgNDHJlZmxlY3RDb2xvcgUMBAAACQMhDgICAQwCDAULBQwABgQCBgUMCQMYDgMCBgUMAg0FDAICAwUMBQwA";
shaders_GammaRamp.SRC = "HXSLEXNoYWRlcnMuR2FtbWFSYW1wCgEFaW5wdXQNAQICCHBvc2l0aW9uBQoBAQADAnV2BQoBAQABAAAEBWZsaXBZAwIAAAUGb3V0cHV0DQICBghwb3NpdGlvbgUMBAUABwVjb2xvcgUMBAUABAAACApwaXhlbENvbG9yBQwEAAAJDGNhbGN1bGF0ZWRVVgUKBAAACgd0ZXh0dXJlCgIAAAsQZ2FtbWFSYW1wSW52U2l6ZQMCAAAMCF9faW5pdF9fDgYAAA0GdmVydGV4DgYAAA4IZnJhZ21lbnQOBgAAAwIMAAAFAgYEAgcFDAIIBQwFDAYEAgkFCgIDBQoFCgAADQAABQEGBAIGBQwJAyoOBAoCAgUKAAADBgEKAgIFCgQAAwIEAwMBAwAAAAAAAAAAAwEDAAAAAAAA8D8DBQwFDAABDgAABQUIDwhnZXRDb2xvcgUMBAAABgAGAQIIBQwEBgMBAwAAAAAAAPA/AwILAwMDBQwEBgEBAwAAAAAAAOA/AwILAwMDBQwABgQKAggFDAAAAwoJAyEOAgIKCgkDKA4CCgIPBQwAAAMBAwAAAAAAAOA/AwUKBQwAAAMDBgQKAggFDAQAAwoJAyEOAgIKCgkDKA4CCgIPBQwEAAMBAwAAAAAAAOA/AwUKBQwEAAMDBgQKAggFDAgAAwoJAyEOAgIKCgkDKA4CCgIPBQwIAAMBAwAAAAAAAOA/AwUKBQwIAAMDBgQKAggFDAwAAwEDAAAAAAAA8D8DAwA";
shaders_MarbleReflection.SRC = "HXSLGHNoYWRlcnMuTWFyYmxlUmVmbGVjdGlvbggBCnBpeGVsQ29sb3IFDAQAAAIRdHJhbnNmb3JtZWROb3JtYWwFCwQAAAMHdGV4dHVyZQwCAAAEBmNhbWVyYQ0BAQUIcG9zaXRpb24FCwAEAAAAAAYFaW5wdXQNAgIHCHBvc2l0aW9uBQsBBgAIBm5vcm1hbAULAQYAAQAACRhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAAAoHZnJlc25lbA4GAAALCGZyYWdtZW50DgYAAAIDCgMMCWRpcmVjdGlvbgULBAAADQZub3JtYWwFCwQAAA4GaW52ZXJ0AgQAAAMFCAgPCm5EaXJlY3Rpb24FCwQAAAkDHw4BAgwFCwULAAgQB25Ob3JtYWwFCwQAAAkDHw4BAg0FCwULAAgRDWhhbGZEaXJlY3Rpb24FCwQAAAkDHw4BBgACEAULAg8FCwULBQsACBIIZXhwb25lbnQDBAAAAQMAAAAAAAAUQAMACBMGY29zaW5lAwQAAAkDHQ4CAhEFCwIPBQsDAAgUB3Byb2R1Y3QDBAAACQMWDgICEwMBAwAAAAAAAAAAAwMACBUGZmFjdG9yAwQAAAsCDgIGAwEDAAAAAAAA8D8DCQMIDgICFAMCEgMDAwkDCA4CAhQDAhIDAwMADQIVAwAAAQsAAAUGCBYHdmlld0RpcgULBAAACQMfDgEGAwIFBQsCCQULBQsFCwAIFwNmYWMDBAAACQIKDgMCFgULAgIFCwEBAQIDAAgYC2luY2lkZW50UmF5BQsEAAAJAx8OAQYDAgkFCwIFBQsFCwULAAgZDXJlZmxlY3Rpb25SYXkFCwQAAAkDIA4CAhgFCwICBQsFCwAIGgRyZWZsBQwEAAAJAyEOAgIDDAIZBQsFDAAGBAIBBQwJAxgOAwIBBQwCGgUMBgECFwMBA2ZmZmZmZuY/AwMFDAUMAA";
shaders_NoiseTileMaterial.SRC = "HXSLGXNoYWRlcnMuTm9pc2VUaWxlTWF0ZXJpYWwTAQpkaWZmdXNlTWFwCgIAAAINc3BlY3VsYXJDb2xvcgUMAgAAAwlub3JtYWxNYXAKAgAABAhub2lzZU1hcAoCAAAFCXNoaW5pbmVzcwMCAAAGFHNlY29uZGFyeU1hcFV2RmFjdG9yAwIAAAcGY2FtZXJhDQECCAhwb3NpdGlvbgULAAcACQNkaXIFCwMHAAAAAAoGZ2xvYmFsDQIDCwltb2RlbFZpZXcHAAoBAwwQbW9kZWxWaWV3SW52ZXJzZQcACgEDDRJtb2RlbFZpZXdUcmFuc3Bvc2UHAAoBAwAAAA4FaW5wdXQNAwYPCHBvc2l0aW9uBQsBDgAQBm5vcm1hbAULAQ4AEQJ1dgUKAQ4AEgF0BQsBDgATAWIFCwEOABQBbgULAQ4AAQAAFQxjYWxjdWxhdGVkVVYFCgQAABYKcGl4ZWxDb2xvcgUMBAAAFxB1c2VBY2N1cmF0ZU5vaXNlAgIAAQAAAAAAGAtvdXRMaWdodFZlYwUMAwAAGQZvdXRQb3MFCwMAABoJb3V0RXllUG9zBQsDAAAbB2xhbWJlcnQOBgAAHA10cmFuc3Bvc2VNYXQzDgYAAB0GdmVydGV4DgYAAB4IZnJhZ21lbnQOBgAABAMbAh8Gbm9ybWFsBQsEAAAgDWxpZ2h0UG9zaXRpb24FCwQAAAMFAgghBnJlc3VsdAMEAAAJAx0OAgIfBQsCIAULAwANCQM1DgECIQMDAAADHAEiAW0GBAAABgUBDQkDMg4DCQMpDgMKEQIiBgECAAAAAAEFCwAAAwoRAiIGAQIBAAAAAQULAAADChECIgYBAgIAAAABBQsAAAMFCwkDKQ4DChECIgYBAgAAAAABBQsEAAMKEQIiBgECAQAAAAEFCwQAAwoRAiIGAQICAAAAAQULBAADBQsJAykOAwoRAiIGAQIAAAAAAQULCAADChECIgYBAgEAAAABBQsIAAMKEQIiBgECAgAAAAEFCwgAAwULBgAAAB0AAAULBgQCFQUKBgECEQUKAgYDBQoFCggjEW9ialRvVGFuZ2VudFNwYWNlBgQAAAkDMg4DAhIFCwITBQsCFAULBgAGBAIYBQwJAyoOAQEDAAAAAAAAAAADBQwFDAgkCmluTGlnaHRWZWMFCwQAAAYBCQMpDgMBA4EmwoanV+K/AwEDjxmojH+f0T8DAQP8jAsHQrLovwMFCwkDMg4BAg0HBgULAAglBmV5ZVBvcwULBAAABgECCAULCQM0DgECDAcIBQsABgQKAhgFDJIABQsGAQcDAiQFCwULAiMGBQsFCwgmAXAFCwQAAAIPBQsABgQCGQULBgEEBgICJgULAQMAAAAAAABZQAMFCwULAiMGBQsFCwYEAhoFCwYBBAYCAiUFCwEDAAAAAAAAWUADBQsFCwIjBgULBQsIJwFuBQsEAAACEAULAAYECgIYBQwMAAMJAxkOAgEDAAAAAAAAAAADCQMdDgICJwULBwMCJAULBQsDAwMAAR4AAAUVCCgKYnVtcE5vcm1hbAULBAAABgMGAQoJAyEOAgIDCgIVBQoFDJIABQsBAwAAAAAAAABAAwULAQMAAAAAAADwPwMFCwAIKQdidW1wRG90AwQAAAkDNQ4BCQMdDgICKAULCgIYBQySAAULAwMACCoHZGlmZnVzZQUMBAAACQMhDgICAQoCFQUKBQwACCsHYW1iaWVudAUMBAAACQMqDgQBA2iR7Xw/Nd4/AwEDiUFg5dAi2z8DAQNmZmZmZmbePwMBAwAAAAAAAPA/AwUMAAgsCWhhbGZQaXhlbAUKBAAACQMoDgIGAgEDAAAAAAAA8D8DAQMAAAAAAABQQAMDBgIBAwAAAAAAAPA/AwEDAAAAAAAAUEADAwUKAAgtDWZpbmFsTm9pc2VDb2wFDAQAAAAACwIXAgUSCC4Kbm9pc2VJbmRleAUKBAAAAAAILwtub2lzZUNvbG9yMQUMBAAAAAAIMAtub2lzZUNvbG9yMgUMBAAAAAAIMQtub2lzZUNvbG9yMwUMBAAAAAAIMgtub2lzZUNvbG9yNAUMBAAAAAAGBAoCLgUKAAADBgAGAgkDEQ4BBgMKAhUFCgAAAwoCLAUKAAADAwMBAwAAAAAAgE9AAwMGAgEDAAAAAAAA4D8DAQMAAAAAAABQQAMDAwMGBAoCLgUKBAADBgAGAgkDEQ4BBgMKAhUFCgQAAwoCLAUKBAADAwMBAwAAAAAAgE9AAwMGAgEDAAAAAAAA4D8DAQMAAAAAAABQQAMDAwMGBAIvBQwGAwYBCQMhDgICBAoCLgUKBQwBAwAAAAAAAPA/AwUMAQMAAAAAAADgPwMFDAUMBgQKAi4FCgAAAwYABgIJAxEOAQYDCgIVBQoAAAMKAiwFCgAAAwMDAQMAAAAAAIBPQAMDBgIBAwAAAAAAAOA/AwEDAAAAAAAAUEADAwMDBgQKAi4FCgQAAwYABgIJAxEOAQYACgIVBQoEAAMKAiwFCgQAAwMDAQMAAAAAAIBPQAMDBgIBAwAAAAAAAOA/AwEDAAAAAAAAUEADAwMDBgQCMAUMBgMGAQkDIQ4CAgQKAi4FCgUMAQMAAAAAAADwPwMFDAEDAAAAAAAA4D8DBQwFDAYECgIuBQoAAAMGAAYCCQMRDgEGAAoCFQUKAAADCgIsBQoAAAMDAwEDAAAAAACAT0ADAwYCAQMAAAAAAADgPwMBAwAAAAAAAFBAAwMDAwYECgIuBQoEAAMGAAYCCQMRDgEGAAoCFQUKBAADCgIsBQoEAAMDAwEDAAAAAACAT0ADAwYCAQMAAAAAAADgPwMBAwAAAAAAAFBAAwMDAwYEAjEFDAYDBgEJAyEOAgIECgIuBQoFDAEDAAAAAAAA8D8DBQwBAwAAAAAAAOA/AwUMBQwGBAoCLgUKAAADBgAGAgkDEQ4BBgAKAhUFCgAAAwoCLAUKAAADAwMBAwAAAAAAgE9AAwMGAgEDAAAAAAAA4D8DAQMAAAAAAABQQAMDAwMGBAoCLgUKBAADBgAGAgkDEQ4BBgMKAhUFCgQAAwoCLAUKBAADAwMBAwAAAAAAgE9AAwMGAgEDAAAAAAAA4D8DAQMAAAAAAABQQAMDAwMGBAIyBQwGAwYBCQMhDgICBAoCLgUKBQwBAwAAAAAAAPA/AwUMAQMAAAAAAADgPwMFDAUMBgQCLQUMBgIEBgAGAAYAAi8FDAIwBQwFDAIxBQwFDAIyBQwFDAUMAQMAAAAAAAAQQAMFDAUMAAUBBgQCLQUMBgMGAQkDIQ4CAgQKBgAGAgkDEQ4BCgIVBQoRAAUKBQoBAwAAAAAAgE9AAwUKBgIBAwAAAAAAAOA/AwEDAAAAAAAAUEADAwUKBQwBAwAAAAAAAPA/AwUMAQMAAAAAAADgPwMFDAUMAAAIMwhub2lzZUFkZAUMBAAABgECLQUMCgIqBQwMAAMFDAAINAZvdXRDb2wFDAQAAAYAAioFDAIzBQwFDAAINQdzaGFkaW5nBQsEAAAJAykOAwEDSOF6FK5H8T8DAQN7FK5H4XrwPwMBA83MzMzMzOw/AwULAAaBCgI0BQySAAULAjUFCwULBoECNAUMBgACKQMCKwUMBQwFDAg2BmV5ZVZlYwULBAAACQMfDgEEBgMCGgULAhkFCwULBQsFCwAINwdoYWxmQW5nBQsEAAAJAx8OAQQGAAI2BQsKAhgFDJIABQsFCwULBQsACDgJc3BlY1ZhbHVlAwQAAAYBCQM1DgEJAx0OAgIoBQsCNwULAwMKAhgFDAwAAwMACDkIc3BlY3VsYXIFDAQAAAYBAgIFDAkDCA4CAjgDAgUDAwUMAAaAAjQFDAYBAjkFDAoCKgUMDAADBQwFDAg6AWEDBAAAAQMebRyxFh/wPwMACDsBYgMEAAABAzi+9sySAPM/AwAGBAoCNAUMkgAFCwYBAjoDCQMIDgIKAjQFDJIABQsJAykOAQI7AwULBQsFCwULBgQCFgUMAjQFDAUMAA";
shaders_NormalMaterial.SRC = "HXSLFnNoYWRlcnMuTm9ybWFsTWF0ZXJpYWwTAQpkaWZmdXNlTWFwCgIAAAIJbm9ybWFsTWFwCgIAAAMMYW1iaWVudExpZ2h0BQsCAAAECGRpckxpZ2h0BQsCAAAFC2RpckxpZ2h0RGlyBQsCAAAGBmNhbWVyYQ0BAgcIcG9zaXRpb24FCwAGAAgDZGlyBQsDBgAAAAAJBmdsb2JhbA0CAgoJbW9kZWxWaWV3BwAJAQMLEG1vZGVsVmlld0ludmVyc2UHAAkBAwAAAAwFaW5wdXQNAwMNBm5vcm1hbAULAQwADgd0YW5nZW50BQsBDAAPAnV2BQoBDAABAAAQDGNhbGN1bGF0ZWRVVgUKBAAAEQpwaXhlbENvbG9yBQwEAAASCXNwZWNDb2xvcgULBAAAEwlzcGVjUG93ZXIDBAAAFBN0cmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAVEXRyYW5zZm9ybWVkTm9ybWFsBQsEAAAWEnRyYW5zZm9ybWVkVGFuZ2VudAUMAwAAFw5fX2luaXRfX3ZlcnRleA4GAAAYB2xhbWJlcnQOBgAAGQZ2ZXJ0ZXgOBgAAGghmcmFnbWVudA4GAAAEAhcAAAUBBgQCFgUMCQMqDgIGAQIOBQsJAzIOAQIKBwYFCwsGBwkDHQ4CAg4FCwIOBQsDAQMAAAAAAADgPwMCAQMAAAAAAADwPwMBAwAAAAAAAPC/AwMFDAUMAAMYAhsGbm9ybWFsBQsEAAAcDWxpZ2h0UG9zaXRpb24FCwQAAAMFAggdBnJlc3VsdAMEAAAJAx0OAgIbBQsCHAULAwANCQMWDgICHQMBAwAAAAAAAAAAAwMAAAAZAAAFAQYEAhAFCgIPBQoFCgABGgAABRIIHgdkaWZmdXNlBQwEAAAJAyEOAgIBCgIQBQoFDAAIHw1pbmNvbWluZ0xpZ2h0BQsEAAAJAykOAQEDAAAAAAAAAAADBQsACCANc3BlY3VsYXJMaWdodAULBAAACQMpDgEBAwAAAAAAAAAAAwULAAaAAh8FCwIDBQsFCwghAW4FCwQAAAIVBQsACCICbmYFCwQAAAkDOQ4BCQMhDgICAgoCEAUKBQwFCwAIIwR0YW5YBQsEAAAJAx8OAQoCFgUMkgAFCwULAAgkBHRhblkFCwQAAAYBCQMeDgICIQULAiMFCwULBwMKAhYFDAwAAwMFCwAGBAIVBQsJAx8OAQQGAAYABgEKAiIFCwAAAwIjBQsFCwYBCgIiBQsEAAMCJAULBQsFCwYBCgIiBQsIAAMCIQULBQsFCwULBQsFCwglCmFkZGVkTGlnaHQFCwQAAAYBAgQFCwkCGA4CAhUFCwcDAgUFCwULAwULAAaAAh8FCwIlBQsFCwgmAXIFCwQAAAkDHw4BCQMgDgICBQULAhUFCwULBQsACCcJc3BlY0NvbG9yBQsEAAAJAykOAwEDAAAAAAAA8D8DAQMAAAAAAADwPwMBAwAAAAAAAPA/AwULAAgoCXNwZWNWYWx1ZQMEAAAJAxYOAgkDHQ4CAiYFCwkDHw4BBAYDAgcFCwIUBQsFCwULBQsDAQMAAAAAAAAAAAMDAAaAAiAFCwYBBgECJwULCQMIDgICKAMBAwAAAAAAAChAAwMFCwEDmpmZmZmZ6T8DBQsFCwgpBnNoYWRlZAUMBAAABgECHgUMCQMqDgICHwULAQMAAAAAAADwPwMFDAUMAAaACgIpBQySAAULAiAFCwULBgQCEQUMAikFDAUMAA";
shaders_PhongMaterial.SRC = "HXSLFXNoYWRlcnMuUGhvbmdNYXRlcmlhbBgBCmRpZmZ1c2VNYXAKAgAAAglub3JtYWxNYXAKAgAAAwlzaGluaW5lc3MDAgAABA1zcGVjdWxhckNvbG9yBQwCAAAFDGFtYmllbnRMaWdodAULAgAABghkaXJMaWdodAULAgAABwtkaXJMaWdodERpcgULAgAACA11dlNjYWxlRmFjdG9yAwIAAAkKaXNIYWxmVGlsZQICAAEAAAAAAAoGY2FtZXJhDQECCwhwb3NpdGlvbgULAAoADANkaXIFCwMKAAAAAA0GZ2xvYmFsDQICDgltb2RlbFZpZXcHAA0BAw8QbW9kZWxWaWV3SW52ZXJzZQcADQEDAAAAEAVpbnB1dA0DAxEGbm9ybWFsBQsBEAASB3RhbmdlbnQFCwEQABMCdXYFCgEQAAEAABQMY2FsY3VsYXRlZFVWBQoEAAAVCnBpeGVsQ29sb3IFDAQAABYJc3BlY0NvbG9yBQsEAAAXCXNwZWNQb3dlcgMEAAAYE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAABkRdHJhbnNmb3JtZWROb3JtYWwFCwQAABoSdHJhbnNmb3JtZWRUYW5nZW50BQwDAAAbCmZyYWdMaWdodFcDAwAAHA5fX2luaXRfX3ZlcnRleA4GAAAdB2xhbWJlcnQOBgAAHgZ2ZXJ0ZXgOBgAAHwhmcmFnbWVudA4GAAAEAhwAAAUBBgQCGgUMCQMqDgIGAQISBQsJAzIOAQIOBwYFCwsGBwkDHQ4CAhIFCwISBQsDAQMAAAAAAADgPwMCAQMAAAAAAADwPwMBAwAAAAAAAPC/AwMFDAUMAAMdAiAGbm9ybWFsBQsEAAAhDWxpZ2h0UG9zaXRpb24FCwQAAAMFAwsCCQIFAQ0JAzUOAQkDHQ4CAiAFCwIhBQsDAwAAAAAIIgZyZXN1bHQDBAAABAYBBAYACQMdDgICIAULAiEFCwMBAwAAAAAAAPA/AwMDAQMAAAAAAADgPwMDAwANAiIDAAAAHgAABQIGBAIUBQoGAQITBQoCCAMFCgUKBgQCGwMJAxkOAgEDAAAAAAAAAAADCQMdDgICBgULAhEFCwMDAwABHwAABRUIIwdkaWZmdXNlBQwEAAAJAyEOAgIBCgIUBQoFDAAIJAZvdXRDb2wFDAQAAAIjBQwACCUBbgULBAAAAhkFCwAIJgJuZgULBAAACQM5DgEJAyEOAgICCgIUBQoFDAULAAgnBHRhblgFCwQAAAkDHw4BCgIaBQySAAULBQsACCgEdGFuWQULBAAABgEJAx4OAgIlBQsCJwULBQsKAhoFDAwAAwULAAYEAhkFCwkDHw4BBAYABgAGAQoCJgULAAADAicFCwULBgEKAiYFCwQAAwIoBQsFCwULBgEKAiYFCwgAAwIlBQsFCwULBQsFCwULCCkHc2hhZGluZwULBAAACQMpDgMBAwAAAAAAAPA/AwEDAAAAAAAA8D8DAQMF1VC0vLzsPwMFCwAIKgdidW1wRG90AwQAAAkCHQ4CAhkFCwcDAgcFCwULAwALAgkCBoEKAiQFDJIABQsGAAQGAQIpBQsCKgMFCwULAgUFCwULBQsGgQoCJAUMkgAFCwYBAikFCwQGAAIqAwIFBQsFCwULBQsFCwAIKwZleWVWZWMFCwQAAAkDHw4BBAYDAgsFCwIYBQsFCwULBQsACCwHaGFsZkFuZwULBAAACQMfDgEEBgMCKwULAgcFCwULBQsFCwAILQlzcGVjVmFsdWUDBAAABgEJAzUOAQkDHQ4CAhkFCwIsBQsDAwIbAwMACC4Ic3BlY3VsYXIFDAQAAAYBAgQFDAkDCA4CAi0DAgMDAwUMAAaAAiQFDAYBAi4FDAoCIwUMDAADBQwFDAgvAWEDBAAAAQMebRyxFh/wPwMACDABYgMEAAABAzi+9sySAPM/AwAGBAoCJAUMAAADBgECLwMJAwgOAgoCJAUMAAADAjADAwMDBgQKAiQFDAQAAwYBAi8DCQMIDgIKAiQFDAQAAwIwAwMDAwYECgIkBQwIAAMGAQIvAwkDCA4CCgIkBQwIAAMCMAMDAwMGBAIVBQwCJAUMBQwA";
shaders_RefractMaterial.SRC = "HXSLF3NoYWRlcnMuUmVmcmFjdE1hdGVyaWFsFgEKZGlmZnVzZU1hcAoCAAACCnJlZnJhY3RNYXAKAgAAAw1zcGVjdWxhckNvbG9yBQwCAAAECW5vcm1hbE1hcAoCAAAFCXNoaW5pbmVzcwMCAAAGFHNlY29uZGFyeU1hcFV2RmFjdG9yAwIAAAcGY2FtZXJhDQECCAhwb3NpdGlvbgULAAcACQNkaXIFCwMHAAAAAAoGZ2xvYmFsDQIDCwltb2RlbFZpZXcHAAoBAwwQbW9kZWxWaWV3SW52ZXJzZQcACgEDDRJtb2RlbFZpZXdUcmFuc3Bvc2UHAAoBAwAAAA4FaW5wdXQNAwYPCHBvc2l0aW9uBQsBDgAQBm5vcm1hbAULAQ4AEQJ1dgUKAQ4AEgF0BQsBDgATAWIFCwEOABQBbgULAQ4AAQAAFQxjYWxjdWxhdGVkVVYFCgQAABYKcGl4ZWxDb2xvcgUMBAAAFwlzcGVjQ29sb3IFCwQAABgJc3BlY1Bvd2VyAwQAABkRcHJvamVjdGVkUG9zaXRpb24FDAQAABoLb3V0TGlnaHRWZWMFDAMAABsGb3V0UG9zBQsDAAAcCW91dEV5ZVBvcwULAwAAHQtkb0dhbW1hUmFtcAICAAEAAAAAAB4HbGFtYmVydA4GAAAfDXRyYW5zcG9zZU1hdDMOBgAAIAZ2ZXJ0ZXgOBgAAIQhmcmFnbWVudA4GAAAEAx4CIgZub3JtYWwFCwQAACMNbGlnaHRQb3NpdGlvbgULBAAAAwUCCCQGcmVzdWx0AwQAAAkDHQ4CAiIFCwIjBQsDAA0JAzUOAQIkAwMAAAMfASUBbQYEAAAGBQENCQMyDgMJAykOAwoRAiUGAQIAAAAAAQULAAADChECJQYBAgEAAAABBQsAAAMKEQIlBgECAgAAAAEFCwAAAwULCQMpDgMKEQIlBgECAAAAAAEFCwQAAwoRAiUGAQIBAAAAAQULBAADChECJQYBAgIAAAABBQsEAAMFCwkDKQ4DChECJQYBAgAAAAABBQsIAAMKEQIlBgECAQAAAAEFCwgAAwoRAiUGAQICAAAAAQULCAADBQsGAAAAIAAABQsGBAIVBQoCEQUKBQoIJhFvYmpUb1RhbmdlbnRTcGFjZQYEAAAJAzIOAwISBQsCEwULAhQFCwYABgQCGgUMCQMqDgEBAwAAAAAAAAAAAwUMBQwIJwppbkxpZ2h0VmVjBQsEAAAGAQkDKQ4DAQOBJsKGp1fivwMBA48ZqIx/n9E/AwED/IwLB0Ky6L8DBQsJAzIOAQINBwYFCwAIKAZleWVQb3MFCwQAAAYBAggFCwkDNA4BAgwHCAULAAYECgIaBQySAAULBgEHAwInBQsFCwImBgULBQsIKQFwBQsEAAACDwULAAYEAhsFCwYBBAYCAikFCwEDAAAAAAAAWUADBQsFCwImBgULBQsGBAIcBQsGAQQGAgIoBQsBAwAAAAAAAFlAAwULBQsCJgYFCwULCCoBbgULBAAAAhAFCwAGBAoCGgUMDAADCQMZDgIBAwAAAAAAAOC/AwkDHQ4CAioFCwcDAicFCwULAwMDAAEhAAAFDwgrCmJ1bXBOb3JtYWwFCwQAAAYDBgEKCQMhDgICBAoGAQIVBQoCBgMFCgUMkgAFCwEDAAAAAAAAAEADBQsBAwAAAAAAAPA/AwULAAgsCmRpc3RvcnRpb24DBAAAAQMzMzMzMzPTPwMACC0Db2ZmBQwEAAACGQUMAAaACgItBQwRAAUKBgEKAisFCxEABQoCLAMFCgUKCC4McmVmcmFjdENvbG9yBQwEAAAJAyEOAgICCgkDOg4BBgIKAi0FDBEABQoKAi0FDAwAAwUKBQoFDAAILwdkaWZmdXNlBQwEAAAJAyEOAgIBCgIVBQoFDAAIMAdhbWJpZW50BQwEAAAJAyoOBAEDaJHtfD813j8DAQOJQWDl0CLbPwMBA2ZmZmZmZt4/AwEDAAAAAAAA8D8DBQwACDEGb3V0Q29sBQwEAAAGAQIuBQwCLwUMBQwACDIGZXllVmVjBQsEAAAJAx8OAQQGAwIcBQsCGwULBQsFCwULAAgzB2hhbGZBbmcFCwQAAAkDHw4BBAYAAjIFCwoCGgUMkgAFCwULBQsFCwAINAlzcGVjVmFsdWUDBAAABgEJAzUOAQkDHQ4CAisFCwIzBQsDAwoCGgUMDAADAwAINQhzcGVjdWxhcgUMBAAABgECAwUMCQMIDgICNAMCBQMDBQwABoACMQUMBgECNQUMCgIvBQwMAAMFDAUMCwIdAgUFCDYBYQMEAAABAx5tHLEWH/A/AwAINwFiAwQAAAEDOL72zJIA8z8DAAYECgIxBQwAAAMGAQI2AwkDCA4CCgIxBQwAAAMCNwMDAwMGBAoCMQUMBAADBgECNgMJAwgOAgoCMQUMBAADAjcDAwMDBgQKAjEFDAgAAwYBAjYDCQMIDgIKAjEFDAgAAwI3AwMDAwAAAAYEAhYFDAIxBQwFDAA";
shaders_Skybox.SRC = "HXSLDnNoYWRlcnMuU2t5Ym94DAEKcGl4ZWxDb2xvcgUMBAAAAhN0cmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAADEXByb2plY3RlZFBvc2l0aW9uBQwEAAAEB3RleHR1cmUMAgAABQZjYW1lcmENAQUGCHBvc2l0aW9uBQsABQAHCHZpZXdQcm9qBwAFAAgEdmlldwcABQAJBHByb2oHAAUACghwcm9qRmxpcAMABQAAAAALBWlucHV0DQIBDAhwb3NpdGlvbgULAQsAAQAADQZnbG9iYWwNAwEOCW1vZGVsVmlldwcADQEDAAAADwZvdXRwdXQNBAMQCHBvc2l0aW9uBQwEDwARBWNvbG9yBQwEDwASBWRlcHRoAwQPAAQAABMIcHJvak5vcm0FCwQAABQIX19pbml0X18OBgAAFQZ2ZXJ0ZXgOBgAAFghmcmFnbWVudA4GAAADAhQAAAUCBgQCAgULBgECDAULCQM0DgECDgcIBQsFCwYEAgMFDAYBCQMqDgICAgULAQMAAAAAAADwPwMFDAIHBwUMBQwAABUAAAUCBgQCEwULBgMCAgULAgYFCwULBQsGBAIQBQwGAQIDBQwJAyoOBAEDAAAAAAAA8D8DAgoDAQMAAAAAAADwPwMBAwAAAAAAAPA/AwUMBQwFDAABFgAABQEGBAIRBQwKCQMhDgICBAwJAx8OAQITBQsFCwUMkwMFDAUMAA";
shaders_TrivialMaterial.SRC = "HXSLF3NoYWRlcnMuVHJpdmlhbE1hdGVyaWFsBwEKZGlmZnVzZU1hcAoCAAACBmdsb2JhbA0BAgMJbW9kZWxWaWV3BwACAQMEEG1vZGVsVmlld0ludmVyc2UHAAIBAwAAAAUFaW5wdXQNAgYGCHBvc2l0aW9uBQsBBQAHBm5vcm1hbAULAQUACAJ1dgUKAQUACQF0BQsBBQAKAWIFCwEFAAsBbgULAQUAAQAADAxjYWxjdWxhdGVkVVYFCgQAAA0KcGl4ZWxDb2xvcgUMBAAADgZ2ZXJ0ZXgOBgAADwhmcmFnbWVudA4GAAACAA4AAAUBBgQCDAUKAggFCgUKAAEPAAAFAggQB2RpZmZ1c2UFDAQAAAkDIQ4CAgEKAgwFCgUMAAYEAg0FDAYBAhAFDAkDKg4EAQNI4XoUrkfxPwMBA3sUrkfhevA/AwEDzczMzMzM7D8DAQMAAAAAAADwPwMFDAUMBQwA";
shaders_UVRotAnim.SRC = "HXSLEXNoYWRlcnMuVVZSb3RBbmltBQEGZ2xvYmFsDQEBAgR0aW1lAwABAAAAAAMGb2Zmc2V0BQoCAAAECnV2Um90U3BlZWQDAgAABQxjYWxjdWxhdGVkVVYFCgQAAAYGdmVydGV4DgYAAAEABgAABQYIBwFzAwQAAAkDAg4BBgECAgMCBAMDAwAICAFjAwQAAAkDAw4BBgECAgMCBAMDAwAICQF2BQoEAAAGAwIFBQoCAwUKBQoACAoCdngDBAAABgMGAQoCCQUKAAADAggDAwYBCgIJBQoEAAMCBwMDAwAICwJ2eQMEAAAGAAYBCgIJBQoAAAMCBwMDBgEKAgkFCgQAAwIIAwMDAAYEAgUFCgkDKA4CBgAKAgMFCgAAAwIKAwMGAAoCAwUKBAADAgsDAwUKBQoA";
shaders_marble_ClassicGlass.SRC = "HXSLG3NoYWRlcnMubWFyYmxlLkNsYXNzaWNHbGFzcxcBCmRpZmZ1c2VNYXAKAgAAAglub3JtYWxNYXAKAgAAAwZlbnZNYXAMAgAABAlzaGluaW5lc3MDAgAABQ1zcGVjdWxhckNvbG9yBQwCAAAGDXV2U2NhbGVGYWN0b3IDAgAABwZjYW1lcmENAQIICHBvc2l0aW9uBQsABwAJA2RpcgULAwcAAAAACgZnbG9iYWwNAgMLCW1vZGVsVmlldwcACgEDDBJtb2RlbFZpZXdUcmFuc3Bvc2UHAAoBAw0QbW9kZWxWaWV3SW52ZXJzZQcACgEDAAAADgVpbnB1dA0DBA8IcG9zaXRpb24FCwEOABAGbm9ybWFsBQsBDgARAXQFCwEOABICdXYFCgEOAAEAABMMY2FsY3VsYXRlZFVWBQoEAAAUCnBpeGVsQ29sb3IFDAQAABUJc3BlY0NvbG9yBQsEAAAWCXNwZWNQb3dlcgMEAAAXE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAABgRdHJhbnNmb3JtZWROb3JtYWwFCwQAABkYcGl4ZWxUcmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAaEnRyYW5zZm9ybWVkVGFuZ2VudAUMAwAAGwpmcmFnTGlnaHRXAwMAABwHbGFtYmVydA4GAAAdDXRyYW5zcG9zZU1hdDMOBgAAHg5fX2luaXRfX3ZlcnRleA4GAAAfBnZlcnRleA4GAAAgCGZyYWdtZW50DgYAAAUDHAIhBm5vcm1hbAULBAAAIg1saWdodFBvc2l0aW9uBQsEAAADBQIIIwZyZXN1bHQDBAAACQMdDgICIQULAiIFCwMADQkDNQ4BAiMDAwAAAx0BJAFtBgQAAAYFAQ0JAzIOAwkDKQ4DChECJAYBAgAAAAABBQsAAAMKEQIkBgECAQAAAAEFCwAAAwoRAiQGAQICAAAAAQULAAADBQsJAykOAwoRAiQGAQIAAAAAAQULBAADChECJAYBAgEAAAABBQsEAAMKEQIkBgECAgAAAAEFCwQAAwULCQMpDgMKEQIkBgECAAAAAAEFCwgAAwoRAiQGAQIBAAAAAQULCAADChECJAYBAgIAAAABBQsIAAMFCwYAAAIeAAAFAQYEAhoFDAkDKg4CBgECEQULCQMyDgECCwcGBQsLBgcJAx0OAgIRBQsCEQULAwEDAAAAAAAA4D8DAgEDAAAAAAAA8D8DAQMAAAAAAADwvwMDBQwFDAAAHwAABQMGBAITBQoGAQISBQoCBgMFCgUKCCUIZGlyTGlnaHQFCwQAAAkDKQ4DAQOBJsKGp1fivwMBA48ZqIx/n9E/AwED/IwLB0Ky6L8DBQsABgQCGwMJAxkOAgEDAAAAAAAA4L8DCQMdDgICJQULAhAFCwMDAwABIAAABRgIJgh0ZXhDb2xvcgUMBAAACQMhDgICAQoCEwUKBQwACCcJYnVtcENvbG9yBQwEAAAJAyEOAgICCgITBQoFDAAIKARub3JtBQsEAAAJAx8OAQYDBgEKAicFDJIABQsBAwAAAAAAAABAAwULAQMAAAAAAADwPwMFCwULAAaBCgIoBQsAAAMBAwAAAAAAAPC/AwMIKQhkaXJMaWdodAUMBAAACQMqDgQBA0jhehSuR/E/AwEDexSuR+F68D8DAQPNzMzMzMzsPwMBAwAAAAAAAPA/AwUMAAgqC2RpckxpZ2h0RGlyBQsEAAAJAykOAwEDgSbChqdX4r8DAQOPGaiMf5/RPwMBA/yMCwdCsui/AwULAAgrB2RpZmZ1c2UFDAQAAAYBBgECKQUMBAYACQMdDgICKAULBwMCKgULBQsDAQPNzMzMzMz0PwMDAwUMAQMAAAAAAADgPwMFDAAILAZleWVWZWMFCwQAAAkDHw4BBAYDAggFCwIXBQsFCwULBQsACC0HaGFsZkFuZwULBAAACQMfDgEEBgMCLAULAioFCwULBQsFCwAILglzcGVjVmFsdWUDBAAABgEJAzUOAQkDHQ4CAigFCwItBQsDAwIbAwMACC8Ic3BlY3VsYXIFDAQAAAYBAgUFDAkDCA4CAi4DAgQDAwUMAAgwB3ZpZXdEaXIFCwQAAAkDHw4BBgMCCAULAhkFCwULBQsABgQCKAULCQMfDgEEBgECKAULCQMyDgECCwcGBQsFCwULBQsIMQtmcmVzbmVsQmlhcwMEAAABAwAAAAAAAAAAAwAIMgpmcmVzbmVsUG93AwQAAAEDMzMzMzMz8z8DAAgzDGZyZXNuZWxTY2FsZQMEAAABAwAAAAAAAPA/AwAINAtmcmVzbmVsVGVybQMEAAAGAAIxAwYBBgECMwMEBgMBAwAAAAAAAPA/AwIxAwMDAwkDCA4CBgMBAwAAAAAAAPA/AwkDFg4CCQMdDgICMAULAigFCwMBAwAAAAAAAAAAAwMDAjIDAwMDAAg1C2luY2lkZW50UmF5BQsEAAAJAx8OAQYDAhkFCwIIBQsFCwULAAg2DXJlZmxlY3Rpb25SYXkFCwQAAAkDIA4CAjUFCwIoBQsFCwAINwxyZWZsZWN0Q29sb3IFDAQAAAkDIQ4CAgMMAjYFCwUMAAg4Bm91dENvbAUMBAAACQMYDgMGAQImBQwBAzMzMzMzM/M/AwUMAjcFDAI0AwUMAAaBAjgFDAIrBQwFDAaAAjgFDAYBAi8FDAoCJwUMDAADBQwFDAYEAhQFDAI4BQwFDAA";
shaders_marble_ClassicGlassPureSphere.SRC = "HXSLJXNoYWRlcnMubWFyYmxlLkNsYXNzaWNHbGFzc1B1cmVTcGhlcmUUAQpkaWZmdXNlTWFwCgIAAAIJbm9ybWFsTWFwCgIAAAMGZW52TWFwDAIAAAQJc2hpbmluZXNzAwIAAAUNc3BlY3VsYXJDb2xvcgUMAgAABg11dlNjYWxlRmFjdG9yAwIAAAcGY2FtZXJhDQECCAhwb3NpdGlvbgULAAcACQNkaXIFCwMHAAAAAAoGZ2xvYmFsDQIDCwltb2RlbFZpZXcHAAoBAwwSbW9kZWxWaWV3VHJhbnNwb3NlBwAKAQMNEG1vZGVsVmlld0ludmVyc2UHAAoBAwAAAA4FaW5wdXQNAwIPBm5vcm1hbAULAQ4AEAJ1dgUKAQ4AAQAAEQxjYWxjdWxhdGVkVVYFCgQAABIKcGl4ZWxDb2xvcgUMBAAAEwlzcGVjQ29sb3IFCwQAABQJc3BlY1Bvd2VyAwQAABUTdHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAFhF0cmFuc2Zvcm1lZE5vcm1hbAULBAAAFxhwaXhlbFRyYW5zZm9ybWVkUG9zaXRpb24FCwQAABgKZnJhZ0xpZ2h0VwMDAAAZB2xhbWJlcnQOBgAAGgZ2ZXJ0ZXgOBgAAGwhmcmFnbWVudA4GAAADAxkCHAZub3JtYWwFCwQAAB0NbGlnaHRQb3NpdGlvbgULBAAAAwUCCB4GcmVzdWx0AwQAAAkDHQ4CAhwFCwIdBQsDAA0JAzUOAQIeAwMAAAAaAAAFAwYEAhEFCgYBAhAFCgIGAwUKBQoIHwhkaXJMaWdodAULBAAACQMpDgMBA4EmwoanV+K/AwEDjxmojH+f0T8DAQP8jAsHQrLovwMFCwAGBAIYAwkDGQ4CAQMAAAAAAADgvwMJAx0OAgIfBQsCDwULAwMDAAEbAAAFFQggCHRleENvbG9yBQwEAAAJAyEOAgIBCgIRBQoFDAAIIQlidW1wQ29sb3IFDAQAAAkDIQ4CAgIKAhEFCgUMAAgiCGRpckxpZ2h0BQwEAAAJAyoOBAEDSOF6FK5H8T8DAQN7FK5H4XrwPwMBA83MzMzMzOw/AwEDAAAAAAAA8D8DBQwACCMLZGlyTGlnaHREaXIFCwQAAAkDKQ4DAQOBJsKGp1fivwMBA48ZqIx/n9E/AwED/IwLB0Ky6L8DBQsACCQHZGlmZnVzZQUMBAAABgEGAQIiBQwEBgAJAx0OAgIWBQsHAwIjBQsFCwMBA83MzMzMzPQ/AwMDBQwBAwAAAAAAAOA/AwUMAAglBmV5ZVZlYwULBAAACQMfDgEEBgMCCAULAhUFCwULBQsFCwAIJgdoYWxmQW5nBQsEAAAJAx8OAQQGAwIlBQsCIwULBQsFCwULAAgnCXNwZWNWYWx1ZQMEAAAGAQkDNQ4BCQMdDgICFgULAiYFCwMDAhgDAwAIKAhzcGVjdWxhcgUMBAAABgECBQUMCQMIDgICJwMCBAMDBQwACCkHdmlld0RpcgULBAAACQMfDgEGAwIIBQsCFwULBQsFCwAIKgtmcmVzbmVsQmlhcwMEAAABAwAAAAAAAAAAAwAIKwpmcmVzbmVsUG93AwQAAAEDMzMzMzMz8z8DAAgsDGZyZXNuZWxTY2FsZQMEAAABAwAAAAAAAPA/AwAILQtmcmVzbmVsVGVybQMEAAAGAAIqAwYBBgECLAMEBgMBAwAAAAAAAPA/AwIqAwMDAwkDCA4CBgMBAwAAAAAAAPA/AwkDFg4CCQMdDgICKQULAhYFCwMBAwAAAAAAAAAAAwMDAisDAwMDAAguC2luY2lkZW50UmF5BQsEAAAJAx8OAQYDAhcFCwIIBQsFCwULAAgvDXJlZmxlY3Rpb25SYXkFCwQAAAkDIA4CAi4FCwIWBQsFCwAIMAxyZWZsZWN0Q29sb3IFDAQAAAkDIQ4CAgMMAi8FCwUMAAgxBm91dENvbAUMBAAACQMYDgMGAQIgBQwBAzMzMzMzM/M/AwUMAjAFDAItAwUMAAaBAjEFDAIkBQwFDAaAAjEFDAYBAigFDAoCIQUMDAADBQwFDAYEAhIFDAIxBQwFDAA";
shaders_marble_ClassicMarb.SRC = "HXSLGnNoYWRlcnMubWFyYmxlLkNsYXNzaWNNYXJiEwEKZGlmZnVzZU1hcAoCAAACBmVudk1hcAwCAAADCXNoaW5pbmVzcwMCAAAEDXNwZWN1bGFyQ29sb3IFDAIAAAUNdXZTY2FsZUZhY3RvcgMCAAAGBmNhbWVyYQ0BAgcIcG9zaXRpb24FCwAGAAgDZGlyBQsDBgAAAAAJBmdsb2JhbA0CAwoJbW9kZWxWaWV3BwAJAQMLEm1vZGVsVmlld1RyYW5zcG9zZQcACQEDDBBtb2RlbFZpZXdJbnZlcnNlBwAJAQMAAAANBWlucHV0DQMCDgZub3JtYWwFCwENAA8CdXYFCgENAAEAABAMY2FsY3VsYXRlZFVWBQoEAAARCnBpeGVsQ29sb3IFDAQAABIJc3BlY0NvbG9yBQsEAAATCXNwZWNQb3dlcgMEAAAUE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAABURdHJhbnNmb3JtZWROb3JtYWwFCwQAABYYcGl4ZWxUcmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAXCmZyYWdMaWdodFcDAwAAGAdsYW1iZXJ0DgYAABkGdmVydGV4DgYAABoIZnJhZ21lbnQOBgAAAwMYAhsGbm9ybWFsBQsEAAAcDWxpZ2h0UG9zaXRpb24FCwQAAAMFAggdBnJlc3VsdAMEAAAJAx0OAgIbBQsCHAULAwANCQM1DgECHQMDAAAAGQAABQMGBAIQBQoGAQIPBQoCBQMFCgUKCB4IZGlyTGlnaHQFCwQAAAkDKQ4DAQOBJsKGp1fivwMBA48ZqIx/n9E/AwED/IwLB0Ky6L8DBQsABgQCFwMJAxkOAgEDAAAAAAAA4L8DCQMdDgICHgULAg4FCwMDAwABGgAABRQIHwh0ZXhDb2xvcgUMBAAACQMhDgICAQoCEAUKBQwACCAIZGlyTGlnaHQFDAQAAAkDKg4EAQNI4XoUrkfxPwMBA3sUrkfhevA/AwEDzczMzMzM7D8DAQMAAAAAAADwPwMFDAAIIQtkaXJMaWdodERpcgULBAAACQMpDgMBA4EmwoanV+K/AwEDjxmojH+f0T8DAQP8jAsHQrLovwMFCwAIIgdkaWZmdXNlBQwEAAAGAQIgBQwEBgAEBgEEBgAJAx0OAgIVBQsHAwIhBQsFCwMBAwAAAAAAAPA/AwMDAQMAAAAAAADgPwMDAwEDmpmZmZmZ2T8DAwMFDAAIIwZleWVWZWMFCwQAAAkDHw4BBAYDAgcFCwIUBQsFCwULBQsACCQHaGFsZkFuZwULBAAACQMfDgEEBgMCIwULAiEFCwULBQsFCwAIJQlzcGVjVmFsdWUDBAAABgEJAzUOAQkDHQ4CAhUFCwIkBQsDAwIXAwMACCYIc3BlY3VsYXIFDAQAAAYBAgQFDAkDCA4CAiUDAgMDAwUMAAgnB3ZpZXdEaXIFCwQAAAkDHw4BBgMCBwULAhYFCwULBQsACCgLZnJlc25lbEJpYXMDBAAAAQMAAAAAAAAAAAMACCkKZnJlc25lbFBvdwMEAAABAzMzMzMzM/M/AwAIKgxmcmVzbmVsU2NhbGUDBAAAAQMAAAAAAADwPwMACCsLZnJlc25lbFRlcm0DBAAABgACKAMGAQYBAioDBAYDAQMAAAAAAADwPwMCKAMDAwMJAwgOAgYDAQMAAAAAAADwPwMJAxYOAgkDHQ4CAicFCwIVBQsDAQMAAAAAAAAAAAMDAwIpAwMDAwAILAtpbmNpZGVudFJheQULBAAACQMfDgEGAwIWBQsCBwULBQsFCwAILQ1yZWZsZWN0aW9uUmF5BQsEAAAJAyAOAgIsBQsCFQULBQsACC4McmVmbGVjdENvbG9yBQwEAAAJAyEOAgICDAItBQsFDAAILwZvdXRDb2wFDAQAAAkDGA4DBgECHwUMAQMzMzMzMzPzPwMFDAIuBQwCKwMFDAAGgQIvBQwCIgUMBQwGgAIvBQwGAQImBQwBAwAAAAAAAOA/AwUMBQwGBAIRBQwCLwUMBQwA";
shaders_marble_ClassicMarb2.SRC = "HXSLG3NoYWRlcnMubWFyYmxlLkNsYXNzaWNNYXJiMhMBCmRpZmZ1c2VNYXAKAgAAAgZlbnZNYXAMAgAAAwlzaGluaW5lc3MDAgAABA1zcGVjdWxhckNvbG9yBQwCAAAFDXV2U2NhbGVGYWN0b3IDAgAABgZjYW1lcmENAQIHCHBvc2l0aW9uBQsABgAIA2RpcgULAwYAAAAACQZnbG9iYWwNAgMKCW1vZGVsVmlldwcACQEDCxJtb2RlbFZpZXdUcmFuc3Bvc2UHAAkBAwwQbW9kZWxWaWV3SW52ZXJzZQcACQEDAAAADQVpbnB1dA0DAg4Gbm9ybWFsBQsBDQAPAnV2BQoBDQABAAAQDGNhbGN1bGF0ZWRVVgUKBAAAEQpwaXhlbENvbG9yBQwEAAASCXNwZWNDb2xvcgULBAAAEwlzcGVjUG93ZXIDBAAAFBN0cmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAVEXRyYW5zZm9ybWVkTm9ybWFsBQsEAAAWGHBpeGVsVHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAFwpmcmFnTGlnaHRXAwMAABgHbGFtYmVydA4GAAAZBnZlcnRleA4GAAAaCGZyYWdtZW50DgYAAAMDGAIbBm5vcm1hbAULBAAAHA1saWdodFBvc2l0aW9uBQsEAAADBQIIHQZyZXN1bHQDBAAACQMdDgICGwULAhwFCwMADQkDNQ4BAh0DAwAAABkAAAUDBgQCEAUKBgECDwUKAgUDBQoFCggeCGRpckxpZ2h0BQsEAAAJAykOAwEDgSbChqdX4r8DAQOPGaiMf5/RPwMBA/yMCwdCsui/AwULAAYEAhcDCQMZDgIBAwAAAAAAAOC/AwkDHQ4CAh4FCwIOBQsDAwMAARoAAAUPCB8IdGV4Q29sb3IFDAQAAAkDIQ4CAgEKAhAFCgUMAAggCGRpckxpZ2h0BQwEAAAJAyoOBAEDSOF6FK5H8T8DAQN7FK5H4XrwPwMBA83MzMzMzOw/AwEDAAAAAAAA8D8DBQwACCELZGlyTGlnaHREaXIFCwQAAAkDKQ4DAQOBJsKGp1fivwMBA48ZqIx/n9E/AwED/IwLB0Ky6L8DBQsACCIHZGlmZnVzZQUMBAAABgEGAQIgBQwEBgAJAx0OAgIVBQsHAwIhBQsFCwMBA83MzMzMzPQ/AwMDBQwBAwAAAAAAAOA/AwUMAAgjBmV5ZVZlYwULBAAACQMfDgEEBgMCBwULAhQFCwULBQsFCwAIJAdoYWxmQW5nBQsEAAAJAx8OAQQGAwIjBQsCIQULBQsFCwULAAglCXNwZWNWYWx1ZQMEAAAGAQkDNQ4BCQMdDgICFQULAiQFCwMDAhcDAwAIJghzcGVjdWxhcgUMBAAABgECBAUMCQMIDgICJQMCAwMDBQwACCcHdmlld0RpcgULBAAACQMfDgEGAwIHBQsCFgULBQsFCwAIKAtpbmNpZGVudFJheQULBAAACQMfDgEGAwIWBQsCBwULBQsFCwAIKQ1yZWZsZWN0aW9uUmF5BQsEAAAJAyAOAgIoBQsCFQULBQsACCoMcmVmbGVjdENvbG9yBQwEAAAJAyEOAgICDAIpBQsFDAAIKwZvdXRDb2wFDAQAAAkDGA4DBgEGAQIfBQwCIgUMBQwBAzMzMzMzM/M/AwUMBgECKgUMAiIFDAUMCgIfBQwMAAMFDAAGgAIrBQwGAQYBAiYFDAoCHwUMDAADBQwBAwAAAAAAAOA/AwUMBQwGBAIRBQwCKwUMBQwA";
shaders_marble_ClassicMarb3.SRC = "HXSLG3NoYWRlcnMubWFyYmxlLkNsYXNzaWNNYXJiMxMBCmRpZmZ1c2VNYXAKAgAAAgZlbnZNYXAMAgAAAwlzaGluaW5lc3MDAgAABA1zcGVjdWxhckNvbG9yBQwCAAAFDXV2U2NhbGVGYWN0b3IDAgAABgZjYW1lcmENAQIHCHBvc2l0aW9uBQsABgAIA2RpcgULAwYAAAAACQZnbG9iYWwNAgMKCW1vZGVsVmlldwcACQEDCxJtb2RlbFZpZXdUcmFuc3Bvc2UHAAkBAwwQbW9kZWxWaWV3SW52ZXJzZQcACQEDAAAADQVpbnB1dA0DAg4Gbm9ybWFsBQsBDQAPAnV2BQoBDQABAAAQDGNhbGN1bGF0ZWRVVgUKBAAAEQpwaXhlbENvbG9yBQwEAAASCXNwZWNDb2xvcgULBAAAEwlzcGVjUG93ZXIDBAAAFBN0cmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAVEXRyYW5zZm9ybWVkTm9ybWFsBQsEAAAWGHBpeGVsVHJhbnNmb3JtZWRQb3NpdGlvbgULBAAAFwpmcmFnTGlnaHRXAwMAABgHbGFtYmVydA4GAAAZBnZlcnRleA4GAAAaCGZyYWdtZW50DgYAAAMDGAIbBm5vcm1hbAULBAAAHA1saWdodFBvc2l0aW9uBQsEAAADBQIIHQZyZXN1bHQDBAAACQMdDgICGwULAhwFCwMADQkDNQ4BAh0DAwAAABkAAAUDBgQCEAUKBgECDwUKAgUDBQoFCggeCGRpckxpZ2h0BQsEAAAJAykOAwEDgSbChqdX4r8DAQOPGaiMf5/RPwMBA/yMCwdCsui/AwULAAYEAhcDCQMZDgIBAwAAAAAAAOC/AwkDHQ4CAh4FCwIOBQsDAwMAARoAAAURCB8IdGV4Q29sb3IFDAQAAAkDIQ4CAgEKAhAFCgUMAAggCGRpckxpZ2h0BQwEAAAJAyoOBAEDSOF6FK5H8T8DAQN7FK5H4XrwPwMBA83MzMzMzOw/AwEDAAAAAAAA8D8DBQwACCELZGlyTGlnaHREaXIFCwQAAAkDKQ4DAQOBJsKGp1fivwMBA48ZqIx/n9E/AwED/IwLB0Ky6L8DBQsACCIHZGlmZnVzZQUMBAAABgEGAQIgBQwEBgAJAx0OAgIVBQsHAwIhBQsFCwMBA83MzMzMzPQ/AwMDBQwBAwAAAAAAAOA/AwUMAAgjBmV5ZVZlYwULBAAACQMfDgEEBgMCBwULAhQFCwULBQsFCwAIJAdoYWxmQW5nBQsEAAAJAx8OAQQGAwIjBQsCIQULBQsFCwULAAglCXNwZWNWYWx1ZQMEAAAGAQkDNQ4BCQMdDgICFQULAiQFCwMDAhcDAwAIJghzcGVjdWxhcgUMBAAABgECBAUMCQMIDgICJQMCAwMDBQwACCcHdmlld0RpcgULBAAACQMfDgEGAwIHBQsCFgULBQsFCwAIKAtpbmNpZGVudFJheQULBAAACQMfDgEGAwIWBQsCBwULBQsFCwAIKQ1yZWZsZWN0aW9uUmF5BQsEAAAJAyAOAgIoBQsCFQULBQsACCoMcmVmbGVjdENvbG9yBQwEAAAJAyEOAgICDAIpBQsFDAAIKwhhdmdDb2xvcgUMBAAACQMqDgEGAgQGAAYACgIqBQwAAAMKAioFDAQAAwMKAioFDAgAAwMDAQMAAAAAAAAIQAMDBQwACCwRZmluYWxSZWZsZWN0Q29sb3IFDAQAAAkDGA4DAioFDAIrBQwBAwAAAAAAAPA/AwUMAAgtBm91dENvbAUMBAAACQMYDgMGAQYBAh8FDAIiBQwFDAEDMzMzMzMz8z8DBQwGAQIsBQwCIgUMBQwKAh8FDAwAAwUMAAaAAi0FDAYBAiYFDAEDAAAAAAAA4D8DBQwFDAYEAhEFDAItBQwFDAA";
shaders_marble_ClassicMetal.SRC = "HXSLG3NoYWRlcnMubWFyYmxlLkNsYXNzaWNNZXRhbBYBCmRpZmZ1c2VNYXAKAgAAAglub3JtYWxNYXAKAgAAAwZlbnZNYXAMAgAABAlzaGluaW5lc3MDAgAABQ1zcGVjdWxhckNvbG9yBQwCAAAGDXV2U2NhbGVGYWN0b3IDAgAABwZjYW1lcmENAQIICHBvc2l0aW9uBQsABwAJA2RpcgULAwcAAAAACgZnbG9iYWwNAgMLCW1vZGVsVmlldwcACgEDDBJtb2RlbFZpZXdUcmFuc3Bvc2UHAAoBAw0QbW9kZWxWaWV3SW52ZXJzZQcACgEDAAAADgVpbnB1dA0DAw8Gbm9ybWFsBQsBDgAQAXQFCwEOABECdXYFCgEOAAEAABIMY2FsY3VsYXRlZFVWBQoEAAATCnBpeGVsQ29sb3IFDAQAABQJc3BlY0NvbG9yBQsEAAAVCXNwZWNQb3dlcgMEAAAWE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAABcRdHJhbnNmb3JtZWROb3JtYWwFCwQAABgYcGl4ZWxUcmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAZEnRyYW5zZm9ybWVkVGFuZ2VudAUMAwAAGgpmcmFnTGlnaHRXAwMAABsHbGFtYmVydA4GAAAcDl9faW5pdF9fdmVydGV4DgYAAB0GdmVydGV4DgYAAB4IZnJhZ21lbnQOBgAABAMbAh8Gbm9ybWFsBQsEAAAgDWxpZ2h0UG9zaXRpb24FCwQAAAMFAgghBnJlc3VsdAMEAAAJAx0OAgIfBQsCIAULAwANCQM1DgECIQMDAAACHAAABQEGBAIZBQwJAyoOAgYBAhAFCwkDMg4BAgsHBgULCwYHCQMdDgICEAULAhAFCwMBAwAAAAAAAOA/AwIBAwAAAAAAAPA/AwEDAAAAAAAA8L8DAwUMBQwAAB0AAAUDBgQCEgUKBgECEQUKAgYDBQoFCggiCGRpckxpZ2h0BQsEAAAJAykOAwEDgSbChqdX4r8DAQOPGaiMf5/RPwMBA/yMCwdCsui/AwULAAYEAhoDCQMZDgIBAwAAAAAAAOC/AwkDHQ4CAiIFCwIPBQsDAwMAAR4AAAUZCCMIdGV4Q29sb3IFDAQAAAkDIQ4CAgEKAhIFCgUMAAgkCWJ1bXBDb2xvcgUMBAAACQMhDgICAgoCEgUKBQwACCUEbm9ybQULBAAACQMfDgEGAwYBCgIkBQySAAULAQMAAAAAAAAAQAMFCwEDAAAAAAAA8D8DBQsFCwAGgQoCJQULAAADAQMAAAAAAADwvwMDCCYIZGlyTGlnaHQFDAQAAAkDKg4EAQNI4XoUrkfxPwMBA3sUrkfhevA/AwEDzczMzMzM7D8DAQMAAAAAAADwPwMFDAAIJwtkaXJMaWdodERpcgULBAAACQMpDgMBA4EmwoanV+K/AwEDjxmojH+f0T8DAQP8jAsHQrLovwMFCwAIKAdkaWZmdXNlBQwEAAAGAQYBAiYFDAQGAAkDHQ4CAiUFCwcDAicFCwULAwEDzczMzMzM9D8DAwMFDAEDAAAAAAAA4D8DBQwACCkGZXllVmVjBQsEAAAJAx8OAQQGAwIIBQsCFgULBQsFCwULAAgqB2hhbGZBbmcFCwQAAAkDHw4BBAYDAikFCwInBQsFCwULBQsACCsJc3BlY1ZhbHVlAwQAAAYBCQM1DgEJAx0OAgIlBQsCKgULAwMCGgMDAAgsCHNwZWN1bGFyBQwEAAAGAQIFBQwJAwgOAgIrAwIEAwMFDAAILQd2aWV3RGlyBQsEAAAJAx8OAQYDAggFCwIYBQsFCwULAAYEAiUFCwkDHw4BBAYBAiUFCwkDMg4BAgsHBgULBQsFCwULCC4LZnJlc25lbEJpYXMDBAAAAQMAAAAAAAAAAAMACC8KZnJlc25lbFBvdwMEAAABAzMzMzMzM/M/AwAIMAxmcmVzbmVsU2NhbGUDBAAAAQMAAAAAAADwPwMACDELZnJlc25lbFRlcm0DBAAABgACLgMGAQYBAjADBAYDAQMAAAAAAADwPwMCLgMDAwMJAwgOAgYDAQMAAAAAAADwPwMJAxYOAgkDHQ4CAi0FCwIlBQsDAQMAAAAAAAAAAAMDAwIvAwMDAwAIMgtpbmNpZGVudFJheQULBAAACQMfDgEGAwIYBQsCCAULBQsFCwAIMw1yZWZsZWN0aW9uUmF5BQsEAAAJAyAOAgIyBQsCJQULBQsACDQMcmVmbGVjdENvbG9yBQwEAAAJAyEOAgIDDAIzBQsFDAAINRFmaW5hbFJlZmxlY3RDb2xvcgUMBAAACQMqDgEGAgQGAAYACgI0BQwAAAMKAjQFDAQAAwMKAjQFDAgAAwMDAQMAAAAAAAAIQAMDBQwACDYGb3V0Q29sBQwEAAAGAQIjBQwJAxgOAwkDKg4BAQMAAAAAAADwPwMFDAI1BQwKAiQFDAwAAwUMBQwABoECNgUMAigFDAUMBoACNgUMBgECLAUMCgIkBQwMAAMFDAUMBgQCEwUMAjYFDAUMAA";
shaders_marble_CrystalMarb.SRC = "HXSLGnNoYWRlcnMubWFyYmxlLkNyeXN0YWxNYXJiFQEKZGlmZnVzZU1hcAoCAAACCW5vcm1hbE1hcAoCAAADBmVudk1hcAwCAAAEDXV2U2NhbGVGYWN0b3IDAgAABQZjYW1lcmENAQIGCHBvc2l0aW9uBQsABQAHA2RpcgULAwUAAAAACAZnbG9iYWwNAgMJCW1vZGVsVmlldwcACAEDChJtb2RlbFZpZXdUcmFuc3Bvc2UHAAgBAwsQbW9kZWxWaWV3SW52ZXJzZQcACAEDAAAADAVpbnB1dA0DBA0IcG9zaXRpb24FCwEMAA4Gbm9ybWFsBQsBDAAPAXQFCwEMABACdXYFCgEMAAEAABEMY2FsY3VsYXRlZFVWBQoEAAASCnBpeGVsQ29sb3IFDAQAABMJc3BlY0NvbG9yBQsEAAAUCXNwZWNQb3dlcgMEAAAVE3RyYW5zZm9ybWVkUG9zaXRpb24FCwQAABYRdHJhbnNmb3JtZWROb3JtYWwFCwQAABcYcGl4ZWxUcmFuc2Zvcm1lZFBvc2l0aW9uBQsEAAAYEnRyYW5zZm9ybWVkVGFuZ2VudAUMAwAAGQdsYW1iZXJ0DgYAABoNdHJhbnNwb3NlTWF0Mw4GAAAbB3JlZnJhY3QOBgAAHA5fX2luaXRfX3ZlcnRleA4GAAAdBnZlcnRleA4GAAAeCGZyYWdtZW50DgYAAAYDGQIfBm5vcm1hbAULBAAAIA1saWdodFBvc2l0aW9uBQsEAAADBQIIIQZyZXN1bHQDBAAACQMdDgICHwULAiAFCwMADQkDNQ4BAiEDAwAAAxoBIgFtBgQAAAYFAQ0JAzIOAwkDKQ4DChECIgYBAgAAAAABBQsAAAMKEQIiBgECAQAAAAEFCwAAAwoRAiIGAQICAAAAAQULAAADBQsJAykOAwoRAiIGAQIAAAAAAQULBAADChECIgYBAgEAAAABBQsEAAMKEQIiBgECAgAAAAEFCwQAAwULCQMpDgMKEQIiBgECAAAAAAEFCwgAAwoRAiIGAQIBAAAAAQULCAADChECIgYBAgIAAAABBQsIAAMFCwYAAAMbAyMIaW5jaWRlbnQFCwQAACQGbm9ybWFsBQsEAAAlA2V0YQMEAAAFCwUDCCYFbmRvdGkDBAAACQMdDgICJAULAiMFCwMACCcBawMEAAAGAwEDAAAAAAAA8D8DBgEGAQIlAwIlAwMEBgMBAwAAAAAAAPA/AwYBAiYDAiYDAwMDAwMADQsGCQInAwEDAAAAAAAAAAADAgkDKQ4BAQMAAAAAAAAAAAMFCwYDBgECJQMCIwULBQsGAQQGAAYBAiUDAiYDAwkDDQ4BAicDAwMDAiQFCwULBQsFCwAAAhwAAAUBBgQCGAUMCQMqDgIGAQIPBQsJAzIOAQIJBwYFCwsGBwkDHQ4CAg8FCwIPBQsDAQMAAAAAAADgPwMCAQMAAAAAAADwPwMBAwAAAAAAAPC/AwMFDAUMAAAdAAAFAgYEAhEFCgYBAhAFCgIEAwUKBQoIKAhkaXJMaWdodAULBAAACQMpDgMBA4EmwoanV+K/AwEDjxmojH+f0T8DAQP8jAsHQrLovwMFCwAAAR4AAAURCCkIdGV4Q29sb3IFDAQAAAkDIQ4CAgEKAhEFCgUMAAgqCWJ1bXBDb2xvcgUMBAAACQMhDgICAgoCEQUKBQwACCsEbm9ybQULBAAACQMfDgEGAwYBCgIqBQySAAULAQMAAAAAAAAAQAMFCwEDAAAAAAAA8D8DBQsFCwAGgQoCKwULAAADAQMAAAAAAADwvwMDCCwHdmlld0RpcgULBAAACQMfDgEGAwIGBQsCFwULBQsFCwAGBAIrBQsJAx8OAQQGAQIrBQsJAzIOAQIJBwYFCwULBQsFCwgtC2ZyZXNuZWxCaWFzAwQAAAEDmpmZmZmZyT8DAAguCmZyZXNuZWxQb3cDBAAAAQPNzMzMzMz0PwMACC8MZnJlc25lbFNjYWxlAwQAAAEDAAAAAAAA8D8DAAgwC2ZyZXNuZWxUZXJtAwQAAAYAAi0DBgEGAQIvAwQGAwEDAAAAAAAA8D8DAi0DAwMDCQMIDgIGAwEDAAAAAAAA8D8DCQMWDgIJAx0OAgIsBQsCKwULAwEDAAAAAAAAAAADAwMCLgMDAwMACDELaW5jaWRlbnRSYXkFCwQAAAkDHw4BBgMCFwULAgYFCwULBQsACDINcmVmbGVjdGlvblJheQULBAAACQMgDgICMQULAisFCwULAAgzCnJlZnJhY3RWZWMFCwQAAAkCGw4DBwMCMQULBQsCKwULAQMAAAAAAADwPwMFCwAINAxyZWZsZWN0Q29sb3IFDAQAAAkDIQ4CAgMMAjIFCwUMAAg1DHJlZnJhY3RDb2xvcgUMBAAACQMhDgICAwwCMwULBQwACDYGb3V0Q29sBQwEAAAGAQkDGA4DAikFDAkDKg4BAQMAAAAAAADwPwMFDAEDAAAAAAAA0D8DBQwJAxgOAwI1BQwCNAUMAjADBQwFDAAGBAISBQwCNgUMBQwA";
src_DtsObject.sharedGraphNodesMap = new haxe_ds_StringMap();
var shapes_SuperJump_superJumpParticleOptions = { ejectionPeriod : 10, ambientVelocity : new h3d_Vector(0,0,0), ejectionVelocity : 1, velocityVariance : 0.25, emitterLifetime : 1000, inheritedVelFactor : 0.1, particleOptions : { texture : "particles/twirl.png", blending : h2d_BlendMode.Add, spinSpeed : 90, spinRandomMin : -90, spinRandomMax : 90, lifetime : 1000, lifetimeVariance : 150, dragCoefficient : 0.25, acceleration : 0, colors : [new h3d_Vector(0.38,0.38,0.38,0),new h3d_Vector(0.34,0.34,0.34,1),new h3d_Vector(0.3,0.3,0.3,0)], sizes : [0.25,0.25,0.5], times : [0,0.75,1]}};
var shapes_SuperSpeed_superSpeedParticleOptions = { ejectionPeriod : 5, ambientVelocity : new h3d_Vector(0,0,0), ejectionVelocity : 1, velocityVariance : 0.25, emitterLifetime : 1100, inheritedVelFactor : 0.25, particleOptions : { texture : "particles/smoke.png", blending : h2d_BlendMode.Add, spinSpeed : 0, spinRandomMin : 0, spinRandomMax : 0, lifetime : 1500, lifetimeVariance : 750, dragCoefficient : 4, acceleration : 0, colors : [new h3d_Vector(0.42,0.42,0.38,0.1),new h3d_Vector(0.34,0.34,0.34,0.1),new h3d_Vector(0.30,0.30,0.30,0.1)], sizes : [0.3,0.7,1.4], times : [0,0.5,1]}};
src_Analytics.umami = "https://analytics.randomityguy.me/api/send";
src_Debug.timeScale = 1.0;
src_Debug.wireFrame = false;
src_Debug.drawBounds = false;
src_Debug._triangles = [];
src_Debug._spheres = [];
src_ResourceLoader.interiorResources = new haxe_ds_StringMap();
src_ResourceLoader.dtsResources = new haxe_ds_StringMap();
src_ResourceLoader.textureCache = new haxe_ds_StringMap();
src_ResourceLoader.imageCache = new haxe_ds_StringMap();
src_ResourceLoader.audioCache = new haxe_ds_StringMap();
src_ResourceLoader.zipFilesystem = new haxe_ds_StringMap();
src_ResourceLoader.loadedFiles = new haxe_ds_StringMap();
src_ResourceLoader.initialized = false;
src_DifBuilder.difCache = new src_LRUCache_$src_$DifCache(24);
src_DifBuilder.materialDict = (function($this) {
	var $r;
	let _g = new haxe_ds_StringMap();
	_g.h["friction_none"] = { friction : 0.01, restitution : 0.5};
	_g.h["friction_low"] = { friction : 0.2, restitution : 0.5};
	_g.h["friction_low_shadow"] = { friction : 0.2, restitution : 0.5};
	_g.h["friction_high"] = { friction : 1.5, restitution : 0.5};
	_g.h["friction_ramp_yellow"] = { friction : 2.0, restitution : 1.0};
	_g.h["oilslick"] = { friction : 0.05, restitution : 0.5};
	_g.h["base.slick"] = { friction : 0.05, restitution : 0.5};
	_g.h["ice.slick"] = { friction : 0.05, restitution : 0.5};
	_g.h["grass"] = { friction : 1.5, restitution : 0.35};
	_g.h["ice1"] = { friction : 0.03, restitution : 0.95};
	_g.h["rug"] = { friction : 6.0, restitution : 0.5};
	_g.h["tarmac"] = { friction : 0.35, restitution : 0.7};
	_g.h["carpet"] = { friction : 6.0, restitution : 0.5};
	_g.h["sand"] = { friction : 4.0, restitution : 0.1};
	_g.h["water"] = { friction : 6.0, restitution : 0.0};
	_g.h["floor_bounce"] = { friction : 0.2, restitution : 0.0, force : 15};
	_g.h["mbp_chevron_friction"] = { friction : -1.0, restitution : 1.0};
	_g.h["mbp_chevron_friction2"] = { friction : -1.0, restitution : 1.0};
	_g.h["mbp_chevron_friction3"] = { friction : -1.0, restitution : 1.0};
	_g.h["mmg_grass"] = { friction : 0.9, restitution : 0.5};
	_g.h["mmg_sand"] = { friction : 6.0, restitution : 0.1};
	_g.h["mmg_water"] = { friction : 6.0, restitution : 0.0};
	_g.h["mmg_ice"] = { friction : 0.03, restitution : 0.95};
	_g.h["mmg_ice_shadow"] = { friction : 0.03, restitution : 0.95};
	_g.h["friction_mp_high"] = { friction : 6, restitution : 0.3};
	_g.h["friction_mp_high_shadow"] = { friction : 6, restitution : 0.3};
	_g.h["friction_high_shadow"] = { friction : 6, restitution : 0.3};
	_g.h["friction_bouncy"] = { friction : 0.2, restitution : 2.0, force : 15.0};
	$r = _g;
	return $r;
}(this));
src_DifBuilder.customMaterialDict = new haxe_ds_StringMap();
src_DifBuilder.shaderMaterialDict = (function($this) {
	var $r;
	let _g = new haxe_ds_StringMap();
	_g.h["plate_1"] = function(onFinish) {
		src_DifBuilder.createDefaultMaterial(onFinish,"data/textures/plate.randomize.png","data/textures/plate.normal.png",8,new h3d_Vector(1,1,0.8,1),1,true);
	};
	_g.h["plate_1_small"] = function(onFinish) {
		src_DifBuilder.createDefaultMaterial(onFinish,"data/textures/plate.randomize.png","data/textures/plate.normal.png",8,new h3d_Vector(1,1,0.8,1),1,false);
	};
	_g.h["tile_beginner"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_beginner.png","",40,new h3d_Vector(1,1,1,1));
	};
	_g.h["tile_beginner_shadow"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_beginner.png","_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2));
	};
	_g.h["tile_beginner_red"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_beginner.png","_red",40,new h3d_Vector(1,1,1,1));
	};
	_g.h["tile_beginner_red_shadow"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_beginner.png","_red_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2));
	};
	_g.h["tile_beginner_blue"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_beginner.png","_blue",40,new h3d_Vector(1,1,1,1));
	};
	_g.h["tile_beginner_blue_shadow"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_beginner.png","_blue_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2));
	};
	_g.h["tile_intermediate"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_intermediate.png","",40,new h3d_Vector(1,1,1,1));
	};
	_g.h["tile_intermediate_shadow"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_intermediate.png","_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2));
	};
	_g.h["tile_intermediate_red"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_intermediate.png","_red",40,new h3d_Vector(1,1,1,1));
	};
	_g.h["tile_intermediate_red_shadow"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_intermediate.png","_red_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2));
	};
	_g.h["tile_intermediate_green"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_intermediate.png","_green",40,new h3d_Vector(1,1,1,1));
	};
	_g.h["tile_intermediate_green_shadow"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_intermediate.png","_green_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2));
	};
	_g.h["tile_advanced"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_advanced.png","",40,new h3d_Vector(1,1,1,1));
	};
	_g.h["tile_advanced_shadow"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_advanced.png","_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2));
	};
	_g.h["tile_advanced_blue"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_advanced.png","_blue",40,new h3d_Vector(1,1,1,1));
	};
	_g.h["tile_advanced_blue_shadow"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_advanced.png","_blue_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2));
	};
	_g.h["tile_advanced_green"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_advanced.png","_green",40,new h3d_Vector(1,1,1,1));
	};
	_g.h["tile_advanced_green_shadow"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_advanced.png","_green_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2));
	};
	_g.h["tile_underside"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_underside.png","",40,new h3d_Vector(1,1,1,1));
	};
	_g.h["tile_beginner_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_beginner.png","",40,new h3d_Vector(1,1,1,1),4);
	};
	_g.h["tile_beginner_shadow_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_beginner.png","_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2),4);
	};
	_g.h["tile_beginner_red_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_beginner.png","_red",40,new h3d_Vector(1,1,1,1),4);
	};
	_g.h["tile_beginner_red_shadow_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_beginner.png","_red_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2),4);
	};
	_g.h["tile_beginner_blue_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_beginner.png","_blue",40,new h3d_Vector(1,1,1,1),4);
	};
	_g.h["tile_beginner_blue_shadow_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_beginner.png","_blue_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2),4);
	};
	_g.h["tile_intermediate_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_intermediate.png","",40,new h3d_Vector(1,1,1,1),4);
	};
	_g.h["tile_intermediate_shadow_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_intermediate.png","_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2),4);
	};
	_g.h["tile_intermediate_red_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_intermediate.png","_red",40,new h3d_Vector(1,1,1,1),4);
	};
	_g.h["tile_intermediate_red_shadow_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_intermediate.png","_red_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2),4);
	};
	_g.h["tile_intermediate_green_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_intermediate.png","_green",40,new h3d_Vector(1,1,1,1),4);
	};
	_g.h["tile_intermediate_green_shadow_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_intermediate.png","_green_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2),4);
	};
	_g.h["tile_advanced_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_advanced.png","",40,new h3d_Vector(1,1,1,1),4);
	};
	_g.h["tile_advanced_shadow_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_advanced.png","_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2),4);
	};
	_g.h["tile_advanced_blue_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_advanced.png","_blue",40,new h3d_Vector(1,1,1,1),4);
	};
	_g.h["tile_advanced_blue_shadow_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_advanced.png","_blue_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2),4);
	};
	_g.h["tile_advanced_green_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_advanced.png","_green",40,new h3d_Vector(1,1,1,1),4);
	};
	_g.h["tile_advanced_green_shadow_4x4"] = function(onFinish) {
		src_DifBuilder.createNoiseTileMaterial(onFinish,"tile_advanced.png","_green_shadow",40,new h3d_Vector(0.2,0.2,0.2,0.2),4);
	};
	_g.h["wall_beginner"] = function(onFinish) {
		src_DifBuilder.createDefaultNormalMaterial(onFinish,"data/textures/wall_beginner.png",12,new h3d_Vector(0.8,0.8,0.6,1));
	};
	_g.h["edge_white"] = function(onFinish) {
		src_DifBuilder.createDefaultMaterial(onFinish,"data/textures/edge_white.png","data/textures/edge.normal.png",50,new h3d_Vector(0.8,0.8,0.8,1));
	};
	_g.h["edge_white_shadow"] = function(onFinish) {
		src_DifBuilder.createDefaultMaterial(onFinish,"data/textures/edge_white_shadow.png","data/textures/edge.normal.png",50,new h3d_Vector(0.2,0.2,0.2,0.2));
	};
	_g.h["beam"] = function(onFinish) {
		src_DifBuilder.createDefaultMaterial(onFinish,"data/textures/beam.png","data/textures/beam.normal.png",12,new h3d_Vector(0.8,0.8,0.6,1));
	};
	_g.h["beam_side"] = function(onFinish) {
		src_DifBuilder.createDefaultMaterial(onFinish,"data/textures/beam_side.png","data/textures/beam_side.normal.png",12,new h3d_Vector(0.8,0.8,0.6,1));
	};
	_g.h["friction_low"] = function(onFinish) {
		src_DifBuilder.createDefaultCubemapMaterial(onFinish,"data/textures/friction_low.png","data/textures/friction_low.normal.png",128,new h3d_Vector(1,1,1,0.8));
	};
	_g.h["friction_low_shadow"] = function(onFinish) {
		src_DifBuilder.createDefaultCubemapMaterial(onFinish,"data/textures/friction_low_shadow.png","data/textures/friction_low.normal.png",128,new h3d_Vector(0.3,0.3,0.35,1));
	};
	_g.h["friction_high"] = function(onFinish) {
		src_DifBuilder.createDefaultMaterial(onFinish,"data/textures/friction_high.png","data/textures/friction_high.normal.png",10,new h3d_Vector(0.3,0.3,0.35,1));
	};
	_g.h["friction_high_shadow"] = function(onFinish) {
		src_DifBuilder.createDefaultMaterial(onFinish,"data/textures/friction_high_shadow.png","data/textures/friction_high.normal.png",10,new h3d_Vector(0.15,0.15,0.16,1.0));
	};
	_g.h["friction_bouncy"] = function(onFinish) {
		src_DifBuilder.createDefaultNormalMaterial(onFinish,"data/textures/friction_bouncy.png",8,new h3d_Vector(0.4,0.4,0.2,1));
	};
	_g.h["stripe_caution"] = function(onFinish) {
		src_DifBuilder.createDefaultNormalMaterial(onFinish,"data/textures/stripe_caution.png",12,new h3d_Vector(0.8,0.8,0.6,1));
	};
	$r = _g;
	return $r;
}(this));
var src_DtsObject_DROP_TEXTURE_FOR_ENV_MAP = ["shapes/items/superjump.dts","shapes/items/antigravity.dts"];
var src_DtsObject_dtsMaterials = (function($this) {
	var $r;
	let _g = new haxe_ds_StringMap();
	_g.h["oilslick"] = { friction : 0.05, restitution : 0.5, force : 0.0};
	_g.h["base.slick"] = { friction : 0.05, restitution : 0.5, force : 0.0};
	_g.h["ice.slick"] = { friction : 0.05, restitution : 0.5, force : 0.0};
	_g.h["bumper-rubber"] = { friction : 0.5, restitution : 0.0, force : 15.0};
	_g.h["triang-side"] = { friction : 0.5, restitution : 0.0, force : 15.0};
	_g.h["triang-top"] = { friction : 0.5, restitution : 0.0, force : 15.0};
	_g.h["bumper"] = { friction : 0.5, restitution : 0.0, force : 15.0};
	_g.h["pball-round-top"] = { friction : 0.5, restitution : 0.0, force : 15.0};
	_g.h["pball-round-bottm"] = { friction : 0.5, restitution : 0.0, force : 15.0};
	$r = _g;
	return $r;
}(this));
src_Gamepad.gamepad = hxd_Pad.createDummy();
src_InstanceManager.render_tmpBounds = new h3d_col_Bounds();
src_Leaderboards.host = "https://lb.randomityguy.me";
src_Leaderboards.game = "Ultra";
src_Marble.updateFinishAnimation_animTimeAccumulator = 0.0;
var src_Marble_bounceParticleOptions = { ejectionPeriod : 5, ambientVelocity : new h3d_Vector(0,0,0.0), ejectionVelocity : 6, velocityVariance : 0.25, emitterLifetime : 50, inheritedVelFactor : 0, particleOptions : { texture : "particles/burst.png", blending : h2d_BlendMode.Add, spinSpeed : 90, spinRandomMin : -90, spinRandomMax : 90, lifetime : 400, lifetimeVariance : 50, dragCoefficient : 0, acceleration : -2, colors : [new h3d_Vector(0.5,0.5,0.5,0.6),new h3d_Vector(0.3,0.3,0.2,0.4),new h3d_Vector(0.2,0.2,0.1,0)], sizes : [0.8,0.4,0.2], times : [0,0.75,1]}};
src_MarbleGame.currentVersion = "1.2.2";
src_Scheduler._hx_skip_constructor = false;
src_Marbleland.missions = new haxe_ds_IntMap();
src_MeshBatch.modelViewID = hxsl_Globals.allocID("global.modelView");
src_MeshBatch.modelViewTransposeID = hxsl_Globals.allocID("global.modelViewTranspose");
src_MeshBatch.modelViewInverseID = hxsl_Globals.allocID("global.modelViewInverse");
src_MeshBatch.MAX_BUFFER_ELEMENTS = 4096;
src_MissionList._build = false;
src_ProfilerUI.updateNetworkStats_lastSentMove = 0;
src_ProfilerUI.enabled = false;
src_ProfilerUI.mode = 0;
src_Renderer.bloomPass_kernelComputed = false;
src_Renderer.bloomPass_kernelY = [];
src_Renderer.bloomPass_kernelX = [];
src_Renderer.bloomPass_divisor = 0.0;
src_Renderer.bloomPass_divisors = [0.1,0.3,0.4,0.5,0.6,0.7,1.0,0.7,0.5,0.5,0.4,0.3,0.1];
src_Renderer.bloomPass_offsets = [-7.5,-6.25,-5,-3.75,-2.5,-1.25,0,1.25,2.5,3.75,5,6.25,7.5];
src_Renderer.dirtyBuffers = true;
src_Renderer.pixelRatio = 1;
src_Renderer.cubemapPass = false;
src_Settings.highScores = new haxe_ds_StringMap();
src_Settings.easterEggs = new haxe_ds_StringMap();
src_Settings.optionsSettings = { screenWidth : 1280, screenHeight : 720, isFullScreen : false, videoDriver : 0, colorDepth : 1, shadows : false, musicVolume : 1, soundVolume : 0.7, fovX : 90, frameRateVis : false, oobInsults : true, marbleIndex : 0, marbleCategoryIndex : 0, marbleSkin : "base", marbleModel : "data/shapes/balls/marble01.dts", marbleShader : "ClassicGlassPureSphere", rewindEnabled : false, rewindTimescale : 1, reflectionDetail : 2, maxPixelRatio : 1, vsync : false, huntRandom : false, fastLoad : false};
src_Settings.controlsSettings = { forward : 87, backward : 83, left : 65, right : 68, camForward : 38, camBackward : 40, camLeft : 37, camRight : 39, jump : 32, powerup : 0, freelook : 2, alwaysFreeLook : true, controllerVerticalCenter : true, cameraSensitivity : 0.6, invertYAxis : false, respawn : 8, blast : 1, rewind : 82, chat : 84, oobRespawnKeyByPowerup : false, moddedController : false};
src_Settings.touchSettings = { joystickPos : [100,40], joystickSize : 50, jumpButtonPos : [440,320], jumpButtonSize : 60, powerupButtonPos : [440,180], powerupButtonSize : 60, blastButtonPos : [300,240], blastButtonSize : 60, rewindButtonPos : [300,100], rewindButtonSize : 60, buttonJoystickMultiplier : 2.5, hideControls : false, dynamicJoystick : false, cameraSwipeExtent : 10.0};
src_Settings.gamepadSettings = { moveXAxis : "analogX", moveYAxis : "analogY", cameraXAxis : "ranalogX", cameraYAxis : "ranalogY", jump : ["A","LT"], powerup : ["B","RT"], cameraSensitivity : 1.0, invertXAxis : false, invertYAxis : false, axisDeadzone : 0.15, respawn : ["back"], blast : ["X","LB","RB"], rewind : ["Y"]};
src_Settings.playStatistics = { oobs : 0, respawns : 0, totalTime : 0, totalMPScore : 0};
src_Settings.levelStatistics = new haxe_ds_StringMap();
src_Settings.highscoreName = "Player";
src_Settings.userId = "";
src_Settings.uiScale = 1.0;
src_Settings.zoomRatio = 1.0;
src_Settings.isTouch = haxe_ds_Option.None;
src_Sky.cubemapTextureCache = new haxe_ds_StringMap();
stb_format_vorbis_VorbisTools.INVERSE_DB_TABLE = [1.0649863e-07,1.1341951e-07,1.2079015e-07,1.2863978e-07,1.3699951e-07,1.4590251e-07,1.5538408e-07,1.6548181e-07,1.7623575e-07,1.8768855e-07,1.9988561e-07,2.1287530e-07,2.2670913e-07,2.4144197e-07,2.5713223e-07,2.7384213e-07,2.9163793e-07,3.1059021e-07,3.3077411e-07,3.5226968e-07,3.7516214e-07,3.9954229e-07,4.2550680e-07,4.5315863e-07,4.8260743e-07,5.1396998e-07,5.4737065e-07,5.8294187e-07,6.2082472e-07,6.6116941e-07,7.0413592e-07,7.4989464e-07,7.9862701e-07,8.5052630e-07,9.0579828e-07,9.6466216e-07,1.0273513e-06,1.0941144e-06,1.1652161e-06,1.2409384e-06,1.3215816e-06,1.4074654e-06,1.4989305e-06,1.5963394e-06,1.7000785e-06,1.8105592e-06,1.9282195e-06,2.0535261e-06,2.1869758e-06,2.3290978e-06,2.4804557e-06,2.6416497e-06,2.8133190e-06,2.9961443e-06,3.1908506e-06,3.3982101e-06,3.6190449e-06,3.8542308e-06,4.1047004e-06,4.3714470e-06,4.6555282e-06,4.9580707e-06,5.2802740e-06,5.6234160e-06,5.9888572e-06,6.3780469e-06,6.7925283e-06,7.2339451e-06,7.7040476e-06,8.2047000e-06,8.7378876e-06,9.3057248e-06,9.9104632e-06,1.0554501e-05,1.1240392e-05,1.1970856e-05,1.2748789e-05,1.3577278e-05,1.4459606e-05,1.5399272e-05,1.6400004e-05,1.7465768e-05,1.8600792e-05,1.9809576e-05,2.1096914e-05,2.2467911e-05,2.3928002e-05,2.5482978e-05,2.7139006e-05,2.8902651e-05,3.0780908e-05,3.2781225e-05,3.4911534e-05,3.7180282e-05,3.9596466e-05,4.2169667e-05,4.4910090e-05,4.7828601e-05,5.0936773e-05,5.4246931e-05,5.7772202e-05,6.1526565e-05,6.5524908e-05,6.9783085e-05,7.4317983e-05,7.9147585e-05,8.4291040e-05,8.9768747e-05,9.5602426e-05,0.00010181521,0.00010843174,0.00011547824,0.00012298267,0.00013097477,0.00013948625,0.00014855085,0.00015820453,0.00016848555,0.00017943469,0.00019109536,0.00020351382,0.00021673929,0.00023082423,0.00024582449,0.00026179955,0.00027881276,0.00029693158,0.00031622787,0.00033677814,0.00035866388,0.00038197188,0.00040679456,0.00043323036,0.00046138411,0.00049136745,0.00052329927,0.00055730621,0.00059352311,0.00063209358,0.00067317058,0.00071691700,0.00076350630,0.00081312324,0.00086596457,0.00092223983,0.00098217216,0.0010459992,0.0011139742,0.0011863665,0.0012634633,0.0013455702,0.0014330129,0.0015261382,0.0016253153,0.0017309374,0.0018434235,0.0019632195,0.0020908006,0.0022266726,0.0023713743,0.0025254795,0.0026895994,0.0028643847,0.0030505286,0.0032487691,0.0034598925,0.0036847358,0.0039241906,0.0041792066,0.0044507950,0.0047400328,0.0050480668,0.0053761186,0.0057254891,0.0060975636,0.0064938176,0.0069158225,0.0073652516,0.0078438871,0.0083536271,0.0088964928,0.009474637,0.010090352,0.010746080,0.011444421,0.012188144,0.012980198,0.013823725,0.014722068,0.015678791,0.016697687,0.017782797,0.018938423,0.020169149,0.021479854,0.022875735,0.024362330,0.025945531,0.027631618,0.029427276,0.031339626,0.033376252,0.035545228,0.037855157,0.040315199,0.042935108,0.045725273,0.048696758,0.051861348,0.055231591,0.058820850,0.062643361,0.066714279,0.071049749,0.075666962,0.080584227,0.085821044,0.091398179,0.097337747,0.10366330,0.11039993,0.11757434,0.12521498,0.13335215,0.14201813,0.15124727,0.16107617,0.17154380,0.18269168,0.19456402,0.20720788,0.22067342,0.23501402,0.25028656,0.26655159,0.28387361,0.30232132,0.32196786,0.34289114,0.36517414,0.38890521,0.41417847,0.44109412,0.46975890,0.50028648,0.53279791,0.56742212,0.60429640,0.64356699,0.68538959,0.72993007,0.77736504,0.82788260,0.88168307,0.9389798,1.0];
{
	Main.main();
	haxe_EntryPoint.run();
}
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=marblegame.js.map